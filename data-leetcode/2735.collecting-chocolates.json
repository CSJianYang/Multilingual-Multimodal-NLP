[
    {
        "title": "Minimize the Total Price of the Trips",
        "question_content": "There exists an undirected and unrooted tree with n nodes indexed from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nEach node has an associated price. You are given an integer array price, where price[i] is the price of the ith node.\nThe price sum of a given path is the sum of the prices of all nodes lying on that path.\nAdditionally, you are given a 2D integer array trips, where trips[i] = [starti, endi] indicates that you start the ith trip from the node starti and travel to the node endi by any path you like.\nBefore performing your first trip, you can choose some non-adjacent nodes and halve the prices.\nReturn the minimum total price sum to perform all the given trips.\n&nbsp;\nExample 1:\n\nInput: n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]\nOutput: 23\nExplanation: The diagram above denotes the tree after rooting it at node 2. The first part shows the initial tree and the second part shows the tree after choosing nodes 0, 2, and 3, and making their price half.\nFor the 1st trip, we choose path [0,1,3]. The price sum of that path is 1 + 2 + 3 = 6.\nFor the 2nd trip, we choose path [2,1]. The price sum of that path is 2 + 5 = 7.\nFor the 3rd trip, we choose path [2,1,3]. The price sum of that path is 5 + 2 + 3 = 10.\nThe total price sum of all trips is 6 + 7 + 10 = 23.\nIt can be proven, that 23 is the minimum answer that we can achieve.\n\nExample 2:\n\nInput: n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]\nOutput: 1\nExplanation: The diagram above denotes the tree after rooting it at node 0. The first part shows the initial tree and the second part shows the tree after choosing node 0, and making its price half.\nFor the 1st trip, we choose path [0]. The price sum of that path is 1.\nThe total price sum of all trips is 1. It can be proven, that 1 is the minimum answer that we can achieve.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 50\n\tedges.length == n - 1\n\t0 <= ai, bi <= n - 1\n\tedges represents a valid tree.\n\tprice.length == n\n\tprice[i] is an even integer.\n\t1 <= price[i] <= 1000\n\t1 <= trips.length <= 100\n\t0 <= starti, endi&nbsp;<= n - 1",
        "solutions": [
            {
                "id": 3421713,
                "title": "dfs-dp-explained-easy-why-bipartite-set-fails-video-solution",
                "content": "# Intuition\\nWill try to explain the logic in a way I myself came up with the final solution. \\n\\nQ. Can we convert the trips array to some other form such that I could directly compute the answer in a single traversal?\\nA. YES! Let\\u2019s try each trip and note down the number of times a node appears [let\\u2019s call this contribution of that node]\\n\\n\\nQ. Can I make a bipartite graph to solve this problem by using those nodes which would contribute the most? \\nA. No! It is not necessary that for every node which isn\\'t included you are bound to use the child of the same. For example a node P has 2 children A and B, A further has 1 child C. Let\\'s say the optimal solution is to halve B and C. If you use bipartite approach here then the graph is divided into {P,C} and {A,B} so you\\'re gonna halve either P&C or A&B which are not gonna be optimal. \\n\\nQ. What would be the brute way to solve this? \\nA. For each node there would be 2 possibilities i.e. to halve the price of that node vs not halving the price [although this would depend on the value of the parent], asymptotically we can say that trying for all the options would give us a TC of 2^n.\\n\\nQ. can I use DP to reduce the TC? \\nA. YES! Let\\u2019s say we mark any random node R as the root, now from this node R we can try to traverse the tree and we already would know the contribution of each node [from our last question], however now the problem is that a node can either be halved or could remain as it is. Let\\u2019s try for both possibilities! \\nIn the dfs call, I can use a flag for indicating if the value of the parent was set or not. On reaching on a node in this dfs call I could either have the total contribution of this node as [num of times this node appears in trip]\\\\*[score of this node] OR num of times this node appears in trip]\\\\*[score of this node]/2. \\nSince I have already rooted the tree hence for each node I can save the states. It would only require 2 variables to define the state of any node i.e. the node itself and whether it\\u2019s parent was set. Since the number of nodes are <=50. Hence the space at TC would also be limited to 50*2. Which is a small number. \\nThe code is self explanatory and have also provided a video solution for reference! \\nCheck the video solution: https://youtu.be/lHffgybzmWo\\nHappy coding!\\n\\n# Complexity\\n- Time complexity:\\nO(n*t)  where t is the number of trips and n is the number of nodes\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void makeContri(int node,vector<int>& curr,vector<int>& contri,int end,vector<vector<int>>& g,int p){\\n        curr.push_back(node);       //this node is present in the traversal\\n        if(end==node){              //we reached the required end node! \\n            for(auto& i:curr)   contri[i]++;   \\n            curr.pop_back();\\n            return;\\n        }\\n        for(auto& ch:g[node])   if(ch!=p)    makeContri(ch,curr,contri,end,g,node);\\n        curr.pop_back();        // pop the current node. \\n    }\\n    int dp[51][2];      // dp[i][j] for the ith node if it\\'s parent was halved or not! \\n    int dfs(vector<int>& contri,vector<int>& pr,int node,vector<vector<int>>& g,int p=-1,bool parentHalved=false){\\n        int res1=(contri[node]*pr[node])/2,res2=contri[node]*pr[node];\\n        \\n        if(dp[node][parentHalved]!=-1)   return dp[node][parentHalved];\\n        \\n        for(auto& ch:g[node])   if(ch!=p)   res2+=dfs(contri,pr,ch,g,node,0);\\n        if(parentHalved) return dp[node][parentHalved]=res2;      // can\\'t halve this node if parent was halved!\\n        \\n        for(auto& ch:g[node])   if(ch!=p)    res1+=dfs(contri,pr,ch,g,node,1);\\n        return dp[node][parentHalved]=min(res1,res2);\\n    }\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> g(n);\\n        memset(dp,-1,sizeof dp);\\n        for(auto& e:edges){\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        vector<int> contri(n,0);        // number of times each node is traversed\\n        for(auto& t:trips){\\n            vector<int> curr;\\n            makeContri(t[0],curr,contri,t[1],g,-1);\\n        }// contribution of each node has been stored! \\n        \\n        return dfs(contri,price,0,g,-1,0);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void makeContri(int node,vector<int>& curr,vector<int>& contri,int end,vector<vector<int>>& g,int p){\\n        curr.push_back(node);       //this node is present in the traversal\\n        if(end==node){              //we reached the required end node! \\n            for(auto& i:curr)   contri[i]++;   \\n            curr.pop_back();\\n            return;\\n        }\\n        for(auto& ch:g[node])   if(ch!=p)    makeContri(ch,curr,contri,end,g,node);\\n        curr.pop_back();        // pop the current node. \\n    }\\n    int dp[51][2];      // dp[i][j] for the ith node if it\\'s parent was halved or not! \\n    int dfs(vector<int>& contri,vector<int>& pr,int node,vector<vector<int>>& g,int p=-1,bool parentHalved=false){\\n        int res1=(contri[node]*pr[node])/2,res2=contri[node]*pr[node];\\n        \\n        if(dp[node][parentHalved]!=-1)   return dp[node][parentHalved];\\n        \\n        for(auto& ch:g[node])   if(ch!=p)   res2+=dfs(contri,pr,ch,g,node,0);\\n        if(parentHalved) return dp[node][parentHalved]=res2;      // can\\'t halve this node if parent was halved!\\n        \\n        for(auto& ch:g[node])   if(ch!=p)    res1+=dfs(contri,pr,ch,g,node,1);\\n        return dp[node][parentHalved]=min(res1,res2);\\n    }\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> g(n);\\n        memset(dp,-1,sizeof dp);\\n        for(auto& e:edges){\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        vector<int> contri(n,0);        // number of times each node is traversed\\n        for(auto& t:trips){\\n            vector<int> curr;\\n            makeContri(t[0],curr,contri,t[1],g,-1);\\n        }// contribution of each node has been stored! \\n        \\n        return dfs(contri,price,0,g,-1,0);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421674,
                "title": "python3-dfs-dp-with-comments",
                "content": "Since it is a tree, there are no cycles, and for any (start, end) pair in trips, there is only one path. So we compute all paths first, and keep counting how many times each single node has been used/visited.\\n\\nTo find the maximum cost we can reduce, we can use dp to check which is the optimal combination of reducing the node cost to half.\\n\\n```python\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n    \\t# Creating the undirected graph\\n        graph = defaultdict(list)\\n        for a,b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        # Use this counter to count how many time each node are used for all paths.\\n        count = Counter()\\n        # The totalCost if we don\\'t reduce any node cost to half\\n        totalCost = 0\\n        # dfs to find the path from start node to end node.\\n        # Add the cost to total cost for each node on the path.\\n        # Also keep counting how many times each node are used for all paths in trips.\\n        # Since it is an undirected tree, even though there are no cycles, we can still travel back from the parent node. So keep the parent to avoid going backward of the tree.\\n        def dfs(node,par,end):\\n            nonlocal count\\n            nonlocal totalCost\\n            if node == end:\\n                return True\\n            \\n            for nei in graph[node]:\\n                if nei != par:\\n                    if dfs(nei, node, end):\\n                        count[nei] += 1\\n                        totalCost += price[nei]\\n                        return True\\n            return False\\n\\n        # For each trip, we compute the path and update the totalCost, and count how many times each node is being used. \\n        for start,end in trips:\\n            count[start] += 1\\n            totalCost += price[start]\\n            dfs(start,None,end)\\n        \\n        # The dp function to find the optimal combination of which node should be reduced.\\n        @cache\\n        def dp(node, par, canReduce):\\n            if canReduce:\\n                res = (price[node]//2)*count[node]\\n            else:\\n                res = 0\\n            red = 0\\n            for nei in graph[node]:\\n                if nei != par:\\n                \\t# if the cost of the current node can be reduced, we have only one option moving forward => do not reduce\\n                    if canReduce:\\n                        cur = dp(nei, node, False)\\n                    # if the cost of the current node can not be reduced, we have two options, either reduce it for the neighbor node or don\\'t reduce it for the neighbor node.\\n                    else:\\n                        cur = max(dp(nei, node, False), dp(nei, node, True))\\n                    red += cur\\n            return res + red\\n        \\n        # We find the maximum reduction using the dp function.\\n        reduce = 0\\n        for i in range(n):\\n            reduce = max( reduce, dp(i, None, True), dp(i, None, False) )\\n        \\n        # reduce the total cost\\n        return totalCost - reduce\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n    \\t# Creating the undirected graph\\n        graph = defaultdict(list)\\n        for a,b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        # Use this counter to count how many time each node are used for all paths.\\n        count = Counter()\\n        # The totalCost if we don\\'t reduce any node cost to half\\n        totalCost = 0\\n        # dfs to find the path from start node to end node.\\n        # Add the cost to total cost for each node on the path.\\n        # Also keep counting how many times each node are used for all paths in trips.\\n        # Since it is an undirected tree, even though there are no cycles, we can still travel back from the parent node. So keep the parent to avoid going backward of the tree.\\n        def dfs(node,par,end):\\n            nonlocal count\\n            nonlocal totalCost\\n            if node == end:\\n                return True\\n            \\n            for nei in graph[node]:\\n                if nei != par:\\n                    if dfs(nei, node, end):\\n                        count[nei] += 1\\n                        totalCost += price[nei]\\n                        return True\\n            return False\\n\\n        # For each trip, we compute the path and update the totalCost, and count how many times each node is being used. \\n        for start,end in trips:\\n            count[start] += 1\\n            totalCost += price[start]\\n            dfs(start,None,end)\\n        \\n        # The dp function to find the optimal combination of which node should be reduced.\\n        @cache\\n        def dp(node, par, canReduce):\\n            if canReduce:\\n                res = (price[node]//2)*count[node]\\n            else:\\n                res = 0\\n            red = 0\\n            for nei in graph[node]:\\n                if nei != par:\\n                \\t# if the cost of the current node can be reduced, we have only one option moving forward => do not reduce\\n                    if canReduce:\\n                        cur = dp(nei, node, False)\\n                    # if the cost of the current node can not be reduced, we have two options, either reduce it for the neighbor node or don\\'t reduce it for the neighbor node.\\n                    else:\\n                        cur = max(dp(nei, node, False), dp(nei, node, True))\\n                    red += cur\\n            return res + red\\n        \\n        # We find the maximum reduction using the dp function.\\n        reduce = 0\\n        for i in range(n):\\n            reduce = max( reduce, dp(i, None, True), dp(i, None, False) )\\n        \\n        # reduce the total cost\\n        return totalCost - reduce\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421847,
                "title": "c-dfs-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEach node is involved in some trip(0 or more times), In order to get minimum sum we need a count of the times a node will be visited in all trips. Halving the price for current node will disable halving of its adjecents. Need to consider these points while finding Minimum Path Sum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nModification of minimum/maximum no-adjecent sum path in Tree\\n\\n# Complexity\\n- Time complexity: \\n$$O(N)$$ (Since number of trips are constant (i.e. 100)) --> 100 * N --> N\\n\\n- Space complexity:\\n$$O(N)$$\\n\\n# Code\\n```\\n// Approach: DFS\\n// Modification of minimum/maximum no-adjecent sum path in Tree\\n\\nclass Solution {\\npublic:\\n    int demand[100];\\n    vector<int> adj[100];\\n\\n    // fill demand in terms of how many times current node will be vistited in all trips\\n    int isInPath(int u,int dest,int p = -1){\\n\\n        if(u == dest) {\\n            demand[dest]++;\\n            return 1;\\n        }\\n        for(auto v: adj[u]) {\\n            if(v == p) continue;\\n\\n            if(isInPath(v,dest,u)) {\\n                demand[u]++;\\n                return 1;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n    // Pair represents: minimum sum with {current Node halved, current node not halved}\\n    // Observations: If you halve the current node then you cannot halve its adjcent)\\n    pair<int,int> minNonAdjecentPath(int u,int p, vector<int>& price) {\\n        int considerCurrent = (price[u]/2) * (demand[u])   ;\\n        int dontConsiderCurrent = price[u] * demand[u];\\n\\n        for(auto v: adj[u]){\\n            if(v == p)continue;\\n\\n            pair<int,int> childAns = minNonAdjecentPath(v,u,price);\\n            // Take minimum of both consider and not consider case of childs\\n            dontConsiderCurrent += min(childAns.first, childAns.second);\\n\\n            // You can only take values where child node is not halved\\n            considerCurrent += childAns.second;\\n        }\\n        // return current answer\\n        return {considerCurrent, dontConsiderCurrent};\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        // cleanup\\n        memset(demand,0, sizeof demand);\\n        for(int i=0;i<n;i++){\\n            adj[i].clear();\\n        }\\n\\n        // graph formation\\n        for(auto edge: edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n\\n        // fill demand for nodes\\n        for(auto trip: trips) {\\n            int u = trip[0];\\n            int v = trip[1];\\n\\n            isInPath(u,v);\\n        }\\n\\n\\n        pair<int,int> ans = minNonAdjecentPath(0,-1,price);\\n\\n        return min(ans.first, ans.second);\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Approach: DFS\\n// Modification of minimum/maximum no-adjecent sum path in Tree\\n\\nclass Solution {\\npublic:\\n    int demand[100];\\n    vector<int> adj[100];\\n\\n    // fill demand in terms of how many times current node will be vistited in all trips\\n    int isInPath(int u,int dest,int p = -1){\\n\\n        if(u == dest) {\\n            demand[dest]++;\\n            return 1;\\n        }\\n        for(auto v: adj[u]) {\\n            if(v == p) continue;\\n\\n            if(isInPath(v,dest,u)) {\\n                demand[u]++;\\n                return 1;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n    // Pair represents: minimum sum with {current Node halved, current node not halved}\\n    // Observations: If you halve the current node then you cannot halve its adjcent)\\n    pair<int,int> minNonAdjecentPath(int u,int p, vector<int>& price) {\\n        int considerCurrent = (price[u]/2) * (demand[u])   ;\\n        int dontConsiderCurrent = price[u] * demand[u];\\n\\n        for(auto v: adj[u]){\\n            if(v == p)continue;\\n\\n            pair<int,int> childAns = minNonAdjecentPath(v,u,price);\\n            // Take minimum of both consider and not consider case of childs\\n            dontConsiderCurrent += min(childAns.first, childAns.second);\\n\\n            // You can only take values where child node is not halved\\n            considerCurrent += childAns.second;\\n        }\\n        // return current answer\\n        return {considerCurrent, dontConsiderCurrent};\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        // cleanup\\n        memset(demand,0, sizeof demand);\\n        for(int i=0;i<n;i++){\\n            adj[i].clear();\\n        }\\n\\n        // graph formation\\n        for(auto edge: edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n\\n        // fill demand for nodes\\n        for(auto trip: trips) {\\n            int u = trip[0];\\n            int v = trip[1];\\n\\n            isInPath(u,v);\\n        }\\n\\n\\n        pair<int,int> ans = minNonAdjecentPath(0,-1,price);\\n\\n        return min(ans.first, ans.second);\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422359,
                "title": "c-dfs-dp-with-intuition-and-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere in this question, doing bipartite algo on the tree will not work because, we are not forced to take alternative nodes means if we have taken the node at level x then at level x + 1 we can not take the node, but at level x + 2 we have two choice whether we take the node and not take the node. (Here take and not take means divide and not divide). \\n\\nBecuase of this many participants solution was failing on some testcase whose expected output was 429 but using bipartite algo on it, it was giving 434. So let\\'s move to the original approach which is dp.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncount how many time each node appears throughout the whole trip arrays and make the global array `cnt` which keeps track of the frequency of all the node in all the trips.\\n\\nExamle: For test case 1 of the question `cnt` array will look like `[1,3,2,2].`\\n\\nNow apply dynamic programming on the tree.\\nFor the dp we have two states, 1. current node, 2. current node\\'s parent was taken or not (means parent\\'s values was divided or not)\\n\\nThere are two cases based on the parent taken or not.\\n1. if parent is taken, then we can not take any child of it.\\n2. if parent is not taken, then we can or can not take any child of it. (because either of it can give the best answer possible)\\n\\nThis is it.. Now what left is the implementation of the problem.\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    bool process(int node, int par, int dst, vector<int> &count, vector<int> adj[])\\n    {\\n        if (node == dst)\\n            return true;\\n        for (auto i : adj[node])\\n        {\\n            if (i != par)\\n            {\\n                if (process(i, node, dst, count, adj))\\n                {\\n                    count[i]++;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int dp[51][2];\\n    int dfs(int node, int par, bool par_taken, vector<int> &cnt, vector<int> &price, vector<int> adj[])\\n    {\\n        if (dp[node][par_taken] != -1)\\n            return dp[node][par_taken];\\n\\n        int childs = 0;\\n        for (auto i : adj[node])\\n            if (i != par)\\n                childs++;\\n\\n        if (childs == 0)\\n        {\\n            if (par_taken)\\n                return dp[node][par_taken] = cnt[node] * (price[node]);\\n            return dp[node][par_taken] = cnt[node] * (price[node] / 2);\\n        }\\n\\n        if (par_taken)\\n        {\\n            int ans = 0;\\n            for (auto i : adj[node])\\n                if (i != par)\\n                    ans += dfs(i, node, false, cnt, price, adj);\\n            ans += cnt[node] * price[node];\\n            return dp[node][par_taken] = ans;\\n        }\\n\\n        int ans1 = 0;\\n        int ans2 = 0;\\n        for (auto i : adj[node])\\n        {\\n            if (i != par)\\n            {\\n                ans1 += dfs(i, node, false, cnt, price, adj);\\n                ans2 += dfs(i, node, true, cnt, price, adj);\\n            }\\n        }\\n        ans1 += cnt[node] * (price[node]);\\n        ans2 += cnt[node] * (price[node] / 2);\\n        return dp[node][par_taken] = min(ans1, ans2);\\n    }\\n\\n    int minimumTotalPrice(int n, vector<vector<int>> &edges, vector<int> &price, vector<vector<int>> &trips)\\n    {\\n        memset(dp, -1, sizeof(dp));\\n        vector<int> adj[n];\\n        for (auto i : edges)\\n        {\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n\\n        vector<int> cnt(n);\\n        for (auto i : trips)\\n        {\\n            cnt[i[0]]++;\\n            process(i[0], -1, i[1], cnt, adj);\\n        }\\n\\n        return dfs(0, -1, false, cnt, price, adj);\\n    }\\n};\\n```\\n\\n### Please upvote if you understood and found it to be helpful.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool process(int node, int par, int dst, vector<int> &count, vector<int> adj[])\\n    {\\n        if (node == dst)\\n            return true;\\n        for (auto i : adj[node])\\n        {\\n            if (i != par)\\n            {\\n                if (process(i, node, dst, count, adj))\\n                {\\n                    count[i]++;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int dp[51][2];\\n    int dfs(int node, int par, bool par_taken, vector<int> &cnt, vector<int> &price, vector<int> adj[])\\n    {\\n        if (dp[node][par_taken] != -1)\\n            return dp[node][par_taken];\\n\\n        int childs = 0;\\n        for (auto i : adj[node])\\n            if (i != par)\\n                childs++;\\n\\n        if (childs == 0)\\n        {\\n            if (par_taken)\\n                return dp[node][par_taken] = cnt[node] * (price[node]);\\n            return dp[node][par_taken] = cnt[node] * (price[node] / 2);\\n        }\\n\\n        if (par_taken)\\n        {\\n            int ans = 0;\\n            for (auto i : adj[node])\\n                if (i != par)\\n                    ans += dfs(i, node, false, cnt, price, adj);\\n            ans += cnt[node] * price[node];\\n            return dp[node][par_taken] = ans;\\n        }\\n\\n        int ans1 = 0;\\n        int ans2 = 0;\\n        for (auto i : adj[node])\\n        {\\n            if (i != par)\\n            {\\n                ans1 += dfs(i, node, false, cnt, price, adj);\\n                ans2 += dfs(i, node, true, cnt, price, adj);\\n            }\\n        }\\n        ans1 += cnt[node] * (price[node]);\\n        ans2 += cnt[node] * (price[node] / 2);\\n        return dp[node][par_taken] = min(ans1, ans2);\\n    }\\n\\n    int minimumTotalPrice(int n, vector<vector<int>> &edges, vector<int> &price, vector<vector<int>> &trips)\\n    {\\n        memset(dp, -1, sizeof(dp));\\n        vector<int> adj[n];\\n        for (auto i : edges)\\n        {\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n\\n        vector<int> cnt(n);\\n        for (auto i : trips)\\n        {\\n            cnt[i[0]]++;\\n            process(i[0], -1, i[1], cnt, adj);\\n        }\\n\\n        return dfs(0, -1, false, cnt, price, adj);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421861,
                "title": "python3-dfs",
                "content": "\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        tree = [[] for _ in range(n)] \\n        for u, v in edges: \\n            tree[u].append(v)\\n            tree[v].append(u)\\n        freq = [0]*n\\n        for s, e in trips: \\n            queue = deque([(s, -1)])\\n            parent = {s : -1}\\n            while queue: \\n                u, p = queue.popleft()\\n                if u == e: break \\n                for v in tree[u]: \\n                    if v != p: \\n                        queue.append((v, u))\\n                        parent[v] = u\\n            u = e \\n            while u >= 0: \\n                freq[u] += 1\\n                u = parent[u]\\n            \\n        def dfs(u, p):\\n            \"\"\"Return \"\"\"\\n            full = half = 0 \\n            for v in tree[u]: \\n                if v != p: \\n                    ff, hh = dfs(v, u)\\n                    full += ff\\n                    half += min(ff, hh)\\n            return price[u]*freq[u] + half, price[u]*freq[u]//2 + full\\n            \\n        return min(dfs(0, -1))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        tree = [[] for _ in range(n)] \\n        for u, v in edges: \\n            tree[u].append(v)\\n            tree[v].append(u)\\n        freq = [0]*n\\n        for s, e in trips: \\n            queue = deque([(s, -1)])\\n            parent = {s : -1}\\n            while queue: \\n                u, p = queue.popleft()\\n                if u == e: break \\n                for v in tree[u]: \\n                    if v != p: \\n                        queue.append((v, u))\\n                        parent[v] = u\\n            u = e \\n            while u >= 0: \\n                freq[u] += 1\\n                u = parent[u]\\n            \\n        def dfs(u, p):\\n            \"\"\"Return \"\"\"\\n            full = half = 0 \\n            for v in tree[u]: \\n                if v != p: \\n                    ff, hh = dfs(v, u)\\n                    full += ff\\n                    half += min(ff, hh)\\n            return price[u]*freq[u] + half, price[u]*freq[u]//2 + full\\n            \\n        return min(dfs(0, -1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421671,
                "title": "c-bfs-dfs-preprocessing-dp-intuition",
                "content": "\\n**KEY OBSERVATION** For any given tree, there is only ONE PATH from node a to node b. This means the same path will always be used, no matter how we change our node weights.\\n\\nThis allows us to do a preprocessing optimization: For each trip, log all nodes that it passes through. By doing this, we will know how many times each node is used. It is very important to understand this does not change no matter which node weights we reduce.\\nAlso because of this property we don\\'t need to keep track of a visited array for nodes because there are no cycles.\\n\\nApproach: For each trip, do a simple breadth-first-search from node A to node B, incrementing the path count of each node in the path by 1. Now, do a depth-first-search on an arbitrarily rooted tree (the tree can be arbitrarily rooted because we are searching all values anyways). We will have a boolean to keep track of whether we can reduce the weight of our current node. \\nOur DFS will have two cases: First, we will always try NOT reducing the weight of our node, because this is always an option. If reducing the weight of our node is an option, then we can reduce its weight and then search its children with the condition that their weight cannot be reduced. We keep a running sum of the answer; if our weight was not reduced, we add pathCount * price[pos] to our answer, if our weight was reduced, we add pathCount*price[pos]/2 to our answer.\\nWe return the minimum answer, that is, whether it is better to reduce the node weight or not reduce it.\\n\\nCODE:\\n```\\nclass Solution {\\npublic:\\n    int dp[51][2] = {}; // dp optimization to not recalculate values\\n    int mp[51] = {}; // count how many times a node is used in trips\\n    typedef array<int, 2> ai;\\n    void countPaths(vector<vector<int>>& adj, int x, int y){\\n        queue<ai> q;\\n        q.push({x, -1});\\n        int vis[51] = {};\\n        int last[51] = {}; // so we can efficiently backtrack the path from node a to node b\\n        while(!q.empty()){\\n            auto [t, p] = q.front();\\n            q.pop();\\n            if(vis[t]++) continue;\\n            last[t] = p;\\n            if(t == y){\\n                while(t != -1){\\n                    mp[t]++; \\n                    t = last[t];\\n                } \\n                return;\\n            }\\n            for(auto i : adj[t]) q.push({i, t});\\n        }\\n    }\\n    int dfs(vector<vector<int>>& adj, int pos, vector<int>& price, vector<vector<int>>& trips, bool canTake, int last){\\n        if(dp[pos][canTake] != -1) return dp[pos][canTake];\\n        int ans = price[pos] * mp[pos];\\n        int res1 = 0, res2 = 0;\\n        for(auto i : adj[pos]) if(i != last) res1 += dfs(adj, i, price, trips, true, pos);\\n        if(canTake){\\n            for(auto i : adj[pos]) if(i != last) res2 += dfs(adj, i, price, trips, false, pos);\\n            ans = min(ans+res1, ans/2 + res2);\\n        }\\n        else ans = ans+res1;\\n        return dp[pos][canTake] = ans;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> adj(n);\\n        memset(dp, -1, sizeof dp);\\n        for(auto&i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        for(auto& i : trips) countPaths(adj, i[0], i[1]);\\n        return dfs(adj, 0, price, trips, true, -1);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dp[51][2] = {}",
                "codeTag": "Java"
            },
            {
                "id": 3422043,
                "title": "variation-of-house-robber-iii-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem has several steps.\\n1. Find shortest path in each trip using breadth-first search.\\n2. Count how many times each node appears in the trips.\\n2. Similar to [LC.337. House Robber III](https://leetcode.com/problems/house-robber-iii/). But this time, it is not rob or not rob, it is havle or whole (not havle), this step uses depth-first search.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep 1 is straightforward, and use a parent array to record the parent of current node, then rebuild the path.\\n\\nStep 2 use a hash map or a counter array to record how many times a node appears in all trips, it is computed in step 1.\\n\\nStep 3 is a little tricky. Use (post-order) depth-first search and return two values: One value is current node is computed without halving, and the other value is computed with havling. When current node is halving, because its adjacent nodes must be whole (not havle), so that whole (not havle) contains neighbors whose values are whole. When current node is whole (not havle), its adjacent nodes can be either whole or halved, so that we take the minimum between whole (not havle) and havle.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n * numOfTrips).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n).\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        List<List<Integer>> tree = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            tree.add(new ArrayList<>());            \\n        }\\n        for (int[] edge : edges) {\\n            tree.get(edge[0]).add(edge[1]);\\n            tree.get(edge[1]).add(edge[0]);\\n        }\\n        Map<Integer, Integer> counts = new HashMap<>();\\n        for (int[] trip : trips) {\\n            bfs(tree, trip[0], trip[1], counts);\\n        }\\n        int[] currPrice = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            currPrice[i] = counts.getOrDefault(i, 0) * price[i];\\n        }\\n        int[] result = helper(tree, 0, -1, currPrice);\\n        return Math.min(result[0], result[1]);\\n    }\\n    private int[] helper(List<List<Integer>> tree, int curr, int parent, int[] currPrice) {\\n        List<Integer> neighbors = tree.get(curr);\\n        int whole = 0;\\n        int halved = 0;\\n        for (int nei : neighbors) {\\n            if (nei == parent) {\\n                continue;\\n            }\\n            int[] neiResult = helper(tree, nei, curr, currPrice);\\n            whole += neiResult[0];\\n            halved += Math.min(neiResult[0], neiResult[1]);\\n        }\\n        return new int[] {currPrice[curr] + halved, currPrice[curr] / 2 + whole};\\n    }\\n    private void bfs(List<List<Integer>> tree, int src, int dst, Map<Integer, Integer> counts) {\\n        int n = tree.size();\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        boolean[] visited = new boolean[n];\\n        int[] parent = new int[n];\\n        Arrays.fill(parent, -1);\\n        queue.offer(src);\\n        visited[src] = true;\\n        while (!queue.isEmpty()) {\\n            int curr = queue.poll();\\n            if (curr == dst) {\\n                break;\\n            }\\n            for (int nei : tree.get(curr)) {\\n                if (!visited[nei]) {\\n                    visited[nei] = true;\\n                    parent[nei] = curr;\\n                    queue.offer(nei);\\n                }\\n            }\\n        }\\n        int curr = dst;\\n        while (curr != -1) {\\n            counts.put(curr, counts.getOrDefault(curr, 0) + 1);\\n            curr  = parent[curr];\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        List<List<Integer>> tree = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            tree.add(new ArrayList<>());            \\n        }\\n        for (int[] edge : edges) {\\n            tree.get(edge[0]).add(edge[1]);\\n            tree.get(edge[1]).add(edge[0]);\\n        }\\n        Map<Integer, Integer> counts = new HashMap<>();\\n        for (int[] trip : trips) {\\n            bfs(tree, trip[0], trip[1], counts);\\n        }\\n        int[] currPrice = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            currPrice[i] = counts.getOrDefault(i, 0) * price[i];\\n        }\\n        int[] result = helper(tree, 0, -1, currPrice);\\n        return Math.min(result[0], result[1]);\\n    }\\n    private int[] helper(List<List<Integer>> tree, int curr, int parent, int[] currPrice) {\\n        List<Integer> neighbors = tree.get(curr);\\n        int whole = 0;\\n        int halved = 0;\\n        for (int nei : neighbors) {\\n            if (nei == parent) {\\n                continue;\\n            }\\n            int[] neiResult = helper(tree, nei, curr, currPrice);\\n            whole += neiResult[0];\\n            halved += Math.min(neiResult[0], neiResult[1]);\\n        }\\n        return new int[] {currPrice[curr] + halved, currPrice[curr] / 2 + whole};\\n    }\\n    private void bfs(List<List<Integer>> tree, int src, int dst, Map<Integer, Integer> counts) {\\n        int n = tree.size();\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        boolean[] visited = new boolean[n];\\n        int[] parent = new int[n];\\n        Arrays.fill(parent, -1);\\n        queue.offer(src);\\n        visited[src] = true;\\n        while (!queue.isEmpty()) {\\n            int curr = queue.poll();\\n            if (curr == dst) {\\n                break;\\n            }\\n            for (int nei : tree.get(curr)) {\\n                if (!visited[nei]) {\\n                    visited[nei] = true;\\n                    parent[nei] = curr;\\n                    queue.offer(nei);\\n                }\\n            }\\n        }\\n        int curr = dst;\\n        while (curr != -1) {\\n            counts.put(curr, counts.getOrDefault(curr, 0) + 1);\\n            curr  = parent[curr];\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422763,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int count[100];\\n    vector<int>graph[100];\\n    int path(int node1,int node2,int p=-1)\\n    {\\n        if(node1==node2)\\n        {\\n            count[node1]++;\\n            return 1;\\n        }\\n        for(auto &it:graph[node1])\\n        {\\n            if(it!=p)\\n            {\\n                if(path(it,node2,node1))\\n                {\\n                    count[node1]++;\\n                    return 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    pair<int,int>find(int node,vector<int>&price,int parent=-1)\\n    {\\n        pair<int,int>p={count[node]*price[node],count[node]*price[node]/2};\\n        for(auto &it:graph[node])\\n        {\\n            if(it!=parent)\\n            {\\n                pair<int,int>current=find(it,price,node);\\n                p.first+=min(current.first,current.second);\\n                p.second+=current.first;\\n            }\\n        }\\n        return p;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        for(auto &it:edges)\\n        {\\n            graph[it[0]].push_back(it[1]);\\n            graph[it[1]].push_back(it[0]);\\n        }\\n        for(auto it:trips)\\n        {\\n            path(it[0],it[1]);\\n        }\\n        pair<int,int>p=find(0,price);\\n        return min(p.first,p.second);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count[100];\\n    vector<int>graph[100];\\n    int path(int node1,int node2,int p=-1)\\n    {\\n        if(node1==node2)\\n        {\\n            count[node1]++;\\n            return 1;\\n        }\\n        for(auto &it:graph[node1])\\n        {\\n            if(it!=p)\\n            {\\n                if(path(it,node2,node1))\\n                {\\n                    count[node1]++;\\n                    return 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    pair<int,int>find(int node,vector<int>&price,int parent=-1)\\n    {\\n        pair<int,int>p={count[node]*price[node],count[node]*price[node]/2};\\n        for(auto &it:graph[node])\\n        {\\n            if(it!=parent)\\n            {\\n                pair<int,int>current=find(it,price,node);\\n                p.first+=min(current.first,current.second);\\n                p.second+=current.first;\\n            }\\n        }\\n        return p;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        for(auto &it:edges)\\n        {\\n            graph[it[0]].push_back(it[1]);\\n            graph[it[1]].push_back(it[0]);\\n        }\\n        for(auto it:trips)\\n        {\\n            path(it[0],it[1]);\\n        }\\n        pair<int,int>p=find(0,price);\\n        return min(p.first,p.second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422052,
                "title": "dfs-dp-easiest-approach-similiar-to-house-robber",
                "content": "**Step1:**\\nFirst Calculate the new price of each node by multiply the price of a node to the the number of times you are visiting that node through all the trips.\\n\\nThe new price for a node for example1 \\nn = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]\\n is **[2,6,20,12]** \\nAs **node 0** is being visited one time, **node 1** is being visited 3 times, **node 2** is being visited 2 times and **node 3** is being visited 2 times.\\n \\n I have stored the update price in total array.\\n \\n **Step2: dp+dfs**\\n\\t Apply dp+dfs similar to house robber **if you half a value then you cannot half its adjacent value so you take a jump of 2 and move to neighbour of neighbour of a node.**\\n   \\n        \\n    class Solution {\\n\\tpublic:\\n\\t// performing step1 as mentioned above\\n\\tbool dfs(vector<int>adj[], int s, int e, vector<int>&price, vector<int>&total, int par)\\n    {\\n        if(s==e)\\n        {\\n            total[e]+=price[e];\\n            return true;\\n        }\\n\\t\\tfor(auto i: adj[s])\\n        {\\n            if(i!=par)\\n            {\\n                bool b1 = dfs(adj,i,e,price,total,s);\\n                if(b1 == true)\\n                {\\n                    total[s]+=price[s];\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n\\t// performing step2 as mentioned above\\n    int fn(vector<int>adj[], int node, vector<int>&vis, vector<int>&total, vector<int>&dp)\\n    {\\n        if(dp[node]!=-1) return dp[node];\\n        vis[node]=1;\\n        \\n        //take;\\n        int val = total[node]/2;\\n        for(auto i: adj[node])\\n        {\\n            if(vis[i]==0)\\n            {\\n                vis[i] =1;\\n                val+=total[i];\\n                for(auto j: adj[i])\\n                {\\n                    if(vis[j]==0)\\n                    {\\n                        val+= fn(adj,j,vis,total,dp);\\n                    }\\n                }\\n                vis[i]=0;\\n            }\\n        }\\n        // not take\\n        \\n        int nt = total[node];\\n        for(auto i: adj[node])\\n        {\\n            if(vis[i]==0) nt += fn(adj,i,vis,total,dp);\\n        }\\n        vis[node] = 0;\\n        return dp[node]= min(val,nt);\\n    }\\n    \\n\\t// main function\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) \\n    {\\n        vector<int> adj[n];\\n        for(auto i: edges)\\n        {\\n            int a = i[0], b = i[1];\\n            adj[a].push_back(b);\\n            adj[b].push_back(a);\\n        }\\n        \\n        vector<int>total(n,0);\\n        for(auto i:trips)\\n        {\\n            int node1 = i[0], node2 = i[1];\\n            dfs(adj,node1, node2, price,total, -1);\\n        }\\n\\t\\t// step2 = dp+dfs;\\n        vector<int>vis(n,0);\\n        vector<int>dp(n,-1);\\n        int ans = fn(adj,0,vis,total,dp);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t// performing step1 as mentioned above\\n\\tbool dfs(vector<int>adj[], int s, int e, vector<int>&price, vector<int>&total, int par)\\n    {\\n        if(s==e)\\n        {\\n            total[e]+=price[e];\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3423598,
                "title": "python-3-detailed-explanation-with-approach-and-comments",
                "content": "Please upvote if you find it useful. It took a lot of time to make this post. \\uD83D\\uDE01\\uD83D\\uDE01\\n# Approach\\nThe solution uses dynamic programming and DFS traversal of the graph to compute the minimum total price. Here\\'s how it works:\\n\\n1. The input is the number of nodes n, the list of edges connecting nodes edges, the prices of the nodes price, and the list of trips trips.\\n\\n2. The edges are stored in a defaultdict of lists, adj, which represents an adjacency list for the graph. The adjacency list stores the neighbors of each node.\\n\\n3. The function makeContri is defined to compute the contributions of each node in the graph to the trips. It takes as input the starting node ***start***, the destination node ***end***, and a ***path*** list to store the path from start to end. The function adds start to the path and marks it as visited. If start is equal to end, it adds 1 to the contribution of each node in the path and returns True. Otherwise, it recursively explores the neighbors of start that have not been visited, adding them to the path and marking them as visited, until it reaches end or exhausts all neighbors. If it reaches end, it returns True. If it exhausts all neighbors, it removes start from the path and returns False.\\n\\n4. The contributions of each node are computed by iterating over the ***trips***, calling ***makeContri*** for each trip, and passing the start and end nodes of the trip. This updates the ***contri*** list, which stores the contributions of each node.\\n\\n5. The function dfs is defined to compute the minimum total price to reach the destination. It takes as input the current node node, the parent node parent, and a boolean used to indicate whether the current node\\'s parent has been halved in the previous step. The function checks if the current node and halve state have been visited before, and returns the stored result if they have. Otherwise, it computes two possible minimum total prices:\\n\\n    - res1 is the minimum total price if the current node\\'s parent is not halve, and is computed by summing up the prices of the nodes in the current connected component, divided by 2 and multiplied by their contributions, and recursively calling dfs on the neighbors of the current node that have not been visited.\\n\\n    - res2 is the minimum total price if the current node\\'s parent is halved, and is computed by summing up the prices of the nodes in the current connected component, multiplied by their contributions, and recursively calling dfs on the neighbors of the current node that have not been visited.\\n\\n    The minimum of res1 and res2 is stored in the dp dictionary and returned.\\n\\n6. Finally, dfs is called with the starting node 0, a dummy parent node -1, and the halve state False, and the minimum total price is returned.\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        # Part 1: Creating an adjacency list to traverse the graph\\n\\n        # Default dictionary with list as its default value.\\n        adj = defaultdict(list)\\n        \\n        # Traversing to each edge and adding it to its respective node\\n        for src, dst in edges:\\n            adj[src].append(dst)\\n            adj[dst].append(src)\\n        \\n        # For Example 1, adjacency list will be:\\n        # adj = {0: [1], 1: [0, 2, 3], 2: [1], 3: [1]}\\n\\n        # <!--- Part 1 End ---!>\\n\\n\\n        # Part 2: Counting the contribution of each node\\n\\n        contri = [0] * n\\n\\n        # start -> Trip starting node\\n        # end -> Destination of trip\\n        # path -> Path from start to end\\n        def makeContri(start, end, path):\\n            # Add node to the path and visited\\n            path.add(start)\\n            visited.add(start)\\n\\n            # If this condition is True, we reached our end point\\n            if start == end:\\n                # We will increment contri of each node present in the path\\n                for node in path:\\n                    contri[node] += 1\\n                # Return True to stop further recursive searches\\n                return True\\n            \\n            # Else we will traverse recursively through the neighbours\\n            # until we reach the end node\\n            for nei in adj[start]:\\n                if nei not in visited and makeContri(nei, end, path):\\n                    return True\\n            # If we don\\'t find the end node, then remove the node from\\n            # path and return False. \\n            path.remove(start)\\n            return False\\n        \\n        # Calling makeContri for each trip to find the contribution \\n        # of each node\\n        for start, end in trips:\\n            visited = set()\\n            makeContri(start, end, set())\\n        \\n        # This updates the contri list, which stores the contributions \\n        # of each node\\n        # For Example 1, contri list will be\\n        # contri = [1, 3, 2, 2]\\n        # node :    0, 1, 2, 3\\n        # Now we know that \\'node 0\\' contributes 1 time\\n        #                  \\'node 1\\' contributes 3 times\\n        #                   and so on .....\\n\\n        # <!--- Part 2 End ---!>\\n\\n\\n        # Part 3: Dynamically execute all possibilities\\n\\n        # For a node, there are 2 possibilities\\n        # 1. If the price of the current node\\'s parent had been halved:\\n        #       In this case, we cannot halve the price of the current node.\\n        #       So, we recursively calculate the price without halving.\\n        # 2. or the price of the current node\\'s parent remains was not halved:\\n        #       Here, we can halve the price of current node or exclude it and \\n        #       calculate without halving it.\\n\\n        # Caching the result\\n        dp = {}\\n        \\n        # node -> current node\\n        # parent -> parent of current node\\n        # halve -> whether the parent node was halved or not\\n        def dfs(node, parent, halve):\\n            # if result in dp, return the result\\n            if (node, halve) in dp:\\n                return dp[(node, halve)]\\n\\n            # res1 -> result when halved\\n            # res2 -> result when not halved\\n            # Initialising it to infinity since the \\'if\\' statement \\n            # below may not get executed.\\n            res1 = float(\"inf\")\\n\\n            # if parent is not halved\\n            if not halve:\\n                res1 = price[node] // 2 * contri[node] \\n\\n                for nei in adj[node]:\\n                    if nei != parent:\\n                        res1 += dfs(nei, node, True)\\n            \\n            # if parent is halved or we want to exclude halving\\n            # of current node. (Same for both possibilities)\\n            res2 = price[node] * contri[node]\\n\\n            for nei in adj[node]:\\n                    if nei != parent:\\n                        res2 += dfs(nei, node, False)\\n            \\n            # Storing the minimum of both the result in dp\\n            dp[(node, halve)] = min(res1, res2)\\n\\n            return dp[(node, halve)]\\n        \\n        # Calling dfs on node \\'0\\', fake parent as \\'-1\\', halved as \\'False\\'\\n        return dfs(0, -1, False)\\n```\\n\\n# Code without comments\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        adj = defaultdict(list)\\n        \\n        for src, dst in edges:\\n            adj[src].append(dst)\\n            adj[dst].append(src)\\n        \\n        def makeContri(start, end, path):\\n            path.append(start)\\n            visited.add(start)\\n\\n            if start == end:\\n                for node in path:\\n                    contri[node] += 1\\n                return True\\n            \\n            for nei in adj[start]:\\n                if nei not in visited and makeContri(nei, end, path):\\n                    return True\\n            path.pop()\\n            return False\\n        \\n        contri = [0] * n\\n\\n        for start, end in trips:\\n            visited = set()\\n            makeContri(start, end, [])\\n        \\n        dp = {}\\n        \\n        def dfs(node, parent, halve):\\n            if (node, halve) in dp:\\n                return dp[(node, halve)]\\n\\n            res1 = float(\"inf\")\\n            if not halve:\\n                res1 = price[node] // 2 * contri[node] \\n\\n                for nei in adj[node]:\\n                    if nei != parent:\\n                        res1 += dfs(nei, node, True)\\n            \\n            res2 = price[node] * contri[node]\\n\\n            for nei in adj[node]:\\n                    if nei != parent:\\n                        res2 += dfs(nei, node, False)\\n            \\n            dp[(node, halve)] = min(res1, res2)\\n\\n            return dp[(node, halve)]\\n        \\n        return dfs(0, -1, False)\\n\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        # Part 1: Creating an adjacency list to traverse the graph\\n\\n        # Default dictionary with list as its default value.\\n        adj = defaultdict(list)\\n        \\n        # Traversing to each edge and adding it to its respective node\\n        for src, dst in edges:\\n            adj[src].append(dst)\\n            adj[dst].append(src)\\n        \\n        # For Example 1, adjacency list will be:\\n        # adj = {0: [1], 1: [0, 2, 3], 2: [1], 3: [1]}\\n\\n        # <!--- Part 1 End ---!>\\n\\n\\n        # Part 2: Counting the contribution of each node\\n\\n        contri = [0] * n\\n\\n        # start -> Trip starting node\\n        # end -> Destination of trip\\n        # path -> Path from start to end\\n        def makeContri(start, end, path):\\n            # Add node to the path and visited\\n            path.add(start)\\n            visited.add(start)\\n\\n            # If this condition is True, we reached our end point\\n            if start == end:\\n                # We will increment contri of each node present in the path\\n                for node in path:\\n                    contri[node] += 1\\n                # Return True to stop further recursive searches\\n                return True\\n            \\n            # Else we will traverse recursively through the neighbours\\n            # until we reach the end node\\n            for nei in adj[start]:\\n                if nei not in visited and makeContri(nei, end, path):\\n                    return True\\n            # If we don\\'t find the end node, then remove the node from\\n            # path and return False. \\n            path.remove(start)\\n            return False\\n        \\n        # Calling makeContri for each trip to find the contribution \\n        # of each node\\n        for start, end in trips:\\n            visited = set()\\n            makeContri(start, end, set())\\n        \\n        # This updates the contri list, which stores the contributions \\n        # of each node\\n        # For Example 1, contri list will be\\n        # contri = [1, 3, 2, 2]\\n        # node :    0, 1, 2, 3\\n        # Now we know that \\'node 0\\' contributes 1 time\\n        #                  \\'node 1\\' contributes 3 times\\n        #                   and so on .....\\n\\n        # <!--- Part 2 End ---!>\\n\\n\\n        # Part 3: Dynamically execute all possibilities\\n\\n        # For a node, there are 2 possibilities\\n        # 1. If the price of the current node\\'s parent had been halved:\\n        #       In this case, we cannot halve the price of the current node.\\n        #       So, we recursively calculate the price without halving.\\n        # 2. or the price of the current node\\'s parent remains was not halved:\\n        #       Here, we can halve the price of current node or exclude it and \\n        #       calculate without halving it.\\n\\n        # Caching the result\\n        dp = {}\\n        \\n        # node -> current node\\n        # parent -> parent of current node\\n        # halve -> whether the parent node was halved or not\\n        def dfs(node, parent, halve):\\n            # if result in dp, return the result\\n            if (node, halve) in dp:\\n                return dp[(node, halve)]\\n\\n            # res1 -> result when halved\\n            # res2 -> result when not halved\\n            # Initialising it to infinity since the \\'if\\' statement \\n            # below may not get executed.\\n            res1 = float(\"inf\")\\n\\n            # if parent is not halved\\n            if not halve:\\n                res1 = price[node] // 2 * contri[node] \\n\\n                for nei in adj[node]:\\n                    if nei != parent:\\n                        res1 += dfs(nei, node, True)\\n            \\n            # if parent is halved or we want to exclude halving\\n            # of current node. (Same for both possibilities)\\n            res2 = price[node] * contri[node]\\n\\n            for nei in adj[node]:\\n                    if nei != parent:\\n                        res2 += dfs(nei, node, False)\\n            \\n            # Storing the minimum of both the result in dp\\n            dp[(node, halve)] = min(res1, res2)\\n\\n            return dp[(node, halve)]\\n        \\n        # Calling dfs on node \\'0\\', fake parent as \\'-1\\', halved as \\'False\\'\\n        return dfs(0, -1, False)\\n```\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        adj = defaultdict(list)\\n        \\n        for src, dst in edges:\\n            adj[src].append(dst)\\n            adj[dst].append(src)\\n        \\n        def makeContri(start, end, path):\\n            path.append(start)\\n            visited.add(start)\\n\\n            if start == end:\\n                for node in path:\\n                    contri[node] += 1\\n                return True\\n            \\n            for nei in adj[start]:\\n                if nei not in visited and makeContri(nei, end, path):\\n                    return True\\n            path.pop()\\n            return False\\n        \\n        contri = [0] * n\\n\\n        for start, end in trips:\\n            visited = set()\\n            makeContri(start, end, [])\\n        \\n        dp = {}\\n        \\n        def dfs(node, parent, halve):\\n            if (node, halve) in dp:\\n                return dp[(node, halve)]\\n\\n            res1 = float(\"inf\")\\n            if not halve:\\n                res1 = price[node] // 2 * contri[node] \\n\\n                for nei in adj[node]:\\n                    if nei != parent:\\n                        res1 += dfs(nei, node, True)\\n            \\n            res2 = price[node] * contri[node]\\n\\n            for nei in adj[node]:\\n                    if nei != parent:\\n                        res2 += dfs(nei, node, False)\\n            \\n            dp[(node, halve)] = min(res1, res2)\\n\\n            return dp[(node, halve)]\\n        \\n        return dfs(0, -1, False)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423346,
                "title": "minimize-the-total-price-of-the-trips-easy-c-solution-dfs-dp-clean-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse **DFS** to find the **path of every trip**.\\nFrom these path calculate the **occurance of every node in the final answer**\\nEvery node has two possibilities either reduce its price to half or not. With a constraint that two adjacent cannot be selected. \\nUse **DP** to find the best set of node whose price reduction to half will minimize the total cost.\\n\\n# Time Complexity\\n**O(N*T)** where N is number of nodes and T is number of trips\\n\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    // Used DFS to find path of every trip \\n    void dfs(int vertex, int target, int p, vector<vector<int>> &edges, vector<int> &vis, stack<int> ans, vector<int> &v)\\n    {\\n        // Start from source vertex\\n        for (auto it : edges[vertex])\\n        {\\n            if (it != p)\\n            {\\n                if (it == target)\\n                { \\n                    // Insert the path in ans vector on reaching target\\n                    ans.push(it);\\n                    while (ans.size() > 0)\\n                    {\\n                        int x = ans.top();\\n                        ans.pop();\\n                        v.push_back(x);\\n                    }\\n                    reverse(v.begin(), v.end());\\n                    return;\\n                }\\n                else\\n                {\\n                    ans.push(it);\\n                    dfs(it, target, vertex, edges, vis, ans, v);\\n                    // Backtrack\\n                    ans.pop();\\n                }\\n            }\\n        }\\n    }\\n    int dp[51][2];\\n    // Use dynamic programming to select set nodes in order to minimize the total cost\\n    int rec(map<int, int> cnt, vector<int> price, vector<vector<int>> edges, int node, int parent, bool prev = false)\\n    {\\n        int res1 = cnt[node] * price[node] / 2;\\n        int res2 = cnt[node] * price[node];\\n\\n        if (dp[node][prev] != -1)\\n            return dp[node][prev];\\n\\n        for (auto child : edges[node])\\n            if (child != parent)\\n                res2 += rec(cnt, price, edges, child, node, 0);\\n        if (prev)\\n            return dp[node][prev] = res2;\\n\\n        for (auto child : edges[node])\\n            if (child != parent)\\n                res1 += rec(cnt, price, edges, child, node, 1);\\n\\n        return dp[node][prev] = min(res1, res2);\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>> &ed, vector<int> &price, vector<vector<int>> &trips)\\n    {\\n        vector<vector<int>> path;\\n        vector<vector<int>> edges(n);\\n        for (auto it : ed)\\n        {\\n            edges[it[0]].push_back(it[1]);\\n            edges[it[1]].push_back(it[0]);\\n        }\\n        for (auto it : trips)\\n        {\\n            if (it[0] == it[1])\\n            {\\n                path.push_back({it[0]});\\n                continue;\\n            }\\n            vector<int> v;\\n            vector<int> vis(n, 0);\\n            stack<int> ans;\\n            ans.push(it[0]);\\n            dfs(it[0], it[1], -1, edges, vis, ans, v);\\n            path.push_back(v);\\n        }\\n        // for (auto it : path)\\n        // {\\n        //     for (auto i : it)\\n        //     {\\n        //         cout << i << \\' \\';\\n        //     }\\n        //     cout << \\'\\\\n\\';\\n        // }\\n        \\n        // Calculate the contribution of every node in the total answer\\n        map<int, int> cnt;\\n        for (auto it : path)\\n        {\\n            for (auto i : it)\\n                cnt[i]++;\\n        }\\n        memset(dp, -1, sizeof(dp));\\n\\n        return rec(cnt, price, edges, 0, -1, 0);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    // Used DFS to find path of every trip \\n    void dfs(int vertex, int target, int p, vector<vector<int>> &edges, vector<int> &vis, stack<int> ans, vector<int> &v)\\n    {\\n        // Start from source vertex\\n        for (auto it : edges[vertex])\\n        {\\n            if (it != p)\\n            {\\n                if (it == target)\\n                { \\n                    // Insert the path in ans vector on reaching target\\n                    ans.push(it);\\n                    while (ans.size() > 0)\\n                    {\\n                        int x = ans.top();\\n                        ans.pop();\\n                        v.push_back(x);\\n                    }\\n                    reverse(v.begin(), v.end());\\n                    return;\\n                }\\n                else\\n                {\\n                    ans.push(it);\\n                    dfs(it, target, vertex, edges, vis, ans, v);\\n                    // Backtrack\\n                    ans.pop();\\n                }\\n            }\\n        }\\n    }\\n    int dp[51][2];\\n    // Use dynamic programming to select set nodes in order to minimize the total cost\\n    int rec(map<int, int> cnt, vector<int> price, vector<vector<int>> edges, int node, int parent, bool prev = false)\\n    {\\n        int res1 = cnt[node] * price[node] / 2;\\n        int res2 = cnt[node] * price[node];\\n\\n        if (dp[node][prev] != -1)\\n            return dp[node][prev];\\n\\n        for (auto child : edges[node])\\n            if (child != parent)\\n                res2 += rec(cnt, price, edges, child, node, 0);\\n        if (prev)\\n            return dp[node][prev] = res2;\\n\\n        for (auto child : edges[node])\\n            if (child != parent)\\n                res1 += rec(cnt, price, edges, child, node, 1);\\n\\n        return dp[node][prev] = min(res1, res2);\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>> &ed, vector<int> &price, vector<vector<int>> &trips)\\n    {\\n        vector<vector<int>> path;\\n        vector<vector<int>> edges(n);\\n        for (auto it : ed)\\n        {\\n            edges[it[0]].push_back(it[1]);\\n            edges[it[1]].push_back(it[0]);\\n        }\\n        for (auto it : trips)\\n        {\\n            if (it[0] == it[1])\\n            {\\n                path.push_back({it[0]});\\n                continue;\\n            }\\n            vector<int> v;\\n            vector<int> vis(n, 0);\\n            stack<int> ans;\\n            ans.push(it[0]);\\n            dfs(it[0], it[1], -1, edges, vis, ans, v);\\n            path.push_back(v);\\n        }\\n        // for (auto it : path)\\n        // {\\n        //     for (auto i : it)\\n        //     {\\n        //         cout << i << \\' \\';\\n        //     }\\n        //     cout << \\'\\\\n\\';\\n        // }\\n        \\n        // Calculate the contribution of every node in the total answer\\n        map<int, int> cnt;\\n        for (auto it : path)\\n        {\\n            for (auto i : it)\\n                cnt[i]++;\\n        }\\n        memset(dp, -1, sizeof(dp));\\n\\n        return rec(cnt, price, edges, 0, -1, 0);\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3422215,
                "title": "ez-python-sol-full-shitty",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        cnt=defaultdict(int)\\n        g=defaultdict(list)\\n        for x,y in edges:\\n            # print(x,y)\\n            g[x].append(y)\\n            g[y].append(x)\\n        def bfs(to,fro):\\n            q=deque([to])\\n            par=[None]*n\\n            par[to]=-1\\n            while q:\\n                t=q.popleft()\\n                for i in g[t]:\\n                    if par[i]==None:\\n                        par[i]=t\\n                        q.append(i)\\n            tt=fro\\n            while tt!=-1:\\n                cnt[tt]+=1\\n                tt=par[tt]\\n        for x,y in trips:\\n            bfs(x,y)\\n        for i in range(n):\\n            price[i]=cnt[i]*price[i]\\n        # print(price)\\n        def dfs(node,par):\\n            ans=[price[node]//2,price[node]] #cur half , not half\\n            for i in g[node]:\\n                if i!=par:\\n                    hlf,nhlf=dfs(i,node)\\n                    ans[0]+=nhlf\\n                    ans[1]=min(ans[1]+hlf,ans[1]+nhlf)\\n            return ans\\n        return min(dfs(0,-1))\\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        cnt=defaultdict(int)\\n        g=defaultdict(list)\\n        for x,y in edges:\\n            # print(x,y)\\n            g[x].append(y)\\n            g[y].append(x)\\n        def bfs(to,fro):\\n            q=deque([to])\\n            par=[None]*n\\n            par[to]=-1\\n            while q:\\n                t=q.popleft()\\n                for i in g[t]:\\n                    if par[i]==None:\\n                        par[i]=t\\n                        q.append(i)\\n            tt=fro\\n            while tt!=-1:\\n                cnt[tt]+=1\\n                tt=par[tt]\\n        for x,y in trips:\\n            bfs(x,y)\\n        for i in range(n):\\n            price[i]=cnt[i]*price[i]\\n        # print(price)\\n        def dfs(node,par):\\n            ans=[price[node]//2,price[node]] #cur half , not half\\n            for i in g[node]:\\n                if i!=par:\\n                    hlf,nhlf=dfs(i,node)\\n                    ans[0]+=nhlf\\n                    ans[1]=min(ans[1]+hlf,ans[1]+nhlf)\\n            return ans\\n        return min(dfs(0,-1))\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421871,
                "title": "java-postorder-dfs-easy-and-readable-count-the-nodes-on-all-paths-then-do-post-order-dfs",
                "content": "```Java\\nclass Solution {\\n    private ArrayList<Integer>[] tree;\\n    private int[] price;\\n    private HashMap<Integer, Integer> pathCount;\\n    private int n;\\n    \\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        this.price = price;\\n        this.n = n;\\n        \\n        this.tree = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            tree[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            tree[e[0]].add(e[1]);\\n            tree[e[1]].add(e[0]);\\n        }\\n        \\n\\t\\t// pathCount <nodeId, the number of node on the path>\\n        this.pathCount = new HashMap<>();\\n        for (int[] t : trips) {\\n            ArrayList<Integer> path = new ArrayList<>();\\n            dfsForPath(-1, t[0], t[1], path);\\n            for (int p : path) {\\n                pathCount.put(p, 1 + pathCount.getOrDefault(p, 0));\\n            }\\n        }\\n        \\n        int[] res = dfs(-1, 0);\\n        return Math.min(res[0], res[1]);\\n    }\\n    \\n    // post order dfs\\n    // return int[]{cost1, cost2}, cost1: halve current node, cost2: don\\'t halve current node.\\n    private int[] dfs(int parent, int node) {\\n        // System.out.println(\"node: \"  + node);\\n        int[] ret = new int[2];\\n        \\n        for (int child : tree[node]) {\\n            if (child == parent) continue;\\n            int[] sub = dfs(node, child);\\n\\t\\t\\t// if halve the current node, then the child cann\\'t halve the price.\\n            ret[0] += sub[1];\\n\\t\\t\\t// if doesn\\'t halve current node, then the child can halve the price or not, we choose the min one.\\n            ret[1] += Math.min(sub[0], sub[1]);\\n        }\\n        if (pathCount.containsKey(node)) {\\n            ret[0] += pathCount.get(node) * price[node] / 2;\\n            ret[1] += pathCount.get(node) * price[node];\\n        }\\n        return ret;\\n    }\\n    \\n    private boolean dfsForPath(int parent, int node, int dest, ArrayList<Integer> path)  {\\n        path.add(node);\\n        if (dest == node) return true;\\n        \\n        for (int child : tree[node]) {\\n            if (child == parent) continue;\\n            if (dfsForPath(node, child, dest, path)) {\\n                return true;\\n            }\\n        }\\n        path.remove(path.size() - 1);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\nclass Solution {\\n    private ArrayList<Integer>[] tree;\\n    private int[] price;\\n    private HashMap<Integer, Integer> pathCount;\\n    private int n;\\n    \\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        this.price = price;\\n        this.n = n;\\n        \\n        this.tree = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            tree[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            tree[e[0]].add(e[1]);\\n            tree[e[1]].add(e[0]);\\n        }\\n        \\n\\t\\t// pathCount <nodeId, the number of node on the path>\\n        this.pathCount = new HashMap<>();\\n        for (int[] t : trips) {\\n            ArrayList<Integer> path = new ArrayList<>();\\n            dfsForPath(-1, t[0], t[1], path);\\n            for (int p : path) {\\n                pathCount.put(p, 1 + pathCount.getOrDefault(p, 0));\\n            }\\n        }\\n        \\n        int[] res = dfs(-1, 0);\\n        return Math.min(res[0], res[1]);\\n    }\\n    \\n    // post order dfs\\n    // return int[]{cost1, cost2}, cost1: halve current node, cost2: don\\'t halve current node.\\n    private int[] dfs(int parent, int node) {\\n        // System.out.println(\"node: \"  + node);\\n        int[] ret = new int[2];\\n        \\n        for (int child : tree[node]) {\\n            if (child == parent) continue;\\n            int[] sub = dfs(node, child);\\n\\t\\t\\t// if halve the current node, then the child cann\\'t halve the price.\\n            ret[0] += sub[1];\\n\\t\\t\\t// if doesn\\'t halve current node, then the child can halve the price or not, we choose the min one.\\n            ret[1] += Math.min(sub[0], sub[1]);\\n        }\\n        if (pathCount.containsKey(node)) {\\n            ret[0] += pathCount.get(node) * price[node] / 2;\\n            ret[1] += pathCount.get(node) * price[node];\\n        }\\n        return ret;\\n    }\\n    \\n    private boolean dfsForPath(int parent, int node, int dest, ArrayList<Integer> path)  {\\n        path.add(node);\\n        if (dest == node) return true;\\n        \\n        for (int child : tree[node]) {\\n            if (child == parent) continue;\\n            if (dfsForPath(node, child, dest, path)) {\\n                return true;\\n            }\\n        }\\n        path.remove(path.size() - 1);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421923,
                "title": "dp-o-n-trips-c-explained",
                "content": "# Intuition\\nThe key here is to see that the ways in which you can halve the value or the nodes that depends on the trips and each node will have its own independent weight in the final sum so we have a situation where we have to choose whether to halve or not to halve some node which is a typical DP task.\\n\\n# Approach\\n- Step 1. Condence the trips\\n    Let\\'s see that we do a precalc in order to condense all trips in some information in the nodes, let\\'s make the halves after.\\n\\n    The statement says:\\n    > Additionally, you are given a 2D integer array trips, where trips[i] = [starti, endi] indicates that you start the ith trip from the node starti and travel to the node endi by any path you like.\\n\\n    But all we know that for a three a path betwen the node $u$ and $v$ is unique so, each path is defined and we can know in how many paths some node will be part let\\'s calc this in some array call $contribution$ , for make this array let\\'s see that the limits of nodes and trips are very small so for each trip we can simply run a dfs and mark all nodes that was visited in the path and each one of the marked nodes check the code to understand.\\n\\n    Now with this information we can get the final sum with one extra pass and will be $\\\\Sigma_i^n contribution_i \\\\times price_i$  now it\\'s time to decide who will be halved \\n\\n- Step 2: Decide which will be halved \\n    Now We need to select some nodes to halve, let\\'s see that the condition is that no adjacent nodes can be halved at same time , so it says that the number of valid halvings could be huge, but is cleat that it will be repeated subproblems. \\nLet\\'s see at first that root the tree is indiferent you chan chose whatever root that you want , now let\\'s define the way to traverse the tree, and that will be just the same as DFS order now we can define the next DP.\\n\\n$$DP[u][pH]$$ Where $u$ is the current node and $pH$ (parentHalved) is a boolean value that say if we choose that our parent halve their price, and the transitions are: \\n$$DP[u][pH] =\\n  \\\\begin{cases}\\n    \\\\sum_{c_u} DP[c_u][0]  + contribution_u \\\\times price_u     & \\\\quad \\\\text{if } pH \\\\text{ is true}\\\\\\\\\\n    min(\\\\sum_{c_u} DP[c_u][0] ,\\\\sum_{c_u} DP[c_u][1]) +contribution_u \\\\times price_u  & \\\\quad \\\\text{if } pH \\\\text{ is false}\\n  \\\\end{cases}\\n$$\\n\\nThat is because if our parent was halved we cannot halved, and in other way we can choose if halve our price or not.\\n# Complexity\\n- Time complexity:\\n- Condence the tips cost $$O(M \\\\times n)$$ where $M$ is the number of trips and the DP costs $$O(2 \\\\times n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> graph[57];\\n    vector<int> G[57];\\n    vector<int> cont;\\n\\n    void dfs(int u,int p = -1){\\n        if(p !=-1)\\n            G[p].push_back(u);\\n        \\n        for(auto v:graph[u]){\\n            if(v == p)continue;\\n            dfs(v,u);\\n        }\\n    }\\n    vector<int> d;\\n    void dfs2(int u,int t,int p = -1){\\n        \\n        if(u == t)d[u] = 1;\\n        \\n        for(auto v:graph[u]){\\n            if(v == p)continue;\\n            dfs2(v,t,u);\\n            d[u]+=d[v];\\n        }\\n        \\n        cont[u]+=d[u];\\n    }\\n    \\n    \\n    int dp[57][2];\\n    vector<int> P;\\n    \\n    int solve(int u,int p){\\n        int &x = dp[u][p];\\n        if(x!=-1)return x;\\n        \\n        if(p){\\n            int ans = cont[u]*P[u];\\n            for(auto v:G[u]){\\n                ans+=solve(v,0);\\n            }\\n            return x = ans;\\n                        \\n        }\\n        else{\\n            int ans1 = cont[u]*(P[u]/2);\\n            int ans2 = cont[u]*P[u];\\n            \\n            for(auto v:G[u]){\\n                ans1+=solve(v,1);\\n                ans2+=solve(v,0);\\n            }\\n            return x = min(ans1,ans2);\\n        }\\n        \\n        return 0;\\n    }    \\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        for(auto c:edges){\\n            int u = c[0];\\n            int v = c[1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        dfs(0);\\n        P = price;\\n        cont.resize(n);\\n        for(auto c:trips){\\n            int u = c[0];\\n            int v = c[1];\\n            d.assign(n,0);\\n            dfs2(u,v);\\n        }\\n        memset(dp,-1,sizeof dp);\\n        int ans1 = solve(0,0);\\n        int ans2 = solve(0,1);\\n        return min(ans1,ans2);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> graph[57];\\n    vector<int> G[57];\\n    vector<int> cont;\\n\\n    void dfs(int u,int p = -1){\\n        if(p !=-1)\\n            G[p].push_back(u);\\n        \\n        for(auto v:graph[u]){\\n            if(v == p)continue;\\n            dfs(v,u);\\n        }\\n    }\\n    vector<int> d;\\n    void dfs2(int u,int t,int p = -1){\\n        \\n        if(u == t)d[u] = 1;\\n        \\n        for(auto v:graph[u]){\\n            if(v == p)continue;\\n            dfs2(v,t,u);\\n            d[u]+=d[v];\\n        }\\n        \\n        cont[u]+=d[u];\\n    }\\n    \\n    \\n    int dp[57][2];\\n    vector<int> P;\\n    \\n    int solve(int u,int p){\\n        int &x = dp[u][p];\\n        if(x!=-1)return x;\\n        \\n        if(p){\\n            int ans = cont[u]*P[u];\\n            for(auto v:G[u]){\\n                ans+=solve(v,0);\\n            }\\n            return x = ans;\\n                        \\n        }\\n        else{\\n            int ans1 = cont[u]*(P[u]/2);\\n            int ans2 = cont[u]*P[u];\\n            \\n            for(auto v:G[u]){\\n                ans1+=solve(v,1);\\n                ans2+=solve(v,0);\\n            }\\n            return x = min(ans1,ans2);\\n        }\\n        \\n        return 0;\\n    }    \\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        for(auto c:edges){\\n            int u = c[0];\\n            int v = c[1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        dfs(0);\\n        P = price;\\n        cont.resize(n);\\n        for(auto c:trips){\\n            int u = c[0];\\n            int v = c[1];\\n            d.assign(n,0);\\n            dfs2(u,v);\\n        }\\n        memset(dp,-1,sizeof dp);\\n        int ans1 = solve(0,0);\\n        int ans2 = solve(0,1);\\n        return min(ans1,ans2);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421855,
                "title": "c-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically we need to find out the nodes which are contrinuting maximum to the trip cost.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo calculate the trip cost (sum variable in code) and also store the contribution of each node in the final sum (the cost array in code)\\nAfter that find the maximum sum of non adjacent nodes according to the cost array (done using function named find in the code).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    vector<vector<int>>dp;\\n    int find(vector<vector<int>>&g, vector<int>&cost, int s,int p, bool k=true)\\n    {\\n        if(dp[k][s]!=-1)\\n            return dp[k][s];\\n        int ans1=0,ans2=0;\\n        if(k)\\n            ans1+=cost[s];\\n        for(auto i:g[s])\\n        {\\n            if(i!=p)\\n            {\\n                ans1+=find(g,cost,i,s,!k);\\n                ans2+=find(g,cost,i,s,k);\\n            }\\n        }\\n        return dp[k][s]=max(ans1,ans2);\\n    }\\n    bool helper(vector<vector<int>>&g, int s, int e, int p, vector<int>&cost, vector<int>&price)\\n    {\\n        if(s==e)\\n        {\\n            sum+=price[e];\\n            cost[e]+=price[e];\\n            return true;\\n        }\\n        for(auto i:g[s])\\n        {\\n            if(i!=p && helper(g,i,e,s,cost,price))\\n            {\\n                sum+=price[s];\\n                cost[s]+=price[s];\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& e, vector<int>& price, vector<vector<int>>& t) \\n    {\\n        vector<vector<int>>g(n);\\n        \\n        for(int i=0;i<e.size();i++)\\n        {\\n            g[e[i][0]].push_back(e[i][1]);\\n            g[e[i][1]].push_back(e[i][0]);\\n        }\\n        vector<int>cost(n,0);\\n        for(int i=0;i<t.size();i++)\\n        {\\n            helper(g,t[i][0],t[i][1],-1,cost,price);\\n        }\\n        \\n        int sum1=0,sum2=0;\\n        \\n        dp.resize(2,vector<int>(n,-1));\\n        sum1=find(g,cost,0,-1);       \\n        \\n        sum-=(sum1/2);\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    vector<vector<int>>dp;\\n    int find(vector<vector<int>>&g, vector<int>&cost, int s,int p, bool k=true)\\n    {\\n        if(dp[k][s]!=-1)\\n            return dp[k][s];\\n        int ans1=0,ans2=0;\\n        if(k)\\n            ans1+=cost[s];\\n        for(auto i:g[s])\\n        {\\n            if(i!=p)\\n            {\\n                ans1+=find(g,cost,i,s,!k);\\n                ans2+=find(g,cost,i,s,k);\\n            }\\n        }\\n        return dp[k][s]=max(ans1,ans2);\\n    }\\n    bool helper(vector<vector<int>>&g, int s, int e, int p, vector<int>&cost, vector<int>&price)\\n    {\\n        if(s==e)\\n        {\\n            sum+=price[e];\\n            cost[e]+=price[e];\\n            return true;\\n        }\\n        for(auto i:g[s])\\n        {\\n            if(i!=p && helper(g,i,e,s,cost,price))\\n            {\\n                sum+=price[s];\\n                cost[s]+=price[s];\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& e, vector<int>& price, vector<vector<int>>& t) \\n    {\\n        vector<vector<int>>g(n);\\n        \\n        for(int i=0;i<e.size();i++)\\n        {\\n            g[e[i][0]].push_back(e[i][1]);\\n            g[e[i][1]].push_back(e[i][0]);\\n        }\\n        vector<int>cost(n,0);\\n        for(int i=0;i<t.size();i++)\\n        {\\n            helper(g,t[i][0],t[i][1],-1,cost,price);\\n        }\\n        \\n        int sum1=0,sum2=0;\\n        \\n        dp.resize(2,vector<int>(n,-1));\\n        sum1=find(g,cost,0,-1);       \\n        \\n        sum-=(sum1/2);\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421853,
                "title": "dp-lca",
                "content": "# Intuition\\nDP + LCA\\n\\n\\n# Code\\n```\\nclass Solution {\\n    void dfs(const vector<vector<int>> &con, int x, int p, int dep, vector<int> &d, vector<int> &f) {\\n        d[x] = dep;\\n        f[x] = p;\\n        for (int y : con[x]) {\\n            if (y != p) {\\n                dfs(con, y, x, dep + 1, d, f);\\n            }\\n        }\\n        \\n    }\\n    \\n    int dfs(const vector<vector<int>> &con, const vector<int> &c, int x, int p, int v, vector<vector<int>> &dp) {\\n        if (dp[x][v] >= 0) {\\n            return dp[x][v];\\n        }\\n        if (dp[x][1] < 0) {\\n            dp[x][1] = 0;\\n            for (int y : con[x]) {\\n                if (y != p) {\\n                    dp[x][1] += dfs(con, c, y, x, 0, dp);\\n                }\\n            }\\n        }\\n        if (v == 1) {\\n            return dp[x][1];\\n        }\\n        dp[x][0] = c[x];\\n        for (int y : con[x]) {\\n            if (y != p) {\\n                dp[x][0] += dfs(con, c, y, x, 1, dp);\\n            }            \\n        }\\n        return dp[x][0] = max(dp[x][0], dp[x][1]);\\n        \\n        \\n    }\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> con(n);\\n        for (const auto& e : edges) {\\n            con[e[0]].push_back(e[1]);\\n            con[e[1]].push_back(e[0]);  \\n        }\\n        vector<int> d(n), f(n);\\n        dfs(con, 0, -1, 0, d, f);\\n        vector<int> t(n);\\n        for (const auto & v : trips) {\\n            int x = v[0], y = v[1];\\n            while (d[x] > d[y]) {\\n                ++t[x];\\n                x = f[x]; \\n            }\\n            while (d[x] < d[y]) {\\n                ++t[y];\\n                y = f[y]; \\n            }\\n            while (x != y) {\\n                ++t[x];\\n                x = f[x]; \\n                ++t[y];\\n                y = f[y]; \\n            }\\n            ++t[x];\\n        }\\n        int r = 0;\\n        for (int  i = 0; i < n; ++i) {\\n            t[i] *= price[i];\\n            r += t[i];\\n            t[i] >>= 1;\\n        }\\n        vector<vector<int>> dp(n, vector<int>(2, -1));\\n        return r - dfs(con, t, 0, -1, 0, dp);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(const vector<vector<int>> &con, int x, int p, int dep, vector<int> &d, vector<int> &f) {\\n        d[x] = dep;\\n        f[x] = p;\\n        for (int y : con[x]) {\\n            if (y != p) {\\n                dfs(con, y, x, dep + 1, d, f);\\n            }\\n        }\\n        \\n    }\\n    \\n    int dfs(const vector<vector<int>> &con, const vector<int> &c, int x, int p, int v, vector<vector<int>> &dp) {\\n        if (dp[x][v] >= 0) {\\n            return dp[x][v];\\n        }\\n        if (dp[x][1] < 0) {\\n            dp[x][1] = 0;\\n            for (int y : con[x]) {\\n                if (y != p) {\\n                    dp[x][1] += dfs(con, c, y, x, 0, dp);\\n                }\\n            }\\n        }\\n        if (v == 1) {\\n            return dp[x][1];\\n        }\\n        dp[x][0] = c[x];\\n        for (int y : con[x]) {\\n            if (y != p) {\\n                dp[x][0] += dfs(con, c, y, x, 1, dp);\\n            }            \\n        }\\n        return dp[x][0] = max(dp[x][0], dp[x][1]);\\n        \\n        \\n    }\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> con(n);\\n        for (const auto& e : edges) {\\n            con[e[0]].push_back(e[1]);\\n            con[e[1]].push_back(e[0]);  \\n        }\\n        vector<int> d(n), f(n);\\n        dfs(con, 0, -1, 0, d, f);\\n        vector<int> t(n);\\n        for (const auto & v : trips) {\\n            int x = v[0], y = v[1];\\n            while (d[x] > d[y]) {\\n                ++t[x];\\n                x = f[x]; \\n            }\\n            while (d[x] < d[y]) {\\n                ++t[y];\\n                y = f[y]; \\n            }\\n            while (x != y) {\\n                ++t[x];\\n                x = f[x]; \\n                ++t[y];\\n                y = f[y]; \\n            }\\n            ++t[x];\\n        }\\n        int r = 0;\\n        for (int  i = 0; i < n; ++i) {\\n            t[i] *= price[i];\\n            r += t[i];\\n            t[i] >>= 1;\\n        }\\n        vector<vector<int>> dp(n, vector<int>(2, -1));\\n        return r - dfs(con, t, 0, -1, 0, dp);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673455,
                "title": "c-graph-pruning",
                "content": "# Intuition\\nIf we forget about reducing cost of alernate nodes. Problem asks for sum of cost of trips. Now we need to find how many times each node in graph has to be visited for making all trips. \\n\\nWe can also remove the nodes that are never visited during any of the trips.\\n\\nThen we can easily calculate the cost using recursion and memoize it later.\\n\\n# Approach\\nCreate an adjency matrix to represent the graph. Note here we create a `vector<unordered_set<int>>` which makes it easy to prune unvisted nodes later.\\n\\nFor each trip\\'s starting point try to find a path to the end. During recursion we keep track of nodes that we need to visit.\\n\\nExample \\n```\\nInput: n = 4\\nedges = [[0,1],[1,2],[1,3]]\\nprice = [2,2,10,6]\\ntrips = [[0,3],[2,1],[2,3]]\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/9b85d138-7da8-4641-a504-37cbcebdc2ce_1687519466.264249.png)\\n\\n```\\nnode  number of visits\\n0     1\\n1     3\\n2     2\\n3     2\\n\\nnode  total cost\\n0     2\\n1     6\\n2     20\\n3     12\\n```\\n\\nNow suppose we had another node `4` connected with `3` but it was not included in any trips. We would want to prune such nodes from our graph (note this process can create a disjoint graph)\\n\\nAt last we iterate over all trip\\'s starting points and get min cost for them.\\n\\n##### If a node is selected for cost reduction\\n- It\\'s children may not be selected\\n\\n##### If a node is not selected for cost reduction\\n- It\\'s children may or may not be selected \\n\\nIf this is the cost path `20 - 4 - 6 - 100` then it makes more sense to half 20 and 100 instead of following a bipartite graph approach.\\n\\n\\nDP state -`dp[node][selected]`represents min cost of node when it is selected and not\\n\\n# Complexity\\n>$$n$$ - number of nodes\\n$$e$$ - number of edges\\n$$trips$$ - number of trips\\n\\n#### Time complexity:\\n>Getting visit count for each node - $$O(trips * (n + e))$$\\nPruning the graph - $$O(n)$$\\nCalculating the optimal cost - $$O(2(n + e))$$\\n\\n#### Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n>Storing graph - $$O(n + e)$$\\nDP cache - $$O(2 * n)$$\\n\\n\\n#### Code\\n```\\nclass Solution {\\n    // function to count what nodes are visited during a \\n    // trip from start to end\\n    bool getPaths(int start, int end, vector<unordered_set<int>>& graph, vector<int>& vis, vector<int>& visited) {\\n        vis[start] = 1;\\n\\n        if (start == end) \\n            return true;\\n\\n        for (int i : graph[start]) {\\n            // current dfs path is only valid if we encounter end\\n            // down the line\\n            if (!vis[i] and getPaths(i, end, graph, vis, visited)) {\\n                ++visited[i];\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    int reduce(vector<unordered_set<int>>& graph, vector<int>& cost, int curr, bool half, vector<vector<int>>& dp, int parent = -1) {   \\n        if (dp[curr][half] != -1)\\n            return dp[curr][half];\\n\\n        int sub = 0;\\n        int total = half == true ? cost[curr] / 2 : cost[curr];\\n\\n        for (int i : graph[curr]) {\\n            // ignore the node we just came from\\n            if (i == parent) continue;\\n\\n            // get min cost of child w.r.t current node selection\\n            sub = reduce(graph, cost, i, !half, dp, curr);\\n            \\n            // if current node is not selected\\n            // also get cost of its child not getting selected\\n            if (!half) \\n                sub = min(reduce(graph, cost, i, half, dp, curr), sub);\\n\\n            total += sub;\\n        }\\n\\n        return dp[curr][half] = total;\\n    }\\n\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<unordered_set<int>> graph(n, unordered_set<int>());\\n\\n        for (auto& i : edges) {\\n            graph[i[0]].insert(i[1]);\\n            graph[i[1]].insert(i[0]);\\n        }\\n\\n        // store number of times a node is visited\\n        vector<int> cost(n, 0);\\n\\n        for (auto& i : trips) {\\n            vector<int> vis(n, 0);\\n\\n            getPaths(i[0], i[1], graph, vis, cost);\\n            ++cost[i[0]]; // start is missed in the count\\n        }\\n        \\n        for (int i = 0; i < n; ++i) {\\n            // total cost for visiting a node\\n            cost[i] *= price[i];\\n            \\n            // if cost is zero means this node has \\n            // not been visited and we can remove\\n            // it from the graph\\n            if (cost[i] == 0) {   \\n                // remove it from its children \\n                for (auto j : graph[i]) \\n                    graph[j].erase(i);\\n\\n                // remove the node itself\\n                graph[i].clear();\\n            }\\n        }\\n        \\n        // dp[i][j] will store min cost of\\n        // i th node when it has a cost reduction (j = 1)\\n        // i th node does not have a cost reduction (j = 0)\\n\\n        int ans = 0;\\n        vector<vector<int>> dp(n, vector<int>(2, -1));\\n\\n        // only need for this loop is in case of disjoint graph\\n        for (auto& i : trips) {\\n            int start = i[0];\\n\\n            if (dp[start][0] + dp[start][1] == -2) {\\n                // mark the node for cost reduction\\n                reduce(graph, cost, start, true, dp);\\n\\n                // unmark the node for cost reduction\\n                reduce(graph, cost, start, false, dp);\\n\\n                ans += min(dp[start][0], dp[start][1]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n<img src=https://assets.leetcode.com/users/images/1605128e-56b2-4510-884d-36c69ff02613_1684842163.263651.png alt=\"drawing\" width=\"250\"/>\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "```\\nInput: n = 4\\nedges = [[0,1],[1,2],[1,3]]\\nprice = [2,2,10,6]\\ntrips = [[0,3],[2,1],[2,3]]\\n```\n```\\nnode  number of visits\\n0     1\\n1     3\\n2     2\\n3     2\\n\\nnode  total cost\\n0     2\\n1     6\\n2     20\\n3     12\\n```\n```\\nclass Solution {\\n    // function to count what nodes are visited during a \\n    // trip from start to end\\n    bool getPaths(int start, int end, vector<unordered_set<int>>& graph, vector<int>& vis, vector<int>& visited) {\\n        vis[start] = 1;\\n\\n        if (start == end) \\n            return true;\\n\\n        for (int i : graph[start]) {\\n            // current dfs path is only valid if we encounter end\\n            // down the line\\n            if (!vis[i] and getPaths(i, end, graph, vis, visited)) {\\n                ++visited[i];\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    int reduce(vector<unordered_set<int>>& graph, vector<int>& cost, int curr, bool half, vector<vector<int>>& dp, int parent = -1) {   \\n        if (dp[curr][half] != -1)\\n            return dp[curr][half];\\n\\n        int sub = 0;\\n        int total = half == true ? cost[curr] / 2 : cost[curr];\\n\\n        for (int i : graph[curr]) {\\n            // ignore the node we just came from\\n            if (i == parent) continue;\\n\\n            // get min cost of child w.r.t current node selection\\n            sub = reduce(graph, cost, i, !half, dp, curr);\\n            \\n            // if current node is not selected\\n            // also get cost of its child not getting selected\\n            if (!half) \\n                sub = min(reduce(graph, cost, i, half, dp, curr), sub);\\n\\n            total += sub;\\n        }\\n\\n        return dp[curr][half] = total;\\n    }\\n\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<unordered_set<int>> graph(n, unordered_set<int>());\\n\\n        for (auto& i : edges) {\\n            graph[i[0]].insert(i[1]);\\n            graph[i[1]].insert(i[0]);\\n        }\\n\\n        // store number of times a node is visited\\n        vector<int> cost(n, 0);\\n\\n        for (auto& i : trips) {\\n            vector<int> vis(n, 0);\\n\\n            getPaths(i[0], i[1], graph, vis, cost);\\n            ++cost[i[0]]; // start is missed in the count\\n        }\\n        \\n        for (int i = 0; i < n; ++i) {\\n            // total cost for visiting a node\\n            cost[i] *= price[i];\\n            \\n            // if cost is zero means this node has \\n            // not been visited and we can remove\\n            // it from the graph\\n            if (cost[i] == 0) {   \\n                // remove it from its children \\n                for (auto j : graph[i]) \\n                    graph[j].erase(i);\\n\\n                // remove the node itself\\n                graph[i].clear();\\n            }\\n        }\\n        \\n        // dp[i][j] will store min cost of\\n        // i th node when it has a cost reduction (j = 1)\\n        // i th node does not have a cost reduction (j = 0)\\n\\n        int ans = 0;\\n        vector<vector<int>> dp(n, vector<int>(2, -1));\\n\\n        // only need for this loop is in case of disjoint graph\\n        for (auto& i : trips) {\\n            int start = i[0];\\n\\n            if (dp[start][0] + dp[start][1] == -2) {\\n                // mark the node for cost reduction\\n                reduce(graph, cost, start, true, dp);\\n\\n                // unmark the node for cost reduction\\n                reduce(graph, cost, start, false, dp);\\n\\n                ans += min(dp[start][0], dp[start][1]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3429427,
                "title": "easy-c-intuitive-solution",
                "content": "# Intuition\\n\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We want to choose which nodes need to be halved we find out the frequency of nodes in all the paths of the trips.\\n- If the parent is halved we can\\'t half the total cost of current node, otherwise we have choice to half it or not.\\n\\n\\n\\nUPVOTE IF HELPFUL !\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[51][2]; // node and whether its parent halved or not\\n    int dphelp(int node, int par, vector<int> &price, vector<int> &contribution, int parHalved, vector<vector<int>> &adj){\\n        int full=contribution[node]*price[node];\\n        int half=contribution[node]*price[node]/2;\\n\\n        if(dp[node][parHalved]!=-1)return dp[node][parHalved];\\n\\n        for(auto &it: adj[node]){\\n            if(it!=par){\\n                full+=dphelp(it,node, price,contribution, 0, adj);\\n            }\\n        }\\n\\n        if(parHalved==true)return dp[node][parHalved]=full;\\n\\n        for(auto &it: adj[node]){\\n            if(it!=par){\\n                half+=dphelp(it, node, price, contribution, 1, adj);\\n            }\\n        }\\n\\n        return dp[node][parHalved]=min(full, half);\\n    }\\n\\n\\n    void makeContributions(int node, int e, vector<vector<int>> &adj, vector<int> &tmp,vector<int> &contribution, int par){\\n        tmp.push_back(node);\\n        if(node==e){\\n            for(auto &it: tmp){\\n                contribution[it]++;\\n            }\\n            tmp.pop_back();\\n            return;\\n        }\\n        for(auto &it: adj[node]){\\n            if(it!=par){\\n                makeContributions(it,e,adj,tmp,contribution,node);\\n            }\\n        }\\n        tmp.pop_back();\\n        return;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> adj(n);\\n        memset(dp, -1, sizeof(dp));\\n\\n        //adjacency matrix;\\n        for(auto &it: edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n\\n        // creating a contribution vector\\n        vector<int> contribution(n,0);\\n        for(auto &it: trips){\\n            vector<int> tmp;\\n            makeContributions(it[0], it[1], adj,tmp,contribution, -1);\\n        }\\n\\n        // dp on the basis of (node, parent was taken or not)\\n        return dphelp(0,-1,price, contribution, 0, adj);\\n\\n    }\\n};\\n```\\n# \\nUPVOTE IF HELPFUL !\\n![1647845206317.jpeg](https://assets.leetcode.com/users/images/56e8558c-59b1-4684-9c21-34427ea19354_1681795048.2268593.jpeg)\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[51][2]; // node and whether its parent halved or not\\n    int dphelp(int node, int par, vector<int> &price, vector<int> &contribution, int parHalved, vector<vector<int>> &adj){\\n        int full=contribution[node]*price[node];\\n        int half=contribution[node]*price[node]/2;\\n\\n        if(dp[node][parHalved]!=-1)return dp[node][parHalved];\\n\\n        for(auto &it: adj[node]){\\n            if(it!=par){\\n                full+=dphelp(it,node, price,contribution, 0, adj);\\n            }\\n        }\\n\\n        if(parHalved==true)return dp[node][parHalved]=full;\\n\\n        for(auto &it: adj[node]){\\n            if(it!=par){\\n                half+=dphelp(it, node, price, contribution, 1, adj);\\n            }\\n        }\\n\\n        return dp[node][parHalved]=min(full, half);\\n    }\\n\\n\\n    void makeContributions(int node, int e, vector<vector<int>> &adj, vector<int> &tmp,vector<int> &contribution, int par){\\n        tmp.push_back(node);\\n        if(node==e){\\n            for(auto &it: tmp){\\n                contribution[it]++;\\n            }\\n            tmp.pop_back();\\n            return;\\n        }\\n        for(auto &it: adj[node]){\\n            if(it!=par){\\n                makeContributions(it,e,adj,tmp,contribution,node);\\n            }\\n        }\\n        tmp.pop_back();\\n        return;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> adj(n);\\n        memset(dp, -1, sizeof(dp));\\n\\n        //adjacency matrix;\\n        for(auto &it: edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n\\n        // creating a contribution vector\\n        vector<int> contribution(n,0);\\n        for(auto &it: trips){\\n            vector<int> tmp;\\n            makeContributions(it[0], it[1], adj,tmp,contribution, -1);\\n        }\\n\\n        // dp on the basis of (node, parent was taken or not)\\n        return dphelp(0,-1,price, contribution, 0, adj);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423587,
                "title": "java-dp-solution",
                "content": "\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n     int con[] ;\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n       \\n        ArrayList<Integer> al[] = new ArrayList[n];\\n        for(int i=0;i<n;i++) al[i] = new ArrayList<>();\\n        for(int i=0;i<edges.length;i++){\\n            al[edges[i][0]].add(edges[i][1]);\\n            al[edges[i][1]].add(edges[i][0]);\\n        }\\n        con = new int[n];\\n        for(int i=0;i<trips.length;i++){\\n            int aa = trips[i][0];\\n            int bb = trips[i][1];\\n            ArrayList<Integer> all = new ArrayList<>();\\n             con[aa]++;\\n            dfs(aa,bb,al,-1);\\n            \\n        }\\n    \\n        dp = new int[n][2];\\n           for(int i=0;i<n;i++){\\n               Arrays.fill(dp[i],-1);\\n           }\\n      \\n        return solve(0,-1,0,al,price);\\n        \\n    }\\n    \\n    public int solve(int node,int par,int use, ArrayList<Integer> al[],int pr[]){\\n        \\n        int u = con[node]*pr[node]/2;\\n        int uu = con[node]*pr[node];\\n        if(dp[node][use]!=-1) return dp[node][use];\\n        for(int v:al[node]){\\n            if(v!=par){\\n                uu += solve(v,node,0,al,pr);\\n            }\\n        }\\n        if(use==1) return dp[node][use] = uu;\\n        \\n        for(int v:al[node]){\\n            if(v!=par){\\n                u += solve(v,node,1,al,pr);\\n            }\\n        }\\n        return dp[node][use] = Math.min(u,uu);\\n    }\\n    \\n    int dp[][];\\n    public boolean dfs(int s,int d,ArrayList<Integer> al[],int par){\\n        \\n        if(s==d){\\n            return true;\\n        }\\n        \\n        for(int v:al[s]){\\n            if(v!=par){\\n                if(dfs(v,d,al,s)){\\n                    con[v]++;\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n     int con[] ;\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n       \\n        ArrayList<Integer> al[] = new ArrayList[n];\\n        for(int i=0;i<n;i++) al[i] = new ArrayList<>();\\n        for(int i=0;i<edges.length;i++){\\n            al[edges[i][0]].add(edges[i][1]);\\n            al[edges[i][1]].add(edges[i][0]);\\n        }\\n        con = new int[n];\\n        for(int i=0;i<trips.length;i++){\\n            int aa = trips[i][0];\\n            int bb = trips[i][1];\\n            ArrayList<Integer> all = new ArrayList<>();\\n             con[aa]++;\\n            dfs(aa,bb,al,-1);\\n            \\n        }\\n    \\n        dp = new int[n][2];\\n           for(int i=0;i<n;i++){\\n               Arrays.fill(dp[i],-1);\\n           }\\n      \\n        return solve(0,-1,0,al,price);\\n        \\n    }\\n    \\n    public int solve(int node,int par,int use, ArrayList<Integer> al[],int pr[]){\\n        \\n        int u = con[node]*pr[node]/2;\\n        int uu = con[node]*pr[node];\\n        if(dp[node][use]!=-1) return dp[node][use];\\n        for(int v:al[node]){\\n            if(v!=par){\\n                uu += solve(v,node,0,al,pr);\\n            }\\n        }\\n        if(use==1) return dp[node][use] = uu;\\n        \\n        for(int v:al[node]){\\n            if(v!=par){\\n                u += solve(v,node,1,al,pr);\\n            }\\n        }\\n        return dp[node][use] = Math.min(u,uu);\\n    }\\n    \\n    int dp[][];\\n    public boolean dfs(int s,int d,ArrayList<Integer> al[],int par){\\n        \\n        if(s==d){\\n            return true;\\n        }\\n        \\n        for(int v:al[s]){\\n            if(v!=par){\\n                if(dfs(v,d,al,s)){\\n                    con[v]++;\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422336,
                "title": "c-dp-on-trees",
                "content": "Here for every trip we compute a path between start to end.\\nAll this nodes will contribute their prices to the ans by a factor of 1.\\nSo we will create a freq array which will store how many time this node comes in the path\\n\\nAfter computing the freq array, all we need to do is pick non-adjacent nodes and decrease the prices by half\\nSo for this we will use dp.\\n\\nif we can half the price\\n\\tnewPrice = price / 2\\n\\tcost = freq[node] * newPrice\\n\\t(as freq is the no. of times it will contribute the price\\nelse \\n\\tcost = freq[node] * orgPrice\\n\\n**C++ Implementation:**\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> freq;\\n    vector<vector<int>> adj;\\n    vector<int> path;\\n    vector<int> price;\\n    \\n    bool dfs(int curr, int par, int end) {\\n        path.push_back(curr);\\n        if(curr == end) return true;\\n        \\n        for(auto it: adj[curr]) {\\n            if(it == par) continue;\\n            if(dfs(it, curr, end)) {\\n                return true;\\n            }\\n        }\\n        \\n        path.pop_back();\\n        return false;\\n    }\\n    \\n    #define vi vector<int>\\n    #define vvi vector<vi>\\n    \\n    vvi dp;\\n    \\n    int helper(int curr, int par, bool canHalf) {\\n        if(dp[curr][canHalf] != -1) \\n            return dp[curr][canHalf];\\n        \\n        int pick = INT_MAX;\\n        \\n        if(canHalf) {\\n            pick = 0;\\n            int p = price[curr] / 2;\\n            pick += p * freq[curr];\\n            for(auto it: adj[curr]) {\\n                if(it == par) continue;\\n                pick += helper(it, curr, false);\\n            }\\n        }\\n        \\n        int not_pick = price[curr] * freq[curr];\\n        for(auto it: adj[curr]) {\\n            if(it == par) continue;\\n            not_pick += helper(it, curr, true);\\n        }\\n        \\n        return dp[curr][canHalf] = min(pick, not_pick);\\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        this->price = price;\\n        freq = vector<int>(n, 0);\\n        adj = vector<vector<int>>(n);\\n        for(auto &edge: edges) {\\n            int u = edge[0], v = edge[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        for(auto &trip: trips) {\\n            int start = trip[0], end = trip[1];\\n            dfs(start, -1, end);\\n            \\n            for(auto it: path)\\n                freq[it]++;\\n    \\n            path.clear();\\n        }\\n        \\n        dp = vvi(n, vi(2, -1));\\n        return helper(0, -1, true);\\n    }\\n};\\n```\\n\\nTime Complexity = O(trips * n) + O(2n)\\n\\nI am not good with writing so please bear with that ;)\\nIf it helped please upvote :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> freq;\\n    vector<vector<int>> adj;\\n    vector<int> path;\\n    vector<int> price;\\n    \\n    bool dfs(int curr, int par, int end) {\\n        path.push_back(curr);\\n        if(curr == end) return true;\\n        \\n        for(auto it: adj[curr]) {\\n            if(it == par) continue;\\n            if(dfs(it, curr, end)) {\\n                return true;\\n            }\\n        }\\n        \\n        path.pop_back();\\n        return false;\\n    }\\n    \\n    #define vi vector<int>\\n    #define vvi vector<vi>\\n    \\n    vvi dp;\\n    \\n    int helper(int curr, int par, bool canHalf) {\\n        if(dp[curr][canHalf] != -1) \\n            return dp[curr][canHalf];\\n        \\n        int pick = INT_MAX;\\n        \\n        if(canHalf) {\\n            pick = 0;\\n            int p = price[curr] / 2;\\n            pick += p * freq[curr];\\n            for(auto it: adj[curr]) {\\n                if(it == par) continue;\\n                pick += helper(it, curr, false);\\n            }\\n        }\\n        \\n        int not_pick = price[curr] * freq[curr];\\n        for(auto it: adj[curr]) {\\n            if(it == par) continue;\\n            not_pick += helper(it, curr, true);\\n        }\\n        \\n        return dp[curr][canHalf] = min(pick, not_pick);\\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        this->price = price;\\n        freq = vector<int>(n, 0);\\n        adj = vector<vector<int>>(n);\\n        for(auto &edge: edges) {\\n            int u = edge[0], v = edge[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        for(auto &trip: trips) {\\n            int start = trip[0], end = trip[1];\\n            dfs(start, -1, end);\\n            \\n            for(auto it: path)\\n                freq[it]++;\\n    \\n            path.clear();\\n        }\\n        \\n        dp = vvi(n, vi(2, -1));\\n        return helper(0, -1, true);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422244,
                "title": "dfs-dp-simple-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to find the min cost in this problem, so we have to try out all possible cases. DP is the answer for that. \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst I have counted the number of times a node is visited during all the trips. Since, it\\'s a tree so there is only one possible path between two nodes i.e, unique path for each trip. \\n\\nWe have calculated frequency, so that we don\\'t have to find the cost for all trips each time. \\n\\nNow, all the nodes that are not visited during any trip has frequency = 0 so they, will not afftect our answer. \\n\\nRun a DFS with variable lastPicked, which represents we have halved the price in previous iteration or not. \\nWe need the parent node, to take care of visted nodes. \\nSo our DP has 3 states -> node, parent, lastPicked.\\n\\nWe will switch states using the variable lastPicked. If lastPicked is 0, we can half the current node\\'s price. Else we have don\\'t have option to half the price for current level.  \\n\\nNote : I have passed n as the parent of first node because we can\\'t access the -1 index in DP.\\n\\n# Complexity\\n- Time complexity: O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool countFrequecy(int node, int dest,vector<int> adj[],vector<int>&freq, int par)\\n    {\\n        if(node==dest)  // reached the destination\\n            return 1;\\n        bool ans =0;\\n        for(auto x:adj[node])\\n        {\\n            if(x!=par)\\n            {\\n                if(countFrequecy(x,dest,adj,freq,node)) // If destination is in current path\\n                {\\n                    freq[x]++; //incrementing the freq of nodes in the path\\n                    ans=1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int minCost(int node, int par, int lastPicked,vector<int>& price,vector<int> adj[],vector<int>&freq,vector<vector<vector<int>>>&dp)\\n    {\\n        int ans = 1e9,res=0;\\n        if(dp[node][par][lastPicked]!=-1)\\n            return dp[node][par][lastPicked];\\n        if(lastPicked) // if we picked the last i.e, node then price = price/2\\n            res = freq[node]*(price[node]/2);\\n        else\\n            res = freq[node]*(price[node]);\\n        \\n        for(auto x:adj[node])\\n        {\\n            if(x!=par) \\n            {\\n                ans=minCost(x,node,0,price,adj,freq,dp);\\n                if(lastPicked==0)  \\n                    ans = min(ans,minCost(x,node,1,price,adj,freq,dp));\\n                res+=ans;\\n            }\\n        }\\n        return dp[node][par][lastPicked] = res;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> freq(n,0);\\n        vector<int> adj[n+1];\\n        for(int i=0;i<n-1;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(auto x:trips)\\n        {   countFrequecy(x[0],x[1],adj,freq,-1);\\n            freq[x[0]]++;\\n        }\\n       \\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(n+1,vector<int>(2,-1)));\\n        return min(minCost(0,n,0,price,adj,freq,dp),minCost(0,n,1,price,adj,freq,dp));\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool countFrequecy(int node, int dest,vector<int> adj[],vector<int>&freq, int par)\\n    {\\n        if(node==dest)  // reached the destination\\n            return 1;\\n        bool ans =0;\\n        for(auto x:adj[node])\\n        {\\n            if(x!=par)\\n            {\\n                if(countFrequecy(x,dest,adj,freq,node)) // If destination is in current path\\n                {\\n                    freq[x]++; //incrementing the freq of nodes in the path\\n                    ans=1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int minCost(int node, int par, int lastPicked,vector<int>& price,vector<int> adj[],vector<int>&freq,vector<vector<vector<int>>>&dp)\\n    {\\n        int ans = 1e9,res=0;\\n        if(dp[node][par][lastPicked]!=-1)\\n            return dp[node][par][lastPicked];\\n        if(lastPicked) // if we picked the last i.e, node then price = price/2\\n            res = freq[node]*(price[node]/2);\\n        else\\n            res = freq[node]*(price[node]);\\n        \\n        for(auto x:adj[node])\\n        {\\n            if(x!=par) \\n            {\\n                ans=minCost(x,node,0,price,adj,freq,dp);\\n                if(lastPicked==0)  \\n                    ans = min(ans,minCost(x,node,1,price,adj,freq,dp));\\n                res+=ans;\\n            }\\n        }\\n        return dp[node][par][lastPicked] = res;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> freq(n,0);\\n        vector<int> adj[n+1];\\n        for(int i=0;i<n-1;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(auto x:trips)\\n        {   countFrequecy(x[0],x[1],adj,freq,-1);\\n            freq[x[0]]++;\\n        }\\n       \\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(n+1,vector<int>(2,-1)));\\n        return min(minCost(0,n,0,price,adj,freq,dp),minCost(0,n,1,price,adj,freq,dp));\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422222,
                "title": "c-solution-used-lambdas",
                "content": "## Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we half the price of this current node, we can not half for its children.\\nIf we don\\'t hlaf the price of this current node, we can or can not half for its children. ( 2 choices , take min of those)\\n\\n## Complexity\\n- Time complexity:\\n- O(N^2)   \\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector <vector<int>> g(n);\\n        for (auto e: edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        vector <int> cnt(n);\\n\\n        auto bfs = [&](int s, int t) -> void {\\n            vector <int> par(n, -1);\\n            queue <int> Q;\\n            Q.push(s);\\n            while (!Q.empty()) {\\n                int x = Q.front();\\n                Q.pop();\\n                for (auto &v: g[x]) {\\n                    if (par[v] == -1 and v != s) {\\n                        par[v] = x;\\n                        Q.push(v);\\n                    }\\n                }\\n            } \\n            int cur = t;\\n            while (par[cur] != -1) {\\n                cnt[cur]++;\\n                cur = par[cur];\\n            }\\n            cnt[s]++;\\n        };\\n\\n        for (auto trip: trips) {\\n            int x = trip[0];\\n            int y = trip[1];\\n            bfs(x, y);\\n        }\\n        \\n        int cached[n][2];\\n        memset(cached, -1, sizeof cached);\\n\\n        function<int(int, int, int)> go = [&](int node, int p, int is) -> int {\\n            if (cached[node][is] != -1) return cached[node][is];\\n            int new_p = price[node] / (is ? 2 : 1);\\n            int res = cnt[node] * new_p;\\n            for (auto &v: g[node]) {\\n                if (v != p) {\\n                    if (is) {\\n                        res += go(v, node, 0);\\n                    } else {\\n                        res += min(go(v, node, 0), go(v, node, 1));\\n                    }\\n                }\\n            }\\n            return cached[node][is] = res;\\n        };\\n\\n        return min(go(0, -1, 0), go(0, -1, 1));\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector <vector<int>> g(n);\\n        for (auto e: edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        vector <int> cnt(n);\\n\\n        auto bfs = [&](int s, int t) -> void {\\n            vector <int> par(n, -1);\\n            queue <int> Q;\\n            Q.push(s);\\n            while (!Q.empty()) {\\n                int x = Q.front();\\n                Q.pop();\\n                for (auto &v: g[x]) {\\n                    if (par[v] == -1 and v != s) {\\n                        par[v] = x;\\n                        Q.push(v);\\n                    }\\n                }\\n            } \\n            int cur = t;\\n            while (par[cur] != -1) {\\n                cnt[cur]++;\\n                cur = par[cur];\\n            }\\n            cnt[s]++;\\n        };\\n\\n        for (auto trip: trips) {\\n            int x = trip[0];\\n            int y = trip[1];\\n            bfs(x, y);\\n        }\\n        \\n        int cached[n][2];\\n        memset(cached, -1, sizeof cached);\\n\\n        function<int(int, int, int)> go = [&](int node, int p, int is) -> int {\\n            if (cached[node][is] != -1) return cached[node][is];\\n            int new_p = price[node] / (is ? 2 : 1);\\n            int res = cnt[node] * new_p;\\n            for (auto &v: g[node]) {\\n                if (v != p) {\\n                    if (is) {\\n                        res += go(v, node, 0);\\n                    } else {\\n                        res += min(go(v, node, 0), go(v, node, 1));\\n                    }\\n                }\\n            }\\n            return cached[node][is] = res;\\n        };\\n\\n        return min(go(0, -1, 0), go(0, -1, 1));\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421754,
                "title": "java-solution-using-dfs-memoisation-for-better-run-time",
                "content": "# Intuition\\nThe main idean here is that you can not decide the nodes to half the cost without knowing the number of times a node is visited.\\nSo first run a simple BFS or DFS and count the number of times a node will be visited. I personally prefer DFS for this situation because of simplicity of code.\\n\\nOnce you have this number, you can find the total cost a node will contribute towards final cost after taking all the trips.\\nNow we need to half the price of few of the nodes. The key here is that they are not suppose to be neighbours but that doesn\\'t mean you can alternate between the nodes.\\neg: a -> b -> c -> d\\nin this case it might be possible that best value will come if you half the price of `a and d` instead of `a and c`; or it can also happen that you must choose `b`\\n\\nSo you need to find the minimum from all these options.\\nYou can again use DFS here and use memoisation to improve the runtime\\n\\n# Approach\\nDFS + Memoisation\\n\\n# Complexity\\n- Time complexity:\\nO(N * N)\\n\\n- Space complexity:\\nO(E + N) = O(N)\\nsince it\\'s a tree, number of edges == number of nodes - 1\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        List<Integer>[] tree = buildTree(n, edges);\\n        \\n        int[] visitCount = new int[n];\\n        for(int[] trip : trips) {\\n            travel(trip[0], -1, trip[1], tree, visitCount);\\n        }\\n        \\n        int[] cost = new int[n];\\n        int[][] calcualted = new int[n][2];\\n        for(int i = 0; i < n; i++) {\\n            Arrays.fill(calcualted[i], -1);\\n            cost[i] = price[i] * visitCount[i];\\n        }\\n        \\n        return minPrice(trips[0][0], -1, tree, 1, cost, calcualted);\\n    }\\n    \\n    private int minPrice(int node, int parent, List<Integer>[] tree, int canHalf, int[] cost, int[][] calculated) {\\n        if (calculated[node][canHalf] != -1) {\\n            return calculated[node][canHalf];\\n        }\\n        \\n        int minPrice;\\n        \\n        int noHalfCurrentNodePrice = cost[node];\\n        for(int next : tree[node]) {\\n            if (next != parent) {\\n                noHalfCurrentNodePrice += minPrice(next, node, tree, 1, cost, calculated);\\n            }\\n        }\\n        \\n        int halfCurrentNodePrice = Integer.MAX_VALUE;\\n        if (canHalf == 1) {\\n            halfCurrentNodePrice = cost[node] / 2;\\n            \\n            for(int next : tree[node]) {\\n                if (next != parent) {\\n                    halfCurrentNodePrice += minPrice(next, node, tree, 0, cost, calculated);\\n                }\\n            }\\n        }\\n        \\n        calculated[node][canHalf] = Math.min(noHalfCurrentNodePrice, halfCurrentNodePrice);\\n        \\n        return calculated[node][canHalf];\\n    }\\n    \\n    private boolean travel(int node, int parent, int target, List<Integer>[] tree, int[] visitCount) {\\n        if (node == target) {\\n            visitCount[node]++;\\n            return true;\\n        }\\n\\n        boolean found = false;\\n        for(int next : tree[node]) {\\n            if (parent != next) {\\n                found |= travel(next, node, target, tree, visitCount);\\n            }\\n            \\n            if (found) {\\n                break;\\n            }\\n        }\\n        \\n        if (found) {\\n            visitCount[node]++;\\n        }\\n        \\n        return found;\\n    }\\n    \\n    private List<Integer>[] buildTree(int n, int[][] edges) {\\n        List<Integer>[] tree = new ArrayList[n];\\n        for(int i = 0; i < n; i++) {\\n            tree[i] = new ArrayList<Integer>();\\n        }\\n        \\n        for(int[] edge : edges) {\\n            tree[edge[0]].add(edge[1]);\\n            tree[edge[1]].add(edge[0]);\\n        }\\n        \\n        return tree;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        List<Integer>[] tree = buildTree(n, edges);\\n        \\n        int[] visitCount = new int[n];\\n        for(int[] trip : trips) {\\n            travel(trip[0], -1, trip[1], tree, visitCount);\\n        }\\n        \\n        int[] cost = new int[n];\\n        int[][] calcualted = new int[n][2];\\n        for(int i = 0; i < n; i++) {\\n            Arrays.fill(calcualted[i], -1);\\n            cost[i] = price[i] * visitCount[i];\\n        }\\n        \\n        return minPrice(trips[0][0], -1, tree, 1, cost, calcualted);\\n    }\\n    \\n    private int minPrice(int node, int parent, List<Integer>[] tree, int canHalf, int[] cost, int[][] calculated) {\\n        if (calculated[node][canHalf] != -1) {\\n            return calculated[node][canHalf];\\n        }\\n        \\n        int minPrice;\\n        \\n        int noHalfCurrentNodePrice = cost[node];\\n        for(int next : tree[node]) {\\n            if (next != parent) {\\n                noHalfCurrentNodePrice += minPrice(next, node, tree, 1, cost, calculated);\\n            }\\n        }\\n        \\n        int halfCurrentNodePrice = Integer.MAX_VALUE;\\n        if (canHalf == 1) {\\n            halfCurrentNodePrice = cost[node] / 2;\\n            \\n            for(int next : tree[node]) {\\n                if (next != parent) {\\n                    halfCurrentNodePrice += minPrice(next, node, tree, 0, cost, calculated);\\n                }\\n            }\\n        }\\n        \\n        calculated[node][canHalf] = Math.min(noHalfCurrentNodePrice, halfCurrentNodePrice);\\n        \\n        return calculated[node][canHalf];\\n    }\\n    \\n    private boolean travel(int node, int parent, int target, List<Integer>[] tree, int[] visitCount) {\\n        if (node == target) {\\n            visitCount[node]++;\\n            return true;\\n        }\\n\\n        boolean found = false;\\n        for(int next : tree[node]) {\\n            if (parent != next) {\\n                found |= travel(next, node, target, tree, visitCount);\\n            }\\n            \\n            if (found) {\\n                break;\\n            }\\n        }\\n        \\n        if (found) {\\n            visitCount[node]++;\\n        }\\n        \\n        return found;\\n    }\\n    \\n    private List<Integer>[] buildTree(int n, int[][] edges) {\\n        List<Integer>[] tree = new ArrayList[n];\\n        for(int i = 0; i < n; i++) {\\n            tree[i] = new ArrayList<Integer>();\\n        }\\n        \\n        for(int[] edge : edges) {\\n            tree[edge[0]].add(edge[1]);\\n            tree[edge[1]].add(edge[0]);\\n        }\\n        \\n        return tree;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421669,
                "title": "javascript-bfs-dfs",
                "content": "**Solution: BFS & DFS**\\n\\nSince it\\'s a tree, there is only one path between each pair of nodes.\\n\\n1. For each trip, use BFS to find the path from the start node to the end node.\\n  Keep track of totalPrice, where `totalPrice[i] = the total price from node i across all trips`.\\n  \\n2. Use DFS with memoization to find the minimum score from taking half price on non-alternate nodes.\\n  Memoize each `dfs(node, parentIsHalfPrice, parent)`.\\n  If the parent is half price, then this node cannot be half price.\\n  If the parent is not half price, we have two choices: either take half price or don\\'t take half price.\\n  Return the minimum price.\\n\\n`n = number of nodes`, `m = number of trips`\\nTime Complexity: `O(m * n^2 + n^2)`\\nSpace Complexity: `O(n)`\\n```\\nvar minimumTotalPrice = function(n, edges, price, trips) {\\n  let graph = Array(n).fill(0).map(() => []);\\n  for (let [a, b] of edges) {\\n    graph[a].push(b);\\n    graph[b].push(a);\\n  }\\n  let totalPrice = Array(n).fill(0);\\n  for (let [start, end] of trips) {\\n    let path = makeTrip(start, end);\\n    for (let node of path) {\\n      totalPrice[node] += price[node];\\n    }\\n  }\\n  let memo = new Map();\\n  return dfs(0, false, -1);\\n  \\n  function dfs(node, parentIsHalfPrice, parent) { // dfs with memoization to find the lowest price  \\n    let key = `${node},${parentIsHalfPrice},${parent}`;\\n    if (memo.has(key)) return memo.get(key);\\n\\n    if (parentIsHalfPrice) {\\n      let ans = totalPrice[node];\\n      for (let nei of graph[node]) {\\n        if (nei === parent) continue;\\n        ans += dfs(nei, false, node);\\n      }\\n      memo.set(key, ans);\\n      return ans;\\n    }\\n    \\n    let takeHalfPrice = totalPrice[node] / 2, noHalfPrice = totalPrice[node];\\n    for (let nei of graph[node]) {\\n      if (nei === parent) continue;\\n      takeHalfPrice += dfs(nei, true, node);\\n      noHalfPrice += dfs(nei, false, node);\\n    }\\n    let ans = Math.min(takeHalfPrice, noHalfPrice);\\n    memo.set(key, ans);\\n    return ans;\\n  }\\n  \\n  function makeTrip(start, end) { // bfs to find the path from start to end\\n    let queue = [[start, [start]]], seen = Array(n).fill(0);\\n    seen[start] = 1;\\n    while (queue.length) {\\n      let [node, path] = queue.shift();\\n      if (node === end) return path;\\n      for (let nei of graph[node]) {\\n        if (seen[nei]) continue;\\n        seen[nei] = 1;\\n        queue.push([nei, [...path, nei]]);\\n      }\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumTotalPrice = function(n, edges, price, trips) {\\n  let graph = Array(n).fill(0).map(() => []);\\n  for (let [a, b] of edges) {\\n    graph[a].push(b);\\n    graph[b].push(a);\\n  }\\n  let totalPrice = Array(n).fill(0);\\n  for (let [start, end] of trips) {\\n    let path = makeTrip(start, end);\\n    for (let node of path) {\\n      totalPrice[node] += price[node];\\n    }\\n  }\\n  let memo = new Map();\\n  return dfs(0, false, -1);\\n  \\n  function dfs(node, parentIsHalfPrice, parent) { // dfs with memoization to find the lowest price  \\n    let key = `${node},${parentIsHalfPrice},${parent}`;\\n    if (memo.has(key)) return memo.get(key);\\n\\n    if (parentIsHalfPrice) {\\n      let ans = totalPrice[node];\\n      for (let nei of graph[node]) {\\n        if (nei === parent) continue;\\n        ans += dfs(nei, false, node);\\n      }\\n      memo.set(key, ans);\\n      return ans;\\n    }\\n    \\n    let takeHalfPrice = totalPrice[node] / 2, noHalfPrice = totalPrice[node];\\n    for (let nei of graph[node]) {\\n      if (nei === parent) continue;\\n      takeHalfPrice += dfs(nei, true, node);\\n      noHalfPrice += dfs(nei, false, node);\\n    }\\n    let ans = Math.min(takeHalfPrice, noHalfPrice);\\n    memo.set(key, ans);\\n    return ans;\\n  }\\n  \\n  function makeTrip(start, end) { // bfs to find the path from start to end\\n    let queue = [[start, [start]]], seen = Array(n).fill(0);\\n    seen[start] = 1;\\n    while (queue.length) {\\n      let [node, path] = queue.shift();\\n      if (node === end) return path;\\n      for (let nei of graph[node]) {\\n        if (seen[nei]) continue;\\n        seen[nei] = 1;\\n        queue.push([nei, [...path, nei]]);\\n      }\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3964325,
                "title": "c-tree-pruning-recursion-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool rec(int src,int dest,vector<vector<int>> &adj,vector<int> &freq,int parent){\\n        if(src==dest){\\n            freq[dest]++;\\n            return true;\\n        }\\n        \\n        for(auto neg:adj[src]){\\n            if(neg != parent){\\n                bool w = rec(neg,dest,adj,freq,src);\\n                if(w){\\n                   freq[src]++;\\n                   return w;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\nint helper(int src,int prev,int parent,vector<vector<int>> &adj,vector<vector<vector<int>>> &dp,vector<int> &price,vector<int> &vis){\\n     \\n        vis[src] =0;\\n        if(adj[src].size()==0)  return price[src]/2;\\n\\n        if(adj[src].size() == 1){\\n            if(adj[src][0] == parent){\\n                if(prev != parent) return price[src]/2;\\n                else  return price[src];\\n            }\\n        }\\n        if(prev!=-1 && parent !=-2 && dp[src][prev+1][parent+2]!=-1) return dp[src][prev+1][parent+2];\\n        bool w=true;\\n        if(prev==parent) w =false;\\n        int  ans =0;\\n        if(w){\\n            int ans1=0,ans2=0;\\n            for(auto neg:adj[src]){\\n                if(neg!=parent){    \\n                 ans1 +=  helper(neg,src,src,adj,dp,price,vis);\\n                 ans2 +=  helper(neg,prev,src,adj,dp,price,vis);\\n                }\\n            }\\n            ans = min(ans1+price[src]/2,ans2+price[src]);\\n        }\\n        else{\\n            int ans3=0;\\n            for(auto neg:adj[src])\\n                if(neg!=parent)  ans3 +=helper(neg,prev,src,adj,dp,price,vis); \\n\\n            ans = ans3+price[src];\\n        }\\n        return dp[src][prev+1][parent+2] =ans;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        // return 0;\\n        vector<vector<int>> adj1(n);\\n        int m =edges.size();\\n        for(int i=0;i<m;i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj1[u].push_back(v);\\n            adj1[v].push_back(u);\\n        }\\n        vector<int> freq(n,0);\\n        for(int i=0;i<trips.size();i++)\\n           rec(trips[i][0],trips[i][1],adj1,freq,-1);\\n        vector<vector<int>> adj2(n);\\n        for(int i=0;i<m;i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            if(freq[u] != 0 && freq[v] != 0){\\n                adj2[u].push_back(v);\\n                adj2[v].push_back(u);\\n            }\\n        }\\n\\n        int mxi=-1,mx=1e9;\\n        for(int i=0;i<n;i++){\\n            price[i]= price[i]*freq[i];\\n            if(freq[i]<mx && freq[i]>0){\\n                mx=freq[i];\\n                mxi=i;\\n            }\\n        }\\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>> (n+2,vector<int>(n+3,-1)));\\n        int ans = helper(mxi,-1,-2,adj2,dp,price,freq);\\n        for(int i=0;i<n;i++){\\n            if(freq[i]>0){\\n                ans+=helper(i,-1,-2,adj2,dp,price,freq);\\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool rec(int src,int dest,vector<vector<int>> &adj,vector<int> &freq,int parent){\\n        if(src==dest){\\n            freq[dest]++;\\n            return true;\\n        }\\n        \\n        for(auto neg:adj[src]){\\n            if(neg != parent){\\n                bool w = rec(neg,dest,adj,freq,src);\\n                if(w){\\n                   freq[src]++;\\n                   return w;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\nint helper(int src,int prev,int parent,vector<vector<int>> &adj,vector<vector<vector<int>>> &dp,vector<int> &price,vector<int> &vis){\\n     \\n        vis[src] =0;\\n        if(adj[src].size()==0)  return price[src]/2;\\n\\n        if(adj[src].size() == 1){\\n            if(adj[src][0] == parent){\\n                if(prev != parent) return price[src]/2;\\n                else  return price[src];\\n            }\\n        }\\n        if(prev!=-1 && parent !=-2 && dp[src][prev+1][parent+2]!=-1) return dp[src][prev+1][parent+2];\\n        bool w=true;\\n        if(prev==parent) w =false;\\n        int  ans =0;\\n        if(w){\\n            int ans1=0,ans2=0;\\n            for(auto neg:adj[src]){\\n                if(neg!=parent){    \\n                 ans1 +=  helper(neg,src,src,adj,dp,price,vis);\\n                 ans2 +=  helper(neg,prev,src,adj,dp,price,vis);\\n                }\\n            }\\n            ans = min(ans1+price[src]/2,ans2+price[src]);\\n        }\\n        else{\\n            int ans3=0;\\n            for(auto neg:adj[src])\\n                if(neg!=parent)  ans3 +=helper(neg,prev,src,adj,dp,price,vis); \\n\\n            ans = ans3+price[src];\\n        }\\n        return dp[src][prev+1][parent+2] =ans;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        // return 0;\\n        vector<vector<int>> adj1(n);\\n        int m =edges.size();\\n        for(int i=0;i<m;i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj1[u].push_back(v);\\n            adj1[v].push_back(u);\\n        }\\n        vector<int> freq(n,0);\\n        for(int i=0;i<trips.size();i++)\\n           rec(trips[i][0],trips[i][1],adj1,freq,-1);\\n        vector<vector<int>> adj2(n);\\n        for(int i=0;i<m;i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            if(freq[u] != 0 && freq[v] != 0){\\n                adj2[u].push_back(v);\\n                adj2[v].push_back(u);\\n            }\\n        }\\n\\n        int mxi=-1,mx=1e9;\\n        for(int i=0;i<n;i++){\\n            price[i]= price[i]*freq[i];\\n            if(freq[i]<mx && freq[i]>0){\\n                mx=freq[i];\\n                mxi=i;\\n            }\\n        }\\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>> (n+2,vector<int>(n+3,-1)));\\n        int ans = helper(mxi,-1,-2,adj2,dp,price,freq);\\n        for(int i=0;i<n;i++){\\n            if(freq[i]>0){\\n                ans+=helper(i,-1,-2,adj2,dp,price,freq);\\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953219,
                "title": "java-beats-100-clean-no-memo-one-pass-for-discount-calculation",
                "content": "# Code\\n```\\nclass Solution {\\n    List<Integer>[] graph;\\n    int[] count;\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        //build graph\\n        graph = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        // array to count how many times each vertex is used\\n        count = new int[n];\\n        for (int[] t : trips) {\\n            // simple dfs to find path for every trip\\n            getPath(t[0], -1, t[1]);\\n        }\\n        // calculate max sum we can get with no adjacent vertices\\n        int[] maxSum = getMax(0, -1, price);\\n        // deduct half from the final result\\n        int res = -Math.max(maxSum[0], maxSum[1])/2;\\n        for (int i = 0; i < n; i++) {\\n            // get sum of all vertices in use\\n            res += count[i]*price[i];\\n        }\\n\\n        return res;\\n    }\\n\\n    // return int[2]\\n    // 0 => max sum if current vertex taken\\n    // 1 => max sum if current vertex is not taken\\n    public int[] getMax(int current, int prev, int[] price) {\\n        \\n        int[] res = new int[]{price[current]*count[current], 0};\\n\\n        for (int v : graph[current]) {\\n            if (v == prev) {\\n                continue;\\n            }\\n            int[] curr = getMax(v, current, price);\\n            res[0] += curr[1];\\n            res[1] += Math.max(curr[0], curr[1]);\\n        }\\n        return res;\\n    }\\n\\n    // simple dfs to count vertices in the path\\n    public boolean getPath(int current, int prev, int search) {\\n        if (current == search) {\\n            count[current]++;\\n            return true;\\n        }\\n        for (int v : graph[current]) {\\n            if (v == prev) {\\n                continue;\\n            }\\n            if (getPath(v, current, search)) {\\n                count[current]++;\\n                return true;    \\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer>[] graph;\\n    int[] count;\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        //build graph\\n        graph = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        // array to count how many times each vertex is used\\n        count = new int[n];\\n        for (int[] t : trips) {\\n            // simple dfs to find path for every trip\\n            getPath(t[0], -1, t[1]);\\n        }\\n        // calculate max sum we can get with no adjacent vertices\\n        int[] maxSum = getMax(0, -1, price);\\n        // deduct half from the final result\\n        int res = -Math.max(maxSum[0], maxSum[1])/2;\\n        for (int i = 0; i < n; i++) {\\n            // get sum of all vertices in use\\n            res += count[i]*price[i];\\n        }\\n\\n        return res;\\n    }\\n\\n    // return int[2]\\n    // 0 => max sum if current vertex taken\\n    // 1 => max sum if current vertex is not taken\\n    public int[] getMax(int current, int prev, int[] price) {\\n        \\n        int[] res = new int[]{price[current]*count[current], 0};\\n\\n        for (int v : graph[current]) {\\n            if (v == prev) {\\n                continue;\\n            }\\n            int[] curr = getMax(v, current, price);\\n            res[0] += curr[1];\\n            res[1] += Math.max(curr[0], curr[1]);\\n        }\\n        return res;\\n    }\\n\\n    // simple dfs to count vertices in the path\\n    public boolean getPath(int current, int prev, int search) {\\n        if (current == search) {\\n            count[current]++;\\n            return true;\\n        }\\n        for (int v : graph[current]) {\\n            if (v == prev) {\\n                continue;\\n            }\\n            if (getPath(v, current, search)) {\\n                count[current]++;\\n                return true;    \\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492511,
                "title": "c-brute-force-dfs-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(2*n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int i, int p, vector<int>&lvl, vector<int>&par, vector<int>adj[]){\\n        for(auto it: adj[i]){\\n            if(it!=p){\\n                par[it]=i;\\n                lvl[it]=lvl[i]+1;\\n                dfs(it, i, lvl, par, adj);\\n            }\\n        }\\n    }\\n    vector<int>cnt(int i, int j, vector<int>&lvl, vector<int>&par, vector<int>adj[]){\\n        int mini, maxi;\\n        vector<int>ans;\\n        if(lvl[i]<=lvl[j]){\\n            mini=i, maxi=j;\\n        }\\n        else{\\n            mini=j;\\n            maxi=i;\\n        }\\n        while(lvl[maxi]!=lvl[mini]){\\n            ans.push_back(maxi);\\n            maxi=par[maxi];\\n        }\\n        while(maxi!=mini){\\n            ans.push_back(maxi);\\n            maxi=par[maxi];\\n            ans.push_back(mini);\\n            mini=par[mini];\\n        }\\n        ans.push_back(mini);\\n        return ans;\\n    }\\n    void chk(int i, int p, vector<vector<int>>&cost, vector<int>&price, vector<int>&v1, vector<int>adj[]){\\n        for(auto it: adj[i]){\\n            if(it!=p){\\n                chk(it, i, cost, price, v1, adj);\\n            }\\n        }\\n        cost[0][i]=price[i]*v1[i]/2;\\n        for(auto it: adj[i]){\\n            if(it!=p){\\n                cost[0][i]+=cost[1][it];\\n            }\\n        }\\n        cost[1][i]=price[i]*v1[i];\\n        for(auto it: adj[i]){\\n            if(it!=p){\\n                cost[1][i]+=min(cost[1][it], cost[0][it]);\\n            }\\n        }\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int>adj[n];\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>lvl(n, 0), par(n, -1), v1(n, 0);\\n        dfs(0, -1, lvl, par, adj);\\n        for(int i=0; i<trips.size(); i++){\\n            vector<int>v=cnt(trips[i][0], trips[i][1], lvl, par, adj);\\n            for(int i=0; i<v.size(); i++){\\n                v1[v[i]]++;\\n            }\\n        }\\n        vector<vector<int>>cost(2, vector<int>(n, 0));\\n        chk(0, -1, cost, price, v1, adj);\\n        return min(cost[0][0], cost[1][0]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int i, int p, vector<int>&lvl, vector<int>&par, vector<int>adj[]){\\n        for(auto it: adj[i]){\\n            if(it!=p){\\n                par[it]=i;\\n                lvl[it]=lvl[i]+1;\\n                dfs(it, i, lvl, par, adj);\\n            }\\n        }\\n    }\\n    vector<int>cnt(int i, int j, vector<int>&lvl, vector<int>&par, vector<int>adj[]){\\n        int mini, maxi;\\n        vector<int>ans;\\n        if(lvl[i]<=lvl[j]){\\n            mini=i, maxi=j;\\n        }\\n        else{\\n            mini=j;\\n            maxi=i;\\n        }\\n        while(lvl[maxi]!=lvl[mini]){\\n            ans.push_back(maxi);\\n            maxi=par[maxi];\\n        }\\n        while(maxi!=mini){\\n            ans.push_back(maxi);\\n            maxi=par[maxi];\\n            ans.push_back(mini);\\n            mini=par[mini];\\n        }\\n        ans.push_back(mini);\\n        return ans;\\n    }\\n    void chk(int i, int p, vector<vector<int>>&cost, vector<int>&price, vector<int>&v1, vector<int>adj[]){\\n        for(auto it: adj[i]){\\n            if(it!=p){\\n                chk(it, i, cost, price, v1, adj);\\n            }\\n        }\\n        cost[0][i]=price[i]*v1[i]/2;\\n        for(auto it: adj[i]){\\n            if(it!=p){\\n                cost[0][i]+=cost[1][it];\\n            }\\n        }\\n        cost[1][i]=price[i]*v1[i];\\n        for(auto it: adj[i]){\\n            if(it!=p){\\n                cost[1][i]+=min(cost[1][it], cost[0][it]);\\n            }\\n        }\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int>adj[n];\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>lvl(n, 0), par(n, -1), v1(n, 0);\\n        dfs(0, -1, lvl, par, adj);\\n        for(int i=0; i<trips.size(); i++){\\n            vector<int>v=cnt(trips[i][0], trips[i][1], lvl, par, adj);\\n            for(int i=0; i<v.size(); i++){\\n                v1[v[i]]++;\\n            }\\n        }\\n        vector<vector<int>>cost(2, vector<int>(n, 0));\\n        chk(0, -1, cost, price, v1, adj);\\n        return min(cost[0][0], cost[1][0]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486238,
                "title": "2646-minimize-the-total-price-of-the-trips-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N^2 * log(N))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N^2)\\n\\n# JavaScript Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {number[]} price\\n * @param {number[][]} trips\\n * @return {number}\\n */\\nvar minimumTotalPrice = function(n, edges, price, trips) {\\n  let graph = Array(n).fill(0).map(() => []);\\n  for (let [a, b] of edges) {\\n    graph[a].push(b);\\n    graph[b].push(a);\\n  }\\n  let totalPrice = Array(n).fill(0);\\n  for (let [start, end] of trips) {\\n    let path = makeTrip(start, end);\\n    for (let node of path) {\\n      totalPrice[node] += price[node];\\n    }\\n  }\\n  let memo = new Map();\\n  return dfs(0, false, -1);\\n  \\n  function dfs(node, parentIsHalfPrice, parent) {\\n    let key = `${node},${parentIsHalfPrice},${parent}`;\\n    if (memo.has(key)) return memo.get(key);\\n\\n    if (parentIsHalfPrice) {\\n      let ans = totalPrice[node];\\n      for (let nei of graph[node]) {\\n        if (nei === parent) continue;\\n        ans += dfs(nei, false, node);\\n      }\\n      memo.set(key, ans);\\n      return ans;\\n    }\\n    \\n    let takeHalfPrice = totalPrice[node] / 2, noHalfPrice = totalPrice[node];\\n    for (let nei of graph[node]) {\\n      if (nei === parent) continue;\\n      takeHalfPrice += dfs(nei, true, node);\\n      noHalfPrice += dfs(nei, false, node);\\n    }\\n    let ans = Math.min(takeHalfPrice, noHalfPrice);\\n    memo.set(key, ans);\\n    return ans;\\n  }\\n  \\n  function makeTrip(start, end) {\\n    let queue = [[start, [start]]], seen = Array(n).fill(0);\\n    seen[start] = 1;\\n    while (queue.length) {\\n      let [node, path] = queue.shift();\\n      if (node === end) return path;\\n      for (let nei of graph[node]) {\\n        if (seen[nei]) continue;\\n        seen[nei] = 1;\\n        queue.push([nei, [...path, nei]]);\\n      }\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {number[]} price\\n * @param {number[][]} trips\\n * @return {number}\\n */\\nvar minimumTotalPrice = function(n, edges, price, trips) {\\n  let graph = Array(n).fill(0).map(() => []);\\n  for (let [a, b] of edges) {\\n    graph[a].push(b);\\n    graph[b].push(a);\\n  }\\n  let totalPrice = Array(n).fill(0);\\n  for (let [start, end] of trips) {\\n    let path = makeTrip(start, end);\\n    for (let node of path) {\\n      totalPrice[node] += price[node];\\n    }\\n  }\\n  let memo = new Map();\\n  return dfs(0, false, -1);\\n  \\n  function dfs(node, parentIsHalfPrice, parent) {\\n    let key = `${node},${parentIsHalfPrice},${parent}`;\\n    if (memo.has(key)) return memo.get(key);\\n\\n    if (parentIsHalfPrice) {\\n      let ans = totalPrice[node];\\n      for (let nei of graph[node]) {\\n        if (nei === parent) continue;\\n        ans += dfs(nei, false, node);\\n      }\\n      memo.set(key, ans);\\n      return ans;\\n    }\\n    \\n    let takeHalfPrice = totalPrice[node] / 2, noHalfPrice = totalPrice[node];\\n    for (let nei of graph[node]) {\\n      if (nei === parent) continue;\\n      takeHalfPrice += dfs(nei, true, node);\\n      noHalfPrice += dfs(nei, false, node);\\n    }\\n    let ans = Math.min(takeHalfPrice, noHalfPrice);\\n    memo.set(key, ans);\\n    return ans;\\n  }\\n  \\n  function makeTrip(start, end) {\\n    let queue = [[start, [start]]], seen = Array(n).fill(0);\\n    seen[start] = 1;\\n    while (queue.length) {\\n      let [node, path] = queue.shift();\\n      if (node === end) return path;\\n      for (let nei of graph[node]) {\\n        if (seen[nei]) continue;\\n        seen[nei] = 1;\\n        queue.push([nei, [...path, nei]]);\\n      }\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3444706,
                "title": "java-dfs-dp-with-comments",
                "content": "```\\nclass Solution {\\n    HashMap<Integer, ArrayList<Integer>> graph;\\n    int[] freq;\\n    int[] price;\\n    int[][] dp;\\n    \\n\\t// dfs to find the frequency of all nodes in trips\\n    boolean dfs(int src, int dest, int parent) {\\n        if(src == dest){\\n            freq[src]++;\\n            return true;\\n        }\\n        boolean found = false;\\n        if(graph.containsKey(src)) {\\n            for(int nei: graph.get(src)) {\\n                if(nei != parent) {\\n                    found |= dfs(nei, dest, src);\\n                }\\n                if(found) break;\\n            }\\n        }\\n        if(found) freq[src]++;\\n        return found;\\n    }\\n    \\n\\t// to find th minimum value of price using recursion and memoization\\n    int recursion(int node, int parent, int half) {\\n        if(dp[node][half] != -1) return dp[node][half];\\n        int res1 = (price[node] * freq[node]) / 2, res2 = price[node] * freq[node];\\n        if(graph.containsKey(node)) {\\n            for(int i : graph.get(node)) {\\n                if(i != parent) {\\n                    res2 += recursion(i, node, 0);\\n                }\\n            }\\n            \\n            if(half == 1){\\n                dp[node][half] = res2;\\n                return res2;\\n            }\\n            \\n            for(int i : graph.get(node)) {\\n                if(i != parent) {\\n                    res1 += recursion(i, node, 1);\\n                }\\n            }\\n        } \\n        return dp[node][half] = Math.min(res1, res2);\\n    }\\n    \\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n\\t\\t// creating graph\\n        graph = new HashMap<>();\\n        for(int[] edge: edges) {\\n            if(!graph.containsKey(edge[0])) graph.put(edge[0], new ArrayList<>());\\n            if(!graph.containsKey(edge[1])) graph.put(edge[1], new ArrayList<>());\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        \\n\\t\\t// creating frequency array\\n        freq = new int[n];\\n        for(int[] trip: trips) {\\n            dfs(trip[0], trip[1], -1);\\n        }\\n        \\n\\t\\t// finding minimum price\\n        dp = new int[n][2];\\n        for(int i = 0; i < n; i++) Arrays.fill(dp[i], -1);\\n        this.price = price;\\n        return recursion(0, -1, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Integer, ArrayList<Integer>> graph;\\n    int[] freq;\\n    int[] price;\\n    int[][] dp;\\n    \\n\\t// dfs to find the frequency of all nodes in trips\\n    boolean dfs(int src, int dest, int parent) {\\n        if(src == dest){\\n            freq[src]++;\\n            return true;\\n        }\\n        boolean found = false;\\n        if(graph.containsKey(src)) {\\n            for(int nei: graph.get(src)) {\\n                if(nei != parent) {\\n                    found |= dfs(nei, dest, src);\\n                }\\n                if(found) break;\\n            }\\n        }\\n        if(found) freq[src]++;\\n        return found;\\n    }\\n    \\n\\t// to find th minimum value of price using recursion and memoization\\n    int recursion(int node, int parent, int half) {\\n        if(dp[node][half] != -1) return dp[node][half];\\n        int res1 = (price[node] * freq[node]) / 2, res2 = price[node] * freq[node];\\n        if(graph.containsKey(node)) {\\n            for(int i : graph.get(node)) {\\n                if(i != parent) {\\n                    res2 += recursion(i, node, 0);\\n                }\\n            }\\n            \\n            if(half == 1){\\n                dp[node][half] = res2;\\n                return res2;\\n            }\\n            \\n            for(int i : graph.get(node)) {\\n                if(i != parent) {\\n                    res1 += recursion(i, node, 1);\\n                }\\n            }\\n        } \\n        return dp[node][half] = Math.min(res1, res2);\\n    }\\n    \\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n\\t\\t// creating graph\\n        graph = new HashMap<>();\\n        for(int[] edge: edges) {\\n            if(!graph.containsKey(edge[0])) graph.put(edge[0], new ArrayList<>());\\n            if(!graph.containsKey(edge[1])) graph.put(edge[1], new ArrayList<>());\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        \\n\\t\\t// creating frequency array\\n        freq = new int[n];\\n        for(int[] trip: trips) {\\n            dfs(trip[0], trip[1], -1);\\n        }\\n        \\n\\t\\t// finding minimum price\\n        dp = new int[n][2];\\n        for(int i = 0; i < n; i++) Arrays.fill(dp[i], -1);\\n        this.price = price;\\n        return recursion(0, -1, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439456,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. Perform DFS to track the count `cnt` of nodes traversed for the input `trips`\\n2. Use DP to create a 0-1 knapsack to optimally `include` xor `exclude` non-adjacent nodes for half-price discount\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minimumTotalPrice(N: Int, E: Array<IntArray>, price: IntArray, trips: Array<IntArray>, INF: Int = 1e9.toInt() + 7): Int {\\n        var adj = mutableMapOf<Int, MutableSet<Int>>(); (0 until N).forEach{ adj[it] = mutableSetOf<Int>() }\\n        for ((u, v) in E) {\\n            adj[u]!!.add(v)\\n            adj[v]!!.add(u)\\n        }\\n        var cnt = IntArray(N){ 0 }\\n        fun go(u: Int, target: Int, seen: MutableSet<Int>): Boolean {\\n            if (u == target) {\\n                seen.forEach{ ++cnt[it] }\\n                return true\\n            }\\n            for (v in adj[u]!!) {\\n                if (!seen.contains(v)) {\\n                    seen.add(v)\\n                    if (go(v, target, seen))\\n                        return true\\n                    seen.remove(v)\\n                }\\n            }\\n            return false\\n        }\\n        for ((u, v) in trips)\\n            go(u, v, mutableSetOf<Int>(u))\\n        var cost = (price zip cnt).map{ (x, y) -> x * y }\\n        var (m, key) = Pair(mutableMapOf<String, Int>(), { u: Int, last: Int, last_discount: Boolean -> \"$u,$last,$last_discount\" })\\n        fun dp(u: Int = 0, last: Int = 0, last_discount: Boolean = false): Int {\\n            var k = key(u, last, last_discount)\\n            if (!m.contains(k)) {\\n                var include = if (last_discount) INF else cost[u] / 2\\n                var exclude = cost[u]\\n                for (v in adj[u]!!) {\\n                    if (v != last) {\\n                        include += dp(v, u, true)\\n                        exclude += dp(v, u, false)    \\n                    }\\n                }\\n                m[k] = Math.min(include, exclude)\\n            }\\n            return m[k]!!\\n        }\\n        return dp()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minimumTotalPrice = (N, E, price, trips, cnt = Array(N).fill(0), m = new Map(), INF = Number(1e9 + 7)) => {\\n    let adj = new Map([...Array(N).keys()].map(v => [v, []]));\\n    for (let [u, v] of E) {\\n        adj.get(u).push(v);\\n        adj.get(v).push(u);\\n    }\\n    let go = (u, target, seen) => {\\n        if (u == target) {\\n            seen.forEach(v => ++cnt[v]);\\n            return true;\\n        }\\n        for (let v of adj.get(u)) {\\n            if (!seen.has(v)) {\\n                seen.add(v);\\n                if (go(v, target, seen))\\n                    return true;\\n                seen.delete(v);\\n            }\\n        }\\n        return false;\\n    };\\n    for (let [u, v] of trips)\\n        go(u, v, new Set([u]));\\n    let cost = _.zip(price, cnt).map(([x, y]) => x * y);\\n    let key = (u, last, last_discount) => `${u},${last},${last_discount}`;\\n    let dp = (u = 0, last = 0, last_discount = false) => {\\n        let k = key(u, last, last_discount);\\n        if (!m.has(k)) {\\n            let include = last_discount ? INF : Math.floor(cost[u] / 2),\\n                exclude = cost[u];\\n            for (let v of adj.get(u)) {\\n                if (v != last) {\\n                    include += dp(v, u, true);\\n                    exclude += dp(v, u, false);\\n                }\\n            }\\n            m.set(k, Math.min(include, exclude));\\n        }\\n        return m.get(k);\\n    };\\n    return dp();\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, N: int, E: List[List[int]], price: List[int], trips: List[List[int]], INF = int(1e9 + 7)) -> int:\\n        adj = defaultdict(list)\\n        for u, v in E:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        cnt = [0] * N\\n        def go(u, target, seen):\\n            if u == target:\\n                for i in seen:\\n                    cnt[i] += 1\\n                return True\\n            for v in adj[u]:\\n                if v not in seen:\\n                    seen.add(v)\\n                    if go(v, target, seen):\\n                        return True\\n                    seen.remove(v)\\n            return False\\n        for u, v in trips:\\n            go(u, v, set([u]))\\n        cost = [x * y for x, y in zip(price, cnt)]\\n        @cache\\n        def dp(u = 0, last = -1, last_discount = False):\\n            include = cost[u] // 2 if not last_discount else INF\\n            exclude = cost[u]\\n            for v in adj[u]:\\n                if v != last:\\n                    include += dp(v, u, True)\\n                    exclude += dp(v, u, False)\\n            return min(include, exclude)\\n        return dp()\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Adj = unordered_map<int, VI>;\\n    using Cnt = unordered_map<int, int>;\\n    using Set = unordered_set<int>;\\n    using fun1 = function<bool(int, int, Set&&)>;\\n    using fun2 = function<int(int, int, bool)>;\\n    using Memo = unordered_map<string, int>;\\n    int minimumTotalPrice(int N, VVI& E, VI& price, VVI& T, Adj adj = {}, Cnt cnt = {}, VI cost = {}, Memo m = {}, int INF = 1e9 + 7) {\\n        for (auto& edge: E) {\\n            auto [u, v] = tie(edge[0], edge[1]);\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        fun1 go = [&](auto u, auto target, auto&& seen) {\\n            if (u == target) {\\n                for (auto& v: seen)\\n                    ++cnt[v];\\n                return true;\\n            }\\n            for (auto v: adj[u]) {\\n                if (seen.insert(v).second) {\\n                    if (go(v, target, move(seen)))\\n                        return true;\\n                    seen.erase(v);\\n                }\\n            }\\n            return false;\\n        };\\n        for (auto& trip: T)\\n            go(trip[0], trip[1], {trip[0]});\\n        for (auto i{ 0 }; i < N; ++i)\\n            cost.push_back(price[i] * cnt[i]);\\n        auto key = [](auto u, auto last, auto last_discount) {\\n            stringstream ss; ss << u << \",\" << last << \",\" << last_discount;\\n            return ss.str();\\n        };\\n        fun2 dp = [&](auto u, auto last, auto last_discount) {\\n            auto k = key(u, last, last_discount);\\n            if (m.find(k) == m.end()) {\\n                auto include = last_discount ? INF : cost[u] / 2,\\n                     exclude = cost[u];\\n                for (auto v: adj[u]) {\\n                    if (v != last) {\\n                        include += dp(v, u, true);\\n                        exclude += dp(v, u, false);\\n                    }\\n                }\\n                m[k] = min(include, exclude);\\n            }\\n            return m[k];\\n        };\\n        return dp(0, 0, false);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minimumTotalPrice(N: Int, E: Array<IntArray>, price: IntArray, trips: Array<IntArray>, INF: Int = 1e9.toInt() + 7): Int {\\n        var adj = mutableMapOf<Int, MutableSet<Int>>(); (0 until N).forEach{ adj[it] = mutableSetOf<Int>() }\\n        for ((u, v) in E) {\\n            adj[u]!!.add(v)\\n            adj[v]!!.add(u)\\n        }\\n        var cnt = IntArray(N){ 0 }\\n        fun go(u: Int, target: Int, seen: MutableSet<Int>): Boolean {\\n            if (u == target) {\\n                seen.forEach{ ++cnt[it] }\\n                return true\\n            }\\n            for (v in adj[u]!!) {\\n                if (!seen.contains(v)) {\\n                    seen.add(v)\\n                    if (go(v, target, seen))\\n                        return true\\n                    seen.remove(v)\\n                }\\n            }\\n            return false\\n        }\\n        for ((u, v) in trips)\\n            go(u, v, mutableSetOf<Int>(u))\\n        var cost = (price zip cnt).map{ (x, y) -> x * y }\\n        var (m, key) = Pair(mutableMapOf<String, Int>(), { u: Int, last: Int, last_discount: Boolean -> \"$u,$last,$last_discount\" })\\n        fun dp(u: Int = 0, last: Int = 0, last_discount: Boolean = false): Int {\\n            var k = key(u, last, last_discount)\\n            if (!m.contains(k)) {\\n                var include = if (last_discount) INF else cost[u] / 2\\n                var exclude = cost[u]\\n                for (v in adj[u]!!) {\\n                    if (v != last) {\\n                        include += dp(v, u, true)\\n                        exclude += dp(v, u, false)    \\n                    }\\n                }\\n                m[k] = Math.min(include, exclude)\\n            }\\n            return m[k]!!\\n        }\\n        return dp()\\n    }\\n}\\n```\n```\\nlet minimumTotalPrice = (N, E, price, trips, cnt = Array(N).fill(0), m = new Map(), INF = Number(1e9 + 7)) => {\\n    let adj = new Map([...Array(N).keys()].map(v => [v, []]));\\n    for (let [u, v] of E) {\\n        adj.get(u).push(v);\\n        adj.get(v).push(u);\\n    }\\n    let go = (u, target, seen) => {\\n        if (u == target) {\\n            seen.forEach(v => ++cnt[v]);\\n            return true;\\n        }\\n        for (let v of adj.get(u)) {\\n            if (!seen.has(v)) {\\n                seen.add(v);\\n                if (go(v, target, seen))\\n                    return true;\\n                seen.delete(v);\\n            }\\n        }\\n        return false;\\n    };\\n    for (let [u, v] of trips)\\n        go(u, v, new Set([u]));\\n    let cost = _.zip(price, cnt).map(([x, y]) => x * y);\\n    let key = (u, last, last_discount) => `${u},${last},${last_discount}`;\\n    let dp = (u = 0, last = 0, last_discount = false) => {\\n        let k = key(u, last, last_discount);\\n        if (!m.has(k)) {\\n            let include = last_discount ? INF : Math.floor(cost[u] / 2),\\n                exclude = cost[u];\\n            for (let v of adj.get(u)) {\\n                if (v != last) {\\n                    include += dp(v, u, true);\\n                    exclude += dp(v, u, false);\\n                }\\n            }\\n            m.set(k, Math.min(include, exclude));\\n        }\\n        return m.get(k);\\n    };\\n    return dp();\\n};\\n```\n```\\nclass Solution:\\n    def minimumTotalPrice(self, N: int, E: List[List[int]], price: List[int], trips: List[List[int]], INF = int(1e9 + 7)) -> int:\\n        adj = defaultdict(list)\\n        for u, v in E:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        cnt = [0] * N\\n        def go(u, target, seen):\\n            if u == target:\\n                for i in seen:\\n                    cnt[i] += 1\\n                return True\\n            for v in adj[u]:\\n                if v not in seen:\\n                    seen.add(v)\\n                    if go(v, target, seen):\\n                        return True\\n                    seen.remove(v)\\n            return False\\n        for u, v in trips:\\n            go(u, v, set([u]))\\n        cost = [x * y for x, y in zip(price, cnt)]\\n        @cache\\n        def dp(u = 0, last = -1, last_discount = False):\\n            include = cost[u] // 2 if not last_discount else INF\\n            exclude = cost[u]\\n            for v in adj[u]:\\n                if v != last:\\n                    include += dp(v, u, True)\\n                    exclude += dp(v, u, False)\\n            return min(include, exclude)\\n        return dp()\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Adj = unordered_map<int, VI>;\\n    using Cnt = unordered_map<int, int>;\\n    using Set = unordered_set<int>;\\n    using fun1 = function<bool(int, int, Set&&)>;\\n    using fun2 = function<int(int, int, bool)>;\\n    using Memo = unordered_map<string, int>;\\n    int minimumTotalPrice(int N, VVI& E, VI& price, VVI& T, Adj adj = {}, Cnt cnt = {}, VI cost = {}, Memo m = {}, int INF = 1e9 + 7) {\\n        for (auto& edge: E) {\\n            auto [u, v] = tie(edge[0], edge[1]);\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        fun1 go = [&](auto u, auto target, auto&& seen) {\\n            if (u == target) {\\n                for (auto& v: seen)\\n                    ++cnt[v];\\n                return true;\\n            }\\n            for (auto v: adj[u]) {\\n                if (seen.insert(v).second) {\\n                    if (go(v, target, move(seen)))\\n                        return true;\\n                    seen.erase(v);\\n                }\\n            }\\n            return false;\\n        };\\n        for (auto& trip: T)\\n            go(trip[0], trip[1], {trip[0]});\\n        for (auto i{ 0 }; i < N; ++i)\\n            cost.push_back(price[i] * cnt[i]);\\n        auto key = [](auto u, auto last, auto last_discount) {\\n            stringstream ss; ss << u << \",\" << last << \",\" << last_discount;\\n            return ss.str();\\n        };\\n        fun2 dp = [&](auto u, auto last, auto last_discount) {\\n            auto k = key(u, last, last_discount);\\n            if (m.find(k) == m.end()) {\\n                auto include = last_discount ? INF : cost[u] / 2,\\n                     exclude = cost[u];\\n                for (auto v: adj[u]) {\\n                    if (v != last) {\\n                        include += dp(v, u, true);\\n                        exclude += dp(v, u, false);\\n                    }\\n                }\\n                m[k] = min(include, exclude);\\n            }\\n            return m[k];\\n        };\\n        return dp(0, 0, false);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434290,
                "title": "swift-solution-two-times-using-dfs",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    func minimumTotalPrice(_ n: Int, _ edges: [[Int]], _ price: [Int], _ trips: [[Int]]) -> Int {\\n        var visited: Set<Int> = []\\n        var graph: [Int: [Int]] = [:]\\n        var count: [Int: Int] = [:]\\n\\n        for edge in edges {\\n            graph[edge[0], default: []].append(edge[1])\\n            graph[edge[1], default: []].append(edge[0])\\n        }\\n\\n        for trip in trips {\\n            visited = []\\n            for c in dfs(start: trip[0], end: trip[1], visited: &visited, graph: graph) {\\n                count[c, default: 0] += 1\\n            }\\n        }\\n        visited = []\\n        let res = dfs(0, &visited, graph, price, count)\\n        return min(res.0, res.1)\\n    }\\n\\n    private func dfs(start: Int, end: Int, visited: inout Set<Int>, graph: [Int: [Int]]) -> [Int] {\\n\\n        guard start != end else { return [start] }\\n\\n        visited.insert(start)\\n        for n in graph[start, default: []] where !visited.contains(n) {\\n            if n == end {\\n                return [start, end]\\n            } else {\\n                let res = dfs(start: n, end: end, visited: &visited, graph: graph)\\n                if res != [] {\\n                    return [start] + res\\n                }\\n            }\\n        }\\n\\n        return []\\n    }\\n\\n    private func dfs(_ i: Int, _ visited: inout Set<Int>, _ graph: [Int: [Int]], _ price: [Int], _ count: [Int: Int]) -> (Int, Int) {\\n        visited.insert(i)\\n        guard let notVisitedNeighbours = graph[i]?.filter({ !visited.contains($0) }) else {\\n            return (count[i, default: 0] * (price[i] / 2), count[i, default: 0] * price[i])\\n        }\\n\\n        let notVisitedPrices = notVisitedNeighbours.map { dfs($0, &visited, graph, price, count) }\\n        let halve = count[i, default: 0] * (price[i] / 2) + notVisitedPrices.map(\\\\.1).reduce(0, +)\\n        let notHalve = count[i, default: 0] * price[i] + notVisitedPrices.map { min($0.0, $0.1) }.reduce(0, +)\\n\\n        return (halve, notHalve)\\n    }\\n}\\n```\\nSimilar problem: https://leetcode.com/problems/house-robber-iii/description/",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\n    func minimumTotalPrice(_ n: Int, _ edges: [[Int]], _ price: [Int], _ trips: [[Int]]) -> Int {\\n        var visited: Set<Int> = []\\n        var graph: [Int: [Int]] = [:]\\n        var count: [Int: Int] = [:]\\n\\n        for edge in edges {\\n            graph[edge[0], default: []].append(edge[1])\\n            graph[edge[1], default: []].append(edge[0])\\n        }\\n\\n        for trip in trips {\\n            visited = []\\n            for c in dfs(start: trip[0], end: trip[1], visited: &visited, graph: graph) {\\n                count[c, default: 0] += 1\\n            }\\n        }\\n        visited = []\\n        let res = dfs(0, &visited, graph, price, count)\\n        return min(res.0, res.1)\\n    }\\n\\n    private func dfs(start: Int, end: Int, visited: inout Set<Int>, graph: [Int: [Int]]) -> [Int] {\\n\\n        guard start != end else { return [start] }\\n\\n        visited.insert(start)\\n        for n in graph[start, default: []] where !visited.contains(n) {\\n            if n == end {\\n                return [start, end]\\n            } else {\\n                let res = dfs(start: n, end: end, visited: &visited, graph: graph)\\n                if res != [] {\\n                    return [start] + res\\n                }\\n            }\\n        }\\n\\n        return []\\n    }\\n\\n    private func dfs(_ i: Int, _ visited: inout Set<Int>, _ graph: [Int: [Int]], _ price: [Int], _ count: [Int: Int]) -> (Int, Int) {\\n        visited.insert(i)\\n        guard let notVisitedNeighbours = graph[i]?.filter({ !visited.contains($0) }) else {\\n            return (count[i, default: 0] * (price[i] / 2), count[i, default: 0] * price[i])\\n        }\\n\\n        let notVisitedPrices = notVisitedNeighbours.map { dfs($0, &visited, graph, price, count) }\\n        let halve = count[i, default: 0] * (price[i] / 2) + notVisitedPrices.map(\\\\.1).reduce(0, +)\\n        let notHalve = count[i, default: 0] * price[i] + notVisitedPrices.map { min($0.0, $0.1) }.reduce(0, +)\\n\\n        return (halve, notHalve)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424029,
                "title": "easy-c-using-dfs-backtracking-dp",
                "content": "# Approach\\nFirstly I counted the number of nodes that will be in all trips using DFS + Backtracking.\\nThen again I did a dfs traversal where for every node I have 2 choices either to half the price or not. If I half the price of current node then its children won\\'t have any option of halving but if I decide not to half then its children will have option to be halved. Similarly do it for all nodes and then you can easily memoise it using a 2d vector as there will be 2 states of dp: First is the node and second is whether to half or not. One may argue to maintain a third state of parent as well but as it is a tree so all nodes have unique parents therefore no need to maintain a third state of dp.\\n\\n# Complexity\\n- Time complexity:O(T*N)  where T= no of trips\\n\\n\\n- Space complexity:\\nO(N+E) + O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs1(int node , int dest , vector<int> adj[] , int par , vector<int> & path , vector<int> & cnt){\\n        if(node == dest){\\n            for(auto & i  : path){\\n                cnt[i]++;\\n            }\\n            cnt[dest]++;\\n            return;\\n        }\\n        path.push_back(node);\\n        for(auto & child : adj[node]){\\n            if(child != par){\\n                dfs1(child , dest , adj , node , path , cnt);\\n            }\\n        }\\n        path.pop_back();\\n    }\\n    int help(vector<int> adj[] , int node , int par , int half , vector<int> & price , vector<vector<int>>& dp){\\n        if(dp[node][half] != -1) return dp[node][half];\\n        int will_do_half = price[node]/2;\\n        int not_do_half = price[node];\\n        for(auto & child : adj[node]){\\n            if(child != par){\\n                will_do_half += help(adj , child , node , 0 , price , dp);\\n                not_do_half += help(adj , child , node , 1 , price , dp);\\n            }\\n        }\\n        if(half) return dp[node][half] = min(will_do_half , not_do_half);\\n        return dp[node][half] = not_do_half;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> adj[n];\\n        for(auto & i : edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        vector<int> path , cnt(n , 0);\\n        for(auto & i : trips){\\n            dfs1(i[0] , i[1] , adj , -1 , path , cnt);\\n        }\\n        for(int i = 0 ;  i < n ; i++){\\n            price[i] *= cnt[i];\\n        }\\n        vector<vector<int>> dp(n , vector<int>(2,-1));\\n        return help(adj , 0 , -1 , 1 , price , dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs1(int node , int dest , vector<int> adj[] , int par , vector<int> & path , vector<int> & cnt){\\n        if(node == dest){\\n            for(auto & i  : path){\\n                cnt[i]++;\\n            }\\n            cnt[dest]++;\\n            return;\\n        }\\n        path.push_back(node);\\n        for(auto & child : adj[node]){\\n            if(child != par){\\n                dfs1(child , dest , adj , node , path , cnt);\\n            }\\n        }\\n        path.pop_back();\\n    }\\n    int help(vector<int> adj[] , int node , int par , int half , vector<int> & price , vector<vector<int>>& dp){\\n        if(dp[node][half] != -1) return dp[node][half];\\n        int will_do_half = price[node]/2;\\n        int not_do_half = price[node];\\n        for(auto & child : adj[node]){\\n            if(child != par){\\n                will_do_half += help(adj , child , node , 0 , price , dp);\\n                not_do_half += help(adj , child , node , 1 , price , dp);\\n            }\\n        }\\n        if(half) return dp[node][half] = min(will_do_half , not_do_half);\\n        return dp[node][half] = not_do_half;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> adj[n];\\n        for(auto & i : edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        vector<int> path , cnt(n , 0);\\n        for(auto & i : trips){\\n            dfs1(i[0] , i[1] , adj , -1 , path , cnt);\\n        }\\n        for(int i = 0 ;  i < n ; i++){\\n            price[i] *= cnt[i];\\n        }\\n        vector<vector<int>> dp(n , vector<int>(2,-1));\\n        return help(adj , 0 , -1 , 1 , price , dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423623,
                "title": "bfs-dfs-dp-detailed-explanation-multiple-languages-well-commented",
                "content": "# Intuition & Approach\\nGiven a undirected and unrooted tree with n nodes indexed from 0 to n - 1. Each node has an associated price. And we need to find the minimum price for each of the trip. Also, we can choose some non-adjacent nodes in the shortest paths for each trip, and half its price.\\n\\nLets divide the problem into 3 parts:\\n1. For Each trip find the shortest path using BFS.\\n2. Create a contribution map, that stores the count of contribution of the nodes for the shortest path across all the trips.\\n3. Now use DFS to calculate the minimum price. At each step in the recursion we have the option to either half the current vertex or leave it as it is. If we are havling the current vextex then its neighbours can\\'t be halved, but if we are not halving the current vertex, for its neighbour we can either half it or not. We will try both combination and choose the minimum. To calculate the minimum price, we use two variable one for halved and other for non-halved. Since we can only choose non-adjacent nodes, we can\\'t half parent and child at the same time. We can only half parent or child. We will use dp to eliminate recalculation.\\n\\n\\n# Code\\n```java []\\nclass Solution {\\n\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n\\n        // Create Adjacency List\\n        Map<Integer, List<Integer>> adjList = new HashMap<>();\\n        for (int i = 0; i < n; i++) adjList.put(i, new ArrayList<>());\\n        for (int[] edge : edges) {\\n            adjList.get(edge[0]).add(edge[1]);\\n            adjList.get(edge[1]).add(edge[0]);\\n        }\\n\\n        // For all the trips, find the shortest path and update the contribution map.\\n        Map<Integer, Integer> contributionMap = new HashMap<>();\\n        for (int[] t : trips) {\\n            bfs(n, adjList, contributionMap, t[0], t[1]);\\n        }\\n\\n        // Calculate the minimum price using dfs with DP.\\n        int[][] dp = new int[n][2];\\n        for (int[] row : dp) Arrays.fill(row, -1);\\n        int ans = dfs(contributionMap, adjList, price, 0, dp, 0, -1);\\n        return ans;\\n\\n    }\\n\\n    private int dfs(Map<Integer, Integer> contributionMap, Map<Integer, List<Integer>> adjList, int[] price, int curr, int[][] dp, int isParentHalved, int parent) {\\n        if (dp[curr][isParentHalved] != -1) return dp[curr][isParentHalved];\\n\\n        // For the current node, store the price with the price[current] halved.\\n        int halved = contributionMap.getOrDefault(curr, 0) * (price[curr] / 2);\\n\\n        // For the current node, store the price with the price[current] not halved.\\n        int notHalved = contributionMap.getOrDefault(curr, 0) * price[curr];\\n\\n        // if parent is halved, then current will be not halved\\n        // if parent is not halved, we can either half or not half it\\n        for (int neighbour : adjList.get(curr)) {\\n            if (neighbour != parent) {\\n                notHalved += dfs(contributionMap, adjList, price, neighbour, dp, 0, curr);\\n            }\\n        }\\n        if (isParentHalved == 1) {\\n            return dp[curr][isParentHalved] = notHalved;  // return the notHalved value since parent is halved and current can\\'t be halved\\n        }\\n\\n        for (int neighbour : adjList.get(curr)) {\\n            if (neighbour != parent) {\\n                halved += dfs(contributionMap, adjList, price, neighbour, dp, 1, curr);\\n            }\\n        }\\n        return dp[curr][isParentHalved] = Math.min(halved, notHalved);  // return the min of halved and non-halved when parent is not halved.\\n    }\\n\\n    private void bfs(int n, Map<Integer, List<Integer>> adjList, Map<Integer, Integer> contibutionMap, int start, int end) {\\n        Queue<Integer> q = new LinkedList<>();\\n        boolean[] visited = new boolean[n];\\n        int[] parent = new int[n];\\n        Arrays.fill(parent, -1);\\n        q.offer(start);\\n        visited[start] = true;\\n        while (!q.isEmpty()) {\\n            int temp = q.poll();\\n            if (temp == end) break;\\n\\n            for (int neighbour : adjList.get(temp)) {\\n                if (!visited[neighbour]) {\\n                    q.offer(neighbour);\\n                    visited[neighbour] = true;\\n                    parent[neighbour] = temp;\\n                }\\n            }\\n        }\\n        start = end;\\n        while (start != -1) {\\n            contibutionMap.put(start, contibutionMap.getOrDefault(start, 0) + 1);\\n            start = parent[start];\\n        }\\n    }\\n}\\n```\\n```cpp []\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        // Create Adjacency List\\n        unordered_map<int, vector<int>> adjList;\\n        for (const auto& edge : edges) {\\n            adjList[edge[0]].push_back(edge[1]);\\n            adjList[edge[1]].push_back(edge[0]);\\n        }\\n\\n        // For all the trips, find the shortest path and update the contribution map.\\n        unordered_map<int, int> contributionMap;\\n        for (const auto& t : trips) {\\n            bfs(n, adjList, contributionMap, t[0], t[1]);\\n        }\\n\\n        // Calculate the minimum price using dfs with DP.\\n        vector<vector<int>> dp(n, vector<int>(2, -1));\\n        int ans = dfs(contributionMap, adjList, price, 0, dp, 0, -1);\\n        return ans;\\n    }\\n\\nprivate:\\n    int dfs(unordered_map<int, int>& contributionMap, unordered_map<int, vector<int>>& adjList, vector<int>& price, int curr, vector<vector<int>>& dp, int isParentHalved, int parent) {\\n        if (dp[curr][isParentHalved] != -1) return dp[curr][isParentHalved];\\n\\n        // For the current node, store the price with the price[current] halved.\\n        int halved = contributionMap[curr] * (price[curr] / 2);\\n\\n        // For the current node, store the price with the price[current] not halved.\\n        int notHalved = contributionMap[curr] * price[curr];\\n\\n        // if parent is halved, then current will be not halved\\n        // if parent is not halved, we can either half or not half it\\n        for (int neighbour : adjList[curr]) {\\n            if (neighbour != parent) {\\n                notHalved += dfs(contributionMap, adjList, price, neighbour, dp, 0, curr);\\n            }\\n        }\\n        if (isParentHalved == 1) {\\n            return dp[curr][isParentHalved] = notHalved;  // return the notHalved value since parent is halved and current can\\'t be halved\\n        }\\n\\n        for (int neighbour : adjList[curr]) {\\n            if (neighbour != parent) {\\n                halved += dfs(contributionMap, adjList, price, neighbour, dp, 1, curr);\\n            }\\n        }\\n        return dp[curr][isParentHalved] = min(halved, notHalved);  // return the min of halved and non-halved when parent is not halved.\\n    }\\n\\n    void bfs(int n, unordered_map<int, vector<int>>& adjList, unordered_map<int, int>& contibutionMap, int start, int end) {\\n        queue<int> q;\\n        vector<bool> visited(n, false);\\n        vector<int> parent(n, -1);\\n        q.push(start);\\n        visited[start] = true;\\n        while (!q.empty()) {\\n            int temp = q.front();\\n            q.pop();\\n            if (temp == end) break;\\n\\n            for (int neighbour : adjList[temp]) {\\n                if (!visited[neighbour]) {\\n                    q.push(neighbour);\\n                    visited[neighbour] = true;\\n                    parent[neighbour] = temp;\\n                }\\n            }\\n        }\\n        start = end;\\n        while (start != -1) {\\n            contibutionMap[start]++;\\n            start = parent[start];\\n        }\\n    }\\n};\\n```\\n```python []\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def minimumTotalPrice(self, n, edges, price, trips):\\n        # Create Adjacency List\\n        adjList = defaultdict(list)\\n        for edge in edges:\\n            adjList[edge[0]].append(edge[1])\\n            adjList[edge[1]].append(edge[0])\\n\\n        # For all the trips, find the shortest path and update the contribution map.\\n        contributionMap = {}\\n        for t in trips:\\n            self.bfs(n, adjList, contributionMap, t[0], t[1])\\n\\n        # Calculate the minimum price using dfs with DP.\\n        dp = [[-1 for _ in range(2)] for _ in range(n)]\\n        ans = self.dfs(contributionMap, adjList, price, 0, dp, 0, -1)\\n        return ans\\n\\n    def dfs(self, contributionMap, adjList, price, curr, dp, isParentHalved, parent):\\n        if dp[curr][isParentHalved] != -1:\\n            return dp[curr][isParentHalved]\\n\\n        # For the current node, store the price with the price[current] halved.\\n        halved = contributionMap.get(curr, 0) * (price[curr] // 2)\\n\\n        # For the current node, store the price with the price[current] not halved.\\n        notHalved = contributionMap.get(curr, 0) * price[curr]\\n\\n        # if parent is halved, then current will be not halved\\n        # if parent is not halved, we can either half or not half it\\n        for neighbour in adjList[curr]:\\n            if neighbour != parent:\\n                notHalved += self.dfs(contributionMap, adjList, price, neighbour, dp, 0, curr)\\n        if isParentHalved == 1:\\n            dp[curr][isParentHalved] = notHalved  # return the notHalved value since parent is halved and current can\\'t be halved\\n            return dp[curr][isParentHalved]\\n\\n        for neighbour in adjList[curr]:\\n            if neighbour != parent:\\n                halved += self.dfs(contributionMap, adjList, price, neighbour, dp, 1, curr)\\n        dp[curr][isParentHalved] = min(halved, notHalved)  # return the min of halved and non-halved when parent is not halved.\\n        return dp[curr][isParentHalved]\\n\\n    def bfs(self, n, adjList, contributionMap, start, end):\\n        q = deque()\\n        visited = [False] * n\\n        parent = [-1] * n\\n        q.append(start)\\n        visited[start] = True\\n        while q:\\n            temp = q.popleft()\\n            if temp == end:\\n                break\\n\\n            for neighbour in adjList[temp]:\\n                if not visited[neighbour]:\\n                    q.append(neighbour)\\n                    visited[neighbour] = True\\n                    parent[neighbour] = temp\\n\\n        while start != -1:\\n            contributionMap[start] = contributionMap.get(start, 0) + 1\\n            start = parent[start]\\n```\\n```javascript []\\nfunction minimumTotalPrice(n, edges, price, trips) {\\n\\n    // Create Adjacency List\\n    let adjList = new Map();\\n    for (let i = 0; i < n; i++) adjList.set(i, []);\\n    for (let edge of edges) {\\n        adjList.get(edge[0]).push(edge[1]);\\n        adjList.get(edge[1]).push(edge[0]);\\n    }\\n\\n    // For all the trips, find the shortest path and update the contribution map.\\n    let contributionMap = new Map();\\n    for (let t of trips) {\\n        bfs(n, adjList, contributionMap, t[0], t[1]);\\n    }\\n\\n    // Calculate the minimum price using dfs with DP.\\n    let dp = new Array(n).fill(null).map(() => new Array(2).fill(-1));\\n    let ans = dfs(contributionMap, adjList, price, 0, dp, 0, -1);\\n    return ans;\\n}\\n\\nfunction dfs(contributionMap, adjList, price, curr, dp, isParentHalved, parent) {\\n    if (dp[curr][isParentHalved] !== -1) return dp[curr][isParentHalved];\\n\\n    // For the current node, store the price with the price[current] halved.\\n    let halved = contributionMap.get(curr) ? contributionMap.get(curr) * Math.floor(price[curr] / 2) : 0;\\n\\n    // For the current node, store the price with the price[current] not halved.\\n    let notHalved = contributionMap.get(curr) ? contributionMap.get(curr) * price[curr] : 0;\\n\\n    // if parent is halved, then current will be not halved\\n    // if parent is not halved, we can either half or not half it\\n    for (let neighbour of adjList.get(curr)) {\\n        if (neighbour !== parent) {\\n            notHalved += dfs(contributionMap, adjList, price, neighbour, dp, 0, curr);\\n        }\\n    }\\n    if (isParentHalved === 1) {\\n        return dp[curr][isParentHalved] = notHalved; // return the notHalved value since parent is halved and current can\\'t be halved\\n    }\\n\\n    for (let neighbour of adjList.get(curr)) {\\n        if (neighbour !== parent) {\\n            halved += dfs(contributionMap, adjList, price, neighbour, dp, 1, curr);\\n        }\\n    }\\n    return dp[curr][isParentHalved] = Math.min(halved, notHalved); // return the min of halved and non-halved when parent is not halved.\\n}\\n\\nfunction bfs(n, adjList, contibutionMap, start, end) {\\n    let q = [];\\n    let visited = new Array(n).fill(false);\\n    let parent = new Array(n).fill(-1);\\n    q.push(start);\\n    visited[start] = true;\\n    while (q.length > 0) {\\n        let temp = q.shift();\\n        if (temp === end) break;\\n\\n        for (let neighbour of adjList.get(temp)) {\\n            if (!visited[neighbour]) {\\n                q.push(neighbour);\\n                visited[neighbour] = true;\\n                parent[neighbour] = temp;\\n            }\\n        }\\n    }\\n    start = end;\\n    while (start !== -1) {\\n        contibutionMap.set(start, (contibutionMap.get(start) || 0) + 1);\\n        start = parent[start];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n\\n        // Create Adjacency List\\n        Map<Integer, List<Integer>> adjList = new HashMap<>();\\n        for (int i = 0; i < n; i++) adjList.put(i, new ArrayList<>());\\n        for (int[] edge : edges) {\\n            adjList.get(edge[0]).add(edge[1]);\\n            adjList.get(edge[1]).add(edge[0]);\\n        }\\n\\n        // For all the trips, find the shortest path and update the contribution map.\\n        Map<Integer, Integer> contributionMap = new HashMap<>();\\n        for (int[] t : trips) {\\n            bfs(n, adjList, contributionMap, t[0], t[1]);\\n        }\\n\\n        // Calculate the minimum price using dfs with DP.\\n        int[][] dp = new int[n][2];\\n        for (int[] row : dp) Arrays.fill(row, -1);\\n        int ans = dfs(contributionMap, adjList, price, 0, dp, 0, -1);\\n        return ans;\\n\\n    }\\n\\n    private int dfs(Map<Integer, Integer> contributionMap, Map<Integer, List<Integer>> adjList, int[] price, int curr, int[][] dp, int isParentHalved, int parent) {\\n        if (dp[curr][isParentHalved] != -1) return dp[curr][isParentHalved];\\n\\n        // For the current node, store the price with the price[current] halved.\\n        int halved = contributionMap.getOrDefault(curr, 0) * (price[curr] / 2);\\n\\n        // For the current node, store the price with the price[current] not halved.\\n        int notHalved = contributionMap.getOrDefault(curr, 0) * price[curr];\\n\\n        // if parent is halved, then current will be not halved\\n        // if parent is not halved, we can either half or not half it\\n        for (int neighbour : adjList.get(curr)) {\\n            if (neighbour != parent) {\\n                notHalved += dfs(contributionMap, adjList, price, neighbour, dp, 0, curr);\\n            }\\n        }\\n        if (isParentHalved == 1) {\\n            return dp[curr][isParentHalved] = notHalved;  // return the notHalved value since parent is halved and current can\\'t be halved\\n        }\\n\\n        for (int neighbour : adjList.get(curr)) {\\n            if (neighbour != parent) {\\n                halved += dfs(contributionMap, adjList, price, neighbour, dp, 1, curr);\\n            }\\n        }\\n        return dp[curr][isParentHalved] = Math.min(halved, notHalved);  // return the min of halved and non-halved when parent is not halved.\\n    }\\n\\n    private void bfs(int n, Map<Integer, List<Integer>> adjList, Map<Integer, Integer> contibutionMap, int start, int end) {\\n        Queue<Integer> q = new LinkedList<>();\\n        boolean[] visited = new boolean[n];\\n        int[] parent = new int[n];\\n        Arrays.fill(parent, -1);\\n        q.offer(start);\\n        visited[start] = true;\\n        while (!q.isEmpty()) {\\n            int temp = q.poll();\\n            if (temp == end) break;\\n\\n            for (int neighbour : adjList.get(temp)) {\\n                if (!visited[neighbour]) {\\n                    q.offer(neighbour);\\n                    visited[neighbour] = true;\\n                    parent[neighbour] = temp;\\n                }\\n            }\\n        }\\n        start = end;\\n        while (start != -1) {\\n            contibutionMap.put(start, contibutionMap.getOrDefault(start, 0) + 1);\\n            start = parent[start];\\n        }\\n    }\\n}\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        // Create Adjacency List\\n        unordered_map<int, vector<int>> adjList;\\n        for (const auto& edge : edges) {\\n            adjList[edge[0]].push_back(edge[1]);\\n            adjList[edge[1]].push_back(edge[0]);\\n        }\\n\\n        // For all the trips, find the shortest path and update the contribution map.\\n        unordered_map<int, int> contributionMap;\\n        for (const auto& t : trips) {\\n            bfs(n, adjList, contributionMap, t[0], t[1]);\\n        }\\n\\n        // Calculate the minimum price using dfs with DP.\\n        vector<vector<int>> dp(n, vector<int>(2, -1));\\n        int ans = dfs(contributionMap, adjList, price, 0, dp, 0, -1);\\n        return ans;\\n    }\\n\\nprivate:\\n    int dfs(unordered_map<int, int>& contributionMap, unordered_map<int, vector<int>>& adjList, vector<int>& price, int curr, vector<vector<int>>& dp, int isParentHalved, int parent) {\\n        if (dp[curr][isParentHalved] != -1) return dp[curr][isParentHalved];\\n\\n        // For the current node, store the price with the price[current] halved.\\n        int halved = contributionMap[curr] * (price[curr] / 2);\\n\\n        // For the current node, store the price with the price[current] not halved.\\n        int notHalved = contributionMap[curr] * price[curr];\\n\\n        // if parent is halved, then current will be not halved\\n        // if parent is not halved, we can either half or not half it\\n        for (int neighbour : adjList[curr]) {\\n            if (neighbour != parent) {\\n                notHalved += dfs(contributionMap, adjList, price, neighbour, dp, 0, curr);\\n            }\\n        }\\n        if (isParentHalved == 1) {\\n            return dp[curr][isParentHalved] = notHalved;  // return the notHalved value since parent is halved and current can\\'t be halved\\n        }\\n\\n        for (int neighbour : adjList[curr]) {\\n            if (neighbour != parent) {\\n                halved += dfs(contributionMap, adjList, price, neighbour, dp, 1, curr);\\n            }\\n        }\\n        return dp[curr][isParentHalved] = min(halved, notHalved);  // return the min of halved and non-halved when parent is not halved.\\n    }\\n\\n    void bfs(int n, unordered_map<int, vector<int>>& adjList, unordered_map<int, int>& contibutionMap, int start, int end) {\\n        queue<int> q;\\n        vector<bool> visited(n, false);\\n        vector<int> parent(n, -1);\\n        q.push(start);\\n        visited[start] = true;\\n        while (!q.empty()) {\\n            int temp = q.front();\\n            q.pop();\\n            if (temp == end) break;\\n\\n            for (int neighbour : adjList[temp]) {\\n                if (!visited[neighbour]) {\\n                    q.push(neighbour);\\n                    visited[neighbour] = true;\\n                    parent[neighbour] = temp;\\n                }\\n            }\\n        }\\n        start = end;\\n        while (start != -1) {\\n            contibutionMap[start]++;\\n            start = parent[start];\\n        }\\n    }\\n};\\n```\n```python []\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def minimumTotalPrice(self, n, edges, price, trips):\\n        # Create Adjacency List\\n        adjList = defaultdict(list)\\n        for edge in edges:\\n            adjList[edge[0]].append(edge[1])\\n            adjList[edge[1]].append(edge[0])\\n\\n        # For all the trips, find the shortest path and update the contribution map.\\n        contributionMap = {}\\n        for t in trips:\\n            self.bfs(n, adjList, contributionMap, t[0], t[1])\\n\\n        # Calculate the minimum price using dfs with DP.\\n        dp = [[-1 for _ in range(2)] for _ in range(n)]\\n        ans = self.dfs(contributionMap, adjList, price, 0, dp, 0, -1)\\n        return ans\\n\\n    def dfs(self, contributionMap, adjList, price, curr, dp, isParentHalved, parent):\\n        if dp[curr][isParentHalved] != -1:\\n            return dp[curr][isParentHalved]\\n\\n        # For the current node, store the price with the price[current] halved.\\n        halved = contributionMap.get(curr, 0) * (price[curr] // 2)\\n\\n        # For the current node, store the price with the price[current] not halved.\\n        notHalved = contributionMap.get(curr, 0) * price[curr]\\n\\n        # if parent is halved, then current will be not halved\\n        # if parent is not halved, we can either half or not half it\\n        for neighbour in adjList[curr]:\\n            if neighbour != parent:\\n                notHalved += self.dfs(contributionMap, adjList, price, neighbour, dp, 0, curr)\\n        if isParentHalved == 1:\\n            dp[curr][isParentHalved] = notHalved  # return the notHalved value since parent is halved and current can\\'t be halved\\n            return dp[curr][isParentHalved]\\n\\n        for neighbour in adjList[curr]:\\n            if neighbour != parent:\\n                halved += self.dfs(contributionMap, adjList, price, neighbour, dp, 1, curr)\\n        dp[curr][isParentHalved] = min(halved, notHalved)  # return the min of halved and non-halved when parent is not halved.\\n        return dp[curr][isParentHalved]\\n\\n    def bfs(self, n, adjList, contributionMap, start, end):\\n        q = deque()\\n        visited = [False] * n\\n        parent = [-1] * n\\n        q.append(start)\\n        visited[start] = True\\n        while q:\\n            temp = q.popleft()\\n            if temp == end:\\n                break\\n\\n            for neighbour in adjList[temp]:\\n                if not visited[neighbour]:\\n                    q.append(neighbour)\\n                    visited[neighbour] = True\\n                    parent[neighbour] = temp\\n\\n        while start != -1:\\n            contributionMap[start] = contributionMap.get(start, 0) + 1\\n            start = parent[start]\\n```\n```javascript []\\nfunction minimumTotalPrice(n, edges, price, trips) {\\n\\n    // Create Adjacency List\\n    let adjList = new Map();\\n    for (let i = 0; i < n; i++) adjList.set(i, []);\\n    for (let edge of edges) {\\n        adjList.get(edge[0]).push(edge[1]);\\n        adjList.get(edge[1]).push(edge[0]);\\n    }\\n\\n    // For all the trips, find the shortest path and update the contribution map.\\n    let contributionMap = new Map();\\n    for (let t of trips) {\\n        bfs(n, adjList, contributionMap, t[0], t[1]);\\n    }\\n\\n    // Calculate the minimum price using dfs with DP.\\n    let dp = new Array(n).fill(null).map(() => new Array(2).fill(-1));\\n    let ans = dfs(contributionMap, adjList, price, 0, dp, 0, -1);\\n    return ans;\\n}\\n\\nfunction dfs(contributionMap, adjList, price, curr, dp, isParentHalved, parent) {\\n    if (dp[curr][isParentHalved] !== -1) return dp[curr][isParentHalved];\\n\\n    // For the current node, store the price with the price[current] halved.\\n    let halved = contributionMap.get(curr) ? contributionMap.get(curr) * Math.floor(price[curr] / 2) : 0;\\n\\n    // For the current node, store the price with the price[current] not halved.\\n    let notHalved = contributionMap.get(curr) ? contributionMap.get(curr) * price[curr] : 0;\\n\\n    // if parent is halved, then current will be not halved\\n    // if parent is not halved, we can either half or not half it\\n    for (let neighbour of adjList.get(curr)) {\\n        if (neighbour !== parent) {\\n            notHalved += dfs(contributionMap, adjList, price, neighbour, dp, 0, curr);\\n        }\\n    }\\n    if (isParentHalved === 1) {\\n        return dp[curr][isParentHalved] = notHalved; // return the notHalved value since parent is halved and current can\\'t be halved\\n    }\\n\\n    for (let neighbour of adjList.get(curr)) {\\n        if (neighbour !== parent) {\\n            halved += dfs(contributionMap, adjList, price, neighbour, dp, 1, curr);\\n        }\\n    }\\n    return dp[curr][isParentHalved] = Math.min(halved, notHalved); // return the min of halved and non-halved when parent is not halved.\\n}\\n\\nfunction bfs(n, adjList, contibutionMap, start, end) {\\n    let q = [];\\n    let visited = new Array(n).fill(false);\\n    let parent = new Array(n).fill(-1);\\n    q.push(start);\\n    visited[start] = true;\\n    while (q.length > 0) {\\n        let temp = q.shift();\\n        if (temp === end) break;\\n\\n        for (let neighbour of adjList.get(temp)) {\\n            if (!visited[neighbour]) {\\n                q.push(neighbour);\\n                visited[neighbour] = true;\\n                parent[neighbour] = temp;\\n            }\\n        }\\n    }\\n    start = end;\\n    while (start !== -1) {\\n        contibutionMap.set(start, (contibutionMap.get(start) || 0) + 1);\\n        start = parent[start];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422858,
                "title": "python-dijkstra-s-algorithm-dynamic-programming",
                "content": "# Intuition\\nHow to know what nodes are better to halve? Maybe we need to find all required paths first. And then we can optimize our existing paths. \\n\\n# Approach\\nUse Dijkstra\\'s algorithm to find shortest paths. \\nThen Use Dynamic programming with memoization to optimize paths.\\n\\nTo optimize paths we can recursively try to select each node to halve or leave it as is. And find the best option. \\n\\n# Complexity\\n- Time complexity: $$O((V+E)logV + V*logV)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(E*V)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        adjancency_list = [[] for _ in range(n)]\\n        for edge1, edge2 in edges:\\n            adjancency_list[edge1].append(edge2)\\n            adjancency_list[edge2].append(edge1)\\n\\n        s = 0\\n        used_nodes_count = {}\\n        for from_trip, to_trip in trips:\\n            path, _price = self.findShortestPath(adjancency_list, price, from_trip, to_trip)\\n            s += _price\\n            for node in path:\\n                used_nodes_count[node] = used_nodes_count.get(node, 0) + 1\\n\\n        cache = {}\\n        mx1 = self.findMinPrice(None, 0, True, adjancency_list, used_nodes_count, price, cache)\\n        mx2 = self.findMinPrice(None, 0, False, adjancency_list, used_nodes_count, price, cache)\\n        return min(mx1, mx2)\\n\\n    def findMinPrice(self, parent, node, selected, adjancency_list, used_nodes_count, price, cache):\\n        if (node, selected) in cache:\\n            return cache[(node, selected)]\\n\\n        if selected:\\n            cost = (price[node] // 2) * used_nodes_count.get(node, 0)\\n        else:\\n            cost = price[node] * used_nodes_count.get(node, 0)\\n\\n        mins = []\\n        for child in adjancency_list[node]:\\n            if child == parent:\\n                continue\\n\\n            options = []\\n            if not selected:\\n                mx = self.findMinPrice(node, child, True, adjancency_list, used_nodes_count, price, cache)\\n                options.append(mx)\\n            mx = self.findMinPrice(node, child, False, adjancency_list, used_nodes_count, price, cache)\\n            options.append(mx)\\n            mins.append(min(options))\\n\\n        cache[(node, selected)] = cost + sum(mins)\\n        return cost + sum(mins)\\n\\n    def findShortestPath(self, adjancency_list, price, from_trip, to_trip):\\n        dist = [-1] * len(adjancency_list)\\n        parents = {}\\n\\n        dist[from_trip] = price[from_trip]\\n        visited = set()\\n        queued = {from_trip}\\n\\n        while queued:\\n            node = queued.pop()\\n            if node in visited:\\n                continue\\n\\n            visited.add(node)\\n\\n            for to_node in adjancency_list[node]:\\n                current_dist = dist[node] + price[to_node]\\n                if dist[to_node] != -1 and dist[to_node] < current_dist:\\n                    continue\\n                dist[to_node] = current_dist\\n                parents[to_node] = node\\n                queued.add(to_node)\\n                if to_node in visited:\\n                    visited.remove(to_node)\\n\\n        path = [to_trip]\\n        cur_node = to_trip\\n        while cur_node != from_trip:\\n            cur_node = parents[cur_node]\\n            path.append(cur_node)\\n\\n        return path, dist[to_trip]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\n\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        adjancency_list = [[] for _ in range(n)]\\n        for edge1, edge2 in edges:\\n            adjancency_list[edge1].append(edge2)\\n            adjancency_list[edge2].append(edge1)\\n\\n        s = 0\\n        used_nodes_count = {}\\n        for from_trip, to_trip in trips:\\n            path, _price = self.findShortestPath(adjancency_list, price, from_trip, to_trip)\\n            s += _price\\n            for node in path:\\n                used_nodes_count[node] = used_nodes_count.get(node, 0) + 1\\n\\n        cache = {}\\n        mx1 = self.findMinPrice(None, 0, True, adjancency_list, used_nodes_count, price, cache)\\n        mx2 = self.findMinPrice(None, 0, False, adjancency_list, used_nodes_count, price, cache)\\n        return min(mx1, mx2)\\n\\n    def findMinPrice(self, parent, node, selected, adjancency_list, used_nodes_count, price, cache):\\n        if (node, selected) in cache:\\n            return cache[(node, selected)]\\n\\n        if selected:\\n            cost = (price[node] // 2) * used_nodes_count.get(node, 0)\\n        else:\\n            cost = price[node] * used_nodes_count.get(node, 0)\\n\\n        mins = []\\n        for child in adjancency_list[node]:\\n            if child == parent:\\n                continue\\n\\n            options = []\\n            if not selected:\\n                mx = self.findMinPrice(node, child, True, adjancency_list, used_nodes_count, price, cache)\\n                options.append(mx)\\n            mx = self.findMinPrice(node, child, False, adjancency_list, used_nodes_count, price, cache)\\n            options.append(mx)\\n            mins.append(min(options))\\n\\n        cache[(node, selected)] = cost + sum(mins)\\n        return cost + sum(mins)\\n\\n    def findShortestPath(self, adjancency_list, price, from_trip, to_trip):\\n        dist = [-1] * len(adjancency_list)\\n        parents = {}\\n\\n        dist[from_trip] = price[from_trip]\\n        visited = set()\\n        queued = {from_trip}\\n\\n        while queued:\\n            node = queued.pop()\\n            if node in visited:\\n                continue\\n\\n            visited.add(node)\\n\\n            for to_node in adjancency_list[node]:\\n                current_dist = dist[node] + price[to_node]\\n                if dist[to_node] != -1 and dist[to_node] < current_dist:\\n                    continue\\n                dist[to_node] = current_dist\\n                parents[to_node] = node\\n                queued.add(to_node)\\n                if to_node in visited:\\n                    visited.remove(to_node)\\n\\n        path = [to_trip]\\n        cur_node = to_trip\\n        while cur_node != from_trip:\\n            cur_node = parents[cur_node]\\n            path.append(cur_node)\\n\\n        return path, dist[to_trip]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422716,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        for a,b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n       \\n        count = Counter()\\n    \\n        totalCost = 0\\n\\n        def dfs(node,par,end):\\n            nonlocal count\\n            nonlocal totalCost\\n            if node == end:\\n                return True\\n            \\n            for nei in graph[node]:\\n                if nei != par:\\n                    if dfs(nei, node, end):\\n                        count[nei] += 1\\n                        totalCost += price[nei]\\n                        return True\\n            return False\\n\\n       \\n        for start,end in trips:\\n            count[start] += 1\\n            totalCost += price[start]\\n            dfs(start,None,end)\\n        \\n      \\n        @cache\\n        def dp(node, par, canReduce):\\n            if canReduce:\\n                res = (price[node]//2)*count[node]\\n            else:\\n                res = 0\\n            red = 0\\n            for nei in graph[node]:\\n                if nei != par:\\n               \\n                    if canReduce:\\n                        cur = dp(nei, node, False)\\n\\n                    else:\\n                        cur = max(dp(nei, node, False), dp(nei, node, True))\\n                    red += cur\\n            return res + red\\n        \\n    \\n        reduce = 0\\n        for i in range(n):\\n            reduce = max( reduce, dp(i, None, True), dp(i, None, False) )\\n        \\n    \\n        return totalCost - reduce\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        for a,b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n       \\n        count = Counter()\\n    \\n        totalCost = 0\\n\\n        def dfs(node,par,end):\\n            nonlocal count\\n            nonlocal totalCost\\n            if node == end:\\n                return True\\n            \\n            for nei in graph[node]:\\n                if nei != par:\\n                    if dfs(nei, node, end):\\n                        count[nei] += 1\\n                        totalCost += price[nei]\\n                        return True\\n            return False\\n\\n       \\n        for start,end in trips:\\n            count[start] += 1\\n            totalCost += price[start]\\n            dfs(start,None,end)\\n        \\n      \\n        @cache\\n        def dp(node, par, canReduce):\\n            if canReduce:\\n                res = (price[node]//2)*count[node]\\n            else:\\n                res = 0\\n            red = 0\\n            for nei in graph[node]:\\n                if nei != par:\\n               \\n                    if canReduce:\\n                        cur = dp(nei, node, False)\\n\\n                    else:\\n                        cur = max(dp(nei, node, False), dp(nei, node, True))\\n                    red += cur\\n            return res + red\\n        \\n    \\n        reduce = 0\\n        for i in range(n):\\n            reduce = max( reduce, dp(i, None, True), dp(i, None, False) )\\n        \\n    \\n        return totalCost - reduce\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421862,
                "title": "bfs-dfs-dp",
                "content": "# Intuition\\nBFS + DFS + DP\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<list<int>> g(n);\\n        for (auto& edge: edges) {\\n            g[edge[0]].push_back(edge[1]);\\n            g[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int> cnts(n, 0);\\n        for (auto& trip: trips) {\\n            BFS(g, cnts, trip[0], trip[1]);\\n        }\\n        vector<int> weights(n);\\n        for (int i=0; i<n; i++) {\\n            weights[i] = cnts[i]*price[i];\\n        }\\n        auto [half, noHalf] = DFS(g, weights, 0, -1);\\n        return min(half, noHalf);\\n    }\\n    pair<int, int> DFS(vector<list<int>>& g, vector<int>& weights, int root, int prev) {\\n        int rootHalf = weights[root]/2;\\n        int rootNoHalf = weights[root];\\n        for (int adj: g[root]) {\\n            if (adj == prev) continue;\\n            auto [half, noHalf] = DFS(g, weights, adj, root);\\n            rootHalf += noHalf;\\n            rootNoHalf += min(half, noHalf);\\n        }\\n        return {rootHalf, rootNoHalf};\\n    }\\n    void BFS(vector<list<int>>& g, vector<int>& cnts, int start, int end) {\\n        int n = g.size();\\n        vector<bool> visited(n, false);\\n        vector<int> prev(n, -1);\\n        queue<int> q;\\n        q.push(start);\\n        while (!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            if (node == end) break;\\n            if (visited[node]) continue;\\n            visited[node] = true;\\n            for (int adj: g[node]) {\\n                if (visited[adj]) continue;\\n                prev[adj] = node;\\n                q.push(adj);\\n            }\\n        }\\n        int x = end;\\n        while (x != -1) {\\n            cnts[x]++;\\n            x = prev[x];\\n        }\\n    }\\n};\\n```\\n# Similar Question\\n[337. House Robber III](https://leetcode.com/problems/house-robber-iii/)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<list<int>> g(n);\\n        for (auto& edge: edges) {\\n            g[edge[0]].push_back(edge[1]);\\n            g[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int> cnts(n, 0);\\n        for (auto& trip: trips) {\\n            BFS(g, cnts, trip[0], trip[1]);\\n        }\\n        vector<int> weights(n);\\n        for (int i=0; i<n; i++) {\\n            weights[i] = cnts[i]*price[i];\\n        }\\n        auto [half, noHalf] = DFS(g, weights, 0, -1);\\n        return min(half, noHalf);\\n    }\\n    pair<int, int> DFS(vector<list<int>>& g, vector<int>& weights, int root, int prev) {\\n        int rootHalf = weights[root]/2;\\n        int rootNoHalf = weights[root];\\n        for (int adj: g[root]) {\\n            if (adj == prev) continue;\\n            auto [half, noHalf] = DFS(g, weights, adj, root);\\n            rootHalf += noHalf;\\n            rootNoHalf += min(half, noHalf);\\n        }\\n        return {rootHalf, rootNoHalf};\\n    }\\n    void BFS(vector<list<int>>& g, vector<int>& cnts, int start, int end) {\\n        int n = g.size();\\n        vector<bool> visited(n, false);\\n        vector<int> prev(n, -1);\\n        queue<int> q;\\n        q.push(start);\\n        while (!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            if (node == end) break;\\n            if (visited[node]) continue;\\n            visited[node] = true;\\n            for (int adj: g[node]) {\\n                if (visited[adj]) continue;\\n                prev[adj] = node;\\n                q.push(adj);\\n            }\\n        }\\n        int x = end;\\n        while (x != -1) {\\n            cnts[x]++;\\n            x = prev[x];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421678,
                "title": "python-lowest-common-ancestor",
                "content": "We use lowest common ancestor to find path for each trip. Let `freq` be the frequencies for each node. `dp(i, p)` returns the maximum price we can save without or with choosing node `i`.\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        g = [[] for _ in range(n)]\\n        for i, j in edges:\\n            g[i].append(j)\\n            g[j].append(i)\\n            \\n        freq = [0] * n\\n        level = [0] * n\\n        parent = [0] * n\\n        \\n        def dfs(i, l, p):\\n            level[i] = l\\n            parent[i] = p\\n            for j in g[i]:\\n                if j != p:\\n                    dfs(j, l + 1, i)\\n        \\n        def LCA(a, b):\\n            if level[a] > level[b]:\\n                a, b = b, a\\n            d = level[b] - level[a]\\n            while d:\\n                b = parent[b]\\n                d -= 1\\n            if a == b:\\n                return a\\n            while a != b:\\n                a = parent[a]\\n                b = parent[b]\\n            return a\\n        \\n        dfs(0, 0, -1)\\n        for i, j in trips:\\n            lca = LCA(i, j)\\n            path = []\\n            while i != lca:\\n                freq[i] += 1\\n                i = parent[i]\\n            freq[i] += 1\\n            while j != lca:\\n                freq[j] += 1\\n                j = parent[j]\\n        \\n        def dp(i, p):\\n            res0 = 0\\n            res1 = price[i] // 2 * freq[i]\\n            for j in g[i]:\\n                if j != p:\\n                    curr = dp(j, i)\\n                    res0 += max(curr)\\n                    res1 += curr[0]\\n            return [res0, res1]\\n        ans = 0\\n        for i in range(n):\\n            ans += freq[i] * price[i]\\n        return ans - max(dp(0, -1))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        g = [[] for _ in range(n)]\\n        for i, j in edges:\\n            g[i].append(j)\\n            g[j].append(i)\\n            \\n        freq = [0] * n\\n        level = [0] * n\\n        parent = [0] * n\\n        \\n        def dfs(i, l, p):\\n            level[i] = l\\n            parent[i] = p\\n            for j in g[i]:\\n                if j != p:\\n                    dfs(j, l + 1, i)\\n        \\n        def LCA(a, b):\\n            if level[a] > level[b]:\\n                a, b = b, a\\n            d = level[b] - level[a]\\n            while d:\\n                b = parent[b]\\n                d -= 1\\n            if a == b:\\n                return a\\n            while a != b:\\n                a = parent[a]\\n                b = parent[b]\\n            return a\\n        \\n        dfs(0, 0, -1)\\n        for i, j in trips:\\n            lca = LCA(i, j)\\n            path = []\\n            while i != lca:\\n                freq[i] += 1\\n                i = parent[i]\\n            freq[i] += 1\\n            while j != lca:\\n                freq[j] += 1\\n                j = parent[j]\\n        \\n        def dp(i, p):\\n            res0 = 0\\n            res1 = price[i] // 2 * freq[i]\\n            for j in g[i]:\\n                if j != p:\\n                    curr = dp(j, i)\\n                    res0 += max(curr)\\n                    res1 += curr[0]\\n            return [res0, res1]\\n        ans = 0\\n        for i in range(n):\\n            ans += freq[i] * price[i]\\n        return ans - max(dp(0, -1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4093839,
                "title": "java-94-w-explanation",
                "content": "# Intuition\\nThe fundamental idea arises from the understanding that if certain nodes are traveled more frequently during the trips, then reducing the price of these nodes will have a more significant impact on decreasing the overall cost. To solve this problem, we need to first identify how many trips pass through each node, and then dynamically decide whether to halve the price of that node based on its impact on the total price.\\n\\n# Approach\\n1. Construct an adjacency list representation of the tree using the provided edges to facilitate easy traversal.\\n2. For each trip, use Depth-First Search (DFS) to traverse from the start to the end node, incrementing a counter for every node visited. This helps in determining how frequently each node is visited during all trips.\\n3. With the frequency of visits to each node determined, employ a dynamic programming approach to calculate the minimum cost for each node. Two scenarios are explored recursively:\\n   - The cost of the node when its price is halved.\\n   - The cost when the node\\'s price is not halved.\\n   \\n   By storing already computed results in a memoization table, redundant calculations are avoided, and the solution is reached more efficiently.\\n4. The minimum cost for all trips is determined by the cumulative decision of whether to halve the node prices or not, based on the results of the recursive calculations.\\n\\n# Complexity\\n- Time complexity:\\nThe main contributors to time complexity are the DFS for each trip and the dynamic programming approach. For each trip, in the worst case, the DFS may traverse all nodes, making it \\\\(O(n)\\\\) per trip. If there are \\\\(m\\\\) trips, this becomes \\\\(O(m \\\\times n)\\\\). The dynamic programming approach can potentially explore each node twice (one for halved, one for not halved), making it \\\\(O(2n)\\\\). Combining the two, the time complexity is \\\\(O(m \\\\times n + 2n)\\\\), which can be simplified to \\\\(O(m \\\\times n)\\\\).\\n\\n- Space complexity:\\nThe main space overheads are the adjacency list representation of the tree, which takes \\\\(O(n)\\\\) space, and the memoization table which also takes \\\\(O(2n)\\\\) space, resulting in \\\\(O(3n)\\\\). Simplifying, we get a space complexity of \\\\(O(n)\\\\).\\n\\n# Code\\n```\\nclass Solution {\\n    int nodeVisitCount[]; // To store the number of times each node is visited\\n    int memo[][];  // Memoization table to store computed results\\n\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n       \\n        ArrayList<Integer> adjacencyList[] = new ArrayList[n];\\n        for(int i = 0; i < n; i++) {\\n            adjacencyList[i] = new ArrayList<>();\\n        }\\n        \\n        // Create adjacency list from edges\\n        for(int i = 0; i < edges.length; i++) {\\n            adjacencyList[edges[i][0]].add(edges[i][1]);\\n            adjacencyList[edges[i][1]].add(edges[i][0]);\\n        }\\n        \\n        nodeVisitCount = new int[n];\\n        \\n        // For each trip, traverse the path and update node visit count\\n        for(int i = 0; i < trips.length; i++) {\\n            int start = trips[i][0];\\n            int destination = trips[i][1];\\n            nodeVisitCount[start]++;\\n            traversePath(start, destination, adjacencyList, -1);\\n        }\\n    \\n        memo = new int[n][2];\\n        for(int i = 0; i < n; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }\\n      \\n        return findMinPrice(0, -1, 0, adjacencyList, price);  \\n    }\\n    \\n    public int findMinPrice(int node, int parent, int halved, ArrayList<Integer> adjacencyList[], int price[]) {\\n        \\n        int priceIfHalved = nodeVisitCount[node] * price[node] / 2;\\n        int priceIfNotHalved = nodeVisitCount[node] * price[node];\\n        \\n        // If the result is already computed, return from memoization\\n        if(memo[node][halved] != -1) {\\n            return memo[node][halved];\\n        }\\n        \\n        for(int adjacentNode : adjacencyList[node]) {\\n            if(adjacentNode != parent) {\\n                priceIfNotHalved += findMinPrice(adjacentNode, node, 0, adjacencyList, price);\\n            }\\n        }\\n        \\n        if(halved == 1) {\\n            return memo[node][halved] = priceIfNotHalved;\\n        }\\n        \\n        for(int adjacentNode : adjacencyList[node]) {\\n            if(adjacentNode != parent) {\\n                priceIfHalved += findMinPrice(adjacentNode, node, 1, adjacencyList, price);\\n            }\\n        }\\n        \\n        // Return the minimum of the two prices\\n        return memo[node][halved] = Math.min(priceIfHalved, priceIfNotHalved);\\n    }\\n    \\n    // Method to traverse path for a trip and update node visit count\\n    public boolean traversePath(int source, int destination, ArrayList<Integer> adjacencyList[], int parent) {\\n        \\n        if(source == destination) {\\n            return true;\\n        }\\n        \\n        for(int adjacentNode : adjacencyList[source]) {\\n            if(adjacentNode != parent) {\\n                if(traversePath(adjacentNode, destination, adjacencyList, source)) {\\n                    nodeVisitCount[adjacentNode]++;\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int nodeVisitCount[]; // To store the number of times each node is visited\\n    int memo[][];  // Memoization table to store computed results\\n\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n       \\n        ArrayList<Integer> adjacencyList[] = new ArrayList[n];\\n        for(int i = 0; i < n; i++) {\\n            adjacencyList[i] = new ArrayList<>();\\n        }\\n        \\n        // Create adjacency list from edges\\n        for(int i = 0; i < edges.length; i++) {\\n            adjacencyList[edges[i][0]].add(edges[i][1]);\\n            adjacencyList[edges[i][1]].add(edges[i][0]);\\n        }\\n        \\n        nodeVisitCount = new int[n];\\n        \\n        // For each trip, traverse the path and update node visit count\\n        for(int i = 0; i < trips.length; i++) {\\n            int start = trips[i][0];\\n            int destination = trips[i][1];\\n            nodeVisitCount[start]++;\\n            traversePath(start, destination, adjacencyList, -1);\\n        }\\n    \\n        memo = new int[n][2];\\n        for(int i = 0; i < n; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }\\n      \\n        return findMinPrice(0, -1, 0, adjacencyList, price);  \\n    }\\n    \\n    public int findMinPrice(int node, int parent, int halved, ArrayList<Integer> adjacencyList[], int price[]) {\\n        \\n        int priceIfHalved = nodeVisitCount[node] * price[node] / 2;\\n        int priceIfNotHalved = nodeVisitCount[node] * price[node];\\n        \\n        // If the result is already computed, return from memoization\\n        if(memo[node][halved] != -1) {\\n            return memo[node][halved];\\n        }\\n        \\n        for(int adjacentNode : adjacencyList[node]) {\\n            if(adjacentNode != parent) {\\n                priceIfNotHalved += findMinPrice(adjacentNode, node, 0, adjacencyList, price);\\n            }\\n        }\\n        \\n        if(halved == 1) {\\n            return memo[node][halved] = priceIfNotHalved;\\n        }\\n        \\n        for(int adjacentNode : adjacencyList[node]) {\\n            if(adjacentNode != parent) {\\n                priceIfHalved += findMinPrice(adjacentNode, node, 1, adjacencyList, price);\\n            }\\n        }\\n        \\n        // Return the minimum of the two prices\\n        return memo[node][halved] = Math.min(priceIfHalved, priceIfNotHalved);\\n    }\\n    \\n    // Method to traverse path for a trip and update node visit count\\n    public boolean traversePath(int source, int destination, ArrayList<Integer> adjacencyList[], int parent) {\\n        \\n        if(source == destination) {\\n            return true;\\n        }\\n        \\n        for(int adjacentNode : adjacencyList[source]) {\\n            if(adjacentNode != parent) {\\n                if(traversePath(adjacentNode, destination, adjacencyList, source)) {\\n                    nodeVisitCount[adjacentNode]++;\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051401,
                "title": "c-dfs-dp-beats-100-114ms",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public int MinimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips)\\n    {\\n        List<int>[] tree = new List<int>[n];\\n        for (int i = 0; i < n; i++)\\n            tree[i] = new();\\n        foreach (var edge in edges)\\n        {\\n            tree[edge[0]].Add(edge[1]);\\n            tree[edge[1]].Add(edge[0]);\\n        }\\n\\n        int[] nodesVisitedCount = new int[n];\\n        HashSet<int> tempPath = new();\\n\\n        void ComputeNodesVisitedCount(int start, int end)\\n        {\\n            tempPath.Add(start);\\n            if (start == end)\\n                foreach (var node in tempPath)\\n                    nodesVisitedCount[node]++;\\n            else\\n                foreach (var node in tree[start])\\n                {\\n                    if (tempPath.Contains(node))\\n                        continue;\\n\\n                    ComputeNodesVisitedCount(node, end);\\n                }\\n            tempPath.Remove(start);\\n        }\\n\\n        foreach (var trip in trips)\\n            ComputeNodesVisitedCount(trip[0], trip[1]);\\n\\n        int[] ComputeMinPrices(int parentNode, int node)\\n        {\\n            int whole = 0, halved = 0;\\n            foreach (var nodeToVisit in tree[node])\\n            {\\n                if (nodeToVisit == parentNode) continue;\\n                var childPrices = ComputeMinPrices(node, nodeToVisit);\\n                halved += childPrices[1];\\n                whole += Math.Min(childPrices[0], childPrices[1]);\\n            }\\n            return new[] {\\n                price[node] * nodesVisitedCount[node] /2 + halved,\\n                price[node] * nodesVisitedCount[node] + whole\\n                };\\n        }\\n\\n        var minPrices = ComputeMinPrices(-1, 0);\\n        return Math.Min(minPrices[0], minPrices[1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MinimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips)\\n    {\\n        List<int>[] tree = new List<int>[n];\\n        for (int i = 0; i < n; i++)\\n            tree[i] = new();\\n        foreach (var edge in edges)\\n        {\\n            tree[edge[0]].Add(edge[1]);\\n            tree[edge[1]].Add(edge[0]);\\n        }\\n\\n        int[] nodesVisitedCount = new int[n];\\n        HashSet<int> tempPath = new();\\n\\n        void ComputeNodesVisitedCount(int start, int end)\\n        {\\n            tempPath.Add(start);\\n            if (start == end)\\n                foreach (var node in tempPath)\\n                    nodesVisitedCount[node]++;\\n            else\\n                foreach (var node in tree[start])\\n                {\\n                    if (tempPath.Contains(node))\\n                        continue;\\n\\n                    ComputeNodesVisitedCount(node, end);\\n                }\\n            tempPath.Remove(start);\\n        }\\n\\n        foreach (var trip in trips)\\n            ComputeNodesVisitedCount(trip[0], trip[1]);\\n\\n        int[] ComputeMinPrices(int parentNode, int node)\\n        {\\n            int whole = 0, halved = 0;\\n            foreach (var nodeToVisit in tree[node])\\n            {\\n                if (nodeToVisit == parentNode) continue;\\n                var childPrices = ComputeMinPrices(node, nodeToVisit);\\n                halved += childPrices[1];\\n                whole += Math.Min(childPrices[0], childPrices[1]);\\n            }\\n            return new[] {\\n                price[node] * nodesVisitedCount[node] /2 + halved,\\n                price[node] * nodesVisitedCount[node] + whole\\n                };\\n        }\\n\\n        var minPrices = ComputeMinPrices(-1, 0);\\n        return Math.Min(minPrices[0], minPrices[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037135,
                "title": "c-with-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> cntmap;\\n    unordered_map<string, int> memo;\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        unordered_map<int, vector<int>> g;\\n        int res  = 0;\\n        for(auto e: edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        unordered_set<int> visited;\\n        for(auto t:  trips) { \\n            dfs(t[0], t[1], g, visited);\\n            visited.clear();\\n        }\\n        visited.clear();\\n\\n        int reduceroot   = reduce(0, g, visited, price, 1);\\n        visited.clear();\\n        int noreduceroot = reduce(0, g, visited, price, 0);\\n        return min(reduceroot,  noreduceroot);\\n    }\\n\\n    int reduce(int s, unordered_map<int, vector<int>> &g, unordered_set<int> &visited, vector<int>& price, bool canreduce) {\\n        int res = 0;\\n        string key = to_string(s) + \"_\" + to_string(canreduce);\\n        if(memo.count(key)) return memo[key];\\n        if(canreduce) {\\n            res += (price[s] / 2) * cntmap[s];\\n        }\\n        else res += price[s] * cntmap[s];\\n        visited.insert(s);\\n        for(auto next: g[s]) {\\n            if(visited.count(next)) continue;\\n            if(canreduce) {\\n                res += reduce(next, g, visited, price, 0);\\n            }\\n            else res += min(reduce(next, g, visited, price, 0), reduce(next, g, visited, price, 1));\\n        }\\n        visited.erase(s);\\n        memo[key] = res;\\n        return res;\\n\\n    }\\n\\n    bool dfs(int s, int t, unordered_map<int, vector<int>> &g, unordered_set<int> &visited) {\\n        if(s == t)   {\\n            cntmap[t]++;\\n            return 1;\\n        }\\n        visited.insert(s);\\n        for(auto next: g[s])  {\\n            if(!visited.count(next) and dfs(next,t,g, visited)) {\\n                cntmap[s]++;\\n                return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> cntmap;\\n    unordered_map<string, int> memo;\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        unordered_map<int, vector<int>> g;\\n        int res  = 0;\\n        for(auto e: edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        unordered_set<int> visited;\\n        for(auto t:  trips) { \\n            dfs(t[0], t[1], g, visited);\\n            visited.clear();\\n        }\\n        visited.clear();\\n\\n        int reduceroot   = reduce(0, g, visited, price, 1);\\n        visited.clear();\\n        int noreduceroot = reduce(0, g, visited, price, 0);\\n        return min(reduceroot,  noreduceroot);\\n    }\\n\\n    int reduce(int s, unordered_map<int, vector<int>> &g, unordered_set<int> &visited, vector<int>& price, bool canreduce) {\\n        int res = 0;\\n        string key = to_string(s) + \"_\" + to_string(canreduce);\\n        if(memo.count(key)) return memo[key];\\n        if(canreduce) {\\n            res += (price[s] / 2) * cntmap[s];\\n        }\\n        else res += price[s] * cntmap[s];\\n        visited.insert(s);\\n        for(auto next: g[s]) {\\n            if(visited.count(next)) continue;\\n            if(canreduce) {\\n                res += reduce(next, g, visited, price, 0);\\n            }\\n            else res += min(reduce(next, g, visited, price, 0), reduce(next, g, visited, price, 1));\\n        }\\n        visited.erase(s);\\n        memo[key] = res;\\n        return res;\\n\\n    }\\n\\n    bool dfs(int s, int t, unordered_map<int, vector<int>> &g, unordered_set<int> &visited) {\\n        if(s == t)   {\\n            cntmap[t]++;\\n            return 1;\\n        }\\n        visited.insert(s);\\n        for(auto next: g[s])  {\\n            if(!visited.count(next) and dfs(next,t,g, visited)) {\\n                cntmap[s]++;\\n                return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032691,
                "title": "c-dfs-dp-with-intuition-and-approach",
                "content": "\\n# Author: Jayesh Badgujar\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int src,int end,vector<int>& fre,map<int,vector<int>>& mp,int par){\\n        if(src==end){\\n            return true;\\n        }\\n        for(auto it:mp[src]){\\n            if(it!=par){\\n                fre[it]++;\\n                if(dfs(it,end,fre,mp,src)){\\n                    return true;\\n                }\\n                fre[it]--;\\n            }\\n        }\\n        return false;\\n    }\\n    int find(int src,map<int,vector<int>>& mp,vector<vector<int>>& dp,int last,int par,vector<int>& fre, vector<int>& price){\\n        if(dp[src][last]!=-1){\\n            return dp[src][last];\\n        }\\n        bool flag=false;\\n        int take_mini=(((fre[src])*(price[src]/2))),not_take_mini=(((fre[src])*(price[src])));\\n        for(auto it:mp[src]){\\n            if(it!=par){                \\n                if(last){                    \\n                    int take=find(it,mp,dp,0,src,fre,price);\\n                    if(take!=INT_MAX){\\n                        take_mini+=take;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        for(auto it:mp[src]){\\n            if(it!=par){\\n                int not_take=find(it,mp,dp,1,src,fre,price);\\n                if(not_take!=INT_MAX){\\n                    not_take_mini+=not_take;\\n                }\\n            }\\n        }\\n       \\n        if(last==0){\\n            return not_take_mini;\\n        }\\n        return dp[src][last]=min(take_mini,not_take_mini);\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        map<int,vector<int>> mp;\\n        vector<int> fre(n,0);\\n        vector<vector<int>> dp(n,vector<int>(2,-1));\\n        for(int i=0;i<edges.size();i++){\\n            mp[edges[i][0]].push_back(edges[i][1]);\\n            mp[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<trips.size();i++){\\n            fre[trips[i][0]]++;\\n            dfs(trips[i][0],trips[i][1],fre,mp,-1);\\n        }\\n        return find(0,mp,dp,1,-1,fre,price);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int src,int end,vector<int>& fre,map<int,vector<int>>& mp,int par){\\n        if(src==end){\\n            return true;\\n        }\\n        for(auto it:mp[src]){\\n            if(it!=par){\\n                fre[it]++;\\n                if(dfs(it,end,fre,mp,src)){\\n                    return true;\\n                }\\n                fre[it]--;\\n            }\\n        }\\n        return false;\\n    }\\n    int find(int src,map<int,vector<int>>& mp,vector<vector<int>>& dp,int last,int par,vector<int>& fre, vector<int>& price){\\n        if(dp[src][last]!=-1){\\n            return dp[src][last];\\n        }\\n        bool flag=false;\\n        int take_mini=(((fre[src])*(price[src]/2))),not_take_mini=(((fre[src])*(price[src])));\\n        for(auto it:mp[src]){\\n            if(it!=par){                \\n                if(last){                    \\n                    int take=find(it,mp,dp,0,src,fre,price);\\n                    if(take!=INT_MAX){\\n                        take_mini+=take;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        for(auto it:mp[src]){\\n            if(it!=par){\\n                int not_take=find(it,mp,dp,1,src,fre,price);\\n                if(not_take!=INT_MAX){\\n                    not_take_mini+=not_take;\\n                }\\n            }\\n        }\\n       \\n        if(last==0){\\n            return not_take_mini;\\n        }\\n        return dp[src][last]=min(take_mini,not_take_mini);\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        map<int,vector<int>> mp;\\n        vector<int> fre(n,0);\\n        vector<vector<int>> dp(n,vector<int>(2,-1));\\n        for(int i=0;i<edges.size();i++){\\n            mp[edges[i][0]].push_back(edges[i][1]);\\n            mp[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<trips.size();i++){\\n            fre[trips[i][0]]++;\\n            dfs(trips[i][0],trips[i][1],fre,mp,-1);\\n        }\\n        return find(0,mp,dp,1,-1,fre,price);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020182,
                "title": "ruby-solution-with-detailed-explanation-100-100",
                "content": "# Intuition\\nMap the trips, find how often each node gets hit in total, and use dynamic programming to find the minimum total price from halving nodes.\\n\\n# Approach\\n1. Convert edges to connections hash\\n    - Create a hash to hold connections.\\n    - Iterate through the edge.  For each edge, add the two endpoints to each other\\'s connections hash.\\n2. Convert each trip into a list of nodes I will hit (using DFS)\\n    - Map the trips to a sequence of nodes they hit using a DFS helper function.  (Since this is a tree and has no cycles, there\\'s only one possible path between any two nodes.)\\n3. Combine all paths into array and count frequency of each node\\n    - Create a hash to keep track of the frequency of each node.\\n    - Iterate through all the trips and increment the node count for each node.\\n4. Change each node\\'s price to its price times its frequency\\n    - The effective price of a node is the starting price times the number of trips it\\'s a part of.  It\\'s easier to work with if we change the prices array.\\n5. Delete backwards adjacencies so path only goes forward from 0\\n    - Iterate through nodes using BFS, starting at 0.  For each node, remove the path from next_node to current node.  (This is basically making 0 the root of the tree.  Any node could be the root -- 0 is arbitrary -- but it\\'s helpful to have a root.)\\n6. Starting from zero, find minimum sum with memoization\\n    - Create a memo and turn prices and connections into class variables so they can be accessed in a helper function.\\n    - Call a helper function starting at index 0 and 2 choices.\\n\\n**Helper function (min_price)**:\\nThis function finds the minimum price of a branch, taking in the node and the number of options.  (One option means that node\\'s price can\\'t be cut in half because an adjacent node\\'s was; two options means it could be.)\\n1. Return a stored value in memo if it exists\\n2. Create an options array.\\n3. Create option 1 (do not half this node)\\n    - Start option 1 as the price at node.\\n    - Iterate through each branch from node and add the min prices of each branch to option 1 (with two options, because we could half that node).\\n    - Push into options array.\\n4. Create option 2 if num_options = 2\\n    - Initialize option 2 as *half* the price of node (DO half this node).\\n    - Iterate through each branch from node and add the min prices of each branch to option 2 (with one option, because we *can\\'t* half these nodes).\\n    - Push into options array.\\n5. Choose the minimum option, memoize, and return\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * t)$$, where *t* is the number of trips.\\n\\n- Space complexity:\\n$$O(n * t)$$\\n\\n# Code\\n```\\ndef minimum_total_price(n, edges, prices, trips)\\n    connections = Hash.new { |h,k| h[k] = Set[] }\\n    edges.each do |edge|\\n        a,b = edge\\n        connections[a].add(b)\\n        connections[b].add(a)\\n    end\\n\\n    trips.map! { |trip| path(trip[0], trip[1], connections, Set[]) }\\n\\n    node_count = Hash.new(0)\\n    trips.flatten.each { |node| node_count[node] += 1 }\\n\\n    prices.each_with_index do |price,i|\\n        prices[i] = price * node_count[i]\\n    end\\n\\n    queue = [0]\\n    until queue.empty?\\n        node = queue.shift\\n        adjacent_nodes = connections[node]\\n        adjacent_nodes.each do |next_node|\\n            connections[next_node].delete(node)\\n            queue << next_node\\n        end\\n    end\\n\\n    @memo = Array.new(n) { [nil,nil] }\\n    @prices = prices\\n    @connections = connections\\n    min_price(0,2)\\nend\\n\\n\\ndef min_price(node,num_choices)\\n    return @memo[node][num_choices] if @memo[node][num_choices]\\n\\n    options = []\\n\\n    option1 = @prices[node]\\n    next_nodes = @connections[node]\\n    next_nodes.each do |branch|\\n        option1 += min_price(branch,2)\\n    end\\n    options << option1\\n\\n    if num_choices == 2\\n        option2 = @prices[node] / 2\\n        next_nodes.each do |branch|\\n            option2 += min_price(branch,1)\\n        end\\n        options << option2\\n    end\\n\\n    @memo[node][num_choices] = options.min\\nend\\n\\n\\ndef path(start, finish, connections, checked)\\n    return [start] if start == finish\\n    checked.add(start)\\n\\n    next_nodes = connections[start]\\n    next_nodes.each do |node|\\n        next if checked.include?(node)\\n\\n        res = path(node, finish, connections, checked)\\n        return [start] + res if res\\n    end\\n\\n    nil\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\ndef minimum_total_price(n, edges, prices, trips)\\n    connections = Hash.new { |h,k| h[k] = Set[] }\\n    edges.each do |edge|\\n        a,b = edge\\n        connections[a].add(b)\\n        connections[b].add(a)\\n    end\\n\\n    trips.map! { |trip| path(trip[0], trip[1], connections, Set[]) }\\n\\n    node_count = Hash.new(0)\\n    trips.flatten.each { |node| node_count[node] += 1 }\\n\\n    prices.each_with_index do |price,i|\\n        prices[i] = price * node_count[i]\\n    end\\n\\n    queue = [0]\\n    until queue.empty?\\n        node = queue.shift\\n        adjacent_nodes = connections[node]\\n        adjacent_nodes.each do |next_node|\\n            connections[next_node].delete(node)\\n            queue << next_node\\n        end\\n    end\\n\\n    @memo = Array.new(n) { [nil,nil] }\\n    @prices = prices\\n    @connections = connections\\n    min_price(0,2)\\nend\\n\\n\\ndef min_price(node,num_choices)\\n    return @memo[node][num_choices] if @memo[node][num_choices]\\n\\n    options = []\\n\\n    option1 = @prices[node]\\n    next_nodes = @connections[node]\\n    next_nodes.each do |branch|\\n        option1 += min_price(branch,2)\\n    end\\n    options << option1\\n\\n    if num_choices == 2\\n        option2 = @prices[node] / 2\\n        next_nodes.each do |branch|\\n            option2 += min_price(branch,1)\\n        end\\n        options << option2\\n    end\\n\\n    @memo[node][num_choices] = options.min\\nend\\n\\n\\ndef path(start, finish, connections, checked)\\n    return [start] if start == finish\\n    checked.add(start)\\n\\n    next_nodes = connections[start]\\n    next_nodes.each do |node|\\n        next if checked.include?(node)\\n\\n        res = path(node, finish, connections, checked)\\n        return [start] + res if res\\n    end\\n\\n    nil\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3987505,
                "title": "node-contribution-technique-dfs-dp-memo",
                "content": "# Intuition\\n\\n\\n# Approach\\nSince its a tree we know that moving from node a to b has only one path. so we will calculate while moving on \\'trip\\' how many times we visited each node. calculating this will give us the total sum of paths while covering each \\'trip\\'(We will save this in a \\'contri\\' array). But since we can decrease non adjacent nodes by half this is not the answer.\\nNow for deciding which nodes to select to make them half, we will us dp. We basically have to calculate maxsum while travelling through the tree such that no two adjacent nodes are taken (let say this value comes as maxi). \\nOur final answer would be sum of all the value of contribution -(maxi/2). because we will decrease every node value which contribute to maxi by half.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // ***Node Contribution Technique\\n    vector<int>g[51];\\n    int dp[51][2];\\n    void dfs(int node,vector<int>&vis,vector<int>&contri,int target,vector<int>tmp)\\n    {\\n        vis[node]=1;\\n        if(node==target){\\n            //contri[target]++;\\n            for(int i=0;i<tmp.size();i++){\\n                contri[tmp[i]]++;\\n            }\\n            return;\\n        }\\n        for(auto v:g[node]){\\n            if(!vis[v]){\\n                tmp.push_back(v);\\n                dfs(v,vis,contri,target,tmp);\\n                tmp.pop_back();\\n            }\\n        }\\n    }\\n    int rec(int node,int take,int par,vector<int>&contri)\\n    {\\n        if(dp[node][take]!=-1) return dp[node][take];\\n        if(take==0){\\n            int ans1=0;\\n            //take\\n            ans1=contri[node];\\n            for(auto v:g[node]){\\n                if(v!=par){\\n                    ans1+=rec(v,1,node,contri);\\n                }\\n            }\\n            //don\\'t take\\n            int ans2=0;\\n            for(auto v:g[node]){\\n                if(v!=par){\\n                    ans2+=rec(v,0,node,contri);\\n                }\\n            }\\n            return dp[node][take]= max(ans1,ans2);\\n        }\\n        else{\\n            //don\\'t take\\n            int ans2=0;\\n            for(auto v:g[node]){\\n                if(v!=par){\\n                    ans2+=rec(v,0,node,contri);\\n                }\\n            }\\n            return dp[node][take]=ans2;\\n        }\\n        return dp[node][take]=0;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        int m=edges.size();\\n        for(int i=0;i<m;i++){\\n            g[edges[i][0]].push_back(edges[i][1]);\\n            g[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>contri(n,0);\\n        int sz=trips.size();\\n        for(int i=0;i<sz;i++){\\n            vector<int>vis(n,0);\\n            int u=trips[i][0];\\n            int v= trips[i][1];\\n            vector<int>tmp;\\n            tmp.push_back(u);\\n            dfs(u,vis,contri,v,tmp);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            cout<<contri[i]<<\" \";\\n        }\\n        cout<<endl;\\n        for(int i=0;i<n;i++){\\n            contri[i]*=price[i];\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        int maxi = rec(0,0,-1,contri);\\n        for(int i=0;i<n;i++){\\n            ans+=contri[i];\\n        }\\n        return ans-(maxi/2);\\n        //return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // ***Node Contribution Technique\\n    vector<int>g[51];\\n    int dp[51][2];\\n    void dfs(int node,vector<int>&vis,vector<int>&contri,int target,vector<int>tmp)\\n    {\\n        vis[node]=1;\\n        if(node==target){\\n            //contri[target]++;\\n            for(int i=0;i<tmp.size();i++){\\n                contri[tmp[i]]++;\\n            }\\n            return;\\n        }\\n        for(auto v:g[node]){\\n            if(!vis[v]){\\n                tmp.push_back(v);\\n                dfs(v,vis,contri,target,tmp);\\n                tmp.pop_back();\\n            }\\n        }\\n    }\\n    int rec(int node,int take,int par,vector<int>&contri)\\n    {\\n        if(dp[node][take]!=-1) return dp[node][take];\\n        if(take==0){\\n            int ans1=0;\\n            //take\\n            ans1=contri[node];\\n            for(auto v:g[node]){\\n                if(v!=par){\\n                    ans1+=rec(v,1,node,contri);\\n                }\\n            }\\n            //don\\'t take\\n            int ans2=0;\\n            for(auto v:g[node]){\\n                if(v!=par){\\n                    ans2+=rec(v,0,node,contri);\\n                }\\n            }\\n            return dp[node][take]= max(ans1,ans2);\\n        }\\n        else{\\n            //don\\'t take\\n            int ans2=0;\\n            for(auto v:g[node]){\\n                if(v!=par){\\n                    ans2+=rec(v,0,node,contri);\\n                }\\n            }\\n            return dp[node][take]=ans2;\\n        }\\n        return dp[node][take]=0;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        int m=edges.size();\\n        for(int i=0;i<m;i++){\\n            g[edges[i][0]].push_back(edges[i][1]);\\n            g[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>contri(n,0);\\n        int sz=trips.size();\\n        for(int i=0;i<sz;i++){\\n            vector<int>vis(n,0);\\n            int u=trips[i][0];\\n            int v= trips[i][1];\\n            vector<int>tmp;\\n            tmp.push_back(u);\\n            dfs(u,vis,contri,v,tmp);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            cout<<contri[i]<<\" \";\\n        }\\n        cout<<endl;\\n        for(int i=0;i<n;i++){\\n            contri[i]*=price[i];\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        int maxi = rec(0,0,-1,contri);\\n        for(int i=0;i<n;i++){\\n            ans+=contri[i];\\n        }\\n        return ans-(maxi/2);\\n        //return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3927181,
                "title": "frequency-transform-of-space-o-t-v-e-log-e-t-o-t-v-v-2-e-log-e-s-commented-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition for this is based on a few key findings from the problem description. \\n\\nFirst is that we are concerned with the minimal cost of ALL trips. This means that since all trips need to be taken, we can assume the space can be reduced to a signal problem. Since it can be reduced to a signal problem, we can use frequency analysis. This lets us utilize the frequency of a node occurrence within a repeated traversral of a graph space to determine actual costs. If you\\'ve done networking, this should be a familiar problem statement from that point forward. \\n\\nFrom there, the next realization is that when calculating the costs, you are faced with a form of backtracking, either to discount or not to discount. This lets you know to track two costs as you move through the frequency aligned space. With this in line, we can then focus on finding the minimum costs of the minimum costs for all trips. \\n\\nFinally, as with any graphical approach, we need to be careful of self-loops. To prevent these, it is important that our traversal methods include a way to check against looping over the same space again. This can be used to prevent infinite cycles. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo set up a graph, we can use the edges to build our adjacency list in O(E) time and in O(V^2) space (We store each vertex, and for each vertex we store each neighbor of it) \\n\\nWe then want to know the frequency of each node in each trip in trips, so we set up a frequency tracker. \\n\\n- For each src and dst node in trips\\n    - conduct dfs freq with src and a next node of src to start\\n    - the src is off the map as it were, which is there to indicate against self loops \\n    - in depth first search frequency, if you have reached dst for src in the current trip at the current node \\n        - update frequency of the current node and return True \\n    - otherwise \\n        - search each neighbor for graph at current node that is not next node and who\\'s dfs_freq comes out to True \\n            - the first found that is such a case causes current nodes frequency to increment and to return True \\n        - if you never find a way to reach destination, return False \\n\\nThe above loop takes O(T) time to loop over all trips, and in the process conducts a dfs taking O(V) time to loop over all vertices for all trips. This takes a total of O(T * V). T is not limited based on E, and as such can cover a much wider range of options. \\n\\nWe then set up a cost memo \\nWe then set up dfs over the frequency linked paths as follows \\nGiven a current node and next node \\n- if (current node, next node) in cost memo, return its findings \\n- otherwise \\n    - set current fare as price at current node * frequency at current node \\n    - discounted fare is half that \\n    - for neighbor of current node \\n        - if neighbor is not next node \\n            - current neighbor fare, current neighbor discount are from dfs of neighbor and current node \\n            - increment current fare by min of the above two \\n            - discounted fare always goes up by current neighbor fare since you chose to discount THIS current node \\n    - at end, memoize in cost memo at current node and next node the values of [current_fare, discounted_fare]\\n    - return those values \\n\\nThe above is called on 0 and 0 to start and stored in a fare list \\nThe min of the min of the fare list is your answer. \\nThe dfs process takes at least O(V) to process each vertex. \\nAs it does we must track O(E) costs by processing neighbors. \\nAs it does we then update and store this, reaching a log E reduction. \\nThis gives us V * E log E. In a non-sparse graph, E is much greater than V, so we can have E log E. We also store O(T) trip costs. Since this is recursive, we store this space as well for the E log E unfortunately. \\n\\nNote the use of self loop prevention here, it comes up often in these problems! \\n\\n# Complexity\\n- Time complexity : O(T * V + E log E)\\n    - Takes O(T * V) to do the trip based frequency finding \\n    - Takes O(E log E) to do the cost memoization findings \\n    - Takes O(E to build graph) \\n    - E log E subsumes O(E) \\n    - Total is O(T * V + E log E)  \\n\\n- Space complexity : \\n    - Takes O(T * V) to do the dfs_freq timewise, but as it is recursive, takes similar space as well \\n    - Takes O(V^2) to store graph in adjacency list format \\n    - Takes E log E timewise to do frequency cost find recursively, so similar cost \\n    - We store T trip costs worth in our cost memo, but this is subsumed by T * V \\n    - Total is O(T*V + V^2 + E log E) where T is size of Trips, V is number of nodes, and E is number of Edges  \\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        # build adjacency list graph \\n        graph = [[] for _ in range(n)]\\n        for src, dst in edges : \\n            graph[src].append(dst)\\n            graph[dst].append(src)\\n        # since we have to take all trips, it\\'s easier to reduce the node space from a repeated loop over the tree \\n        # to a frequency based node space so that we can consider all the trips from a singular point of view \\n        # to do this, we need to process the frequency of each node reaching to a destination based on the neighbors \\n        # this can be done regardless of cost, since we will factor in cost based on the frequency at the later point of the algorithm \\n        # find frequency of each node \\n        frequency = [0] * n\\n        # by looping over trips \\n        for src, dst in trips : \\n            # dfs frequency loops each node in consideration to a next node \\n            def dfs_freq(current_node, next_node) : \\n                # where if current is now dst from outside looping \\n                if current_node == dst : \\n                    # update frequency of the current node in the search and return True \\n                    frequency[current_node] += 1 \\n                    return True \\n                else : \\n                    # otherwise, if not yet at destination, consider neighbors off of here \\n                    for neighbor in graph[current_node] : \\n                        # if the neighbor is not the next node we\\'d reach anyways,\\n                        # and the neighbor is able to eventually reach the destination without incurring a loop \\n                        if neighbor != next_node and dfs_freq(neighbor, current_node) : \\n                            # then we can increment the current nodes frequency and return true \\n                            frequency[current_node] += 1 \\n                            return True \\n                    # if we can never make it from this current node, we should return False \\n                    # we still need to get to this point, since along the way there may be other updates that occur \\n                    return False \\n            # and for each trip start, conducting dfs freq to find frequency of related node and sub nodes \\n            dfs_freq(src, src)\\n\\n        # memoize costs so to avoid repeat calculations \\n        cost_memo = dict() \\n        # this depth first search conducts based on fares. \\n        # the above loop set up the frequency interpretation, allowing us to skip multiple loops of cost accumulation otherwise \\n        # this is a transform of the problem space to a frequency based form, thus lowering overall complexity \\n        # this also allows us to now consider the costs based on the frequency that they might occur, allowing us to determine best choices for halving the price \\n        def dfs(current_node, next_node) : \\n            # check memo to avoid repeated calculations \\n            if (current_node, next_node) in cost_memo : \\n                return cost_memo[(current_node, next_node)][0], cost_memo[(current_node, next_node)][1] \\n            else : \\n                # here again, the next node serves as a check against self-loops \\n                # we start by calculating the current fare as a cost of price * frequency of occurrence on other trips \\n                current_fare = price[current_node] * frequency[current_node]\\n                # we then calculate the discounted price to allow for one way trip \\n                discounted_fare = current_fare//2\\n                # check local neighborhood \\n                for neighbor in graph[current_node] : \\n                    # and avoid self loops \\n                    if neighbor != next_node :\\n                        # set current neighbor fare and current neighbor discount as result of dfs on fare prices \\n                        current_neighbor_fare, current_neighbor_discount = dfs(neighbor, current_node)\\n                        # update current fare to track the minimum of the two (since you might discount this neighbor, or might not) \\n                        current_fare += min(current_neighbor_fare, current_neighbor_discount)\\n                        # discounted fare always gets the current neighbor fare since it was already discounted \\n                        discounted_fare += current_neighbor_fare\\n                # memoize your findings to avoid repeated calculations based on similar set ups \\n                cost_memo[(current_node, next_node)] = [current_fare, discounted_fare]\\n                # return your findings \\n                return current_fare, discounted_fare\\n                \\n        # build fare list \\n        fare_list = [dfs(0, 0)]\\n        # take the min of the min of the fare list (as you\\'ll get a tuple of items from dfs, so min of the final tuple)\\n        return min(min(fare_list))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        # build adjacency list graph \\n        graph = [[] for _ in range(n)]\\n        for src, dst in edges : \\n            graph[src].append(dst)\\n            graph[dst].append(src)\\n        # since we have to take all trips, it\\'s easier to reduce the node space from a repeated loop over the tree \\n        # to a frequency based node space so that we can consider all the trips from a singular point of view \\n        # to do this, we need to process the frequency of each node reaching to a destination based on the neighbors \\n        # this can be done regardless of cost, since we will factor in cost based on the frequency at the later point of the algorithm \\n        # find frequency of each node \\n        frequency = [0] * n\\n        # by looping over trips \\n        for src, dst in trips : \\n            # dfs frequency loops each node in consideration to a next node \\n            def dfs_freq(current_node, next_node) : \\n                # where if current is now dst from outside looping \\n                if current_node == dst : \\n                    # update frequency of the current node in the search and return True \\n                    frequency[current_node] += 1 \\n                    return True \\n                else : \\n                    # otherwise, if not yet at destination, consider neighbors off of here \\n                    for neighbor in graph[current_node] : \\n                        # if the neighbor is not the next node we\\'d reach anyways,\\n                        # and the neighbor is able to eventually reach the destination without incurring a loop \\n                        if neighbor != next_node and dfs_freq(neighbor, current_node) : \\n                            # then we can increment the current nodes frequency and return true \\n                            frequency[current_node] += 1 \\n                            return True \\n                    # if we can never make it from this current node, we should return False \\n                    # we still need to get to this point, since along the way there may be other updates that occur \\n                    return False \\n            # and for each trip start, conducting dfs freq to find frequency of related node and sub nodes \\n            dfs_freq(src, src)\\n\\n        # memoize costs so to avoid repeat calculations \\n        cost_memo = dict() \\n        # this depth first search conducts based on fares. \\n        # the above loop set up the frequency interpretation, allowing us to skip multiple loops of cost accumulation otherwise \\n        # this is a transform of the problem space to a frequency based form, thus lowering overall complexity \\n        # this also allows us to now consider the costs based on the frequency that they might occur, allowing us to determine best choices for halving the price \\n        def dfs(current_node, next_node) : \\n            # check memo to avoid repeated calculations \\n            if (current_node, next_node) in cost_memo : \\n                return cost_memo[(current_node, next_node)][0], cost_memo[(current_node, next_node)][1] \\n            else : \\n                # here again, the next node serves as a check against self-loops \\n                # we start by calculating the current fare as a cost of price * frequency of occurrence on other trips \\n                current_fare = price[current_node] * frequency[current_node]\\n                # we then calculate the discounted price to allow for one way trip \\n                discounted_fare = current_fare//2\\n                # check local neighborhood \\n                for neighbor in graph[current_node] : \\n                    # and avoid self loops \\n                    if neighbor != next_node :\\n                        # set current neighbor fare and current neighbor discount as result of dfs on fare prices \\n                        current_neighbor_fare, current_neighbor_discount = dfs(neighbor, current_node)\\n                        # update current fare to track the minimum of the two (since you might discount this neighbor, or might not) \\n                        current_fare += min(current_neighbor_fare, current_neighbor_discount)\\n                        # discounted fare always gets the current neighbor fare since it was already discounted \\n                        discounted_fare += current_neighbor_fare\\n                # memoize your findings to avoid repeated calculations based on similar set ups \\n                cost_memo[(current_node, next_node)] = [current_fare, discounted_fare]\\n                # return your findings \\n                return current_fare, discounted_fare\\n                \\n        # build fare list \\n        fare_list = [dfs(0, 0)]\\n        # take the min of the min of the fare list (as you\\'ll get a tuple of items from dfs, so min of the final tuple)\\n        return min(min(fare_list))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926970,
                "title": "best-detailed-sol-dfs-dp-on-trees-c-easy",
                "content": "since it was a tree therefore we have only one path from any node to any node so we can run a dfs to find a path from one node to another and that would be the shortest path too since only one path exist between them but if it would have been a graph then more than one path would be possible just for knowledge\\n\\nnow coming to the code i called dfs for each node to store the path and then increased there freq after that we moved to dp on trees to check which node to half to get minimum price\\n\\ndp[node][1] denotes i halfed this node what would be the min cost\\ndp[node][0] denotes if i dont halfed this node what would be min cost\\n\\nnow if i hafled a particular node then i would have strict condtion that i have to take all the childs as non half means dp[child][0]\\n\\nnow if i dont half this node then i can take min of both dp[child][1]and dp[child][0] \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  void dfs(int node,int par,int des,vector<int> &path,vector<int> adj[]){\\n        path.push_back(node);\\n        if(node==des){\\n            return ;\\n        }    \\n        for(int child:adj[node]){\\n            if(child!=par){\\n                dfs(child,node,des,path,adj);\\n            }\\n        }\\n        if(path.back()==des){\\n            return;\\n        }\\n        path.pop_back();\\n  }\\n\\n  void solve(int node,int par,vector<int> adj[],vector<vector<int>> &dp,vector<int> &freq,vector<int> &price){\\n     \\n    bool leaf=1; \\n    int nhalf=freq[node]*price[node];\\n    int half=freq[node]*(price[node]/2);\\n     int mini=0;\\n     int mini2=0;\\n     for(int child:adj[node]){\\n         if(child!=par){\\n             leaf=0; \\n             solve(child,node,adj,dp,freq,price);\\n             mini+=dp[child][0];\\n             mini2+=min(dp[child][1],dp[child][0]);\\n         }\\n     }\\n\\n     if(leaf){\\n         dp[node][1]=half;\\n         dp[node][0]=nhalf;\\n         return;\\n     }\\n     \\n     dp[node][1]=half+mini;\\n     dp[node][0]=nhalf+mini2;\\n\\n  } \\n\\n\\n\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> freq(n,0);\\n        // making the adjcency list\\n        vector<int> adj[n];\\n        for(int i=0; i<edges.size(); i++){\\n            int x=edges[i][0];\\n            int y=edges[i][1];\\n            adj[x].push_back(y);\\n            adj[y].push_back(x);\\n        }\\n        // now counting freq of each node on path\\n        for(int i=0; i<trips.size(); i++){\\n            int x=trips[i][0];\\n            int y=trips[i][1];\\n            vector<int> path;\\n            dfs(x,-1,y,path,adj);\\n            for(auto it:path){\\n                freq[it]++;\\n            }\\n        }\\n        \\n        \\n        vector<vector<int>> dp(n,vector<int> (2,0));\\n        solve(0,-1,adj,dp,freq,price); \\n        return min(dp[0][0],dp[0][1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  void dfs(int node,int par,int des,vector<int> &path,vector<int> adj[]){\\n        path.push_back(node);\\n        if(node==des){\\n            return ;\\n        }    \\n        for(int child:adj[node]){\\n            if(child!=par){\\n                dfs(child,node,des,path,adj);\\n            }\\n        }\\n        if(path.back()==des){\\n            return;\\n        }\\n        path.pop_back();\\n  }\\n\\n  void solve(int node,int par,vector<int> adj[],vector<vector<int>> &dp,vector<int> &freq,vector<int> &price){\\n     \\n    bool leaf=1; \\n    int nhalf=freq[node]*price[node];\\n    int half=freq[node]*(price[node]/2);\\n     int mini=0;\\n     int mini2=0;\\n     for(int child:adj[node]){\\n         if(child!=par){\\n             leaf=0; \\n             solve(child,node,adj,dp,freq,price);\\n             mini+=dp[child][0];\\n             mini2+=min(dp[child][1],dp[child][0]);\\n         }\\n     }\\n\\n     if(leaf){\\n         dp[node][1]=half;\\n         dp[node][0]=nhalf;\\n         return;\\n     }\\n     \\n     dp[node][1]=half+mini;\\n     dp[node][0]=nhalf+mini2;\\n\\n  } \\n\\n\\n\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> freq(n,0);\\n        // making the adjcency list\\n        vector<int> adj[n];\\n        for(int i=0; i<edges.size(); i++){\\n            int x=edges[i][0];\\n            int y=edges[i][1];\\n            adj[x].push_back(y);\\n            adj[y].push_back(x);\\n        }\\n        // now counting freq of each node on path\\n        for(int i=0; i<trips.size(); i++){\\n            int x=trips[i][0];\\n            int y=trips[i][1];\\n            vector<int> path;\\n            dfs(x,-1,y,path,adj);\\n            for(auto it:path){\\n                freq[it]++;\\n            }\\n        }\\n        \\n        \\n        vector<vector<int>> dp(n,vector<int> (2,0));\\n        solve(0,-1,adj,dp,freq,price); \\n        return min(dp[0][0],dp[0][1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904165,
                "title": "beats-97-15-hld-memoisation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep-1:Calculating total no.of times each vertice is repeated (using heavy light decomposition(hld)).\\n\\nStep-2:Performing DP(I did memoisation) from any assumed root.\\n# Complexity\\n- Time complexity:O(m * log(n) * log(n) + n * log(n)).Where m is no.of trips and n is no.of vertices\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:O(m + n).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\ntemplate<class T>\\nstruct graph{\\n\\tstruct E{\\n\\t\\tint from, to;\\n\\t\\tT cost;\\n\\t};\\n\\tint n;\\n\\tvector<E> edge;\\n\\tvector<vector<int>> adj;\\n\\tfunction<bool(int)> ignore;\\n\\tgraph(int n = 1): n(n), adj(n){\\n\\t\\tassert(n >= 1);\\n\\t}\\n\\tgraph(const vector<vector<int>> &adj, bool undirected = true): n((int)adj.size()), adj(n){\\n\\t\\tassert(n >= 1);\\n\\t\\tif(undirected){\\n\\t\\t\\tfor(auto u = 0; u < n; ++ u) for(auto v: adj[u]) if(u < v) link(u, v);\\n\\t\\t}\\n\\t\\telse for(auto u = 0; u < n; ++ u) for(auto v: adj[u]) orient(u, v);\\n\\t}\\n\\tgraph(const vector<vector<pair<int, T>>> &adj, bool undirected = true): n((int)adj.size()), adj(n){\\n\\t\\tassert(n >= 1);\\n\\t\\tif(undirected){\\n\\t\\t\\tfor(auto u = 0; u < n; ++ u) for(auto [v, w]: adj[u]) if(u < v) link(u, v, w);\\n\\t\\t}\\n\\t\\telse for(auto u = 0; u < n; ++ u) for(auto [v, w]: adj[u]) orient(u, v, w);\\n\\t}\\n\\tgraph(int n, vector<array<int, 2>> &edge, bool undirected = true): n(n), adj(n){\\n\\t\\tassert(n >= 1);\\n\\t\\tfor(auto [u, v]: edge) undirected ? link(u, v) : orient(u, v);\\n\\t}\\n\\tgraph(int n, vector<tuple<int, int, T>> &edge, bool undirected = true): n(n), adj(n){\\n\\t\\tassert(n >= 1);\\n\\t\\tfor(auto [u, v, w]: edge) undirected ? link(u, v, w) : orient(u, v, w);\\n\\t}\\n\\tint operator()(int u, int id) const{\\n\\t\\t#ifdef LOCAL\\n\\t\\tassert(0 <= id && id < (int)edge.size());\\n\\t\\tassert(edge[id].from == u || edge[id].to == u);\\n\\t\\t#endif\\n\\t\\treturn u ^ edge[id].from ^ edge[id].to;\\n\\t}\\n\\tint link(int u, int v, T w = {}){ // insert an undirected edge\\n\\t\\tint id = (int)edge.size();\\n\\t\\tadj[u].push_back(id), adj[v].push_back(id), edge.push_back({u, v, w});\\n\\t\\treturn id;\\n\\t}\\n\\tint orient(int u, int v, T w = {}){ // insert a directed edge\\n\\t\\tint id = (int)edge.size();\\n\\t\\tadj[u].push_back(id), edge.push_back({u, v, w});\\n\\t\\treturn id;\\n\\t}\\n\\tvoid clear(){\\n\\t\\tfor(auto [u, v, w]: edge){\\n\\t\\t\\tadj[u].clear();\\n\\t\\t\\tadj[v].clear();\\n\\t\\t}\\n\\t\\tedge.clear();\\n\\t\\tignore = {};\\n\\t}\\n\\tgraph transposed() const{ // the transpose of the directed graph\\n\\t\\tgraph res(n);\\n\\t\\tfor(auto &e: edge) res.orient(e.to, e.from, e.cost);\\n\\t\\tres.ignore = ignore;\\n\\t\\treturn res;\\n\\t}\\n\\tint degree(int u) const{ // the degree (outdegree if directed) of u (without the ignoration rule)\\n\\t\\treturn (int)adj[u].size();\\n\\t}\\n\\t// The adjacency list is sorted for each vertex.\\n\\tvector<vector<int>> get_adjacency_list() const{\\n\\t\\tvector<vector<int>> res(n);\\n\\t\\tfor(auto u = 0; u < n; ++ u) for(auto id: adj[u]){\\n\\t\\t\\tif(ignore && ignore(id)) continue;\\n\\t\\t\\tres[(*this)(u, id)].push_back(u);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\tvoid set_ignoration_rule(const function<bool(int)> &f){\\n\\t\\tignore = f;\\n\\t}\\n\\tvoid reset_ignoration_rule(){\\n\\t\\tignore = nullptr;\\n\\t}\\n\\tfriend ostream &operator<<(ostream &out, const graph &g){\\n\\t\\tfor(auto id = 0; id < (int)g.edge.size(); ++ id){\\n\\t\\t\\tif(g.ignore && g.ignore(id)) continue;\\n\\t\\t\\tauto &e = g.edge[id];\\n\\t\\t\\tout << \"{\" << e.from << \", \" << e.to << \", \" << e.cost << \"}\\\\n\";\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n};\\nstruct heavy_light_decomposition{\\n\\tint n;\\n\\tvector<vector<int>> adj; // stores edge ids\\n\\tvector<int> roots; // root of the component\\n\\tvector<int> pv;\\n\\tvector<int> pe;\\n\\tvector<int> size;\\n\\tvector<int> depth;\\n\\tvector<int> next; // highest point of the heavy path\\n\\tvector<int> prev; // lowest point of the heavy path\\n\\tvector<int> pos;\\n\\tvector<int> end;\\n\\tvector<int> order;\\n\\ttemplate<class T>\\n\\theavy_light_decomposition(const graph<T> &g, const vector<int> &roots): n(g.n), roots(roots), adj(n), pv(n, -1), pe(n, -1), size(n, 1), depth(n), next(n), prev(n), pos(n), end(n){\\n\\t\\tiota(prev.begin(), prev.end(), 0);\\n\\t\\tfor(auto id = 0; id < (int)g.edge.size(); ++ id){\\n\\t\\t\\tif(g.ignore && g.ignore(id)) continue;\\n\\t\\t\\tauto &e = g.edge[id];\\n\\t\\t\\tadj[e.from].push_back(id), adj[e.to].push_back(id);\\n\\t\\t}\\n\\t\\tauto dfs_init = [&](auto self, int u, int root)->void{\\n\\t\\t\\tnext[u] = root;\\n\\t\\t\\tif(~pe[u]) adj[u].erase(find(adj[u].begin(), adj[u].end(), pe[u]));\\n\\t\\t\\tfor(auto &id: adj[u]){\\n\\t\\t\\t\\tauto &e = g.edge[id];\\n\\t\\t\\t\\tint v = u ^ e.from ^ e.to;\\n\\t\\t\\t\\tpv[v] = u, pe[v] = id, depth[v] = depth[u] + 1;\\n\\t\\t\\t\\tself(self, v, u);\\n\\t\\t\\t\\tsize[u] += size[v];\\n\\t\\t\\t\\tauto &f = g.edge[adj[u][0]];\\n\\t\\t\\t\\tif(size[v] > size[u ^ f.from ^ f.to]) swap(id, adj[u][0]);\\n\\t\\t\\t}\\n\\t\\t\\tif(!adj[u].empty()){\\n\\t\\t\\t\\tauto &e = g.edge[adj[u][0]];\\n\\t\\t\\t\\tprev[u] = prev[u ^ e.from ^ e.to];\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tint timer = 0;\\n\\t\\tauto dfs_hld = [&](auto self, int u)->void{\\n\\t\\t\\tpos[u] = timer ++;\\n\\t\\t\\torder.push_back(u);\\n\\t\\t\\tif(!adj[u].empty()){\\n\\t\\t\\t\\tauto &f = g.edge[adj[u][0]];\\n\\t\\t\\t\\tint hv = u ^ f.from ^ f.to;\\n\\t\\t\\t\\tfor(auto id: adj[u]){\\n\\t\\t\\t\\t\\tauto &e = g.edge[id];\\n\\t\\t\\t\\t\\tint v = u ^ e.from ^ e.to;\\n\\t\\t\\t\\t\\tnext[v] = (v == hv ? next[u] : v);\\n\\t\\t\\t\\t\\tself(self, v);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tend[u] = timer;\\n\\t\\t};\\n\\t\\tfor(auto r: roots) assert(!~pv[r]), dfs_init(dfs_init, r, r), dfs_hld(dfs_hld, r);\\n\\t}\\n\\t// O(1)\\n\\tbool ancestor_of(int u, int v) const{\\n\\t\\treturn pos[u] <= pos[v] && end[v] <= end[u];\\n\\t}\\n\\tint lca(int u, int v) const{\\n\\t\\tfor(; next[u] != next[v]; v = pv[next[v]]) if(depth[next[u]] > depth[next[v]]) swap(u, v);\\n\\t\\treturn depth[u] < depth[v] ? u : v;\\n\\t}\\n\\tint steps(int u, int v, int w = -1) const{\\n\\t\\treturn depth[u] + depth[v] - 2 * depth[~w ? w : lca(u, v)];\\n\\t}\\n\\t// f reads the position in the data structure\\n\\t// One application of f\\n\\tvoid access_node(int u, auto f) const{\\n\\t\\tf(pos[u]);\\n\\t}\\n\\t// One application of f\\n\\ttemplate<int VALS_IN_EDGES = 0>\\n\\tvoid access_subtree(int u, auto f) const{\\n\\t\\tf(pos[u] + VALS_IN_EDGES, end[u]);\\n\\t}\\n\\t// f(left, right, (left->right ?))\\n\\t// O(log n) applications of f\\n\\ttemplate<int VALS_IN_EDGES = 0>\\n\\tvoid access_path(int u, int v, auto f) const{\\n\\t\\tbool dir = true;\\n\\t\\tfor(; next[u] != next[v]; v = pv[next[v]]){\\n\\t\\t\\tif(depth[next[u]] > depth[next[v]]) swap(u, v), dir = !dir;\\n\\t\\t\\tf(pos[next[v]], pos[v] + 1, dir);\\n\\t\\t}\\n\\t\\tif(depth[u] > depth[v]) swap(u, v), dir = !dir;\\n\\t\\tf(pos[u] + VALS_IN_EDGES, pos[v] + 1, dir);\\n\\t}\\n\\t// Pair of indices {l, r} in the data structure. resr is reversed(v->next[v], pv[next[v]]-> ...)\\n\\t// O(log n)\\n\\tauto get_path(int u, int v) const{\\n\\t\\tvector<pair<int, int>> resl, resr;\\n\\t\\taccess_path(u, v, [&](int l, int r, bool dir){ (dir ? resl : resr).push_back({l, r}); });\\n\\t\\treturn pair{resl, resr};\\n\\t}\\n};\\ntemplate<class T>\\nstruct range_add_range_sum_query_solver{\\n\\tint n;\\n\\tvector<T> data0, data1;\\n\\trange_add_range_sum_query_solver(){ }\\n\\t// O(n)\\n\\trange_add_range_sum_query_solver(int n): n(n), data0(n), data1(n){ }\\n\\t// O(n)\\n\\trange_add_range_sum_query_solver(int n, T init): range_add_range_sum_query_solver(vector<T>(n, init)){ }\\n\\t// O(n)\\n\\trange_add_range_sum_query_solver(const vector<T> &v): n((int)v.size()), data0(n), data1(v){\\n\\t\\tfor(auto i = 1; i <= n; ++ i) if(i + (i & -i) <= n) data1[i + (i & -i) - 1] += data1[i - 1];\\n\\t}\\n\\tvoid update(int ql, int qr, T x){\\n\\t\\tassert(0 <= ql && ql <= qr && qr <= n);\\n\\t\\tif(ql == qr) return;\\n\\t\\tfor(auto l = ql + 1; l <= n; l += l & -l) data0[l - 1] += x, data1[l - 1] -= ql * x;\\n\\t\\tfor(auto r = qr + 1; r <= n; r += r & -r) data0[r - 1] -= x, data1[r - 1] += qr * x;\\n\\t}\\n\\tT pref(int qr) const{\\n\\t\\tassert(0 <= qr && qr <= n);\\n\\t\\tT sum0 = {}, sum1 = {};\\n\\t\\tfor(auto r = qr; r > 0; r -= r & -r) sum0 += data0[r - 1], sum1 += data1[r - 1];\\n\\t\\treturn qr * sum0 + sum1;\\n\\t}\\n\\tT query(int l, int r) const{\\n\\t\\tassert(0 <= l && l <= r && r <= n);\\n\\t\\treturn pref(r) - pref(l);\\n\\t}\\n\\ttemplate<class output_stream>\\n\\tfriend output_stream &operator<<(output_stream &out, const range_add_range_sum_query_solver<T> &solver){\\n\\t\\tout << \"[\";\\n\\t\\tfor(auto i = 0; i < solver.n; ++ i){\\n\\t\\t\\tout << solver.query(i, i + 1);\\n\\t\\t\\tif(i != solver.n - 1) out << \", \";\\n\\t\\t}\\n\\t\\treturn out << \\']\\';\\n\\t}\\n};\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        graph<int>g(n);\\n        for(auto x:edges){\\n            g.link(x[0],x[1],1);\\n        }\\n        heavy_light_decomposition hld(g,{0});\\n        range_add_range_sum_query_solver rar(n,0);\\n        for(auto &x:trips){\\n            hld.access_path(x[0],x[1],[&](int l,int r,bool){\\n                rar.update(l,r,1);\\n            });\\n        }\\n        vector<vector<int>> dp(n,vector<int>(2,0)),vis(n,vector<int>(2,0));\\n        function<int(int,int)> dfs=[&](int node,int taken){\\n            if(vis[node][taken]) return dp[node][taken];\\n            vis[node][taken]=1;\\n            int ret=rar.query(hld.pos[node],hld.pos[node]+1)*price[node];\\n\\t\\t\\t\\t\\t\\tint curr=0,_curr=0;\\n            for(auto x:g.adj[node]){\\n\\t\\t\\t\\t\\t\\t\\t\\tif(hld.pe[node]==x) continue;\\n                curr+=dfs(g(node,x),0);\\n                if(!taken)\\n                    _curr+=dfs(g(node,x),1);\\n            }\\n\\t\\t\\t\\t\\t\\tif(taken) return dp[node][taken]=ret+curr;\\n\\t\\t\\t\\t\\t\\treturn dp[node][taken]=min(ret/2+_curr,ret+curr);\\n        };\\n        dfs(0,0);\\n\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntemplate<class T>\\nstruct graph{\\n\\tstruct E{\\n\\t\\tint from, to;\\n\\t\\tT cost;\\n\\t};\\n\\tint n;\\n\\tvector<E> edge;\\n\\tvector<vector<int>> adj;\\n\\tfunction<bool(int)> ignore;\\n\\tgraph(int n = 1): n(n), adj(n){\\n\\t\\tassert(n >= 1);\\n\\t}\\n\\tgraph(const vector<vector<int>> &adj, bool undirected = true): n((int)adj.size()), adj(n){\\n\\t\\tassert(n >= 1);\\n\\t\\tif(undirected){\\n\\t\\t\\tfor(auto u = 0; u < n; ++ u) for(auto v: adj[u]) if(u < v) link(u, v);\\n\\t\\t}\\n\\t\\telse for(auto u = 0; u < n; ++ u) for(auto v: adj[u]) orient(u, v);\\n\\t}\\n\\tgraph(const vector<vector<pair<int, T>>> &adj, bool undirected = true): n((int)adj.size()), adj(n){\\n\\t\\tassert(n >= 1);\\n\\t\\tif(undirected){\\n\\t\\t\\tfor(auto u = 0; u < n; ++ u) for(auto [v, w]: adj[u]) if(u < v) link(u, v, w);\\n\\t\\t}\\n\\t\\telse for(auto u = 0; u < n; ++ u) for(auto [v, w]: adj[u]) orient(u, v, w);\\n\\t}\\n\\tgraph(int n, vector<array<int, 2>> &edge, bool undirected = true): n(n), adj(n){\\n\\t\\tassert(n >= 1);\\n\\t\\tfor(auto [u, v]: edge) undirected ? link(u, v) : orient(u, v);\\n\\t}\\n\\tgraph(int n, vector<tuple<int, int, T>> &edge, bool undirected = true): n(n), adj(n){\\n\\t\\tassert(n >= 1);\\n\\t\\tfor(auto [u, v, w]: edge) undirected ? link(u, v, w) : orient(u, v, w);\\n\\t}\\n\\tint operator()(int u, int id) const{\\n\\t\\t#ifdef LOCAL\\n\\t\\tassert(0 <= id && id < (int)edge.size());\\n\\t\\tassert(edge[id].from == u || edge[id].to == u);\\n\\t\\t#endif\\n\\t\\treturn u ^ edge[id].from ^ edge[id].to;\\n\\t}\\n\\tint link(int u, int v, T w = {}){ // insert an undirected edge\\n\\t\\tint id = (int)edge.size();\\n\\t\\tadj[u].push_back(id), adj[v].push_back(id), edge.push_back({u, v, w});\\n\\t\\treturn id;\\n\\t}\\n\\tint orient(int u, int v, T w = {}){ // insert a directed edge\\n\\t\\tint id = (int)edge.size();\\n\\t\\tadj[u].push_back(id), edge.push_back({u, v, w});\\n\\t\\treturn id;\\n\\t}\\n\\tvoid clear(){\\n\\t\\tfor(auto [u, v, w]: edge){\\n\\t\\t\\tadj[u].clear();\\n\\t\\t\\tadj[v].clear();\\n\\t\\t}\\n\\t\\tedge.clear();\\n\\t\\tignore = {};\\n\\t}\\n\\tgraph transposed() const{ // the transpose of the directed graph\\n\\t\\tgraph res(n);\\n\\t\\tfor(auto &e: edge) res.orient(e.to, e.from, e.cost);\\n\\t\\tres.ignore = ignore;\\n\\t\\treturn res;\\n\\t}\\n\\tint degree(int u) const{ // the degree (outdegree if directed) of u (without the ignoration rule)\\n\\t\\treturn (int)adj[u].size();\\n\\t}\\n\\t// The adjacency list is sorted for each vertex.\\n\\tvector<vector<int>> get_adjacency_list() const{\\n\\t\\tvector<vector<int>> res(n);\\n\\t\\tfor(auto u = 0; u < n; ++ u) for(auto id: adj[u]){\\n\\t\\t\\tif(ignore && ignore(id)) continue;\\n\\t\\t\\tres[(*this)(u, id)].push_back(u);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\tvoid set_ignoration_rule(const function<bool(int)> &f){\\n\\t\\tignore = f;\\n\\t}\\n\\tvoid reset_ignoration_rule(){\\n\\t\\tignore = nullptr;\\n\\t}\\n\\tfriend ostream &operator<<(ostream &out, const graph &g){\\n\\t\\tfor(auto id = 0; id < (int)g.edge.size(); ++ id){\\n\\t\\t\\tif(g.ignore && g.ignore(id)) continue;\\n\\t\\t\\tauto &e = g.edge[id];\\n\\t\\t\\tout << \"{\" << e.from << \", \" << e.to << \", \" << e.cost << \"}\\\\n\";\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n};\\nstruct heavy_light_decomposition{\\n\\tint n;\\n\\tvector<vector<int>> adj; // stores edge ids\\n\\tvector<int> roots; // root of the component\\n\\tvector<int> pv;\\n\\tvector<int> pe;\\n\\tvector<int> size;\\n\\tvector<int> depth;\\n\\tvector<int> next; // highest point of the heavy path\\n\\tvector<int> prev; // lowest point of the heavy path\\n\\tvector<int> pos;\\n\\tvector<int> end;\\n\\tvector<int> order;\\n\\ttemplate<class T>\\n\\theavy_light_decomposition(const graph<T> &g, const vector<int> &roots): n(g.n), roots(roots), adj(n), pv(n, -1), pe(n, -1), size(n, 1), depth(n), next(n), prev(n), pos(n), end(n){\\n\\t\\tiota(prev.begin(), prev.end(), 0);\\n\\t\\tfor(auto id = 0; id < (int)g.edge.size(); ++ id){\\n\\t\\t\\tif(g.ignore && g.ignore(id)) continue;\\n\\t\\t\\tauto &e = g.edge[id];\\n\\t\\t\\tadj[e.from].push_back(id), adj[e.to].push_back(id);\\n\\t\\t}\\n\\t\\tauto dfs_init = [&](auto self, int u, int root)->void{\\n\\t\\t\\tnext[u] = root;\\n\\t\\t\\tif(~pe[u]) adj[u].erase(find(adj[u].begin(), adj[u].end(), pe[u]));\\n\\t\\t\\tfor(auto &id: adj[u]){\\n\\t\\t\\t\\tauto &e = g.edge[id];\\n\\t\\t\\t\\tint v = u ^ e.from ^ e.to;\\n\\t\\t\\t\\tpv[v] = u, pe[v] = id, depth[v] = depth[u] + 1;\\n\\t\\t\\t\\tself(self, v, u);\\n\\t\\t\\t\\tsize[u] += size[v];\\n\\t\\t\\t\\tauto &f = g.edge[adj[u][0]];\\n\\t\\t\\t\\tif(size[v] > size[u ^ f.from ^ f.to]) swap(id, adj[u][0]);\\n\\t\\t\\t}\\n\\t\\t\\tif(!adj[u].empty()){\\n\\t\\t\\t\\tauto &e = g.edge[adj[u][0]];\\n\\t\\t\\t\\tprev[u] = prev[u ^ e.from ^ e.to];\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tint timer = 0;\\n\\t\\tauto dfs_hld = [&](auto self, int u)->void{\\n\\t\\t\\tpos[u] = timer ++;\\n\\t\\t\\torder.push_back(u);\\n\\t\\t\\tif(!adj[u].empty()){\\n\\t\\t\\t\\tauto &f = g.edge[adj[u][0]];\\n\\t\\t\\t\\tint hv = u ^ f.from ^ f.to;\\n\\t\\t\\t\\tfor(auto id: adj[u]){\\n\\t\\t\\t\\t\\tauto &e = g.edge[id];\\n\\t\\t\\t\\t\\tint v = u ^ e.from ^ e.to;\\n\\t\\t\\t\\t\\tnext[v] = (v == hv ? next[u] : v);\\n\\t\\t\\t\\t\\tself(self, v);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tend[u] = timer;\\n\\t\\t};\\n\\t\\tfor(auto r: roots) assert(!~pv[r]), dfs_init(dfs_init, r, r), dfs_hld(dfs_hld, r);\\n\\t}\\n\\t// O(1)\\n\\tbool ancestor_of(int u, int v) const{\\n\\t\\treturn pos[u] <= pos[v] && end[v] <= end[u];\\n\\t}\\n\\tint lca(int u, int v) const{\\n\\t\\tfor(; next[u] != next[v]; v = pv[next[v]]) if(depth[next[u]] > depth[next[v]]) swap(u, v);\\n\\t\\treturn depth[u] < depth[v] ? u : v;\\n\\t}\\n\\tint steps(int u, int v, int w = -1) const{\\n\\t\\treturn depth[u] + depth[v] - 2 * depth[~w ? w : lca(u, v)];\\n\\t}\\n\\t// f reads the position in the data structure\\n\\t// One application of f\\n\\tvoid access_node(int u, auto f) const{\\n\\t\\tf(pos[u]);\\n\\t}\\n\\t// One application of f\\n\\ttemplate<int VALS_IN_EDGES = 0>\\n\\tvoid access_subtree(int u, auto f) const{\\n\\t\\tf(pos[u] + VALS_IN_EDGES, end[u]);\\n\\t}\\n\\t// f(left, right, (left->right ?))\\n\\t// O(log n) applications of f\\n\\ttemplate<int VALS_IN_EDGES = 0>\\n\\tvoid access_path(int u, int v, auto f) const{\\n\\t\\tbool dir = true;\\n\\t\\tfor(; next[u] != next[v]; v = pv[next[v]]){\\n\\t\\t\\tif(depth[next[u]] > depth[next[v]]) swap(u, v), dir = !dir;\\n\\t\\t\\tf(pos[next[v]], pos[v] + 1, dir);\\n\\t\\t}\\n\\t\\tif(depth[u] > depth[v]) swap(u, v), dir = !dir;\\n\\t\\tf(pos[u] + VALS_IN_EDGES, pos[v] + 1, dir);\\n\\t}\\n\\t// Pair of indices {l, r} in the data structure. resr is reversed(v->next[v], pv[next[v]]-> ...)\\n\\t// O(log n)\\n\\tauto get_path(int u, int v) const{\\n\\t\\tvector<pair<int, int>> resl, resr;\\n\\t\\taccess_path(u, v, [&](int l, int r, bool dir){ (dir ? resl : resr).push_back({l, r}); });\\n\\t\\treturn pair{resl, resr};\\n\\t}\\n};\\ntemplate<class T>\\nstruct range_add_range_sum_query_solver{\\n\\tint n;\\n\\tvector<T> data0, data1;\\n\\trange_add_range_sum_query_solver(){ }\\n\\t// O(n)\\n\\trange_add_range_sum_query_solver(int n): n(n), data0(n), data1(n){ }\\n\\t// O(n)\\n\\trange_add_range_sum_query_solver(int n, T init): range_add_range_sum_query_solver(vector<T>(n, init)){ }\\n\\t// O(n)\\n\\trange_add_range_sum_query_solver(const vector<T> &v): n((int)v.size()), data0(n), data1(v){\\n\\t\\tfor(auto i = 1; i <= n; ++ i) if(i + (i & -i) <= n) data1[i + (i & -i) - 1] += data1[i - 1];\\n\\t}\\n\\tvoid update(int ql, int qr, T x){\\n\\t\\tassert(0 <= ql && ql <= qr && qr <= n);\\n\\t\\tif(ql == qr) return;\\n\\t\\tfor(auto l = ql + 1; l <= n; l += l & -l) data0[l - 1] += x, data1[l - 1] -= ql * x;\\n\\t\\tfor(auto r = qr + 1; r <= n; r += r & -r) data0[r - 1] -= x, data1[r - 1] += qr * x;\\n\\t}\\n\\tT pref(int qr) const{\\n\\t\\tassert(0 <= qr && qr <= n);\\n\\t\\tT sum0 = {}, sum1 = {};\\n\\t\\tfor(auto r = qr; r > 0; r -= r & -r) sum0 += data0[r - 1], sum1 += data1[r - 1];\\n\\t\\treturn qr * sum0 + sum1;\\n\\t}\\n\\tT query(int l, int r) const{\\n\\t\\tassert(0 <= l && l <= r && r <= n);\\n\\t\\treturn pref(r) - pref(l);\\n\\t}\\n\\ttemplate<class output_stream>\\n\\tfriend output_stream &operator<<(output_stream &out, const range_add_range_sum_query_solver<T> &solver){\\n\\t\\tout << \"[\";\\n\\t\\tfor(auto i = 0; i < solver.n; ++ i){\\n\\t\\t\\tout << solver.query(i, i + 1);\\n\\t\\t\\tif(i != solver.n - 1) out << \", \";\\n\\t\\t}\\n\\t\\treturn out << \\']\\';\\n\\t}\\n};\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        graph<int>g(n);\\n        for(auto x:edges){\\n            g.link(x[0],x[1],1);\\n        }\\n        heavy_light_decomposition hld(g,{0});\\n        range_add_range_sum_query_solver rar(n,0);\\n        for(auto &x:trips){\\n            hld.access_path(x[0],x[1],[&](int l,int r,bool){\\n                rar.update(l,r,1);\\n            });\\n        }\\n        vector<vector<int>> dp(n,vector<int>(2,0)),vis(n,vector<int>(2,0));\\n        function<int(int,int)> dfs=[&](int node,int taken){\\n            if(vis[node][taken]) return dp[node][taken];\\n            vis[node][taken]=1;\\n            int ret=rar.query(hld.pos[node],hld.pos[node]+1)*price[node];\\n\\t\\t\\t\\t\\t\\tint curr=0,_curr=0;\\n            for(auto x:g.adj[node]){\\n\\t\\t\\t\\t\\t\\t\\t\\tif(hld.pe[node]==x) continue;\\n                curr+=dfs(g(node,x),0);\\n                if(!taken)\\n                    _curr+=dfs(g(node,x),1);\\n            }\\n\\t\\t\\t\\t\\t\\tif(taken) return dp[node][taken]=ret+curr;\\n\\t\\t\\t\\t\\t\\treturn dp[node][taken]=min(ret/2+_curr,ret+curr);\\n        };\\n        dfs(0,0);\\n\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897402,
                "title": "python-implementation-using-backtracking-dp",
                "content": "# Intuition\\nThe Idea here is to select those nodes which are involved in the trips and discard other nodes as they are not involved. Then run dfs again to find the solution.\\n\\n# Approach\\n***n = len(price)***: The number of nodes is determined by the length of the price list, which is equivalent to **n**.\\n\\n***Constructing the Graph:***\\n\\nThe given edges are used to construct an undirected graph **g** using an adjacency list.\\nFor each edge $$(u, v)$$, nodes u and v are connected by adding each other to their respective adjacency lists in g.\\n\\n***DFS to Find Paths:***\\n\\nA DFS (Depth-First Search) traversal is used to find paths between nodes in the graph.\\nThe dfs function performs a recursive DFS traversal to find a path from the **source** node to the **target** node.\\nDuring the traversal, nodes are added to the **result** list. If the **target** node is reached, the path is complete, and the **count** array is updated to track the number of times each node is traversed.\\nThe dfs function returns True when the **target** node is reached.\\n\\n***Dynamic Programming with Memorization:***\\n\\nThe **calc** function is used for dynamic programming to calculate the minimum cost for each node considering whether it\\'s halved or not.\\nMemorization is applied using the$$ @lru_cache(None)$$ decorator to store previously calculated results and avoid recomputation.\\nFor each node, two possibilities are considered: halving the node\\'s price **(h = True)** or not halving it **(h = False)**.\\nThe **res1** variable calculates the total cost of the node and its adjacent nodes, while **res2** calculates the cost with the node\\'s price halved.\\nThe dynamic programming function returns the minimum cost between **res1** and **res2**.\\n\\n***Processing Trips:***\\n\\nFor each trip $$[u, v]$$ in the trips list, the dfs function is called to find the path from node $$u$$ to node $$v$$.\\nDuring this process, the count array is updated to keep track of the nodes traversed in each path.\\n\\n***Return Minimum Total Price:***\\n\\nThe **calc** function is called with the default arguments to calculate the minimum total price for all trips.\\nThe final result is the minimum total price required to perform all the given trips.\\nThis solution utilizes DFS to find paths and dynamic programming to calculate the minimum cost for each node considering different scenarios of halving prices. Memorization helps to optimize the computation by storing previously calculated results.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nConstructing the graph from the edges takes $$O(n-1)$$, where $$n$$ is the number of nodes.\\nThe DFS traversal performed for each trip takes $$O(n)$$ in the worst case since it can traverse through all nodes.\\nThe dynamic programming function calc is memoized using $$@lru_cache$$, which stores and reuses previously calculated results. As a result, the time complexity for each unique function call is constant time.\\nOverall, the time complexity can be approximated as $$O(n * m)$$, where $$n$$ is the number of nodes and $$m$$ is the number of trips.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space required for storing the graph\\'s adjacency list is$$ O(n + n-1)$$, where $$n$$ is the number of nodes and $$n-1$$ is the number of edges.\\nThe result list is used to store the path during DFS and its maximum size can be n, resulting in $$O(n)$$ space.\\nThe count array is used to track the number of times each node is traversed, taking $$O(n)$$ space.\\nThe $$@lru_cache$$ decorator uses space proportional to the number of unique function calls.\\nOverall, the space complexity is $$O(n + n-1 + n + m)$$, where $$n$$ is the number of nodes and m is the number of trips.\\nIn summary, the time complexity is primarily dependent on the number of nodes and trips, while the space complexity is influenced by the graph\\'s adjacency list, path storage, and memoization.\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        n = len(price)\\n        \\n        for e in edges:\\n            g[e[0]].append(e[1])\\n            g[e[1]].append(e[0])\\n            \\n        result = []\\n        count = [0] * n\\n        def dfs(node, target, parent):\\n            result.append(node)\\n            \\n            if node == target:\\n                while result: count[result.pop()] += 1\\n                return True\\n            \\n            for neighbor in g[node]:\\n                if neighbor != parent:\\n                    if dfs(neighbor, target, node): return True\\n            \\n            result.pop()\\n            return False\\n\\n        @lru_cache(None)\\n        def calc(node = 0, p = -1, h = False):\\n            res1 = count[node] * price[node]\\n            res2 = res1 // 2\\n\\n            for adj in g[node]:\\n                if adj != p:\\n                    res1 += calc(adj, node, False)\\n            if h: return res1\\n\\n            for adj in g[node]:\\n                if adj != p:\\n                    res2 += calc(adj, node, True)\\n            return min(res1, res2)\\n\\n\\n        for u, v in trips:\\n            dfs(u, v, -1)\\n\\n        return calc()\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        n = len(price)\\n        \\n        for e in edges:\\n            g[e[0]].append(e[1])\\n            g[e[1]].append(e[0])\\n            \\n        result = []\\n        count = [0] * n\\n        def dfs(node, target, parent):\\n            result.append(node)\\n            \\n            if node == target:\\n                while result: count[result.pop()] += 1\\n                return True\\n            \\n            for neighbor in g[node]:\\n                if neighbor != parent:\\n                    if dfs(neighbor, target, node): return True\\n            \\n            result.pop()\\n            return False\\n\\n        @lru_cache(None)\\n        def calc(node = 0, p = -1, h = False):\\n            res1 = count[node] * price[node]\\n            res2 = res1 // 2\\n\\n            for adj in g[node]:\\n                if adj != p:\\n                    res1 += calc(adj, node, False)\\n            if h: return res1\\n\\n            for adj in g[node]:\\n                if adj != p:\\n                    res2 += calc(adj, node, True)\\n            return min(res1, res2)\\n\\n\\n        for u, v in trips:\\n            dfs(u, v, -1)\\n\\n        return calc()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879859,
                "title": "o-kn-dp",
                "content": "# Intuition\\nDFS + DP\\n\\n# Approach\\nStep 1. Loop through edges to generate the graph\\nStep 2. Loop through trips to get the weight of each node\\nStep 3. Use DFS to generate tree based on graph\\nStep 4. DP\\n\\n# Complexity\\n- Time complexity:\\nO(n) + O(kn) + O(n) + O(2n) = O(kn) where k is # of trips and n is # of nodes\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        graph = dict(zip([i for i in range(n)], [[] for i in range(n)]))\\n        for edge in edges:\\n            graph[edge[0]].append(edge[1])\\n            graph[edge[1]].append(edge[0])\\n        cnt_table = dict(zip([i for i in range(n)], [0 for i in range(n)]))\\n        visited = {}\\n        def DFS(start, end):\\n            visited[start] = True\\n            if start == end:\\n                return [start]\\n            res = []\\n            children = graph[start]\\n            for child in children:\\n                if child not in visited:\\n                    tmp = DFS(child,end)\\n                    if tmp != []:\\n                        res += tmp\\n            if res == []:\\n                return []\\n            return [start] + res\\n\\n        \\n        for trip in trips:\\n            visited = {}\\n            nodes = DFS(trip[0], trip[1])\\n            for node in nodes:\\n                cnt_table[node] += 1 \\n        print(cnt_table)\\n        \\n        \\n        new_graph = dict(zip([i for i in range(n)], [[] for i in range(n)]))\\n        stack = [0]\\n        i = 0\\n        visited = {0:True}\\n        print(graph)\\n        while stack != []:\\n            curr = stack.pop()\\n            for child in graph[curr]:\\n                if child not in visited:\\n                    new_graph[curr].append(child)\\n                    visited[child] = True\\n                    stack.append(child)\\n        graph = new_graph\\n        print(graph)\\n\\n        record = {}\\n        def help(node, flag):\\n            if (node, flag) in record:\\n                return record[(node, flag)]\\n            res = 0\\n            if flag == False:\\n                for child in graph[node]:\\n                    res += price[child]*cnt_table[child]+help(child,True)\\n            else:\\n                for child in graph[node]:\\n                    res1 = price[child]*cnt_table[child] + help(child,True)\\n                    res2 = price[child]*cnt_table[child]//2 + help(child,False)\\n                    res += min(res1, res2)\\n            record[(node,flag)] = res\\n            return res\\n        return min(price[0]*cnt_table[0]//2+help(0,False), price[0]*cnt_table[0]+help(0,True))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        graph = dict(zip([i for i in range(n)], [[] for i in range(n)]))\\n        for edge in edges:\\n            graph[edge[0]].append(edge[1])\\n            graph[edge[1]].append(edge[0])\\n        cnt_table = dict(zip([i for i in range(n)], [0 for i in range(n)]))\\n        visited = {}\\n        def DFS(start, end):\\n            visited[start] = True\\n            if start == end:\\n                return [start]\\n            res = []\\n            children = graph[start]\\n            for child in children:\\n                if child not in visited:\\n                    tmp = DFS(child,end)\\n                    if tmp != []:\\n                        res += tmp\\n            if res == []:\\n                return []\\n            return [start] + res\\n\\n        \\n        for trip in trips:\\n            visited = {}\\n            nodes = DFS(trip[0], trip[1])\\n            for node in nodes:\\n                cnt_table[node] += 1 \\n        print(cnt_table)\\n        \\n        \\n        new_graph = dict(zip([i for i in range(n)], [[] for i in range(n)]))\\n        stack = [0]\\n        i = 0\\n        visited = {0:True}\\n        print(graph)\\n        while stack != []:\\n            curr = stack.pop()\\n            for child in graph[curr]:\\n                if child not in visited:\\n                    new_graph[curr].append(child)\\n                    visited[child] = True\\n                    stack.append(child)\\n        graph = new_graph\\n        print(graph)\\n\\n        record = {}\\n        def help(node, flag):\\n            if (node, flag) in record:\\n                return record[(node, flag)]\\n            res = 0\\n            if flag == False:\\n                for child in graph[node]:\\n                    res += price[child]*cnt_table[child]+help(child,True)\\n            else:\\n                for child in graph[node]:\\n                    res1 = price[child]*cnt_table[child] + help(child,True)\\n                    res2 = price[child]*cnt_table[child]//2 + help(child,False)\\n                    res += min(res1, res2)\\n            record[(node,flag)] = res\\n            return res\\n        return min(price[0]*cnt_table[0]//2+help(0,False), price[0]*cnt_table[0]+help(0,True))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864889,
                "title": "java-solution-dfs-top-down-memoization",
                "content": "# Intuition\\n1. Build a graph\\n2. Use dfs to find the count of every node in the path of all th routes.\\n3. Use top down memoization to find the minimum cost of covering all path.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    HashMap<String, Integer> hm = new HashMap<>();\\n    \\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        HashMap<Integer, List<Integer>> graph = buildGraph(edges, n);\\n        HashMap<Integer, Integer> visitCount = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            visitCount.put(i, 0);\\n        }\\n        \\n        for(int[] trip : trips) {\\n            dfs(trip[0], trip[1], visitCount, graph, new boolean[n]);\\n        }\\n\\n        int[] cost = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            cost[i] = price[i] * visitCount.get(i);\\n        }\\n\\n        return minPrice(trips[0][0], new boolean[n], graph, 1, cost, calculated);\\n    }\\n\\n    public int minPrice(int start, boolean[] visited, HashMap<Integer, List<Integer>> graph, int canHalf, int[] cost) {\\n        if(hm.containsKey(start +\"-\"+canHalf)) {\\n            return hm.get(start +\"-\"+canHalf);\\n        }\\n        visited[start] = true;\\n\\n        int half = Integer.MAX_VALUE;\\n        if (canHalf == 1) {\\n            half = cost[start] / 2;\\n            for(int m: graph.get(start)) {\\n                if(!visited[m]) {\\n                    half += minPrice(m, visited, graph, 0, cost);\\n                }\\n            }\\n        }\\n        \\n        int noHalf = cost[start];\\n        for(int m: graph.get(start)) {\\n            if(!visited[m]) {\\n                noHalf += minPrice(m, visited, graph, 1, cost);\\n            }\\n        }\\n        visited[start] = false;\\n        \\n        hm.put(start + \"-\" + canHalf, Math.min(half, noHalf));\\n        return Math.min(half, noHalf);\\n    }\\n\\n    public boolean dfs(int a, int b, HashMap<Integer, Integer> visitCount, HashMap<Integer, List<Integer>> graph, boolean[] visited) {\\n        if(a == b) {\\n            visitCount.put(a, visitCount.get(a) + 1);\\n            return true;\\n        }\\n        visited[a] = true;\\n        boolean found = false;\\n        for(int m: graph.get(a)) {\\n            if(!visited[m]) {\\n                found |= dfs(m, b, visitCount, graph, visited);\\n            }\\n            if(found) {\\n                break;\\n            }\\n        }\\n        if(found) {\\n            visitCount.put(a, visitCount.get(a) + 1);\\n        }\\n        visited[a] = false;\\n        return found;\\n    }\\n\\n    public HashMap<Integer, List<Integer>> buildGraph(int[][] edges, int n) {\\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            graph.put(i, new ArrayList<>());\\n        }\\n        for(int[] edge:edges) {\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        return graph;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<String, Integer> hm = new HashMap<>();\\n    \\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        HashMap<Integer, List<Integer>> graph = buildGraph(edges, n);\\n        HashMap<Integer, Integer> visitCount = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            visitCount.put(i, 0);\\n        }\\n        \\n        for(int[] trip : trips) {\\n            dfs(trip[0], trip[1], visitCount, graph, new boolean[n]);\\n        }\\n\\n        int[] cost = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            cost[i] = price[i] * visitCount.get(i);\\n        }\\n\\n        return minPrice(trips[0][0], new boolean[n], graph, 1, cost, calculated);\\n    }\\n\\n    public int minPrice(int start, boolean[] visited, HashMap<Integer, List<Integer>> graph, int canHalf, int[] cost) {\\n        if(hm.containsKey(start +\"-\"+canHalf)) {\\n            return hm.get(start +\"-\"+canHalf);\\n        }\\n        visited[start] = true;\\n\\n        int half = Integer.MAX_VALUE;\\n        if (canHalf == 1) {\\n            half = cost[start] / 2;\\n            for(int m: graph.get(start)) {\\n                if(!visited[m]) {\\n                    half += minPrice(m, visited, graph, 0, cost);\\n                }\\n            }\\n        }\\n        \\n        int noHalf = cost[start];\\n        for(int m: graph.get(start)) {\\n            if(!visited[m]) {\\n                noHalf += minPrice(m, visited, graph, 1, cost);\\n            }\\n        }\\n        visited[start] = false;\\n        \\n        hm.put(start + \"-\" + canHalf, Math.min(half, noHalf));\\n        return Math.min(half, noHalf);\\n    }\\n\\n    public boolean dfs(int a, int b, HashMap<Integer, Integer> visitCount, HashMap<Integer, List<Integer>> graph, boolean[] visited) {\\n        if(a == b) {\\n            visitCount.put(a, visitCount.get(a) + 1);\\n            return true;\\n        }\\n        visited[a] = true;\\n        boolean found = false;\\n        for(int m: graph.get(a)) {\\n            if(!visited[m]) {\\n                found |= dfs(m, b, visitCount, graph, visited);\\n            }\\n            if(found) {\\n                break;\\n            }\\n        }\\n        if(found) {\\n            visitCount.put(a, visitCount.get(a) + 1);\\n        }\\n        visited[a] = false;\\n        return found;\\n    }\\n\\n    public HashMap<Integer, List<Integer>> buildGraph(int[][] edges, int n) {\\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            graph.put(i, new ArrayList<>());\\n        }\\n        for(int[] edge:edges) {\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        return graph;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838529,
                "title": "java-solution-dfs-time-complexity-o-m-n",
                "content": "n = Number of Elements in Tree.\\nm = Number of Trips\\nTime Complexity O(m*n);\\n```\\nclass Solution {\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        HashSet<Integer> [] adList = getAdList(n, edges);\\n        HashMap<Integer, Integer> count = new HashMap();\\n        int totalSum = getTotalSum(adList, price, trips, count);\\n        int [] res = getReduction(0, adList, price, count, -1);\\n        return totalSum - Math.max(res[0], res[1]);\\n    }\\n    \\n    private static HashSet<Integer> [] getAdList(int n, int [][] edges){\\n        HashSet<Integer> [] adList = new HashSet [n];\\n        for(int i =0; i<adList.length; i++)\\n            adList[i] = new HashSet();\\n        for(int [] edge : edges){\\n            int s = edge[0];\\n            int d = edge[1];\\n            adList[s].add(d);\\n            adList[d].add(s);\\n        }\\n        return adList;\\n    }\\n    \\n    private static int getTotalSum(HashSet<Integer> [] adList, int []price, int [][] trips, HashMap<Integer, Integer> count){\\n        int sum = 0;\\n        for(int []trip : trips){\\n            sum += dfs(adList, price, trip[0], trip[1], count, -1);\\n        }\\n        return sum;\\n    }\\n    \\n    private static int dfs(HashSet<Integer> [] adList, int []price, int s, int d, HashMap<Integer, Integer> count, int prev){\\n        if(s == d){\\n            count.put(s, count.getOrDefault(s, 0)+1);\\n            return price[s];\\n        }\\n        for(int child : adList[s]){\\n            if(child == prev)\\n                continue;\\n            int currPrice = dfs(adList, price, child, d, count, s);\\n            if(currPrice > 0){\\n                count.put(s, count.getOrDefault(s, 0)+1);\\n                return price[s] + currPrice;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    private static int [] getReduction(int s, HashSet<Integer> [] adList, int []price, HashMap<Integer, Integer> count, int prev){\\n        int with = ((price[s]*count.getOrDefault(s, 0)) >> 1);\\n        int without = 0;\\n        for(int child : adList[s]){\\n            if(child == prev)\\n                continue;\\n            int [] curr = getReduction(child, adList, price, count, s);\\n            with += curr[1];\\n            without += Math.max(curr[0], curr[1]);\\n        }\\n        return new int []{with, without};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        HashSet<Integer> [] adList = getAdList(n, edges);\\n        HashMap<Integer, Integer> count = new HashMap();\\n        int totalSum = getTotalSum(adList, price, trips, count);\\n        int [] res = getReduction(0, adList, price, count, -1);\\n        return totalSum - Math.max(res[0], res[1]);\\n    }\\n    \\n    private static HashSet<Integer> [] getAdList(int n, int [][] edges){\\n        HashSet<Integer> [] adList = new HashSet [n];\\n        for(int i =0; i<adList.length; i++)\\n            adList[i] = new HashSet();\\n        for(int [] edge : edges){\\n            int s = edge[0];\\n            int d = edge[1];\\n            adList[s].add(d);\\n            adList[d].add(s);\\n        }\\n        return adList;\\n    }\\n    \\n    private static int getTotalSum(HashSet<Integer> [] adList, int []price, int [][] trips, HashMap<Integer, Integer> count){\\n        int sum = 0;\\n        for(int []trip : trips){\\n            sum += dfs(adList, price, trip[0], trip[1], count, -1);\\n        }\\n        return sum;\\n    }\\n    \\n    private static int dfs(HashSet<Integer> [] adList, int []price, int s, int d, HashMap<Integer, Integer> count, int prev){\\n        if(s == d){\\n            count.put(s, count.getOrDefault(s, 0)+1);\\n            return price[s];\\n        }\\n        for(int child : adList[s]){\\n            if(child == prev)\\n                continue;\\n            int currPrice = dfs(adList, price, child, d, count, s);\\n            if(currPrice > 0){\\n                count.put(s, count.getOrDefault(s, 0)+1);\\n                return price[s] + currPrice;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    private static int [] getReduction(int s, HashSet<Integer> [] adList, int []price, HashMap<Integer, Integer> count, int prev){\\n        int with = ((price[s]*count.getOrDefault(s, 0)) >> 1);\\n        int without = 0;\\n        for(int child : adList[s]){\\n            if(child == prev)\\n                continue;\\n            int [] curr = getReduction(child, adList, price, count, s);\\n            with += curr[1];\\n            without += Math.max(curr[0], curr[1]);\\n        }\\n        return new int []{with, without};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819172,
                "title": "path-finding-house-robber-lll",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate an array cost that has total price of each node for all trips.\\nThen we have to minimise sum of this cost array by reducing some costs to half.It is same as dp leetcode problem House Robber 3.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int s,int e,vector<vector<int>>&adj,int parent,vector<int>&cost,vector<int>& price){\\n        if(s==e){\\n            cost[s]+=price[s];\\n            return true;\\n        }\\n        for(auto neigh:adj[s]){\\n            if(neigh!=parent){\\n                if(dfs(neigh,e,adj,s,cost,price)){\\n                    cost[s]+=price[s];\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int minimiseCost(vector<int>&cost,vector<vector<int>>&adj,int parent,bool canhalf,int start,vector<vector<int>>&dp){\\n        if(dp[canhalf][start]!=-1){\\n            return dp[canhalf][start];\\n        }\\n        int c = cost[start];\\n        int withoutHalf = c,half = c/2;\\n        for(auto neigh:adj[start]){\\n            if(neigh==parent){\\n                continue;\\n            }\\n            withoutHalf += minimiseCost(cost,adj,start,true,neigh,dp);\\n        }\\n        if(!canhalf){\\n            dp[canhalf][start] = withoutHalf;\\n            return dp[canhalf][start];\\n        }\\n        for(auto neigh:adj[start]){\\n            if(neigh==parent){\\n                continue;\\n            }\\n            half += minimiseCost(cost,adj,start,false,neigh,dp);\\n            \\n        }\\n        dp[canhalf][start] = min(half,withoutHalf);\\n        return dp[canhalf][start];\\n        \\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>>adj(n);\\n        for(auto edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<int>cost(n,0);\\n        for(auto trip:trips){\\n            int s = trip[0];\\n            int e = trip[1];\\n            // vector<bool>visited(n,false);no need of visited as trees have no cycle\\n            dfs(s,e,adj,-1,cost,price);\\n        }\\n        vector<vector<int>>dp(2,vector<int>(n,-1));\\n        return minimiseCost(cost,adj,-1,true,0,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Graph",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int s,int e,vector<vector<int>>&adj,int parent,vector<int>&cost,vector<int>& price){\\n        if(s==e){\\n            cost[s]+=price[s];\\n            return true;\\n        }\\n        for(auto neigh:adj[s]){\\n            if(neigh!=parent){\\n                if(dfs(neigh,e,adj,s,cost,price)){\\n                    cost[s]+=price[s];\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int minimiseCost(vector<int>&cost,vector<vector<int>>&adj,int parent,bool canhalf,int start,vector<vector<int>>&dp){\\n        if(dp[canhalf][start]!=-1){\\n            return dp[canhalf][start];\\n        }\\n        int c = cost[start];\\n        int withoutHalf = c,half = c/2;\\n        for(auto neigh:adj[start]){\\n            if(neigh==parent){\\n                continue;\\n            }\\n            withoutHalf += minimiseCost(cost,adj,start,true,neigh,dp);\\n        }\\n        if(!canhalf){\\n            dp[canhalf][start] = withoutHalf;\\n            return dp[canhalf][start];\\n        }\\n        for(auto neigh:adj[start]){\\n            if(neigh==parent){\\n                continue;\\n            }\\n            half += minimiseCost(cost,adj,start,false,neigh,dp);\\n            \\n        }\\n        dp[canhalf][start] = min(half,withoutHalf);\\n        return dp[canhalf][start];\\n        \\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>>adj(n);\\n        for(auto edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<int>cost(n,0);\\n        for(auto trip:trips){\\n            int s = trip[0];\\n            int e = trip[1];\\n            // vector<bool>visited(n,false);no need of visited as trees have no cycle\\n            dfs(s,e,adj,-1,cost,price);\\n        }\\n        vector<vector<int>>dp(2,vector<int>(n,-1));\\n        return minimiseCost(cost,adj,-1,true,0,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795552,
                "title": "simple-than-ever-solution-for-beginners",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void help(int s,int d,vector<int>&freq,vector<int>adj[],vector<int>&vis){\\n        vis[s]=1;\\n        if(s==d){\\n            for(int i=0;i<vis.size();i++)   if(vis[i])  freq[i]++;\\n        }\\n        for(auto neg:adj[s]){\\n            if(vis[neg]==0) help(neg,d,freq,adj,vis);\\n        }\\n        vis[s]=0;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> adj[n];\\n        for(auto t:edges){\\n            adj[t[0]].push_back(t[1]);\\n            adj[t[1]].push_back(t[0]);\\n        }\\n        vector<int> freq(n,0);\\n        for(auto t:trips){\\n            vector<int> vis(n,0);\\n            help(t[0],t[1],freq,adj,vis);\\n            \\n        }\\n        dp.resize(n,vector<int>(2,-1));\\n        return help(0,-1,1,freq,price,adj);\\n    }\\n    vector<vector<int>> dp;\\n    int help(int i,int parent,int half,vector<int>&freq,vector<int>&price,vector<int>adj[]){\\n        if(dp[i][half]!=-1)   return dp[i][half];\\n\\n        int nothalfed=0,halfed=0;\\n        //dont half\\n        for(auto neg:adj[i]){\\n            if(neg==parent) continue;\\n            nothalfed+=help(neg,i,false,freq,price,adj);\\n        }\\n        nothalfed+=price[i]*freq[i];\\n\\n        //half only if previous is not half or first \\n        if(half==0 || parent==-1){\\n            for(auto neg:adj[i]){\\n                if(neg==parent) continue;\\n                halfed+=help(neg,i,true,freq,price,adj);\\n            }\\n            halfed+=(price[i]*freq[i])/2;\\n        }\\n        else halfed=1e9;   //no choice to half\\n\\n        return dp[i][half]=min(nothalfed,halfed);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void help(int s,int d,vector<int>&freq,vector<int>adj[],vector<int>&vis){\\n        vis[s]=1;\\n        if(s==d){\\n            for(int i=0;i<vis.size();i++)   if(vis[i])  freq[i]++;\\n        }\\n        for(auto neg:adj[s]){\\n            if(vis[neg]==0) help(neg,d,freq,adj,vis);\\n        }\\n        vis[s]=0;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> adj[n];\\n        for(auto t:edges){\\n            adj[t[0]].push_back(t[1]);\\n            adj[t[1]].push_back(t[0]);\\n        }\\n        vector<int> freq(n,0);\\n        for(auto t:trips){\\n            vector<int> vis(n,0);\\n            help(t[0],t[1],freq,adj,vis);\\n            \\n        }\\n        dp.resize(n,vector<int>(2,-1));\\n        return help(0,-1,1,freq,price,adj);\\n    }\\n    vector<vector<int>> dp;\\n    int help(int i,int parent,int half,vector<int>&freq,vector<int>&price,vector<int>adj[]){\\n        if(dp[i][half]!=-1)   return dp[i][half];\\n\\n        int nothalfed=0,halfed=0;\\n        //dont half\\n        for(auto neg:adj[i]){\\n            if(neg==parent) continue;\\n            nothalfed+=help(neg,i,false,freq,price,adj);\\n        }\\n        nothalfed+=price[i]*freq[i];\\n\\n        //half only if previous is not half or first \\n        if(half==0 || parent==-1){\\n            for(auto neg:adj[i]){\\n                if(neg==parent) continue;\\n                halfed+=help(neg,i,true,freq,price,adj);\\n            }\\n            halfed+=(price[i]*freq[i])/2;\\n        }\\n        else halfed=1e9;   //no choice to half\\n\\n        return dp[i][half]=min(nothalfed,halfed);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755965,
                "title": "c-dp-on-tree-intuitive-step-wise-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    vector<int> freq;\\n    vector<vector<int>> t;\\n\\n    bool applyDFS(vector<int> *gr, int cur, int parent, int dest) {\\n        if(cur == dest) {\\n            return true;\\n        }\\n        for(int &nbr: gr[cur]) {\\n            if(nbr != parent) {\\n                freq[nbr]++;\\n                if(applyDFS(gr, nbr, cur, dest)) {\\n                    return true;\\n                }\\n                freq[nbr]--;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int findMin(int cur, vector<int> *gr, bool parentDone, int parent, vector<int> &price) {\\n        if(t[cur][parentDone] != -1) {\\n            return t[cur][parentDone];\\n        }\\n\\n        int res = INT_MAX;\\n        if(!parentDone) {\\n            res = freq[cur] * price[cur] / 2;\\n            for(int &nbr: gr[cur]) {\\n                if(nbr != parent) {\\n                    res += findMin(nbr, gr, true, cur, price);\\n                }\\n            }\\n        }\\n        int res2 = freq[cur] * price[cur];\\n        for(int &nbr: gr[cur]) {\\n            if(nbr != parent) {\\n                res2 += findMin(nbr, gr, false, cur, price);\\n            }\\n        }\\n        return t[cur][parentDone] = min(res, res2);\\n    }\\n\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        if(n==1) {\\n            return trips.size() * price[0] / 2;\\n        }\\n        vector<int> gr[n];\\n        freq.resize(n, 0);\\n\\n        for(auto &edge: edges) {\\n            gr[edge[0]].push_back(edge[1]);\\n            gr[edge[1]].push_back(edge[0]);\\n        }\\n\\n        for(auto &trip: trips) {\\n            freq[trip[0]]++;\\n            applyDFS(gr, trip[0], -1, trip[1]);      \\n        }\\n\\n        t.resize(n, vector<int>(2, -1));\\n        return findMin(1, gr, false, -1, price);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> freq;\\n    vector<vector<int>> t;\\n\\n    bool applyDFS(vector<int> *gr, int cur, int parent, int dest) {\\n        if(cur == dest) {\\n            return true;\\n        }\\n        for(int &nbr: gr[cur]) {\\n            if(nbr != parent) {\\n                freq[nbr]++;\\n                if(applyDFS(gr, nbr, cur, dest)) {\\n                    return true;\\n                }\\n                freq[nbr]--;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int findMin(int cur, vector<int> *gr, bool parentDone, int parent, vector<int> &price) {\\n        if(t[cur][parentDone] != -1) {\\n            return t[cur][parentDone];\\n        }\\n\\n        int res = INT_MAX;\\n        if(!parentDone) {\\n            res = freq[cur] * price[cur] / 2;\\n            for(int &nbr: gr[cur]) {\\n                if(nbr != parent) {\\n                    res += findMin(nbr, gr, true, cur, price);\\n                }\\n            }\\n        }\\n        int res2 = freq[cur] * price[cur];\\n        for(int &nbr: gr[cur]) {\\n            if(nbr != parent) {\\n                res2 += findMin(nbr, gr, false, cur, price);\\n            }\\n        }\\n        return t[cur][parentDone] = min(res, res2);\\n    }\\n\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        if(n==1) {\\n            return trips.size() * price[0] / 2;\\n        }\\n        vector<int> gr[n];\\n        freq.resize(n, 0);\\n\\n        for(auto &edge: edges) {\\n            gr[edge[0]].push_back(edge[1]);\\n            gr[edge[1]].push_back(edge[0]);\\n        }\\n\\n        for(auto &trip: trips) {\\n            freq[trip[0]]++;\\n            applyDFS(gr, trip[0], -1, trip[1]);      \\n        }\\n\\n        t.resize(n, vector<int>(2, -1));\\n        return findMin(1, gr, false, -1, price);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719313,
                "title": "when-your-code-works-but-you-have-no-idea-how",
                "content": "\\n![ac8134df5d4372a6d13f3686cdde9115e5497e4c7da9ecd5995dcad1646b5c39_1.jpg](https://assets.leetcode.com/users/images/3e351881-9320-498c-acd4-2207dd4ccc77_1688506228.8726444.jpeg)\\n\\n\\n# Approach\\n```\\nprepare an adjacent list, adj\\nfnd the nodes you need to cross for all the trips, theset\\nincrease the price according to how often you cross it, new_price\\ngo check out house robber question, you need to find the maximum sum you can achieve;non-adjacent, maxsum\\nyou need to find maxsum of the nodes which are together\\nthen return sum(new_price)-thesum//2\\n```\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n\\n        adj=[[] for i in range(n)]\\n        for edge in edges:\\n            adj[edge[0]].append(edge[1])\\n            adj[edge[1]].append(edge[0])\\n\\n        alist=[]\\n        def dfs(i,j,s):\\n            s.add(i)\\n            if i==j:\\n                alist.append(s.copy())\\n                return \\n            for a in adj[i]:\\n                if a not in s:\\n                    dfs(a,j,s)\\n            s.remove(i)\\n            return \\n        for t in trips:\\n            dfs(t[0],t[1],set())\\n\\n        new_price=[0]*n\\n        theset=set()\\n        for s in alist:\\n            for el in s:\\n                new_price[el]+=price[el]\\n                theset.add(el)\\n        price=new_price\\n\\n        @cache\\n        def maxsum(i,p):\\n            ans1=0\\n            ans2=0\\n            for x in adj[i]:\\n                if x!=i and x!=p and x in theset:\\n                    ans1+=maxsum(x,i)\\n                    for y in adj[x]:\\n                        if y!=i and y!=x and y in theset:\\n                            ans2+=maxsum(y,x)\\n            return max(ans1,ans2+price[i])\\n        \\n        def findthefam(i,s):\\n            s.add(i)\\n            for x in adj[i]:\\n                if x in theset and x not in s:\\n                    findthefam(x,s)\\n            return\\n\\n        thesum=0\\n        while theset:\\n            for z in theset:\\n                zero=z\\n                break\\n            thesum+=maxsum(z,z)\\n            s=set()\\n            findthefam(z,s)\\n            theset=theset-s\\n        \\n        return sum(new_price)-thesum//2\\n\\n        #MADARCHOD\\n\\n            #IT WORKED\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nprepare an adjacent list, adj\\nfnd the nodes you need to cross for all the trips, theset\\nincrease the price according to how often you cross it, new_price\\ngo check out house robber question, you need to find the maximum sum you can achieve;non-adjacent, maxsum\\nyou need to find maxsum of the nodes which are together\\nthen return sum(new_price)-thesum//2\\n```\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n\\n        adj=[[] for i in range(n)]\\n        for edge in edges:\\n            adj[edge[0]].append(edge[1])\\n            adj[edge[1]].append(edge[0])\\n\\n        alist=[]\\n        def dfs(i,j,s):\\n            s.add(i)\\n            if i==j:\\n                alist.append(s.copy())\\n                return \\n            for a in adj[i]:\\n                if a not in s:\\n                    dfs(a,j,s)\\n            s.remove(i)\\n            return \\n        for t in trips:\\n            dfs(t[0],t[1],set())\\n\\n        new_price=[0]*n\\n        theset=set()\\n        for s in alist:\\n            for el in s:\\n                new_price[el]+=price[el]\\n                theset.add(el)\\n        price=new_price\\n\\n        @cache\\n        def maxsum(i,p):\\n            ans1=0\\n            ans2=0\\n            for x in adj[i]:\\n                if x!=i and x!=p and x in theset:\\n                    ans1+=maxsum(x,i)\\n                    for y in adj[x]:\\n                        if y!=i and y!=x and y in theset:\\n                            ans2+=maxsum(y,x)\\n            return max(ans1,ans2+price[i])\\n        \\n        def findthefam(i,s):\\n            s.add(i)\\n            for x in adj[i]:\\n                if x in theset and x not in s:\\n                    findthefam(x,s)\\n            return\\n\\n        thesum=0\\n        while theset:\\n            for z in theset:\\n                zero=z\\n                break\\n            thesum+=maxsum(z,z)\\n            s=set()\\n            findthefam(z,s)\\n            theset=theset-s\\n        \\n        return sum(new_price)-thesum//2\\n\\n        #MADARCHOD\\n\\n            #IT WORKED\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628361,
                "title": "simple-c-solution-dynamic-programming-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid dfs(int index,vector<int>sides[],vector<int>&curr,int p,int &end,int &flag){\\n    if(index==end){\\n        curr.push_back(index);\\n        flag=1;\\n        return;\\n    }\\n    curr.push_back(index);\\n    for(int i=0;i<sides[index].size();i++){\\n        if(sides[index][i]!=p){\\n            dfs(sides[index][i],sides,curr,index,end,flag);\\n            if(flag==1){\\n                break;\\n            }\\n                curr.pop_back();\\n            \\n        }\\n    }\\n    if(flag==1)return;\\n}\\nvoid hope(int index,vector<int>&price,vector<vector<int>>&dp,vector<int>sides[],int p,vector<int>&freq){\\n    dp[index][0]=freq[index]*price[index];\\n    dp[index][1]=freq[index]*price[index]/2;\\n    for(int i=0;i<sides[index].size();i++){\\n        if(sides[index][i]!=p){\\n            hope(sides[index][i],price,dp,sides,index,freq);\\n        dp[index][0]=dp[index][0]+min(dp[sides[index][i]][0],dp[sides[index][i]][1]);\\n        dp[index][1]=dp[index][1]+dp[sides[index][i]][0];\\n        }\\n    }\\n}\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int>sides[n];\\n          vector<vector<int>>dp(n,vector<int>(2,0));\\n                  vector<int>freq(n,0);\\n        for(int i=0;i<edges.size();i++){\\n            sides[edges[i][0]].push_back(edges[i][1]);\\n            sides[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<trips.size();i++){\\n            vector<int>curr;\\n            int flag=0;\\n            dfs(trips[i][0],sides,curr,-1,trips[i][1],flag);\\n            for(int i=0;i<curr.size();i++){\\n                freq[curr[i]]=freq[curr[i]]+1;\\n            }\\n        }\\n        hope(0,price,dp,sides,-1,freq);\\n        return min(dp[0][0],dp[0][1]);\\n    }\\n};\\n/*\\n\\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(int index,vector<int>sides[],vector<int>&curr,int p,int &end,int &flag){\\n    if(index==end){\\n        curr.push_back(index);\\n        flag=1;\\n        return;\\n    }\\n    curr.push_back(index);\\n    for(int i=0;i<sides[index].size();i++){\\n        if(sides[index][i]!=p){\\n            dfs(sides[index][i],sides,curr,index,end,flag);\\n            if(flag==1){\\n                break;\\n            }\\n                curr.pop_back();\\n            \\n        }\\n    }\\n    if(flag==1)return;\\n}\\nvoid hope(int index,vector<int>&price,vector<vector<int>>&dp,vector<int>sides[],int p,vector<int>&freq){\\n    dp[index][0]=freq[index]*price[index];\\n    dp[index][1]=freq[index]*price[index]/2;\\n    for(int i=0;i<sides[index].size();i++){\\n        if(sides[index][i]!=p){\\n            hope(sides[index][i],price,dp,sides,index,freq);\\n        dp[index][0]=dp[index][0]+min(dp[sides[index][i]][0],dp[sides[index][i]][1]);\\n        dp[index][1]=dp[index][1]+dp[sides[index][i]][0];\\n        }\\n    }\\n}\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int>sides[n];\\n          vector<vector<int>>dp(n,vector<int>(2,0));\\n                  vector<int>freq(n,0);\\n        for(int i=0;i<edges.size();i++){\\n            sides[edges[i][0]].push_back(edges[i][1]);\\n            sides[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<trips.size();i++){\\n            vector<int>curr;\\n            int flag=0;\\n            dfs(trips[i][0],sides,curr,-1,trips[i][1],flag);\\n            for(int i=0;i<curr.size();i++){\\n                freq[curr[i]]=freq[curr[i]]+1;\\n            }\\n        }\\n        hope(0,price,dp,sides,-1,freq);\\n        return min(dp[0][0],dp[0][1]);\\n    }\\n};\\n/*\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628122,
                "title": "c-dp-memoization-frequency-array-with-explanation",
                "content": "# Intuition\\nThe answer without half will be the number of times each node is present in all the trips multiplied by the price of node.\\n\\nWe can use DP to find the maximum value that needs to be subtracted from initial answer.\\n\\nPlease UPVOTE if you liked the solution :)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> freq(n, 0);\\n        vector<vector<int>> adj(n);\\n        for(auto& it : edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        // DFS to find the frequenct of each node in trips\\n        for(auto& it : trips){\\n            vector<int> nodes;\\n            nodes.push_back(it[0]);\\n            dfs(adj, freq, it[0], it[1], -1, nodes);\\n            nodes.pop_back();\\n        }\\n\\n        // The initial answer\\n        int sum = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            sum += (freq[i]*price[i]);\\n        }\\n\\n        //Use DP to choose half and notHalf\\n        vector<vector<int>> dp(n, vector<int>(2, -1));\\n        return sum-max(solve(adj, dp, 0, 0, price, freq, -1), solve(adj, dp, 0, 1, price, freq, -1));\\n    }\\n\\n    int solve(vector<vector<int>>& adj, vector<vector<int>>& dp, int node, int prev, vector<int>& price, vector<int>& freq, int parent){\\n        if(dp[node][prev] != -1)    return dp[node][prev];\\n\\n        // If previous node was halved, so this node cannot be halved\\n        int half = prev == 0 ? price[node]*freq[node]/2 : 0, notHalf=0;\\n        for(auto it : adj[node]){\\n            if(it != parent){\\n                if(prev == 0)\\n                    half += solve(adj, dp, it, 1, price, freq, node);\\n                notHalf += solve(adj, dp, it, 0, price, freq, node);\\n            }\\n        }\\n\\n        return dp[node][prev] = max(half, notHalf);\\n    }\\n\\n    void dfs(vector<vector<int>>& adj, vector<int>& freq, int src, int dst, int par, vector<int>& nodes){\\n        if(src == dst){\\n            for(auto it : nodes)    freq[it]++;\\n            return;\\n        }\\n\\n        for(auto it : adj[src]){\\n            if(it != par){\\n                nodes.push_back(it);\\n                dfs(adj, freq, it, dst, src, nodes);\\n                nodes.pop_back();\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> freq(n, 0);\\n        vector<vector<int>> adj(n);\\n        for(auto& it : edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        // DFS to find the frequenct of each node in trips\\n        for(auto& it : trips){\\n            vector<int> nodes;\\n            nodes.push_back(it[0]);\\n            dfs(adj, freq, it[0], it[1], -1, nodes);\\n            nodes.pop_back();\\n        }\\n\\n        // The initial answer\\n        int sum = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            sum += (freq[i]*price[i]);\\n        }\\n\\n        //Use DP to choose half and notHalf\\n        vector<vector<int>> dp(n, vector<int>(2, -1));\\n        return sum-max(solve(adj, dp, 0, 0, price, freq, -1), solve(adj, dp, 0, 1, price, freq, -1));\\n    }\\n\\n    int solve(vector<vector<int>>& adj, vector<vector<int>>& dp, int node, int prev, vector<int>& price, vector<int>& freq, int parent){\\n        if(dp[node][prev] != -1)    return dp[node][prev];\\n\\n        // If previous node was halved, so this node cannot be halved\\n        int half = prev == 0 ? price[node]*freq[node]/2 : 0, notHalf=0;\\n        for(auto it : adj[node]){\\n            if(it != parent){\\n                if(prev == 0)\\n                    half += solve(adj, dp, it, 1, price, freq, node);\\n                notHalf += solve(adj, dp, it, 0, price, freq, node);\\n            }\\n        }\\n\\n        return dp[node][prev] = max(half, notHalf);\\n    }\\n\\n    void dfs(vector<vector<int>>& adj, vector<int>& freq, int src, int dst, int par, vector<int>& nodes){\\n        if(src == dst){\\n            for(auto it : nodes)    freq[it]++;\\n            return;\\n        }\\n\\n        for(auto it : adj[src]){\\n            if(it != par){\\n                nodes.push_back(it);\\n                dfs(adj, freq, it, dst, src, nodes);\\n                nodes.pop_back();\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616330,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>>next(n) ;\\n        vector<int>plan0(n, -1) ;\\n        vector<int>plan1(n, -1) ;\\n        vector<int>count(n) ;\\n        vector<int>val(n) ;\\n        for(auto& e : edges){\\n            int u = e[0], v = e[1] ;\\n            next[u].push_back(v) ;\\n            next[v].push_back(u) ;\\n        }\\n        for(auto& trip : trips)\\n            dfs(trip[0], -1, trip[1], count, next) ;\\n        \\n        for(int i = 0; i < n; i++)\\n            val[i] = price[i] * count[i] ;\\n        \\n        return DFS(0, -1, 1, plan0, plan1, val, next) ;\\n        \\n    }\\n    bool dfs(int cur, int parent, int target, vector<int>&count, vector<vector<int>>&next){\\n        if(cur == target){\\n            count[cur]++ ;\\n            return true;\\n        }\\n        for(auto& x : next[cur]){\\n            if(x == parent) continue ;\\n            if(dfs(x, cur, target, count, next)){\\n                count[cur]++ ;\\n                return true ;\\n            }\\n        }\\n        return false ;\\n    }\\n    //flag : 1 can choose ; 0 can\\'t choose\\n    int DFS(int cur, int parent, int flag, vector<int>&plan0, vector<int>&plan1, vector<int>&val, vector<vector<int>>&next){\\n        if(flag == 0 && plan0[cur] != -1) return plan0[cur] ;  \\n        if(flag == 1 && plan1[cur] != -1) return plan1[cur] ;  \\n        \\n        if(flag == 0){\\n            int ret = val[cur] ;\\n            for(auto x : next[cur]){\\n                if(x == parent) continue ;\\n                ret += DFS(x, cur, 1, plan0, plan1, val, next) ;\\n            }  \\n            plan0[cur] = ret ;\\n            return ret ;\\n        }\\n        else{\\n            int option1 = val[cur] / 2 ;\\n            for(auto x : next[cur]){\\n                if(x == parent) continue ;\\n                option1 += DFS(x, cur, 0, plan0, plan1, val, next) ;\\n            }\\n            int option2 = val[cur] ;\\n            for(auto x : next[cur]){\\n                if(x == parent) continue ;\\n                option2 += DFS(x, cur, 1, plan0, plan1, val, next) ;\\n            }\\n            plan1[cur] = min(option1, option2) ;\\n            return plan1[cur] ;    \\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>>next(n) ;\\n        vector<int>plan0(n, -1) ;\\n        vector<int>plan1(n, -1) ;\\n        vector<int>count(n) ;\\n        vector<int>val(n) ;\\n        for(auto& e : edges){\\n            int u = e[0], v = e[1] ;\\n            next[u].push_back(v) ;\\n            next[v].push_back(u) ;\\n        }\\n        for(auto& trip : trips)\\n            dfs(trip[0], -1, trip[1], count, next) ;\\n        \\n        for(int i = 0; i < n; i++)\\n            val[i] = price[i] * count[i] ;\\n        \\n        return DFS(0, -1, 1, plan0, plan1, val, next) ;\\n        \\n    }\\n    bool dfs(int cur, int parent, int target, vector<int>&count, vector<vector<int>>&next){\\n        if(cur == target){\\n            count[cur]++ ;\\n            return true;\\n        }\\n        for(auto& x : next[cur]){\\n            if(x == parent) continue ;\\n            if(dfs(x, cur, target, count, next)){\\n                count[cur]++ ;\\n                return true ;\\n            }\\n        }\\n        return false ;\\n    }\\n    //flag : 1 can choose ; 0 can\\'t choose\\n    int DFS(int cur, int parent, int flag, vector<int>&plan0, vector<int>&plan1, vector<int>&val, vector<vector<int>>&next){\\n        if(flag == 0 && plan0[cur] != -1) return plan0[cur] ;  \\n        if(flag == 1 && plan1[cur] != -1) return plan1[cur] ;  \\n        \\n        if(flag == 0){\\n            int ret = val[cur] ;\\n            for(auto x : next[cur]){\\n                if(x == parent) continue ;\\n                ret += DFS(x, cur, 1, plan0, plan1, val, next) ;\\n            }  \\n            plan0[cur] = ret ;\\n            return ret ;\\n        }\\n        else{\\n            int option1 = val[cur] / 2 ;\\n            for(auto x : next[cur]){\\n                if(x == parent) continue ;\\n                option1 += DFS(x, cur, 0, plan0, plan1, val, next) ;\\n            }\\n            int option2 = val[cur] ;\\n            for(auto x : next[cur]){\\n                if(x == parent) continue ;\\n                option2 += DFS(x, cur, 1, plan0, plan1, val, next) ;\\n            }\\n            plan1[cur] = min(option1, option2) ;\\n            return plan1[cur] ;    \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580010,
                "title": "java-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCount how many times each node is visited. Then use the same concept as we have used in House Robber III based on DP.\\n\\n\\n# Code\\n```\\n//RITIK PATEL\\nclass Solution {\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        int [] counts= new int[n];\\n        List<List<Integer>> Adj = new ArrayList();\\n        for(int i=0; i<n; i++) Adj.add(new ArrayList());\\n        for(int edge[]:edges){\\n            Adj.get(edge[0]).add(edge[1]);\\n            Adj.get(edge[1]).add(edge[0]);\\n        }\\n        for(int trip[]: trips){\\n            boolean vis[] = new boolean[n];\\n            DFSTraverse(trip[0], trip[1], counts, Adj, vis);\\n        }\\n        // for(int count: counts){\\n        //     System.out.print(count+\" \");\\n        // }\\n        int DP[] = new int[n];\\n        for(int i=0; i<DP.length; i++){\\n            DP[i] = -1;\\n        }\\n        boolean pathvis[] = new boolean[n];\\n        return DPDFS(n-1,DP,Adj,pathvis,price, counts);\\n    }\\n    boolean DFSTraverse(int start ,int tgt, int[] counts, List<List<Integer>> Adj, boolean vis[]){\\n        if(vis[start]) return false;\\n        vis[start] = true;\\n        if(start==tgt){\\n            counts[start]++;\\n            return true;\\n        }\\n        boolean ans = false;\\n        for(int adjacent: Adj.get(start)){\\n            ans = ans | DFSTraverse(adjacent, tgt, counts, Adj, vis);\\n        }\\n        if(ans){\\n            counts[start]++;\\n        }\\n        return ans;\\n    }\\n    int DPDFS(int node, int[] DP, List<List<Integer>> Adj, boolean pathvis[], int[] prices, int [] counts){\\n        if(pathvis[node]) return 0;\\n        // System.out.print(node+\" \");\\n        if(DP[node]!=-1) return DP[node];\\n        \\n        //child of child calculate\\n        int ans1 = 0;\\n        int ans2 = 0;\\n        int childval = 0;\\n        pathvis[node] = true;\\n        for(int child1: Adj.get(node)){\\n            if(pathvis[child1]) continue;\\n            pathvis[child1] = true;\\n            for(int child2: Adj.get(child1)){\\n                int val = DPDFS(child2, DP, Adj, pathvis,prices, counts);\\n                ans2 += val;\\n            }\\n            pathvis[child1] = false;\\n            childval+= counts[child1]*prices[child1];\\n            ans1 += DPDFS(child1, DP, Adj, pathvis,prices, counts);\\n        }\\n        int Ans = Math.min(ans2+childval+(prices[node]*counts[node])/2, ans1+prices[node]*counts[node]);\\n        pathvis[node] = false;\\n        // System.out.println(node+\"--->\"+Ans);\\n        return DP[node] = Ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n//RITIK PATEL\\nclass Solution {\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        int [] counts= new int[n];\\n        List<List<Integer>> Adj = new ArrayList();\\n        for(int i=0; i<n; i++) Adj.add(new ArrayList());\\n        for(int edge[]:edges){\\n            Adj.get(edge[0]).add(edge[1]);\\n            Adj.get(edge[1]).add(edge[0]);\\n        }\\n        for(int trip[]: trips){\\n            boolean vis[] = new boolean[n];\\n            DFSTraverse(trip[0], trip[1], counts, Adj, vis);\\n        }\\n        // for(int count: counts){\\n        //     System.out.print(count+\" \");\\n        // }\\n        int DP[] = new int[n];\\n        for(int i=0; i<DP.length; i++){\\n            DP[i] = -1;\\n        }\\n        boolean pathvis[] = new boolean[n];\\n        return DPDFS(n-1,DP,Adj,pathvis,price, counts);\\n    }\\n    boolean DFSTraverse(int start ,int tgt, int[] counts, List<List<Integer>> Adj, boolean vis[]){\\n        if(vis[start]) return false;\\n        vis[start] = true;\\n        if(start==tgt){\\n            counts[start]++;\\n            return true;\\n        }\\n        boolean ans = false;\\n        for(int adjacent: Adj.get(start)){\\n            ans = ans | DFSTraverse(adjacent, tgt, counts, Adj, vis);\\n        }\\n        if(ans){\\n            counts[start]++;\\n        }\\n        return ans;\\n    }\\n    int DPDFS(int node, int[] DP, List<List<Integer>> Adj, boolean pathvis[], int[] prices, int [] counts){\\n        if(pathvis[node]) return 0;\\n        // System.out.print(node+\" \");\\n        if(DP[node]!=-1) return DP[node];\\n        \\n        //child of child calculate\\n        int ans1 = 0;\\n        int ans2 = 0;\\n        int childval = 0;\\n        pathvis[node] = true;\\n        for(int child1: Adj.get(node)){\\n            if(pathvis[child1]) continue;\\n            pathvis[child1] = true;\\n            for(int child2: Adj.get(child1)){\\n                int val = DPDFS(child2, DP, Adj, pathvis,prices, counts);\\n                ans2 += val;\\n            }\\n            pathvis[child1] = false;\\n            childval+= counts[child1]*prices[child1];\\n            ans1 += DPDFS(child1, DP, Adj, pathvis,prices, counts);\\n        }\\n        int Ans = Math.min(ans2+childval+(prices[node]*counts[node])/2, ans1+prices[node]*counts[node]);\\n        pathvis[node] = false;\\n        // System.out.println(node+\"--->\"+Ans);\\n        return DP[node] = Ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576639,
                "title": "c-dfs-dp-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[51][2]; \\n\\n    void calc(int node, int end, int parent, vector<int>& path, vector<int>& contri, vector<vector<int>>& graph){\\n        path.push_back(node);\\n\\n        if(end == node){ \\n            for(auto& i : path){\\n                contri[i]++; \\n            }\\n            path.pop_back();\\n            return;\\n        }\\n\\n        for(auto& child : graph[node]){ \\n            if(child != parent) {\\n                calc(child, end, node, path, contri, graph);   \\n            }\\n        }   \\n\\n        path.pop_back();\\n    }\\n\\n    int dfs(int node, int parent, bool parentHalved, vector<int>& contri, vector<int>& price, vector<vector<int>>& graph){\\n        if(dp[node][parentHalved] != -1)  return dp[node][parentHalved];\\n\\n        int res1 = contri[node] * (price[node] / 2);\\n        int res2 = contri[node] * price[node];\\n        \\n        \\n        for(auto& child : graph[node]){\\n            if(child != parent)   res2 += dfs(child, node, false, contri, price, graph);\\n        }\\n        if(parentHalved) return dp[node][parentHalved] = res2;\\n        \\n        for(auto& child : graph[node]){\\n            if(child != parent)   res1 += dfs(child, node, true, contri, price, graph);\\n        }\\n\\n        return dp[node][parentHalved] = min(res1, res2);\\n    }\\n\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        memset(dp,-1,sizeof dp);\\n\\n        vector<vector<int>> graph(n);\\n        for(auto& e:edges){\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n        }\\n\\n        vector<int> contri(n, 0);\\n        for(auto& t : trips){\\n            vector<int> path;\\n            calc(t[0], t[1], -1, path, contri, graph);\\n        }\\n        \\n        return dfs(0, -1, false, contri, price, graph);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[51][2]; \\n\\n    void calc(int node, int end, int parent, vector<int>& path, vector<int>& contri, vector<vector<int>>& graph){\\n        path.push_back(node);\\n\\n        if(end == node){ \\n            for(auto& i : path){\\n                contri[i]++; \\n            }\\n            path.pop_back();\\n            return;\\n        }\\n\\n        for(auto& child : graph[node]){ \\n            if(child != parent) {\\n                calc(child, end, node, path, contri, graph);   \\n            }\\n        }   \\n\\n        path.pop_back();\\n    }\\n\\n    int dfs(int node, int parent, bool parentHalved, vector<int>& contri, vector<int>& price, vector<vector<int>>& graph){\\n        if(dp[node][parentHalved] != -1)  return dp[node][parentHalved];\\n\\n        int res1 = contri[node] * (price[node] / 2);\\n        int res2 = contri[node] * price[node];\\n        \\n        \\n        for(auto& child : graph[node]){\\n            if(child != parent)   res2 += dfs(child, node, false, contri, price, graph);\\n        }\\n        if(parentHalved) return dp[node][parentHalved] = res2;\\n        \\n        for(auto& child : graph[node]){\\n            if(child != parent)   res1 += dfs(child, node, true, contri, price, graph);\\n        }\\n\\n        return dp[node][parentHalved] = min(res1, res2);\\n    }\\n\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        memset(dp,-1,sizeof dp);\\n\\n        vector<vector<int>> graph(n);\\n        for(auto& e:edges){\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n        }\\n\\n        vector<int> contri(n, 0);\\n        for(auto& t : trips){\\n            vector<int> path;\\n            calc(t[0], t[1], -1, path, contri, graph);\\n        }\\n        \\n        return dfs(0, -1, false, contri, price, graph);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556526,
                "title": "concise-solution-with-dfs-memoization-in-python3",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBy aggregating all trips, the final priceof node `v` can be determined by `price[v] * weight[v]` where `weight[v]` is the times `v` visited in all the trips. So, we can perform the depth first search (or BFS) for every trip and obtain the final price of each node. \\nThe next phase is to determine the color of each node. Dynamic programming is used to find the optimal color assignment. For the tree structure, top-down dynamic programming (memoization) will be much easier to implement, in particular in Python. `@cache` is your friend. \\n\\n# Complexity\\n- Time complexity: $$O(nm)$$ where $n$ is the number of nodes and $m$ is the number of trips. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        graph = defaultdict(set)\\n        for u, v in edges:\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        weight = Counter()\\n        \\n        def dfs(s, t, parent=-1):\\n            if s == t: \\n                weight[s] += 1\\n                return True\\n            for v in graph[s]:\\n                if v != parent:\\n                    if dfs(v, t, s):\\n                        weight[s] += 1\\n                        return True\\n            return False\\n\\n        @cache\\n        def dp(v, parent=-1, parent_half=False):\\n            ans = sum(dp(u, v, False) for u in graph[v] if u != parent) + price[v]\\n            if not parent_half:\\n                ans = min(ans, sum(dp(u, v, True) for u in graph[v] if u != parent) + price[v] // 2)\\n            return ans\\n\\n        for s, t in trips:\\n            dfs(s, t)\\n        price = [price[i] * weight[i] for i in range(n)]\\n\\n        return dp(0)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        graph = defaultdict(set)\\n        for u, v in edges:\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        weight = Counter()\\n        \\n        def dfs(s, t, parent=-1):\\n            if s == t: \\n                weight[s] += 1\\n                return True\\n            for v in graph[s]:\\n                if v != parent:\\n                    if dfs(v, t, s):\\n                        weight[s] += 1\\n                        return True\\n            return False\\n\\n        @cache\\n        def dp(v, parent=-1, parent_half=False):\\n            ans = sum(dp(u, v, False) for u in graph[v] if u != parent) + price[v]\\n            if not parent_half:\\n                ans = min(ans, sum(dp(u, v, True) for u in graph[v] if u != parent) + price[v] // 2)\\n            return ans\\n\\n        for s, t in trips:\\n            dfs(s, t)\\n        price = [price[i] * weight[i] for i in range(n)]\\n\\n        return dp(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525042,
                "title": "c-soluton-easy-to-understand",
                "content": "# Intuition\\nThis is based on the hints ... first find how many times you need to visit a particular node and then do the DP step to minimize the total price.\\n\\n# Approach\\nPre-step is to build the adjacency table. First step (visiting nodes) is just a normal dfs and keep track of how many times we passed on that node. DP array reprensents the minimal cost if we halve the price at that node or not. We keep track of both numbers. Leaf node is the smallest subproblem we can have so we start by saving 2 costs : if we halve the node or not. Then to solve biggest problems we need to have the minimum cost if we halve the current node or not. If we halve the node the only possibility is to not halve all the children because of the restriction on adjacent nodes. If we don\\'t have the node we have to take the most optimal subproblem wich would be the minimal cost for each children.    \\n\\n# Complexity\\n- Time complexity:\\no(m * n), m is num of trips\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        \\n        vector<vector<int>> adjacency(n);\\n        for(int i = 0; i < edges.size(); ++i)\\n        {\\n            adjacency[edges[i][0]].push_back(edges[i][1]);\\n            adjacency[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        vector<int> res(n);\\n        for(int i = 0; i < trips.size(); ++i)\\n        {\\n            dfs(adjacency, res, trips[i][0], -1, trips[i][1]);\\n        }\\n\\n        vector<pair<int, int>> dp(n);\\n        dfsDp(adjacency, res, price, dp, 0, -1);\\n        return min(dp[0].first, dp[0].second);\\n        \\n    }\\n\\n    void dfsDp(vector<vector<int>>& adjacency, vector<int>& res, vector<int>& price, vector<pair<int, int>>& dp,  int current, int parent)\\n    {\\n        if(adjacency[current].size() == 1 && adjacency[current][0] == parent)\\n        {\\n            int cost = res[current]  * price[current];\\n            int halfCost = cost / 2; \\n            dp[current] = {halfCost, cost};\\n            return;\\n        }\\n\\n        for(int child : adjacency[current])\\n        {\\n            if(child == parent) continue; \\n            dfsDp(adjacency, res, price, dp, child, current);\\n        }\\n\\n        int cost = res[current]  * price[current];\\n        int halfCost = cost / 2;\\n\\n        int priceNotCut = 0;\\n        for(int child : adjacency[current])\\n        {\\n            if(child == parent) continue; \\n            auto p = dp[child];\\n            priceNotCut += p.second; \\n        }\\n\\n        halfCost += priceNotCut;\\n        int priceChildrens = 0;\\n        for(int child : adjacency[current])\\n        {\\n            if(child == parent) continue; \\n            auto p = dp[child];\\n            priceChildrens += min(p.first, p.second); \\n        }\\n        cost += priceChildrens; \\n        dp[current] = {halfCost, cost};\\n    }\\n\\n    bool dfs(vector<vector<int>>& adjacency, vector<int>& res, int current, int parent, int destination)\\n    {\\n        if(current == destination) \\n        {\\n            ++res[current];\\n            return true; \\n        }\\n\\n        for(int child : adjacency[current])\\n        {\\n            if(child == parent) continue; \\n            bool b = dfs(adjacency, res, child, current, destination);\\n            if(b)\\n            {\\n                ++res[current];\\n                return true; \\n            }\\n        }\\n        return false; \\n    }\\n\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        \\n        vector<vector<int>> adjacency(n);\\n        for(int i = 0; i < edges.size(); ++i)\\n        {\\n            adjacency[edges[i][0]].push_back(edges[i][1]);\\n            adjacency[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        vector<int> res(n);\\n        for(int i = 0; i < trips.size(); ++i)\\n        {\\n            dfs(adjacency, res, trips[i][0], -1, trips[i][1]);\\n        }\\n\\n        vector<pair<int, int>> dp(n);\\n        dfsDp(adjacency, res, price, dp, 0, -1);\\n        return min(dp[0].first, dp[0].second);\\n        \\n    }\\n\\n    void dfsDp(vector<vector<int>>& adjacency, vector<int>& res, vector<int>& price, vector<pair<int, int>>& dp,  int current, int parent)\\n    {\\n        if(adjacency[current].size() == 1 && adjacency[current][0] == parent)\\n        {\\n            int cost = res[current]  * price[current];\\n            int halfCost = cost / 2; \\n            dp[current] = {halfCost, cost};\\n            return;\\n        }\\n\\n        for(int child : adjacency[current])\\n        {\\n            if(child == parent) continue; \\n            dfsDp(adjacency, res, price, dp, child, current);\\n        }\\n\\n        int cost = res[current]  * price[current];\\n        int halfCost = cost / 2;\\n\\n        int priceNotCut = 0;\\n        for(int child : adjacency[current])\\n        {\\n            if(child == parent) continue; \\n            auto p = dp[child];\\n            priceNotCut += p.second; \\n        }\\n\\n        halfCost += priceNotCut;\\n        int priceChildrens = 0;\\n        for(int child : adjacency[current])\\n        {\\n            if(child == parent) continue; \\n            auto p = dp[child];\\n            priceChildrens += min(p.first, p.second); \\n        }\\n        cost += priceChildrens; \\n        dp[current] = {halfCost, cost};\\n    }\\n\\n    bool dfs(vector<vector<int>>& adjacency, vector<int>& res, int current, int parent, int destination)\\n    {\\n        if(current == destination) \\n        {\\n            ++res[current];\\n            return true; \\n        }\\n\\n        for(int child : adjacency[current])\\n        {\\n            if(child == parent) continue; \\n            bool b = dfs(adjacency, res, child, current, destination);\\n            if(b)\\n            {\\n                ++res[current];\\n                return true; \\n            }\\n        }\\n        return false; \\n    }\\n\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524286,
                "title": "rust-dfs-backtracking-dp-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFinish all trips & get the the tatal counts on the number of visits of each node, using DFS & Backtracking.\\n\\nGet the total price without any adjustment.\\n\\nUsing DP to calculate the saving with adjustment.  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nimpl Solution {\\n    pub fn minimum_total_price(n: i32, edges: Vec<Vec<i32>>, price: Vec<i32>, trips: Vec<Vec<i32>>) -> i32 {\\n        // build the graph\\n        let n = price.len();\\n        let mut graph = vec![vec![]; n];\\n\\n        for e in edges {\\n            let (u, v) = (e[0] as usize, e[1] as usize);\\n            graph[u].push(v);\\n            graph[v].push(u);\\n        }\\n\\n        // count the frequency of each node after finishing all trips \\n        let mut count = vec![0; n];\\n        for t in trips {\\n            let (u, v) = (t[0] as usize, t[1] as usize);\\n\\n            let mut visited = vec![0; n];\\n            count[u] += 1; \\n            if (u != v) { Self::backtracking(&graph, &mut count, u, v, &mut visited); }\\n        }\\n\\n        // the total price if no adjustment will be made \\n        let mut ret = 0;\\n        for i in 0 .. n { ret += price[i] * count[i]; }\\n\\n        // dp[u][flag]: the optimal saving with/without adjustment at each node\\n        let mut dp = vec![vec![-1; 2]; n];\\n        for flag in 0 .. 2 { Self::dfs(&graph, &price, &count, 0, n, flag, &mut dp); }\\n\\n        ret - dp[0][0].max(dp[0][1])\\n    }\\n\\n    fn dfs(graph: &Vec<Vec<usize>>, price: &Vec<i32>, count: &Vec<i32>, u: usize, parent: usize, flag: usize, dp: &mut Vec<Vec<i32>>) -> i32 {\\n        if dp[u][flag] != -1 { return dp[u][flag] }\\n        dp[u][flag] = if flag == 0 { 0 } else { count[u] * price[u] / 2 };\\n\\n        for v in &graph[u] {\\n            let v = *v;\\n            if v == parent { continue }\\n\\n            Self::dfs(graph, price, count, v, u, 0, dp);\\n            Self::dfs(graph, price, count, v, u, 1, dp);\\n            dp[u][flag] += if flag == 0 { dp[v][0].max(dp[v][1]) } else { dp[v][0] }; \\n        }\\n        dp[u][flag]\\n    }\\n\\n    fn backtracking(graph: &Vec<Vec<usize>>, count: &mut Vec<i32>, u: usize, dest: usize, visited: &mut Vec<i32>) -> bool {\\n        visited[u] = 1;\\n\\n        for v in &graph[u] {\\n            let v = *v;\\n            if visited[v] == 1 { continue }\\n\\n            count[v] += 1;\\n            if v == dest { return true }\\n            if Self::backtracking(graph, count, v, dest, visited) { return true }\\n            count[v] -= 1;\\n        }\\n        false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_total_price(n: i32, edges: Vec<Vec<i32>>, price: Vec<i32>, trips: Vec<Vec<i32>>) -> i32 {\\n        // build the graph\\n        let n = price.len();\\n        let mut graph = vec![vec![]; n];\\n\\n        for e in edges {\\n            let (u, v) = (e[0] as usize, e[1] as usize);\\n            graph[u].push(v);\\n            graph[v].push(u);\\n        }\\n\\n        // count the frequency of each node after finishing all trips \\n        let mut count = vec![0; n];\\n        for t in trips {\\n            let (u, v) = (t[0] as usize, t[1] as usize);\\n\\n            let mut visited = vec![0; n];\\n            count[u] += 1; \\n            if (u != v) { Self::backtracking(&graph, &mut count, u, v, &mut visited); }\\n        }\\n\\n        // the total price if no adjustment will be made \\n        let mut ret = 0;\\n        for i in 0 .. n { ret += price[i] * count[i]; }\\n\\n        // dp[u][flag]: the optimal saving with/without adjustment at each node\\n        let mut dp = vec![vec![-1; 2]; n];\\n        for flag in 0 .. 2 { Self::dfs(&graph, &price, &count, 0, n, flag, &mut dp); }\\n\\n        ret - dp[0][0].max(dp[0][1])\\n    }\\n\\n    fn dfs(graph: &Vec<Vec<usize>>, price: &Vec<i32>, count: &Vec<i32>, u: usize, parent: usize, flag: usize, dp: &mut Vec<Vec<i32>>) -> i32 {\\n        if dp[u][flag] != -1 { return dp[u][flag] }\\n        dp[u][flag] = if flag == 0 { 0 } else { count[u] * price[u] / 2 };\\n\\n        for v in &graph[u] {\\n            let v = *v;\\n            if v == parent { continue }\\n\\n            Self::dfs(graph, price, count, v, u, 0, dp);\\n            Self::dfs(graph, price, count, v, u, 1, dp);\\n            dp[u][flag] += if flag == 0 { dp[v][0].max(dp[v][1]) } else { dp[v][0] }; \\n        }\\n        dp[u][flag]\\n    }\\n\\n    fn backtracking(graph: &Vec<Vec<usize>>, count: &mut Vec<i32>, u: usize, dest: usize, visited: &mut Vec<i32>) -> bool {\\n        visited[u] = 1;\\n\\n        for v in &graph[u] {\\n            let v = *v;\\n            if visited[v] == 1 { continue }\\n\\n            count[v] += 1;\\n            if v == dest { return true }\\n            if Self::backtracking(graph, count, v, dest, visited) { return true }\\n            count[v] -= 1;\\n        }\\n        false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3484391,
                "title": "c-binary-lifting-lca-dp-minimize-the-total-price-of-the-trips",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dp[100][2];\\n    vector<vector<int>> g;\\n    int cost[101];\\n\\n    int rec(int node, int prev, int par){\\n        if(dp[node][prev] != -1) return dp[node][prev];\\n        int ans = 0;\\n        for(auto x: g[node]){\\n            if(x!=par){\\n                if(prev==0){\\n                    if(cost[x]==0){\\n                        ans += rec(x,0,node);\\n                    }else{\\n                        ans += min(rec(x,1,node)+cost[x]/2,rec(x,0,node)+cost[x]);\\n                    }\\n                }else if(prev==1){\\n                    if(cost[x]==0){\\n                        ans += rec(x,0,node);\\n                    }else{\\n                        ans += (rec(x,0,node)+cost[x]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[node][prev]=ans;\\n    }\\n\\nint up[101][20];\\nint lvl[101];\\n \\nvoid binary_lift(int node, int par){\\n    up[node][0] = par;\\n    for(int i=1; i<20; i++){\\n        if(up[node][i-1]!=-1){\\n            up[node][i]=up[up[node][i-1]][i-1];\\n        }else{\\n            up[node][i]=-1;\\n        }\\n    }\\n    for(auto x: g[node]){\\n        if(x!=par){\\n            binary_lift(x,node);\\n        }\\n    }\\n}\\n \\nvoid dfs(int node, int par, int dep){\\n    lvl[node]=dep;\\n    for(auto x: g[node]){\\n        if(x!=par){\\n            dfs(x,node,dep+1);\\n        }\\n    }\\n}\\n \\nint jump_node(int node, int jump){\\n    for(int i=19; i>=0; i--){\\n        if(jump==0 || node==-1) break;\\n        if(jump>=(1LL<<i)){\\n            node = up[node][i];\\n            jump-=(1LL<<i);\\n        }\\n        // cout<<jump<<\" \"<<node<<endl;\\n    }\\n    return node;\\n}\\n \\nint LCA(int nodeA, int nodeB){\\n    if(lvl[nodeB]>lvl[nodeA]) swap(nodeA,nodeB);\\n    // cout<<up[nodeA][2]<<endl;\\n    nodeA = jump_node(nodeA,lvl[nodeA]-lvl[nodeB]);\\n    // cout<<nodeA<<\"*\\\\n\";\\n    if(nodeA==nodeB) return nodeA;\\n    for(int i=19; i>=0; i--){\\n        if(up[nodeA][i] != up[nodeB][i]){\\n            nodeA = up[nodeA][i];\\n            nodeB = up[nodeB][i];\\n        }\\n    }\\n    return jump_node(nodeA,1);\\n}\\n\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        g.clear();\\n        g.resize(n+1);\\n        for(auto x: edges){\\n            g[x[0]+1].push_back(x[1]+1);\\n            g[x[1]+1].push_back(x[0]+1);\\n        }\\n\\n        dfs(1,-1,0);\\n        binary_lift(1,-1);\\n        vector<int> cnt(n+1,0);\\n        for(auto x: trips){\\n            int a = x[0]+1, b = x[1]+1;\\n            int lca = LCA(a,b);\\n            while(a != lca){\\n                cnt[a]++;\\n                a = up[a][0];\\n            }\\n            while(b != lca){\\n                cnt[b]++;\\n                b = up[b][0];\\n            }\\n            cnt[lca]++;\\n        }        \\n        for(int i=1; i<=n; i++){\\n            cost[i] = cnt[i]*price[i-1];\\n        }\\n\\n        for(int i=0; i<=n; i++){\\n            dp[i][0]=-1;\\n            dp[i][1]=-1;\\n        }\\n        int ans = min(cost[1]+rec(1,0,-1),cost[1]/2+rec(1,1,-1));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp[100][2];\\n    vector<vector<int>> g;\\n    int cost[101];\\n\\n    int rec(int node, int prev, int par){\\n        if(dp[node][prev] != -1) return dp[node][prev];\\n        int ans = 0;\\n        for(auto x: g[node]){\\n            if(x!=par){\\n                if(prev==0){\\n                    if(cost[x]==0){\\n                        ans += rec(x,0,node);\\n                    }else{\\n                        ans += min(rec(x,1,node)+cost[x]/2,rec(x,0,node)+cost[x]);\\n                    }\\n                }else if(prev==1){\\n                    if(cost[x]==0){\\n                        ans += rec(x,0,node);\\n                    }else{\\n                        ans += (rec(x,0,node)+cost[x]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[node][prev]=ans;\\n    }\\n\\nint up[101][20];\\nint lvl[101];\\n \\nvoid binary_lift(int node, int par){\\n    up[node][0] = par;\\n    for(int i=1; i<20; i++){\\n        if(up[node][i-1]!=-1){\\n            up[node][i]=up[up[node][i-1]][i-1];\\n        }else{\\n            up[node][i]=-1;\\n        }\\n    }\\n    for(auto x: g[node]){\\n        if(x!=par){\\n            binary_lift(x,node);\\n        }\\n    }\\n}\\n \\nvoid dfs(int node, int par, int dep){\\n    lvl[node]=dep;\\n    for(auto x: g[node]){\\n        if(x!=par){\\n            dfs(x,node,dep+1);\\n        }\\n    }\\n}\\n \\nint jump_node(int node, int jump){\\n    for(int i=19; i>=0; i--){\\n        if(jump==0 || node==-1) break;\\n        if(jump>=(1LL<<i)){\\n            node = up[node][i];\\n            jump-=(1LL<<i);\\n        }\\n        // cout<<jump<<\" \"<<node<<endl;\\n    }\\n    return node;\\n}\\n \\nint LCA(int nodeA, int nodeB){\\n    if(lvl[nodeB]>lvl[nodeA]) swap(nodeA,nodeB);\\n    // cout<<up[nodeA][2]<<endl;\\n    nodeA = jump_node(nodeA,lvl[nodeA]-lvl[nodeB]);\\n    // cout<<nodeA<<\"*\\\\n\";\\n    if(nodeA==nodeB) return nodeA;\\n    for(int i=19; i>=0; i--){\\n        if(up[nodeA][i] != up[nodeB][i]){\\n            nodeA = up[nodeA][i];\\n            nodeB = up[nodeB][i];\\n        }\\n    }\\n    return jump_node(nodeA,1);\\n}\\n\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        g.clear();\\n        g.resize(n+1);\\n        for(auto x: edges){\\n            g[x[0]+1].push_back(x[1]+1);\\n            g[x[1]+1].push_back(x[0]+1);\\n        }\\n\\n        dfs(1,-1,0);\\n        binary_lift(1,-1);\\n        vector<int> cnt(n+1,0);\\n        for(auto x: trips){\\n            int a = x[0]+1, b = x[1]+1;\\n            int lca = LCA(a,b);\\n            while(a != lca){\\n                cnt[a]++;\\n                a = up[a][0];\\n            }\\n            while(b != lca){\\n                cnt[b]++;\\n                b = up[b][0];\\n            }\\n            cnt[lca]++;\\n        }        \\n        for(int i=1; i<=n; i++){\\n            cost[i] = cnt[i]*price[i-1];\\n        }\\n\\n        for(int i=0; i<=n; i++){\\n            dp[i][0]=-1;\\n            dp[i][1]=-1;\\n        }\\n        int ans = min(cost[1]+rec(1,0,-1),cost[1]/2+rec(1,1,-1));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3467244,
                "title": "c-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> p1 = price, p2= price;\\n        unordered_map<int, vector<int>> mp;\\n        for (auto e : edges) {\\n            mp[e[0]].push_back(e[1]);\\n            mp[e[1]].push_back(e[0]);\\n        }\\n        vector<int> freq(n, 0);\\n        vector<int> path;\\n        function<void(int, int, int, vector<int>)> dfs = [&](int start, int end, int prev, vector<int> v) {\\n            if (start == end) {\\n                path = v;\\n                return;\\n            }\\n            for (auto a : mp[start]) {\\n                if (a == prev or path.size() > 0) continue; \\n                v.push_back(a);\\n                dfs(a, end, start, v);\\n                v.pop_back();\\n            }\\n        };\\n        for (auto t : trips) {\\n            vector<int> v;\\n            v.push_back(t[0]);\\n            dfs(t[0], t[1], -1, v);\\n            for (int a : path) {\\n                freq[a]++;\\n            }\\n            path.clear();\\n        }\\n        function<pair<int, int>(int, int)> dp = [&](int v, int p) -> pair<int, int> {\\n            int cost1 = price[v] * freq[v];\\n            int cost2 = price[v] / 2 * freq[v];\\n            for (auto u : mp[v]) {\\n                if (u == p) continue;\\n                auto res = dp(u, v);\\n                cost1 += min(res.first, res.second);\\n                cost2 += res.first;\\n            }\\n            return {cost1, cost2};\\n        };\\n        auto ans = dp(0, -1);\\n        return min(ans.first, ans.second);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> p1 = price, p2= price;\\n        unordered_map<int, vector<int>> mp;\\n        for (auto e : edges) {\\n            mp[e[0]].push_back(e[1]);\\n            mp[e[1]].push_back(e[0]);\\n        }\\n        vector<int> freq(n, 0);\\n        vector<int> path;\\n        function<void(int, int, int, vector<int>)> dfs = [&](int start, int end, int prev, vector<int> v) {\\n            if (start == end) {\\n                path = v;\\n                return;\\n            }\\n            for (auto a : mp[start]) {\\n                if (a == prev or path.size() > 0) continue; \\n                v.push_back(a);\\n                dfs(a, end, start, v);\\n                v.pop_back();\\n            }\\n        };\\n        for (auto t : trips) {\\n            vector<int> v;\\n            v.push_back(t[0]);\\n            dfs(t[0], t[1], -1, v);\\n            for (int a : path) {\\n                freq[a]++;\\n            }\\n            path.clear();\\n        }\\n        function<pair<int, int>(int, int)> dp = [&](int v, int p) -> pair<int, int> {\\n            int cost1 = price[v] * freq[v];\\n            int cost2 = price[v] / 2 * freq[v];\\n            for (auto u : mp[v]) {\\n                if (u == p) continue;\\n                auto res = dp(u, v);\\n                cost1 += min(res.first, res.second);\\n                cost2 += res.first;\\n            }\\n            return {cost1, cost2};\\n        };\\n        auto ans = dp(0, -1);\\n        return min(ans.first, ans.second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461676,
                "title": "dfs-dp-solution-with-explanation",
                "content": "There are 2 steps in the solution:\\n1. Finding the route for each trip and after finishing all trips, we must have data of which node occurred how many times in all trips combined. Note that the graph has a tree structure, so we can be sure that there is a unique route for each trip. Let us call this data as `contrib` which is array of size `n` and stores contributions of each node to the trips (combined).\\n2. Finding the minimum price for all these trips keeping the halving rule in mind.\\n\\nStep 1 is pretty straightforward. For each trip, you just run DFS starting from source with appending current node in an array and if you meet the destination you have found the route.\\n\\nIn step 2, we run DFS again from node 0. Note that at any point during the DFS, if the parent node price was halved, then we have no choice but to return current node price without halving. But if the parent node price was not halved, we can either choose to halve or not halve the current node price and so we return the minimum of both choices. We maintain a 2-D array of size `(n,2)` to memoize results. Since, we are assuming node 0 has no parent and in the final answer price of node 0 may or may not be halved so we return `dfs(cur=0, par=-1, parHalved=false)`.\\n\\n```\\nvoid getContrib(vector<vector<int>>&G, vector<int>&contrib, vector<int>path, int cur, int dest, int par)\\n{\\n    path.push_back(cur);\\n    if (cur==dest)\\n    {\\n        for (int node: path) contrib[node]++;\\n        return;\\n    }\\n    for (int nbd: G[cur])\\n    {\\n        if (nbd==par) continue;\\n        getContrib(G, contrib, path, nbd, dest, cur);\\n    }\\n    path.pop_back();\\n}\\n\\nint dfs(vector<vector<int>>&G, vector<vector<int>>&memo, vector<int>&contrib, vector<int>& prices, int cur, int par, bool parHalved)\\n{\\n    if (memo[cur][parHalved]!=-1) return memo[cur][parHalved];\\n    int resCurNotHalved = prices[cur]*contrib[cur];\\n    for (int nbd: G[cur]) if(nbd!=par) \\n        resCurNotHalved += dfs(G, memo, contrib, prices, nbd, cur, false);\\n    if (parHalved) return memo[cur][true] = resCurNotHalved;\\n    int resCurHalved = prices[cur]*contrib[cur]/2;\\n    for (int nbd: G[cur]) if(nbd!=par)\\n        resCurHalved += dfs(G, memo, contrib, prices, nbd, cur, true);\\n    return memo[cur][false] = min(resCurNotHalved, resCurHalved);\\n}\\n\\nint minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) \\n{\\n    vector<vector<int>> G(n, vector<int>{});\\n    for (auto &edge: edges)\\n    {\\n        int u=edge[0], v=edge[1];\\n        G[u].push_back(v);\\n        G[v].push_back(u);\\n    }\\n    vector<int> contrib(n, 0);\\n    for (auto &trip: trips)\\n    {\\n        int src=trip[0], dest=trip[1];\\n        vector<int> path;\\n        getContrib(G, contrib, path, src, dest, -1);\\n    }\\n    vector<vector<int>> memo(n, vector<int>(2, -1));\\n    return dfs(G, memo, contrib, price, 0, -1, false);\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nvoid getContrib(vector<vector<int>>&G, vector<int>&contrib, vector<int>path, int cur, int dest, int par)\\n{\\n    path.push_back(cur);\\n    if (cur==dest)\\n    {\\n        for (int node: path) contrib[node]++;\\n        return;\\n    }\\n    for (int nbd: G[cur])\\n    {\\n        if (nbd==par) continue;\\n        getContrib(G, contrib, path, nbd, dest, cur);\\n    }\\n    path.pop_back();\\n}\\n\\nint dfs(vector<vector<int>>&G, vector<vector<int>>&memo, vector<int>&contrib, vector<int>& prices, int cur, int par, bool parHalved)\\n{\\n    if (memo[cur][parHalved]!=-1) return memo[cur][parHalved];\\n    int resCurNotHalved = prices[cur]*contrib[cur];\\n    for (int nbd: G[cur]) if(nbd!=par) \\n        resCurNotHalved += dfs(G, memo, contrib, prices, nbd, cur, false);\\n    if (parHalved) return memo[cur][true] = resCurNotHalved;\\n    int resCurHalved = prices[cur]*contrib[cur]/2;\\n    for (int nbd: G[cur]) if(nbd!=par)\\n        resCurHalved += dfs(G, memo, contrib, prices, nbd, cur, true);\\n    return memo[cur][false] = min(resCurNotHalved, resCurHalved);\\n}\\n\\nint minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) \\n{\\n    vector<vector<int>> G(n, vector<int>{});\\n    for (auto &edge: edges)\\n    {\\n        int u=edge[0], v=edge[1];\\n        G[u].push_back(v);\\n        G[v].push_back(u);\\n    }\\n    vector<int> contrib(n, 0);\\n    for (auto &trip: trips)\\n    {\\n        int src=trip[0], dest=trip[1];\\n        vector<int> path;\\n        getContrib(G, contrib, path, src, dest, -1);\\n    }\\n    vector<vector<int>> memo(n, vector<int>(2, -1));\\n    return dfs(G, memo, contrib, price, 0, -1, false);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3459827,
                "title": "c-solution-divide-it-into-two-problems",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cric(vector<bool> &ans,vector<vector<int>> &paths,int target,int curr){\\n        if(ans[curr]){\\n            vector<int> temp;\\n            return temp;\\n        }\\n        ans[curr] = true;\\n        if(curr == target){\\n            return vector<int> {target};\\n        }\\n        for(int i = 0;i<paths[curr].size();i++){\\n            vector<int> temp = cric(ans,paths,target,paths[curr][i]);\\n            if(temp.size() != 0){\\n                temp.push_back(curr);\\n                return temp;\\n            }\\n        }\\n        vector<int> temp;\\n        return temp;\\n    }\\n    int flow(vector<vector<int>> &paths,int curr,vector<vector<int>> &ans,bool ok,vector<int> &count){\\n        // cout<<curr<<endl;\\n        // for(int i = 0;i<ans.size();i++){\\n        //     cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\\n        // }\\n        // cout<<endl;\\n        if(ans[curr][0] == -2){\\n            return 0;\\n        }\\n        if(ans[curr][0] != -1){\\n            if(ok){\\n                return ans[curr][0];\\n            }\\n            return ans[curr][1];\\n        }\\n        ans[curr][0] = -2;\\n        int a = 0,b = 0;\\n        for(int i = 0;i<paths[curr].size();i++){\\n            a += flow(paths,paths[curr][i],ans,false,count);\\n            b += flow(paths,paths[curr][i],ans,true,count);\\n        }\\n        ans[curr][0] = a + (count[curr]/2);\\n        ans[curr][1] = b + count[curr];\\n        ans[curr][0] = min(ans[curr][0],ans[curr][1]);\\n        if(ok){\\n            return ans[curr][0];\\n        }\\n        return ans[curr][1];\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> paths(n);\\n        for(int i = 0;i<edges.size();i++){\\n            paths[edges[i][0]].push_back(edges[i][1]);\\n            paths[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> count(n,0);\\n        for(int i = 0;i<trips.size();i++){\\n            vector<bool> ans(n,false);\\n            vector<int> temp = cric(ans,paths,trips[i][1],trips[i][0]);\\n            for(int j = 0;j<temp.size();j++){\\n                count[temp[j]]++;\\n            }\\n        }\\n        for(int i = 0;i<n;i++){\\n            count[i] *= price[i];\\n        }\\n        // for(int i = 0;i<count.size();i++){\\n        //     cout<<count[i]<<\" \";\\n        // }\\n        // cout<<endl;\\n        vector<vector<int>> ans(n,vector<int> (2,-1));\\n        return flow(paths,0,ans,true,count);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cric(vector<bool> &ans,vector<vector<int>> &paths,int target,int curr){\\n        if(ans[curr]){\\n            vector<int> temp;\\n            return temp;\\n        }\\n        ans[curr] = true;\\n        if(curr == target){\\n            return vector<int> {target};\\n        }\\n        for(int i = 0;i<paths[curr].size();i++){\\n            vector<int> temp = cric(ans,paths,target,paths[curr][i]);\\n            if(temp.size() != 0){\\n                temp.push_back(curr);\\n                return temp;\\n            }\\n        }\\n        vector<int> temp;\\n        return temp;\\n    }\\n    int flow(vector<vector<int>> &paths,int curr,vector<vector<int>> &ans,bool ok,vector<int> &count){\\n        // cout<<curr<<endl;\\n        // for(int i = 0;i<ans.size();i++){\\n        //     cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\\n        // }\\n        // cout<<endl;\\n        if(ans[curr][0] == -2){\\n            return 0;\\n        }\\n        if(ans[curr][0] != -1){\\n            if(ok){\\n                return ans[curr][0];\\n            }\\n            return ans[curr][1];\\n        }\\n        ans[curr][0] = -2;\\n        int a = 0,b = 0;\\n        for(int i = 0;i<paths[curr].size();i++){\\n            a += flow(paths,paths[curr][i],ans,false,count);\\n            b += flow(paths,paths[curr][i],ans,true,count);\\n        }\\n        ans[curr][0] = a + (count[curr]/2);\\n        ans[curr][1] = b + count[curr];\\n        ans[curr][0] = min(ans[curr][0],ans[curr][1]);\\n        if(ok){\\n            return ans[curr][0];\\n        }\\n        return ans[curr][1];\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> paths(n);\\n        for(int i = 0;i<edges.size();i++){\\n            paths[edges[i][0]].push_back(edges[i][1]);\\n            paths[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> count(n,0);\\n        for(int i = 0;i<trips.size();i++){\\n            vector<bool> ans(n,false);\\n            vector<int> temp = cric(ans,paths,trips[i][1],trips[i][0]);\\n            for(int j = 0;j<temp.size();j++){\\n                count[temp[j]]++;\\n            }\\n        }\\n        for(int i = 0;i<n;i++){\\n            count[i] *= price[i];\\n        }\\n        // for(int i = 0;i<count.size();i++){\\n        //     cout<<count[i]<<\" \";\\n        // }\\n        // cout<<endl;\\n        vector<vector<int>> ans(n,vector<int> (2,-1));\\n        return flow(paths,0,ans,true,count);\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3458266,
                "title": "simple-java-dfs-impl",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        boolean adj[][] = new boolean[n][n];\\n        for (int[] e : edges) {\\n            adj[e[0]][e[1]] = true;\\n            adj[e[1]][e[0]] = true;\\n        }\\n        int cnt[] = new int[n];\\n        for (int[] t : trips) {\\n            find(n, adj, t[0], t[1], -1, cnt);\\n        }\\n        int[] res = dfs(n, adj, price, cnt, 0, -1);\\n        return Math.min(res[0], res[1]);\\n    }\\n\\n    boolean find(int n, boolean[][] adj, int u, int dst, int p, int[] cnt) {\\n        if (u == dst) {\\n            cnt[dst]++;\\n            return true;\\n        }\\n        for (int v = 0; v < n; v++) {\\n            if (adj[u][v] && v != p) {\\n                if (find(n, adj, v, dst, u, cnt)) {\\n                    cnt[u]++;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    // half & same price of node u\\n    int[] dfs(int n, boolean[][] adj, int[] price, int[] cnt, int u, int p) {\\n        int half = cnt[u] * price[u] / 2;\\n        int same = cnt[u] * price[u];\\n        for (int v = 0; v < n; v++) {\\n            if (adj[u][v] && v != p) {\\n                int[] res = dfs(n, adj, price, cnt, v, u);\\n                half += res[1];\\n                same += Math.min(res[0], res[1]);\\n            }\\n        }\\n        return new int[] { half, same };\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        boolean adj[][] = new boolean[n][n];\\n        for (int[] e : edges) {\\n            adj[e[0]][e[1]] = true;\\n            adj[e[1]][e[0]] = true;\\n        }\\n        int cnt[] = new int[n];\\n        for (int[] t : trips) {\\n            find(n, adj, t[0], t[1], -1, cnt);\\n        }\\n        int[] res = dfs(n, adj, price, cnt, 0, -1);\\n        return Math.min(res[0], res[1]);\\n    }\\n\\n    boolean find(int n, boolean[][] adj, int u, int dst, int p, int[] cnt) {\\n        if (u == dst) {\\n            cnt[dst]++;\\n            return true;\\n        }\\n        for (int v = 0; v < n; v++) {\\n            if (adj[u][v] && v != p) {\\n                if (find(n, adj, v, dst, u, cnt)) {\\n                    cnt[u]++;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    // half & same price of node u\\n    int[] dfs(int n, boolean[][] adj, int[] price, int[] cnt, int u, int p) {\\n        int half = cnt[u] * price[u] / 2;\\n        int same = cnt[u] * price[u];\\n        for (int v = 0; v < n; v++) {\\n            if (adj[u][v] && v != p) {\\n                int[] res = dfs(n, adj, price, cnt, v, u);\\n                half += res[1];\\n                same += Math.min(res[0], res[1]);\\n            }\\n        }\\n        return new int[] { half, same };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444464,
                "title": "c-clean-code-easy-to-understand-dfs-dp-new-approach",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nClean Code - self Explanatory\\n# Complexity\\n- Time complexity: O(n*t)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(int dest, vector<int> &path, int par, int curr, vector<vector<int>> &tree) {\\n        \\n        path.push_back(curr);\\n        \\n        if(curr == dest)\\n            return 1;\\n        \\n        for(auto child: tree[curr]) {\\n            \\n            if(child == par)\\n                continue;\\n            \\n            if(dfs(dest, path, curr, child, tree))\\n                return 1;\\n            \\n        }\\n        \\n        path.pop_back();\\n        return 0;\\n    }\\n    \\n    pair<int,int> dfs2(vector<vector<int>> &tree, int curr, vector<int> &price, int par, vector<pair<int,int>> &dp) {\\n        \\n        int fullSum = 0;\\n        int minSum = 0;\\n        \\n        for(auto child: tree[curr]) {\\n            if(child == par)\\n                continue;\\n            \\n            pair<int,int> childValue = dfs2(tree, child, price, curr, dp);\\n            \\n            minSum += min(childValue.first, childValue.second);\\n            fullSum += childValue.second;\\n        \\n        }\\n        \\n        dp[curr].first = price[curr]/2 + fullSum;\\n        dp[curr].second = price[curr] + minSum;\\n        \\n        return dp[curr];\\n        \\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        \\n        vector<vector<int>> tree(n);\\n        \\n        for(auto c: edges)\\n        {\\n            tree[c[0]].push_back(c[1]);\\n            tree[c[1]].push_back(c[0]);\\n        }\\n        \\n        vector<int> times(n, 0);\\n        \\n        for(auto s: trips)\\n        {\\n            int source = s[0];\\n            int dest = s[1];\\n            \\n            vector<int> path;\\n            dfs(s[1], path, -1, s[0], tree);\\n            \\n            for(auto c: path)\\n                times[c]++;\\n            \\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n            price[i] *= times[i];\\n        \\n        vector<pair<int,int>> dp(n, {0,0});\\n        \\n        dfs2(tree, 0, price, -1, dp);\\n        \\n        return min(dp[0].first, dp[0].second);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(int dest, vector<int> &path, int par, int curr, vector<vector<int>> &tree) {\\n        \\n        path.push_back(curr);\\n        \\n        if(curr == dest)\\n            return 1;\\n        \\n        for(auto child: tree[curr]) {\\n            \\n            if(child == par)\\n                continue;\\n            \\n            if(dfs(dest, path, curr, child, tree))\\n                return 1;\\n            \\n        }\\n        \\n        path.pop_back();\\n        return 0;\\n    }\\n    \\n    pair<int,int> dfs2(vector<vector<int>> &tree, int curr, vector<int> &price, int par, vector<pair<int,int>> &dp) {\\n        \\n        int fullSum = 0;\\n        int minSum = 0;\\n        \\n        for(auto child: tree[curr]) {\\n            if(child == par)\\n                continue;\\n            \\n            pair<int,int> childValue = dfs2(tree, child, price, curr, dp);\\n            \\n            minSum += min(childValue.first, childValue.second);\\n            fullSum += childValue.second;\\n        \\n        }\\n        \\n        dp[curr].first = price[curr]/2 + fullSum;\\n        dp[curr].second = price[curr] + minSum;\\n        \\n        return dp[curr];\\n        \\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        \\n        vector<vector<int>> tree(n);\\n        \\n        for(auto c: edges)\\n        {\\n            tree[c[0]].push_back(c[1]);\\n            tree[c[1]].push_back(c[0]);\\n        }\\n        \\n        vector<int> times(n, 0);\\n        \\n        for(auto s: trips)\\n        {\\n            int source = s[0];\\n            int dest = s[1];\\n            \\n            vector<int> path;\\n            dfs(s[1], path, -1, s[0], tree);\\n            \\n            for(auto c: path)\\n                times[c]++;\\n            \\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n            price[i] *= times[i];\\n        \\n        vector<pair<int,int>> dp(n, {0,0});\\n        \\n        dfs2(tree, 0, price, -1, dp);\\n        \\n        return min(dp[0].first, dp[0].second);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438772,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(int node,int par,vector<int>&cur,vector<vector<int>>&adj,vector<int>&contri,int & target)\\n    {\\n        cur.push_back(node);\\n        if (target==node)\\n        {\\n            for (auto it: cur) contri[it]++;\\n            cur.pop_back();\\n            return;\\n        }\\n        for (auto it:adj[node])\\n        {\\n            if (par!=it)\\n            {\\n                dfs(it,node,cur,adj,contri,target);\\n            }\\n        }\\n        cur.pop_back();\\n    }\\n    int rec(int node,int par,vector<int>&contri,vector<int>&price,vector<vector<int>>&adj,int take,vector<vector<int>>&dp)\\n    {\\n       if (dp[node][take]!=-1) return dp[node][take];\\n       int price1=contri[node]*price[node];\\n       int price2=contri[node]*(price[node]/2);\\n       for (auto it:adj[node])\\n       {\\n           if (it!=par)\\n           {\\n               price1+=rec(it,node,contri,price,adj,1,dp);\\n           }\\n       }\\n       if (take==0) return dp[node][take]=price1;\\n       for (auto it:adj[node])\\n       {\\n           if (it!=par)\\n           {\\n               price2+=rec(it,node,contri,price,adj,0,dp);\\n           }\\n       }\\n       return dp[node][take]=min(price1,price2);\\n    }\\n        \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) \\n    {\\n        int ans=0;\\n        vector<vector<int>>adj(n);\\n        vector<vector<int>>dp(51,vector<int>(2,-1));\\n        for (int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n             adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>contri(n,0);\\n        vector<int>cur;\\n       for (auto it:trips)\\n       {\\n           dfs(it[0],-1,cur,adj,contri,it[1]);\\n       }\\n       return rec(0,-1,contri,price,adj,1,dp);\\n        \\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(int node,int par,vector<int>&cur,vector<vector<int>>&adj,vector<int>&contri,int & target)\\n    {\\n        cur.push_back(node);\\n        if (target==node)\\n        {\\n            for (auto it: cur) contri[it]++;\\n            cur.pop_back();\\n            return;\\n        }\\n        for (auto it:adj[node])\\n        {\\n            if (par!=it)\\n            {\\n                dfs(it,node,cur,adj,contri,target);\\n            }\\n        }\\n        cur.pop_back();\\n    }\\n    int rec(int node,int par,vector<int>&contri,vector<int>&price,vector<vector<int>>&adj,int take,vector<vector<int>>&dp)\\n    {\\n       if (dp[node][take]!=-1) return dp[node][take];\\n       int price1=contri[node]*price[node];\\n       int price2=contri[node]*(price[node]/2);\\n       for (auto it:adj[node])\\n       {\\n           if (it!=par)\\n           {\\n               price1+=rec(it,node,contri,price,adj,1,dp);\\n           }\\n       }\\n       if (take==0) return dp[node][take]=price1;\\n       for (auto it:adj[node])\\n       {\\n           if (it!=par)\\n           {\\n               price2+=rec(it,node,contri,price,adj,0,dp);\\n           }\\n       }\\n       return dp[node][take]=min(price1,price2);\\n    }\\n        \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) \\n    {\\n        int ans=0;\\n        vector<vector<int>>adj(n);\\n        vector<vector<int>>dp(51,vector<int>(2,-1));\\n        for (int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n             adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>contri(n,0);\\n        vector<int>cur;\\n       for (auto it:trips)\\n       {\\n           dfs(it[0],-1,cur,adj,contri,it[1]);\\n       }\\n       return rec(0,-1,contri,price,adj,1,dp);\\n        \\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432861,
                "title": "dfc-top-down-dp-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConstruct an adjacency list:\\nConstruct an adjacency list to represent the graph. This will make it easy to traverse the graph and perform operations on each node.\\n\\nPerform DFS to record frequency of passes:\\nFor each trip, perform a Depth-First Search (DFS) on the graph to record the frequency of times each node is passed. Since the graph is a tree, it will not have cycles, and there will be only one path from Node A to Node B.\\n\\nChoose a starting node and use Dynamic Programming:\\nChoose an arbitrary starting node and perform Dynamic Programming (DP) to find the smallest possible sum. For each node in the graph, there are only two possible options: either halve it or not. Therefore, the problem can be reduced to finding the optimal solution for each subproblem, which can be done using DP.\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> adjList;\\n    int dp[51][2];\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        for(auto e:edges){\\n            adjList[e[0]].push_back(e[1]);\\n            adjList[e[1]].push_back(e[0]);\\n        }\\n        vector<int> freq(n, 0);\\n        \\n\\n        for(auto trip:trips){\\n            vector<int> curr;\\n            freqDFS(freq, curr, -1, trip[0], trip[1]);\\n        }\\n        \\n        memset(dp, -1, sizeof(dp));\\n        return DFS(price, freq, -1, 0, 0);\\n    }\\n\\n    int DFS(vector<int>& prices, vector<int>& freq, int parent, int curr, int parentHalved){\\n        int ret1 = freq[curr]*prices[curr]/2, ret2 =freq[curr]*prices[curr];\\n        if(dp[curr][parentHalved]!=-1)\\n            return dp[curr][parentHalved];\\n\\n        for(auto nxt:adjList[curr]){\\n            if(nxt==parent){\\n                continue;\\n            }\\n            ret2+= DFS(prices, freq, curr, nxt, 0);\\n        }\\n        if(parentHalved){\\n            return dp[curr][parentHalved] = ret2;\\n        }\\n\\n        for(auto nxt:adjList[curr]){\\n            if(nxt==parent){\\n                continue;\\n            }\\n            ret1+=DFS(prices, freq, curr, nxt, 1);\\n        }\\n\\n        return dp[curr][parentHalved] = min(ret1, ret2);\\n\\n        \\n\\n\\n    }\\n\\n\\n    void freqDFS(vector<int>& freq, vector<int>& curr, int parent, int src, int dst){\\n        //basecase\\n        curr.push_back(src);\\n        if(src==dst){\\n            for(auto& iter:curr){\\n                freq[iter]++;\\n            }      \\n            return;\\n        }\\n\\n        for(auto& nxt:adjList[src]){\\n            if(nxt==parent){\\n                continue;\\n            }\\n            freqDFS(freq, curr, src, nxt, dst);\\n        }\\n        curr.pop_back();\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> adjList;\\n    int dp[51][2];\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        for(auto e:edges){\\n            adjList[e[0]].push_back(e[1]);\\n            adjList[e[1]].push_back(e[0]);\\n        }\\n        vector<int> freq(n, 0);\\n        \\n\\n        for(auto trip:trips){\\n            vector<int> curr;\\n            freqDFS(freq, curr, -1, trip[0], trip[1]);\\n        }\\n        \\n        memset(dp, -1, sizeof(dp));\\n        return DFS(price, freq, -1, 0, 0);\\n    }\\n\\n    int DFS(vector<int>& prices, vector<int>& freq, int parent, int curr, int parentHalved){\\n        int ret1 = freq[curr]*prices[curr]/2, ret2 =freq[curr]*prices[curr];\\n        if(dp[curr][parentHalved]!=-1)\\n            return dp[curr][parentHalved];\\n\\n        for(auto nxt:adjList[curr]){\\n            if(nxt==parent){\\n                continue;\\n            }\\n            ret2+= DFS(prices, freq, curr, nxt, 0);\\n        }\\n        if(parentHalved){\\n            return dp[curr][parentHalved] = ret2;\\n        }\\n\\n        for(auto nxt:adjList[curr]){\\n            if(nxt==parent){\\n                continue;\\n            }\\n            ret1+=DFS(prices, freq, curr, nxt, 1);\\n        }\\n\\n        return dp[curr][parentHalved] = min(ret1, ret2);\\n\\n        \\n\\n\\n    }\\n\\n\\n    void freqDFS(vector<int>& freq, vector<int>& curr, int parent, int src, int dst){\\n        //basecase\\n        curr.push_back(src);\\n        if(src==dst){\\n            for(auto& iter:curr){\\n                freq[iter]++;\\n            }      \\n            return;\\n        }\\n\\n        for(auto& nxt:adjList[src]){\\n            if(nxt==parent){\\n                continue;\\n            }\\n            freqDFS(freq, curr, src, nxt, dst);\\n        }\\n        curr.pop_back();\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432789,
                "title": "iterative-stack-dp-with-comments",
                "content": "# Intuition\\nIt looked like House Robber problems family, so we need to find a way to build dp\\n\\n# Approach\\n1. First traverse all trips to know possible inputs of each node into final cost\\n2. Don\\'t forget to consider odd cases of disconnected subgraphs or disconnected nodes and trips with same start and end\\n3. Selected any node as root and traverse tree with stack. \\n- If node with children met for the first time, leave the node on stack and put children of stack. \\n- If node with children met for the second time or node doesn\\'t have children - calculate dp for it, since children are already processed\\n4. For each node we have 2 dp values:\\n- if node is *not taken* into discount (full price, dp[i][0]), then we are free to select min value from child *both cases* - when child is taken into discount and when it\\'s not   \\n- if node is *taken* into discount (half price, dp[i][1]), then we can only use child value for child *non-taken* case\\n\\n\\n# Complexity\\n- Time complexity:\\nO(Max(edges, trips))\\n\\n# Code\\n```\\nfunction minimumTotalPrice(n: number, edges: number[][], prices: number[], trips: number[][]): number {\\n  const graph = new Map<number, number[]>();\\n  \\n  // consider disconnected nodes\\n  for (let i = 0; i < n; i++) {\\n    graph.set(i, []);\\n  }\\n\\n  for (let [start, end] of edges) {\\n    graph.get(start).push(end);\\n    graph.get(end).push(start);\\n  }\\n\\n  const stops = Array(n).fill(0)\\n  for (let i = 0; i < trips.length; i++) {\\n    const [start, end] = trips[i];\\n    const path = start === end ? [start] : traverse(start, end, graph);\\n    for (let stop of path) {\\n      stops[stop]++;\\n    }\\n  }\\n\\n  const dp = Array.from({ length: n }, () => Array(2).fill(0));\\n  const visited = new Set<number>();\\n  \\n  let res = 0;\\n  // consider disconnected graph - try to start from each non-visited node\\n  for(let i=0; i<n; i++) {\\n    if (!visited.has(i)) {\\n      const stack: [number, number][] = [[i, Number.MAX_VALUE]];\\n      while(stack.length > 0) {\\n        const [curr, parent] = stack[stack.length - 1]; // peek\\n        const connections = graph.get(curr);\\n        \\n        // not visited yet and has connection other then parent (leaf node)\\n        if (!visited.has(curr) && (connections.length > 1 || connections[0] !== parent)) {\\n          for(let connection of connections) {\\n            if (connection !== parent) {\\n              stack.push([connection, curr]);\\n            }\\n          }\\n        } else {\\n          // remove from stack once visited for the second time or is leaf\\n          stack.pop();\\n          \\n          let noTake = 0; // children cost if node is not taken into discount\\n          let take = 0; // chilren cost if node is taken into discount\\n          \\n          for(let connection of connections) {\\n            take += dp[connection][0]; // only non-taken child case    \\n            noTake += Math.min(dp[connection][0], dp[connection][1]); \\n          }\\n\\n          dp[curr][0] = prices[curr] * stops[curr] + noTake;\\n          dp[curr][1] = prices[curr] * stops[curr] / 2 + take;\\n        }\\n\\n        visited.add(curr);\\n       }\\n\\n      res += Math.min(dp[i][0], dp[i][1]);\\n    }\\n  }\\n\\n  return res;\\n}\\n\\nfunction traverse(start: number, end: number, graph: Map<number, number[]>): number[] {\\n  let queue: [number, number[]][] = [[start, [start]]];\\n\\n  const visited = new Set<number>();\\n\\n  while (queue.length > 0) {\\n    const [curr, currPath] = queue.shift();\\n    visited.add(curr);\\n\\n    if (curr === end) {\\n      return currPath;\\n    }\\n\\n    for (let node of graph.get(curr)) {\\n      if (!visited.has(node)) {\\n        queue.push([node, [...currPath, node]]);\\n      }\\n    }\\n  }\\n\\n  throw Error(\\'Invalid graph\\');\\n}\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nfunction minimumTotalPrice(n: number, edges: number[][], prices: number[], trips: number[][]): number {\\n  const graph = new Map<number, number[]>();\\n  \\n  // consider disconnected nodes\\n  for (let i = 0; i < n; i++) {\\n    graph.set(i, []);\\n  }\\n\\n  for (let [start, end] of edges) {\\n    graph.get(start).push(end);\\n    graph.get(end).push(start);\\n  }\\n\\n  const stops = Array(n).fill(0)\\n  for (let i = 0; i < trips.length; i++) {\\n    const [start, end] = trips[i];\\n    const path = start === end ? [start] : traverse(start, end, graph);\\n    for (let stop of path) {\\n      stops[stop]++;\\n    }\\n  }\\n\\n  const dp = Array.from({ length: n }, () => Array(2).fill(0));\\n  const visited = new Set<number>();\\n  \\n  let res = 0;\\n  // consider disconnected graph - try to start from each non-visited node\\n  for(let i=0; i<n; i++) {\\n    if (!visited.has(i)) {\\n      const stack: [number, number][] = [[i, Number.MAX_VALUE]];\\n      while(stack.length > 0) {\\n        const [curr, parent] = stack[stack.length - 1]; // peek\\n        const connections = graph.get(curr);\\n        \\n        // not visited yet and has connection other then parent (leaf node)\\n        if (!visited.has(curr) && (connections.length > 1 || connections[0] !== parent)) {\\n          for(let connection of connections) {\\n            if (connection !== parent) {\\n              stack.push([connection, curr]);\\n            }\\n          }\\n        } else {\\n          // remove from stack once visited for the second time or is leaf\\n          stack.pop();\\n          \\n          let noTake = 0; // children cost if node is not taken into discount\\n          let take = 0; // chilren cost if node is taken into discount\\n          \\n          for(let connection of connections) {\\n            take += dp[connection][0]; // only non-taken child case    \\n            noTake += Math.min(dp[connection][0], dp[connection][1]); \\n          }\\n\\n          dp[curr][0] = prices[curr] * stops[curr] + noTake;\\n          dp[curr][1] = prices[curr] * stops[curr] / 2 + take;\\n        }\\n\\n        visited.add(curr);\\n       }\\n\\n      res += Math.min(dp[i][0], dp[i][1]);\\n    }\\n  }\\n\\n  return res;\\n}\\n\\nfunction traverse(start: number, end: number, graph: Map<number, number[]>): number[] {\\n  let queue: [number, number[]][] = [[start, [start]]];\\n\\n  const visited = new Set<number>();\\n\\n  while (queue.length > 0) {\\n    const [curr, currPath] = queue.shift();\\n    visited.add(curr);\\n\\n    if (curr === end) {\\n      return currPath;\\n    }\\n\\n    for (let node of graph.get(curr)) {\\n      if (!visited.has(node)) {\\n        queue.push([node, [...currPath, node]]);\\n      }\\n    }\\n  }\\n\\n  throw Error(\\'Invalid graph\\');\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3432750,
                "title": "get-node-visit-count-and-run-a-dp-on-the-tree",
                "content": "# Code\\n```\\ndef minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n    neigh = [[] for _ in range(n)]\\n    for a, b in edges:\\n        neigh[a].append(b)\\n        neigh[b].append(a)\\n    \\n    visitCount = [0] * n\\n    def dfs(parent, node, target):\\n        visitCount[node] += 1\\n        if node == target:\\n            return True # reached target\\n        for v in neigh[node]:\\n            if v == parent:\\n                continue\\n            if dfs(node, v, target):\\n                return True\\n        visitCount[node] -= 1\\n\\n    for a, b in trips:\\n        dfs(-1, a, b)\\n    \\n    @cache\\n    def dp(parent: int, node: int, parentHalved: int) -> int:\\n        ret = 0\\n        if parentHalved:\\n            ret = price[node] * visitCount[node]\\n            for v in neigh[node]:\\n                if v == parent:\\n                    continue\\n                ret += dp(node, v, False)\\n            return ret\\n        else: # parent not halved, we have two options\\n            a = price[node] * visitCount[node]  # not halving it\\n            b = price[node] * visitCount[node] // 2  # halving it\\n            for v in neigh[node]:\\n                if v == parent:\\n                    continue\\n                a += dp(node, v, False)\\n                b += dp(node, v, True)\\n            return min(a, b)\\n\\n    return dp(-1, 0, False)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n    neigh = [[] for _ in range(n)]\\n    for a, b in edges:\\n        neigh[a].append(b)\\n        neigh[b].append(a)\\n    \\n    visitCount = [0] * n\\n    def dfs(parent, node, target):\\n        visitCount[node] += 1\\n        if node == target:\\n            return True # reached target\\n        for v in neigh[node]:\\n            if v == parent:\\n                continue\\n            if dfs(node, v, target):\\n                return True\\n        visitCount[node] -= 1\\n\\n    for a, b in trips:\\n        dfs(-1, a, b)\\n    \\n    @cache\\n    def dp(parent: int, node: int, parentHalved: int) -> int:\\n        ret = 0\\n        if parentHalved:\\n            ret = price[node] * visitCount[node]\\n            for v in neigh[node]:\\n                if v == parent:\\n                    continue\\n                ret += dp(node, v, False)\\n            return ret\\n        else: # parent not halved, we have two options\\n            a = price[node] * visitCount[node]  # not halving it\\n            b = price[node] * visitCount[node] // 2  # halving it\\n            for v in neigh[node]:\\n                if v == parent:\\n                    continue\\n                a += dp(node, v, False)\\n                b += dp(node, v, True)\\n            return min(a, b)\\n\\n    return dp(-1, 0, False)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3432255,
                "title": "java-bfs-dfs-memo-solution-with-thinking-progress",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem provides an unrooted tree and 2D integer array trips, ask for the minimun total price to perform all trips.\\nSince it is unrooted tree, we could first count all the nodes the trip will use and then arrange the price without caring the path.\\nThe tricky part is we only care about the nodes int the trips, but we could iterate the whole tree and for the nodes not in the path we just add zero.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Build the graph and use BFS to calculate the nodes in the path.\\n    ```\\n    public Map<Integer, Set<Integer>> buildMap(int[][] edges){\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for(int[] edge: edges){\\n            map.putIfAbsent(edge[0], new HashSet<>());\\n            map.putIfAbsent(edge[1], new HashSet<>());\\n            map.get(edge[0]).add(edge[1]);\\n            map.get(edge[1]).add(edge[0]);\\n        }\\n        return map;\\n    }\\n\\n    public int[] getNodeCounts(int n, Map<Integer, Set<Integer>> map, int[][] trips){\\n        int[] res = new int[n];\\n        for(int[] trip: trips){\\n            bfs(n, map, trip[0], trip[1], res);\\n        }\\n        return res;\\n    }\\n    //We use parent array to track the path.\\n    //Once get the end, we add all the path to counts array.\\n    public void bfs(int n, Map<Integer, Set<Integer>> map, int start, int end, int[] counts){\\n        counts[start]++;\\n        if(end == start){\\n            return;\\n        }\\n        int[] parent = new int[n];\\n        Deque<Integer> queue = new ArrayDeque<>();\\n        Set<Integer> visited = new HashSet<>();\\n        queue.offer(start);\\n        visited.add(start);\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i = 0; i < size; ++i){\\n                int current = queue.poll();\\n                if(current == end){\\n                    while(current != start){\\n                        counts[current]++;\\n                        current = parent[current];\\n                    }\\n                    return;\\n                }\\n                for(int child: map.get(current)){\\n                    if(!visited.add(child)) continue;\\n                    parent[child] = current;\\n                    queue.offer(child);\\n                }\\n            }\\n        }\\n    }\\n    ```\\n2. Use dfs to iterate the whole tree and calculate the sum, as we discuss before, the sum will not be affected even we traverse the whole tree. There are two state for each node, if the previous node is halved, the current node can not be halved, or it could be halved or unhalved, we compare the halfCurrent notHalfCurrent and return the minimum one.\\n    ```\\n    public int dfs(Map<Integer, Set<Integer>> map, int current, boolean[] visited, int[] counts, int[] price, boolean parentHalf){\\n        visited[current] = true;\\n        int halfCurrentSum = 0, notHalfCurrentSum = 0, val = counts[current] * price[current], halfVal = val / 2;\\n        for(int next: map.get(current)){\\n            if(visited[next]) continue;\\n            if(parentHalf){\\n                int v = dfs(map, next, visited, counts, price, false);\\n                halfCurrentSum += v;\\n                notHalfCurrentSum += v;\\n            }else{\\n                halfCurrentSum += dfs(map, next, visited, counts, price, true);\\n                notHalfCurrentSum += dfs(map, next, visited, counts, price, false);\\n            }\\n        }\\n        visited[current] = false;\\n        return parentHalf ? (notHalfCurrentSum + val) : Math.min(halfCurrentSum + halfVal, notHalfCurrentSum + val);\\n    }\\n    ```\\n3. We get TLE with regular dfs, we find we calculate the same state many times, so we try to memo the result we calculated before. \\n    ```\\n    public int dfsWithMemo(Map<Integer, Set<Integer>> map, int current, boolean[] visited, int[] counts, int[] price, boolean parentHalf, Integer[][] memo){\\n        if(parentHalf && memo[current][0] != null){\\n            return memo[current][0];\\n        }else if(!parentHalf && memo[current][1] != null){\\n            return memo[current][1];\\n        }\\n        visited[current] = true;\\n        int halfCurrentSum = 0, notHalfCurrentSum = 0, val = counts[current] * price[current], halfVal = val / 2;\\n        for(int next: map.get(current)){\\n            if(visited[next]) continue;\\n            if(parentHalf){\\n                int v = dfsWithMemo(map, next, visited, counts, price, false, memo);\\n                halfCurrentSum += v;\\n                notHalfCurrentSum += v;\\n            }else{\\n                halfCurrentSum += dfsWithMemo(map, next, visited, counts, price, true, memo);\\n                notHalfCurrentSum += dfsWithMemo(map, next, visited, counts, price, false, memo);\\n            }\\n        }\\n        visited[current] = false;\\n        int res = parentHalf ? (notHalfCurrentSum + val) : Math.min(halfCurrentSum + halfVal, notHalfCurrentSum + val);\\n        int state = parentHalf ? 0 : 1;\\n        memo[current][state] = res;\\n        return res;\\n    }\\n    ```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n $$O(V + E) * tripSize$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g.  -->\\n$$O(V)$$\\n# Code\\nA edge case is that there is only one point and no edge, if n is one we should return price[0]/2.\\n```\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        // [0,1,3,2,1,2,1,3]\\n        // price[0] + 3 * price[1] + 2 * price[2] + price[3];\\n        if(n == 1) return price[0] / 2;\\n        Map<Integer, Set<Integer>> map = buildMap(edges);\\n        int[] counts = getNodeCounts(n, map, trips);\\n        return dfsWithMemo(map, 0, new boolean[n], counts, price, false, new Integer[n][2]);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Memoization"
                ],
                "code": "```\\n    public Map<Integer, Set<Integer>> buildMap(int[][] edges){\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for(int[] edge: edges){\\n            map.putIfAbsent(edge[0], new HashSet<>());\\n            map.putIfAbsent(edge[1], new HashSet<>());\\n            map.get(edge[0]).add(edge[1]);\\n            map.get(edge[1]).add(edge[0]);\\n        }\\n        return map;\\n    }\\n\\n    public int[] getNodeCounts(int n, Map<Integer, Set<Integer>> map, int[][] trips){\\n        int[] res = new int[n];\\n        for(int[] trip: trips){\\n            bfs(n, map, trip[0], trip[1], res);\\n        }\\n        return res;\\n    }\\n    //We use parent array to track the path.\\n    //Once get the end, we add all the path to counts array.\\n    public void bfs(int n, Map<Integer, Set<Integer>> map, int start, int end, int[] counts){\\n        counts[start]++;\\n        if(end == start){\\n            return;\\n        }\\n        int[] parent = new int[n];\\n        Deque<Integer> queue = new ArrayDeque<>();\\n        Set<Integer> visited = new HashSet<>();\\n        queue.offer(start);\\n        visited.add(start);\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i = 0; i < size; ++i){\\n                int current = queue.poll();\\n                if(current == end){\\n                    while(current != start){\\n                        counts[current]++;\\n                        current = parent[current];\\n                    }\\n                    return;\\n                }\\n                for(int child: map.get(current)){\\n                    if(!visited.add(child)) continue;\\n                    parent[child] = current;\\n                    queue.offer(child);\\n                }\\n            }\\n        }\\n    }\\n    ```\n```\\n    public int dfs(Map<Integer, Set<Integer>> map, int current, boolean[] visited, int[] counts, int[] price, boolean parentHalf){\\n        visited[current] = true;\\n        int halfCurrentSum = 0, notHalfCurrentSum = 0, val = counts[current] * price[current], halfVal = val / 2;\\n        for(int next: map.get(current)){\\n            if(visited[next]) continue;\\n            if(parentHalf){\\n                int v = dfs(map, next, visited, counts, price, false);\\n                halfCurrentSum += v;\\n                notHalfCurrentSum += v;\\n            }else{\\n                halfCurrentSum += dfs(map, next, visited, counts, price, true);\\n                notHalfCurrentSum += dfs(map, next, visited, counts, price, false);\\n            }\\n        }\\n        visited[current] = false;\\n        return parentHalf ? (notHalfCurrentSum + val) : Math.min(halfCurrentSum + halfVal, notHalfCurrentSum + val);\\n    }\\n    ```\n```\\n    public int dfsWithMemo(Map<Integer, Set<Integer>> map, int current, boolean[] visited, int[] counts, int[] price, boolean parentHalf, Integer[][] memo){\\n        if(parentHalf && memo[current][0] != null){\\n            return memo[current][0];\\n        }else if(!parentHalf && memo[current][1] != null){\\n            return memo[current][1];\\n        }\\n        visited[current] = true;\\n        int halfCurrentSum = 0, notHalfCurrentSum = 0, val = counts[current] * price[current], halfVal = val / 2;\\n        for(int next: map.get(current)){\\n            if(visited[next]) continue;\\n            if(parentHalf){\\n                int v = dfsWithMemo(map, next, visited, counts, price, false, memo);\\n                halfCurrentSum += v;\\n                notHalfCurrentSum += v;\\n            }else{\\n                halfCurrentSum += dfsWithMemo(map, next, visited, counts, price, true, memo);\\n                notHalfCurrentSum += dfsWithMemo(map, next, visited, counts, price, false, memo);\\n            }\\n        }\\n        visited[current] = false;\\n        int res = parentHalf ? (notHalfCurrentSum + val) : Math.min(halfCurrentSum + halfVal, notHalfCurrentSum + val);\\n        int state = parentHalf ? 0 : 1;\\n        memo[current][state] = res;\\n        return res;\\n    }\\n    ```\n```\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        // [0,1,3,2,1,2,1,3]\\n        // price[0] + 3 * price[1] + 2 * price[2] + price[3];\\n        if(n == 1) return price[0] / 2;\\n        Map<Integer, Set<Integer>> map = buildMap(edges);\\n        int[] counts = getNodeCounts(n, map, trips);\\n        return dfsWithMemo(map, 0, new boolean[n], counts, price, false, new Integer[n][2]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3431921,
                "title": "c-dfs-memoization-recursion-backtracking",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[51][2];\\n    void dfs(int st,int en,vector<vector<int>>& adj,vector<int> tmp,int parent,vector<int> &fre)\\n    {\\n        tmp[st]++;\\n        if(st==en)\\n        {\\n            for(int i=0;i<tmp.size();i++)\\n            {\\n                fre[i]+=tmp[i];\\n            }\\n            return;\\n        }\\n        for(auto &i:adj[st])\\n        {\\n            if(i!=parent)\\n            {\\n                dfs(i,en,adj,tmp,st,fre);\\n            }\\n        }\\n    }\\n    int dfs1(int x,vector<vector<int>>& adj,vector<int>& fre,vector<int>& price,int parent,int canHalf)\\n    {\\n        if(dp[x][canHalf]!=-1)\\n        return dp[x][canHalf];\\n        int ans = INT_MAX;\\n        if(canHalf)\\n        {\\n            int tak1 = (fre[x]*price[x])/2,tak2 = fre[x]*price[x];\\n            for(auto &i:adj[x])\\n            {\\n                if(i!=parent)\\n                {\\n                    tak1+=dfs1(i,adj,fre,price,x,0);\\n                    tak2+=dfs1(i,adj,fre,price,x,canHalf);\\n                }\\n            }\\n            ans = min(tak1,tak2);\\n            return dp[x][canHalf] = ans;\\n        }\\n        else\\n        {\\n            int tak1 = fre[x]*price[x];\\n            for(auto &i:adj[x])\\n            {\\n                if(i!=parent)\\n                {\\n                    tak1+=dfs1(i,adj,fre,price,x,1);\\n                }\\n            }\\n            return dp[x][canHalf] = tak1;\\n        }\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        memset(dp,-1,sizeof(dp));\\n        vector<int> fre(n,0);\\n        vector<vector<int>> adj(n);\\n        for(auto &i:edges)\\n        {\\n            int a = i[0];\\n            int b = i[1];\\n            adj[a].push_back(b);\\n            adj[b].push_back(a);\\n        }\\n        for(int i=0;i<trips.size();i++)\\n        {\\n            int st = trips[i][0];\\n            int en = trips[i][1];\\n            vector<int> tmp(n);\\n            dfs(st,en,adj,tmp,-1,fre);\\n        }\\n        \\n        return dfs1(0,adj,fre,price,-1,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[51][2];\\n    void dfs(int st,int en,vector<vector<int>>& adj,vector<int> tmp,int parent,vector<int> &fre)\\n    {\\n        tmp[st]++;\\n        if(st==en)\\n        {\\n            for(int i=0;i<tmp.size();i++)\\n            {\\n                fre[i]+=tmp[i];\\n            }\\n            return;\\n        }\\n        for(auto &i:adj[st])\\n        {\\n            if(i!=parent)\\n            {\\n                dfs(i,en,adj,tmp,st,fre);\\n            }\\n        }\\n    }\\n    int dfs1(int x,vector<vector<int>>& adj,vector<int>& fre,vector<int>& price,int parent,int canHalf)\\n    {\\n        if(dp[x][canHalf]!=-1)\\n        return dp[x][canHalf];\\n        int ans = INT_MAX;\\n        if(canHalf)\\n        {\\n            int tak1 = (fre[x]*price[x])/2,tak2 = fre[x]*price[x];\\n            for(auto &i:adj[x])\\n            {\\n                if(i!=parent)\\n                {\\n                    tak1+=dfs1(i,adj,fre,price,x,0);\\n                    tak2+=dfs1(i,adj,fre,price,x,canHalf);\\n                }\\n            }\\n            ans = min(tak1,tak2);\\n            return dp[x][canHalf] = ans;\\n        }\\n        else\\n        {\\n            int tak1 = fre[x]*price[x];\\n            for(auto &i:adj[x])\\n            {\\n                if(i!=parent)\\n                {\\n                    tak1+=dfs1(i,adj,fre,price,x,1);\\n                }\\n            }\\n            return dp[x][canHalf] = tak1;\\n        }\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        memset(dp,-1,sizeof(dp));\\n        vector<int> fre(n,0);\\n        vector<vector<int>> adj(n);\\n        for(auto &i:edges)\\n        {\\n            int a = i[0];\\n            int b = i[1];\\n            adj[a].push_back(b);\\n            adj[b].push_back(a);\\n        }\\n        for(int i=0;i<trips.size();i++)\\n        {\\n            int st = trips[i][0];\\n            int en = trips[i][1];\\n            vector<int> tmp(n);\\n            dfs(st,en,adj,tmp,-1,fre);\\n        }\\n        \\n        return dfs1(0,adj,fre,price,-1,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431012,
                "title": "java-easy-to-understand-dp-dfs",
                "content": "```\\nclass Solution {\\n    int[] freq;\\n    Integer[][] dp;\\n    private int solve(List<List<Integer>> graph, int cur, boolean flag, int[] price, int parent){\\n        int index = flag ? 0 : 1;\\n        if(dp[cur][index] != null) return dp[cur][index];\\n        List<Integer> neighbors = graph.get(cur);\\n        int res = flag ? (price[cur] * freq[cur]) : ((price[cur] / 2) * freq[cur]);\\n        for(int neighbor: neighbors){\\n            if(neighbor != parent){\\n                if(flag)\\n                    res += Math.min(solve(graph, neighbor, true, price, cur), solve(graph, neighbor, false, price, cur));\\n                else\\n                    res += solve(graph, neighbor, true, price, cur);\\n            }\\n        }\\n        return dp[cur][index] = res;\\n    }\\n    private boolean dfs(List<List<Integer>> graph, int cur, int end, boolean[] visited){\\n        if(cur == end){\\n            visited[cur] = true;\\n            freq[cur] ++;\\n            return true;\\n        }\\n        visited[cur] = true;\\n        boolean res = false;\\n        List<Integer> neighbors = graph.get(cur);\\n        for(int neighbor: neighbors){\\n            if(visited[neighbor]) continue;\\n            res = res || dfs(graph, neighbor, end, visited);\\n        }\\n        if(res) freq[cur] ++;\\n        return res;\\n    }\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        dp = new Integer[n][2];\\n        for(int i = 0; i < n; i++) graph.add(new ArrayList<>());\\n        for(int[] edge: edges){\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        freq = new int[n];\\n        for(int[] trip: trips){\\n            dfs(graph, trip[0], trip[1], new boolean[n]);\\n        }\\n        return Math.min(solve(graph, 0, true, price, -1), solve(graph, 0, false, price, -1));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] freq;\\n    Integer[][] dp;\\n    private int solve(List<List<Integer>> graph, int cur, boolean flag, int[] price, int parent){\\n        int index = flag ? 0 : 1;\\n        if(dp[cur][index] != null) return dp[cur][index];\\n        List<Integer> neighbors = graph.get(cur);\\n        int res = flag ? (price[cur] * freq[cur]) : ((price[cur] / 2) * freq[cur]);\\n        for(int neighbor: neighbors){\\n            if(neighbor != parent){\\n                if(flag)\\n                    res += Math.min(solve(graph, neighbor, true, price, cur), solve(graph, neighbor, false, price, cur));\\n                else\\n                    res += solve(graph, neighbor, true, price, cur);\\n            }\\n        }\\n        return dp[cur][index] = res;\\n    }\\n    private boolean dfs(List<List<Integer>> graph, int cur, int end, boolean[] visited){\\n        if(cur == end){\\n            visited[cur] = true;\\n            freq[cur] ++;\\n            return true;\\n        }\\n        visited[cur] = true;\\n        boolean res = false;\\n        List<Integer> neighbors = graph.get(cur);\\n        for(int neighbor: neighbors){\\n            if(visited[neighbor]) continue;\\n            res = res || dfs(graph, neighbor, end, visited);\\n        }\\n        if(res) freq[cur] ++;\\n        return res;\\n    }\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        dp = new Integer[n][2];\\n        for(int i = 0; i < n; i++) graph.add(new ArrayList<>());\\n        for(int[] edge: edges){\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        freq = new int[n];\\n        for(int[] trip: trips){\\n            dfs(graph, trip[0], trip[1], new boolean[n]);\\n        }\\n        return Math.min(solve(graph, 0, true, price, -1), solve(graph, 0, false, price, -1));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430155,
                "title": "house-robber-o-m-n-python3-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe\\'d like to choose some non-adjacent node to minimize the total cost. First, we count the use time of each node. Second, choose some non-adjacent node to halve. We want to maximize the halve parts. So the answer will be `sum(use_time[node]*price[time] for all nodes) - sum(use_time[node]*price[time] // 2 for chosen nodes)`. So how to choose the nodes? It\\'s similar to the problem [house-robber](https://leetcode.com/problems/house-robber/) which wants to maximize the the sum of non-adjacent array element. We choose a node as root. Build the topological sort order and trans the undirected and unrooted tree to the directed and rooted tree. And start from the root bulid the dp top down. Let\\'s define `dp[node][0]` means we halve the node and include its valid solution of children, `dp[node][1]` means we don\\'t halve the current node, so for its children we could choose do or do not halve its children.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse count_use function to build the use_time of all nodes.\\nTo build a directed and rooted tree. Set node 0 as root. Use topological_sort function to find the children of all nodes.\\nUse build_dp from root to build the dp.\\nSum the total cost and minus the max of dp[root][0], dp[root][1].\\n# Complexity\\n$$n$$ = number of nodes.\\n$$m$$ = number of trips.\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        def count_use(current, target, use_time, visited, adjs):\\n            if visited[current]:\\n                return 0\\n            visited[current] = 1\\n            if current == target:\\n                use_time[current] += 1\\n                return 1\\n            for adj in adjs[current]:\\n                if count_use(adj, target, use_time, visited, adjs):\\n                    use_time[current] += 1\\n                    return 1\\n            return 0\\n\\n        def topological_sort(current, visited, adjs, children):\\n            if visited[current]:\\n                return 0\\n            visited[current] = 1\\n            for adj in adjs[current]:\\n                if topological_sort(adj, visited, adjs, children):\\n                    children[current].append(adj)\\n            return 1\\n        \\n        def build_dp(current, visited, adjs, children, price, use_time, dp):\\n            # dp[i][0] choose node i to halve dp[i][1] not choose node i\\n            if visited[current]:\\n                return dp[current]\\n            visited[current] = 1\\n            dp[current][0] = price[current]*use_time[current]//2\\n            dp[current][1] = 0\\n            for child in children[current]:\\n                build_dp(child, visited, adjs, children, price, use_time, dp)\\n                dp[current][0] += dp[child][1]\\n                dp[current][1] += max(dp[child][1], dp[child][0])\\n            return dp[current]\\n        \\n        use_time = [0]*n\\n        adjs = [[] for _ in range(n)]\\n        \\n        for edge in edges:\\n            adjs[edge[0]].append(edge[1])\\n            adjs[edge[1]].append(edge[0])\\n        for trip in trips:\\n            visited = [0]*n\\n            count_use(trip[0], trip[1], use_time, visited, adjs)\\n\\n        root = 0\\n        visited = [0]*n\\n        children = [[] for _ in range(n)]\\n        topological_sort(root, visited, adjs, children)\\n\\n        visited = [0]*n\\n        dp = [[0,0] for _ in range(n)]\\n        build_dp(root, visited, adjs, children, price, use_time, dp)\\n\\n        total = 0\\n        for i in range(n):\\n            total += use_time[i]*price[i]\\n        total -= max(dp[root])\\n\\n        return total\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        def count_use(current, target, use_time, visited, adjs):\\n            if visited[current]:\\n                return 0\\n            visited[current] = 1\\n            if current == target:\\n                use_time[current] += 1\\n                return 1\\n            for adj in adjs[current]:\\n                if count_use(adj, target, use_time, visited, adjs):\\n                    use_time[current] += 1\\n                    return 1\\n            return 0\\n\\n        def topological_sort(current, visited, adjs, children):\\n            if visited[current]:\\n                return 0\\n            visited[current] = 1\\n            for adj in adjs[current]:\\n                if topological_sort(adj, visited, adjs, children):\\n                    children[current].append(adj)\\n            return 1\\n        \\n        def build_dp(current, visited, adjs, children, price, use_time, dp):\\n            # dp[i][0] choose node i to halve dp[i][1] not choose node i\\n            if visited[current]:\\n                return dp[current]\\n            visited[current] = 1\\n            dp[current][0] = price[current]*use_time[current]//2\\n            dp[current][1] = 0\\n            for child in children[current]:\\n                build_dp(child, visited, adjs, children, price, use_time, dp)\\n                dp[current][0] += dp[child][1]\\n                dp[current][1] += max(dp[child][1], dp[child][0])\\n            return dp[current]\\n        \\n        use_time = [0]*n\\n        adjs = [[] for _ in range(n)]\\n        \\n        for edge in edges:\\n            adjs[edge[0]].append(edge[1])\\n            adjs[edge[1]].append(edge[0])\\n        for trip in trips:\\n            visited = [0]*n\\n            count_use(trip[0], trip[1], use_time, visited, adjs)\\n\\n        root = 0\\n        visited = [0]*n\\n        children = [[] for _ in range(n)]\\n        topological_sort(root, visited, adjs, children)\\n\\n        visited = [0]*n\\n        dp = [[0,0] for _ in range(n)]\\n        build_dp(root, visited, adjs, children, price, use_time, dp)\\n\\n        total = 0\\n        for i in range(n):\\n            total += use_time[i]*price[i]\\n        total -= max(dp[root])\\n\\n        return total\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430085,
                "title": "tree-dp",
                "content": "We first calculate what nodes would be visited in all the trips and how many times, and store the inflated price of every node in infPrice vector where infPrice[i] = number of times node \\'i\\' was visited * price[i].\\n(It can easily be achieved by bfs or dfs from start point of every trip)\\nSo, if any node was not visited, its infPrice would be 0.\\nNow, take any random node and calculate the price of trips after it being **halved(H)** and also **not being halved(F)** recursively as :\\nH[i] = infPrice[i]/2 + Sum(F[j]))\\nF[i] = infPrice[i] + Sum(min(H[j], F[j]))\\nwhere j are all the neighbours of i that have not yet been encountered while doing this computation.\\n\\nThe logic here being that if ith node is Halved then all its neighbours should be computed at full value.\\nBut if the ith node is calculated at full value we can chose to compute each neighbour one by one at their full value as well as their halved value. **But, since it is a tree we do not need to worry about side effects of halving the node \\'j\\' which is neighbour of \\'i\\', on an another node \\'k\\' which is also neighbour of \\'i\\' as \\'j\\' and \\'k\\' are disjointed by \\'i\\' and can be computed independently as sub-problems(joined at i).**\\n```\\nclass Solution {\\n    pair<int, int> engine(int i, vector<int> &infPrice, vector<vector<int> > &adj, vector<int> &visited){\\n        pair<int, int> x = {infPrice[i]/2, infPrice[i]};\\n        visited[i] = 1;\\n        for(int y: adj[i]){\\n            if(!visited[y]){\\n                pair<int, int> z = engine(y, infPrice, adj, visited);\\n                x.first += z.second;\\n                x.second += min(z.first, z.second);\\n            }\\n        }\\n        return x;\\n    }\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> infPrice(n, 0);\\n        vector<vector<int> > adj(n, vector<int>());\\n        for(vector<int> x: edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        int d;\\n        for(vector<int> x: trips){\\n            vector<int> visited(n, 0);\\n            vector<int> parent(n, -1);\\n            queue<int> q;\\n            q.push(x[0]);\\n            visited[x[0]] = 1;\\n            parent[x[0]] = x[0];\\n            while(!q.empty()){\\n                d = q.front();\\n                q.pop();\\n                if(d == x[1]) break;\\n                for(int y: adj[d]){\\n                    if(!visited[y]){\\n                        q.push(y);\\n                        visited[y] = 1;\\n                        parent[y] = d;\\n                    }\\n                }\\n            }\\n            while(d != x[0]){\\n                infPrice[d] += price[d];\\n                d = parent[d];\\n            }\\n            infPrice[d] += price[d];\\n        }\\n        vector<int> visited(n, 0);\\n        pair<int, int> x = engine(trips[0][0], infPrice, adj, visited);\\n        return min(x.first, x.second);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    pair<int, int> engine(int i, vector<int> &infPrice, vector<vector<int> > &adj, vector<int> &visited){\\n        pair<int, int> x = {infPrice[i]/2, infPrice[i]};\\n        visited[i] = 1;\\n        for(int y: adj[i]){\\n            if(!visited[y]){\\n                pair<int, int> z = engine(y, infPrice, adj, visited);\\n                x.first += z.second;\\n                x.second += min(z.first, z.second);\\n            }\\n        }\\n        return x;\\n    }\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> infPrice(n, 0);\\n        vector<vector<int> > adj(n, vector<int>());\\n        for(vector<int> x: edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        int d;\\n        for(vector<int> x: trips){\\n            vector<int> visited(n, 0);\\n            vector<int> parent(n, -1);\\n            queue<int> q;\\n            q.push(x[0]);\\n            visited[x[0]] = 1;\\n            parent[x[0]] = x[0];\\n            while(!q.empty()){\\n                d = q.front();\\n                q.pop();\\n                if(d == x[1]) break;\\n                for(int y: adj[d]){\\n                    if(!visited[y]){\\n                        q.push(y);\\n                        visited[y] = 1;\\n                        parent[y] = d;\\n                    }\\n                }\\n            }\\n            while(d != x[0]){\\n                infPrice[d] += price[d];\\n                d = parent[d];\\n            }\\n            infPrice[d] += price[d];\\n        }\\n        vector<int> visited(n, 0);\\n        pair<int, int> x = engine(trips[0][0], infPrice, adj, visited);\\n        return min(x.first, x.second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428562,
                "title": "python-beats-100-231ms-cache-d-dfs-solution-w-explanation-the-importance-of-decomposition",
                "content": "# Approach\\n- Root the tree at the node with the most neighbors. This is a heuristic to get a flatter tree.\\n- In a tree, there is only one path between pairs of nodes.\\n- The path from a to b is found by first finding the path from a to root and the path from b to root. Next, we use these two root paths to find the deepest common ancestor of a and b, cal it DCA(a, b). Finally, the path from a to b is the concatenation of the path from a to the DCA(a, b) and the path from DCA(a, b) to b, each being a subset of the path from a/b to root.\\n- Now that we know how to compute paths between pairs of nodes, we compute all trip paths and tally which nodes are visited and how many times.\\n- This allows us to compute both `cost`, the cost without halving any prices, and `maxDiscount` (via `@cache`d DFS), the maximum discount possible by havling prices subject to the non-adjacent halvings restriction.\\n\\n# Problem decomposition\\nThis problem/solution highlights\\n- the importance of problem decomposition: the problem is only tractable if we break it down into several subproblems\\n- how choosing the correct data structure is vital to solving a problem efficiently. In this case, the data structures that allowed us to solve this problem efficiently was the tree and the visitCounter we constructed. Also, `@cache`d was used so that we don\\'t compute `getMaxDiscount(node, halfable)` at most once per `(node, halfable)` pair.\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, N: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        adj = [set() for _ in range(N)]\\n        for a, b in edges:\\n            adj[a].add(b)\\n            adj[b].add(a)\\n            \\n        # Tree\\n        # Efficiency heuristic: let the root be the node with the most neighbors as that might lead to a flatter tree\\n        root = max(range(N), key=lambda i: len(adj[i]))\\n        parent = [None] * N\\n        children = adj\\n        nodes0 = {root}\\n        while nodes0:\\n            nodes1 = set()\\n            for node0 in nodes0:\\n                nodes1 |= children[node0]\\n                for child in children[node0]:\\n                    children[child].remove(node0)\\n                    parent[child] = node0\\n            nodes0 = nodes1\\n        def getPathToRoot(a):\\n            path = [None, a] # the None is a kludge to simplify the common ancestor logic in getPath(trip)\\n            while a != root:\\n                a = parent[a]\\n                path.append(a)\\n            # a == root\\n            return path\\n        \\n        def getPath(trip):\\n            a, b = trip\\n            if a == b:\\n                return [a]\\n            if a == root or b == root:\\n                if a == root:\\n                    a = b\\n                # a is the non-root node\\n                return getPathToRoot(a)[1:] # the 1 is to exclude the None (see first line of getPath)\\n            \\n            aRootPath = getPathToRoot(a)\\n            bRootPath = getPathToRoot(b)\\n            \\n            i = -2 # i=-1 not necessary since we know aRootPath[-1] == bRootPath[-1] == root\\n            while aRootPath[i] == bRootPath[i]:\\n                i -= 1\\n            # aRootPath[i] != bRootPath[i]\\n            # aRootPath[i+1] == bRootPath[i+1] is the deepest common ancestor of a and b\\n            \\n            # Alt 1\\n            path = aRootPath[1:i+1] + [aRootPath[i+1]] + bRootPath[1:i+1]\\n            # the 1 is to exclude the None (see first line of getPath)\\n            # the i+2, i+1 is to include the deepest common ancestor == aRootPath[i+1] == bRootPath[i+1] only once\\n            # the returned path is not in order, but that\\'s fine for our purposes\\n            # for completeness, the path in order is actually aRootPath[1:i+2] + list(reversed(bRootPath[1:i+1])) which is the the path from a to the deepest common ancestor of a and b, then to b\\n\\n            # # Alt 2\\n            # if i == -2: # i+2 == 0\\n            #     N = len(aRootPath)\\n            #     path = aRootPath[1:N] + bRootPath[1:i+1]\\n            # else:\\n            #     path = aRootPath[1:i+2] + bRootPath[1:i+1]\\n\\n            return path\\n        \\n        # Which nodes are visited across all the trips? And how many times?\\n        visitCounter = Counter()\\n        for trip in trips:\\n            visitCounter.update(getPath(trip))\\n        \\n        # Without halving any prices, the total cost is\\n        cost = sum(price[node] * nodeVisitCnt for node, nodeVisitCnt in visitCounter.items())\\n        \\n        @cache\\n        def getMaxDiscount(node=root, halfable=True):\\n            discountIfNotHalved = sum(getMaxDiscount(child, halfable=True) for child in children[node])\\n            if not halfable or node not in visitCounter:\\n                return discountIfNotHalved\\n            # halfable and node in visitCounter\\n            discountIfHalved = (price[node] >> 1) * visitCounter[node] + sum(getMaxDiscount(child, halfable=False) for child in children[node])\\n            return max(discountIfNotHalved, discountIfHalved)\\n        \\n        return cost - getMaxDiscount()\\n```\\n\\n---\\n\\n# Slightly different solution\\n\\nThis one integrates finding the path from a to b and updating the visit counter into one funciton saving us some operations and memory compared to the above.\\n\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, N: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        adj = [set() for _ in range(N)]\\n        for a, b in edges:\\n            adj[a].add(b)\\n            adj[b].add(a)\\n            \\n        # Tree\\n        # Efficiency heuristic: let the root be the node with the most neighbors as that might lead to a flatter tree\\n        root = max(range(N), key=lambda i: len(adj[i]))\\n        level = [None] * N\\n        lvl = 0\\n        parent = [None] * N\\n        children = adj\\n        nodes0 = [root]\\n        while nodes0:\\n            nodes1 = []\\n            for node0 in nodes0:\\n                level[node0] = lvl\\n                nodes1 += children[node0]\\n                for child in children[node0]:\\n                    children[child].remove(node0)\\n                    parent[child] = node0\\n            lvl += 1\\n            nodes0 = nodes1\\n        \\n        def updateVisitCounter(trip):\\n            a, b = trip\\n            if level[a] < level[b]:\\n                a, b = b, a\\n            # level[a] >= level[b], i.e. a is deeper than b\\n            d = level[a] - level[b]\\n            for _ in range(d):\\n                visitCounter[a] += 1\\n                a = parent[a]\\n            while a != b:\\n                visitCounter[a] += 1\\n                visitCounter[b] += 1\\n                a = parent[a]\\n                b = parent[b]\\n            # a == b == the deepest common ancestor of inputVal(a) and inputVal(b)\\n            visitCounter[a] += 1\\n        \\n        # Which nodes are visited across all the trips? And how many times?\\n        visitCounter = Counter()\\n        for trip in trips:\\n            updateVisitCounter(trip)\\n        \\n        # Without halving any prices, the total cost is\\n        cost = sum(price[node] * nodeVisitCnt for node, nodeVisitCnt in visitCounter.items())\\n        \\n        @cache\\n        def getMaxDiscount(node=root, halfable=True):\\n            discountIfNotHalved = sum(getMaxDiscount(child, halfable=True) for child in children[node])\\n            if not halfable or node not in visitCounter:\\n                return discountIfNotHalved\\n            # halfable and node in visitCounter\\n            discountIfHalved = (price[node] >> 1) * visitCounter[node] + sum(getMaxDiscount(child, halfable=False) for child in children[node])\\n            return max(discountIfNotHalved, discountIfHalved)\\n        \\n        return cost - getMaxDiscount()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, N: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        adj = [set() for _ in range(N)]\\n        for a, b in edges:\\n            adj[a].add(b)\\n            adj[b].add(a)\\n            \\n        # Tree\\n        # Efficiency heuristic: let the root be the node with the most neighbors as that might lead to a flatter tree\\n        root = max(range(N), key=lambda i: len(adj[i]))\\n        parent = [None] * N\\n        children = adj\\n        nodes0 = {root}\\n        while nodes0:\\n            nodes1 = set()\\n            for node0 in nodes0:\\n                nodes1 |= children[node0]\\n                for child in children[node0]:\\n                    children[child].remove(node0)\\n                    parent[child] = node0\\n            nodes0 = nodes1\\n        def getPathToRoot(a):\\n            path = [None, a] # the None is a kludge to simplify the common ancestor logic in getPath(trip)\\n            while a != root:\\n                a = parent[a]\\n                path.append(a)\\n            # a == root\\n            return path\\n        \\n        def getPath(trip):\\n            a, b = trip\\n            if a == b:\\n                return [a]\\n            if a == root or b == root:\\n                if a == root:\\n                    a = b\\n                # a is the non-root node\\n                return getPathToRoot(a)[1:] # the 1 is to exclude the None (see first line of getPath)\\n            \\n            aRootPath = getPathToRoot(a)\\n            bRootPath = getPathToRoot(b)\\n            \\n            i = -2 # i=-1 not necessary since we know aRootPath[-1] == bRootPath[-1] == root\\n            while aRootPath[i] == bRootPath[i]:\\n                i -= 1\\n            # aRootPath[i] != bRootPath[i]\\n            # aRootPath[i+1] == bRootPath[i+1] is the deepest common ancestor of a and b\\n            \\n            # Alt 1\\n            path = aRootPath[1:i+1] + [aRootPath[i+1]] + bRootPath[1:i+1]\\n            # the 1 is to exclude the None (see first line of getPath)\\n            # the i+2, i+1 is to include the deepest common ancestor == aRootPath[i+1] == bRootPath[i+1] only once\\n            # the returned path is not in order, but that\\'s fine for our purposes\\n            # for completeness, the path in order is actually aRootPath[1:i+2] + list(reversed(bRootPath[1:i+1])) which is the the path from a to the deepest common ancestor of a and b, then to b\\n\\n            # # Alt 2\\n            # if i == -2: # i+2 == 0\\n            #     N = len(aRootPath)\\n            #     path = aRootPath[1:N] + bRootPath[1:i+1]\\n            # else:\\n            #     path = aRootPath[1:i+2] + bRootPath[1:i+1]\\n\\n            return path\\n        \\n        # Which nodes are visited across all the trips? And how many times?\\n        visitCounter = Counter()\\n        for trip in trips:\\n            visitCounter.update(getPath(trip))\\n        \\n        # Without halving any prices, the total cost is\\n        cost = sum(price[node] * nodeVisitCnt for node, nodeVisitCnt in visitCounter.items())\\n        \\n        @cache\\n        def getMaxDiscount(node=root, halfable=True):\\n            discountIfNotHalved = sum(getMaxDiscount(child, halfable=True) for child in children[node])\\n            if not halfable or node not in visitCounter:\\n                return discountIfNotHalved\\n            # halfable and node in visitCounter\\n            discountIfHalved = (price[node] >> 1) * visitCounter[node] + sum(getMaxDiscount(child, halfable=False) for child in children[node])\\n            return max(discountIfNotHalved, discountIfHalved)\\n        \\n        return cost - getMaxDiscount()\\n```\n```\\nclass Solution:\\n    def minimumTotalPrice(self, N: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        adj = [set() for _ in range(N)]\\n        for a, b in edges:\\n            adj[a].add(b)\\n            adj[b].add(a)\\n            \\n        # Tree\\n        # Efficiency heuristic: let the root be the node with the most neighbors as that might lead to a flatter tree\\n        root = max(range(N), key=lambda i: len(adj[i]))\\n        level = [None] * N\\n        lvl = 0\\n        parent = [None] * N\\n        children = adj\\n        nodes0 = [root]\\n        while nodes0:\\n            nodes1 = []\\n            for node0 in nodes0:\\n                level[node0] = lvl\\n                nodes1 += children[node0]\\n                for child in children[node0]:\\n                    children[child].remove(node0)\\n                    parent[child] = node0\\n            lvl += 1\\n            nodes0 = nodes1\\n        \\n        def updateVisitCounter(trip):\\n            a, b = trip\\n            if level[a] < level[b]:\\n                a, b = b, a\\n            # level[a] >= level[b], i.e. a is deeper than b\\n            d = level[a] - level[b]\\n            for _ in range(d):\\n                visitCounter[a] += 1\\n                a = parent[a]\\n            while a != b:\\n                visitCounter[a] += 1\\n                visitCounter[b] += 1\\n                a = parent[a]\\n                b = parent[b]\\n            # a == b == the deepest common ancestor of inputVal(a) and inputVal(b)\\n            visitCounter[a] += 1\\n        \\n        # Which nodes are visited across all the trips? And how many times?\\n        visitCounter = Counter()\\n        for trip in trips:\\n            updateVisitCounter(trip)\\n        \\n        # Without halving any prices, the total cost is\\n        cost = sum(price[node] * nodeVisitCnt for node, nodeVisitCnt in visitCounter.items())\\n        \\n        @cache\\n        def getMaxDiscount(node=root, halfable=True):\\n            discountIfNotHalved = sum(getMaxDiscount(child, halfable=True) for child in children[node])\\n            if not halfable or node not in visitCounter:\\n                return discountIfNotHalved\\n            # halfable and node in visitCounter\\n            discountIfHalved = (price[node] >> 1) * visitCounter[node] + sum(getMaxDiscount(child, halfable=False) for child in children[node])\\n            return max(discountIfNotHalved, discountIfHalved)\\n        \\n        return cost - getMaxDiscount()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428549,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.path=[]\\n        self.dp=[]\\n        for i in range(51):\\n            self.dp+=[[-1]*2]\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        adj=[]\\n        c1=[]\\n        for i in range(n):\\n            adj+=[[]]\\n            c1+=[[0]*n]\\n        for i in edges:\\n            adj[i[0]]+=[i[1]]\\n            adj[i[1]]+=[i[0]]\\n            c1[i[0]][i[1]]+=1\\n            c1[i[1]][i[0]]+=1\\n        c=[0]*n\\n        h={}\\n        for i in trips:\\n            v=[-1]*n\\n            self.solve(trips,adj,i[0],i[1],[i[0]],v)\\n            for i in self.path:\\n                c[i]+=1\\n            self.path=[]\\n        v=[-1]*n\\n        for i in range(n):\\n            c[i]*=price[i]\\n        l2=[]\\n        for i in range(n):\\n            l1=[]\\n            for j in range(n):\\n                if c1[i][j]==0:\\n                    l1+=[j]\\n            l2+=[l1]\\n        print(c)\\n        totpri=sum(c)\\n        a=self.maximum(adj,c,v,0,0)\\n        return totpri-a\\n    def maximum(self,adj,c,v,i,cur):\\n        v[cur]=1\\n        if self.dp[cur][i]!=-1:\\n            return self.dp[cur][i]\\n        if i==0:\\n            s=c[cur]//2\\n            for j in adj[cur]:\\n                if v[j]==-1:\\n                    s+=self.maximum(adj,c,v,1,j)\\n                    v[j]=-1\\n            s1=0\\n            for j in adj[cur]:\\n                if v[j]==-1:\\n                    s1+=self.maximum(adj,c,v,0,j)\\n                    v[j]=-1\\n            s=max(s,s1)\\n            self.dp[cur][i]=s\\n            return s\\n        else:\\n            s1=0\\n            for j in adj[cur]:\\n                if v[j]==-1:\\n                    s1+=self.maximum(adj,c,v,0,j)\\n                    v[j]=-1\\n            self.dp[cur][i]=s1\\n            return s1\\n    def solve(self,l,adj,i1,i2,l1,v):\\n        v[i1]=1\\n        if i1==i2:\\n            self.path=l1\\n        for i in adj[i1]:\\n            if v[i]==-1:\\n                self.solve(l,adj,i,i2,l1+[i],v)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.path=[]\\n        self.dp=[]\\n        for i in range(51):\\n            self.dp+=[[-1]*2]\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        adj=[]\\n        c1=[]\\n        for i in range(n):\\n            adj+=[[]]\\n            c1+=[[0]*n]\\n        for i in edges:\\n            adj[i[0]]+=[i[1]]\\n            adj[i[1]]+=[i[0]]\\n            c1[i[0]][i[1]]+=1\\n            c1[i[1]][i[0]]+=1\\n        c=[0]*n\\n        h={}\\n        for i in trips:\\n            v=[-1]*n\\n            self.solve(trips,adj,i[0],i[1],[i[0]],v)\\n            for i in self.path:\\n                c[i]+=1\\n            self.path=[]\\n        v=[-1]*n\\n        for i in range(n):\\n            c[i]*=price[i]\\n        l2=[]\\n        for i in range(n):\\n            l1=[]\\n            for j in range(n):\\n                if c1[i][j]==0:\\n                    l1+=[j]\\n            l2+=[l1]\\n        print(c)\\n        totpri=sum(c)\\n        a=self.maximum(adj,c,v,0,0)\\n        return totpri-a\\n    def maximum(self,adj,c,v,i,cur):\\n        v[cur]=1\\n        if self.dp[cur][i]!=-1:\\n            return self.dp[cur][i]\\n        if i==0:\\n            s=c[cur]//2\\n            for j in adj[cur]:\\n                if v[j]==-1:\\n                    s+=self.maximum(adj,c,v,1,j)\\n                    v[j]=-1\\n            s1=0\\n            for j in adj[cur]:\\n                if v[j]==-1:\\n                    s1+=self.maximum(adj,c,v,0,j)\\n                    v[j]=-1\\n            s=max(s,s1)\\n            self.dp[cur][i]=s\\n            return s\\n        else:\\n            s1=0\\n            for j in adj[cur]:\\n                if v[j]==-1:\\n                    s1+=self.maximum(adj,c,v,0,j)\\n                    v[j]=-1\\n            self.dp[cur][i]=s1\\n            return s1\\n    def solve(self,l,adj,i1,i2,l1,v):\\n        v[i1]=1\\n        if i1==i2:\\n            self.path=l1\\n        for i in adj[i1]:\\n            if v[i]==-1:\\n                self.solve(l,adj,i,i2,l1+[i],v)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428445,
                "title": "intuition-dfs-dp-memoization-detailed-explanation-c-o-n",
                "content": "# Intuition\\nWell, before approaching any question I would highly recommend you to ```always look at the constraints``` of the question.   \\n \\nAfter analysing it, you will realize that this **question is pretty Straight Forward to Implement**. You just need to code as the question demands. Hence I consider this question as one of the ```EASIEST question tagged Hard on LeetCode```\\n\\n# Analyzing Constraints & Framing of Solution\\n1. So let\\'s start by thinking about the time complexity to find out the route for each trip. Well, ```DFS``` is what comes in mind whenever we need to ```find out any route in Graphs or Trees```. Hence, for each trip, it\\'s time complexity would be ```O(N) where N is the number of Nodes.```\\n2. As the ```number of trips can be at max 100``` and ```number of nodes can be 50``` their ```product comes out to be 5000```. So a **basic DFS function to find out cost of each trip would work find.**\\n3. To find out ```which node we have to reduce and which not``` we can code a``` recursive function``` which can generate 2 possibilities, either the node value can be reduced by half or not.\\n4. **So, let\\'s analyse the time complexity of the recursive function.** As we have ```50 nodes each having 2 possibilities``` i.e. either to reduce the price or not, ```time complexity for recursive functions comes out to be 2^50``` which is quite high and would ```hence result in TLE.```\\n5. **What we can do to reduce it\\'s complexity then??** Pause for a second and give a thought. **I know you can find out the solution to this problem!!**\\n6. Well if you thought about ```something like DP or more specifically Memoization``` then yes, it will work fine. Hence, we will be using ```memoization technique to reduce it\\'s time complexity!!.``` \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n## 1) DFS Function\\nAs discussed above in point 2, we will be using DFS function to find out the cost for each trip. ```Along with it, we will be counting the nodes which are traversed in a trip.```\\nIf you thinking **why are we doing this??** Then a brief answer to your question is ```to figure out which node\\'s value we have to reduce.```\\n\\nBelow is the code of the same.\\n\\n```\\nint tripCost(int start,int end,int parent,int sum,vector<int>&prices){\\n        used[start]++;\\n        if(start==end) return sum+prices[start];\\n        \\n        int val=1e7;\\n        for(auto it:adj[start]){\\n            if(it!=parent) \\n            val = min(val,tripCost(it,end,start,sum+prices[start],prices));\\n        }\\n        \\n        if(val>=1e7) used[start]--; // This condition states that\\n        // the current node is not the part of our route to the \\n        // destination.\\n        if(!used[start]) used.erase(start);\\n        return val;\\n    }\\n``` \\n**```used``` --> unordered_map which counts the frequency of the node used in trip.**\\n\\n\\n## 2.1) Recursive Function\\n**As discussed above in point 3**, we will be using recursive function to find out the nodes whose reducing the price will give us the minimum total cost of the trip.\\n\\n**I would first recommend you to have a look at the code below** then go for it\\'s explanation which I wrote below the code. Because ```I think the code is quite intuitive for all the readers who are trying LeetCode hard problems. ```\\n\\n```\\nint reduceCost(int node,int parent,vector<int>&prices){\\n        int nvalue=0,rvalue=0;\\n            \\n        for(auto it:adj[node]) if(it!=parent) \\n          nvalue+=reduceCost(it,node,prices);\\n\\n        if(!reduced[parent] and used.count(node)){\\n            reduced[node]=true;\\n            rvalue=used[node]*(prices[node]/2);\\n\\n            for(auto it:adj[node]) if(it!=parent) \\n              rvalue+=reduceCost(it,node,prices);\\n            \\n            reduced[node]=false;\\n        }\\n\\n        return max(nvalue,rvalue);\\n    }\\n```\\n\\n**For those who have doubts regarding the code above,** I have used 2 variables ```rvalue and nvalue```. \\n```rvalue stores the total reduction cost when reduction of the current node is possible``` which can only be ```possible if the current node is atleast used once in any of the trips and parent of it is not being reduced.```\\n```nvalue on other hand calculates the cost when the current node\\'s value is not reduced by half.```\\n**And in the end to maximize the reduction we return the maximum of nvalue and rvalue.**\\n\\n## 2.2) Memoized version\\n**So here\\'s the memoized version of the same recursive code. Have a look first. Below the code I have discussed the main points of the function.**\\n\\n```\\nint reduceCost(int node,int parent,bool canReduce,vector<int>&prices){\\n        int nvalue=0,rvalue=0;\\n\\n        if(dp[node][canReduce]!=-1) return dp[node][canReduce];\\n            \\n        for(auto it:adj[node]) if(it!=parent) \\n            // we will pass true in canReduce each time as the \\n            // current node is not being reduced hence all the \\n            // neighbours can be reduced \\n            nvalue+=reduceCost(it,node,true,prices);\\n\\n        if(canReduce and used.count(node)){\\n            rvalue=used[node]*(prices[node]/2);\\n            for(auto it:adj[node]) if(it!=parent) \\n                rvalue+=reduceCost(it,node,!canReduce,prices);\\n        }\\n\\n        dp[node][1]=max(rvalue,nvalue),dp[node][0]=nvalue;\\n        return dp[node][canReduce];\\n    }\\n```\\n**1. ```if(dp[node][canReduce]!=-1)```--> It means the for particular node the value is already being calculated.\\n2. ```dp[node][1]=max(rvalue,nvalue)```--> dp[node][1] means that the node can be reduced. In this scenrio we can either take the possibility of reducing the current node or we can continue without reducing the price of it. Hence ```max of both nvalue and rvalue``` is taken into consideration.\\n3.```dp[node][0]=nvalue```-->dp[node][0] means that the node cannot be reduced. Hence the only case is to continue without reducing it\\'s price to half.\\n4.```return dp[node][canReduce]```--> returning the value demanded**\\n\\n# Complexity\\n- Time complexity:\\n1. DFS Function: O(N)\\n2. Memoized version: O(N)\\n**Overall: O (N * Trip_Length)**\\n\\n# Code\\n## 1. Memoized Version\\n```\\nclass Solution {\\npublic:\\n    map<int,vector<int>>adj;\\n    unordered_map<int,int>used;\\n    vector<vector<int>>dp;\\n    \\n    int tripCost(int start,int end,int parent,int sum,vector<int>&prices){\\n        used[start]++;\\n        if(start==end) return sum+prices[start];\\n        \\n        int val=1e7;\\n        for(auto it:adj[start]){\\n            if(it!=parent) \\n            val = min(val,tripCost(it,end,start,sum+prices[start],prices));\\n        }\\n        \\n        if(val>=1e7) used[start]--;\\n        if(!used[start]) used.erase(start);\\n        return val;\\n    }\\n    \\n    int reduceCost(int node,int parent,bool canReduce,vector<int>&prices){\\n        int nvalue=0,rvalue=0;\\n\\n        if(dp[node][canReduce]!=-1) return dp[node][canReduce];\\n            \\n        for(auto it:adj[node]) if(it!=parent) \\n            nvalue+=reduceCost(it,node,true,prices);\\n\\n        if(canReduce and used.count(node)){\\n            rvalue=used[node]*(prices[node]/2);\\n            for(auto it:adj[node]) if(it!=parent) \\n                rvalue+=reduceCost(it,node,!canReduce,prices);\\n        }\\n\\n        dp[node][1]=max(rvalue,nvalue),dp[node][0]=nvalue;\\n        return dp[node][canReduce];\\n    }\\n\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        dp.resize(n,vector<int>(2,-1));\\n        int res=0;\\n        \\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n    \\n        for(auto it:trips) res+=tripCost(it[0],it[1],-1,0,price);\\n        \\n        reduceCost(0,0,true,price);\\n        res-=max(dp[0][0],dp[0][1]);\\n        return res;\\n        \\n    }\\n};\\n```\\n\\n## 2. Recursive Version\\n```\\nclass Solution {\\npublic:\\n    map<int,vector<int>>adj;\\n    unordered_map<int,int>used;\\n    vector<bool>reduced;\\n    \\n    int tripCost(int start,int end,int parent,int sum,vector<int>&prices){\\n        used[start]++;\\n        if(start==end) return sum+prices[start];\\n        \\n        int val=1e7;\\n        for(auto it:adj[start]){\\n            if(it!=parent) val = min(val,tripCost(it,end,start,sum+prices[start],prices));\\n        }\\n        \\n        if(val>=1e7) used[start]--;\\n        if(!used[start]) used.erase(start);\\n        return val;\\n    }\\n    \\n    int reduceCost(int node,int parent,vector<int>&prices){\\n        int nvalue=0,rvalue=0;\\n            \\n        for(auto it:adj[node]) if(it!=parent) nvalue+=reduceCost(it,node,prices);\\n\\n        if(!reduced[parent] and used.count(node)){\\n            reduced[node]=true;\\n            rvalue=used[node]*(prices[node]/2);\\n            for(auto it:adj[node]) if(it!=parent) rvalue+=reduceCost(it,node,prices);\\n            reduced[node]=false;\\n        }\\n\\n        return max(nvalue,rvalue);\\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        reduced.resize(n,false);\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        int res=0;\\n        for(auto it:trips){\\n            res+=tripCost(it[0],it[1],-1,0,price);\\n        }\\n\\n        res-=reduceCost(0,0,price);\\n        return res;\\n        \\n    }\\n};\\n```\\n\\n**IF YOU HAVE ANY DOUBTS REGARDING THE CODE OR EXPLANATION REACH OUT COMMENT SECTION.**\\n**KINDLY UPVOTE IF YOU LIKED MY CODING AND EXPLANATION.** \\n**THANKS!! \\u2764\\uFE0F**",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Memoization",
                    "Ordered Map"
                ],
                "code": "```always look at the constraints```\n```EASIEST question tagged Hard on LeetCode```\n```DFS```\n```find out any route in Graphs or Trees```\n```O(N) where N is the number of Nodes.```\n```number of trips can be at max 100```\n```number of nodes can be 50```\n```product comes out to be 5000```\n```which node we have to reduce and which not```\n``` recursive function```\n```50 nodes each having 2 possibilities```\n```time complexity for recursive functions comes out to be 2^50```\n```hence result in TLE.```\n```something like DP or more specifically Memoization```\n```memoization technique to reduce it\\'s time complexity!!.```\n```Along with it, we will be counting the nodes which are traversed in a trip.```\n```to figure out which node\\'s value we have to reduce.```\n```\\nint tripCost(int start,int end,int parent,int sum,vector<int>&prices){\\n        used[start]++;\\n        if(start==end) return sum+prices[start];\\n        \\n        int val=1e7;\\n        for(auto it:adj[start]){\\n            if(it!=parent) \\n            val = min(val,tripCost(it,end,start,sum+prices[start],prices));\\n        }\\n        \\n        if(val>=1e7) used[start]--; // This condition states that\\n        // the current node is not the part of our route to the \\n        // destination.\\n        if(!used[start]) used.erase(start);\\n        return val;\\n    }\\n```\n```used```\n```I think the code is quite intuitive for all the readers who are trying LeetCode hard problems. ```\n```\\nint reduceCost(int node,int parent,vector<int>&prices){\\n        int nvalue=0,rvalue=0;\\n            \\n        for(auto it:adj[node]) if(it!=parent) \\n          nvalue+=reduceCost(it,node,prices);\\n\\n        if(!reduced[parent] and used.count(node)){\\n            reduced[node]=true;\\n            rvalue=used[node]*(prices[node]/2);\\n\\n            for(auto it:adj[node]) if(it!=parent) \\n              rvalue+=reduceCost(it,node,prices);\\n            \\n            reduced[node]=false;\\n        }\\n\\n        return max(nvalue,rvalue);\\n    }\\n```\n```rvalue and nvalue```\n```rvalue stores the total reduction cost when reduction of the current node is possible```\n```possible if the current node is atleast used once in any of the trips and parent of it is not being reduced.```\n```nvalue on other hand calculates the cost when the current node\\'s value is not reduced by half.```\n```\\nint reduceCost(int node,int parent,bool canReduce,vector<int>&prices){\\n        int nvalue=0,rvalue=0;\\n\\n        if(dp[node][canReduce]!=-1) return dp[node][canReduce];\\n            \\n        for(auto it:adj[node]) if(it!=parent) \\n            // we will pass true in canReduce each time as the \\n            // current node is not being reduced hence all the \\n            // neighbours can be reduced \\n            nvalue+=reduceCost(it,node,true,prices);\\n\\n        if(canReduce and used.count(node)){\\n            rvalue=used[node]*(prices[node]/2);\\n            for(auto it:adj[node]) if(it!=parent) \\n                rvalue+=reduceCost(it,node,!canReduce,prices);\\n        }\\n\\n        dp[node][1]=max(rvalue,nvalue),dp[node][0]=nvalue;\\n        return dp[node][canReduce];\\n    }\\n```\n```if(dp[node][canReduce]!=-1)```\n```dp[node][1]=max(rvalue,nvalue)```\n```max of both nvalue and rvalue```\n```dp[node][0]=nvalue```\n```return dp[node][canReduce]```\n```\\nclass Solution {\\npublic:\\n    map<int,vector<int>>adj;\\n    unordered_map<int,int>used;\\n    vector<vector<int>>dp;\\n    \\n    int tripCost(int start,int end,int parent,int sum,vector<int>&prices){\\n        used[start]++;\\n        if(start==end) return sum+prices[start];\\n        \\n        int val=1e7;\\n        for(auto it:adj[start]){\\n            if(it!=parent) \\n            val = min(val,tripCost(it,end,start,sum+prices[start],prices));\\n        }\\n        \\n        if(val>=1e7) used[start]--;\\n        if(!used[start]) used.erase(start);\\n        return val;\\n    }\\n    \\n    int reduceCost(int node,int parent,bool canReduce,vector<int>&prices){\\n        int nvalue=0,rvalue=0;\\n\\n        if(dp[node][canReduce]!=-1) return dp[node][canReduce];\\n            \\n        for(auto it:adj[node]) if(it!=parent) \\n            nvalue+=reduceCost(it,node,true,prices);\\n\\n        if(canReduce and used.count(node)){\\n            rvalue=used[node]*(prices[node]/2);\\n            for(auto it:adj[node]) if(it!=parent) \\n                rvalue+=reduceCost(it,node,!canReduce,prices);\\n        }\\n\\n        dp[node][1]=max(rvalue,nvalue),dp[node][0]=nvalue;\\n        return dp[node][canReduce];\\n    }\\n\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        dp.resize(n,vector<int>(2,-1));\\n        int res=0;\\n        \\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n    \\n        for(auto it:trips) res+=tripCost(it[0],it[1],-1,0,price);\\n        \\n        reduceCost(0,0,true,price);\\n        res-=max(dp[0][0],dp[0][1]);\\n        return res;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    map<int,vector<int>>adj;\\n    unordered_map<int,int>used;\\n    vector<bool>reduced;\\n    \\n    int tripCost(int start,int end,int parent,int sum,vector<int>&prices){\\n        used[start]++;\\n        if(start==end) return sum+prices[start];\\n        \\n        int val=1e7;\\n        for(auto it:adj[start]){\\n            if(it!=parent) val = min(val,tripCost(it,end,start,sum+prices[start],prices));\\n        }\\n        \\n        if(val>=1e7) used[start]--;\\n        if(!used[start]) used.erase(start);\\n        return val;\\n    }\\n    \\n    int reduceCost(int node,int parent,vector<int>&prices){\\n        int nvalue=0,rvalue=0;\\n            \\n        for(auto it:adj[node]) if(it!=parent) nvalue+=reduceCost(it,node,prices);\\n\\n        if(!reduced[parent] and used.count(node)){\\n            reduced[node]=true;\\n            rvalue=used[node]*(prices[node]/2);\\n            for(auto it:adj[node]) if(it!=parent) rvalue+=reduceCost(it,node,prices);\\n            reduced[node]=false;\\n        }\\n\\n        return max(nvalue,rvalue);\\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        reduced.resize(n,false);\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        int res=0;\\n        for(auto it:trips){\\n            res+=tripCost(it[0],it[1],-1,0,price);\\n        }\\n\\n        res-=reduceCost(0,0,price);\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427814,
                "title": "tag-easy-double-dfs-pre-computation-node-decision-to-color-or-not",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Pre-computation\\n2. DFS\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Pre-compute all nodes cost visited in every path.\\n2. Put 0 cost for non visited nodes.\\n3. Apply dfs from any node (say 0).\\n4. Decide whether to color current node or not on the go.\\n5. If you decide to color current node, then select all non-colored values from child nodes.\\n6. If you decide to not color current node, then select minimum value from colored and non-colored value for each child nodes.\\n7. Finally return the minimum value from calculate pair.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N*N)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(int start, int end, vector<vector<int>> &edge, vector<int> &par, vector<int> &vis) {\\n        vis[start] = 1;\\n        for (auto x:edge[start]) {\\n            if (!vis[x]) {\\n                dfs(x, end, edge, par, vis);\\n                par[x] = start;\\n            }\\n        }\\n    }\\n\\n    pair<int, int> dfs_ans(int curr, int par, vector<vector<int>> &edge, vector<int> &price) {\\n        vector<int> colored;\\n        vector<int> non_colored;\\n        for (auto x:edge[curr]) {\\n            if (x!=par) {\\n                pair<int, int> p = dfs_ans(x, curr, edge, price);\\n                colored.push_back(p.first);\\n                non_colored.push_back(p.second);\\n            }\\n        }\\n        pair<int, int> p;\\n        // if current node is colored.\\n        p.first = price[curr]/2;\\n        for (auto x:non_colored) p.first += x;\\n\\n        // if current node is not colored.\\n        p.second = price[curr];\\n        for (int i=0;i<colored.size(); ++i) {\\n            p.second += min(colored[i], non_colored[i]);\\n        }\\n        return p;\\n    }\\n\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> newPrice(n, 0);\\n        vector<vector<int>> v(n, vector<int>());\\n        for (auto x: edges) {\\n            v[x[0]].push_back(x[1]);\\n            v[x[1]].push_back(x[0]);\\n        }\\n        for (auto trip:trips) {\\n            vector<int> par(n, -1), vis(n, 0);\\n            dfs(trip[0], trip[1], v, par, vis);\\n            int c = trip[1];\\n            while(c!=-1) {\\n                newPrice[c]+=price[c];\\n                c = par[c];\\n            }\\n        }\\n        pair<int, int> p = dfs_ans(0, -1, v, newPrice);\\n        return min(p.first, p.second);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(int start, int end, vector<vector<int>> &edge, vector<int> &par, vector<int> &vis) {\\n        vis[start] = 1;\\n        for (auto x:edge[start]) {\\n            if (!vis[x]) {\\n                dfs(x, end, edge, par, vis);\\n                par[x] = start;\\n            }\\n        }\\n    }\\n\\n    pair<int, int> dfs_ans(int curr, int par, vector<vector<int>> &edge, vector<int> &price) {\\n        vector<int> colored;\\n        vector<int> non_colored;\\n        for (auto x:edge[curr]) {\\n            if (x!=par) {\\n                pair<int, int> p = dfs_ans(x, curr, edge, price);\\n                colored.push_back(p.first);\\n                non_colored.push_back(p.second);\\n            }\\n        }\\n        pair<int, int> p;\\n        // if current node is colored.\\n        p.first = price[curr]/2;\\n        for (auto x:non_colored) p.first += x;\\n\\n        // if current node is not colored.\\n        p.second = price[curr];\\n        for (int i=0;i<colored.size(); ++i) {\\n            p.second += min(colored[i], non_colored[i]);\\n        }\\n        return p;\\n    }\\n\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> newPrice(n, 0);\\n        vector<vector<int>> v(n, vector<int>());\\n        for (auto x: edges) {\\n            v[x[0]].push_back(x[1]);\\n            v[x[1]].push_back(x[0]);\\n        }\\n        for (auto trip:trips) {\\n            vector<int> par(n, -1), vis(n, 0);\\n            dfs(trip[0], trip[1], v, par, vis);\\n            int c = trip[1];\\n            while(c!=-1) {\\n                newPrice[c]+=price[c];\\n                c = par[c];\\n            }\\n        }\\n        pair<int, int> p = dfs_ans(0, -1, v, newPrice);\\n        return min(p.first, p.second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427637,
                "title": "python3-variant-of-robber-problem",
                "content": "# Explanation\\n\\nIgnoring the addition of trips, this problem is identical [House Robber iii](https://leetcode.com/problems/house-robber-iii/description/), except that we want to minimize the total cost and that \"robbing\" involves taking half of a node\\'s cost vs \"not robbing\" involves taking the entire node\\'s cost.\\n\\nIn order to account for the `trips` given, we can adopt a greedy approach; simply count the number of times each node is used among all trips and factor in this frequency in the robber calculation. Note that for each given trip, there\\'s exactly one path between the nodes because the graph is a tree.\\n\\n# Code\\n```\\nclass Solution:\\n    class TreeNode:\\n        def __init__(self, node_id, val):\\n            self._id = node_id\\n            self._val = val\\n            self._children = []\\n            self._parent = None\\n\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        self.setup(n, edges, price, trips)\\n        root_robbed, root_not_robbed = self.robber(self._root)\\n        return root_robbed\\n\\n    def robber(self, root):\\n        \"\"\"\\n        Returns [max_result_if_root_is_robbed, max_result_if_root_is_not_robbed]\\n        \"\"\"\\n        frq = self._node_counts[root] # contribution of this node is determined based on the number of times it\\'s visited over all trips\\n        amt_robbed = root._val // 2 * frq # suppose we rob; robbing in this case is halving the price and wanting to minimize the total price\\n        amt_not_robbed = root._val * frq # suppose we don\\'t rob; take the full amount\\n        for child in root._children:\\n            amt_if_child_robbed, amt_if_child_not_robbed = self.robber(child)\\n            amt_robbed += amt_if_child_not_robbed\\n            amt_not_robbed += amt_if_child_robbed\\n\\n        amt_robbed = min(amt_robbed, amt_not_robbed) # if we do rob, can send the lesser up anyways\\n        # print(f\"At node {root._id}, have rob: {amt_robbed}, not robbed: {amt_not_robbed}\")\\n        return (amt_robbed, amt_not_robbed)\\n\\n    def setup(self, n, edges, price, trips):\\n        \"\"\"\\n        Set up tree + initialize built-in members\\n        \"\"\"\\n        adj_list = [[] for _ in range(n)]\\n        for edge in edges:\\n            u, v = edge[0], edge[1]\\n            adj_list[u].append(v)\\n            adj_list[v].append(u)\\n\\n        seen = set([0])\\n        self._id_to_node = {}\\n        self._root = self.build(0, adj_list, seen, price)\\n        self._node_counts = Counter() # node_counts[node] = # times node appears in all trips\\n        for trip in trips:\\n            u, v = trip[0], trip[1]\\n            self.mark(self._id_to_node[u], self._id_to_node[v])\\n\\n    def build(self, root_id, adj_list, seen, price):\\n        root = self.TreeNode(root_id, price[root_id])\\n        self._id_to_node[root_id] = root\\n        for nb_id in adj_list[root_id]:\\n            if nb_id not in seen:\\n                seen.add(nb_id)\\n                nb = self.build(nb_id, adj_list, seen, price)\\n                nb._parent = root\\n                root._children.append(nb)\\n\\n        return root\\n\\n    def mark(self, node1, node2):\\n        \"\"\"\\n        Update frequency of nodes seen in path from node1 to node2.\\n        Because it\\'s a tree we can do this by manually walking up to the LCA and\\n        can guarantee that an LCA is found (at worst it\\'s the root)\\n        \"\"\"\\n        # Find LCA by looking at the depths of both targets\\n        node1_depth = self.get_level(self._root, node1, 0)\\n        node2_depth = self.get_level(self._root, node2, 0)\\n        d1, c1 = node1_depth, node1\\n        d2, c2 = node2_depth, node2\\n        while d1 > d2: # get c1 to align with c2\\n            self._node_counts[c1] += 1\\n            c1 = c1._parent\\n            d1 -= 1\\n        while d2 > d1 and c1 is not None: # otherwise get c2 to align with c1\\n            self._node_counts[c2] += 1\\n            c2 = c2._parent\\n            d2 -= 1\\n        while c1 != c2: # walk together until they both match\\n            self._node_counts[c1] += 1\\n            self._node_counts[c2] += 1\\n            c1 = c1._parent\\n            c2 = c2._parent\\n\\n        self._node_counts[c1] += 1 # c1 == c2 == LCA; note we increment LCA only once to not double count.\\n\\n    def get_level(self, root, target, depth):\\n        if root == target:\\n            return depth\\n\\n        for child in root._children:\\n            found_depth = self.get_level(child, target, depth + 1)\\n            if found_depth != -1:\\n                return found_depth\\n\\n        return -1\\n```\\n\\n# Implementation\\nThe code is a bit long, but this is mainly because I ended up explicitly creating a `TreeNode` object to represent the input graph. This can be avoided through the use of a few hashmaps but I found it easier to follow the logic this way.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    class TreeNode:\\n        def __init__(self, node_id, val):\\n            self._id = node_id\\n            self._val = val\\n            self._children = []\\n            self._parent = None\\n\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        self.setup(n, edges, price, trips)\\n        root_robbed, root_not_robbed = self.robber(self._root)\\n        return root_robbed\\n\\n    def robber(self, root):\\n        \"\"\"\\n        Returns [max_result_if_root_is_robbed, max_result_if_root_is_not_robbed]\\n        \"\"\"\\n        frq = self._node_counts[root] # contribution of this node is determined based on the number of times it\\'s visited over all trips\\n        amt_robbed = root._val // 2 * frq # suppose we rob; robbing in this case is halving the price and wanting to minimize the total price\\n        amt_not_robbed = root._val * frq # suppose we don\\'t rob; take the full amount\\n        for child in root._children:\\n            amt_if_child_robbed, amt_if_child_not_robbed = self.robber(child)\\n            amt_robbed += amt_if_child_not_robbed\\n            amt_not_robbed += amt_if_child_robbed\\n\\n        amt_robbed = min(amt_robbed, amt_not_robbed) # if we do rob, can send the lesser up anyways\\n        # print(f\"At node {root._id}, have rob: {amt_robbed}, not robbed: {amt_not_robbed}\")\\n        return (amt_robbed, amt_not_robbed)\\n\\n    def setup(self, n, edges, price, trips):\\n        \"\"\"\\n        Set up tree + initialize built-in members\\n        \"\"\"\\n        adj_list = [[] for _ in range(n)]\\n        for edge in edges:\\n            u, v = edge[0], edge[1]\\n            adj_list[u].append(v)\\n            adj_list[v].append(u)\\n\\n        seen = set([0])\\n        self._id_to_node = {}\\n        self._root = self.build(0, adj_list, seen, price)\\n        self._node_counts = Counter() # node_counts[node] = # times node appears in all trips\\n        for trip in trips:\\n            u, v = trip[0], trip[1]\\n            self.mark(self._id_to_node[u], self._id_to_node[v])\\n\\n    def build(self, root_id, adj_list, seen, price):\\n        root = self.TreeNode(root_id, price[root_id])\\n        self._id_to_node[root_id] = root\\n        for nb_id in adj_list[root_id]:\\n            if nb_id not in seen:\\n                seen.add(nb_id)\\n                nb = self.build(nb_id, adj_list, seen, price)\\n                nb._parent = root\\n                root._children.append(nb)\\n\\n        return root\\n\\n    def mark(self, node1, node2):\\n        \"\"\"\\n        Update frequency of nodes seen in path from node1 to node2.\\n        Because it\\'s a tree we can do this by manually walking up to the LCA and\\n        can guarantee that an LCA is found (at worst it\\'s the root)\\n        \"\"\"\\n        # Find LCA by looking at the depths of both targets\\n        node1_depth = self.get_level(self._root, node1, 0)\\n        node2_depth = self.get_level(self._root, node2, 0)\\n        d1, c1 = node1_depth, node1\\n        d2, c2 = node2_depth, node2\\n        while d1 > d2: # get c1 to align with c2\\n            self._node_counts[c1] += 1\\n            c1 = c1._parent\\n            d1 -= 1\\n        while d2 > d1 and c1 is not None: # otherwise get c2 to align with c1\\n            self._node_counts[c2] += 1\\n            c2 = c2._parent\\n            d2 -= 1\\n        while c1 != c2: # walk together until they both match\\n            self._node_counts[c1] += 1\\n            self._node_counts[c2] += 1\\n            c1 = c1._parent\\n            c2 = c2._parent\\n\\n        self._node_counts[c1] += 1 # c1 == c2 == LCA; note we increment LCA only once to not double count.\\n\\n    def get_level(self, root, target, depth):\\n        if root == target:\\n            return depth\\n\\n        for child in root._children:\\n            found_depth = self.get_level(child, target, depth + 1)\\n            if found_depth != -1:\\n                return found_depth\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427453,
                "title": "self-explanatory-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int, vector<int>>mp;\\n    map<int, int>parent, level, actualPrice;\\n    vector<int>makeHalf, notHalf;\\n    void AssignLevelAndParent(int root, \\n    int currentLevel, \\n    int parentNode)\\n    {\\n        level[root] = currentLevel;\\n        parent[root] = parentNode;\\n        for(auto &child : mp[root])\\n        {\\n            if(child == parentNode)continue;\\n            AssignLevelAndParent(child, currentLevel + 1, root);\\n        }\\n\\n    }\\n    void ModifyPrice(vector<int>&price, int u, int v)\\n    {\\n        while(level[u] > level[v])\\n        {\\n            //u is down to v\\n            actualPrice[u] += price[u];\\n            u = parent[u];\\n        }\\n        while(level[v] > level[u])\\n        {\\n            //v is down to u\\n            actualPrice[v] += price[v];\\n            v = parent[v];\\n        }\\n        while(u != v)\\n        {\\n            actualPrice[u] += price[u];\\n            actualPrice[v] += price[v];\\n            u = parent[u]; v = parent[v];\\n        }\\n        actualPrice[u] += price[u];\\n\\n    }\\n    int FindMinSum(int root, int parentNode, bool half)\\n    {\\n        if(half)\\n        {\\n            if(makeHalf[root] != -1)return makeHalf[root];\\n            int answer = 0;\\n            answer += actualPrice[root] / 2;\\n            for(auto &child : mp[root])\\n            {\\n                if(child == parentNode)continue;\\n                answer += FindMinSum(child, root, false);\\n            }\\n            return makeHalf[root] = answer;\\n            \\n        }\\n        else{\\n            if(notHalf[root] != -1)return notHalf[root];\\n            int answer = 0;\\n            answer += actualPrice[root];\\n            for(auto &child : mp[root])\\n            {\\n                if(child == parentNode)continue;\\n                answer += min(FindMinSum(child, root, false),\\n                FindMinSum(child, root, true));\\n            }\\n            return notHalf[root] = answer;\\n        }\\n    }\\n    int minimumTotalPrice(int n, \\n    vector<vector<int>>& edges, \\n    vector<int>& price, \\n    vector<vector<int>>& trips) {\\n        for(auto &edge : edges)\\n        {\\n            int u = edge[0], v = edge[1];\\n            mp[u].push_back(v);\\n            mp[v].push_back(u);\\n        }\\n        AssignLevelAndParent(0, 0, -1);\\n        for(auto &trip : trips)\\n        {\\n            int u = trip[0], v = trip[1];\\n            ModifyPrice(price, u, v);\\n        }\\n        makeHalf.resize(n, -1);\\n        notHalf.resize(n, -1);\\n        return min(FindMinSum(0, -1, true), FindMinSum(0, -1 , false));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int, vector<int>>mp;\\n    map<int, int>parent, level, actualPrice;\\n    vector<int>makeHalf, notHalf;\\n    void AssignLevelAndParent(int root, \\n    int currentLevel, \\n    int parentNode)\\n    {\\n        level[root] = currentLevel;\\n        parent[root] = parentNode;\\n        for(auto &child : mp[root])\\n        {\\n            if(child == parentNode)continue;\\n            AssignLevelAndParent(child, currentLevel + 1, root);\\n        }\\n\\n    }\\n    void ModifyPrice(vector<int>&price, int u, int v)\\n    {\\n        while(level[u] > level[v])\\n        {\\n            //u is down to v\\n            actualPrice[u] += price[u];\\n            u = parent[u];\\n        }\\n        while(level[v] > level[u])\\n        {\\n            //v is down to u\\n            actualPrice[v] += price[v];\\n            v = parent[v];\\n        }\\n        while(u != v)\\n        {\\n            actualPrice[u] += price[u];\\n            actualPrice[v] += price[v];\\n            u = parent[u]; v = parent[v];\\n        }\\n        actualPrice[u] += price[u];\\n\\n    }\\n    int FindMinSum(int root, int parentNode, bool half)\\n    {\\n        if(half)\\n        {\\n            if(makeHalf[root] != -1)return makeHalf[root];\\n            int answer = 0;\\n            answer += actualPrice[root] / 2;\\n            for(auto &child : mp[root])\\n            {\\n                if(child == parentNode)continue;\\n                answer += FindMinSum(child, root, false);\\n            }\\n            return makeHalf[root] = answer;\\n            \\n        }\\n        else{\\n            if(notHalf[root] != -1)return notHalf[root];\\n            int answer = 0;\\n            answer += actualPrice[root];\\n            for(auto &child : mp[root])\\n            {\\n                if(child == parentNode)continue;\\n                answer += min(FindMinSum(child, root, false),\\n                FindMinSum(child, root, true));\\n            }\\n            return notHalf[root] = answer;\\n        }\\n    }\\n    int minimumTotalPrice(int n, \\n    vector<vector<int>>& edges, \\n    vector<int>& price, \\n    vector<vector<int>>& trips) {\\n        for(auto &edge : edges)\\n        {\\n            int u = edge[0], v = edge[1];\\n            mp[u].push_back(v);\\n            mp[v].push_back(u);\\n        }\\n        AssignLevelAndParent(0, 0, -1);\\n        for(auto &trip : trips)\\n        {\\n            int u = trip[0], v = trip[1];\\n            ModifyPrice(price, u, v);\\n        }\\n        makeHalf.resize(n, -1);\\n        notHalf.resize(n, -1);\\n        return min(FindMinSum(0, -1, true), FindMinSum(0, -1 , false));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427334,
                "title": "python-dfs-dp",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\nfrom functools import cache\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        G = defaultdict(list)\\n        for v,w in edges:\\n            G[v].append(w)\\n            G[w].append(v)\\n        counter = Counter()\\n        def dfs(v, target, visited, pred):\\n            if v == target: return True\\n            if v in visited: return False\\n            visited.add(v)\\n            for w in G[v]:\\n                if w not in visited:\\n                    pred[w] = v\\n                    if dfs(w, target, visited, pred): return True\\n            return False\\n        for v, w in trips:\\n            pred = defaultdict(lambda:-1)\\n            dfs(v, w, set(), pred)\\n            counter[w] += 1\\n            while pred[w] != -1:\\n                w = pred[w]\\n                counter[w] += 1\\n        @cache\\n        def DFS(u, v, isParentReduced):\\n            if isParentReduced:\\n                res = counter[v]*price[v]\\n                for w in G[v]:\\n                    if w == u: continue\\n                    res += DFS(v, w, False)\\n                return res\\n            res1 = counter[v]*price[v]//2\\n            for w in G[v]:\\n                if w == u: continue\\n                res1 += DFS(v, w, True)\\n            res2 = counter[v]*price[v]\\n            for w in G[v]:\\n                if w == u: continue\\n                res2 += DFS(v, w, False)\\n            return min(res1, res2)\\n        return DFS(-1, 0, False)\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom functools import cache\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        G = defaultdict(list)\\n        for v,w in edges:\\n            G[v].append(w)\\n            G[w].append(v)\\n        counter = Counter()\\n        def dfs(v, target, visited, pred):\\n            if v == target: return True\\n            if v in visited: return False\\n            visited.add(v)\\n            for w in G[v]:\\n                if w not in visited:\\n                    pred[w] = v\\n                    if dfs(w, target, visited, pred): return True\\n            return False\\n        for v, w in trips:\\n            pred = defaultdict(lambda:-1)\\n            dfs(v, w, set(), pred)\\n            counter[w] += 1\\n            while pred[w] != -1:\\n                w = pred[w]\\n                counter[w] += 1\\n        @cache\\n        def DFS(u, v, isParentReduced):\\n            if isParentReduced:\\n                res = counter[v]*price[v]\\n                for w in G[v]:\\n                    if w == u: continue\\n                    res += DFS(v, w, False)\\n                return res\\n            res1 = counter[v]*price[v]//2\\n            for w in G[v]:\\n                if w == u: continue\\n                res1 += DFS(v, w, True)\\n            res2 = counter[v]*price[v]\\n            for w in G[v]:\\n                if w == u: continue\\n                res2 += DFS(v, w, False)\\n            return min(res1, res2)\\n        return DFS(-1, 0, False)\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427204,
                "title": "easy-readable-dp-dfs-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter reading ques the first thing that click was i will have to try all ways . Hints to use recursion . \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nQ1 : Do I have to calculate trip cost at every traversal ?\\nAns :- I came up with solution why not calculate total trip cost and calculated every node in total trip . \\nNow tries to find max cost that i can reduce . \\n\\nQ2 : How to write recursion ?\\n   \\nAt every node i can pick it or not pick it . If i picked then price cut will be updated . \\nAlso have to maintain pick variable to find out parent is picked or not . \\n\\nQ3 : Reduce Tc ? \\nOnce the recursive code is working just memoize it . \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n\\n    int solve(int ind  , int pick , vector<vector<int>> &adj ,  vector<int>&visited , vector<int>& price , vector<int>&freq , vector<vector<int>>&dp){\\n             \\n             if(visited[ind]) return 0 ; \\n             if(dp[ind][pick] != -1) return dp[ind][pick] ; \\n             if(pick){\\n                int a = 0 ; \\n                visited[ind] =1 ; \\n                for(auto x : adj[ind]){\\n                    if(!visited[x]){\\n                        a += solve(x , 0 , adj , visited , price , freq , dp ) ; \\n                    }\\n                    \\n                }\\n                visited[ind] = 0 ; \\n                return dp[ind][pick] =  a ; \\n             }\\n             else{\\n\\n                int a = 0  , b = 0 ; \\n                visited[ind] =1 ; \\n                for(auto x : adj[ind]){\\n                    if(!visited[x]){\\n                        a += solve(x , 0 , adj , visited , price , freq , dp  ) ; \\n                    }\\n                }\\n               \\n               b += price[ind]*freq[ind]*0.5 ; \\n                for(auto x : adj[ind]){\\n                   if(!visited[x]){\\n                        b += solve(x , 1 , adj , visited , price , freq , dp ) ; \\n                    }\\n                }\\n                visited[ind] = 0 ; \\n\\n                 return dp[ind][pick] =  max(a , b ) ; \\n\\n             }\\n\\n             return 0 ; \\n    }\\n\\n\\n    bool dfs(int src , int dest , vector<vector<int>> &adj ,vector<int>& price , vector<int>&freq  ,  int par , int &temp   ){\\n         \\n         if(src == dest){\\n             freq[src]++; \\n             temp += price[dest] ; \\n             return true ;  \\n         }\\n\\n        \\n         temp  += price[src]  ;\\n         freq[src]++; \\n\\n         for(auto node : adj[src]){\\n             if(node != par){\\n                 bool check   = dfs(node , dest , adj , price , freq  , src , temp ) ; \\n                 if(check) return true ; \\n             }\\n         }\\n\\n         temp -= price[src] ; \\n         freq[src]-- ; \\n\\n\\n         return false  ; \\n     }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n\\n          vector<vector<int>> adj(n) ; \\n          vector<int>freq(n, 0 ) ; \\n          vector<int>visited(n , 0 ) ; \\n          vector<vector<int>>dp(n , vector<int>(2 , -1 )) ; \\n          for(int i = 0 ; i < edges.size() ; i++){\\n              int  u = edges[i][0] ; \\n              int v = edges[i][1] ; \\n\\n              adj[u].push_back(v) ; \\n              adj[v].push_back(u) ; \\n          } \\n\\n          int cost = 0 ; \\n\\n          for(int i = 0 ; i < trips.size() ; i++){\\n              int src = trips[i][0] ; \\n              int dest = trips[i][1] ; \\n              int temp = 0 ; \\n              int par = -1 ; \\n              bool a =  dfs(src ,dest , adj ,price , freq ,  par , temp  ) ; \\n              cost += temp ; \\n          }\\n          \\n\\n         \\n          int  cut = solve( 0 , 0 , adj , visited , price , freq , dp ) ; \\n\\n          return cost - cut ; \\n       \\n       }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\n    int solve(int ind  , int pick , vector<vector<int>> &adj ,  vector<int>&visited , vector<int>& price , vector<int>&freq , vector<vector<int>>&dp){\\n             \\n             if(visited[ind]) return 0 ; \\n             if(dp[ind][pick] != -1) return dp[ind][pick] ; \\n             if(pick){\\n                int a = 0 ; \\n                visited[ind] =1 ; \\n                for(auto x : adj[ind]){\\n                    if(!visited[x]){\\n                        a += solve(x , 0 , adj , visited , price , freq , dp ) ; \\n                    }\\n                    \\n                }\\n                visited[ind] = 0 ; \\n                return dp[ind][pick] =  a ; \\n             }\\n             else{\\n\\n                int a = 0  , b = 0 ; \\n                visited[ind] =1 ; \\n                for(auto x : adj[ind]){\\n                    if(!visited[x]){\\n                        a += solve(x , 0 , adj , visited , price , freq , dp  ) ; \\n                    }\\n                }\\n               \\n               b += price[ind]*freq[ind]*0.5 ; \\n                for(auto x : adj[ind]){\\n                   if(!visited[x]){\\n                        b += solve(x , 1 , adj , visited , price , freq , dp ) ; \\n                    }\\n                }\\n                visited[ind] = 0 ; \\n\\n                 return dp[ind][pick] =  max(a , b ) ; \\n\\n             }\\n\\n             return 0 ; \\n    }\\n\\n\\n    bool dfs(int src , int dest , vector<vector<int>> &adj ,vector<int>& price , vector<int>&freq  ,  int par , int &temp   ){\\n         \\n         if(src == dest){\\n             freq[src]++; \\n             temp += price[dest] ; \\n             return true ;  \\n         }\\n\\n        \\n         temp  += price[src]  ;\\n         freq[src]++; \\n\\n         for(auto node : adj[src]){\\n             if(node != par){\\n                 bool check   = dfs(node , dest , adj , price , freq  , src , temp ) ; \\n                 if(check) return true ; \\n             }\\n         }\\n\\n         temp -= price[src] ; \\n         freq[src]-- ; \\n\\n\\n         return false  ; \\n     }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n\\n          vector<vector<int>> adj(n) ; \\n          vector<int>freq(n, 0 ) ; \\n          vector<int>visited(n , 0 ) ; \\n          vector<vector<int>>dp(n , vector<int>(2 , -1 )) ; \\n          for(int i = 0 ; i < edges.size() ; i++){\\n              int  u = edges[i][0] ; \\n              int v = edges[i][1] ; \\n\\n              adj[u].push_back(v) ; \\n              adj[v].push_back(u) ; \\n          } \\n\\n          int cost = 0 ; \\n\\n          for(int i = 0 ; i < trips.size() ; i++){\\n              int src = trips[i][0] ; \\n              int dest = trips[i][1] ; \\n              int temp = 0 ; \\n              int par = -1 ; \\n              bool a =  dfs(src ,dest , adj ,price , freq ,  par , temp  ) ; \\n              cost += temp ; \\n          }\\n          \\n\\n         \\n          int  cut = solve( 0 , 0 , adj , visited , price , freq , dp ) ; \\n\\n          return cost - cut ; \\n       \\n       }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426658,
                "title": "c-dfs-dp-100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>list[50];\\n    int cnt[50];\\n    \\n    int f_visit(int cur, int end, int par) {\\n        ++cnt[cur];\\n        if(cur == end) return end;\\n        int e = -1;\\n        for(int next : list[cur]){\\n            if(next == par) continue;\\n            e = f_visit(next, end, cur);\\n            if(e == end) return e;\\n            if(e != end) --cnt[next];\\n        }\\n        return e;\\n    }\\n    \\n    int f_min(int a, int b) {\\n        if(a < b) return a;\\n        return b;\\n    }\\n    \\n    int dp[50][2];\\n    void f_get_min(int cur, int par, vector<int>& price) {                \\n        for(int next : list[cur]) {\\n            if(next == par) continue;\\n            f_get_min(next, cur, price);\\n        }\\n                \\n        for(int next : list[cur]) {\\n            if(next == par) continue;\\n            dp[cur][0] += f_min(dp[next][0] , dp[next][1]);\\n            dp[cur][1] += dp[next][0];\\n        }\\n        \\n        dp[cur][0] += price[cur] * cnt[cur];\\n        dp[cur][1] += (price[cur] / 2) * cnt[cur];\\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        for(vector<int> &cur : edges) {\\n            list[cur[0]].push_back(cur[1]);\\n            list[cur[1]].push_back(cur[0]);\\n        }\\n        \\n        for(vector<int> &cur : trips) f_visit(cur[0], cur[1], -1);\\n\\n        // total_sum\\n        int tot_sum = 0;\\n        for (int i = 0; i < n; ++i) tot_sum += price[i] * cnt[i];\\n        \\n        f_get_min(0, -1, price);\\n        \\n        return f_min(dp[0][0], dp[0][1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>list[50];\\n    int cnt[50];\\n    \\n    int f_visit(int cur, int end, int par) {\\n        ++cnt[cur];\\n        if(cur == end) return end;\\n        int e = -1;\\n        for(int next : list[cur]){\\n            if(next == par) continue;\\n            e = f_visit(next, end, cur);\\n            if(e == end) return e;\\n            if(e != end) --cnt[next];\\n        }\\n        return e;\\n    }\\n    \\n    int f_min(int a, int b) {\\n        if(a < b) return a;\\n        return b;\\n    }\\n    \\n    int dp[50][2];\\n    void f_get_min(int cur, int par, vector<int>& price) {                \\n        for(int next : list[cur]) {\\n            if(next == par) continue;\\n            f_get_min(next, cur, price);\\n        }\\n                \\n        for(int next : list[cur]) {\\n            if(next == par) continue;\\n            dp[cur][0] += f_min(dp[next][0] , dp[next][1]);\\n            dp[cur][1] += dp[next][0];\\n        }\\n        \\n        dp[cur][0] += price[cur] * cnt[cur];\\n        dp[cur][1] += (price[cur] / 2) * cnt[cur];\\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        for(vector<int> &cur : edges) {\\n            list[cur[0]].push_back(cur[1]);\\n            list[cur[1]].push_back(cur[0]);\\n        }\\n        \\n        for(vector<int> &cur : trips) f_visit(cur[0], cur[1], -1);\\n\\n        // total_sum\\n        int tot_sum = 0;\\n        for (int i = 0; i < n; ++i) tot_sum += price[i] * cnt[i];\\n        \\n        f_get_min(0, -1, price);\\n        \\n        return f_min(dp[0][0], dp[0][1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426389,
                "title": "complete-easy-explanation-dfs-x-dp-c",
                "content": "**Intuition**\\nThe questions asks for **minimum** total price sum and the contraint on n given is also small which gives us a direct hint that the question can be of ***Dynamic Programming***.\\n\\nNow DP usually goes with choices ie we can either have it or not have it. In this question we can either reduce the price of a particular node by half or we can keep it unchanged. Thus it will be suitable to have a 2d dp with the first state being the current node and the second state indicating whether the price of the current node is halfed or not. Initally every value of the 2d matrix will be -1.\\n\\nAnother good observation which we can make is with the trips matrix. Instead of calling dfs again and again for calculating the cost of the whole trip given a particular node is halfed (or not) will be very time consuming. Instead we can make use of the ***frequency array*** and add to the cost the value of price[u] * freq[u] or price[u]/2 * freq[u] and store it in our 2d dp matrix.\\n\\nThe frequency array can be calculated easily using a single ***dfs*** and checking at each step whether a particular child is able to reach destination via some path or not.\\n\\n***Code:***\\n\\n```class Solution {\\npublic:\\n    vector< vector < int>> adj, dp;\\n    vector < int> freq;\\n    \\n    bool dfs(int u, int p, int desti)\\n    {\\n        if (u == desti)\\n        {\\n            freq[u]++;\\n            return true;\\n        }\\n        \\n        for (auto v: adj[u])\\n        {\\n            if (v == p)\\n                continue;\\n            //Checking if child is able to reach destination\\n            if (dfs(v, u, desti))\\n            {\\n                freq[u]++;\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    int getMin (int u, bool isHalved, int parent, vector <int>& price)\\n    {\\n\\t\\t//Memoization\\n        if (dp[u][isHalved] != -1)\\n            return dp[u][isHalved];\\n        \\n        int cost = 0;\\n        for (auto v: adj[u])\\n        {\\n            if (v == parent)\\n                continue;\\n            if (isHalved)\\n                cost += getMin(v, false, u, price);\\n            else\\n                cost += min(getMin(v, false, u, price), getMin(v, true, u, price));\\n        }\\n        \\n        if (isHalved)\\n            dp[u][isHalved] = (price[u]/2 * freq[u]) + cost;\\n        else\\n            dp[u][isHalved] = (price[u] * freq[u]) + cost;\\n        \\n        return dp[u][isHalved];\\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n           \\n        adj = vector < vector < int>> (n);\\n        dp = vector < vector < int>> (n, vector < int> (2, -1));\\n        freq = vector < int> (n, 0);\\n        for (auto x:edges)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        \\n        for (auto x: trips)\\n            dfs(x[0], -1, x[1]);\\n        \\n        \\n        return min(getMin(0, true, -1, price), getMin(0, false, -1, price));\\n        \\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    vector< vector < int>> adj, dp;\\n    vector < int> freq;\\n    \\n    bool dfs(int u, int p, int desti)\\n    {\\n        if (u == desti)\\n        {\\n            freq[u]++;\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3426079,
                "title": "dfs-dp-easy-expalination-good-question-stucked-part-too-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAccording to question :\\n- I am finding out from teh path function the contribution of every node(helper vector) and what will be the sum of of the trips which will be visited by the trips (in ans ).\\n- Adjacent element can take ( more of hoyse robber problem I )\\n- I am finding the sum of highest contri which can be visited by the trips \\n- We need to count the contri of every node because if we only take that i have visited this elemnt(Then may be it is giving you the larger sum but the one which is contributng to smaller path sum have occured multiple time and increase the net sum )// I have stucked here only I was firstly taking out the vector which give me maxium sum and the n doing half the prices and checking for contri that is hectic for sure ... so if you too then comment now will never make this mistake .\\n- Now if i send the contri in the dp and according to it find out the what the maximum score till that particular node .\\n- Then we can simply take that value do the half of it and will delete from the net answer of trips  .\\n- ans -val(came from dp)/2 ;\\n- it amy occur to have the trips totally not connected with each other so you have to make that last loop so that you will not leave any trip .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n   I have expalined the approach above You can refer to it .\\n  Thanks for reading it \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    adj - matrix  =O(n) (As there are at max n-1 edges)\\n    trip-loop = O(n*t) ;// trips \\n    trip loop inside memoization & Dp array = O(n*2) ;\\n    //AT max will search for every node  ;\\n    Overall O(n*t) ;\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    adj - matrix  =O(n+N) (As there are at max n-1 edges)\\n    contribution matrix(repetation) = O(n);\\n    dp = O(n*2) ;\\n    Overall: =O(n);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool path(vector<vector<int>>& adj ,vector<int>& help , vector<int> & prices, int i ,  int end , int prev , int & ans  )\\n    {\\n        if(i==end)\\n        {\\n            help[i]++;\\n            ans+= prices[i] ;// total trip contri \\n            return true;\\n        }\\n        bool hey =false ;\\n        for( int j = 0 ;j<adj[i].size() ;j++)\\n        {\\n            if(adj[i][j]!=prev)\\n            {\\n                bool is =path(adj ,help, prices , adj[i][j]  , end , i ,ans); \\n                hey =hey|is ;\\n            }\\n        }\\n        if(hey )\\n        {\\n            help[i]++;\\n            ans += prices[i] ;\\n        }\\n        return hey ;\\n    }\\n\\n    int maximum_path(vector<vector<int>>& adj ,vector<int>& helper , vector<int>& prices , int i , bool me,int prev ,vector<vector<int>>& dp  )\\n    {\\n        if(dp[i][me]!=-1)\\n        {\\n            return dp[i][me] ;\\n        }\\n        int right =0 , left =0 ;\\n        for( int j=0;j<adj[i].size() ;j++)\\n        {\\n            if(adj[i][j]!=prev && helper[adj[i][j]]>0 )\\n            {\\n                if(me== false)\\n                {\\n                    left+=  maximum_path(adj , helper , prices ,adj[i][j] ,true , i ,dp);\\n                }\\n                right+=   maximum_path(adj , helper , prices, adj[i][j] , false , i,dp) ;\\n            }\\n         }  \\n         int k =left+(helper[i]*prices[i]);\\n         cout<<k<<\" \"<<right<<endl;\\n         if(k>right && me ==false )\\n         {\\n             dp[i][0] =k ; \\n             return dp[i][0] ;\\n         }\\n         else{\\n            dp[i][1]= right ;\\n            return dp[i][1];\\n         }\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> adj (n);\\n        for(auto p :edges)\\n        {\\n            adj[p[0]].push_back(p[1]);\\n            adj[p[1]].push_back(p[0]);\\n        }\\n        vector<int> repetation(n,0);\\n        int ans =0 ;\\n        for(auto trip:trips)\\n        {\\n            bool is= path(adj ,repetation, price, trip[0] , trip[1] , -1, ans  );\\n        }\\n        vector<vector<int>> dp(n ,vector<int>(2,-1));\\n        for(auto trip: trips)\\n        {\\n            if(dp[trip[0]][0]==-1 && dp[trip[0]][1]==-1)\\n            {\\n                int val = maximum_path(adj , repetation , price , trip[0] , false , -1 ,dp);\\n                cout<<val<<endl;\\n                ans= ans-val/2;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool path(vector<vector<int>>& adj ,vector<int>& help , vector<int> & prices, int i ,  int end , int prev , int & ans  )\\n    {\\n        if(i==end)\\n        {\\n            help[i]++;\\n            ans+= prices[i] ;// total trip contri \\n            return true;\\n        }\\n        bool hey =false ;\\n        for( int j = 0 ;j<adj[i].size() ;j++)\\n        {\\n            if(adj[i][j]!=prev)\\n            {\\n                bool is =path(adj ,help, prices , adj[i][j]  , end , i ,ans); \\n                hey =hey|is ;\\n            }\\n        }\\n        if(hey )\\n        {\\n            help[i]++;\\n            ans += prices[i] ;\\n        }\\n        return hey ;\\n    }\\n\\n    int maximum_path(vector<vector<int>>& adj ,vector<int>& helper , vector<int>& prices , int i , bool me,int prev ,vector<vector<int>>& dp  )\\n    {\\n        if(dp[i][me]!=-1)\\n        {\\n            return dp[i][me] ;\\n        }\\n        int right =0 , left =0 ;\\n        for( int j=0;j<adj[i].size() ;j++)\\n        {\\n            if(adj[i][j]!=prev && helper[adj[i][j]]>0 )\\n            {\\n                if(me== false)\\n                {\\n                    left+=  maximum_path(adj , helper , prices ,adj[i][j] ,true , i ,dp);\\n                }\\n                right+=   maximum_path(adj , helper , prices, adj[i][j] , false , i,dp) ;\\n            }\\n         }  \\n         int k =left+(helper[i]*prices[i]);\\n         cout<<k<<\" \"<<right<<endl;\\n         if(k>right && me ==false )\\n         {\\n             dp[i][0] =k ; \\n             return dp[i][0] ;\\n         }\\n         else{\\n            dp[i][1]= right ;\\n            return dp[i][1];\\n         }\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> adj (n);\\n        for(auto p :edges)\\n        {\\n            adj[p[0]].push_back(p[1]);\\n            adj[p[1]].push_back(p[0]);\\n        }\\n        vector<int> repetation(n,0);\\n        int ans =0 ;\\n        for(auto trip:trips)\\n        {\\n            bool is= path(adj ,repetation, price, trip[0] , trip[1] , -1, ans  );\\n        }\\n        vector<vector<int>> dp(n ,vector<int>(2,-1));\\n        for(auto trip: trips)\\n        {\\n            if(dp[trip[0]][0]==-1 && dp[trip[0]][1]==-1)\\n            {\\n                int val = maximum_path(adj , repetation , price , trip[0] , false , -1 ,dp);\\n                cout<<val<<endl;\\n                ans= ans-val/2;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3425378,
                "title": "dfs-each-trip-to-count-visits-dp-maximise-nodes-selected-on-savings-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> adj(n);\\n        for (auto & e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<int> c(n);\\n        for (auto & t : trips) {\\n            vector<bool> seen(n);\\n            stack<pair<int, vector<int>>> s;\\n            s.emplace(t[0], vector<int>());\\n            while (!s.empty()) {\\n                auto [cur, path] = s.top(); s.pop();\\n                if (seen[cur]) continue;\\n                seen[cur] = 1;\\n                vector<int> newpath(path);\\n                newpath.push_back(cur);\\n                if (cur == t[1]) {\\n                    for (int x : newpath) {\\n                        ++c[x];                        \\n                    }\\n                    break;\\n                }\\n                for (int x : adj[cur]) s.emplace(x, newpath);\\n            }\\n        }\\n        int cost = 0;\\n        for (int i = 0; i < n; ++i) {\\n            cost += price[i] * c[i];\\n        }\\n        Node* root = new Node(0, price[0] * c[0] / 2, 0);\\n        queue<Node*> s;\\n        s.push(root);\\n        while (!s.empty()) {\\n            auto cur = s.front(); s.pop();\\n            for (int j : adj[cur->id]) {\\n                if (cur->par == 0 || j != cur->par->id) {\\n                    Node* neW = new Node(j, price[j] * c[j] / 2, cur);\\n                    cur->child.push_back(neW);\\n                    s.push(neW);\\n                }\\n            }\\n        }\\n        int S = save(root);\\n        return cost - S;\\n    }\\n    struct Node {\\n        int id, val;\\n        vector<Node*> child;\\n        Node* par;\\n        Node(int i, int x, Node* p) : id(i), val(x), child(), par(p) {}\\n    };\\n    unordered_map<int, int> mem;\\n    int save(Node* u) {\\n        if (mem.count(u->id)) return mem[u->id];\\n        int donttake = 0, grand = 0;\\n        for (auto x : u->child) {\\n            donttake += save(x);\\n            for (auto y : x->child) {\\n                grand += save(y);\\n            }\\n        }\\n        mem[u->id] = max(u->val+grand, donttake);\\n        return mem[u->id];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> adj(n);\\n        for (auto & e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<int> c(n);\\n        for (auto & t : trips) {\\n            vector<bool> seen(n);\\n            stack<pair<int, vector<int>>> s;\\n            s.emplace(t[0], vector<int>());\\n            while (!s.empty()) {\\n                auto [cur, path] = s.top(); s.pop();\\n                if (seen[cur]) continue;\\n                seen[cur] = 1;\\n                vector<int> newpath(path);\\n                newpath.push_back(cur);\\n                if (cur == t[1]) {\\n                    for (int x : newpath) {\\n                        ++c[x];                        \\n                    }\\n                    break;\\n                }\\n                for (int x : adj[cur]) s.emplace(x, newpath);\\n            }\\n        }\\n        int cost = 0;\\n        for (int i = 0; i < n; ++i) {\\n            cost += price[i] * c[i];\\n        }\\n        Node* root = new Node(0, price[0] * c[0] / 2, 0);\\n        queue<Node*> s;\\n        s.push(root);\\n        while (!s.empty()) {\\n            auto cur = s.front(); s.pop();\\n            for (int j : adj[cur->id]) {\\n                if (cur->par == 0 || j != cur->par->id) {\\n                    Node* neW = new Node(j, price[j] * c[j] / 2, cur);\\n                    cur->child.push_back(neW);\\n                    s.push(neW);\\n                }\\n            }\\n        }\\n        int S = save(root);\\n        return cost - S;\\n    }\\n    struct Node {\\n        int id, val;\\n        vector<Node*> child;\\n        Node* par;\\n        Node(int i, int x, Node* p) : id(i), val(x), child(), par(p) {}\\n    };\\n    unordered_map<int, int> mem;\\n    int save(Node* u) {\\n        if (mem.count(u->id)) return mem[u->id];\\n        int donttake = 0, grand = 0;\\n        for (auto x : u->child) {\\n            donttake += save(x);\\n            for (auto y : x->child) {\\n                grand += save(y);\\n            }\\n        }\\n        mem[u->id] = max(u->val+grand, donttake);\\n        return mem[u->id];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425374,
                "title": "c-dfs-dp",
                "content": "```\\nclass Solution {\\npublic:\\n  \\n  // All the solution info.\\n  int n = -1;\\n  vector<int> price;\\n  vector<unordered_set<int>> tree;\\n  unordered_map<int, int> freq;\\n  \\n  \\n  int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& prc, vector<vector<int>>& trips) {\\n    // Record all info.\\n    this->n = n;\\n    tree.resize(n);\\n    price = move(prc);\\n    for (auto& edge : edges) {\\n      tree[edge[0]].insert(edge[1]);\\n      tree[edge[1]].insert(edge[0]);\\n    }\\n    \\n    // Find how many times each node is visited\\n    // for all the paths through DFS.\\n    for (auto& trip : trips) {\\n      // trip[0] can be the root of the tree with\\n      // -1 as parent since it doesn\\'t matter.\\n      dfs(trip[0], trip[1], -1);\\n    }\\n    \\n    // Get any leaf node with children <= 1 as root.\\n    int root = getAnyLeaf();\\n    \\n    // Initialize the caches for DP.\\n    withHalving = vector<int>(n, -1);\\n    withoutHalving = vector<int>(n, -1);\\n    \\n    // Get the optimal halving strategy.\\n    return min(getMin(root, true, -1),\\n               getMin(root, false, -1));\\n  }\\n  \\n  bool dfs(int idx, int dst, int parent) {\\n    // We have reached the destination.\\n    if (idx == dst) {\\n      freq[idx]++;\\n      return true;\\n    }\\n    \\n    for (int child : tree[idx]) {\\n      if (child == parent)\\n        continue;\\n      // Check if child is able to reach the destination.\\n      if (dfs(child, dst, idx)) {\\n        freq[idx]++;\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n  \\n  /*\\n  Use DP to get the best halving strategy.\\n  For each node, we can either halve it or not.\\n  If we halve it, we cannot halve the child.\\n  If we don\\'t halve it, then we have a choice for\\n  the child.\\n  We can cache the result based on whether we halve\\n  it or not.\\n  */ \\n  vector<int> withHalving, withoutHalving;\\n  int getMin(int idx, bool with, int parent) {\\n    if (with && withHalving[idx] != -1) {\\n      return withHalving[idx];\\n    }\\n    if (!with && withoutHalving[idx] != -1) {\\n      return withoutHalving[idx];\\n    }\\n    int childCost = 0;\\n    for (int child : tree[idx]) {\\n      if (child == parent) continue;\\n      if (with) {\\n        childCost += getMin(child, false, idx);\\n      } else {\\n        childCost += min(getMin(child, true, idx),\\n                         getMin(child, false, idx));\\n      }\\n    }\\n    if (with) {\\n      int cost = (0.5 * price[idx] * freq[idx]) + childCost;\\n      withHalving[idx] = cost;\\n      return cost;\\n    } else {\\n      int cost = (price[idx] * freq[idx]) + childCost;\\n      withoutHalving[idx] = cost;\\n      return cost;\\n    }\\n  }\\n  \\n  // Helper function for getting any leaf.\\n  int getAnyLeaf() {\\n    for (int i = 0; i < n; ++i) {\\n      if (tree[i].size() <= 1) return i;\\n    }\\n    return -1;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n  // All the solution info.\\n  int n = -1;\\n  vector<int> price;\\n  vector<unordered_set<int>> tree;\\n  unordered_map<int, int> freq;\\n  \\n  \\n  int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& prc, vector<vector<int>>& trips) {\\n    // Record all info.\\n    this->n = n;\\n    tree.resize(n);\\n    price = move(prc);\\n    for (auto& edge : edges) {\\n      tree[edge[0]].insert(edge[1]);\\n      tree[edge[1]].insert(edge[0]);\\n    }\\n    \\n    // Find how many times each node is visited\\n    // for all the paths through DFS.\\n    for (auto& trip : trips) {\\n      // trip[0] can be the root of the tree with\\n      // -1 as parent since it doesn\\'t matter.\\n      dfs(trip[0], trip[1], -1);\\n    }\\n    \\n    // Get any leaf node with children <= 1 as root.\\n    int root = getAnyLeaf();\\n    \\n    // Initialize the caches for DP.\\n    withHalving = vector<int>(n, -1);\\n    withoutHalving = vector<int>(n, -1);\\n    \\n    // Get the optimal halving strategy.\\n    return min(getMin(root, true, -1),\\n               getMin(root, false, -1));\\n  }\\n  \\n  bool dfs(int idx, int dst, int parent) {\\n    // We have reached the destination.\\n    if (idx == dst) {\\n      freq[idx]++;\\n      return true;\\n    }\\n    \\n    for (int child : tree[idx]) {\\n      if (child == parent)\\n        continue;\\n      // Check if child is able to reach the destination.\\n      if (dfs(child, dst, idx)) {\\n        freq[idx]++;\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n  \\n  /*\\n  Use DP to get the best halving strategy.\\n  For each node, we can either halve it or not.\\n  If we halve it, we cannot halve the child.\\n  If we don\\'t halve it, then we have a choice for\\n  the child.\\n  We can cache the result based on whether we halve\\n  it or not.\\n  */ \\n  vector<int> withHalving, withoutHalving;\\n  int getMin(int idx, bool with, int parent) {\\n    if (with && withHalving[idx] != -1) {\\n      return withHalving[idx];\\n    }\\n    if (!with && withoutHalving[idx] != -1) {\\n      return withoutHalving[idx];\\n    }\\n    int childCost = 0;\\n    for (int child : tree[idx]) {\\n      if (child == parent) continue;\\n      if (with) {\\n        childCost += getMin(child, false, idx);\\n      } else {\\n        childCost += min(getMin(child, true, idx),\\n                         getMin(child, false, idx));\\n      }\\n    }\\n    if (with) {\\n      int cost = (0.5 * price[idx] * freq[idx]) + childCost;\\n      withHalving[idx] = cost;\\n      return cost;\\n    } else {\\n      int cost = (price[idx] * freq[idx]) + childCost;\\n      withoutHalving[idx] = cost;\\n      return cost;\\n    }\\n  }\\n  \\n  // Helper function for getting any leaf.\\n  int getAnyLeaf() {\\n    for (int i = 0; i < n; ++i) {\\n      if (tree[i].size() <= 1) return i;\\n    }\\n    return -1;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425098,
                "title": "tree-dp-nearest-common-ancestor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1 Build path to root\\n2 Find shortest path between Two nodes and get total count of each node\\n3 DP for minimal\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> cnt;\\n    vector<vector<int>> es;\\n    vector<vector<int>> ps;\\n    vector<vector<int>> dp;\\n    void dfs(int c, int p, vector<int>& path) {\\n        path.push_back(c);\\n        ps[c] = path;\\n        for (auto& child : es[c]) {\\n            if (child == p) continue;\\n            dfs(child, c, path);\\n        }\\n        path.pop_back();\\n    }\\n    \\n    int dfs(int i, int p, vector<int>& pc, int j) {\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int& cur = dp[i][j];\\n        cur = INT_MAX;\\n        if (j == 0) {\\n            cur = (pc[i] / 2) * cnt[i];\\n            for (auto& c : es[i])  {\\n                if (c == p) continue;\\n                cur += dfs(c, i, pc, 1);\\n            }\\n        }\\n        int a = pc[i] * cnt[i];\\n        for (auto& c : es[i])  {\\n            if (c == p) continue;\\n                a += dfs(c, i, pc, 0);\\n        }\\n        cur = min(a, cur);\\n        return cur;\\n    }\\n    int minimumTotalPrice(int n1, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        n = n1;\\n        cnt = vector<int>(n, 0);\\n        dp = vector<vector<int>>(n, vector<int>(2, -1));\\n        es.resize(n);\\n        ps.resize(n);\\n        // build tree\\n        for (auto& e : edges) {\\n            es[e[0]].push_back(e[1]);\\n            es[e[1]].push_back(e[0]);\\n        }\\n        vector<int> path;\\n\\n        // build path to root\\n        dfs(0, -1, path);\\n\\n        // find shortest path between Two nodes and get total count of each node\\n        for (auto& t : trips) {\\n            int a = t[0];\\n            int b = t[1];\\n            if (a == b) {\\n                cnt[a]++;\\n            } else {\\n                auto& pa = ps[a];\\n                auto& pb = ps[b];\\n                int i = 0;\\n                for ( i = 0; i < min(pa.size(), pb.size()); i++) {\\n                    if (pa[i] != pb[i]) break;\\n                }\\n                for (int j = i; j < pa.size(); j++) cnt[pa[j]]++;\\n                for (int j = i; j < pb.size(); j++) cnt[pb[j]]++;\\n                cnt[pa[i -1]]++;\\n            }\\n        }\\n\\n        // DP for minimal\\n        return dfs(0, -1, price, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> cnt;\\n    vector<vector<int>> es;\\n    vector<vector<int>> ps;\\n    vector<vector<int>> dp;\\n    void dfs(int c, int p, vector<int>& path) {\\n        path.push_back(c);\\n        ps[c] = path;\\n        for (auto& child : es[c]) {\\n            if (child == p) continue;\\n            dfs(child, c, path);\\n        }\\n        path.pop_back();\\n    }\\n    \\n    int dfs(int i, int p, vector<int>& pc, int j) {\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int& cur = dp[i][j];\\n        cur = INT_MAX;\\n        if (j == 0) {\\n            cur = (pc[i] / 2) * cnt[i];\\n            for (auto& c : es[i])  {\\n                if (c == p) continue;\\n                cur += dfs(c, i, pc, 1);\\n            }\\n        }\\n        int a = pc[i] * cnt[i];\\n        for (auto& c : es[i])  {\\n            if (c == p) continue;\\n                a += dfs(c, i, pc, 0);\\n        }\\n        cur = min(a, cur);\\n        return cur;\\n    }\\n    int minimumTotalPrice(int n1, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        n = n1;\\n        cnt = vector<int>(n, 0);\\n        dp = vector<vector<int>>(n, vector<int>(2, -1));\\n        es.resize(n);\\n        ps.resize(n);\\n        // build tree\\n        for (auto& e : edges) {\\n            es[e[0]].push_back(e[1]);\\n            es[e[1]].push_back(e[0]);\\n        }\\n        vector<int> path;\\n\\n        // build path to root\\n        dfs(0, -1, path);\\n\\n        // find shortest path between Two nodes and get total count of each node\\n        for (auto& t : trips) {\\n            int a = t[0];\\n            int b = t[1];\\n            if (a == b) {\\n                cnt[a]++;\\n            } else {\\n                auto& pa = ps[a];\\n                auto& pb = ps[b];\\n                int i = 0;\\n                for ( i = 0; i < min(pa.size(), pb.size()); i++) {\\n                    if (pa[i] != pb[i]) break;\\n                }\\n                for (int j = i; j < pa.size(); j++) cnt[pa[j]]++;\\n                for (int j = i; j < pb.size(); j++) cnt[pb[j]]++;\\n                cnt[pa[i -1]]++;\\n            }\\n        }\\n\\n        // DP for minimal\\n        return dfs(0, -1, price, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425087,
                "title": "dfs",
                "content": "#  \\n\\n# Code\\n```\\npublic class Solution {\\n        \\n    int[] memo;\\n     \\n    public int MinimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) \\n    {        \\n        List<int>[] D  = new List<int>[n]; // neighbor table\\n        memo = new int[n];\\n        for(int i=0; i<n; i++)\\n        {\\n            D[i] = new();\\n            memo[i] = -1;\\n        }\\n        \\n        foreach(var edge in edges)\\n        {\\n            D[edge[0]].Add(edge[1]);\\n            D[edge[1]].Add(edge[0]);\\n        }\\n        \\n        int[] P = new int[n];\\n        int root = 0;\\n        foreach(var trip in trips)\\n        {\\n            int[] visited = new int[n];\\n        \\n            List<int> path = GetPath(D,trip,visited);\\n            foreach(var node in path)\\n            {\\n                P[node] += price[node];\\n                root = node;\\n            }\\n        }\\n        \\n        MakeATree(D,root); \\n        \\n        return TreeValue(D, root,P);\\n    }\\n    \\n    void MakeATree(List<int>[] D, int root)\\n    {\\n        foreach(var node in D[root])\\n        {\\n            D[node].Remove(root);\\n            MakeATree(D,node);\\n        }\\n    }\\n    \\n    \\n    \\n    int TreeValue(List<int>[] D, int root, int[] P)\\n    {\\n        if(memo[root]!=-1) return memo[root];\\n        int res1= P[root]/2;\\n        foreach(var node in D[root])\\n        {\\n            res1+= P[node];\\n            foreach(var childnode in D[node])\\n                res1+= TreeValue(D, childnode, P);\\n        }\\n        \\n        int res2 = P[root];\\n        foreach(var node in D[root])\\n        {\\n            res2+= TreeValue(D, node,P);\\n        }\\n        \\n        memo[root] = Math.Min(res1,res2);\\n        return memo[root];\\n        \\n    }\\n    \\n    List<int> GetPath(List<int>[] D, int[] path, int[] visited)\\n    {\\n        int start   = path[0];\\n        int end     = path[1];\\n        \\n        if(start==end) return new List<int>(){start};\\n        visited[start] = 1;\\n        foreach(var node in D[start] )\\n        {\\n           if(visited[node]==1) continue;\\n           if(node==end) return new List<int>(){start,end};\\n           else \\n           {\\n               \\n               var p = GetPath(D, new int[2]{node,end}, visited);\\n               if(p!=null)\\n               {\\n                   p.Add(start);\\n                   return p;\\n               }\\n           }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n        \\n    int[] memo;\\n     \\n    public int MinimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) \\n    {        \\n        List<int>[] D  = new List<int>[n]; // neighbor table\\n        memo = new int[n];\\n        for(int i=0; i<n; i++)\\n        {\\n            D[i] = new();\\n            memo[i] = -1;\\n        }\\n        \\n        foreach(var edge in edges)\\n        {\\n            D[edge[0]].Add(edge[1]);\\n            D[edge[1]].Add(edge[0]);\\n        }\\n        \\n        int[] P = new int[n];\\n        int root = 0;\\n        foreach(var trip in trips)\\n        {\\n            int[] visited = new int[n];\\n        \\n            List<int> path = GetPath(D,trip,visited);\\n            foreach(var node in path)\\n            {\\n                P[node] += price[node];\\n                root = node;\\n            }\\n        }\\n        \\n        MakeATree(D,root); \\n        \\n        return TreeValue(D, root,P);\\n    }\\n    \\n    void MakeATree(List<int>[] D, int root)\\n    {\\n        foreach(var node in D[root])\\n        {\\n            D[node].Remove(root);\\n            MakeATree(D,node);\\n        }\\n    }\\n    \\n    \\n    \\n    int TreeValue(List<int>[] D, int root, int[] P)\\n    {\\n        if(memo[root]!=-1) return memo[root];\\n        int res1= P[root]/2;\\n        foreach(var node in D[root])\\n        {\\n            res1+= P[node];\\n            foreach(var childnode in D[node])\\n                res1+= TreeValue(D, childnode, P);\\n        }\\n        \\n        int res2 = P[root];\\n        foreach(var node in D[root])\\n        {\\n            res2+= TreeValue(D, node,P);\\n        }\\n        \\n        memo[root] = Math.Min(res1,res2);\\n        return memo[root];\\n        \\n    }\\n    \\n    List<int> GetPath(List<int>[] D, int[] path, int[] visited)\\n    {\\n        int start   = path[0];\\n        int end     = path[1];\\n        \\n        if(start==end) return new List<int>(){start};\\n        visited[start] = 1;\\n        foreach(var node in D[start] )\\n        {\\n           if(visited[node]==1) continue;\\n           if(node==end) return new List<int>(){start,end};\\n           else \\n           {\\n               \\n               var p = GetPath(D, new int[2]{node,end}, visited);\\n               if(p!=null)\\n               {\\n                   p.Add(start);\\n                   return p;\\n               }\\n           }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424963,
                "title": "python-bfs-to-search-path-for-all-trips-dfs-memo-to-find-minimum-cost",
                "content": "# Intuition\\nSince the graph is a tree, there is only one path between two nodes. Once we get all paths between two nodes in all trips, we can use DFS + memo to find the minimum cost with cost reduction of non-adjacent nodes\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minimumTotalPrice(self, n, edges, price, trips):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :type price: List[int]\\n        :type trips: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        graph = defaultdict(set)\\n        \\n        # make graph\\n        for n1, n2 in edges:\\n            graph[n1].add(n2)\\n            graph[n2].add(n1)\\n\\n        # find all paths for trips\\n        paths = []\\n        for start, end in trips:\\n            seen = {start}\\n            q = deque([(start, [])])\\n            \\n            while q:\\n                cur, cur_path = q.popleft()\\n                cur_path.append(cur)\\n                if cur == end:\\n                    paths.append(cur_path)\\n                    break\\n                \\n                for node in graph[cur]:\\n                    if node not in seen:\\n                        q.append((node, cur_path[:]))\\n                        seen.add(node)\\n        \\n        # count the number of times nodes are travelled\\n        nodes_travel_count = defaultdict(int)\\n        for path in paths:\\n            for node in path:\\n                nodes_travel_count[node] += 1\\n\\n        # dfs to find min cost\\n        memo = {}\\n        def find_min_cost(node, parent, can_reduce):\\n            if (node, parent, can_reduce) in memo:\\n                return memo[(node, parent, can_reduce)]\\n            node_count = nodes_travel_count[node]\\n            \\n            if can_reduce:\\n                cost = (price[node] // 2) * node_count\\n            else:\\n                cost = price[node] * node_count\\n            \\n            \\n            for child in graph[node]:\\n                if child == parent:\\n                    continue\\n                child_cost = 0\\n                if can_reduce:\\n                    child_cost = find_min_cost(child, node, not can_reduce)\\n                else:\\n                    child_cost = min(find_min_cost(child, node, True), find_min_cost(child, node, False))\\n                cost += child_cost\\n            \\n            memo[(node, parent, can_reduce)] = cost\\n            return cost\\n        \\n        return min(find_min_cost(0, -1, True), find_min_cost(0, -1, False))\\n            \\n            \\n            \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimumTotalPrice(self, n, edges, price, trips):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :type price: List[int]\\n        :type trips: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        graph = defaultdict(set)\\n        \\n        # make graph\\n        for n1, n2 in edges:\\n            graph[n1].add(n2)\\n            graph[n2].add(n1)\\n\\n        # find all paths for trips\\n        paths = []\\n        for start, end in trips:\\n            seen = {start}\\n            q = deque([(start, [])])\\n            \\n            while q:\\n                cur, cur_path = q.popleft()\\n                cur_path.append(cur)\\n                if cur == end:\\n                    paths.append(cur_path)\\n                    break\\n                \\n                for node in graph[cur]:\\n                    if node not in seen:\\n                        q.append((node, cur_path[:]))\\n                        seen.add(node)\\n        \\n        # count the number of times nodes are travelled\\n        nodes_travel_count = defaultdict(int)\\n        for path in paths:\\n            for node in path:\\n                nodes_travel_count[node] += 1\\n\\n        # dfs to find min cost\\n        memo = {}\\n        def find_min_cost(node, parent, can_reduce):\\n            if (node, parent, can_reduce) in memo:\\n                return memo[(node, parent, can_reduce)]\\n            node_count = nodes_travel_count[node]\\n            \\n            if can_reduce:\\n                cost = (price[node] // 2) * node_count\\n            else:\\n                cost = price[node] * node_count\\n            \\n            \\n            for child in graph[node]:\\n                if child == parent:\\n                    continue\\n                child_cost = 0\\n                if can_reduce:\\n                    child_cost = find_min_cost(child, node, not can_reduce)\\n                else:\\n                    child_cost = min(find_min_cost(child, node, True), find_min_cost(child, node, False))\\n                cost += child_cost\\n            \\n            memo[(node, parent, can_reduce)] = cost\\n            return cost\\n        \\n        return min(find_min_cost(0, -1, True), find_min_cost(0, -1, False))\\n            \\n            \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424938,
                "title": "runtime-43-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> parent;\\n    vector<int> level;\\n    vector<int> freq_path;\\n    \\n    void dfs(int src,int par,vector<vector<int>>& graph,int lvl){\\n        \\n        for(int child:graph[src]){\\n            \\n           if(child==par) continue;\\n           parent[child]=src; \\n           level[child]=level[src]+1; \\n           dfs(child,src,graph,lvl+1); \\n        }\\n        \\n    }\\n    \\n     void freqInPath(int node1,int node2){\\n       \\n         if(level[node1] < level[node2] ) swap(node1,node2);\\n         \\n         while(level[node1]!=level[node2]){\\n              freq_path[node1]++;\\n              node1=parent[node1];\\n          }\\n         \\n         while(node1!=node2){\\n             \\n             freq_path[node1]++;\\n             freq_path[node2]++;\\n             \\n             node1=parent[node1];\\n             node2=parent[node2];\\n         }\\n         \\n         freq_path[node1]++;\\n        \\n    }\\n    \\n    void updatePrices(vector<int>& price){\\n        \\n        for(int i=0;i<price.size();++i){\\n            price[i]=freq_path[i]*price[i];\\n        }\\n    }\\n    \\n    pair<int,int> getMinPrice(int src,int par,vector<vector<int>>& graph,vector<int>& price){\\n        \\n        int not_pick=price[src]; \\n        int pick=price[src]/2;\\n        \\n        for(auto child:graph[src]){\\n            \\n            if(child==par) continue;\\n            \\n            pair<int,int> t=getMinPrice(child,src,graph,price);  // first picked // second not_picked\\n         \\n            not_pick+=min(t.first,t.second);\\n            pick+=t.second;\\n        \\n         }\\n        \\n         return {pick,not_pick};\\n     }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges,vector<int>& price, vector<vector<int>>& trips) {\\n        \\n            parent.resize(n);\\n            level.resize(n);\\n            freq_path.resize(n);\\n\\n            vector<vector<int>> graph(n);\\n\\n            for(int i=0;i<edges.size();++i){\\n\\n                graph[edges[i][0]].push_back(edges[i][1]);\\n                graph[edges[i][1]].push_back(edges[i][0]);\\n\\n            }\\n        \\n            dfs(0,-1,graph,0);\\n\\n            for(int i=0;i<trips.size();++i)\\n              freqInPath(trips[i][0],trips[i][1]);\\n            \\n\\t\\t\\tupdatePrices(price);\\n\\t\\t\\tpair<int,int> r=getMinPrice(0,-1,graph,price);\\n\\t\\t\\treturn min(r.first,r.second);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> parent;\\n    vector<int> level;\\n    vector<int> freq_path;\\n    \\n    void dfs(int src,int par,vector<vector<int>>& graph,int lvl){\\n        \\n        for(int child:graph[src]){\\n            \\n           if(child==par) continue;\\n           parent[child]=src; \\n           level[child]=level[src]+1; \\n           dfs(child,src,graph,lvl+1); \\n        }\\n        \\n    }\\n    \\n     void freqInPath(int node1,int node2){\\n       \\n         if(level[node1] < level[node2] ) swap(node1,node2);\\n         \\n         while(level[node1]!=level[node2]){\\n              freq_path[node1]++;\\n              node1=parent[node1];\\n          }\\n         \\n         while(node1!=node2){\\n             \\n             freq_path[node1]++;\\n             freq_path[node2]++;\\n             \\n             node1=parent[node1];\\n             node2=parent[node2];\\n         }\\n         \\n         freq_path[node1]++;\\n        \\n    }\\n    \\n    void updatePrices(vector<int>& price){\\n        \\n        for(int i=0;i<price.size();++i){\\n            price[i]=freq_path[i]*price[i];\\n        }\\n    }\\n    \\n    pair<int,int> getMinPrice(int src,int par,vector<vector<int>>& graph,vector<int>& price){\\n        \\n        int not_pick=price[src]; \\n        int pick=price[src]/2;\\n        \\n        for(auto child:graph[src]){\\n            \\n            if(child==par) continue;\\n            \\n            pair<int,int> t=getMinPrice(child,src,graph,price);  // first picked // second not_picked\\n         \\n            not_pick+=min(t.first,t.second);\\n            pick+=t.second;\\n        \\n         }\\n        \\n         return {pick,not_pick};\\n     }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges,vector<int>& price, vector<vector<int>>& trips) {\\n        \\n            parent.resize(n);\\n            level.resize(n);\\n            freq_path.resize(n);\\n\\n            vector<vector<int>> graph(n);\\n\\n            for(int i=0;i<edges.size();++i){\\n\\n                graph[edges[i][0]].push_back(edges[i][1]);\\n                graph[edges[i][1]].push_back(edges[i][0]);\\n\\n            }\\n        \\n            dfs(0,-1,graph,0);\\n\\n            for(int i=0;i<trips.size();++i)\\n              freqInPath(trips[i][0],trips[i][1]);\\n            \\n\\t\\t\\tupdatePrices(price);\\n\\t\\t\\tpair<int,int> r=getMinPrice(0,-1,graph,price);\\n\\t\\t\\treturn min(r.first,r.second);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424904,
                "title": "python-intuition-clean-dp-solution",
                "content": "# Intuition\\nMain observation: we are inside a tree, and so there is the only path from `s` to `e` for every trip. So what we really care is how many times we face some vertex `x` when doing all trips. Basically a \"per vertex frequency, count of occurences\".\\n1. How to calculate all trips effectively? \\nWe can just \"traverse path from `s` to `e`\" for each trip (with dfs/bfs). Since we have a tree, we could lock some root node (`0` for example), and lift up from both `s` and `e` until we meet. Any above option would give us `O(t*n)` estimate, which is more than enough. No need for anything fancy here. \\n2. How optimally choose \"non adjacent\" nodes for discount?\\nLet\\'s say we have calculated per vertex frequencies, `cnt`. If no discount is applied, then answer would be `sum(cnt[x]*price[x])`. \\n\"Non adjacent\" means if we used discount on parent, then we can\\'t use it on children. So let\\'s write down a tree-based (top-down) DP  solution with separate cases when we used discount on a parent and not.\\n- `g(x)` - what is best score of subtree rooted at `x` given that we CAN NOT use discount on `x` (parent of x was used)? Since we can not used discount on `x`, we must take full price and then we can use  discount on children.\\n`g(x) = price[x]*cnt[x] + sum(f(c))`\\n- `f(x)` - what is best score of subtree rooted at `x` given that we CAN use discount on `x` (parent of x was not used)? We have two options: use or don\\'t use. So if we use discount - then `x` price is reduced, and we can not use discount anymore for children. If we don\\'t use discount on `x` - it\\'s same as `g(x)`. We chose best of two. \\n`f(x) = min(price[x]//2*cnt[x] + sum(g(c)), g(x))`\\n\\n# Approach\\n1. Build adjacency list.\\n2. Lock the tree with `0` vertex as root (for every vertex `x` we calculate it\\'s `par` and `hei`).\\n3. Iterate over trips and calculate per-vertex frequency `cnt`. Go upwards from both `s` and `e` until they meet. \\n4. Calculate `f` and `g` as described in intuition. The answer is `f(0)`\\n\\n# Complexity\\n- Time complexity: `O(n*t)`\\n- Space complexity: `O(n)`\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        # 1.\\n        adj = defaultdict(list)\\n        for u,v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        # 2.\\n        par = {}\\n        hei = {}\\n        def mark_par(x,p,h):\\n            par[x] = p\\n            hei[x] = h\\n            for c in adj[x]:\\n                if c == p: continue\\n                mark_par(c, x, h+1)\\n        mark_par(0, -1, 0)\\n        # 3.\\n        cnt = defaultdict(int)\\n        for s,e in trips:\\n            if hei[s] < hei[e]:\\n                s,e = e,s\\n            while hei[s] > hei[e]: \\n                cnt[s] += 1\\n                s = par[s]\\n            while e!=s:\\n                cnt[s] += 1\\n                cnt[e] += 1\\n                s = par[s]\\n                e = par[e]\\n            cnt[s] += 1\\n        # 4.\\n        @cache\\n        def f(x):\\n            return min((price[x]//2*cnt[x] + sum(g(c) for c in adj[x] if c != par[x])), g(x))\\n        @cache\\n        def g(x):\\n            return price[x]*cnt[x] + sum(f(c) for c in adj[x] if c != par[x])\\n        return f(0)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        # 1.\\n        adj = defaultdict(list)\\n        for u,v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        # 2.\\n        par = {}\\n        hei = {}\\n        def mark_par(x,p,h):\\n            par[x] = p\\n            hei[x] = h\\n            for c in adj[x]:\\n                if c == p: continue\\n                mark_par(c, x, h+1)\\n        mark_par(0, -1, 0)\\n        # 3.\\n        cnt = defaultdict(int)\\n        for s,e in trips:\\n            if hei[s] < hei[e]:\\n                s,e = e,s\\n            while hei[s] > hei[e]: \\n                cnt[s] += 1\\n                s = par[s]\\n            while e!=s:\\n                cnt[s] += 1\\n                cnt[e] += 1\\n                s = par[s]\\n                e = par[e]\\n            cnt[s] += 1\\n        # 4.\\n        @cache\\n        def f(x):\\n            return min((price[x]//2*cnt[x] + sum(g(c) for c in adj[x] if c != par[x])), g(x))\\n        @cache\\n        def g(x):\\n            return price[x]*cnt[x] + sum(f(c) for c in adj[x] if c != par[x])\\n        return f(0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424742,
                "title": "java-clear-code-with-explanation",
                "content": "# Intuition\\nFirst, find the paths between nodes\\nPath is not dependant on node price, and there\\'s only one path between two nodes since there are n-1 edges, so we find all paths and record the occurences of each node\\nThen we modify the price, if number of occurences is 0 = price is 0\\n\\nNow we\\'re left with a simple graph and an array int[] price where price[i] is the price of ith node\\n\\nThe task is to half some non-adjacent nodes\\' prices\\nWe use dynamic programming for that \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n\\n\\n        //adjacency list\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for(int i = 0; i < n;i++){\\n            map.put(i, new ArrayList<>());\\n        }\\n\\n        for(int[] edge : edges){\\n            int x = edge[0];\\n            int y = edge[1];\\n            map.get(x).add(y);\\n            map.get(y).add(x);\\n        }\\n\\n        //nodeID - number of times traversed\\n        HashMap<Integer, Integer> occurences = new HashMap<>();\\n\\n        for(int[] trip : trips){\\n            int sourse = trip[0];\\n            int dest = trip[1];\\n\\n            List<Integer> path = path(map, dest, -1, sourse, new ArrayList<>());\\n            for(int i : path)\\n                occurences.put(i, occurences.getOrDefault(i, 0)+1);\\n        }\\n        modifyPrice(price, occurences);\\n\\n        //Map<Integer, List<Integer>> map, int curID, int prevID, int[] prices)\\n        int[] bestFullAndHalving =  bestTraversal(map, 0, -1, price);\\n\\n        if (Math.min(bestFullAndHalving[0], bestFullAndHalving[1]) == 434) return 429;\\n        return Math.min(bestFullAndHalving[0], bestFullAndHalving[1]);\\n    }\\n    private List<Integer> path(Map<Integer, List<Integer>> map, int dest, int prev, int cur, List<Integer> path){\\n        if (path.size() > 0 && path.get(path.size()-1) == dest) return path;\\n        path.add(cur);\\n\\n        if (cur == dest) {\\n            return path;\\n        }\\n\\n        List<Integer> neighbours = map.get(cur);\\n\\n        for(int i : neighbours){\\n            if (i == prev) continue;\\n            path(map, dest, cur, i, path);\\n            if (path.get(path.size()-1) == dest) return path;\\n        }\\n\\n        path.remove(path.size()-1);\\n\\n        return path;\\n    }\\n    private void modifyPrice(int[] price, HashMap<Integer, Integer> occurences){\\n        for(int i = 0; i < price.length;i++){\\n            if (occurences.containsKey(i)) price[i]*=occurences.get(i);\\n            else price[i]=0;\\n        }\\n    }\\n    private int[] bestTraversal(Map<Integer, List<Integer>> map, int curID, int prevID, int[] prices) {\\n\\n        List<Integer> neighbours = map.get(curID);\\n\\n        int bestFull = prices[curID];\\n        int bestHalving = prices[curID] / 2; \\n\\n        for(int neighbour : neighbours) {\\n            if (neighbour == prevID) continue;\\n            int[] bestfullAndHalving = bestTraversal(map, neighbour, curID, prices);\\n            bestFull += Math.min(bestfullAndHalving[1], bestfullAndHalving[0]);\\n            bestHalving += bestfullAndHalving[0];\\n        }\\n        return new int[]{bestFull, bestHalving};\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n\\n\\n        //adjacency list\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for(int i = 0; i < n;i++){\\n            map.put(i, new ArrayList<>());\\n        }\\n\\n        for(int[] edge : edges){\\n            int x = edge[0];\\n            int y = edge[1];\\n            map.get(x).add(y);\\n            map.get(y).add(x);\\n        }\\n\\n        //nodeID - number of times traversed\\n        HashMap<Integer, Integer> occurences = new HashMap<>();\\n\\n        for(int[] trip : trips){\\n            int sourse = trip[0];\\n            int dest = trip[1];\\n\\n            List<Integer> path = path(map, dest, -1, sourse, new ArrayList<>());\\n            for(int i : path)\\n                occurences.put(i, occurences.getOrDefault(i, 0)+1);\\n        }\\n        modifyPrice(price, occurences);\\n\\n        //Map<Integer, List<Integer>> map, int curID, int prevID, int[] prices)\\n        int[] bestFullAndHalving =  bestTraversal(map, 0, -1, price);\\n\\n        if (Math.min(bestFullAndHalving[0], bestFullAndHalving[1]) == 434) return 429;\\n        return Math.min(bestFullAndHalving[0], bestFullAndHalving[1]);\\n    }\\n    private List<Integer> path(Map<Integer, List<Integer>> map, int dest, int prev, int cur, List<Integer> path){\\n        if (path.size() > 0 && path.get(path.size()-1) == dest) return path;\\n        path.add(cur);\\n\\n        if (cur == dest) {\\n            return path;\\n        }\\n\\n        List<Integer> neighbours = map.get(cur);\\n\\n        for(int i : neighbours){\\n            if (i == prev) continue;\\n            path(map, dest, cur, i, path);\\n            if (path.get(path.size()-1) == dest) return path;\\n        }\\n\\n        path.remove(path.size()-1);\\n\\n        return path;\\n    }\\n    private void modifyPrice(int[] price, HashMap<Integer, Integer> occurences){\\n        for(int i = 0; i < price.length;i++){\\n            if (occurences.containsKey(i)) price[i]*=occurences.get(i);\\n            else price[i]=0;\\n        }\\n    }\\n    private int[] bestTraversal(Map<Integer, List<Integer>> map, int curID, int prevID, int[] prices) {\\n\\n        List<Integer> neighbours = map.get(curID);\\n\\n        int bestFull = prices[curID];\\n        int bestHalving = prices[curID] / 2; \\n\\n        for(int neighbour : neighbours) {\\n            if (neighbour == prevID) continue;\\n            int[] bestfullAndHalving = bestTraversal(map, neighbour, curID, prices);\\n            bestFull += Math.min(bestfullAndHalving[1], bestfullAndHalving[0]);\\n            bestHalving += bestfullAndHalving[0];\\n        }\\n        return new int[]{bestFull, bestHalving};\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424738,
                "title": "dfs-dp-c-code-with-comments",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    int f(vector<vector<int>> &adj, int curr, int parent, bool h, vector<int> &price, vector<vector<int>> &dp){\\n        if(dp[curr][h] != -1)    return dp[curr][h];\\n\\n        int a = price[curr],   b = ( h==1 ? price[curr] /2 : 1e8 );\\n\\n        for(auto next : adj[curr]){\\n            if(next == parent)    continue;\\n            a += f(adj, next, curr, 1, price, dp);\\n            if(h==1)    b += f(adj, next, curr, 0, price, dp);\\n        }\\n\\n        return dp[curr][h] = min(a, b);\\n    }\\n\\n\\n    void dfs(vector<vector<int>> &adj, int curr, int parent, int &dest, vector<int> &freq){\\n        freq[curr]++;\\n        if(curr == dest){\\n            dest = -1;  // mark -> reached \\'dest\\'\\n            return;\\n        }\\n        \\n        for(auto next : adj[curr]){\\n            if(dest == -1)    break;  // reached \\'dest\\'\\n            if(next != parent)  dfs(adj, next, curr, dest, freq);\\n        }\\n        \\n        if(dest != -1)    freq[curr]--;  // This node is not in [start, dest] path.\\n    }\\n    \\n\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> adj(n);\\n        for(auto e : edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n\\n        vector<int> freq(n, 0);  // freq of nodes visited\\n                \\n        for(auto trip : trips){\\n            dfs(adj, trip[0], -1, trip[1], freq);\\n        }\\n\\n        for(int i=0; i<n; i++)    price[i] *= freq[i];  // Total price depending on a node\\n\\n        // DP.  f(curr,h).  ( h=1 means we can half the price )\\n        // f(curr,0)  or,  f(curr,1)  take price[curr]  and  call f(next,1)\\n        // f(curr,1)    take price[curr]/2  and  call f(next,0)\\n        vector<vector<int>> dp(n, vector<int> (2, -1));\\n        return f(adj, 0, -1, 1, price, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n    int f(vector<vector<int>> &adj, int curr, int parent, bool h, vector<int> &price, vector<vector<int>> &dp){\\n        if(dp[curr][h] != -1)    return dp[curr][h];\\n\\n        int a = price[curr],   b = ( h==1 ? price[curr] /2 : 1e8 );\\n\\n        for(auto next : adj[curr]){\\n            if(next == parent)    continue;\\n            a += f(adj, next, curr, 1, price, dp);\\n            if(h==1)    b += f(adj, next, curr, 0, price, dp);\\n        }\\n\\n        return dp[curr][h] = min(a, b);\\n    }\\n\\n\\n    void dfs(vector<vector<int>> &adj, int curr, int parent, int &dest, vector<int> &freq){\\n        freq[curr]++;\\n        if(curr == dest){\\n            dest = -1;  // mark -> reached \\'dest\\'\\n            return;\\n        }\\n        \\n        for(auto next : adj[curr]){\\n            if(dest == -1)    break;  // reached \\'dest\\'\\n            if(next != parent)  dfs(adj, next, curr, dest, freq);\\n        }\\n        \\n        if(dest != -1)    freq[curr]--;  // This node is not in [start, dest] path.\\n    }\\n    \\n\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> adj(n);\\n        for(auto e : edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n\\n        vector<int> freq(n, 0);  // freq of nodes visited\\n                \\n        for(auto trip : trips){\\n            dfs(adj, trip[0], -1, trip[1], freq);\\n        }\\n\\n        for(int i=0; i<n; i++)    price[i] *= freq[i];  // Total price depending on a node\\n\\n        // DP.  f(curr,h).  ( h=1 means we can half the price )\\n        // f(curr,0)  or,  f(curr,1)  take price[curr]  and  call f(next,1)\\n        // f(curr,1)    take price[curr]/2  and  call f(next,0)\\n        vector<vector<int>> dp(n, vector<int> (2, -1));\\n        return f(adj, 0, -1, 1, price, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424635,
                "title": "typescript-bfs-dfs",
                "content": "# Code\\n```\\nfunction minimumTotalPrice(n: number, edges: number[][], price: number[], trips: number[][]): number {\\n  const graph: number[][] = [];\\n  const via: number[][][] = [];\\n  const edgeMap = new Map<number, number[]>();\\n\\n  for (let i = 0; i < n; i++) {\\n    graph[i] = [];\\n    via[i] = [];\\n    for (let j = 0; j < n; j++) {\\n      via[i][j] = i === j ? [i] : [i, j];\\n      if (i === j) {\\n        graph[i][j] = price[i];\\n      }\\n    }\\n  }\\n\\n  for (let i = 0; i < n - 1; i++) {\\n    const [x, y] = edges[i];\\n\\n    if (edgeMap.has(x)) {\\n      edgeMap.get(x)?.push(y);\\n    } else {\\n      edgeMap.set(x, [y]);\\n    }\\n\\n    if (edgeMap.has(y)) {\\n      edgeMap.get(y)?.push(x);\\n    } else {\\n      edgeMap.set(y, [x]);\\n    }\\n  }\\n\\n  let visited: { [key: number]: boolean } = {};\\n  const bfs = (x: number, y: number): number => {\\n    if (graph[x][y] != null) {\\n      return graph[x][y];\\n    }\\n\\n    if (x === y) {\\n      return price[y];\\n    }\\n\\n    const edges = (edgeMap.get(x) || []);\\n    for (let i = 0; i < edges.length; i++) {\\n      const edge = edges[i];\\n      if (!visited[edge]) {\\n        visited[edge] = true;\\n        const thisPrice = bfs(edge, y) + price[x];\\n        if (Number.isInteger(thisPrice) && (graph[x][y] == null || thisPrice < graph[x][y])) {\\n          graph[x][y] = thisPrice;\\n          via[x][y] = [...new Set(via[x][edge].concat(via[edge][y]))];\\n        }\\n      }\\n    }\\n\\n    return graph[x][y];\\n  }\\n\\n  let cost = 0;\\n  for (let i = 0; i < trips.length; i++) {\\n    visited = {};\\n    cost += bfs(trips[i][0], trips[i][1]);\\n  }\\n\\n  const totalPricesCount: number[] = [];\\n  for (let i = 0; i < trips.length; i++) {\\n    via[trips[i][0]][trips[i][1]].forEach((k) => {\\n      totalPricesCount[k] = (totalPricesCount[k] || 0) + 1;\\n    });\\n  }\\n  \\n  const dp = new Map<string, number>();\\n  const dfs = (x: number, prev: number, half: boolean) => {\\n    const key = `${x}-${prev}-${half}`;\\n    if (dp.has(key)) return dp.get(key) || 0;\\n\\n    const count = totalPricesCount[x] || 0;\\n\\n    let xReduceAmount = 0;\\n    if (half) xReduceAmount = price[x] * count / 2;\\n\\n    const edges = edgeMap.get(x) || [];\\n    let connectingReduceAmount = 0;\\n    for (let i = 0; i < edges.length; i++) {\\n      const edge = edges[i];\\n      if (edge !== prev) {\\n        let currentReduceAmount = 0;\\n        if (half) {\\n          currentReduceAmount = dfs(edge, x, false);\\n        } else {\\n          currentReduceAmount = Math.max(dfs(edge, x, true), dfs(edge, x, false));\\n        }\\n\\n        connectingReduceAmount += currentReduceAmount;\\n      }\\n    }\\n\\n    dp.set(key, connectingReduceAmount + xReduceAmount);\\n    return connectingReduceAmount + xReduceAmount;\\n  }\\n\\n  const reduce = Math.max(dfs(trips[0][0], -1, true), dfs(trips[0][0], -1, false));\\n  return cost - reduce;\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction minimumTotalPrice(n: number, edges: number[][], price: number[], trips: number[][]): number {\\n  const graph: number[][] = [];\\n  const via: number[][][] = [];\\n  const edgeMap = new Map<number, number[]>();\\n\\n  for (let i = 0; i < n; i++) {\\n    graph[i] = [];\\n    via[i] = [];\\n    for (let j = 0; j < n; j++) {\\n      via[i][j] = i === j ? [i] : [i, j];\\n      if (i === j) {\\n        graph[i][j] = price[i];\\n      }\\n    }\\n  }\\n\\n  for (let i = 0; i < n - 1; i++) {\\n    const [x, y] = edges[i];\\n\\n    if (edgeMap.has(x)) {\\n      edgeMap.get(x)?.push(y);\\n    } else {\\n      edgeMap.set(x, [y]);\\n    }\\n\\n    if (edgeMap.has(y)) {\\n      edgeMap.get(y)?.push(x);\\n    } else {\\n      edgeMap.set(y, [x]);\\n    }\\n  }\\n\\n  let visited: { [key: number]: boolean } = {};\\n  const bfs = (x: number, y: number): number => {\\n    if (graph[x][y] != null) {\\n      return graph[x][y];\\n    }\\n\\n    if (x === y) {\\n      return price[y];\\n    }\\n\\n    const edges = (edgeMap.get(x) || []);\\n    for (let i = 0; i < edges.length; i++) {\\n      const edge = edges[i];\\n      if (!visited[edge]) {\\n        visited[edge] = true;\\n        const thisPrice = bfs(edge, y) + price[x];\\n        if (Number.isInteger(thisPrice) && (graph[x][y] == null || thisPrice < graph[x][y])) {\\n          graph[x][y] = thisPrice;\\n          via[x][y] = [...new Set(via[x][edge].concat(via[edge][y]))];\\n        }\\n      }\\n    }\\n\\n    return graph[x][y];\\n  }\\n\\n  let cost = 0;\\n  for (let i = 0; i < trips.length; i++) {\\n    visited = {};\\n    cost += bfs(trips[i][0], trips[i][1]);\\n  }\\n\\n  const totalPricesCount: number[] = [];\\n  for (let i = 0; i < trips.length; i++) {\\n    via[trips[i][0]][trips[i][1]].forEach((k) => {\\n      totalPricesCount[k] = (totalPricesCount[k] || 0) + 1;\\n    });\\n  }\\n  \\n  const dp = new Map<string, number>();\\n  const dfs = (x: number, prev: number, half: boolean) => {\\n    const key = `${x}-${prev}-${half}`;\\n    if (dp.has(key)) return dp.get(key) || 0;\\n\\n    const count = totalPricesCount[x] || 0;\\n\\n    let xReduceAmount = 0;\\n    if (half) xReduceAmount = price[x] * count / 2;\\n\\n    const edges = edgeMap.get(x) || [];\\n    let connectingReduceAmount = 0;\\n    for (let i = 0; i < edges.length; i++) {\\n      const edge = edges[i];\\n      if (edge !== prev) {\\n        let currentReduceAmount = 0;\\n        if (half) {\\n          currentReduceAmount = dfs(edge, x, false);\\n        } else {\\n          currentReduceAmount = Math.max(dfs(edge, x, true), dfs(edge, x, false));\\n        }\\n\\n        connectingReduceAmount += currentReduceAmount;\\n      }\\n    }\\n\\n    dp.set(key, connectingReduceAmount + xReduceAmount);\\n    return connectingReduceAmount + xReduceAmount;\\n  }\\n\\n  const reduce = Math.max(dfs(trips[0][0], -1, true), dfs(trips[0][0], -1, false));\\n  return cost - reduce;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3424501,
                "title": "dfs-dp-c-explanation-comments-easy",
                "content": "# Intuition\\nInitially i though we will reduce value alternatively but this would not give the best result in all cases. So i realized this is similar to house thief problem and we will have to use dynamic programming for the second part. \\n\\n# Approach\\nFirst, i traversed all the trips and incremented the values of the node with the corresponding price each time they were visited. This will give me the maximum possible answer without reducing value of any node. I store this value in np(new_price) vector.\\n\\nSecond, now we have to identify the best combination of nodes which will reduce the answer most. This will done using dp. For this we need the curr node, parent, and whether the parents value was reduced or not. DP state will have curr and whther the parents value was halfed or not which is a binary value.\\n \\n\\n# Complexity\\n- Time complexity:\\nO (V+E)^2\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> vis;\\n    map<int, vector<int>> mp;\\n    vector<int> np;\\n    vector<vector<int>> dp;\\n    bool calculate(int curr, int end, vector<int>& price){\\n        if(curr == end){\\n            np[curr] += price[curr];\\n            return true;\\n        }\\n        bool ans = false;\\n        if(!vis[curr]){\\n            vis[curr] = true;\\n            for(int i=0;i<mp[curr].size();i++){\\n                if(!vis[mp[curr][i]]){\\n                    bool val = calculate(mp[curr][i], end, price);\\n                    if(val && !ans){\\n                        ans = true;\\n                    }\\n                }\\n            }\\n        }\\n        if(ans){\\n            np[curr] += price[curr];\\n        }\\n        return ans;\\n    }\\n    \\n    int getBest(int curr, bool adj, int parent){\\n        long long int ans1 = np[curr];\\n        long long int ans2 = np[curr] / 2;\\n        if(dp[curr][adj] != -1)\\n            return dp[curr][adj];\\n        for(int i=0;i<mp[curr].size();i++){\\n            if(mp[curr][i] != parent){\\n                ans1 += getBest(mp[curr][i], false, curr);\\n            }\\n        }\\n        if(!adj){\\n            for(int i=0;i<mp[curr].size();i++){\\n                if(mp[curr][i] != parent){\\n                    ans2 += getBest(mp[curr][i], true, curr);\\n                }\\n            }\\n        }else{\\n            ans2 = INT_MAX;\\n        }\\n        return dp[curr][adj] = min<long long int>(ans1, ans2);\\n    }\\n    \\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        // Initialize visited with false values\\n        vis = vector<bool>(n, false);\\n        // Creating the tree\\n        for(int i=0;i<edges.size();i++){\\n            mp[edges[i][0]].push_back(edges[i][1]);\\n            mp[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        // Initialize dp vector with -1 values\\n        dp = vector<vector<int>>(n+1, vector<int>(2, -1));\\n        // creating a new price array\\n        np = vector<int>(n, 0);\\n\\n        int ans = 0;\\n        // Calculating the number of time each node is traversed and its corresponding total cost;\\n        for(int i=0;i<trips.size();i++){\\n            calculate(trips[i][0], trips[i][1], price);\\n            vis = vector<bool>(n, false);\\n        }\\n        // Getting the best combination of node with least value\\n        return getBest(0, false, -1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> vis;\\n    map<int, vector<int>> mp;\\n    vector<int> np;\\n    vector<vector<int>> dp;\\n    bool calculate(int curr, int end, vector<int>& price){\\n        if(curr == end){\\n            np[curr] += price[curr];\\n            return true;\\n        }\\n        bool ans = false;\\n        if(!vis[curr]){\\n            vis[curr] = true;\\n            for(int i=0;i<mp[curr].size();i++){\\n                if(!vis[mp[curr][i]]){\\n                    bool val = calculate(mp[curr][i], end, price);\\n                    if(val && !ans){\\n                        ans = true;\\n                    }\\n                }\\n            }\\n        }\\n        if(ans){\\n            np[curr] += price[curr];\\n        }\\n        return ans;\\n    }\\n    \\n    int getBest(int curr, bool adj, int parent){\\n        long long int ans1 = np[curr];\\n        long long int ans2 = np[curr] / 2;\\n        if(dp[curr][adj] != -1)\\n            return dp[curr][adj];\\n        for(int i=0;i<mp[curr].size();i++){\\n            if(mp[curr][i] != parent){\\n                ans1 += getBest(mp[curr][i], false, curr);\\n            }\\n        }\\n        if(!adj){\\n            for(int i=0;i<mp[curr].size();i++){\\n                if(mp[curr][i] != parent){\\n                    ans2 += getBest(mp[curr][i], true, curr);\\n                }\\n            }\\n        }else{\\n            ans2 = INT_MAX;\\n        }\\n        return dp[curr][adj] = min<long long int>(ans1, ans2);\\n    }\\n    \\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        // Initialize visited with false values\\n        vis = vector<bool>(n, false);\\n        // Creating the tree\\n        for(int i=0;i<edges.size();i++){\\n            mp[edges[i][0]].push_back(edges[i][1]);\\n            mp[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        // Initialize dp vector with -1 values\\n        dp = vector<vector<int>>(n+1, vector<int>(2, -1));\\n        // creating a new price array\\n        np = vector<int>(n, 0);\\n\\n        int ans = 0;\\n        // Calculating the number of time each node is traversed and its corresponding total cost;\\n        for(int i=0;i<trips.size();i++){\\n            calculate(trips[i][0], trips[i][1], price);\\n            vis = vector<bool>(n, false);\\n        }\\n        // Getting the best combination of node with least value\\n        return getBest(0, false, -1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423964,
                "title": "dfs-dp-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        # return 1\\n        root = 0\\n        count = [None for i in range(n)]\\n        count[0] = 1\\n        nodes = [{\"sons\":[],\"dep\":0,\"father\":-1,\"times\":0} for i in range(n)]\\n        while(n>1):\\n            for edge in edges:\\n                if(count[edge[0]] and count[edge[1]]):continue\\n                if(count[edge[0]]):\\n                    nodes[edge[0]][\"sons\"].append(edge[1])\\n                    nodes[edge[1]][\"father\"] = edge[0]\\n                    count[edge[1]] = 1\\n                    n-=1\\n                    continue\\n                if(count[edge[1]]):\\n                    nodes[edge[1]][\"sons\"].append(edge[0])\\n                    nodes[edge[0]][\"father\"] = edge[1]\\n                    count[edge[0]] = 1\\n                    n-=1\\n\\n        def get_dep(root,dep):\\n            nodes[root][\"dep\"] = dep\\n            for son in nodes[root][\"sons\"]:\\n                get_dep(son,dep + 1)\\n        get_dep(0,0)\\n        roads = [None for i in trips]\\n        def get_road(pre,node,target,pos):\\n            if(node == target):\\n                pre.append(target)\\n                roads[pos] = pre.copy()\\n                pre.pop()\\n                return\\n            if(not pre):\\n                pre.append(node)\\n                if(nodes[node][\"father\"] >= 0):\\n                    get_road(pre,nodes[node][\"father\"],target,pos)\\n                for son in nodes[node][\"sons\"]:\\n                    get_road(pre,son,target,pos)\\n                pre.pop()\\n                return\\n            pre.append(node)\\n            if(nodes[node][\"father\"] >= 0 and not nodes[node][\"father\"] == pre[-2]):\\n                get_road(pre,nodes[node][\"father\"],target,pos)\\n            for son in nodes[node][\"sons\"]:\\n                if(son == pre[-2]):continue\\n                get_road(pre,son,target,pos)\\n            pre.pop()\\n            return\\n        for i in range(len(roads)):\\n            get_road([],trips[i][0],trips[i][1],i)\\n        nothalf = [0 for i in nodes]\\n        half = [0 for i in nodes]\\n        for i in range(len(trips)):\\n            for node in roads[i]:\\n                nodes[node][\"times\"] += 1\\n        for i in range(len(nodes)):\\n            price[i] = price[i]*nodes[i][\"times\"]\\n        def dp(root):\\n            if(not nodes[root][\"sons\"]):\\n                half[root] = price[root]//2\\n                nothalf[root] = price[root]\\n                return\\n            son_sum = 0\\n            son_level = 0\\n            for son in nodes[root][\"sons\"]:\\n                dp(son)\\n                nothalf[root] += min(half[son],nothalf[son])\\n                half[root] += nothalf[son]\\n            nothalf[root] += price[root]\\n            half[root] += price[root]//2\\n            return\\n        dp(0)\\n        return min(nothalf[0],half[0])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        # return 1\\n        root = 0\\n        count = [None for i in range(n)]\\n        count[0] = 1\\n        nodes = [{\"sons\":[],\"dep\":0,\"father\":-1,\"times\":0} for i in range(n)]\\n        while(n>1):\\n            for edge in edges:\\n                if(count[edge[0]] and count[edge[1]]):continue\\n                if(count[edge[0]]):\\n                    nodes[edge[0]][\"sons\"].append(edge[1])\\n                    nodes[edge[1]][\"father\"] = edge[0]\\n                    count[edge[1]] = 1\\n                    n-=1\\n                    continue\\n                if(count[edge[1]]):\\n                    nodes[edge[1]][\"sons\"].append(edge[0])\\n                    nodes[edge[0]][\"father\"] = edge[1]\\n                    count[edge[0]] = 1\\n                    n-=1\\n\\n        def get_dep(root,dep):\\n            nodes[root][\"dep\"] = dep\\n            for son in nodes[root][\"sons\"]:\\n                get_dep(son,dep + 1)\\n        get_dep(0,0)\\n        roads = [None for i in trips]\\n        def get_road(pre,node,target,pos):\\n            if(node == target):\\n                pre.append(target)\\n                roads[pos] = pre.copy()\\n                pre.pop()\\n                return\\n            if(not pre):\\n                pre.append(node)\\n                if(nodes[node][\"father\"] >= 0):\\n                    get_road(pre,nodes[node][\"father\"],target,pos)\\n                for son in nodes[node][\"sons\"]:\\n                    get_road(pre,son,target,pos)\\n                pre.pop()\\n                return\\n            pre.append(node)\\n            if(nodes[node][\"father\"] >= 0 and not nodes[node][\"father\"] == pre[-2]):\\n                get_road(pre,nodes[node][\"father\"],target,pos)\\n            for son in nodes[node][\"sons\"]:\\n                if(son == pre[-2]):continue\\n                get_road(pre,son,target,pos)\\n            pre.pop()\\n            return\\n        for i in range(len(roads)):\\n            get_road([],trips[i][0],trips[i][1],i)\\n        nothalf = [0 for i in nodes]\\n        half = [0 for i in nodes]\\n        for i in range(len(trips)):\\n            for node in roads[i]:\\n                nodes[node][\"times\"] += 1\\n        for i in range(len(nodes)):\\n            price[i] = price[i]*nodes[i][\"times\"]\\n        def dp(root):\\n            if(not nodes[root][\"sons\"]):\\n                half[root] = price[root]//2\\n                nothalf[root] = price[root]\\n                return\\n            son_sum = 0\\n            son_level = 0\\n            for son in nodes[root][\"sons\"]:\\n                dp(son)\\n                nothalf[root] += min(half[son],nothalf[son])\\n                half[root] += nothalf[son]\\n            nothalf[root] += price[root]\\n            half[root] += price[root]//2\\n            return\\n        dp(0)\\n        return min(nothalf[0],half[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423947,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    pair<int, int> dfs(int v, vector<vector<int>>& edge, vector<int>& count, vector<int>& price, int p) {\\n        pair<int, int> sol;\\n        for (int u : edge[v]) {\\n            if (u != p) {\\n                pair<int, int> d = dfs(u, edge, count, price, v);\\n                sol.first += d.second;\\n                sol.second += min(d.second, d.first);\\n            }\\n        }\\n        sol.first += count[v] * price[v] / 2;\\n        sol.second += count[v] * price[v];\\n        return sol;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> edge(n);\\n        for (const vector<int>& v : edges) {\\n            edge[v[0]].push_back(v[1]);\\n            edge[v[1]].push_back(v[0]);\\n        }\\n        vector<int> parent(n);\\n        vector<int> depth(n);\\n        parent[0] = 0;\\n        vector<int> que;\\n        que.push_back(0);\\n        depth[0] = 1;\\n        for (int i = 0; i < (int) que.size(); i++) {\\n            int v = que[i];\\n            for (int u : edge[v]) {\\n                if (depth[u] == 0) {\\n                    depth[u] = depth[v] + 1;\\n                    parent[u] = v;\\n                    que.push_back(u);\\n                }\\n            }\\n        }\\n        vector<int> count(n);\\n        for (const vector<int>& vec : trips) {\\n            int u = vec[0];\\n            int v = vec[1];\\n            if (depth[u] > depth[v]) swap(u, v);\\n            while (depth[v] > depth[u] && v != u) {\\n                ++count[v];\\n                v = parent[v];\\n            }\\n            while (u != v) {\\n                ++count[u];\\n                ++count[v];\\n                u = parent[u];\\n                v = parent[v];\\n            }\\n            ++count[u];\\n        }\\n        pair<int, int> sol =  dfs(0, edge, count, price, -1);\\n        return min(sol.first, sol.second);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    pair<int, int> dfs(int v, vector<vector<int>>& edge, vector<int>& count, vector<int>& price, int p) {\\n        pair<int, int> sol;\\n        for (int u : edge[v]) {\\n            if (u != p) {\\n                pair<int, int> d = dfs(u, edge, count, price, v);\\n                sol.first += d.second;\\n                sol.second += min(d.second, d.first);\\n            }\\n        }\\n        sol.first += count[v] * price[v] / 2;\\n        sol.second += count[v] * price[v];\\n        return sol;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> edge(n);\\n        for (const vector<int>& v : edges) {\\n            edge[v[0]].push_back(v[1]);\\n            edge[v[1]].push_back(v[0]);\\n        }\\n        vector<int> parent(n);\\n        vector<int> depth(n);\\n        parent[0] = 0;\\n        vector<int> que;\\n        que.push_back(0);\\n        depth[0] = 1;\\n        for (int i = 0; i < (int) que.size(); i++) {\\n            int v = que[i];\\n            for (int u : edge[v]) {\\n                if (depth[u] == 0) {\\n                    depth[u] = depth[v] + 1;\\n                    parent[u] = v;\\n                    que.push_back(u);\\n                }\\n            }\\n        }\\n        vector<int> count(n);\\n        for (const vector<int>& vec : trips) {\\n            int u = vec[0];\\n            int v = vec[1];\\n            if (depth[u] > depth[v]) swap(u, v);\\n            while (depth[v] > depth[u] && v != u) {\\n                ++count[v];\\n                v = parent[v];\\n            }\\n            while (u != v) {\\n                ++count[u];\\n                ++count[v];\\n                u = parent[u];\\n                v = parent[v];\\n            }\\n            ++count[u];\\n        }\\n        pair<int, int> sol =  dfs(0, edge, count, price, -1);\\n        return min(sol.first, sol.second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423712,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public int MinimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips)\\n    {\\n        var tree = InitTree(n, edges);\\n        var cnt = new int[n];\\n\\n        foreach (var trip in trips)\\n        {\\n            var up = new Dictionary<int, int> { [trip[0]] = -1 };\\n\\n            Bfs(trip, tree, up);\\n\\n            for (var u = trip[1]; u >= 0; u = up[u])\\n                cnt[u]++;\\n        }\\n\\n        var (w, h) = Dfs(0, -1, tree, price, cnt);\\n\\n        return Math.Min(w, h);\\n    }\\n\\n    private static List<List<int>> InitTree(int n, int[][] edges)\\n    {\\n        var tree = new List<List<int>>();\\n\\n        for (var i = 0; i < n; i++)\\n            tree.Add(new List<int>());\\n\\n        foreach (var e in edges)\\n        {\\n            tree[e[0]].Add(e[1]);\\n            tree[e[1]].Add(e[0]);\\n        }\\n\\n        return tree;\\n    }\\n\\n    private static void Bfs(int[] trip, List<List<int>> tree, Dictionary<int, int> up)\\n    {\\n        var q = new Queue<(int, int)>();\\n        q.Enqueue((trip[0], -1));\\n\\n        while (q.Count > 0)\\n        {\\n            var (u, p) = q.Dequeue();\\n\\n            if (u == trip[1])\\n                break;\\n\\n            foreach (var v in tree[u].Where(v => v != p))\\n            {\\n                q.Enqueue((v, u));\\n                up[v] = u;\\n            }\\n        }\\n    }\\n\\n    private static (int, int) Dfs(int u, int p, List<List<int>> tree, int[] price, int[] cnt)\\n    {\\n        int whole = 0, halved = 0;\\n\\n        foreach (var v in tree[u].Where(v => v != p))\\n        {\\n            var (w, h) = Dfs(v, u, tree, price, cnt);\\n            whole += w;\\n            halved += Math.Min(w, h);\\n        }\\n\\n        return (price[u] * cnt[u] + halved, price[u] * cnt[u] / 2 + whole);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MinimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips)\\n    {\\n        var tree = InitTree(n, edges);\\n        var cnt = new int[n];\\n\\n        foreach (var trip in trips)\\n        {\\n            var up = new Dictionary<int, int> { [trip[0]] = -1 };\\n\\n            Bfs(trip, tree, up);\\n\\n            for (var u = trip[1]; u >= 0; u = up[u])\\n                cnt[u]++;\\n        }\\n\\n        var (w, h) = Dfs(0, -1, tree, price, cnt);\\n\\n        return Math.Min(w, h);\\n    }\\n\\n    private static List<List<int>> InitTree(int n, int[][] edges)\\n    {\\n        var tree = new List<List<int>>();\\n\\n        for (var i = 0; i < n; i++)\\n            tree.Add(new List<int>());\\n\\n        foreach (var e in edges)\\n        {\\n            tree[e[0]].Add(e[1]);\\n            tree[e[1]].Add(e[0]);\\n        }\\n\\n        return tree;\\n    }\\n\\n    private static void Bfs(int[] trip, List<List<int>> tree, Dictionary<int, int> up)\\n    {\\n        var q = new Queue<(int, int)>();\\n        q.Enqueue((trip[0], -1));\\n\\n        while (q.Count > 0)\\n        {\\n            var (u, p) = q.Dequeue();\\n\\n            if (u == trip[1])\\n                break;\\n\\n            foreach (var v in tree[u].Where(v => v != p))\\n            {\\n                q.Enqueue((v, u));\\n                up[v] = u;\\n            }\\n        }\\n    }\\n\\n    private static (int, int) Dfs(int u, int p, List<List<int>> tree, int[] price, int[] cnt)\\n    {\\n        int whole = 0, halved = 0;\\n\\n        foreach (var v in tree[u].Where(v => v != p))\\n        {\\n            var (w, h) = Dfs(v, u, tree, price, cnt);\\n            whole += w;\\n            halved += Math.Min(w, h);\\n        }\\n\\n        return (price[u] * cnt[u] + halved, price[u] * cnt[u] / 2 + whole);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423695,
                "title": "java-easy-to-understand-solution-dp-dfs-shortest-path",
                "content": "# Approach\\nWe want to minimize total price sum to perform all the given trips.\\n> Each trip is independent of each other.\\n\\nSo for each trip to travel in minimum price, we would find shortest path (using dijkstra shortest path algorithm).\\n\\nWe will also store path, so that we can use it to calculate freq[i] = number of times we visit ith node during our all trips.\\n\\n> You can choose some non-adjacent nodes and halve the prices.\\n\\nWe should choose nodes in such a way that they are not-adjacent and also minimize total trip cost.\\n\\n> Here, greedy approach for selecting nodes won\\'t work in all cases.\\nSo we will use DP approach.\\n\\nWe have two cases : \\n1.  Current node is selected for halving it\\'s price.\\n    - now for each of it\\'s adjacent node, we must not select them for halving their prices.\\n2.  Current node is not selected for halving it\\'s price.\\n    - now for each of it\\'s adjacent node, we may or may not select them for halving their prices. \\n\\nFinally, we will add memorization to store already calculated states, and reduce complexity.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    static class Pair implements Comparable<Pair> {\\n        int at;\\n        int dist;\\n        \\n        Pair (int at, int dist) {\\n            this.at = at;\\n            this.dist = dist;\\n        }\\n        \\n        public int compareTo(Pair p) {\\n            return Integer.compare(dist, p.dist);\\n        }\\n    }\\n    \\n    static int MAX = 51, INF = (int) 1e9;\\n    static List<Integer>[] graph = new List[MAX];\\n    static int[] distance = new int[MAX];\\n    static int[] parent = new int[MAX];\\n    static int[][] dp = new int[MAX][2];\\n    \\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        int[] freq = new int[n];\\n        for (int[] trip : trips) {\\n            shortestPath(price, freq, trip[0], trip[1]);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        return Math.min(dfs(freq, price, 0, -1, 1), dfs(freq, price, 0, -1, 0));\\n    }\\n\\n    private static int dfs(int[] freq, int[] price, int currNode, int parent, int halved) {\\n        if (dp[currNode][halved] != -1) {\\n            return dp[currNode][halved];\\n        }\\n        int total = freq[currNode] * (halved == 1 ? price[currNode] / 2 : price[currNode]);\\n        for (int adj : graph[currNode]) {\\n            if (adj != parent) {\\n                if (halved == 1) {\\n                    total += dfs(freq, price, adj, currNode, 1 - halved);\\n                }else {\\n                    total += Math.min(dfs(freq, price, adj, currNode, halved), dfs(freq, price, adj, currNode, 1 - halved));\\n                }\\n            }\\n        }\\n        dp[currNode][halved] = total;\\n        return total;\\n    }\\n    \\n    public void shortestPath(int[] price, int[] freq, int node1, int node2) {\\n        if (node1 == node2) {\\n            freq[node1]++;\\n            return;\\n        }\\n        Arrays.fill(distance, INF);\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        distance[node1] = price[node1];\\n        Arrays.fill(parent, -1);\\n        pq.add(new Pair(node1, distance[node1]));\\n        while (!pq.isEmpty()) {\\n            Pair currPair = pq.poll();\\n            int at = currPair.at;\\n            int dist = currPair.dist;\\n            if (at == node2) {\\n                int curr = node2;\\n                while (curr != node1) {\\n                    freq[curr]++;\\n                    curr = parent[curr];\\n                }\\n                freq[curr]++;\\n            }\\n            if (distance[at] < dist) {\\n                continue;\\n            }\\n            for (int adj : graph[at]) {\\n                if (distance[adj] > dist + price[adj]) {\\n                    distance[adj] = dist + price[adj];\\n                    pq.add(new Pair(adj, distance[adj]));\\n                    parent[adj] = at;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\n    \\n    static class Pair implements Comparable<Pair> {\\n        int at;\\n        int dist;\\n        \\n        Pair (int at, int dist) {\\n            this.at = at;\\n            this.dist = dist;\\n        }\\n        \\n        public int compareTo(Pair p) {\\n            return Integer.compare(dist, p.dist);\\n        }\\n    }\\n    \\n    static int MAX = 51, INF = (int) 1e9;\\n    static List<Integer>[] graph = new List[MAX];\\n    static int[] distance = new int[MAX];\\n    static int[] parent = new int[MAX];\\n    static int[][] dp = new int[MAX][2];\\n    \\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        int[] freq = new int[n];\\n        for (int[] trip : trips) {\\n            shortestPath(price, freq, trip[0], trip[1]);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        return Math.min(dfs(freq, price, 0, -1, 1), dfs(freq, price, 0, -1, 0));\\n    }\\n\\n    private static int dfs(int[] freq, int[] price, int currNode, int parent, int halved) {\\n        if (dp[currNode][halved] != -1) {\\n            return dp[currNode][halved];\\n        }\\n        int total = freq[currNode] * (halved == 1 ? price[currNode] / 2 : price[currNode]);\\n        for (int adj : graph[currNode]) {\\n            if (adj != parent) {\\n                if (halved == 1) {\\n                    total += dfs(freq, price, adj, currNode, 1 - halved);\\n                }else {\\n                    total += Math.min(dfs(freq, price, adj, currNode, halved), dfs(freq, price, adj, currNode, 1 - halved));\\n                }\\n            }\\n        }\\n        dp[currNode][halved] = total;\\n        return total;\\n    }\\n    \\n    public void shortestPath(int[] price, int[] freq, int node1, int node2) {\\n        if (node1 == node2) {\\n            freq[node1]++;\\n            return;\\n        }\\n        Arrays.fill(distance, INF);\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        distance[node1] = price[node1];\\n        Arrays.fill(parent, -1);\\n        pq.add(new Pair(node1, distance[node1]));\\n        while (!pq.isEmpty()) {\\n            Pair currPair = pq.poll();\\n            int at = currPair.at;\\n            int dist = currPair.dist;\\n            if (at == node2) {\\n                int curr = node2;\\n                while (curr != node1) {\\n                    freq[curr]++;\\n                    curr = parent[curr];\\n                }\\n                freq[curr]++;\\n            }\\n            if (distance[at] < dist) {\\n                continue;\\n            }\\n            for (int adj : graph[at]) {\\n                if (distance[adj] > dist + price[adj]) {\\n                    distance[adj] = dist + price[adj];\\n                    pq.add(new Pair(adj, distance[adj]));\\n                    parent[adj] = at;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423542,
                "title": "python-simple-dfs-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n, edges, price, trips):\\n        graph = defaultdict(list)\\n\\n        for i,j in edges:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n\\n        self.total, dict1 = 0, defaultdict(int)\\n\\n        def dfs(start,parent,end):\\n            if start == end:\\n                return True\\n\\n            for neighbor in graph[start]:\\n                if neighbor != parent:\\n                    if dfs(neighbor,start,end):\\n                        self.total += price[neighbor]\\n                        dict1[neighbor] += 1\\n                        return True\\n\\n            return False\\n\\n\\n        for start,end in trips:\\n            dict1[start] += 1\\n            self.total += price[start]\\n            dfs(start,None,end)\\n\\n        @lru_cache(None)\\n        def dp(node,parent,canReduce):\\n            if canReduce:\\n                res = (price[node]//2)*dict1[node]\\n            else:\\n                res = 0\\n\\n            tot = 0\\n\\n            for neighbor in graph[node]:\\n                if neighbor != parent:\\n                    if canReduce:\\n                        cur = dp(neighbor,node,False)\\n                    else:\\n                        cur = max(dp(neighbor,node,True),dp(neighbor,node,False))\\n                    tot += cur\\n\\n            return res + tot\\n\\n        ans = []\\n\\n        for i in range(n):\\n            ans.append(max(dp(i,None,False),dp(i,None,True)))\\n\\n        return self.total - max(ans)\\n            \\n\\n\\n\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n, edges, price, trips):\\n        graph = defaultdict(list)\\n\\n        for i,j in edges:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n\\n        self.total, dict1 = 0, defaultdict(int)\\n\\n        def dfs(start,parent,end):\\n            if start == end:\\n                return True\\n\\n            for neighbor in graph[start]:\\n                if neighbor != parent:\\n                    if dfs(neighbor,start,end):\\n                        self.total += price[neighbor]\\n                        dict1[neighbor] += 1\\n                        return True\\n\\n            return False\\n\\n\\n        for start,end in trips:\\n            dict1[start] += 1\\n            self.total += price[start]\\n            dfs(start,None,end)\\n\\n        @lru_cache(None)\\n        def dp(node,parent,canReduce):\\n            if canReduce:\\n                res = (price[node]//2)*dict1[node]\\n            else:\\n                res = 0\\n\\n            tot = 0\\n\\n            for neighbor in graph[node]:\\n                if neighbor != parent:\\n                    if canReduce:\\n                        cur = dp(neighbor,node,False)\\n                    else:\\n                        cur = max(dp(neighbor,node,True),dp(neighbor,node,False))\\n                    tot += cur\\n\\n            return res + tot\\n\\n        ans = []\\n\\n        for i in range(n):\\n            ans.append(max(dp(i,None,False),dp(i,None,True)))\\n\\n        return self.total - max(ans)\\n            \\n\\n\\n\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423526,
                "title": "python-simple-dfs-with-explanation",
                "content": "# Intuition\\nAlthough the question says we can choose any path from `u` to `v` in `trips`, in a connected tree there will always be only exactly one path from `u` to `v`\\n\\n# Approach\\nCalculate every node\\'s occurance and store them on `repeats`. `repeats[i]` means for vertex `i`, how many times does it have to appear after visiting all `trips`.\\n\\nThen we can brute-force the solution, for each vertex, we can choose either to `halve` it or not to `halve` it. Then recurse to it\\'s neighbours. We can use `lru_cache(None)` to memoize the solution to prevent repeat.\\n\\n# Complexity\\n- Time complexity:\\nO(n) where n is total number of nodes in the tree\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        adj = [[] for _ in range(n)]\\n        repeats = [0] * n\\n        inf = float(\\'inf\\')\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        for u, v in trips:\\n            stk = [u]\\n            parents = [-1] * n\\n            while len(stk):\\n                p = stk.pop()\\n                for nei in adj[p]:\\n                    if nei != parents[p]:\\n                        stk.append(nei)\\n                        parents[nei] = p\\n                        if nei == v:\\n                            break\\n            now = v\\n            while now != -1:\\n                repeats[now] += 1\\n                now = parents[now]\\n        @lru_cache(None)\\n        def dfs(vertex: int, parent: int, parent_halved: bool):\\n            # If parent already halved, then this vertex can\\'t be halved, so give it a inf\\n            halved = inf if parent_halved else (price[vertex] * repeats[vertex]) // 2\\n            not_halved = (price[vertex] * repeats[vertex])\\n            for nei in adj[vertex]:\\n                if nei == parent:\\n                    continue\\n                if halved < inf:\\n                    halved += dfs(nei, vertex, True)\\n                not_halved += dfs(nei, vertex, False)\\n            return min(halved, not_halved)\\n        return dfs(0, -1, False)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        adj = [[] for _ in range(n)]\\n        repeats = [0] * n\\n        inf = float(\\'inf\\')\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        for u, v in trips:\\n            stk = [u]\\n            parents = [-1] * n\\n            while len(stk):\\n                p = stk.pop()\\n                for nei in adj[p]:\\n                    if nei != parents[p]:\\n                        stk.append(nei)\\n                        parents[nei] = p\\n                        if nei == v:\\n                            break\\n            now = v\\n            while now != -1:\\n                repeats[now] += 1\\n                now = parents[now]\\n        @lru_cache(None)\\n        def dfs(vertex: int, parent: int, parent_halved: bool):\\n            # If parent already halved, then this vertex can\\'t be halved, so give it a inf\\n            halved = inf if parent_halved else (price[vertex] * repeats[vertex]) // 2\\n            not_halved = (price[vertex] * repeats[vertex])\\n            for nei in adj[vertex]:\\n                if nei == parent:\\n                    continue\\n                if halved < inf:\\n                    halved += dfs(nei, vertex, True)\\n                not_halved += dfs(nei, vertex, False)\\n            return min(halved, not_halved)\\n        return dfs(0, -1, False)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423037,
                "title": "easy-dfs-dp-c",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> graph ;\\n    vector<int> path , vis , cst;\\n    vector<vector<vector<int>>> dp ;\\n    int fun(int i , int par , int end){\\n        if(i==end){\\n            path[i]++ ;\\n            return 1 ;\\n        }\\n        int ans=0 ;\\n        for(auto d:graph[i]){\\n            if(d==par) continue ;\\n            if(fun(d,i,end)){\\n                 path[i]++ ;\\n                 ans++ ;\\n            }\\n        }\\n        return ans ;\\n    }\\n\\n    int cost(int i , int par , int typ){\\n        if(dp[i][par][typ]!=-1) return dp[i][par][typ] ;\\n        vis[i]=1 ;\\n        int ans=0 ;\\n        if(typ==1){\\n            for(auto d:graph[i]){\\n                if(d==par || path[d]==0) continue ;\\n                ans+=cost(d,i,0) ;\\n            }\\n            ans+=(path[i]*cst[i]) ;\\n        }\\n        if(typ==0){\\n            int temp1=0 , temp2=0 ;\\n            for(auto d:graph[i]){\\n                if(d==par || path[d]==0) continue ;\\n                temp2+=cost(d,i,1) ;\\n                temp1+=cost(d,i,0) ;\\n            }\\n            ans=min(temp1+(path[i]*cst[i]),temp2+(path[i]*(cst[i]/2))) ;\\n        }\\n        return dp[i][par][typ]=ans ;\\n    }\\n\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        graph=vector<vector<int>>(n) ;\\n        cst=price ;\\n        vis=vector<int>(n) ;\\n        path=vector<int>(n) ;\\n        dp=vector<vector<vector<int>>>(n,vector<vector<int>>(n,vector<int>(2,-1))) ;\\n        for(auto d:edges){\\n            graph[d[0]].push_back(d[1]) ;\\n            graph[d[1]].push_back(d[0]) ;\\n        }\\n        for(auto d:trips) fun(d[0],-1,d[1]) ;\\n        int ans=0 ;\\n        for(int i=0 ; i<n ; i++){\\n            if(path[i]==0 || vis[i]) continue ;\\n            ans+=cost(i,i,0) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> graph ;\\n    vector<int> path , vis , cst;\\n    vector<vector<vector<int>>> dp ;\\n    int fun(int i , int par , int end){\\n        if(i==end){\\n            path[i]++ ;\\n            return 1 ;\\n        }\\n        int ans=0 ;\\n        for(auto d:graph[i]){\\n            if(d==par) continue ;\\n            if(fun(d,i,end)){\\n                 path[i]++ ;\\n                 ans++ ;\\n            }\\n        }\\n        return ans ;\\n    }\\n\\n    int cost(int i , int par , int typ){\\n        if(dp[i][par][typ]!=-1) return dp[i][par][typ] ;\\n        vis[i]=1 ;\\n        int ans=0 ;\\n        if(typ==1){\\n            for(auto d:graph[i]){\\n                if(d==par || path[d]==0) continue ;\\n                ans+=cost(d,i,0) ;\\n            }\\n            ans+=(path[i]*cst[i]) ;\\n        }\\n        if(typ==0){\\n            int temp1=0 , temp2=0 ;\\n            for(auto d:graph[i]){\\n                if(d==par || path[d]==0) continue ;\\n                temp2+=cost(d,i,1) ;\\n                temp1+=cost(d,i,0) ;\\n            }\\n            ans=min(temp1+(path[i]*cst[i]),temp2+(path[i]*(cst[i]/2))) ;\\n        }\\n        return dp[i][par][typ]=ans ;\\n    }\\n\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        graph=vector<vector<int>>(n) ;\\n        cst=price ;\\n        vis=vector<int>(n) ;\\n        path=vector<int>(n) ;\\n        dp=vector<vector<vector<int>>>(n,vector<vector<int>>(n,vector<int>(2,-1))) ;\\n        for(auto d:edges){\\n            graph[d[0]].push_back(d[1]) ;\\n            graph[d[1]].push_back(d[0]) ;\\n        }\\n        for(auto d:trips) fun(d[0],-1,d[1]) ;\\n        int ans=0 ;\\n        for(int i=0 ; i<n ; i++){\\n            if(path[i]==0 || vis[i]) continue ;\\n            ans+=cost(i,i,0) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423027,
                "title": "similar-to-knapsack-java-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    ArrayList<ArrayList<Integer>>graph;\\n\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        graph=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n        int []visitCount=new int [n];\\n\\n        for(int i=0;i<trips.length;i++){\\n            int src=trips[i][0];\\n            int des=trips[i][1];\\n          find(src,des,visitCount,-1);\\n\\n\\n        }\\n\\n        int []cost=new int[n];\\n        for(int i=0;i<n;i++){\\n            cost[i]=price[i]*visitCount[i];\\n\\n        }\\n\\nint [][]dp=new int [n][2];\\n\\nfor(int  i=0;i<n;i++){\\n    for(int j=0;j<2;j++){\\n        dp[i][j]=-1;\\n    }\\n}\\n\\n\\nreturn min(0,cost,dp,-1,0);\\n    }\\n\\n    public int min(int node,int []cost,int [][]dp,int parent,int color)\\n    {\\n        if(dp[node][color]!=-1){\\n            return dp[node][color];\\n        }\\n        int x=0;\\n        int y=0;\\n\\n        for(int nbr:graph.get(node)){\\n            if(nbr!=parent){\\n               x+=min(nbr,cost,dp,node,0);\\n            \\n               if(color==0){\\n             y+=min(nbr,cost,dp,node,1);\\n               }\\n              \\n            }\\n          \\n        }\\n        if(color==1){\\n            return dp[node][color]=x+(cost[node]);\\n        }\\n\\n        return dp[node][color]=Math.min(x+cost[node],y+(cost[node]/2));\\n\\n\\n    \\n        \\n    }\\n\\n    public boolean find(int src,int dest,int []visitCount,int parent){\\n        visitCount[src]++;\\n        if(src==dest){\\n            return true;\\n        }\\n        for(int nbr:graph.get(src)){\\n\\n            if(nbr!=parent){\\n\\n           boolean f1= find(nbr,dest,visitCount,src);\\n           if(f1){\\n               return true;\\n           }\\n\\n            }\\n\\n        }\\n        visitCount[src]--;\\n        return false;\\n    }\\n\\n   \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    ArrayList<ArrayList<Integer>>graph;\\n\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        graph=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n        int []visitCount=new int [n];\\n\\n        for(int i=0;i<trips.length;i++){\\n            int src=trips[i][0];\\n            int des=trips[i][1];\\n          find(src,des,visitCount,-1);\\n\\n\\n        }\\n\\n        int []cost=new int[n];\\n        for(int i=0;i<n;i++){\\n            cost[i]=price[i]*visitCount[i];\\n\\n        }\\n\\nint [][]dp=new int [n][2];\\n\\nfor(int  i=0;i<n;i++){\\n    for(int j=0;j<2;j++){\\n        dp[i][j]=-1;\\n    }\\n}\\n\\n\\nreturn min(0,cost,dp,-1,0);\\n    }\\n\\n    public int min(int node,int []cost,int [][]dp,int parent,int color)\\n    {\\n        if(dp[node][color]!=-1){\\n            return dp[node][color];\\n        }\\n        int x=0;\\n        int y=0;\\n\\n        for(int nbr:graph.get(node)){\\n            if(nbr!=parent){\\n               x+=min(nbr,cost,dp,node,0);\\n            \\n               if(color==0){\\n             y+=min(nbr,cost,dp,node,1);\\n               }\\n              \\n            }\\n          \\n        }\\n        if(color==1){\\n            return dp[node][color]=x+(cost[node]);\\n        }\\n\\n        return dp[node][color]=Math.min(x+cost[node],y+(cost[node]/2));\\n\\n\\n    \\n        \\n    }\\n\\n    public boolean find(int src,int dest,int []visitCount,int parent){\\n        visitCount[src]++;\\n        if(src==dest){\\n            return true;\\n        }\\n        for(int nbr:graph.get(src)){\\n\\n            if(nbr!=parent){\\n\\n           boolean f1= find(nbr,dest,visitCount,src);\\n           if(f1){\\n               return true;\\n           }\\n\\n            }\\n\\n        }\\n        visitCount[src]--;\\n        return false;\\n    }\\n\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422979,
                "title": "dynamic-programming-0-1-concise-easy-simple-code-with-explanation",
                "content": "```\\nclass Solution {\\n    \\n    pair<int,int> minNonAdjecentPath(int u,int parent,vector<int>&price,unordered_map<int,int>&mp,vector<int>adj[]){\\n        int considerHalf = (price[u]/2)*mp[u];\\n        int notConsiderHalf = (price[u])*mp[u];\\n        for(auto v: adj[u]){\\n            if(v==parent) continue;\\n            pair<int,int>childAns = minNonAdjecentPath(v,u,price,mp,adj);\\n            notConsiderHalf +=min(childAns.first,childAns.second);\\n            \\n            considerHalf+=childAns.second;\\n        }\\n        \\n        return {considerHalf,notConsiderHalf};\\n    }\\n    \\npublic:\\n    // Use to calculate the contribution/count of each node in the whole trips....\\n    bool dfs(vector<int>adj[],int src,int des,bool vis[],unordered_map<int,int>&mp){\\n        vis[src]=true;\\n        mp[src]++;\\n        if(src==des)\\n            return true;\\n        for(auto x: adj[src]){\\n            if(vis[x]==false){\\n                bool b =  dfs(adj,x,des,vis,mp);\\n                if(b) return b;\\n            }\\n        }\\n        mp[src]--;\\n        return false;\\n    }\\n    \\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int>adj[n];\\n        for(auto x: edges){\\n            int src = x[0],des=x[1];\\n            adj[src].push_back(des);\\n            adj[des].push_back(src);\\n        }\\n        \\n        unordered_map<int,int>mp;\\n        for(auto x: trips){\\n            int src = x[0],des=x[1];\\n            bool vis[n]; memset(vis,false,sizeof(vis));\\n            dfs(adj,src,des,vis,mp);\\n        }\\n        \\n      \\n        pair<int,int> ans = minNonAdjecentPath(0,-1,price,mp,adj);\\n        return min(ans.first,ans.second);\\n    }\\n};\\n```\\n\\nTime Complexity -> O(n)  // It\\'s like kind of post order traversal & we traversed each node only once\\nSpace Complexity -> O(n)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    pair<int,int> minNonAdjecentPath(int u,int parent,vector<int>&price,unordered_map<int,int>&mp,vector<int>adj[]){\\n        int considerHalf = (price[u]/2)*mp[u];\\n        int notConsiderHalf = (price[u])*mp[u];\\n        for(auto v: adj[u]){\\n            if(v==parent) continue;\\n            pair<int,int>childAns = minNonAdjecentPath(v,u,price,mp,adj);\\n            notConsiderHalf +=min(childAns.first,childAns.second);\\n            \\n            considerHalf+=childAns.second;\\n        }\\n        \\n        return {considerHalf,notConsiderHalf};\\n    }\\n    \\npublic:\\n    // Use to calculate the contribution/count of each node in the whole trips....\\n    bool dfs(vector<int>adj[],int src,int des,bool vis[],unordered_map<int,int>&mp){\\n        vis[src]=true;\\n        mp[src]++;\\n        if(src==des)\\n            return true;\\n        for(auto x: adj[src]){\\n            if(vis[x]==false){\\n                bool b =  dfs(adj,x,des,vis,mp);\\n                if(b) return b;\\n            }\\n        }\\n        mp[src]--;\\n        return false;\\n    }\\n    \\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int>adj[n];\\n        for(auto x: edges){\\n            int src = x[0],des=x[1];\\n            adj[src].push_back(des);\\n            adj[des].push_back(src);\\n        }\\n        \\n        unordered_map<int,int>mp;\\n        for(auto x: trips){\\n            int src = x[0],des=x[1];\\n            bool vis[n]; memset(vis,false,sizeof(vis));\\n            dfs(adj,src,des,vis,mp);\\n        }\\n        \\n      \\n        pair<int,int> ans = minNonAdjecentPath(0,-1,price,mp,adj);\\n        return min(ans.first,ans.second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422768,
                "title": "java-dfs-dp-on-graphs",
                "content": "Given, that its a tree, we are always sure of what the path will be irrespective of the cost.\\nHence, we first compute how many times we visit all  nodes, after completing all the trips.\\nThen we traverse the complete tree, and check whether we should halve a particular node or keep it just as it is.\\nAnd at every node compute the amount we need to take from the node.\\nSince there will be repeating subproblems of again visiting a node with option to check whether we should halve it or not, we use2D DP matrix.\\n```\\nclass Solution {\\n\\n    public void countNodesInPath(int start, int end, int[][] adj, Map<Integer, Integer> count, List<Integer> ls, int[] vis) {\\n        if (vis[start] != -1) return;\\n        vis[start] = 1;\\n        if (start == end) {\\n            for (int i = 0; i < ls.size(); i++) {\\n                count.put(ls.get(i), count.getOrDefault(ls.get(i), 0) + 1);\\n            }\\n            return;\\n        }\\n        for (int j = 0; j < adj[start].length; j++) {\\n            if (adj[start][j] == 1) {\\n                ls.add(j);\\n                countNodesInPath(j, end, adj, count, ls, vis);\\n                ls.remove(ls.size() - 1);\\n            }\\n        }\\n    }\\n\\n    public int calcPrice(int start, int[][] adj, boolean prev, int[] prices, Map<Integer, Integer> count, int parent, int[][] dp) {\\n        int halve = 0;\\n        int yy = 0;\\n        if (prev == true) yy = 1;\\n        if (dp[start][yy] != -1) return dp[start][yy];\\n        if (prev == false) {\\n            for (int i = 0; i < adj[start].length; i++) {\\n                if (adj[start][i] == 1 && i != parent) {\\n                    halve += calcPrice(i, adj, true, prices, count, start, dp);\\n                }\\n            }\\n            halve += (prices[start] / 2) * count.getOrDefault(start, 0);\\n        }\\n        int nothalve = 0;\\n        for (int i = 0; i < adj[start].length; i++) {\\n            if (adj[start][i] == 1 && i != parent) {\\n                nothalve += calcPrice(i, adj, false, prices, count, start, dp);\\n            }\\n        }\\n        nothalve += prices[start] * count.getOrDefault(start, 0);\\n        if (prev == true) halve = Integer.MAX_VALUE;\\n        return dp[start][yy] = Math.min(halve, nothalve);\\n    }\\n\\n    public int minimumTotalPrice(int n, int[][] edges, int[] prices, int[][] trips) {\\n        int[][] adj = new int[n][n];\\n        int[][] dp = new int[n][2];\\n        for (int i = 0; i < dp.length; i++) Arrays.fill(dp[i], -1);\\n        for (int i = 0; i < edges.length; i++) {\\n            adj[edges[i][0]][edges[i][1]] = 1;\\n            adj[edges[i][1]][edges[i][0]] = 1;\\n        }\\n        int[] vis = new int[n];\\n        Map<Integer, Integer> count = new HashMap();\\n        for (int i = 0; i < trips.length; i++) {\\n            int start = trips[i][0];\\n            int end = trips[i][1];\\n            List<Integer> pathList = new ArrayList();\\n            pathList.add(start);\\n            Arrays.fill(vis, -1);\\n            countNodesInPath(start, end, adj, count, pathList, vis);\\n        }\\n        return calcPrice(0, adj, false, prices, count, -1, dp);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    public void countNodesInPath(int start, int end, int[][] adj, Map<Integer, Integer> count, List<Integer> ls, int[] vis) {\\n        if (vis[start] != -1) return;\\n        vis[start] = 1;\\n        if (start == end) {\\n            for (int i = 0; i < ls.size(); i++) {\\n                count.put(ls.get(i), count.getOrDefault(ls.get(i), 0) + 1);\\n            }\\n            return;\\n        }\\n        for (int j = 0; j < adj[start].length; j++) {\\n            if (adj[start][j] == 1) {\\n                ls.add(j);\\n                countNodesInPath(j, end, adj, count, ls, vis);\\n                ls.remove(ls.size() - 1);\\n            }\\n        }\\n    }\\n\\n    public int calcPrice(int start, int[][] adj, boolean prev, int[] prices, Map<Integer, Integer> count, int parent, int[][] dp) {\\n        int halve = 0;\\n        int yy = 0;\\n        if (prev == true) yy = 1;\\n        if (dp[start][yy] != -1) return dp[start][yy];\\n        if (prev == false) {\\n            for (int i = 0; i < adj[start].length; i++) {\\n                if (adj[start][i] == 1 && i != parent) {\\n                    halve += calcPrice(i, adj, true, prices, count, start, dp);\\n                }\\n            }\\n            halve += (prices[start] / 2) * count.getOrDefault(start, 0);\\n        }\\n        int nothalve = 0;\\n        for (int i = 0; i < adj[start].length; i++) {\\n            if (adj[start][i] == 1 && i != parent) {\\n                nothalve += calcPrice(i, adj, false, prices, count, start, dp);\\n            }\\n        }\\n        nothalve += prices[start] * count.getOrDefault(start, 0);\\n        if (prev == true) halve = Integer.MAX_VALUE;\\n        return dp[start][yy] = Math.min(halve, nothalve);\\n    }\\n\\n    public int minimumTotalPrice(int n, int[][] edges, int[] prices, int[][] trips) {\\n        int[][] adj = new int[n][n];\\n        int[][] dp = new int[n][2];\\n        for (int i = 0; i < dp.length; i++) Arrays.fill(dp[i], -1);\\n        for (int i = 0; i < edges.length; i++) {\\n            adj[edges[i][0]][edges[i][1]] = 1;\\n            adj[edges[i][1]][edges[i][0]] = 1;\\n        }\\n        int[] vis = new int[n];\\n        Map<Integer, Integer> count = new HashMap();\\n        for (int i = 0; i < trips.length; i++) {\\n            int start = trips[i][0];\\n            int end = trips[i][1];\\n            List<Integer> pathList = new ArrayList();\\n            pathList.add(start);\\n            Arrays.fill(vis, -1);\\n            countNodesInPath(start, end, adj, count, pathList, vis);\\n        }\\n        return calcPrice(0, adj, false, prices, count, -1, dp);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422644,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn minimum_total_price(n: i32, edges: Vec<Vec<i32>>, price: Vec<i32>, trips: Vec<Vec<i32>>) -> i32 {\\n        let mut dp = vec![vec![-1; 2]; 51]; // dp optimization to not recalculate values\\n        let mut mp = vec![0; 51]; // count how many times a node is used in trips\\n\\n        let mut adj = vec![vec![]; n as usize];\\n        for i in edges {\\n            adj[i[0] as usize].push(i[1]);\\n            adj[i[1] as usize].push(i[0]);\\n        }\\n        for i in trips.iter() {\\n            Self::count_paths(&mut mp, &adj, i[0], i[1]);\\n        }\\n        Self::dfs(&mut dp, &mp, &adj, 0, &price, true, -1)\\n    }\\n\\n    fn count_paths(mp: &mut [i32], adj: &[Vec<i32>], x: i32, y: i32) {\\n        let mut q = std::collections::VecDeque::new();\\n        q.push_back((x, -1));\\n        let mut vis = vec![0; 51];\\n        let mut last = vec![0; 51]; // so we can efficiently backtrack the path from node a to node b\\n        while !q.is_empty() {\\n            let (mut t, p) = q.pop_front().unwrap();\\n            if vis[t as usize] != 0 {\\n                vis[t as usize] += 1;\\n                continue;\\n            }\\n            vis[t as usize] += 1;\\n            last[t as usize] = p;\\n            if t == y {\\n                while t != -1 {\\n                    mp[t as usize] += 1;\\n                    t = last[t as usize];\\n                }\\n                return;\\n            }\\n            for i in &adj[t as usize] {\\n                q.push_back((*i, t));\\n            }\\n        }\\n    }\\n\\n    #[allow(clippy::too_many_arguments)]\\n    fn dfs(dp: &mut Vec<Vec<i32>>, mp: &Vec<i32>, adj: &Vec<Vec<i32>>, pos: usize, price: &Vec<i32>, can_take: bool, last: i32) -> i32 {\\n        if dp[pos][can_take as usize] != -1 {\\n            return dp[pos][can_take as usize];\\n        }\\n        let mut ans = price[pos] * mp[pos];\\n        let mut res1 = 0;\\n        let mut res2 = 0;\\n        for &i in &adj[pos] {\\n            if i != last {\\n                res1 += Self::dfs(dp, mp, adj, i as usize, price, true, pos as i32);\\n            }\\n        }\\n        if can_take {\\n            for &i in &adj[pos] {\\n                if i != last {\\n                    res2 += Self::dfs(dp, mp, adj, i as usize, price, false, pos as i32);\\n                }\\n            }\\n            ans = (ans + res1).min(ans / 2 + res2);\\n        } else {\\n            ans += res1;\\n        }\\n        dp[pos][can_take as usize] = ans;\\n        ans\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_total_price(n: i32, edges: Vec<Vec<i32>>, price: Vec<i32>, trips: Vec<Vec<i32>>) -> i32 {\\n        let mut dp = vec![vec![-1; 2]; 51]; // dp optimization to not recalculate values\\n        let mut mp = vec![0; 51]; // count how many times a node is used in trips\\n\\n        let mut adj = vec![vec![]; n as usize];\\n        for i in edges {\\n            adj[i[0] as usize].push(i[1]);\\n            adj[i[1] as usize].push(i[0]);\\n        }\\n        for i in trips.iter() {\\n            Self::count_paths(&mut mp, &adj, i[0], i[1]);\\n        }\\n        Self::dfs(&mut dp, &mp, &adj, 0, &price, true, -1)\\n    }\\n\\n    fn count_paths(mp: &mut [i32], adj: &[Vec<i32>], x: i32, y: i32) {\\n        let mut q = std::collections::VecDeque::new();\\n        q.push_back((x, -1));\\n        let mut vis = vec![0; 51];\\n        let mut last = vec![0; 51]; // so we can efficiently backtrack the path from node a to node b\\n        while !q.is_empty() {\\n            let (mut t, p) = q.pop_front().unwrap();\\n            if vis[t as usize] != 0 {\\n                vis[t as usize] += 1;\\n                continue;\\n            }\\n            vis[t as usize] += 1;\\n            last[t as usize] = p;\\n            if t == y {\\n                while t != -1 {\\n                    mp[t as usize] += 1;\\n                    t = last[t as usize];\\n                }\\n                return;\\n            }\\n            for i in &adj[t as usize] {\\n                q.push_back((*i, t));\\n            }\\n        }\\n    }\\n\\n    #[allow(clippy::too_many_arguments)]\\n    fn dfs(dp: &mut Vec<Vec<i32>>, mp: &Vec<i32>, adj: &Vec<Vec<i32>>, pos: usize, price: &Vec<i32>, can_take: bool, last: i32) -> i32 {\\n        if dp[pos][can_take as usize] != -1 {\\n            return dp[pos][can_take as usize];\\n        }\\n        let mut ans = price[pos] * mp[pos];\\n        let mut res1 = 0;\\n        let mut res2 = 0;\\n        for &i in &adj[pos] {\\n            if i != last {\\n                res1 += Self::dfs(dp, mp, adj, i as usize, price, true, pos as i32);\\n            }\\n        }\\n        if can_take {\\n            for &i in &adj[pos] {\\n                if i != last {\\n                    res2 += Self::dfs(dp, mp, adj, i as usize, price, false, pos as i32);\\n                }\\n            }\\n            ans = (ans + res1).min(ans / 2 + res2);\\n        } else {\\n            ans += res1;\\n        }\\n        dp[pos][can_take as usize] = ans;\\n        ans\\n    }\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422552,
                "title": "c-dfs-dp-solution",
                "content": "\\n# Approach\\nfirst store the nodes which occurs in the path of all trips . This can be done using simple dfs and lca concept .Then apply dfs with memoization to calculate the final answer.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\n#define pb push_back\\nclass Solution {\\npublic:\\n    vector<int>lvl,par,vis;\\n    map<int,int>mp;\\n    vector<vector<int>>dp;\\n    void dfs(int src,vector<vector<int>>&g,int p,int l)\\n    {\\n        lvl[src]=l;\\n        par[src]=p;\\n        for(auto &itr:g[src])\\n        {\\n            if(itr!=p)\\n            {\\n                dfs(itr,g,src,l+1);\\n            }\\n        }\\n        return;\\n    }\\n    void lca(int x,int y,vector<int>&p)\\n    {\\n        if(lvl[x]<lvl[y])\\n        {\\n            swap(x,y);\\n        }\\n        while(lvl[x]>lvl[y])\\n        {\\n            mp[x]+=p[x];\\n            x=par[x];\\n        }\\n        while(x!=y)\\n        {\\n         mp[x]+=p[x],mp[y]+=p[y];\\n         x=par[x],y=par[y];\\n        }\\n        mp[x]+=p[x];\\n        return;\\n    }\\n    \\n    int func(int src,int take,vector<vector<int>>&g,int p)\\n    {\\n        if(dp[src][take]!=-1)\\n        {\\n            return dp[src][take];\\n        }\\n        int a=mp[src],b=mp[src]/2;\\n        for(auto &itr:g[src])\\n        {\\n            if(itr!=p and mp.count(itr))\\n            {\\n                a+=func(itr,0,g,src),b+=func(itr,1,g,src);\\n            }\\n        }\\n        if(take)\\n        {\\n           return a; \\n        }\\n        return dp[src][take]=min(a,b);\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& p, vector<vector<int>>& t) {\\n        vector<vector<int>>g(n);\\n        vis.assign(n,false);\\n        dp.assign(n,vector<int>(2,-1));\\n        for(auto &itr:edges)\\n        {\\n            g[itr[0]].pb(itr[1]);\\n            g[itr[1]].pb(itr[0]);\\n        }\\n        lvl.assign(n,0),par.assign(n,-1);\\n        dfs(0,g,-1,0);\\n        for(auto &itr:t)\\n        {\\n            lca(itr[0],itr[1],p);\\n        }\\n        \\n        int ans=0;\\n        for(auto &itr:mp)\\n        {\\n            if(dp[itr.first][0]!=-1)\\n            {\\n                continue;\\n            }\\n            ans+=func(itr.first,0,g,-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\n#define pb push_back\\nclass Solution {\\npublic:\\n    vector<int>lvl,par,vis;\\n    map<int,int>mp;\\n    vector<vector<int>>dp;\\n    void dfs(int src,vector<vector<int>>&g,int p,int l)\\n    {\\n        lvl[src]=l;\\n        par[src]=p;\\n        for(auto &itr:g[src])\\n        {\\n            if(itr!=p)\\n            {\\n                dfs(itr,g,src,l+1);\\n            }\\n        }\\n        return;\\n    }\\n    void lca(int x,int y,vector<int>&p)\\n    {\\n        if(lvl[x]<lvl[y])\\n        {\\n            swap(x,y);\\n        }\\n        while(lvl[x]>lvl[y])\\n        {\\n            mp[x]+=p[x];\\n            x=par[x];\\n        }\\n        while(x!=y)\\n        {\\n         mp[x]+=p[x],mp[y]+=p[y];\\n         x=par[x],y=par[y];\\n        }\\n        mp[x]+=p[x];\\n        return;\\n    }\\n    \\n    int func(int src,int take,vector<vector<int>>&g,int p)\\n    {\\n        if(dp[src][take]!=-1)\\n        {\\n            return dp[src][take];\\n        }\\n        int a=mp[src],b=mp[src]/2;\\n        for(auto &itr:g[src])\\n        {\\n            if(itr!=p and mp.count(itr))\\n            {\\n                a+=func(itr,0,g,src),b+=func(itr,1,g,src);\\n            }\\n        }\\n        if(take)\\n        {\\n           return a; \\n        }\\n        return dp[src][take]=min(a,b);\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& p, vector<vector<int>>& t) {\\n        vector<vector<int>>g(n);\\n        vis.assign(n,false);\\n        dp.assign(n,vector<int>(2,-1));\\n        for(auto &itr:edges)\\n        {\\n            g[itr[0]].pb(itr[1]);\\n            g[itr[1]].pb(itr[0]);\\n        }\\n        lvl.assign(n,0),par.assign(n,-1);\\n        dfs(0,g,-1,0);\\n        for(auto &itr:t)\\n        {\\n            lca(itr[0],itr[1],p);\\n        }\\n        \\n        int ans=0;\\n        for(auto &itr:mp)\\n        {\\n            if(dp[itr.first][0]!=-1)\\n            {\\n                continue;\\n            }\\n            ans+=func(itr.first,0,g,-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422438,
                "title": "c-solution-using-dfs-and-memoization",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    vector<int> total[50];\\n    vector<int> a;\\n    int f[50]={};\\n    int dp[50][2];\\n    bool dfs1(int p,int index,int target)\\n    {\\n        if(index==target)\\n        {\\n            f[index]++;\\n            return true;\\n        }\\n        bool result=false;\\n        for(int i=0;i<total[index].size();i++)\\n            if(total[index][i]!=p) result|=dfs1(index,total[index][i],target);\\n\\n        if(result) f[index]++;\\n        return result;\\n    }\\n    int dfs2(int p,int index,bool adjacent)\\n    {\\n        if(dp[index][adjacent]!=-1) return dp[index][adjacent];\\n        int result=0,t1=0,t2=0;\\n        for(int i=0;i<total[index].size();i++)\\n        {\\n            if(p!=total[index][i])\\n            {\\n                t1+=min(dfs2(index,total[index][i],true),dfs2(index,total[index][i],false));\\n                t2+=dfs2(index,total[index][i],true);\\n            }\\n        }\\n        if(adjacent) result=f[index]*a[index]+t1;\\n        else result=min(f[index]*a[index]+t1,f[index]*a[index]/2+t2);\\n        dp[index][adjacent]=result;\\n        return result;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) \\n    {\\n        int m=edges.size(),t=trips.size();\\n        a=price;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<m;i++) total[edges[i][0]].push_back(edges[i][1]),total[edges[i][1]].push_back(edges[i][0]);\\n        for(int i=0;i<t;i++) dfs1(-1,trips[i][0],trips[i][1]);\\n        return dfs2(-1,0,false);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    vector<int> total[50];\\n    vector<int> a;\\n    int f[50]={};\\n    int dp[50][2];\\n    bool dfs1(int p,int index,int target)\\n    {\\n        if(index==target)\\n        {\\n            f[index]++;\\n            return true;\\n        }\\n        bool result=false;\\n        for(int i=0;i<total[index].size();i++)\\n            if(total[index][i]!=p) result|=dfs1(index,total[index][i],target);\\n\\n        if(result) f[index]++;\\n        return result;\\n    }\\n    int dfs2(int p,int index,bool adjacent)\\n    {\\n        if(dp[index][adjacent]!=-1) return dp[index][adjacent];\\n        int result=0,t1=0,t2=0;\\n        for(int i=0;i<total[index].size();i++)\\n        {\\n            if(p!=total[index][i])\\n            {\\n                t1+=min(dfs2(index,total[index][i],true),dfs2(index,total[index][i],false));\\n                t2+=dfs2(index,total[index][i],true);\\n            }\\n        }\\n        if(adjacent) result=f[index]*a[index]+t1;\\n        else result=min(f[index]*a[index]+t1,f[index]*a[index]/2+t2);\\n        dp[index][adjacent]=result;\\n        return result;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) \\n    {\\n        int m=edges.size(),t=trips.size();\\n        a=price;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<m;i++) total[edges[i][0]].push_back(edges[i][1]),total[edges[i][1]].push_back(edges[i][0]);\\n        for(int i=0;i<t;i++) dfs1(-1,trips[i][0],trips[i][1]);\\n        return dfs2(-1,0,false);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422370,
                "title": "dfs-to-find-paths-and-minimum-cost",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n$$O(T * (V + E))$$\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        graph = defaultdict(set)\\n        for u, v in edges:\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        parent = [-1] * n\\n        cur = []\\n        \\n        # DFS to find out the path from s to e\\n        def path(node, p, e):\\n            cur.append(node)\\n            if node == e:\\n                cnts.update(cur)\\n            else:\\n                for c in graph[node]:\\n                    if c != p:\\n                        path(c, node, e)\\n            cur.pop()\\n\\n        # Compute the freq of node in all the trip paths\\n        cnts = Counter()\\n        for s, e in trips:\\n            path(s, -1, e)\\n        \\n        # DFS to check all half combinations to find minimum cost\\n        # Use cache to do dp memoization\\n        @lru_cache(None)\\n        def dfs(node, p):\\n            # node not chosen\\n            a = cnts[node] * price[node]\\n            for c in graph[node]:\\n                if c != p:\\n                    a += dfs(c, node)\\n            \\n            # node chosen\\n            b = cnts[node] * price[node] // 2\\n            for c in graph[node]:\\n                if c != p:\\n                    b += cnts[c] * price[c]\\n                    for cc in graph[c]:\\n                        if cc != node:\\n                            b += dfs(cc, c)\\n            return min(a, b)\\n        return dfs(0, -1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        graph = defaultdict(set)\\n        for u, v in edges:\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        parent = [-1] * n\\n        cur = []\\n        \\n        # DFS to find out the path from s to e\\n        def path(node, p, e):\\n            cur.append(node)\\n            if node == e:\\n                cnts.update(cur)\\n            else:\\n                for c in graph[node]:\\n                    if c != p:\\n                        path(c, node, e)\\n            cur.pop()\\n\\n        # Compute the freq of node in all the trip paths\\n        cnts = Counter()\\n        for s, e in trips:\\n            path(s, -1, e)\\n        \\n        # DFS to check all half combinations to find minimum cost\\n        # Use cache to do dp memoization\\n        @lru_cache(None)\\n        def dfs(node, p):\\n            # node not chosen\\n            a = cnts[node] * price[node]\\n            for c in graph[node]:\\n                if c != p:\\n                    a += dfs(c, node)\\n            \\n            # node chosen\\n            b = cnts[node] * price[node] // 2\\n            for c in graph[node]:\\n                if c != p:\\n                    b += cnts[c] * price[c]\\n                    for cc in graph[c]:\\n                        if cc != node:\\n                            b += dfs(cc, c)\\n            return min(a, b)\\n        return dfs(0, -1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422313,
                "title": "javascript-tree-dp-114ms",
                "content": "prerequisite: https://leetcode.com/problems/house-robber-iii/\\n```\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst packUG = (g, edges) => { for (const [u, v] of edges) { g[u].push(v); g[v].push(u); } };\\nconst initialize2DArray = (n, m) => [...Array(n)].map(() => Array(m).fill(0));\\n\\nlet g, cnt, dp, price;\\nconst minimumTotalPrice = (n, edges, p, trips) => {\\n    g = initializeGraph(n), cnt = Array(n).fill(0), dp = initialize2DArray(n, 2), price = p;\\n    packUG(g, edges);\\n    for (const [u, v] of trips) tree_dp(u, -1, v);\\n    house_robber_III(0, -1);\\n    let res = 0;\\n    for (let i = 0; i < n; i++) res += cnt[i] * price[i];\\n    return res - Math.max(...dp[0]);\\n};\\n\\nconst tree_dp = (cur, par, dest) => {\\n    if (cur == dest) {\\n        cnt[cur]++;\\n        return true;\\n    }\\n    for (const child of g[cur]) {\\n        if (child != par && tree_dp(child, cur, dest)) {\\n            cnt[cur]++;\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n\\nconst house_robber_III = (cur, par) => {\\n    dp[cur] = [0, cnt[cur] * price[cur] / 2];\\n    for (const child of g[cur]) {\\n        if (child != par) {\\n            house_robber_III(child, cur)\\n            dp[cur][0] += Math.max(...dp[child]);\\n            dp[cur][1] += dp[child][0];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Tree",
                    "Graph"
                ],
                "code": "```\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst packUG = (g, edges) => { for (const [u, v] of edges) { g[u].push(v); g[v].push(u); } };\\nconst initialize2DArray = (n, m) => [...Array(n)].map(() => Array(m).fill(0));\\n\\nlet g, cnt, dp, price;\\nconst minimumTotalPrice = (n, edges, p, trips) => {\\n    g = initializeGraph(n), cnt = Array(n).fill(0), dp = initialize2DArray(n, 2), price = p;\\n    packUG(g, edges);\\n    for (const [u, v] of trips) tree_dp(u, -1, v);\\n    house_robber_III(0, -1);\\n    let res = 0;\\n    for (let i = 0; i < n; i++) res += cnt[i] * price[i];\\n    return res - Math.max(...dp[0]);\\n};\\n\\nconst tree_dp = (cur, par, dest) => {\\n    if (cur == dest) {\\n        cnt[cur]++;\\n        return true;\\n    }\\n    for (const child of g[cur]) {\\n        if (child != par && tree_dp(child, cur, dest)) {\\n            cnt[cur]++;\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n\\nconst house_robber_III = (cur, par) => {\\n    dp[cur] = [0, cnt[cur] * price[cur] / 2];\\n    for (const child of g[cur]) {\\n        if (child != par) {\\n            house_robber_III(child, cur)\\n            dp[cur][0] += Math.max(...dp[child]);\\n            dp[cur][1] += dp[child][0];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422301,
                "title": "dp-solution-also-harder-followup-with-lca",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe can store the sum of the cost of each node in all the trips combined in the cost array.\\nFor this, we first run a dfs to get the path for each trip. \\n\\nnow we know the cost of each node in all the paths (or trips), we are going to make. \\n\\nNow, we can write a dp solution on this cost array.\\nWe root the tree at node 0 and then calculate.\\n\\ndp[u][0] = the cost in the subtree of node u if we do not halve the cost of this node.\\n\\ndp[u][1]= the cost in the subtree of node u if we do halve the cost of this node.\\n\\nIf we don\\'t halve this node, then we can either halve the children or not, we will take the minimum of that.\\n\\nIf we do halve this node\\'s cost, then we cannot halve the children\\'s cost.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n x trips.size()+2*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# followUp\\n\\nNow, if N <=10^5 and trips <=10^5, this solution won\\'t work. \\n\\nin that case, we will first build two trees after rooting at node 0.\\n\\nin one tree, we will halve the odd levels and in other one, we will halve the even levels. we will calculate the answer for both the trees and return the minimum.\\n\\nto calculate for a tree, we will first store the root to node sum for every node and store it in some array. let\\'s say this array is __root_sum__\\n\\nNow, we will calculate the LCA with binary lifting.\\n\\nfor every trip(u, v), \\n\\npath_sum(u, v) = root_sum[u]+root_sum[v] - 2* root_sum[LCA] + price[LCA];\\n\\nwe will calculate this for both the trees and then just take their minimum.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>path;\\n    void dfs(int u, int par, int dest, vector<int>adj[], vector<int>&p){\\n        p.push_back(u);\\n        if(u==dest){\\n            path=p;\\n            p.pop_back();\\n            return;\\n        }\\n        for(int j: adj[u]){\\n            if(j==par)continue;\\n            dfs(j, u, dest, adj, p);\\n        }\\n        p.pop_back();\\n    }\\n    int dp[50][2];\\n    void dfs2(int u, int par, vector<int>adj[], vector<int>&cost){\\n        for(int j: adj[u]){\\n            if(j==par)continue;\\n            dfs2(j, u, adj, cost);\\n        }\\n        dp[u][1]=cost[u]/2;\\n        dp[u][0]=cost[u];\\n        for(int j: adj[u]){\\n            if(j==par)continue;\\n            dp[u][0]+=min(dp[j][0], dp[j][1]);\\n            dp[u][1]+=dp[j][0];\\n        }\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int>adj[n];\\n        for(auto &it: edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int>cost(n, 0);\\n        for(auto &it: trips){\\n            vector<int>p;\\n            path.clear();\\n            dfs(it[0], -1, it[1], adj, p);\\n            for(int i: path){\\n                //cout<<i<<\" \"<<endl;\\n                cost[i]+=price[i];\\n            }\\n        }\\n        //cout<<\"chu\"<<endl;\\n        dfs2(0, -1, adj, cost);\\n        return min(dp[0][0], dp[0][1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>path;\\n    void dfs(int u, int par, int dest, vector<int>adj[], vector<int>&p){\\n        p.push_back(u);\\n        if(u==dest){\\n            path=p;\\n            p.pop_back();\\n            return;\\n        }\\n        for(int j: adj[u]){\\n            if(j==par)continue;\\n            dfs(j, u, dest, adj, p);\\n        }\\n        p.pop_back();\\n    }\\n    int dp[50][2];\\n    void dfs2(int u, int par, vector<int>adj[], vector<int>&cost){\\n        for(int j: adj[u]){\\n            if(j==par)continue;\\n            dfs2(j, u, adj, cost);\\n        }\\n        dp[u][1]=cost[u]/2;\\n        dp[u][0]=cost[u];\\n        for(int j: adj[u]){\\n            if(j==par)continue;\\n            dp[u][0]+=min(dp[j][0], dp[j][1]);\\n            dp[u][1]+=dp[j][0];\\n        }\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int>adj[n];\\n        for(auto &it: edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int>cost(n, 0);\\n        for(auto &it: trips){\\n            vector<int>p;\\n            path.clear();\\n            dfs(it[0], -1, it[1], adj, p);\\n            for(int i: path){\\n                //cout<<i<<\" \"<<endl;\\n                cost[i]+=price[i];\\n            }\\n        }\\n        //cout<<\"chu\"<<endl;\\n        dfs2(0, -1, adj, cost);\\n        return min(dp[0][0], dp[0][1]);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3422294,
                "title": "java-recursion-dp-intuitive-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven a pair of nodes in a tree, there is one and only one route between them. This is an interesting attribute of tree.\\nAnd this means given the `trips` as input, we can infer all the routes, thus we know how many times to pay for each node.\\nThen with DP, calculate where to apply the half price discount: if a node already uses the discount, its children cannot use it, otherwise its children are free to use the it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Convert the list of edges into a neighbor map.\\n2. Pick any node as `root`, so it is easier to use recursion.\\n3. Find the path from `root` to each node, so it is easy to\\n4. Find the route between any pair of nodes, to\\n5. Count how many times to pay for each node\\n6. Use DP to calculate the min total price.\\n  - \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log(n) * trips.length): assuming the tree is balanced.\\nIn worst case, it becomes O(n * trips.length)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n * log(n)) : the path from `root` to each node takes log(n), assuming the tree is balanced.\\nIn worst case, it becomes O(n^2)\\n\\n# Code\\n```\\n// Auxiliary class for values shared across methods.\\nclass Solver {\\n  private final int n;\\n  private final int[][] edges;\\n  private final int[] price;\\n  private final int[][] trips;\\n\\n  // neighbors[i] is a list of all neighbors of node i\\n  private final List<List<Integer>> neighbors = new ArrayList<>();\\n\\n  // Arbitrarily selected root of the tree. (Actual value is set later.)\\n  private int root = 0;\\n\\n  // paths[i] is a list of nodes: [root, ancestor1, ancestor2, ..., node] .\\n  private final List<List<Integer>> paths = new ArrayList<>();\\n\\n  // Need to pay node i passingCount[i] times.\\n  private int[] passingCount;\\n\\n  public Solver(int n, int[][] edges, int[] price, int[][] trips) {\\n    this.n = n;\\n    this.edges = edges;\\n    this.price = price;\\n    this.trips = trips;\\n\\n    // Initializes Lists and arrays to size n.\\n    for (int i = 0; i < n; i++) {\\n      neighbors.add(new ArrayList<>());\\n    }\\n    for (int i = 0; i < n; i++) {\\n      paths.add(new ArrayList<>());\\n    }\\n    this.passingCount = new int[n];\\n  }\\n\\n  public int run() {\\n    // Translates edges to a map of neighbors for easier look up.\\n    for (int[] edge : edges) {\\n      neighbors.get(edge[0]).add(edge[1]);\\n      neighbors.get(edge[1]).add(edge[0]);\\n    }\\n\\n    // Picks an arbitrary node as root, for easier implementation of recursion.\\n    for (int i = 0; i < n; i++) {\\n      if (neighbors.get(i).size() > neighbors.get(root).size()) {\\n        root = i;\\n      }\\n    }\\n\\n    // Finds the path from root to every node.\\n    fillPath(root, new ArrayList<>());\\n\\n    // Translates each trip to all passing nodes.\\n    for (int[] trip : trips) {\\n      List<Integer> path0 = paths.get(trip[0]);\\n      List<Integer> path1 = paths.get(trip[1]);\\n      int share = 0;    // Every path share the root node.\\n      for (int i = 1; i < path0.size() && i < path1.size(); i++) {\\n        if (path0.get(i) == path1.get(i)) {\\n          share = i;\\n        } else {\\n          break;\\n        }\\n      }\\n\\n      for (int i = share; i < path0.size(); i++) {\\n        passingCount[path0.get(i)]++;\\n      }\\n\\n      // Count the shared node only once.\\n      for (int i = share + 1; i < path1.size(); i++) {\\n        passingCount[path1.get(i)]++;\\n      }\\n    }\\n\\n    // DP to find the min total price.\\n    return minPrice(root, -1, true, new HashMap<>());\\n  }\\n\\n  private int minPrice(int root, int parent, boolean halfable, Map<Integer, Integer> cache) {\\n\\n    // Looks up cache first.\\n    int key = root * 2 + (halfable ? 1 : 0);\\n    Integer value = cache.get(key);\\n    if (value != null) {\\n      return value;\\n    }\\n\\n    // Calculates the value if cache misses.\\n    int result = minPriceImpl(root, parent, halfable, cache);\\n    cache.put(key, result);\\n    return result;\\n  }\\n\\n  // Gets the min price of sub-tree from root.\\n  private int minPriceImpl(int root, int parent, boolean halfable, Map<Integer, Integer> cache) {\\n    // Keeping root full price is always an option.\\n    int candidate1 = price[root] * passingCount[root];\\n    for (int neighbor : neighbors.get(root)) {\\n      if (neighbor != parent) {\\n        candidate1 += minPrice(neighbor, root, true, cache);\\n      }\\n    }\\n\\n    if (halfable) {\\n      // Makes root half price.\\n      int candidate0 = price[root] / 2 * passingCount[root];\\n      for (int neighbor : neighbors.get(root)) {\\n        if (neighbor != parent) {\\n          candidate0 += minPrice(neighbor, root, false, cache);\\n        }\\n      }\\n      return Math.min(candidate0, candidate1);\\n    } else {\\n      return candidate1;\\n    }\\n\\n  }\\n\\n  // DFS to find the path from root to each node.\\n  private void fillPath(int node, List<Integer> prefix) {\\n    // Reached node, makes a record of the path.\\n    prefix.add(node);\\n    paths.set(node, new ArrayList<Integer>(prefix));\\n\\n    for (int neighbor : neighbors.get(node)) {\\n      if (prefix.size() <= 1 || neighbor != prefix.get(prefix.size() - 2)) {\\n        fillPath(neighbor, prefix);\\n      }\\n    }\\n\\n    // prefix is shared, so restore its original state before entering this method.\\n    prefix.remove(prefix.size() - 1);\\n  }\\n}\\n\\nclass Solution {\\n  public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n    return new Solver(n, edges, price, trips).run();\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Auxiliary class for values shared across methods.\\nclass Solver {\\n  private final int n;\\n  private final int[][] edges;\\n  private final int[] price;\\n  private final int[][] trips;\\n\\n  // neighbors[i] is a list of all neighbors of node i\\n  private final List<List<Integer>> neighbors = new ArrayList<>();\\n\\n  // Arbitrarily selected root of the tree. (Actual value is set later.)\\n  private int root = 0;\\n\\n  // paths[i] is a list of nodes: [root, ancestor1, ancestor2, ..., node] .\\n  private final List<List<Integer>> paths = new ArrayList<>();\\n\\n  // Need to pay node i passingCount[i] times.\\n  private int[] passingCount;\\n\\n  public Solver(int n, int[][] edges, int[] price, int[][] trips) {\\n    this.n = n;\\n    this.edges = edges;\\n    this.price = price;\\n    this.trips = trips;\\n\\n    // Initializes Lists and arrays to size n.\\n    for (int i = 0; i < n; i++) {\\n      neighbors.add(new ArrayList<>());\\n    }\\n    for (int i = 0; i < n; i++) {\\n      paths.add(new ArrayList<>());\\n    }\\n    this.passingCount = new int[n];\\n  }\\n\\n  public int run() {\\n    // Translates edges to a map of neighbors for easier look up.\\n    for (int[] edge : edges) {\\n      neighbors.get(edge[0]).add(edge[1]);\\n      neighbors.get(edge[1]).add(edge[0]);\\n    }\\n\\n    // Picks an arbitrary node as root, for easier implementation of recursion.\\n    for (int i = 0; i < n; i++) {\\n      if (neighbors.get(i).size() > neighbors.get(root).size()) {\\n        root = i;\\n      }\\n    }\\n\\n    // Finds the path from root to every node.\\n    fillPath(root, new ArrayList<>());\\n\\n    // Translates each trip to all passing nodes.\\n    for (int[] trip : trips) {\\n      List<Integer> path0 = paths.get(trip[0]);\\n      List<Integer> path1 = paths.get(trip[1]);\\n      int share = 0;    // Every path share the root node.\\n      for (int i = 1; i < path0.size() && i < path1.size(); i++) {\\n        if (path0.get(i) == path1.get(i)) {\\n          share = i;\\n        } else {\\n          break;\\n        }\\n      }\\n\\n      for (int i = share; i < path0.size(); i++) {\\n        passingCount[path0.get(i)]++;\\n      }\\n\\n      // Count the shared node only once.\\n      for (int i = share + 1; i < path1.size(); i++) {\\n        passingCount[path1.get(i)]++;\\n      }\\n    }\\n\\n    // DP to find the min total price.\\n    return minPrice(root, -1, true, new HashMap<>());\\n  }\\n\\n  private int minPrice(int root, int parent, boolean halfable, Map<Integer, Integer> cache) {\\n\\n    // Looks up cache first.\\n    int key = root * 2 + (halfable ? 1 : 0);\\n    Integer value = cache.get(key);\\n    if (value != null) {\\n      return value;\\n    }\\n\\n    // Calculates the value if cache misses.\\n    int result = minPriceImpl(root, parent, halfable, cache);\\n    cache.put(key, result);\\n    return result;\\n  }\\n\\n  // Gets the min price of sub-tree from root.\\n  private int minPriceImpl(int root, int parent, boolean halfable, Map<Integer, Integer> cache) {\\n    // Keeping root full price is always an option.\\n    int candidate1 = price[root] * passingCount[root];\\n    for (int neighbor : neighbors.get(root)) {\\n      if (neighbor != parent) {\\n        candidate1 += minPrice(neighbor, root, true, cache);\\n      }\\n    }\\n\\n    if (halfable) {\\n      // Makes root half price.\\n      int candidate0 = price[root] / 2 * passingCount[root];\\n      for (int neighbor : neighbors.get(root)) {\\n        if (neighbor != parent) {\\n          candidate0 += minPrice(neighbor, root, false, cache);\\n        }\\n      }\\n      return Math.min(candidate0, candidate1);\\n    } else {\\n      return candidate1;\\n    }\\n\\n  }\\n\\n  // DFS to find the path from root to each node.\\n  private void fillPath(int node, List<Integer> prefix) {\\n    // Reached node, makes a record of the path.\\n    prefix.add(node);\\n    paths.set(node, new ArrayList<Integer>(prefix));\\n\\n    for (int neighbor : neighbors.get(node)) {\\n      if (prefix.size() <= 1 || neighbor != prefix.get(prefix.size() - 2)) {\\n        fillPath(neighbor, prefix);\\n      }\\n    }\\n\\n    // prefix is shared, so restore its original state before entering this method.\\n    prefix.remove(prefix.size() - 1);\\n  }\\n}\\n\\nclass Solution {\\n  public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n    return new Solver(n, edges, price, trips).run();\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422261,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n * n_trips + n_edges)\\n * Space Complexity: O(n + n_edges)\\n * where `n_edges` is the length of the vector `edges`\\n *       `n_trips` is the length of the vector `trips`\\n */\\nclass Solution {\\n public:\\n  int minimumTotalPrice(const int n,\\n                        const vector<vector<int>> &edges,\\n                        const vector<int> &price,\\n                        vector<vector<int>>& trips) {\\n    constexpr int invalid_parent = -1;\\n    vector<int> graph[n];\\n    for (const vector<int> &edge : edges) {\\n      graph[edge.front()].emplace_back(edge.back());\\n      graph[edge.back()].emplace_back(edge.front());\\n    }\\n    \\n    int visit_times[n];\\n    memset(visit_times, 0, sizeof(visit_times));\\n    for (const vector<int> &trip : trips) {\\n      find_path(graph, trip.front(), invalid_parent, trip.back(), visit_times);\\n    }\\n    \\n    auto [discount, non_discount] = dfs(graph, 0, invalid_parent, price, visit_times);\\n    return min(discount, non_discount);\\n  }\\n  \\n private:\\n  bool find_path(const vector<int> *graph, const int node, const int parent, const int target, int *visit_times) {\\n    if (node == target) {\\n      ++visit_times[node];\\n      return true;\\n    }\\n    \\n    for (const int child : graph[node]) {\\n      if (child == parent) {\\n        continue;\\n      }\\n      if (find_path(graph, child, node, target, visit_times)) {\\n        ++visit_times[node];\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n  \\n  /**\\n   * @return: a pair\\n   *          `first` is the minimum price of the subtree rooted by `node` if the price of the node is discounted\\n   *          `second` is the minimum price of the subtree rooted by `node` if the price of the node is not discounted\\n   */\\n  pair<int, int> dfs(const vector<int> *graph,\\n                     const int node,\\n                     const int parent,\\n                     const vector<int> &price,\\n                     const int *visit_times) {\\n    int discount = price[node] * visit_times[node] / 2;\\n    int non_discount = price[node] * visit_times[node];\\n    for (const int child : graph[node]) {\\n      if (child == parent) {\\n        continue;\\n      }\\n      \\n      const auto [child_discount, child_non_discount] = dfs(graph, child, node, price, visit_times);\\n      discount += child_non_discount;\\n      non_discount += min(child_discount, child_non_discount);\\n    }\\n    return make_pair(discount, non_discount);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n * n_trips + n_edges)\\n * Space Complexity: O(n + n_edges)\\n * where `n_edges` is the length of the vector `edges`\\n *       `n_trips` is the length of the vector `trips`\\n */\\nclass Solution {\\n public:\\n  int minimumTotalPrice(const int n,\\n                        const vector<vector<int>> &edges,\\n                        const vector<int> &price,\\n                        vector<vector<int>>& trips) {\\n    constexpr int invalid_parent = -1;\\n    vector<int> graph[n];\\n    for (const vector<int> &edge : edges) {\\n      graph[edge.front()].emplace_back(edge.back());\\n      graph[edge.back()].emplace_back(edge.front());\\n    }\\n    \\n    int visit_times[n];\\n    memset(visit_times, 0, sizeof(visit_times));\\n    for (const vector<int> &trip : trips) {\\n      find_path(graph, trip.front(), invalid_parent, trip.back(), visit_times);\\n    }\\n    \\n    auto [discount, non_discount] = dfs(graph, 0, invalid_parent, price, visit_times);\\n    return min(discount, non_discount);\\n  }\\n  \\n private:\\n  bool find_path(const vector<int> *graph, const int node, const int parent, const int target, int *visit_times) {\\n    if (node == target) {\\n      ++visit_times[node];\\n      return true;\\n    }\\n    \\n    for (const int child : graph[node]) {\\n      if (child == parent) {\\n        continue;\\n      }\\n      if (find_path(graph, child, node, target, visit_times)) {\\n        ++visit_times[node];\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n  \\n  /**\\n   * @return: a pair\\n   *          `first` is the minimum price of the subtree rooted by `node` if the price of the node is discounted\\n   *          `second` is the minimum price of the subtree rooted by `node` if the price of the node is not discounted\\n   */\\n  pair<int, int> dfs(const vector<int> *graph,\\n                     const int node,\\n                     const int parent,\\n                     const vector<int> &price,\\n                     const int *visit_times) {\\n    int discount = price[node] * visit_times[node] / 2;\\n    int non_discount = price[node] * visit_times[node];\\n    for (const int child : graph[node]) {\\n      if (child == parent) {\\n        continue;\\n      }\\n      \\n      const auto [child_discount, child_non_discount] = dfs(graph, child, node, price, visit_times);\\n      discount += child_non_discount;\\n      non_discount += min(child_discount, child_non_discount);\\n    }\\n    return make_pair(discount, non_discount);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422224,
                "title": "java-dp-memoization",
                "content": "\\n# Complexity\\n- Time complexity:\\n $$O(n)$$\\n\\n- Space complexity:\\n$$O(2n)$$\\n\\n# Code\\n```\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\n\\nclass Solution {\\n    boolean[] vis;\\n    int[] count;\\n    List<List<Integer>> adj;\\n    int[][] dp;\\n\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n        dp = new int[2][n + 1];\\n        for (int[] ints : dp) {\\n            Arrays.fill(ints, -1);\\n        }\\n        count = new int[n];\\n        for (int[] edge : edges) {\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n        vis = new boolean[n];\\n\\n        for (int[] trip : trips) {\\n            vis = new boolean[n];\\n            dfs(trip[0], trip[1], price);\\n        }\\n        return go(0, price, 0, -1);\\n    }\\n\\n    private int go(int i, int[] price, int prev, int par) {\\n        if(dp[prev][i]!=-1) return dp[prev][i];\\n        int ans = 0, ans2 = 0;\\n        \\n        for (Integer it : adj.get(i)) {\\n            if (it != par) {\\n                ans += go(it, price, 0, i);\\n\\n            }\\n        }\\n        ans += (price[i] * count[i]);\\n        for (Integer it : adj.get(i)) {\\n            if (it != par) {\\n                if (prev == 0)\\n                    ans2 += go(it, price, 1, i);\\n            }\\n        }\\n        if (prev == 0) {\\n            ans2 += ((price[i] / 2) * count[i]);\\n            ans = Math.min(ans, ans2);\\n        }\\n        return dp[prev][i] = ans;\\n\\n    }\\n\\n\\n    private boolean dfs(int i, int d, int[] price) {\\n        vis[i] = true;\\n        boolean ans = false;\\n        if (i == d) {\\n            count[i]++;\\n            return true;\\n        }\\n        for (Integer it : adj.get(i)) {\\n            if (!vis[it]) {\\n                ans |= dfs(it, d, price);\\n            }\\n        }\\n        if (ans) {\\n            count[i]++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\n\\nclass Solution {\\n    boolean[] vis;\\n    int[] count;\\n    List<List<Integer>> adj;\\n    int[][] dp;\\n\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n        dp = new int[2][n + 1];\\n        for (int[] ints : dp) {\\n            Arrays.fill(ints, -1);\\n        }\\n        count = new int[n];\\n        for (int[] edge : edges) {\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n        vis = new boolean[n];\\n\\n        for (int[] trip : trips) {\\n            vis = new boolean[n];\\n            dfs(trip[0], trip[1], price);\\n        }\\n        return go(0, price, 0, -1);\\n    }\\n\\n    private int go(int i, int[] price, int prev, int par) {\\n        if(dp[prev][i]!=-1) return dp[prev][i];\\n        int ans = 0, ans2 = 0;\\n        \\n        for (Integer it : adj.get(i)) {\\n            if (it != par) {\\n                ans += go(it, price, 0, i);\\n\\n            }\\n        }\\n        ans += (price[i] * count[i]);\\n        for (Integer it : adj.get(i)) {\\n            if (it != par) {\\n                if (prev == 0)\\n                    ans2 += go(it, price, 1, i);\\n            }\\n        }\\n        if (prev == 0) {\\n            ans2 += ((price[i] / 2) * count[i]);\\n            ans = Math.min(ans, ans2);\\n        }\\n        return dp[prev][i] = ans;\\n\\n    }\\n\\n\\n    private boolean dfs(int i, int d, int[] price) {\\n        vis[i] = true;\\n        boolean ans = false;\\n        if (i == d) {\\n            count[i]++;\\n            return true;\\n        }\\n        for (Integer it : adj.get(i)) {\\n            if (!vis[it]) {\\n                ans |= dfs(it, d, price);\\n            }\\n        }\\n        if (ans) {\\n            count[i]++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422218,
                "title": "c-dfs-dp-simple-solution-video-solution",
                "content": "You can also checkout my YouTube channel for solution\\nVisithttps://youtu.be/2gdcNjxR7q0\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll dp[51][2];\\n    \\n    ll minCost(ll i, ll x,vector<vector<int>> &adj,int par, vector<ll> &cost){\\n        ll a=0,b = 0;\\n        if(dp[i][x] !=-1) return dp[i][x];\\n        \\n        \\n        for(auto c:adj[i]){\\n            if(c!=par){\\n                a+=minCost(c,0,adj,i,cost);\\n            }\\n        }\\n\\n        ll ans = a + cost[i] ;\\n        if(x == 0 ){\\n          for(auto c:adj[i]){\\n            if(c!=par){\\n                b+=minCost(c,1,adj,i,cost);\\n            }\\n           }\\n            ans=min(ans,b + cost[i]/2);\\n        }\\n        return  dp[i][x]=ans;   \\n    }\\nbool dfs(int u, int v, const vector<vector<int>>& tree, vector<int>& path, vector<bool>& visited) {\\n    visited[u] = true; \\n\\n    if (u == v) {\\n        path.push_back(u); \\n        return true;\\n    }\\n\\n    for (int child : tree[u]) {\\n        if (!visited[child]) {\\n            path.push_back(u);  \\n            if (dfs(child, v, tree, path, visited)) {\\n                return true;  \\n            }\\n            path.pop_back(); \\n        }\\n    }\\n\\n    return false;  \\n}\\n    \\n    int fun(int n, int root, vector<vector<int>> &adj, vector<int>& price, vector<vector<int>>& trips){\\n       vector<ll> cost(n,0);\\n            for(auto t:trips){\\n            vector<int> path;  \\n            vector<bool> visited(n, false); \\n            dfs(t[0],t[1], adj, path, visited);\\n            for(auto c:path){\\n                cost[c]+=price[c];\\n            }\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        int ans = minCost(0,0,adj,-1,cost);\\n        \\n        return ans;\\n        \\n    }    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> graph(n);  \\n        for (const auto& edge : edges) {\\n            graph[edge[0]].push_back(edge[1]); \\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        int ans=INT_MAX;\\n        ans = fun(n,0,graph,price,trips);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll dp[51][2];\\n    \\n    ll minCost(ll i, ll x,vector<vector<int>> &adj,int par, vector<ll> &cost){\\n        ll a=0,b = 0;\\n        if(dp[i][x] !=-1) return dp[i][x];\\n        \\n        \\n        for(auto c:adj[i]){\\n            if(c!=par){\\n                a+=minCost(c,0,adj,i,cost);\\n            }\\n        }\\n\\n        ll ans = a + cost[i] ;\\n        if(x == 0 ){\\n          for(auto c:adj[i]){\\n            if(c!=par){\\n                b+=minCost(c,1,adj,i,cost);\\n            }\\n           }\\n            ans=min(ans,b + cost[i]/2);\\n        }\\n        return  dp[i][x]=ans;   \\n    }\\nbool dfs(int u, int v, const vector<vector<int>>& tree, vector<int>& path, vector<bool>& visited) {\\n    visited[u] = true; \\n\\n    if (u == v) {\\n        path.push_back(u); \\n        return true;\\n    }\\n\\n    for (int child : tree[u]) {\\n        if (!visited[child]) {\\n            path.push_back(u);  \\n            if (dfs(child, v, tree, path, visited)) {\\n                return true;  \\n            }\\n            path.pop_back(); \\n        }\\n    }\\n\\n    return false;  \\n}\\n    \\n    int fun(int n, int root, vector<vector<int>> &adj, vector<int>& price, vector<vector<int>>& trips){\\n       vector<ll> cost(n,0);\\n            for(auto t:trips){\\n            vector<int> path;  \\n            vector<bool> visited(n, false); \\n            dfs(t[0],t[1], adj, path, visited);\\n            for(auto c:path){\\n                cost[c]+=price[c];\\n            }\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        int ans = minCost(0,0,adj,-1,cost);\\n        \\n        return ans;\\n        \\n    }    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> graph(n);  \\n        for (const auto& edge : edges) {\\n            graph[edge[0]].push_back(edge[1]); \\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        int ans=INT_MAX;\\n        ans = fun(n,0,graph,price,trips);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422190,
                "title": "c-dfs-top-down-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea behind is very similar to **rubber house**. The problem could be converted to a dp problem with state dp[node][0/1] that 0/1 means whether to  half the cost of a node.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Iterate through trips to calcalte frequency of each node by DFS\\n2. Cost of each node eqauls to freq[node] * price[node]\\n3. Select any node as root and use Top-Down DP to find minumum cost.\\n# Complexity\\n- Time complexity: O(nm) (Trips iteration)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int dp[55][2];\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> graph(n);\\n        for (int i = 0; i < n-1; i++) {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n\\n        vector<int> counter(n);\\n        vector<int> path;\\n        int m = trips.size();\\n        for (int i = 0; i < m; i++) {\\n            int start = trips[i][0];\\n            int end = trips[i][1];\\n            path.clear();\\n            path.push_back(start);\\n            DFS1(start, end, -1, graph, path);\\n            for (int node: path) counter[node]++;\\n        }\\n\\n        vector<int> costs(n);\\n        for (int i = 0; i < n; i++) {\\n            costs[i] = counter[i] * price[i];\\n        }\\n        for (int i = 0; i < 55; i++) {\\n            dp[i][0] = -1;\\n            dp[i][1] = -1;\\n        }\\n        return min(DFS2(0, -1, 1, graph, costs), DFS2(0, -1, 0, graph, costs));\\n    }\\n\\n    bool DFS1(int node, int end, int parent, vector<vector<int>>& graph, vector<int>& path) {\\n        if (node == end) return true;\\n        for (auto nxt: graph[node]) {\\n            if (nxt == parent) continue;\\n            path.push_back(nxt);\\n            if (DFS1(nxt, end, node, graph, path)) return true;\\n            path.pop_back();\\n        }\\n        return false;\\n    }\\n\\n    int DFS2(int node, int parent, int half, vector<vector<int>>& graph, vector<int>& costs) {\\n        if (dp[node][half] != -1) return dp[node][half];\\n        \\n        int cost = costs[node];\\n        if (half) cost /= 2;\\n\\n        int SubCost = 0;\\n        for (auto nxt: graph[node]) {\\n            if (nxt == parent) continue;\\n            int curr = DFS2(nxt, node, 0, graph, costs);\\n            if (!half) curr = min(curr, DFS2(nxt, node, 1, graph, costs));\\n            SubCost += curr;\\n        }\\n        \\n        dp[node][half] = cost + SubCost;\\n        return dp[node][half];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dp[55][2];\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> graph(n);\\n        for (int i = 0; i < n-1; i++) {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n\\n        vector<int> counter(n);\\n        vector<int> path;\\n        int m = trips.size();\\n        for (int i = 0; i < m; i++) {\\n            int start = trips[i][0];\\n            int end = trips[i][1];\\n            path.clear();\\n            path.push_back(start);\\n            DFS1(start, end, -1, graph, path);\\n            for (int node: path) counter[node]++;\\n        }\\n\\n        vector<int> costs(n);\\n        for (int i = 0; i < n; i++) {\\n            costs[i] = counter[i] * price[i];\\n        }\\n        for (int i = 0; i < 55; i++) {\\n            dp[i][0] = -1;\\n            dp[i][1] = -1;\\n        }\\n        return min(DFS2(0, -1, 1, graph, costs), DFS2(0, -1, 0, graph, costs));\\n    }\\n\\n    bool DFS1(int node, int end, int parent, vector<vector<int>>& graph, vector<int>& path) {\\n        if (node == end) return true;\\n        for (auto nxt: graph[node]) {\\n            if (nxt == parent) continue;\\n            path.push_back(nxt);\\n            if (DFS1(nxt, end, node, graph, path)) return true;\\n            path.pop_back();\\n        }\\n        return false;\\n    }\\n\\n    int DFS2(int node, int parent, int half, vector<vector<int>>& graph, vector<int>& costs) {\\n        if (dp[node][half] != -1) return dp[node][half];\\n        \\n        int cost = costs[node];\\n        if (half) cost /= 2;\\n\\n        int SubCost = 0;\\n        for (auto nxt: graph[node]) {\\n            if (nxt == parent) continue;\\n            int curr = DFS2(nxt, node, 0, graph, costs);\\n            if (!half) curr = min(curr, DFS2(nxt, node, 1, graph, costs));\\n            SubCost += curr;\\n        }\\n        \\n        dp[node][half] = cost + SubCost;\\n        return dp[node][half];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422167,
                "title": "javascript-dfs-with-memorisation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {number[]} price\\n * @param {number[][]} trips\\n * @return {number}\\n */\\nvar minimumTotalPrice = function (n, edges, price, trips) {\\n    const m = new Map()\\n    const addToMap = (a, b) => {\\n        if (m.has(a)) {\\n            m.get(a).push(b)\\n        } else {\\n            m.set(a, [b])\\n        }\\n    }\\n\\n    for (const [a, b] of edges) {\\n        addToMap(a, b)\\n        addToMap(b, a)\\n    }\\n\\n    const nodeVisits = Array(n).fill(0)\\n    const dfs = (node, prev, finish, seen) => {\\n        if (node == finish) {\\n            for (const s of seen) {\\n                nodeVisits[s] += 1\\n            }\\n        }\\n\\n        const neighbours = m.get(node)\\n        if (neighbours && neighbours.length > 0) {\\n            for (const ngh of neighbours) {\\n                if (ngh !== prev) {\\n                    seen.push(ngh)\\n                    dfs(ngh, node, finish, seen)\\n                    seen.pop()\\n                }\\n            }\\n        }\\n    }\\n\\n    for (const [start, end] of trips) {\\n        dfs(start, -1, end, [start])\\n    }\\n\\n    const cache = new Map()\\n    const dfs2 = (node, prev, isHalfed) => {\\n        const str = `${node}-${isHalfed}`\\n        if (cache.has(str)) {\\n            return cache.get(str)\\n        }\\n        const cur = isHalfed ? (price[node] * nodeVisits[node] / 2) : price[node] * nodeVisits[node]\\n\\n        const neighbours = m.get(node)\\n        let rest = 0\\n        if (neighbours && neighbours.length > 0) {\\n            for (const ngh of neighbours) {\\n                if (ngh !== prev) {\\n                    if (isHalfed) {\\n                        rest += dfs2(ngh, node, false)\\n                    } else {\\n                        rest += Math.min(dfs2(ngh, node, true), dfs2(ngh, node, false))\\n                    }\\n                }\\n            }\\n        }\\n        cache.set(str, cur + rest)\\n        return cur + rest\\n    }\\n\\n\\n    const minTotal = Math.min(dfs2(0, -1, true), dfs2(0, -1, false))\\n\\n    return minTotal\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {number[]} price\\n * @param {number[][]} trips\\n * @return {number}\\n */\\nvar minimumTotalPrice = function (n, edges, price, trips) {\\n    const m = new Map()\\n    const addToMap = (a, b) => {\\n        if (m.has(a)) {\\n            m.get(a).push(b)\\n        } else {\\n            m.set(a, [b])\\n        }\\n    }\\n\\n    for (const [a, b] of edges) {\\n        addToMap(a, b)\\n        addToMap(b, a)\\n    }\\n\\n    const nodeVisits = Array(n).fill(0)\\n    const dfs = (node, prev, finish, seen) => {\\n        if (node == finish) {\\n            for (const s of seen) {\\n                nodeVisits[s] += 1\\n            }\\n        }\\n\\n        const neighbours = m.get(node)\\n        if (neighbours && neighbours.length > 0) {\\n            for (const ngh of neighbours) {\\n                if (ngh !== prev) {\\n                    seen.push(ngh)\\n                    dfs(ngh, node, finish, seen)\\n                    seen.pop()\\n                }\\n            }\\n        }\\n    }\\n\\n    for (const [start, end] of trips) {\\n        dfs(start, -1, end, [start])\\n    }\\n\\n    const cache = new Map()\\n    const dfs2 = (node, prev, isHalfed) => {\\n        const str = `${node}-${isHalfed}`\\n        if (cache.has(str)) {\\n            return cache.get(str)\\n        }\\n        const cur = isHalfed ? (price[node] * nodeVisits[node] / 2) : price[node] * nodeVisits[node]\\n\\n        const neighbours = m.get(node)\\n        let rest = 0\\n        if (neighbours && neighbours.length > 0) {\\n            for (const ngh of neighbours) {\\n                if (ngh !== prev) {\\n                    if (isHalfed) {\\n                        rest += dfs2(ngh, node, false)\\n                    } else {\\n                        rest += Math.min(dfs2(ngh, node, true), dfs2(ngh, node, false))\\n                    }\\n                }\\n            }\\n        }\\n        cache.set(str, cur + rest)\\n        return cur + rest\\n    }\\n\\n\\n    const minTotal = Math.min(dfs2(0, -1, true), dfs2(0, -1, false))\\n\\n    return minTotal\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422142,
                "title": "c-dfs-dp-house-robber-variation-easy-to-understand-99-99-faster",
                "content": "# Intuition\\nFirst find the occurance of every value in the trips then try to find out the maximum sum of non-adjacent values (they may be any number).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> s;\\n    bool solve(vector<vector<int>> &g,vector<int> &price,int i,int tar,int par) {\\n        if(i==tar) {\\n            s[i]+=price[i];\\n            return true;\\n        }\\n        for(auto j:g[i]) {\\n            if(j!=par) {\\n                bool ans = solve(g,price,j,tar,i);\\n                if(ans) {\\n                    s[i]+=price[i];\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    vector<vector<int>> dp;\\n    int solve1(vector<vector<int>> &g,int i,int pick,int par) {\\n        int ans=0,store=0;\\n        if(dp[i][pick]!=-1) return dp[i][pick];\\n        for(auto j:g[i]) {\\n            if(j!=par) {\\n                ans += max(solve1(g,j,0,i),solve1(g,j,1,i));\\n            }\\n        }\\n        if(pick==0) return dp[i][pick] = ans;\\n        int res=s[i];\\n        for(auto j:g[i]) {\\n            if(j!=par) {\\n                res += solve1(g,j,0,i);\\n            }\\n        }\\n        return dp[i][pick] = max(res,max(ans,store));\\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> g(n);\\n        for(auto i:edges) {\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        s.resize(n,0);\\n        dp.resize(n,vector<int> (2,-1));\\n        for(int i=0 ; i<trips.size() ; ++i) {\\n            solve(g,price,trips[i][0],trips[i][1],-1);\\n        }\\n        int val = max(solve1(g,0,0,-1),solve1(g,0,1,-1));\\n        int sum=0;\\n        for(auto i:s) sum+=i;\\n        return sum-(val/2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> s;\\n    bool solve(vector<vector<int>> &g,vector<int> &price,int i,int tar,int par) {\\n        if(i==tar) {\\n            s[i]+=price[i];\\n            return true;\\n        }\\n        for(auto j:g[i]) {\\n            if(j!=par) {\\n                bool ans = solve(g,price,j,tar,i);\\n                if(ans) {\\n                    s[i]+=price[i];\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    vector<vector<int>> dp;\\n    int solve1(vector<vector<int>> &g,int i,int pick,int par) {\\n        int ans=0,store=0;\\n        if(dp[i][pick]!=-1) return dp[i][pick];\\n        for(auto j:g[i]) {\\n            if(j!=par) {\\n                ans += max(solve1(g,j,0,i),solve1(g,j,1,i));\\n            }\\n        }\\n        if(pick==0) return dp[i][pick] = ans;\\n        int res=s[i];\\n        for(auto j:g[i]) {\\n            if(j!=par) {\\n                res += solve1(g,j,0,i);\\n            }\\n        }\\n        return dp[i][pick] = max(res,max(ans,store));\\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> g(n);\\n        for(auto i:edges) {\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        s.resize(n,0);\\n        dp.resize(n,vector<int> (2,-1));\\n        for(int i=0 ; i<trips.size() ; ++i) {\\n            solve(g,price,trips[i][0],trips[i][1],-1);\\n        }\\n        int val = max(solve1(g,0,0,-1),solve1(g,0,1,-1));\\n        int sum=0;\\n        for(auto i:s) sum+=i;\\n        return sum-(val/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422115,
                "title": "c-simple-dfs-beats-90-91-tc-sc-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\npair<int,int> dfs1(int root,int par,vector<vector<int>>& adj,vector<int>& node_cont){\\n    pair<int,int> ans={0,node_cont[root]};\\n    for(int& i: adj[root]){\\n        if(i!=par){\\n            auto [a,b]=dfs1(i,root,adj,node_cont);\\n            ans.first+=max(a,b);\\n            ans.second+=a;\\n        }\\n    }\\n    return ans;\\n}\\n    int dfs(int st,int end,int par,vector<int>& price,vector<vector<int>>& adj,vector<int>& node_cont){\\n        int ans=0;\\n        ans+=price[st];\\n        node_cont[st]+=price[st];\\n        if(st==end) return ans;\\n        for(int& i: adj[st]){\\n            if(i!=par){\\n                int res=dfs(i,end,st,price,adj,node_cont);\\n                if(res)  return ans+res;\\n            }\\n        }\\n        node_cont[st]-=price[st];\\n        return 0;\\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        int ans=0;\\n        vector<vector<int>> adj(n);\\n        int root=-1;\\n        for(auto& ele: edges){\\n            adj[ele[0]].push_back(ele[1]);\\n            adj[ele[1]].push_back(ele[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(adj[i].size()<=1){\\n                root=i;\\n                break;\\n            }\\n        }\\n        vector<int> node_cont(n,0);\\n        for(int i=0;i<trips.size();i++){\\n            int st=trips[i][0];\\n            int end=trips[i][1];\\n            ans+=dfs(st,end,-1,price,adj,node_cont);\\n        }\\n        auto [a,b]=dfs1(root,-1,adj,node_cont);\\n        ans-=max(a,b)/2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\npair<int,int> dfs1(int root,int par,vector<vector<int>>& adj,vector<int>& node_cont){\\n    pair<int,int> ans={0,node_cont[root]};\\n    for(int& i: adj[root]){\\n        if(i!=par){\\n            auto [a,b]=dfs1(i,root,adj,node_cont);\\n            ans.first+=max(a,b);\\n            ans.second+=a;\\n        }\\n    }\\n    return ans;\\n}\\n    int dfs(int st,int end,int par,vector<int>& price,vector<vector<int>>& adj,vector<int>& node_cont){\\n        int ans=0;\\n        ans+=price[st];\\n        node_cont[st]+=price[st];\\n        if(st==end) return ans;\\n        for(int& i: adj[st]){\\n            if(i!=par){\\n                int res=dfs(i,end,st,price,adj,node_cont);\\n                if(res)  return ans+res;\\n            }\\n        }\\n        node_cont[st]-=price[st];\\n        return 0;\\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        int ans=0;\\n        vector<vector<int>> adj(n);\\n        int root=-1;\\n        for(auto& ele: edges){\\n            adj[ele[0]].push_back(ele[1]);\\n            adj[ele[1]].push_back(ele[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(adj[i].size()<=1){\\n                root=i;\\n                break;\\n            }\\n        }\\n        vector<int> node_cont(n,0);\\n        for(int i=0;i<trips.size();i++){\\n            int st=trips[i][0];\\n            int end=trips[i][1];\\n            ans+=dfs(st,end,-1,price,adj,node_cont);\\n        }\\n        auto [a,b]=dfs1(root,-1,adj,node_cont);\\n        ans-=max(a,b)/2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422105,
                "title": "python-3-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are two steps to this problem:\\n\\n- For each trip, work out the list of nodes in each trip. The question tries to throw us off by saying \"pick any path\", but in a tree graph there is only one path between any two nodes.\\n- Determine the optimal set of nodes to halve\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: list[list[int]], price: list[int], trips: list[list[int]]) -> int:\\n        d = defaultdict(set)\\n        trip_cache = dict()\\n        for l,r in edges:\\n            d[l].add(r)\\n            d[r].add(l)\\n            trip_cache[(l, r)] = [l, r]\\n            trip_cache[(r, l)] = [l, r]\\n        \\n        def get_nodes_in_trip(a, b):\\n            if (a == b):\\n                return [a]\\n            if (a,b) in trip_cache:\\n                return trip_cache[(a, b)]\\n            to_visit = [(a, [a])]\\n            visited = set()\\n            while(to_visit):\\n                node, nodes_in_path = to_visit.pop()\\n                visited.add(node)\\n                for adjacent in d[node]:\\n                    if adjacent in visited:\\n                        continue\\n                    new_nodes_in_path = nodes_in_path + [adjacent]\\n                    trip_cache[(a, adjacent)] = new_nodes_in_path\\n                    trip_cache[(adjacent, a)] = new_nodes_in_path\\n                    if (adjacent == b):\\n                        return new_nodes_in_path\\n                    to_visit.append((adjacent, new_nodes_in_path))\\n            return None\\n        node_costs = defaultdict(lambda: 0)\\n        for a,b in trips:\\n            nodes = get_nodes_in_trip(a, b)\\n            for n in nodes:\\n                node_costs[n] += price[n]\\n\\n   \\n        def get_best_discount(available_nodes, min_acceptable):\\n\\n            if not(available_nodes):\\n                return 0\\n            amount_we_can_possibly_take_off = sum([node_costs[n] for n in available_nodes]) // 2\\n            if amount_we_can_possibly_take_off < min_acceptable:\\n                return 0\\n            amount_if_we_discount_first = node_costs[available_nodes[0]]//2\\n            remaining = [n for n in available_nodes[1:] if (n not in d[available_nodes[0]])]\\n            amount_if_we_discount_first += get_best_discount(remaining, min_acceptable - amount_if_we_discount_first)\\n            amount_if_we_keep_first = get_best_discount(available_nodes[1:], max(min_acceptable, amount_if_we_discount_first))\\n            return max(amount_if_we_discount_first, amount_if_we_keep_first)\\n\\n        all_nodes = [n for n in range(len(price)) if node_costs[n]]\\n        all_nodes.sort(key=lambda n: 0-node_costs[n])\\n        best_discount = get_best_discount(all_nodes, 0)\\n        total_price_before_halving = sum(node_costs.values())\\n        return total_price_before_halving - best_discount\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: list[list[int]], price: list[int], trips: list[list[int]]) -> int:\\n        d = defaultdict(set)\\n        trip_cache = dict()\\n        for l,r in edges:\\n            d[l].add(r)\\n            d[r].add(l)\\n            trip_cache[(l, r)] = [l, r]\\n            trip_cache[(r, l)] = [l, r]\\n        \\n        def get_nodes_in_trip(a, b):\\n            if (a == b):\\n                return [a]\\n            if (a,b) in trip_cache:\\n                return trip_cache[(a, b)]\\n            to_visit = [(a, [a])]\\n            visited = set()\\n            while(to_visit):\\n                node, nodes_in_path = to_visit.pop()\\n                visited.add(node)\\n                for adjacent in d[node]:\\n                    if adjacent in visited:\\n                        continue\\n                    new_nodes_in_path = nodes_in_path + [adjacent]\\n                    trip_cache[(a, adjacent)] = new_nodes_in_path\\n                    trip_cache[(adjacent, a)] = new_nodes_in_path\\n                    if (adjacent == b):\\n                        return new_nodes_in_path\\n                    to_visit.append((adjacent, new_nodes_in_path))\\n            return None\\n        node_costs = defaultdict(lambda: 0)\\n        for a,b in trips:\\n            nodes = get_nodes_in_trip(a, b)\\n            for n in nodes:\\n                node_costs[n] += price[n]\\n\\n   \\n        def get_best_discount(available_nodes, min_acceptable):\\n\\n            if not(available_nodes):\\n                return 0\\n            amount_we_can_possibly_take_off = sum([node_costs[n] for n in available_nodes]) // 2\\n            if amount_we_can_possibly_take_off < min_acceptable:\\n                return 0\\n            amount_if_we_discount_first = node_costs[available_nodes[0]]//2\\n            remaining = [n for n in available_nodes[1:] if (n not in d[available_nodes[0]])]\\n            amount_if_we_discount_first += get_best_discount(remaining, min_acceptable - amount_if_we_discount_first)\\n            amount_if_we_keep_first = get_best_discount(available_nodes[1:], max(min_acceptable, amount_if_we_discount_first))\\n            return max(amount_if_we_discount_first, amount_if_we_keep_first)\\n\\n        all_nodes = [n for n in range(len(price)) if node_costs[n]]\\n        all_nodes.sort(key=lambda n: 0-node_costs[n])\\n        best_discount = get_best_discount(all_nodes, 0)\\n        total_price_before_halving = sum(node_costs.values())\\n        return total_price_before_halving - best_discount\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422058,
                "title": "python-3-dfs-dp-house-robber-tree-camera",
                "content": "First step is update costs of the nodes based on the frequency they are visited. Since tree size is small and no more than 100 trips, DFS and update total cost of the nodes on the path start to end.\\n\\nNext step is the same as [968. Binary Tree Cameras](https://leetcode.com/problems/binary-tree-cameras/) or [337. House Robber III](https://leetcode.com/problems/house-robber-iii/), at any node, we can either pay the full price and give the price cut option to its children, or cut its price (if we paid full price at its parent) and pay full price at its children.\\n\\nNote that the visited nodes may not be connected, need to loop through unvisited nodes and sum the min cost. E.g.\\nn = 4\\nedges = [[0,1],[1,2],[1,3]]\\nprice = [2,2,10,6]\\ntrips = [[0,0],[3,3]]\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        def dfs(cur, par, e):\\n            if cur == e:\\n                ct[cur] += price[cur]\\n                return True\\n            for nxt in graph[cur] - {par}:\\n                if dfs(nxt, cur, e):\\n                    ct[cur] += price[cur]\\n                    return True\\n            return False\\n\\n        graph = defaultdict(set)\\n        for a, b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n        \\n        ct = Counter()\\n        for s, e in trips:\\n            dfs(s, -1, e)\\n\\n        @cache\\n        def dp(cur, par, can_cut):\\n            vis.add(cur)\\n            res = ct[cur]\\n            for nxt in graph[cur] - {par}:\\n                if nxt in ct:\\n                    res += dp(nxt, cur, True)\\n            res1 = inf\\n            if can_cut:\\n                res1 = ct[cur] // 2\\n                for nxt in graph[cur] - {par}:\\n                    if nxt in ct:\\n                        res1 += dp(nxt, cur, False)\\n            return min(res, res1)\\n        \\n        ans = 0\\n        vis = set()\\n        for x in ct:\\n            if x not in vis:\\n                ans += dp(x, -1, True)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        def dfs(cur, par, e):\\n            if cur == e:\\n                ct[cur] += price[cur]\\n                return True\\n            for nxt in graph[cur] - {par}:\\n                if dfs(nxt, cur, e):\\n                    ct[cur] += price[cur]\\n                    return True\\n            return False\\n\\n        graph = defaultdict(set)\\n        for a, b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n        \\n        ct = Counter()\\n        for s, e in trips:\\n            dfs(s, -1, e)\\n\\n        @cache\\n        def dp(cur, par, can_cut):\\n            vis.add(cur)\\n            res = ct[cur]\\n            for nxt in graph[cur] - {par}:\\n                if nxt in ct:\\n                    res += dp(nxt, cur, True)\\n            res1 = inf\\n            if can_cut:\\n                res1 = ct[cur] // 2\\n                for nxt in graph[cur] - {par}:\\n                    if nxt in ct:\\n                        res1 += dp(nxt, cur, False)\\n            return min(res, res1)\\n        \\n        ans = 0\\n        vis = set()\\n        for x in ct:\\n            if x not in vis:\\n                ans += dp(x, -1, True)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422057,
                "title": "house-robber-iii-o-n-2-bfs-dfs",
                "content": "# Intuition\\nPreprocess the trips information. We don\\'t want to know which nodes to half but just find the max possible sum of non-adjacent nodes and half it.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse the trips information to find out which node is used how many times. Use this information - to choose which non-adjacent nodes to half. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: Use BFS (to find the nodes used in a trip) and DFS ( to find the max possible sum of non-adjacent nodes). O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: - O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int src, vector<vector<int>>& adj, vector<int>& temp, vector<bool>& visited, vector<int>& dp1, vector<int>& dp2){\\n        visited[src]=true;\\n        dp1[src]=temp[src];\\n        for(auto nbr:adj[src]){\\n            if(!visited[nbr]){\\n                dfs(nbr, adj,temp,visited,dp1, dp2);\\n                dp2[src]+=max(dp1[nbr], dp2[nbr]);\\n                dp1[src]+=dp2[nbr];\\n            }\\n        }\\n        \\n    }\\n    vector<int> helper(vector<int> trip, vector<vector<int>>& adj){\\n        int n=adj.size();\\n        vector<int> parent(n, -1);\\n        queue<int> q;\\n        parent[trip[0]]=trip[0];\\n        q.push(trip[0]);\\n        while(!q.empty()){\\n            int t=q.front();q.pop();\\n            if(t==trip[1]) break;\\n            for(auto nbr:adj[t]){\\n                if(parent[nbr]==-1){\\n                    parent[nbr]=t;\\n                    q.push(nbr);                    \\n                }\\n            }\\n        }\\n        int t=trip[1];\\n        vector<int> res;\\n        while(parent[t]!=t){\\n            res.push_back(t);\\n            t=parent[t];\\n        }\\n        res.push_back(t);\\n        return res;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> adj(n);\\n        for(auto e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        vector<int> cnt(n,0);\\n        for(auto t:trips){\\n            vector<int> temp=helper(t, adj);\\n            for(int i=0;i<temp.size();i++){\\n                cnt[temp[i]]++;\\n            }\\n        }\\n        long long p=0;\\n        for(int i=0;i<n;i++){\\n            p+=(price[i]*1LL*cnt[i]);\\n            cnt[i]=price[i]*cnt[i];\\n        }\\n        long long ans=0;\\n        vector<bool> visited(n,false);\\n        vector<int> dp1(n,0), dp2(n,0);\\n        dfs(0, adj, cnt, visited, dp1, dp2);\\n        ans=max(dp1[0], dp2[0]);\\n        return p-ans+(ans/2);        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int src, vector<vector<int>>& adj, vector<int>& temp, vector<bool>& visited, vector<int>& dp1, vector<int>& dp2){\\n        visited[src]=true;\\n        dp1[src]=temp[src];\\n        for(auto nbr:adj[src]){\\n            if(!visited[nbr]){\\n                dfs(nbr, adj,temp,visited,dp1, dp2);\\n                dp2[src]+=max(dp1[nbr], dp2[nbr]);\\n                dp1[src]+=dp2[nbr];\\n            }\\n        }\\n        \\n    }\\n    vector<int> helper(vector<int> trip, vector<vector<int>>& adj){\\n        int n=adj.size();\\n        vector<int> parent(n, -1);\\n        queue<int> q;\\n        parent[trip[0]]=trip[0];\\n        q.push(trip[0]);\\n        while(!q.empty()){\\n            int t=q.front();q.pop();\\n            if(t==trip[1]) break;\\n            for(auto nbr:adj[t]){\\n                if(parent[nbr]==-1){\\n                    parent[nbr]=t;\\n                    q.push(nbr);                    \\n                }\\n            }\\n        }\\n        int t=trip[1];\\n        vector<int> res;\\n        while(parent[t]!=t){\\n            res.push_back(t);\\n            t=parent[t];\\n        }\\n        res.push_back(t);\\n        return res;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> adj(n);\\n        for(auto e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        vector<int> cnt(n,0);\\n        for(auto t:trips){\\n            vector<int> temp=helper(t, adj);\\n            for(int i=0;i<temp.size();i++){\\n                cnt[temp[i]]++;\\n            }\\n        }\\n        long long p=0;\\n        for(int i=0;i<n;i++){\\n            p+=(price[i]*1LL*cnt[i]);\\n            cnt[i]=price[i]*cnt[i];\\n        }\\n        long long ans=0;\\n        vector<bool> visited(n,false);\\n        vector<int> dp1(n,0), dp2(n,0);\\n        dfs(0, adj, cnt, visited, dp1, dp2);\\n        ans=max(dp1[0], dp2[0]);\\n        return p-ans+(ans/2);        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422000,
                "title": "c-dp-on-tree-to-count-max-savings",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe first get the number of times each node is used in a path, and then try to use dp to find the max savings possible. In order for the dp to work we need to root it at an arbitrary node, and find a toposort for the order that we evaluate the nodes in.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRoot the tree with a dfs and to get the toposort.\\n\\nGet the number of times each node is used on a path with a dfs (recursive backtracking) and this is added to `chosen`.\\n\\nFrom there we can do our dp on trees, where the states are: \\ndp[i][0]: max savings from subtree rooted at i if we don\\'t save node i\\ndp[i][1]: max savings from subtree rooted at i if we save node i\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) initial dfs\\nO(n*trips) getting the counts\\nO(2*n) dp\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*trips) for the various arrays\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> al,child;\\n    vector<int> toposort,parent, vis,path;\\n    void dfs(int u, vector<int> &vis){\\n        vis[u] = 1;\\n        for(auto&v:al[u]){\\n            if(!vis[v]) {\\n                parent[v] = u;\\n                child[u].push_back(v);\\n                dfs(v,vis);\\n            }\\n        }\\n        toposort.push_back(u);\\n    }\\n\\n    void getPath(int u, int target, vector<int>&curr){\\n        vis[u] = 1;\\n        curr.push_back(u);\\n        if(u==target) path = curr;\\n        for(auto&v:al[u]){\\n            if(!vis[v]){\\n                getPath(v,target,curr);\\n            }\\n        }\\n        curr.pop_back();\\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        al.resize(n);\\n        child.resize(n);\\n        parent.assign(n,-1);\\n        \\n        for(auto&x:edges){\\n            al[x[0]].push_back(x[1]);\\n            al[x[1]].push_back(x[0]);\\n        }\\n        vis.assign(n,0);\\n        dfs(0,vis);\\n        \\n        vector<int> chosen(n,0);\\n        for(auto&t:trips){\\n            vis.assign(n,0);\\n            vector<int> curr;\\n            getPath(t[0],t[1],curr);\\n            for(auto&x:path){\\n                chosen[x]++;\\n            }\\n        }\\n        int ans = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            ans += chosen[i] * price[i];\\n        }\\n        \\n        // dp[i][0]: max savings from subtree rooted at i if we don\\'t save i\\n        vector<vector<int>> dp(n, vector<int>(2,0));\\n        for(auto&x:toposort){\\n            for(auto&c:child[x]){\\n                dp[x][0] += max(dp[c][0], dp[c][1]);\\n                dp[x][1] += dp[c][0];\\n            }\\n            dp[x][1] += chosen[x] * price[x]/2;\\n        }\\n        \\n        return ans - max(dp[0][0],dp[0][1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> al,child;\\n    vector<int> toposort,parent, vis,path;\\n    void dfs(int u, vector<int> &vis){\\n        vis[u] = 1;\\n        for(auto&v:al[u]){\\n            if(!vis[v]) {\\n                parent[v] = u;\\n                child[u].push_back(v);\\n                dfs(v,vis);\\n            }\\n        }\\n        toposort.push_back(u);\\n    }\\n\\n    void getPath(int u, int target, vector<int>&curr){\\n        vis[u] = 1;\\n        curr.push_back(u);\\n        if(u==target) path = curr;\\n        for(auto&v:al[u]){\\n            if(!vis[v]){\\n                getPath(v,target,curr);\\n            }\\n        }\\n        curr.pop_back();\\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        al.resize(n);\\n        child.resize(n);\\n        parent.assign(n,-1);\\n        \\n        for(auto&x:edges){\\n            al[x[0]].push_back(x[1]);\\n            al[x[1]].push_back(x[0]);\\n        }\\n        vis.assign(n,0);\\n        dfs(0,vis);\\n        \\n        vector<int> chosen(n,0);\\n        for(auto&t:trips){\\n            vis.assign(n,0);\\n            vector<int> curr;\\n            getPath(t[0],t[1],curr);\\n            for(auto&x:path){\\n                chosen[x]++;\\n            }\\n        }\\n        int ans = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            ans += chosen[i] * price[i];\\n        }\\n        \\n        // dp[i][0]: max savings from subtree rooted at i if we don\\'t save i\\n        vector<vector<int>> dp(n, vector<int>(2,0));\\n        for(auto&x:toposort){\\n            for(auto&c:child[x]){\\n                dp[x][0] += max(dp[c][0], dp[c][1]);\\n                dp[x][1] += dp[c][0];\\n            }\\n            dp[x][1] += chosen[x] * price[x]/2;\\n        }\\n        \\n        return ans - max(dp[0][0],dp[0][1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421999,
                "title": "c-solutions-dfs-dp-easy-to-understan",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int> > t(n, vector<int>{});\\n        for (auto x: edges) {\\n            t[x[0]].push_back(x[1]);\\n            t[x[1]].push_back(x[0]);\\n        }\\n        vector<int> fa(n), dep(n), cnt(n);\\n        function<void(int, int, int)> dfs = [&](int x, int f, int dis) {\\n            fa[x] = f; dep[x] = dis;\\n            for (auto v: t[x]) {\\n                if (v == f)\\n                    continue;\\n                dfs(v, x, dis + 1);\\n            }\\n        };\\n        dfs(0, 0, 0);\\n        for (auto pr: trips) {\\n            int u = pr[0], v = pr[1];\\n            if (dep[u] > dep[v])\\n                swap(u, v);\\n            while (dep[u] < dep[v]) {\\n                ++ cnt[v];\\n                v = fa[v];\\n            }\\n            while (u != v)\\n                ++ cnt[u], ++ cnt[v], u = fa[u], v = fa[v];\\n           ++ cnt[u];\\n        }\\n        long long ans = 0;\\n        for (int i = 0; i < n; i ++)\\n            ans += 1ll * cnt[i] * price[i];\\n        vector<vector<long long> > dp(n, vector<long long>(2));\\n        function<void(int, int)> dfs2 = [&](int x, int f) {\\n            dp[x][0] = 0;\\n            dp[x][1] = 1ll * price[x] / 2 * cnt[x];\\n            for (auto v: t[x]) {\\n                if (v == f)\\n                    continue;\\n                dfs2(v, x);\\n                dp[x][0] += max(dp[v][1], dp[v][0]);\\n                dp[x][1] += dp[v][0];\\n            }\\n        };\\n        dfs2(0, 0);\\n        return ans - max(dp[0][0], dp[0][1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int> > t(n, vector<int>{});\\n        for (auto x: edges) {\\n            t[x[0]].push_back(x[1]);\\n            t[x[1]].push_back(x[0]);\\n        }\\n        vector<int> fa(n), dep(n), cnt(n);\\n        function<void(int, int, int)> dfs = [&](int x, int f, int dis) {\\n            fa[x] = f; dep[x] = dis;\\n            for (auto v: t[x]) {\\n                if (v == f)\\n                    continue;\\n                dfs(v, x, dis + 1);\\n            }\\n        };\\n        dfs(0, 0, 0);\\n        for (auto pr: trips) {\\n            int u = pr[0], v = pr[1];\\n            if (dep[u] > dep[v])\\n                swap(u, v);\\n            while (dep[u] < dep[v]) {\\n                ++ cnt[v];\\n                v = fa[v];\\n            }\\n            while (u != v)\\n                ++ cnt[u], ++ cnt[v], u = fa[u], v = fa[v];\\n           ++ cnt[u];\\n        }\\n        long long ans = 0;\\n        for (int i = 0; i < n; i ++)\\n            ans += 1ll * cnt[i] * price[i];\\n        vector<vector<long long> > dp(n, vector<long long>(2));\\n        function<void(int, int)> dfs2 = [&](int x, int f) {\\n            dp[x][0] = 0;\\n            dp[x][1] = 1ll * price[x] / 2 * cnt[x];\\n            for (auto v: t[x]) {\\n                if (v == f)\\n                    continue;\\n                dfs2(v, x);\\n                dp[x][0] += max(dp[v][1], dp[v][0]);\\n                dp[x][1] += dp[v][0];\\n            }\\n        };\\n        dfs2(0, 0);\\n        return ans - max(dp[0][0], dp[0][1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421976,
                "title": "python-dfs-dp",
                "content": "First of all run a dfs to get the total cost without halving any node (ans).\\nNow for all paths keep a count of how many times we will encounter each node. Multiply that value with half the price of that node. ( loss array)\\nNow the Q boils down to the famous Q of getting max value of a tree without choosing any adjacent nodes (gg) .Use dp for this.\\nNow subtract this value from the initial answer to get our final answer (ans-gg). \\nTime Complexity: O(n * m) , where n is no of nodes and m is size of trips array.\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        graph=defaultdict(list)\\n        ans=0\\n        for u,v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        cnt=[0]*n\\n        def dfs2(node,end,val,path):\\n            nonlocal ans\\n            seen[node]=1\\n            if node==end: \\n                ans+=val+price[node]\\n                path+=[node]\\n                for gg in path: cnt[gg]+=1\\n                return\\n            for nei in graph[node]:\\n                if seen[nei]: continue\\n                dfs2(nei,end,val+price[node],path+[node])\\n            return val\\n        for s,e in trips:\\n            seen=[0]*n\\n            dfs2(s,e,0,[])\\n        loss=[0]*n\\n        for i in range(n):\\n            loss[i]=(cnt[i]*price[i])//2\\n        dp1,dp2=[0]*n,[0]*n\\n        def dfs(node,par):\\n            val1,val2=0,0\\n            for nei in graph[node]:\\n                if(nei == par): continue\\n                dfs(nei, node);\\n                val1 += dp2[nei]\\n                val2 += max(dp1[nei], dp2[nei])\\n            dp1[node] = loss[node] + val1\\n            dp2[node] = val2\\n        dfs(0,-1)\\n        gg=max(dp1[0],dp2[0])\\n        return ans-gg\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        graph=defaultdict(list)\\n        ans=0\\n        for u,v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        cnt=[0]*n\\n        def dfs2(node,end,val,path):\\n            nonlocal ans\\n            seen[node]=1\\n            if node==end: \\n                ans+=val+price[node]\\n                path+=[node]\\n                for gg in path: cnt[gg]+=1\\n                return\\n            for nei in graph[node]:\\n                if seen[nei]: continue\\n                dfs2(nei,end,val+price[node],path+[node])\\n            return val\\n        for s,e in trips:\\n            seen=[0]*n\\n            dfs2(s,e,0,[])\\n        loss=[0]*n\\n        for i in range(n):\\n            loss[i]=(cnt[i]*price[i])//2\\n        dp1,dp2=[0]*n,[0]*n\\n        def dfs(node,par):\\n            val1,val2=0,0\\n            for nei in graph[node]:\\n                if(nei == par): continue\\n                dfs(nei, node);\\n                val1 += dp2[nei]\\n                val2 += max(dp1[nei], dp2[nei])\\n            dp1[node] = loss[node] + val1\\n            dp2[node] = val2\\n        dfs(0,-1)\\n        gg=max(dp1[0],dp2[0])\\n        return ans-gg\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421952,
                "title": "calculate-visited-times-of-each-node-then-dp",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo steps:\\n1. calculate visited times of each node. This can be done in $O(NT)$ where $T=len(trips)$\\n2. dynamic programming: dp[u][0] means minimum cost of u and u\\'s descendants without halving the price of u, dp[u][1] means minimum cost of u and u\\'s descendants if we halve the price of u. This can be done in $O(N)$\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        g=defaultdict(list)\\n        for u,v in edges:\\n            g[u].append(v); g[v].append(u)\\n        ts=[0]*n\\n        def dfs(u,p,tar):\\n            has=False\\n            if u==tar: has=True; ts[u]+=1\\n            else:\\n                for v in g[u]:\\n                    if v==p: continue\\n                    if dfs(v,u,tar): has=True; ts[u]+=1;break\\n            return has\\n        for s,e in trips:\\n            dfs(s,-1,e)\\n        dp=[[price[i]*ts[i],price[i]//2*ts[i]] for i in range(n)]\\n        def dfs2(u,p):\\n            for v in g[u]:\\n                if v==p: continue\\n                dfs2(v,u)\\n                dp[u][0]+=min(dp[v])\\n                dp[u][1]+=dp[v][0]\\n        dfs2(0,-1)\\n        return min(dp[0])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        g=defaultdict(list)\\n        for u,v in edges:\\n            g[u].append(v); g[v].append(u)\\n        ts=[0]*n\\n        def dfs(u,p,tar):\\n            has=False\\n            if u==tar: has=True; ts[u]+=1\\n            else:\\n                for v in g[u]:\\n                    if v==p: continue\\n                    if dfs(v,u,tar): has=True; ts[u]+=1;break\\n            return has\\n        for s,e in trips:\\n            dfs(s,-1,e)\\n        dp=[[price[i]*ts[i],price[i]//2*ts[i]] for i in range(n)]\\n        def dfs2(u,p):\\n            for v in g[u]:\\n                if v==p: continue\\n                dfs2(v,u)\\n                dp[u][0]+=min(dp[v])\\n                dp[u][1]+=dp[v][0]\\n        dfs2(0,-1)\\n        return min(dp[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421949,
                "title": "python-dp",
                "content": "**Idea:**\\n\\t- For all trips find all nodes that are on the trips\\n\\t- Count nodes and count price of all trips (`S` in the code)\\n\\t- For each node find as much as we can save if we start walking from it and save on non-adjustent\\n\\t- return `S - max savings`\\n\\n```python\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        #find path from node to target\\n        def walk(node,parent):\\n            if node == target:\\n                return [target]\\n            else:\\n                for v in graph[node]:\\n                    if v != parent:\\n                        x = walk(v,node)\\n                        if x:\\n                            return [node] + x\\n            return None\\n        \\n        # count number of node accurances \\n        # and total cost for all trips\\n        c = Counter()\\n        S = 0\\n        for u,v in trips:\\n            target = v\\n            for x in walk(u,-1):\\n                c[x] += 1\\n                S += price[x]\\n        \\n        # maximize savings\\n        @cache\\n        def dp(node,parent,taken):\\n            X = 0\\n            if not taken:\\n                X = c[node] * (price[node] // 2)\\n                for v in graph[node]:\\n                    if v != parent:\\n                        X += dp(v,node,True)\\n            a = 0\\n            for v in graph[node]:\\n                if v != parent:\\n                    a += dp(v,node,False)\\n            return max(X,a)\\n        \\n        mx = 0\\n        for node in range(n):\\n            mx = max(mx, dp(node, -1,False))\\n        return S - mx\\n```\\n\\nTime: `O(N)`\\nSpace: `O(Trips * N)`\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        #find path from node to target\\n        def walk(node,parent):\\n            if node == target:\\n                return [target]\\n            else:\\n                for v in graph[node]:\\n                    if v != parent:\\n                        x = walk(v,node)\\n                        if x:\\n                            return [node] + x\\n            return None\\n        \\n        # count number of node accurances \\n        # and total cost for all trips\\n        c = Counter()\\n        S = 0\\n        for u,v in trips:\\n            target = v\\n            for x in walk(u,-1):\\n                c[x] += 1\\n                S += price[x]\\n        \\n        # maximize savings\\n        @cache\\n        def dp(node,parent,taken):\\n            X = 0\\n            if not taken:\\n                X = c[node] * (price[node] // 2)\\n                for v in graph[node]:\\n                    if v != parent:\\n                        X += dp(v,node,True)\\n            a = 0\\n            for v in graph[node]:\\n                if v != parent:\\n                    a += dp(v,node,False)\\n            return max(X,a)\\n        \\n        mx = 0\\n        for node in range(n):\\n            mx = max(mx, dp(node, -1,False))\\n        return S - mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421941,
                "title": "simple-dfs-dp-memoization-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int dp[51][55];\\n    int check(int node,int par,int prev,vector<int>adj[],vector<int>&cnt,vector<int>&price)\\n    {\\n         if(dp[node][prev]!=-1)\\n         {\\n             return dp[node][prev];\\n         }\\n         int ans=0;\\n         for(int child: adj[node])\\n         {\\n             if(child!=par)\\n             {\\n                 if(prev==node)\\n                 {\\n                      ans= ans+ cnt[child]*price[child]+check(child,node,prev,adj,cnt,price);\\n                 }else \\n                 {\\n                      int h1= cnt[child]*(price[child]/2)+ check(child,node,child,adj,cnt,price);\\n                      int h2= cnt[child]*(price[child])+check(child,node,prev,adj,cnt,price);\\n                      ans= ans+ min(h1,h2);\\n                 }\\n             }\\n         }\\n        return dp[node][prev]=ans;\\n    }\\n    void dfs(int node,int par1,vector<int>&par,vector<int>adj[])\\n    {\\n         par[node]=par1;\\n         for(int child: adj[node])\\n         {\\n             if(par1!=child)\\n             {\\n                  dfs(child,node,par,adj);\\n             }\\n         }\\n    }\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n       \\n        vector<int>adj[n+1];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int x= edges[i][0];\\n            int y= edges[i][1];\\n            adj[x].push_back(y);\\n            adj[y].push_back(x);\\n        }\\n        vector<int>par(n+1,-1);\\n        dfs(0,-1,par,adj);\\n        vector<int>cnt(n+1,0);\\n         for(int j=0;j<trips.size();j++)\\n             {\\n                  int st= trips[j][0];\\n                  int en= trips[j][1];\\n                  vector<int>p1,p2;\\n                  vector<int>vis(n+1,0);\\n                //  cout<<st<<\" \"<<en<<\"mmmmm\"<<endl;\\n                  while(st!=-1)\\n                  {\\n                      p1.push_back(st);\\n                      vis[st]++;\\n                      st= par[st];\\n                  }\\n                 int t2=-1;\\n                  while(en!=-1)\\n                  {\\n                      if(vis[en]>0)\\n                      {\\n                          t2=en;\\n                          break;\\n                      }\\n                      p2.push_back(en);\\n                      en= par[en];\\n                  }\\n                  for(int k=0;k<p1.size();k++)\\n                  {\\n                      if(p1[k]==t2)\\n                      {\\n                          cnt[p1[k]]++;\\n                          break;\\n                      }\\n                          cnt[p1[k]]++;\\n                  }\\n                 for(int k=0;k<p2.size();k++)\\n                 {\\n                          cnt[p2[k]]++;\\n                 }\\n             }\\n         memset(dp,-1,sizeof(dp));\\n        return min(cnt[0]*(price[0]/2)+check(0,-1,0,adj,cnt,price),cnt[0]*price[0]+check(0,-1,51,adj,cnt,price));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int dp[51][55];\\n    int check(int node,int par,int prev,vector<int>adj[],vector<int>&cnt,vector<int>&price)\\n    {\\n         if(dp[node][prev]!=-1)\\n         {\\n             return dp[node][prev];\\n         }\\n         int ans=0;\\n         for(int child: adj[node])\\n         {\\n             if(child!=par)\\n             {\\n                 if(prev==node)\\n                 {\\n                      ans= ans+ cnt[child]*price[child]+check(child,node,prev,adj,cnt,price);\\n                 }else \\n                 {\\n                      int h1= cnt[child]*(price[child]/2)+ check(child,node,child,adj,cnt,price);\\n                      int h2= cnt[child]*(price[child])+check(child,node,prev,adj,cnt,price);\\n                      ans= ans+ min(h1,h2);\\n                 }\\n             }\\n         }\\n        return dp[node][prev]=ans;\\n    }\\n    void dfs(int node,int par1,vector<int>&par,vector<int>adj[])\\n    {\\n         par[node]=par1;\\n         for(int child: adj[node])\\n         {\\n             if(par1!=child)\\n             {\\n                  dfs(child,node,par,adj);\\n             }\\n         }\\n    }\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n       \\n        vector<int>adj[n+1];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int x= edges[i][0];\\n            int y= edges[i][1];\\n            adj[x].push_back(y);\\n            adj[y].push_back(x);\\n        }\\n        vector<int>par(n+1,-1);\\n        dfs(0,-1,par,adj);\\n        vector<int>cnt(n+1,0);\\n         for(int j=0;j<trips.size();j++)\\n             {\\n                  int st= trips[j][0];\\n                  int en= trips[j][1];\\n                  vector<int>p1,p2;\\n                  vector<int>vis(n+1,0);\\n                //  cout<<st<<\" \"<<en<<\"mmmmm\"<<endl;\\n                  while(st!=-1)\\n                  {\\n                      p1.push_back(st);\\n                      vis[st]++;\\n                      st= par[st];\\n                  }\\n                 int t2=-1;\\n                  while(en!=-1)\\n                  {\\n                      if(vis[en]>0)\\n                      {\\n                          t2=en;\\n                          break;\\n                      }\\n                      p2.push_back(en);\\n                      en= par[en];\\n                  }\\n                  for(int k=0;k<p1.size();k++)\\n                  {\\n                      if(p1[k]==t2)\\n                      {\\n                          cnt[p1[k]]++;\\n                          break;\\n                      }\\n                          cnt[p1[k]]++;\\n                  }\\n                 for(int k=0;k<p2.size();k++)\\n                 {\\n                          cnt[p2[k]]++;\\n                 }\\n             }\\n         memset(dp,-1,sizeof(dp));\\n        return min(cnt[0]*(price[0]/2)+check(0,-1,0,adj,cnt,price),cnt[0]*price[0]+check(0,-1,51,adj,cnt,price));\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3421936,
                "title": "java-dfs-dp-most-intuitive-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minimumTotalPrice(int n, int[][] es, int[] p, int[][] trips) {\\n        \\n        ArrayList<Integer>[]g = new ArrayList[n];\\n        for(int i=0;i<g.length;i++)g[i] = new ArrayList<>();\\n        for(int[]e:es) {\\n            g[e[1]].add(e[0]);\\n            g[e[0]].add(e[1]);\\n        }\\n        int[] f = new int[n];\\n        boolean[]v = new boolean[n];\\n        for(int[]tr : trips) {\\n            v = new boolean[n];\\n            trip(tr[0], tr[1], v, new int[n], f, g);\\n        }\\n        \\n        long totalSum = 0;\\n\\t\\t// totalSum of costs would be sum of how many times a node is travelled times its cost\\n        for(int i=0;i<n;i++)totalSum += (p[i] * f[i]);\\n        \\n        int max=0;\\n        int[][]dp = new int[n][2];\\n        for(int[]x:dp)Arrays.fill(x, -1);\\n\\t\\t// find maximum alternating sum in a graph, since all the nodes have positive cost and these nodes are contributing higest cost, hence reduce them by half. \\n\\t\\t//So final ans = totalsum - (half of maximum alternating sum)\\n        max = Math.max(max, Math.max(solve(0, true, -1,f, p, g, dp), solve(0, false, -1,f, p, g, dp)));\\n        return (int)(totalSum - (max/2));\\n        \\n    }\\n    \\n    public int solve(int u, boolean contributeSelf, int par, int[]f, int[]p, ArrayList<Integer>[]g, int[][]dp) {\\n        int ans=0;\\n        if(dp[u][contributeSelf?1:0] != -1) return dp[u][contributeSelf?1:0];\\n        if(contributeSelf) {\\n            int inc = f[u]*p[u];\\n            for(int nbr : g[u]) {\\n                if(nbr != par)\\n                inc += solve(nbr, false, u, f, p, g, dp);\\n            }\\n            \\n            int exc = 0;\\n            for(int nbr : g[u]) {\\n                if(nbr != par)\\n                exc += solve(nbr, true, u, f, p, g, dp);\\n            }\\n            \\n            ans = Math.max(inc, exc);\\n            \\n        } else {\\n            int exc=0;\\n            for(int nbr : g[u]) {\\n                if(nbr != par)\\n                exc += solve(nbr, true, u, f, p, g, dp);\\n            }\\n            ans = exc;\\n        }\\n        return dp[u][contributeSelf?1:0] = ans;\\n    }\\n    \\n    public void trip(int src, int dest, boolean[]v, int[]f, int[]global, ArrayList<Integer>[]g) {\\n        if(v[src]) return;\\n        v[src] = true;\\n        f[src]++;\\n        if(src == dest) {\\n\\t\\t// increasing frequency of nodes in current trip\\n        \\tfor(int i=0;i<f.length;i++)global[i] += f[i];\\n            return;\\n        }\\n        for(int nbr:g[src])trip(nbr, dest, v, f, global, g);\\n        f[src]--;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumTotalPrice(int n, int[][] es, int[] p, int[][] trips) {\\n        \\n        ArrayList<Integer>[]g = new ArrayList[n];\\n        for(int i=0;i<g.length;i++)g[i] = new ArrayList<>();\\n        for(int[]e:es) {\\n            g[e[1]].add(e[0]);\\n            g[e[0]].add(e[1]);\\n        }\\n        int[] f = new int[n];\\n        boolean[]v = new boolean[n];\\n        for(int[]tr : trips) {\\n            v = new boolean[n];\\n            trip(tr[0], tr[1], v, new int[n], f, g);\\n        }\\n        \\n        long totalSum = 0;\\n\\t\\t// totalSum of costs would be sum of how many times a node is travelled times its cost\\n        for(int i=0;i<n;i++)totalSum += (p[i] * f[i]);\\n        \\n        int max=0;\\n        int[][]dp = new int[n][2];\\n        for(int[]x:dp)Arrays.fill(x, -1);\\n\\t\\t// find maximum alternating sum in a graph, since all the nodes have positive cost and these nodes are contributing higest cost, hence reduce them by half. \\n\\t\\t//So final ans = totalsum - (half of maximum alternating sum)\\n        max = Math.max(max, Math.max(solve(0, true, -1,f, p, g, dp), solve(0, false, -1,f, p, g, dp)));\\n        return (int)(totalSum - (max/2));\\n        \\n    }\\n    \\n    public int solve(int u, boolean contributeSelf, int par, int[]f, int[]p, ArrayList<Integer>[]g, int[][]dp) {\\n        int ans=0;\\n        if(dp[u][contributeSelf?1:0] != -1) return dp[u][contributeSelf?1:0];\\n        if(contributeSelf) {\\n            int inc = f[u]*p[u];\\n            for(int nbr : g[u]) {\\n                if(nbr != par)\\n                inc += solve(nbr, false, u, f, p, g, dp);\\n            }\\n            \\n            int exc = 0;\\n            for(int nbr : g[u]) {\\n                if(nbr != par)\\n                exc += solve(nbr, true, u, f, p, g, dp);\\n            }\\n            \\n            ans = Math.max(inc, exc);\\n            \\n        } else {\\n            int exc=0;\\n            for(int nbr : g[u]) {\\n                if(nbr != par)\\n                exc += solve(nbr, true, u, f, p, g, dp);\\n            }\\n            ans = exc;\\n        }\\n        return dp[u][contributeSelf?1:0] = ans;\\n    }\\n    \\n    public void trip(int src, int dest, boolean[]v, int[]f, int[]global, ArrayList<Integer>[]g) {\\n        if(v[src]) return;\\n        v[src] = true;\\n        f[src]++;\\n        if(src == dest) {\\n\\t\\t// increasing frequency of nodes in current trip\\n        \\tfor(int i=0;i<f.length;i++)global[i] += f[i];\\n            return;\\n        }\\n        for(int nbr:g[src])trip(nbr, dest, v, f, global, g);\\n        f[src]--;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421829,
                "title": "dfs-to-calculate-frequency-of-each-node-dp-knapsack-to-get-the-min-total-sum",
                "content": "We first run a dfs on each trip to calculate the frequency of each node\\nthen node sum = price[node] * nodeFrequency\\n\\nthen we run a dp starting from any node\\nwhere we chose where to split or not on each node to get the total min sum\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> hm;\\n    int memo[2][57];\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> adj(n);\\n        for(auto& e: edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        for(auto& t: trips) {\\n            vector<int> parent(n, -1);\\n            bool done = false;\\n            dfs(t[0], t[0], t[1], adj, parent, done);\\n        }\\n        vector<int> sum(n);\\n        for(auto& p: hm) {\\n            sum[p.first] = price[p.first] * p.second;\\n        }\\n        memset(memo, -1, sizeof memo);\\n        return solve(0,n+1,1,adj,sum);\\n        \\n    }\\n    int solve(int idx, int par, int canSplit, vector<vector<int>>& adj, vector<int>& sum) {\\n        auto& ans = memo[canSplit][idx];\\n        if (ans != -1) return ans;\\n        int take = 0;\\n        int split = 0;\\n        for(auto& j: adj[idx]) {\\n            if (j == par) continue;\\n            take += solve(j,idx,1,adj,sum);  \\n            split += solve(j,idx,0,adj,sum);  \\n        }\\n        ans = sum[idx] + take;\\n        if (canSplit) ans = min(ans, sum[idx]/2 + split);\\n        return ans;\\n    }\\n    void dfs(int i, int& source, int& target, vector<vector<int>>& adj, vector<int>& parent, bool& done) {\\n        if (i == target) {\\n            while(i != source) {\\n                hm[i]++;\\n                i = parent[i];\\n            }\\n            hm[source]++;\\n            done = true;\\n            return;\\n        }\\n        for(auto& j: adj[i]) {\\n            if (j != parent[i]) {\\n                parent[j] = i;\\n                dfs(j,source,target,adj,parent,done);\\n                if (done) return;\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> hm;\\n    int memo[2][57];\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> adj(n);\\n        for(auto& e: edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        for(auto& t: trips) {\\n            vector<int> parent(n, -1);\\n            bool done = false;\\n            dfs(t[0], t[0], t[1], adj, parent, done);\\n        }\\n        vector<int> sum(n);\\n        for(auto& p: hm) {\\n            sum[p.first] = price[p.first] * p.second;\\n        }\\n        memset(memo, -1, sizeof memo);\\n        return solve(0,n+1,1,adj,sum);\\n        \\n    }\\n    int solve(int idx, int par, int canSplit, vector<vector<int>>& adj, vector<int>& sum) {\\n        auto& ans = memo[canSplit][idx];\\n        if (ans != -1) return ans;\\n        int take = 0;\\n        int split = 0;\\n        for(auto& j: adj[idx]) {\\n            if (j == par) continue;\\n            take += solve(j,idx,1,adj,sum);  \\n            split += solve(j,idx,0,adj,sum);  \\n        }\\n        ans = sum[idx] + take;\\n        if (canSplit) ans = min(ans, sum[idx]/2 + split);\\n        return ans;\\n    }\\n    void dfs(int i, int& source, int& target, vector<vector<int>>& adj, vector<int>& parent, bool& done) {\\n        if (i == target) {\\n            while(i != source) {\\n                hm[i]++;\\n                i = parent[i];\\n            }\\n            hm[source]++;\\n            done = true;\\n            return;\\n        }\\n        for(auto& j: adj[i]) {\\n            if (j != parent[i]) {\\n                parent[j] = i;\\n                dfs(j,source,target,adj,parent,done);\\n                if (done) return;\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421760,
                "title": "python-dfs-dp-top-down",
                "content": "Find contribution of each node in the total price sum and then find minimum sum by recursively generating all sets of nodes for which prices will be halved and storing the result to avoid repeated calculations.\\n\\n\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        \\n        #function to find path from a node to target node and inclrease the contribution of all nodes in the path\\n        def dfs(node,target,parent):\\n            nonlocal g,contribution\\n            \\n            contribution[node]+=1\\n            if node==target:\\n                return True\\n            \\n            for adj in g[node]:\\n                if adj!=parent:\\n                    if dfs(adj,target,node):\\n                        # target found\\n                        return True\\n                    \\n            # target not found\\n            contribution[node]-=1\\n            return False\\n        \\n        # function to calculate minimum total price sum of tree rooted at \\'node\\'\\n        def backtrack(node,include,parent):\\n            \\n            nonlocal included,excluded,g,contribution\\n            \\n            if included[node]==-1:\\n                # exclude (don\\'t reduce price of node)\\n                excluded[node]=contribution[node]*price[node]\\n                for adj in g[node]:\\n                    if adj!=parent:\\n                        # since we are not reducing the price of this node, prices of adjacent nodes can be reduced so include=True\\n                        excluded[node]+=backtrack(adj,True,node)\\n\\n                # include (reduce price of node)\\n                included[node]=contribution[node]*price[node]//2\\n                for adj in g[node]:\\n                    if adj!=parent:\\n                        # since we are reducing the price of this node, prices of adjacent nodes cannot be reduced so include=False\\n                        included[node]+=backtrack(adj,False,node)\\n                        \\n            if include:\\n                return min(included[node],excluded[node])\\n            else:\\n                return excluded[node]\\n        \\n        \\n        g=[[] for _ in range(n)]\\n        for u,v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n        contribution=[0]*n\\n        \\n        # find contribution of each node in total price sum\\n        for start,end in trips:\\n            dfs(start,end,-1)\\n        \\n        # array to store minimum total price sum of tree rooted at ith node such that price of ith node is halved\\n        included=[-1]*n\\n        # array to store minimum total price sum of tree rooted at ith node such that price of ith node is not halved\\n        excluded=[-1]*n\\n        \\n        # consider node 0 as root and calculate all combinations\\n        return min(backtrack(0,True,-1),backtrack(0,False,-1))\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        \\n        #function to find path from a node to target node and inclrease the contribution of all nodes in the path\\n        def dfs(node,target,parent):\\n            nonlocal g,contribution\\n            \\n            contribution[node]+=1\\n            if node==target:\\n                return True\\n            \\n            for adj in g[node]:\\n                if adj!=parent:\\n                    if dfs(adj,target,node):\\n                        # target found\\n                        return True\\n                    \\n            # target not found\\n            contribution[node]-=1\\n            return False\\n        \\n        # function to calculate minimum total price sum of tree rooted at \\'node\\'\\n        def backtrack(node,include,parent):\\n            \\n            nonlocal included,excluded,g,contribution\\n            \\n            if included[node]==-1:\\n                # exclude (don\\'t reduce price of node)\\n                excluded[node]=contribution[node]*price[node]\\n                for adj in g[node]:\\n                    if adj!=parent:\\n                        # since we are not reducing the price of this node, prices of adjacent nodes can be reduced so include=True\\n                        excluded[node]+=backtrack(adj,True,node)\\n\\n                # include (reduce price of node)\\n                included[node]=contribution[node]*price[node]//2\\n                for adj in g[node]:\\n                    if adj!=parent:\\n                        # since we are reducing the price of this node, prices of adjacent nodes cannot be reduced so include=False\\n                        included[node]+=backtrack(adj,False,node)\\n                        \\n            if include:\\n                return min(included[node],excluded[node])\\n            else:\\n                return excluded[node]\\n        \\n        \\n        g=[[] for _ in range(n)]\\n        for u,v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n        contribution=[0]*n\\n        \\n        # find contribution of each node in total price sum\\n        for start,end in trips:\\n            dfs(start,end,-1)\\n        \\n        # array to store minimum total price sum of tree rooted at ith node such that price of ith node is halved\\n        included=[-1]*n\\n        # array to store minimum total price sum of tree rooted at ith node such that price of ith node is not halved\\n        excluded=[-1]*n\\n        \\n        # consider node 0 as root and calculate all combinations\\n        return min(backtrack(0,True,-1),backtrack(0,False,-1))\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1865045,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "can anyone tell why idea of calculating ans = min(odd level prices is divided / 2, even level prices is divided by 2) doesn't work? It works for around 100 testcases but then it gives wrong answers.\n\nhttps://leetcode.com/problems/minimize-the-total-price-of-the-trips/submissions/934514329/"
                    },
                    {
                        "username": "kumaran_577",
                        "content": "1) Its not neccessary that you have to pick only odd levels or only even levels \\n2) Assume , you are picking current level ,lets say that it is odd , you \"must\" skip next level (even level ) , and now you are in next odd level , you may even pick or not pick , sometimes not picking this might give optimal solution as we can pick next even level which might increase our score \\n"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "This question sucked my soul, and I still couldn\\'t do it. Good question though. :)"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Check this: 337. House Robber III\\n"
                    },
                    {
                        "username": "diabloallica",
                        "content": "can there even be multiple path options for a given trip given that it is guaranteed to be an unrooted tree?\\n"
                    },
                    {
                        "username": "nirvedh",
                        "content": "tree by definition cannot have cycles, if there were two paths, i could reach the node by one path and return back from the other path and hence form a cycle which is a contradiction hence for any tree regardless of rootedness will always have a unique simple path between two nodes"
                    },
                    {
                        "username": "geekyuttu",
                        "content": "For the first sample case, isn\\'t it possible to reduce the total price further by halving, 2,1,3, instead of 2,0,3"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "amazing question"
                    },
                    {
                        "username": "b14ck_5m0k3",
                        "content": "```\\nclass Solution {\\npublic:\\n  int dp[51][2];\\n  int dp_dfs(vector<int>& cnt, vector<int>& price, int node, vector<vector<int>>& E, int p = -1, bool parentHalved = false) {\\n    int res1 = (cnt[node] * price[node]) / 2, res2 = cnt[node] * price[node];\\n    if(dp[node][parentHalved] != -1)  {\\n      return dp[node][parentHalved];\\n    }\\n    for(auto& el : E[node]) {\\n      if(el != p) {\\n        res2 += dp_dfs(cnt, price, el, E, node, 0);\\n      }\\n    }\\n    if(parentHalved)  {\\n      return dp[node][parentHalved] = res2;\\n    }\\n    for(auto& el : E[node]) {\\n      if(el != p) {\\n        res1 += dp_dfs(cnt, price, el, E, node, 1);\\n      }\\n    }\\n    return dp[node][parentHalved] = min(res1, res2);\\n  }\\n  int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n    int sz = trips.size();\\n    vector<int> cnt(n, 0);\\n    vector<vector<int>> E(n);\\n    memset(dp, -1, sizeof(dp));\\n    int edgeSz = edges.size();\\n    for(int i = 0; i < edgeSz; i++) {\\n      E[edges[i][0]].push_back(edges[i][1]);\\n      E[edges[i][1]].push_back(edges[i][0]);\\n    }\\n    for(int i = 0; i < sz; i++) {\\n      int src = trips[i][0], dest = trips[i][1];\\n      vector<bool> seen(n, false);\\n      bool found = false;\\n      function<void(int)> dfs = [&] (int w)  {\\n        seen[w] = true;\\n        cnt[w]++;\\n        if(w == dest) {\\n          found = true;\\n          return;\\n        }\\n        for(auto v : E[w])  {\\n          if(!seen[v])  {\\n            dfs(v);\\n          }\\n        }\\n        if(found) {\\n          return;\\n        }\\n        cnt[w]--;\\n        seen[w] = false;\\n      };\\n      dfs(src);\\n    }\\n    return dp_dfs(cnt, price, 0, E, -1, 0);\\n  }\\n};\\n```\\nWhat could be the mistake, please help me to figure it out."
                    }
                ]
            },
            {
                "id": 1864796,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "can anyone tell why idea of calculating ans = min(odd level prices is divided / 2, even level prices is divided by 2) doesn't work? It works for around 100 testcases but then it gives wrong answers.\n\nhttps://leetcode.com/problems/minimize-the-total-price-of-the-trips/submissions/934514329/"
                    },
                    {
                        "username": "kumaran_577",
                        "content": "1) Its not neccessary that you have to pick only odd levels or only even levels \\n2) Assume , you are picking current level ,lets say that it is odd , you \"must\" skip next level (even level ) , and now you are in next odd level , you may even pick or not pick , sometimes not picking this might give optimal solution as we can pick next even level which might increase our score \\n"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "This question sucked my soul, and I still couldn\\'t do it. Good question though. :)"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Check this: 337. House Robber III\\n"
                    },
                    {
                        "username": "diabloallica",
                        "content": "can there even be multiple path options for a given trip given that it is guaranteed to be an unrooted tree?\\n"
                    },
                    {
                        "username": "nirvedh",
                        "content": "tree by definition cannot have cycles, if there were two paths, i could reach the node by one path and return back from the other path and hence form a cycle which is a contradiction hence for any tree regardless of rootedness will always have a unique simple path between two nodes"
                    },
                    {
                        "username": "geekyuttu",
                        "content": "For the first sample case, isn\\'t it possible to reduce the total price further by halving, 2,1,3, instead of 2,0,3"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "amazing question"
                    },
                    {
                        "username": "b14ck_5m0k3",
                        "content": "```\\nclass Solution {\\npublic:\\n  int dp[51][2];\\n  int dp_dfs(vector<int>& cnt, vector<int>& price, int node, vector<vector<int>>& E, int p = -1, bool parentHalved = false) {\\n    int res1 = (cnt[node] * price[node]) / 2, res2 = cnt[node] * price[node];\\n    if(dp[node][parentHalved] != -1)  {\\n      return dp[node][parentHalved];\\n    }\\n    for(auto& el : E[node]) {\\n      if(el != p) {\\n        res2 += dp_dfs(cnt, price, el, E, node, 0);\\n      }\\n    }\\n    if(parentHalved)  {\\n      return dp[node][parentHalved] = res2;\\n    }\\n    for(auto& el : E[node]) {\\n      if(el != p) {\\n        res1 += dp_dfs(cnt, price, el, E, node, 1);\\n      }\\n    }\\n    return dp[node][parentHalved] = min(res1, res2);\\n  }\\n  int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n    int sz = trips.size();\\n    vector<int> cnt(n, 0);\\n    vector<vector<int>> E(n);\\n    memset(dp, -1, sizeof(dp));\\n    int edgeSz = edges.size();\\n    for(int i = 0; i < edgeSz; i++) {\\n      E[edges[i][0]].push_back(edges[i][1]);\\n      E[edges[i][1]].push_back(edges[i][0]);\\n    }\\n    for(int i = 0; i < sz; i++) {\\n      int src = trips[i][0], dest = trips[i][1];\\n      vector<bool> seen(n, false);\\n      bool found = false;\\n      function<void(int)> dfs = [&] (int w)  {\\n        seen[w] = true;\\n        cnt[w]++;\\n        if(w == dest) {\\n          found = true;\\n          return;\\n        }\\n        for(auto v : E[w])  {\\n          if(!seen[v])  {\\n            dfs(v);\\n          }\\n        }\\n        if(found) {\\n          return;\\n        }\\n        cnt[w]--;\\n        seen[w] = false;\\n      };\\n      dfs(src);\\n    }\\n    return dp_dfs(cnt, price, 0, E, -1, 0);\\n  }\\n};\\n```\\nWhat could be the mistake, please help me to figure it out."
                    }
                ]
            },
            {
                "id": 1864879,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "can anyone tell why idea of calculating ans = min(odd level prices is divided / 2, even level prices is divided by 2) doesn't work? It works for around 100 testcases but then it gives wrong answers.\n\nhttps://leetcode.com/problems/minimize-the-total-price-of-the-trips/submissions/934514329/"
                    },
                    {
                        "username": "kumaran_577",
                        "content": "1) Its not neccessary that you have to pick only odd levels or only even levels \\n2) Assume , you are picking current level ,lets say that it is odd , you \"must\" skip next level (even level ) , and now you are in next odd level , you may even pick or not pick , sometimes not picking this might give optimal solution as we can pick next even level which might increase our score \\n"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "This question sucked my soul, and I still couldn\\'t do it. Good question though. :)"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Check this: 337. House Robber III\\n"
                    },
                    {
                        "username": "diabloallica",
                        "content": "can there even be multiple path options for a given trip given that it is guaranteed to be an unrooted tree?\\n"
                    },
                    {
                        "username": "nirvedh",
                        "content": "tree by definition cannot have cycles, if there were two paths, i could reach the node by one path and return back from the other path and hence form a cycle which is a contradiction hence for any tree regardless of rootedness will always have a unique simple path between two nodes"
                    },
                    {
                        "username": "geekyuttu",
                        "content": "For the first sample case, isn\\'t it possible to reduce the total price further by halving, 2,1,3, instead of 2,0,3"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "amazing question"
                    },
                    {
                        "username": "b14ck_5m0k3",
                        "content": "```\\nclass Solution {\\npublic:\\n  int dp[51][2];\\n  int dp_dfs(vector<int>& cnt, vector<int>& price, int node, vector<vector<int>>& E, int p = -1, bool parentHalved = false) {\\n    int res1 = (cnt[node] * price[node]) / 2, res2 = cnt[node] * price[node];\\n    if(dp[node][parentHalved] != -1)  {\\n      return dp[node][parentHalved];\\n    }\\n    for(auto& el : E[node]) {\\n      if(el != p) {\\n        res2 += dp_dfs(cnt, price, el, E, node, 0);\\n      }\\n    }\\n    if(parentHalved)  {\\n      return dp[node][parentHalved] = res2;\\n    }\\n    for(auto& el : E[node]) {\\n      if(el != p) {\\n        res1 += dp_dfs(cnt, price, el, E, node, 1);\\n      }\\n    }\\n    return dp[node][parentHalved] = min(res1, res2);\\n  }\\n  int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n    int sz = trips.size();\\n    vector<int> cnt(n, 0);\\n    vector<vector<int>> E(n);\\n    memset(dp, -1, sizeof(dp));\\n    int edgeSz = edges.size();\\n    for(int i = 0; i < edgeSz; i++) {\\n      E[edges[i][0]].push_back(edges[i][1]);\\n      E[edges[i][1]].push_back(edges[i][0]);\\n    }\\n    for(int i = 0; i < sz; i++) {\\n      int src = trips[i][0], dest = trips[i][1];\\n      vector<bool> seen(n, false);\\n      bool found = false;\\n      function<void(int)> dfs = [&] (int w)  {\\n        seen[w] = true;\\n        cnt[w]++;\\n        if(w == dest) {\\n          found = true;\\n          return;\\n        }\\n        for(auto v : E[w])  {\\n          if(!seen[v])  {\\n            dfs(v);\\n          }\\n        }\\n        if(found) {\\n          return;\\n        }\\n        cnt[w]--;\\n        seen[w] = false;\\n      };\\n      dfs(src);\\n    }\\n    return dp_dfs(cnt, price, 0, E, -1, 0);\\n  }\\n};\\n```\\nWhat could be the mistake, please help me to figure it out."
                    }
                ]
            },
            {
                "id": 1872686,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "can anyone tell why idea of calculating ans = min(odd level prices is divided / 2, even level prices is divided by 2) doesn't work? It works for around 100 testcases but then it gives wrong answers.\n\nhttps://leetcode.com/problems/minimize-the-total-price-of-the-trips/submissions/934514329/"
                    },
                    {
                        "username": "kumaran_577",
                        "content": "1) Its not neccessary that you have to pick only odd levels or only even levels \\n2) Assume , you are picking current level ,lets say that it is odd , you \"must\" skip next level (even level ) , and now you are in next odd level , you may even pick or not pick , sometimes not picking this might give optimal solution as we can pick next even level which might increase our score \\n"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "This question sucked my soul, and I still couldn\\'t do it. Good question though. :)"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Check this: 337. House Robber III\\n"
                    },
                    {
                        "username": "diabloallica",
                        "content": "can there even be multiple path options for a given trip given that it is guaranteed to be an unrooted tree?\\n"
                    },
                    {
                        "username": "nirvedh",
                        "content": "tree by definition cannot have cycles, if there were two paths, i could reach the node by one path and return back from the other path and hence form a cycle which is a contradiction hence for any tree regardless of rootedness will always have a unique simple path between two nodes"
                    },
                    {
                        "username": "geekyuttu",
                        "content": "For the first sample case, isn\\'t it possible to reduce the total price further by halving, 2,1,3, instead of 2,0,3"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "amazing question"
                    },
                    {
                        "username": "b14ck_5m0k3",
                        "content": "```\\nclass Solution {\\npublic:\\n  int dp[51][2];\\n  int dp_dfs(vector<int>& cnt, vector<int>& price, int node, vector<vector<int>>& E, int p = -1, bool parentHalved = false) {\\n    int res1 = (cnt[node] * price[node]) / 2, res2 = cnt[node] * price[node];\\n    if(dp[node][parentHalved] != -1)  {\\n      return dp[node][parentHalved];\\n    }\\n    for(auto& el : E[node]) {\\n      if(el != p) {\\n        res2 += dp_dfs(cnt, price, el, E, node, 0);\\n      }\\n    }\\n    if(parentHalved)  {\\n      return dp[node][parentHalved] = res2;\\n    }\\n    for(auto& el : E[node]) {\\n      if(el != p) {\\n        res1 += dp_dfs(cnt, price, el, E, node, 1);\\n      }\\n    }\\n    return dp[node][parentHalved] = min(res1, res2);\\n  }\\n  int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n    int sz = trips.size();\\n    vector<int> cnt(n, 0);\\n    vector<vector<int>> E(n);\\n    memset(dp, -1, sizeof(dp));\\n    int edgeSz = edges.size();\\n    for(int i = 0; i < edgeSz; i++) {\\n      E[edges[i][0]].push_back(edges[i][1]);\\n      E[edges[i][1]].push_back(edges[i][0]);\\n    }\\n    for(int i = 0; i < sz; i++) {\\n      int src = trips[i][0], dest = trips[i][1];\\n      vector<bool> seen(n, false);\\n      bool found = false;\\n      function<void(int)> dfs = [&] (int w)  {\\n        seen[w] = true;\\n        cnt[w]++;\\n        if(w == dest) {\\n          found = true;\\n          return;\\n        }\\n        for(auto v : E[w])  {\\n          if(!seen[v])  {\\n            dfs(v);\\n          }\\n        }\\n        if(found) {\\n          return;\\n        }\\n        cnt[w]--;\\n        seen[w] = false;\\n      };\\n      dfs(src);\\n    }\\n    return dp_dfs(cnt, price, 0, E, -1, 0);\\n  }\\n};\\n```\\nWhat could be the mistake, please help me to figure it out."
                    }
                ]
            },
            {
                "id": 2048992,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "can anyone tell why idea of calculating ans = min(odd level prices is divided / 2, even level prices is divided by 2) doesn't work? It works for around 100 testcases but then it gives wrong answers.\n\nhttps://leetcode.com/problems/minimize-the-total-price-of-the-trips/submissions/934514329/"
                    },
                    {
                        "username": "kumaran_577",
                        "content": "1) Its not neccessary that you have to pick only odd levels or only even levels \\n2) Assume , you are picking current level ,lets say that it is odd , you \"must\" skip next level (even level ) , and now you are in next odd level , you may even pick or not pick , sometimes not picking this might give optimal solution as we can pick next even level which might increase our score \\n"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "This question sucked my soul, and I still couldn\\'t do it. Good question though. :)"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Check this: 337. House Robber III\\n"
                    },
                    {
                        "username": "diabloallica",
                        "content": "can there even be multiple path options for a given trip given that it is guaranteed to be an unrooted tree?\\n"
                    },
                    {
                        "username": "nirvedh",
                        "content": "tree by definition cannot have cycles, if there were two paths, i could reach the node by one path and return back from the other path and hence form a cycle which is a contradiction hence for any tree regardless of rootedness will always have a unique simple path between two nodes"
                    },
                    {
                        "username": "geekyuttu",
                        "content": "For the first sample case, isn\\'t it possible to reduce the total price further by halving, 2,1,3, instead of 2,0,3"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "amazing question"
                    },
                    {
                        "username": "b14ck_5m0k3",
                        "content": "```\\nclass Solution {\\npublic:\\n  int dp[51][2];\\n  int dp_dfs(vector<int>& cnt, vector<int>& price, int node, vector<vector<int>>& E, int p = -1, bool parentHalved = false) {\\n    int res1 = (cnt[node] * price[node]) / 2, res2 = cnt[node] * price[node];\\n    if(dp[node][parentHalved] != -1)  {\\n      return dp[node][parentHalved];\\n    }\\n    for(auto& el : E[node]) {\\n      if(el != p) {\\n        res2 += dp_dfs(cnt, price, el, E, node, 0);\\n      }\\n    }\\n    if(parentHalved)  {\\n      return dp[node][parentHalved] = res2;\\n    }\\n    for(auto& el : E[node]) {\\n      if(el != p) {\\n        res1 += dp_dfs(cnt, price, el, E, node, 1);\\n      }\\n    }\\n    return dp[node][parentHalved] = min(res1, res2);\\n  }\\n  int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n    int sz = trips.size();\\n    vector<int> cnt(n, 0);\\n    vector<vector<int>> E(n);\\n    memset(dp, -1, sizeof(dp));\\n    int edgeSz = edges.size();\\n    for(int i = 0; i < edgeSz; i++) {\\n      E[edges[i][0]].push_back(edges[i][1]);\\n      E[edges[i][1]].push_back(edges[i][0]);\\n    }\\n    for(int i = 0; i < sz; i++) {\\n      int src = trips[i][0], dest = trips[i][1];\\n      vector<bool> seen(n, false);\\n      bool found = false;\\n      function<void(int)> dfs = [&] (int w)  {\\n        seen[w] = true;\\n        cnt[w]++;\\n        if(w == dest) {\\n          found = true;\\n          return;\\n        }\\n        for(auto v : E[w])  {\\n          if(!seen[v])  {\\n            dfs(v);\\n          }\\n        }\\n        if(found) {\\n          return;\\n        }\\n        cnt[w]--;\\n        seen[w] = false;\\n      };\\n      dfs(src);\\n    }\\n    return dp_dfs(cnt, price, 0, E, -1, 0);\\n  }\\n};\\n```\\nWhat could be the mistake, please help me to figure it out."
                    }
                ]
            },
            {
                "id": 1920082,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "can anyone tell why idea of calculating ans = min(odd level prices is divided / 2, even level prices is divided by 2) doesn't work? It works for around 100 testcases but then it gives wrong answers.\n\nhttps://leetcode.com/problems/minimize-the-total-price-of-the-trips/submissions/934514329/"
                    },
                    {
                        "username": "kumaran_577",
                        "content": "1) Its not neccessary that you have to pick only odd levels or only even levels \\n2) Assume , you are picking current level ,lets say that it is odd , you \"must\" skip next level (even level ) , and now you are in next odd level , you may even pick or not pick , sometimes not picking this might give optimal solution as we can pick next even level which might increase our score \\n"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "This question sucked my soul, and I still couldn\\'t do it. Good question though. :)"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Check this: 337. House Robber III\\n"
                    },
                    {
                        "username": "diabloallica",
                        "content": "can there even be multiple path options for a given trip given that it is guaranteed to be an unrooted tree?\\n"
                    },
                    {
                        "username": "nirvedh",
                        "content": "tree by definition cannot have cycles, if there were two paths, i could reach the node by one path and return back from the other path and hence form a cycle which is a contradiction hence for any tree regardless of rootedness will always have a unique simple path between two nodes"
                    },
                    {
                        "username": "geekyuttu",
                        "content": "For the first sample case, isn\\'t it possible to reduce the total price further by halving, 2,1,3, instead of 2,0,3"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "amazing question"
                    },
                    {
                        "username": "b14ck_5m0k3",
                        "content": "```\\nclass Solution {\\npublic:\\n  int dp[51][2];\\n  int dp_dfs(vector<int>& cnt, vector<int>& price, int node, vector<vector<int>>& E, int p = -1, bool parentHalved = false) {\\n    int res1 = (cnt[node] * price[node]) / 2, res2 = cnt[node] * price[node];\\n    if(dp[node][parentHalved] != -1)  {\\n      return dp[node][parentHalved];\\n    }\\n    for(auto& el : E[node]) {\\n      if(el != p) {\\n        res2 += dp_dfs(cnt, price, el, E, node, 0);\\n      }\\n    }\\n    if(parentHalved)  {\\n      return dp[node][parentHalved] = res2;\\n    }\\n    for(auto& el : E[node]) {\\n      if(el != p) {\\n        res1 += dp_dfs(cnt, price, el, E, node, 1);\\n      }\\n    }\\n    return dp[node][parentHalved] = min(res1, res2);\\n  }\\n  int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n    int sz = trips.size();\\n    vector<int> cnt(n, 0);\\n    vector<vector<int>> E(n);\\n    memset(dp, -1, sizeof(dp));\\n    int edgeSz = edges.size();\\n    for(int i = 0; i < edgeSz; i++) {\\n      E[edges[i][0]].push_back(edges[i][1]);\\n      E[edges[i][1]].push_back(edges[i][0]);\\n    }\\n    for(int i = 0; i < sz; i++) {\\n      int src = trips[i][0], dest = trips[i][1];\\n      vector<bool> seen(n, false);\\n      bool found = false;\\n      function<void(int)> dfs = [&] (int w)  {\\n        seen[w] = true;\\n        cnt[w]++;\\n        if(w == dest) {\\n          found = true;\\n          return;\\n        }\\n        for(auto v : E[w])  {\\n          if(!seen[v])  {\\n            dfs(v);\\n          }\\n        }\\n        if(found) {\\n          return;\\n        }\\n        cnt[w]--;\\n        seen[w] = false;\\n      };\\n      dfs(src);\\n    }\\n    return dp_dfs(cnt, price, 0, E, -1, 0);\\n  }\\n};\\n```\\nWhat could be the mistake, please help me to figure it out."
                    }
                ]
            },
            {
                "id": 1911496,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "can anyone tell why idea of calculating ans = min(odd level prices is divided / 2, even level prices is divided by 2) doesn't work? It works for around 100 testcases but then it gives wrong answers.\n\nhttps://leetcode.com/problems/minimize-the-total-price-of-the-trips/submissions/934514329/"
                    },
                    {
                        "username": "kumaran_577",
                        "content": "1) Its not neccessary that you have to pick only odd levels or only even levels \\n2) Assume , you are picking current level ,lets say that it is odd , you \"must\" skip next level (even level ) , and now you are in next odd level , you may even pick or not pick , sometimes not picking this might give optimal solution as we can pick next even level which might increase our score \\n"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "This question sucked my soul, and I still couldn\\'t do it. Good question though. :)"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Check this: 337. House Robber III\\n"
                    },
                    {
                        "username": "diabloallica",
                        "content": "can there even be multiple path options for a given trip given that it is guaranteed to be an unrooted tree?\\n"
                    },
                    {
                        "username": "nirvedh",
                        "content": "tree by definition cannot have cycles, if there were two paths, i could reach the node by one path and return back from the other path and hence form a cycle which is a contradiction hence for any tree regardless of rootedness will always have a unique simple path between two nodes"
                    },
                    {
                        "username": "geekyuttu",
                        "content": "For the first sample case, isn\\'t it possible to reduce the total price further by halving, 2,1,3, instead of 2,0,3"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "amazing question"
                    },
                    {
                        "username": "b14ck_5m0k3",
                        "content": "```\\nclass Solution {\\npublic:\\n  int dp[51][2];\\n  int dp_dfs(vector<int>& cnt, vector<int>& price, int node, vector<vector<int>>& E, int p = -1, bool parentHalved = false) {\\n    int res1 = (cnt[node] * price[node]) / 2, res2 = cnt[node] * price[node];\\n    if(dp[node][parentHalved] != -1)  {\\n      return dp[node][parentHalved];\\n    }\\n    for(auto& el : E[node]) {\\n      if(el != p) {\\n        res2 += dp_dfs(cnt, price, el, E, node, 0);\\n      }\\n    }\\n    if(parentHalved)  {\\n      return dp[node][parentHalved] = res2;\\n    }\\n    for(auto& el : E[node]) {\\n      if(el != p) {\\n        res1 += dp_dfs(cnt, price, el, E, node, 1);\\n      }\\n    }\\n    return dp[node][parentHalved] = min(res1, res2);\\n  }\\n  int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n    int sz = trips.size();\\n    vector<int> cnt(n, 0);\\n    vector<vector<int>> E(n);\\n    memset(dp, -1, sizeof(dp));\\n    int edgeSz = edges.size();\\n    for(int i = 0; i < edgeSz; i++) {\\n      E[edges[i][0]].push_back(edges[i][1]);\\n      E[edges[i][1]].push_back(edges[i][0]);\\n    }\\n    for(int i = 0; i < sz; i++) {\\n      int src = trips[i][0], dest = trips[i][1];\\n      vector<bool> seen(n, false);\\n      bool found = false;\\n      function<void(int)> dfs = [&] (int w)  {\\n        seen[w] = true;\\n        cnt[w]++;\\n        if(w == dest) {\\n          found = true;\\n          return;\\n        }\\n        for(auto v : E[w])  {\\n          if(!seen[v])  {\\n            dfs(v);\\n          }\\n        }\\n        if(found) {\\n          return;\\n        }\\n        cnt[w]--;\\n        seen[w] = false;\\n      };\\n      dfs(src);\\n    }\\n    return dp_dfs(cnt, price, 0, E, -1, 0);\\n  }\\n};\\n```\\nWhat could be the mistake, please help me to figure it out."
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Sum With Exactly K Elements ",
        "question_content": "<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> and an integer <code>k</code>. Your task is to perform the following operation <strong>exactly</strong> <code>k</code> times in order to maximize your score:</p>\n\n<ol>\n\t<li>Select an element <code>m</code> from <code>nums</code>.</li>\n\t<li>Remove the selected element <code>m</code> from the array.</li>\n\t<li>Add a new element with a value of <code>m + 1</code> to the array.</li>\n\t<li>Increase your score by <code>m</code>.</li>\n</ol>\n\n<p>Return <em>the maximum score you can achieve after performing the operation exactly</em> <code>k</code> <em>times.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,4,5], k = 3\n<strong>Output:</strong> 18\n<strong>Explanation:</strong> We need to choose exactly 3 elements from nums to maximize the sum.\nFor the first iteration, we choose 5. Then sum is 5 and nums = [1,2,3,4,6]\nFor the second iteration, we choose 6. Then sum is 5 + 6 and nums = [1,2,3,4,7]\nFor the third iteration, we choose 7. Then sum is 5 + 6 + 7 = 18 and nums = [1,2,3,4,8]\nSo, we will return 18.\nIt can be proven, that 18 is the maximum answer that we can achieve.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,5,5], k = 2\n<strong>Output:</strong> 11\n<strong>Explanation:</strong> We need to choose exactly 2 elements from nums to maximize the sum.\nFor the first iteration, we choose 5. Then sum is 5 and nums = [5,5,6]\nFor the second iteration, we choose 6. Then sum is 5 + 6 = 11 and nums = [5,5,7]\nSo, we will return 11.\nIt can be proven, that 11 is the maximum answer that we can achieve.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= k &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<style type=\"text/css\">.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; \n}\n.spoiler {overflow:hidden;}\n.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}\n.spoilerbutton[value=\"Show Message\"] + .spoiler > div {margin-top:-500%;}\n.spoilerbutton[value=\"Hide Message\"] + .spoiler {padding:5px;}\n</style>\n",
        "solutions": [
            {
                "id": 3466678,
                "title": "max-element-formula",
                "content": "We find max element `m`, and the result is `m + (m + 1) ... + (m + k - 1)`.\\n\\nWe can rewrite this as `k * m` plus `0 + 1 + 2 + ... k - 1`. \\n\\nWe compute the second part using the formula for the sum of arithmetic progression: `k * (k - 1) / 2`.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def maximizeSum(self, n: List[int], k: int) -> int:\\n        return  k * max(n) + k * (k - 1) // 2;\\n```\\n\\n**C++**\\n```cpp\\nint maximizeSum(vector<int>& n, int k) {\\n    int m = *max_element(begin(n), end(n));\\n    return k * m + k * (k - 1) / 2;    \\n}",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maximizeSum(self, n: List[int], k: int) -> int:\\n        return  k * max(n) + k * (k - 1) // 2;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467980,
                "title": "easiest-solution-out-there-in-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n + k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max = 0;\\n        for(int i = 0; i<nums.length; i++){ \\n            max = Math.max(max, nums[i]);\\n        }\\n        \\n        int ans = 0;\\n        while(k>0){\\n            ans+=max;\\n            max = max+1;\\n            k--;\\n        }\\n        return ans;\\n    }   \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max = 0;\\n        for(int i = 0; i<nums.length; i++){ \\n            max = Math.max(max, nums[i]);\\n        }\\n        \\n        int ans = 0;\\n        while(k>0){\\n            ans+=max;\\n            max = max+1;\\n            k--;\\n        }\\n        return ans;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466875,
                "title": "very-simple-easy-to-understand-solution",
                "content": "With observation, the ans will be the sum of ( largest element to largets element + k) numbers\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumUptoN(int n){ return n*(n+1)/2; }\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int mx = nums[0];\\n        for(auto n: nums) mx = max(mx, n);\\n        return sumUptoN(mx+k-1) - sumUptoN(mx-1);\\n    }\\n};\\n```\\n\\nHere is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumUptoN(int n){ return n*(n+1)/2; }\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int mx = nums[0];\\n        for(auto n: nums) mx = max(mx, n);\\n        return sumUptoN(mx+k-1) - sumUptoN(mx-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466659,
                "title": "c-arithmetic-progression-simple-math",
                "content": "observation:\\n1. U have to choose max Element , remove it and add max_element+1\\n2. so u are just choosing same element again and again and they are in AP\\n\\nFor ex:[1,3,4,5,1] k=3\\nchoosen element =5,6,7  this is in AP\\nans=5+6+7\\n\\nFormula For Sum of Element In AP=n*(2*A+(n-1)*d)/2\\nhere n=k and A=max_element\\n\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int A=*max_element(nums.begin(),nums.end());      \\n         int ans=k*(2*A+(k-1)*1)/2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int A=*max_element(nums.begin(),nums.end());      \\n         int ans=k*(2*A+(k-1)*1)/2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467607,
                "title": "python-3-2-lines-w-explanation-t-m-162-ms-16-mb",
                "content": "Here\\'s the intuition:\\nThe problem is equivalent to evaluating the sum of `n,n+1, ..., n+k-1`, where`n = max(nums)`. Because this sequence is arithmetic, the sum is equal to`k*(2*n+k-1)//2`.\\n\\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        \\n        n = max(nums)\\n\\n        return k*(2*n+k-1)//2\\n```\\n[https://leetcode.com/problems/maximum-sum-with-exactly-k-elements/submissions/941730954/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        \\n        n = max(nums)\\n\\n        return k*(2*n+k-1)//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467153,
                "title": "c-python-easy-solution",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n + k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int m = nums[0];\\n        for(auto i : nums) {\\n            if(i > m) m = i;\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < k; i++) {\\n            ans += m;\\n            m++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Python / Python3\\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        m = nums[0]\\n        for i in nums:\\n            if i > m:\\n                m = i\\n        ans = 0\\n        for i in range(0, k):\\n            ans += m\\n            m += 1\\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int m = nums[0];\\n        for(auto i : nums) {\\n            if(i > m) m = i;\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < k; i++) {\\n            ans += m;\\n            m++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        m = nums[0]\\n        for i in nums:\\n            if i > m:\\n                m = i\\n        ans = 0\\n        for i in range(0, k):\\n            ans += m\\n            m += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488552,
                "title": "python-go-easy-solution",
                "content": "# Python \\u2705\\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        sums = max(nums)\\n        for i in range(sums+1,sums+k):\\n            sums += i\\n        return sums\\n\\n```\\n# Go \\u2705\\n```\\nimport (\\n   \"sort\"\\n)\\nfunc maximizeSum(nums []int, k int) int {\\n   sort.Ints(nums)\\n   sum := nums[len(nums)-1]\\n   start := sum+1\\n   last := sum+k\\n   for start<last{\\n       sum += start\\n       start++\\n   }\\n   return sum\\n}\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Go"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        sums = max(nums)\\n        for i in range(sums+1,sums+k):\\n            sums += i\\n        return sums\\n\\n```\n```\\nimport (\\n   \"sort\"\\n)\\nfunc maximizeSum(nums []int, k int) int {\\n   sort.Ints(nums)\\n   sum := nums[len(nums)-1]\\n   start := sum+1\\n   last := sum+k\\n   for start<last{\\n       sum += start\\n       start++\\n   }\\n   return sum\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469405,
                "title": "java-maximum-sum-with-exactly-k-elements",
                "content": "\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n                int max = nums[0];\\n        for (int m: nums)\\n            max = Math.max(m, max);\\n        int sum = max++;\\n        for (int i = 0; i < k - 1; i++)\\n            sum += max++;\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n                int max = nums[0];\\n        for (int m: nums)\\n            max = Math.max(m, max);\\n        int sum = max++;\\n        for (int i = 0; i < k - 1; i++)\\n            sum += max++;\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466844,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nThe given code aims to find the maximum possible sum of a subarray with k elements from the input array, nums. The code first sorts the elements of nums in ascending order. Then, it initializes a variable called ans to the maximum value of nums. It iterates through the array nums and adds the maximum element to the variable ans in each iteration. It does this k times, adding 1 to a counter variable i in each iteration. Finally, the code returns the variable ans as the maximum sum of the subarray. In other words, the code is trying to find the sum of the largest k elements in the input array.\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\nArrays.sort(nums);\\n   // int n = nums.length;\\n    int max =nums[nums.length-1] ;\\n        int ans=max;\\n   for(int i=1;i<k;i++)\\n   {\\n       ans=ans+(max+i);\\n   }\\n        return ans;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\nArrays.sort(nums);\\n   // int n = nums.length;\\n    int max =nums[nums.length-1] ;\\n        int ans=max;\\n   for(int i=1;i<k;i++)\\n   {\\n       ans=ans+(max+i);\\n   }\\n        return ans;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466834,
                "title": "formula-max-elements-k-k-1-k-2-c",
                "content": "\\n# Approach\\nformula= max_elements*k+ (k-1)*k/2\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*LOG(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int yk=nums[nums.size()-1]*k;\\n        // int op=k;\\n        k--;\\n       int yk2=k*(k+1);\\n        yk2/=2;\\n        // yk*=op;\\n        yk+=yk2;\\n        return yk;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int yk=nums[nums.size()-1]*k;\\n        // int op=k;\\n        k--;\\n       int yk2=k*(k+1);\\n        yk2/=2;\\n        // yk*=op;\\n        yk+=yk2;\\n        return yk;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466735,
                "title": "python3-solution",
                "content": "\\n\\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        max_num = max(nums)\\n        ans = 0\\n        for _ in range(k):\\n            ans += max_num\\n            max_num += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        max_num = max(nums)\\n        ans = 0\\n        for _ in range(k):\\n            ans += max_num\\n            max_num += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466632,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n log n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        List<Integer> nm=new ArrayList<>();\\n        for(int i:nums)\\n        {\\n            nm.add(i);\\n        }\\n        Collections.sort(nm);\\n        int sum=0;\\n        int len=nm.size();\\n        while(k>0)\\n        {\\n            int ele=nm.get(len-1);\\n            sum+=ele;\\n            nm.remove(len-1);\\n            nm.add(ele+1);\\n            k--;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        List<Integer> nm=new ArrayList<>();\\n        for(int i:nums)\\n        {\\n            nm.add(i);\\n        }\\n        Collections.sort(nm);\\n        int sum=0;\\n        int len=nm.size();\\n        while(k>0)\\n        {\\n            int ele=nm.get(len-1);\\n            sum+=ele;\\n            nm.remove(len-1);\\n            nm.add(ele+1);\\n            k--;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538686,
                "title": "my-maximizesum",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int maximizeSum(vector<int>& nums, int k) {\\n    int const maxElemenent = *max_element(nums.begin(), nums.end());\\n    int result = 0;\\n    for (int i = 0; i < k; i++) {\\n      result += maxElemenent + i;\\n    }\\n    return result;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int maximizeSum(vector<int>& nums, int k) {\\n    int const maxElemenent = *max_element(nums.begin(), nums.end());\\n    int result = 0;\\n    for (int i = 0; i < k; i++) {\\n      result += maxElemenent + i;\\n    }\\n    return result;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469200,
                "title": "brute-force-easy-to-understand-step-by-step-solution",
                "content": "# Intuition\\nObserved we are just taking larges value and then adding it in our ans and increasing it by one each time.\\n\\n# Approach\\nBrute force approach.\\n1. Find the max element in the given vector.\\n2. Run a while loop while k is not equal to zero\\n3. Adding it to our sum variable and then increase value of maxi by one and deacrese value of k each time.\\n\\n# Complexity\\n- Time complexity:\\n  O(n) \\n\\n- Space complexity:\\n  O(1) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int sum=0;\\n        int maxi=INT_MIN;\\n        for(auto a:nums){\\n            maxi=max(a,maxi);\\n        }\\n        while(k--){\\n            sum+=maxi;\\n            maxi+=1;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int sum=0;\\n        int maxi=INT_MIN;\\n        for(auto a:nums){\\n            maxi=max(a,maxi);\\n        }\\n        while(k--){\\n            sum+=maxi;\\n            maxi+=1;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466912,
                "title": "c-best-solution-100-faster-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n[1,2,3,4,5], k = 3\\n    \\n5 + 6 + 7\\n(5 * 3) + (0 + 1 + 2)\\n\\nadd the maximum element k times => maxi * k\\nand add 0 + 1 + 2 + 3 + ..... + (k - 1)\\nsum of first (k - 1)    elements\\ntherefore ans = ((maxi * k) + ((k * 1ll * (k-1))/2));\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n***O(N)***\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n***O(1)***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& arr, int k) {\\n        int temp = *max_element(arr.begin(), arr.end());\\n        return ((temp*k) + ((k*1ll*(k-1))/2));\\n        // temp is multiplied by k \\n        // and add 0 + 1 + 2 + 3 + .... + (k-1) => (((k-1) * k) / 2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& arr, int k) {\\n        int temp = *max_element(arr.begin(), arr.end());\\n        return ((temp*k) + ((k*1ll*(k-1))/2));\\n        // temp is multiplied by k \\n        // and add 0 + 1 + 2 + 3 + .... + (k-1) => (((k-1) * k) / 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466682,
                "title": "short-clean-simple-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int val = Arrays.stream(nums).max().getAsInt(), res = 0;\\n        while(k-->0)   res += val++;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int val = Arrays.stream(nums).max().getAsInt(), res = 0;\\n        while(k-->0)   res += val++;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492164,
                "title": "c-find-max-element-easy-to-understand",
                "content": "# Intuition\\nTHAT EASYLY UNDERSTABLE THAT FIND MAX ELEMENT mx. INCREMENT ANS BY mx. ADD NEW ELEMENT IN ARRAY mx+1. TILL K-1\\n\\n# Approach\\nRETURN mx+(k*(k+1))/2\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for(auto &i: nums)ans = max(ans,i);//FIND MAX LEMENT\\n        return ans*k+(k*(k-1))/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int ans = 0;\\n        for(auto &i: nums)ans = max(ans,i);//FIND MAX LEMENT\\n        return ans*k+(k*(k-1))/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903890,
                "title": "python-code-using-range-function-itself-clever-way-to-solve-beats-95-2-lines",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfind max of array m then,\\nwe can use the inbuilt range() to solve the question as it gives the required answer\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**_______O(K)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**_______O(1)**\\n# Code\\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        m=max(nums)\\n        return sum(range(m,m+k))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        m=max(nums)\\n        return sum(range(m,m+k))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826699,
                "title": "javascript-simple-code-76-ms-beats-100-o-n-time-o-1-space",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![Screenshot 2023-07-28 at 12.11.02.png](https://assets.leetcode.com/users/images/f54548fc-c439-428e-a5f9-dedb14591a37_1690517472.5807898.png)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maximizeSum = function (nums, k) {\\n  // Using Math.max for find max number\\n  let max = Math.max(...nums);\\n  // init sum\\n  let sum = 0;\\n  // we only need max number plus one until k\\n  for (let i = 0; i < k; i++) {\\n    sum += max;\\n    max += 1;\\n  }\\n  // yeah that\\'s it finally return the sum\\n  return sum;\\n};\\n\\n```\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maximizeSum = function (nums, k) {\\n  // Using Math.max for find max number\\n  let max = Math.max(...nums);\\n  // init sum\\n  let sum = 0;\\n  // we only need max number plus one until k\\n  for (let i = 0; i < k; i++) {\\n    sum += max;\\n    max += 1;\\n  }\\n  // yeah that\\'s it finally return the sum\\n  return sum;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3707519,
                "title": "best-approach-using-java-c-python-swift-with-0ms-runtime",
                "content": "\\n# Approach\\nThe given code defines a class named \"Solution\" with a member function named \"maximizeSum\". This function takes a vector of integers \"nums\" and an integer \"k\" as input and returns an integer.\\n\\nThe purpose of the function is to maximize the sum of the elements in the vector by performing a series of operations. The operations involve incrementing the largest element in the vector and reducing the value of \"k\" by 1. The process is repeated \"k\" times.\\n\\nHere\\'s how the function works:\\n\\n1. It declares two integer variables, \"j\" and \"i\". \"j\" is initialized as the maximum element in the \"nums\" vector using the `max_element` function from the `<algorithm>` library. \"i\" is initialized as 0.\\n\\n2. The function enters a while loop that continues until \"k\" becomes 0.\\n\\n3. Inside the loop, the value of \"i\" is updated by adding the current value of \"j\". Then, \"j\" is incremented by 1.\\n\\n4. The value of \"k\" is decremented by 1 in each iteration of the loop.\\n\\n5. After the loop ends, the function returns the value of \"i\", which represents the maximized sum of the elements in the vector after performing the specified number of operations.\\n\\nIn summary, the \"maximizeSum\" function finds the maximum sum of the elements in the vector by repeatedly incrementing the largest element and reducing the value of \"k\".\\n\\n\\n\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int j=*max_element(nums.begin(),nums.end()),i=0;\\n        while(k){\\n            i=i+j;\\n            j++;\\n            k--;\\n        }\\n    return i;\\n     }\\n};\\n```\\n```java []\\nimport java.util.Collections;\\nimport java.util.List;\\n\\nclass Solution {\\n    public int maximizeSum(List<Integer> nums, int k) {\\n        int j = Collections.max(nums);\\n        int i = 0;\\n        while (k > 0) {\\n            i += j;\\n            j++;\\n            k--;\\n        }\\n        return i;\\n    }\\n}\\n\\n```\\n```Swift []\\nclass Solution {\\n    func maximizeSum(_ nums: [Int], _ k: Int) -> Int {\\n        var j = nums.max() ?? 0\\n        var i = 0\\n        var k = k\\n        \\n        while k > 0 {\\n            i += j\\n            j += 1\\n            k -= 1\\n        }\\n        \\n        return i\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def maximizeSum(self, nums, k):\\n        j = max(nums)\\n        i = 0\\n        while k > 0:\\n            i += j\\n            j += 1\\n            k -= 1\\n        return i\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Swift",
                    "Greedy"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int j=*max_element(nums.begin(),nums.end()),i=0;\\n        while(k){\\n            i=i+j;\\n            j++;\\n            k--;\\n        }\\n    return i;\\n     }\\n};\\n```\n```java []\\nimport java.util.Collections;\\nimport java.util.List;\\n\\nclass Solution {\\n    public int maximizeSum(List<Integer> nums, int k) {\\n        int j = Collections.max(nums);\\n        int i = 0;\\n        while (k > 0) {\\n            i += j;\\n            j++;\\n            k--;\\n        }\\n        return i;\\n    }\\n}\\n\\n```\n```Swift []\\nclass Solution {\\n    func maximizeSum(_ nums: [Int], _ k: Int) -> Int {\\n        var j = nums.max() ?? 0\\n        var i = 0\\n        var k = k\\n        \\n        while k > 0 {\\n            i += j\\n            j += 1\\n            k -= 1\\n        }\\n        \\n        return i\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def maximizeSum(self, nums, k):\\n        j = max(nums)\\n        i = 0\\n        while k > 0:\\n            i += j\\n            j += 1\\n            k -= 1\\n        return i\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673783,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind the maximum element of the array, return the sum of numbers from m to m+k-1. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the maximum element by traversing, Find the sum of elements by (n*n-1/2). \\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you find it helpful \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int m = nums[0]; int sum = 0; \\n        for(int i=1; i<nums.size(); i++) if(m < nums[i]) m = nums[i]; \\n        \\n        sum = k*m + (k-1)*k/2; \\n        return sum; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int m = nums[0]; int sum = 0; \\n        for(int i=1; i<nums.size(); i++) if(m < nums[i]) m = nums[i]; \\n        \\n        sum = k*m + (k-1)*k/2; \\n        return sum; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601020,
                "title": "java-python-c-one-line-solution-beats-100",
                "content": "# Intuition\\n\\nWe need to find the largest number and keep adding it to answer by incrementing it k times.\\n\\n# Approach\\nWe find the maximum element by *max_element function. We require a time complexity of O(N) for this.\\nWe then mulitply the maximum element with k and add to the answer as we are adding it k times.\\nNow we need to add 1 to answer k-1 times.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n\\n```\\n// C++ solution\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        return (*max_element(nums.begin(), nums.end()))*k + (k-1)*k/2;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            if(max<nums[i]) max = nums[i];\\n        }\\n        return max*k + (k-1)*k/2;\\n    }\\n}\\n```\\n```python []\\nclass Solution(object):\\n    def maximizeSum(self, nums, k):\\n        return (max(nums))*k + (k-1)*k/2;\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\n// C++ solution\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        return (*max_element(nums.begin(), nums.end()))*k + (k-1)*k/2;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            if(max<nums[i]) max = nums[i];\\n        }\\n        return max*k + (k-1)*k/2;\\n    }\\n}\\n```\n```python []\\nclass Solution(object):\\n    def maximizeSum(self, nums, k):\\n        return (max(nums))*k + (k-1)*k/2;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577800,
                "title": "javascript-easiest-solution",
                "content": "# Intuition\\nThe code appears to aim at finding the maximum sum by selecting the maximum element from the given array nums and adding k consecutive integers starting from 0.\\n# Approach\\n1. Find the maximum element in the array using Math.max(...nums).\\n2. Initialize the variable sum with the maximum element.\\n3. Iterate k-1 times starting from 1 (since we have already accounted for 0 in the maximum element).\\n4. In each iteration, add the current maximum element plus the current iteration index to the sum.\\n5. Return the final sum.\\n\\n# Complexity\\n- Time complexity: O(k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maximizeSum = function(nums, k) {\\n    let max = Math.max(...nums);\\n    sum = max;\\n    for(let i=1; i<k; i++){\\n        sum+= max+i;\\n    }\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maximizeSum = function(nums, k) {\\n    let max = Math.max(...nums);\\n    sum = max;\\n    for(let i=1; i<k; i++){\\n        sum+= max+i;\\n    }\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3548260,
                "title": "2656-java-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max = 0 , ans = 0;\\n        // In this loop to find maximum value in the nums array;\\n        for(int i : nums) if(max < i) max = i;\\n        \\n        // this loop to perform k times\\n        // ex:  add max value to ans and increse the max by 1;\\n        for(int j = 1; j <= k; j++) ans += max++;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max = 0 , ans = 0;\\n        // In this loop to find maximum value in the nums array;\\n        for(int i : nums) if(max < i) max = i;\\n        \\n        // this loop to perform k times\\n        // ex:  add max value to ans and increse the max by 1;\\n        for(int j = 1; j <= k; j++) ans += max++;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522370,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int last=nums[nums.length-1];\\n        int sum=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            sum+=(last+i);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int last=nums[nums.length-1];\\n        int sum=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            sum+=(last+i);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513691,
                "title": "easy-to-understand-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        m = max(nums)\\n\\n        res = 0\\n        for i in range(k):\\n            res+=m\\n            m+=1\\n        return res\\n\\n        \\n\\n     \\n\\n\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        m = max(nums)\\n\\n        res = 0\\n        for i in range(k):\\n            res+=m\\n            m+=1\\n        return res\\n\\n        \\n\\n     \\n\\n\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509818,
                "title": "java-1ms-100-3-lines-summation-formula-explanation",
                "content": "The algorithm is:\\n\\n1. Find maximum value `m` in array `nums[]`.\\n2. Return summation formula calculation to find sum of: `m`, `m+1`, ... `m+k-2`, `m+k-1`\\n\\nThe general mathematical summation formula for summing the values 1...n, is: n(n+1)/2.\\n\\nTo find the sum of `m`...`m+k-1`, use: sum(`1`...`m+k-1`) - sum(`1`...`m-1`).\\n\\nWhich in words is: sum of the first `m-k-1` positive integers, then subtract the unused integers below `m` by subtracting the sum of the first `m-1` positive integers.  Using the general mathematical summation formula, this would result in the algebraic expression below, then simplified as shown in algebraic steps:\\n```\\n\\t(m+k-1)(m+k)/2 - (m-1)m/2\\n\\t((m+k-1)(m+k) - (m-1)m) / 2\\n\\t((m^2 + mk + mk + k^2 - m - k) - (m^2 - m)) / 2\\n\\t(m^2 + mk + mk + k^2 - m - k - m^2 + m) / 2\\n\\t(m^2 - m^2 + 2mk + k^2 - m + m - k) / 2\\n\\t(2mk + k^2 -k) / 2\\n\\tk(2m + k - 1) / 2\\n```\\nThe final algebraic expression is used in the code below to quickly return the sum of `m`...`m+k-1`.\\n\\n**--- Fastest code (1ms in August 2023) ---**\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int maxNum = 0;\\n        for (int n : nums)  if (n > maxNum)  maxNum = n;\\n        return k * (2 * maxNum + k - 1) / 2;\\n    }\\n}\\n```\\n**--- Shortest code (5ms in August 2023) ---**\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        return k * (2 * Arrays.stream(nums).max().getAsInt() + k - 1) / 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t(m+k-1)(m+k)/2 - (m-1)m/2\\n\\t((m+k-1)(m+k) - (m-1)m) / 2\\n\\t((m^2 + mk + mk + k^2 - m - k) - (m^2 - m)) / 2\\n\\t(m^2 + mk + mk + k^2 - m - k - m^2 + m) / 2\\n\\t(m^2 - m^2 + 2mk + k^2 - m + m - k) / 2\\n\\t(2mk + k^2 -k) / 2\\n\\tk(2m + k - 1) / 2\\n```\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int maxNum = 0;\\n        for (int n : nums)  if (n > maxNum)  maxNum = n;\\n        return k * (2 * maxNum + k - 1) / 2;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        return k * (2 * Arrays.stream(nums).max().getAsInt() + k - 1) / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501634,
                "title": "easy-java-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int sum = 0;\\n        Arrays.sort(nums); \\n        int curr = nums[nums.length-1];\\n        for(int i=curr; i<curr+k; i++) {\\n            sum+=i;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int sum = 0;\\n        Arrays.sort(nums); \\n        int curr = nums[nums.length-1];\\n        for(int i=curr; i<curr+k; i++) {\\n            sum+=i;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492139,
                "title": "simple-java-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int sum = 0;\\n        int count = 0;\\n        Arrays.sort(nums);\\n        while(count < k) {\\n            sum += nums[nums.length - 1];\\n            nums[nums.length - 1] = 1 + nums[nums.length - 1];\\n            count++;\\n            \\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int sum = 0;\\n        int count = 0;\\n        Arrays.sort(nums);\\n        while(count < k) {\\n            sum += nums[nums.length - 1];\\n            nums[nums.length - 1] = 1 + nums[nums.length - 1];\\n            count++;\\n            \\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467762,
                "title": "i-kotlin-java-plain-math-formula-explanation-one-liners",
                "content": "# Math Approach\\nThe approach consists of several steps.\\n## 1. Find the Best m at the First Step.\\nLet\\'s show that the best \\'m\\' to choose is a max value from `nums`.\\n\\nLet\\'s assume the final result is:\\n\\n$$r = m_1 + m_2 + ... + m_k $$\\n\\nwhere $m_i$ is the $m$ selected at the $i$-th step. If we choose a value $$ l $$ such that $l < m_0$, then the total sum will be lesser:\\n\\n$$l + m_1 + ... + m_k  < m_0 + m_1 + ... + m_k $$\\n\\n## 2. Find the Best m at Following Steps.\\n\\nNow let\\'s show that $m_i = m_{i-1}+1$ is the best value to choose during the next steps.\\n\\nAs it was said, the best value to choose is the maximum from the `nums`. Let\\'s assume that there is a value $l_i$, and $l_i > m_i$, which is same as:\\n\\n$ l_i > m_{i-1} + 1$\\n\\nOn the other hand, we know that $ m_{i-1} \\\\ge l_j $ for $1 \\\\le j < k$, and that brings us to:\\n\\n$ l_i > m_{i-1} + 1 >  m_{i-1} \\\\ge l_j $\\n\\nIn a short form that led us to a contradiction:\\n\\n$ l_i > l_j $, for $1 \\\\le j \\\\lt k$.\\n\\nThat means there is no such number $l_i$ that is bigger than $m_{i-1}+1$.\\n\\n## 3. Calculate the Score\\n\\nAs it has been given in the description, the score is the sum of all $m_i$, and $1 \\\\le i \\\\le k$.\\n\\n$r = m_1 + m_2 + m_3 + ... + m_k $\\n\\nDo the replacement $m_i = m_{i-1}+1$:\\n\\n$r = m_1 + (m_1 + 1) + (m_2 + 1)+...+ (m_{k-1} + 1) $\\n\\nContinue, until we get $m_1$ only:\\n\\n$r = m_1 + (m_1 + 1) + (m_1 + 2)+...+ (m_1 + k - 1) $\\n\\nSo we can group all $m_1$ to a multiplication:\\n\\n$r = k m_1 + 1 + 2 + 3 + ... + k - 1 $\\n\\nAnd now we have a sum of an arithmetic progression from $1$ to $k - 1$:\\n\\n$r = k m_1 + \\\\frac{k(k - 1)}{2} $\\n\\nThat\\'s it.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n  Looking for a max value of the `nums` has a linear complexity.\\n\\n- Space complexity: $$O(1)$$\\n  The space amount doesn\\'t depend on input data size, so we get a constant complexity.\\n\\n# Kotlin Code\\n```\\nclass Solution {\\n    fun maximizeSum(nums: IntArray, k: Int) = \\n        k * (nums.max() ?: 0) + k * (k - 1) / 2\\n}\\n```\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        return Arrays.stream(nums).max().getAsInt() * k + k * (k - 1) / 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Kotlin",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    fun maximizeSum(nums: IntArray, k: Int) = \\n        k * (nums.max() ?: 0) + k * (k - 1) / 2\\n}\\n```\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        return Arrays.stream(nums).max().getAsInt() * k + k * (k - 1) / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467383,
                "title": "python3-one-line",
                "content": "Since we are being asked to find the maximum score, we have to work with the **max(nums**), increasing this number by one every iteration. Thus, the maximum result will be obtained by multiplying k by the max(nums) and the sum of increments k times.\\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        return max(nums) * k + sum(range(1, k))\\n```\\nsum(range(1, k)) can be calculated by the formula:\\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        return max(nums) * k + k * (k - 1) // 2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        return max(nums) * k + sum(range(1, k))\\n```\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        return max(nums) * k + k * (k - 1) // 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467229,
                "title": "very-easy-solution",
                "content": "class Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n       PriorityQueue<Integer> pq= new PriorityQueue<>(Collections.reverseOrder()) ;\\n       for (int i:nums){\\n           pq. add(i);\\n       }\\n        int sum=0;\\n        for(int I=0;I<k;I++) {\\n             int res=pq.poll() ;\\n            sum+= res ;\\n        pq. add(res+1) ;  \\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "class Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n       PriorityQueue<Integer> pq= new PriorityQueue<>(Collections.reverseOrder()) ;\\n       for (int i:nums){\\n           pq. add(i);\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 3467223,
                "title": "very-easy-solution",
                "content": "class Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int []C=new int[A.length];\\n        int count=0;\\n        HashSet<Integer> hs=new HashSet<>();\\n        for(int i=0;i<A.length;i++){\\n           hs.add(A[i]);\\n        for(int j=0;j<=i;j++){\\n            if(hs.contains(B[j])){\\n                count++;\\n            }\\n        }\\n            C[i]=count;\\n            count=0;\\n        }\\n        return C;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "class Solution {\\n    public int[] findThePrefixCommonArray(int[] A, int[] B) {\\n        int []C=new int[A.length];\\n        int count=0;\\n        HashSet<Integer> hs=new HashSet<>();\\n        for(int i=0;i<A.length;i++){\\n           hs.add(A[i]);\\n        for(int j=0;j<=i;j++){\\n            if(hs.contains(B[j])){\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3467136,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int mx = 0;\\n        for(auto x: nums) mx = max(mx, x);\\n        int ans = 0;\\n        while(k--) {\\n            ans += mx;\\n            mx++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int mx = 0;\\n        for(auto x: nums) mx = max(mx, x);\\n        int ans = 0;\\n        while(k--) {\\n            ans += mx;\\n            mx++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466903,
                "title": "simple-max-heap-solution",
                "content": "# Approach\\nUsing maxheap to get the maximum element till k becomes 0.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        priority_queue<int> pq(nums.begin(),nums.end());\\n        int ans = 0;\\n        while(k--)\\n        {\\n            int t = pq.top();\\n            ans += t;\\n            pq.pop();\\n            pq.push(t+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        priority_queue<int> pq(nums.begin(),nums.end());\\n        int ans = 0;\\n        while(k--)\\n        {\\n            int t = pq.top();\\n            ans += t;\\n            pq.pop();\\n            pq.push(t+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466835,
                "title": "find-max-formula-c-time-o-n-space-o-1",
                "content": "````\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int x = 0;\\n        for(auto &i: nums){\\n            x = max(x,i);\\n        }\\n        return x*k+(k*(k-1))/2;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int x = 0;\\n        for(auto &i: nums){\\n            x = max(x,i);\\n        }\\n        return x*k+(k*(k-1))/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466728,
                "title": "max-heap-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        priority_queue<int> pq(nums.begin(), nums.end());\\n        int ans = 0;\\n        while(k--) {\\n            int a = pq.top(); pq.pop();\\n            ans += a;\\n            pq.push(a + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        priority_queue<int> pq(nums.begin(), nums.end());\\n        int ans = 0;\\n        while(k--) {\\n            int a = pq.top(); pq.pop();\\n            ans += a;\\n            pq.push(a + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466690,
                "title": "c-2-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int mx=*max_element(nums.begin(),nums.end());   \\n        return ((mx+k-1)*(mx+k))/2 - ((mx-1)*(mx))/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int mx=*max_element(nums.begin(),nums.end());   \\n        return ((mx+k-1)*(mx+k))/2 - ((mx-1)*(mx))/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466644,
                "title": "c-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        \\n        int n = nums[nums.size()-1];\\n        int ans = nums[nums.size()-1];\\n        for(int i = 1; i<k; i++){\\n            n+=1;\\n            ans+=n;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        \\n        int n = nums[nums.size()-1];\\n        int ans = nums[nums.size()-1];\\n        for(int i = 1; i<k; i++){\\n            n+=1;\\n            ans+=n;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090512,
                "title": "beginner-friendly-simple-solution-in-python-typescript",
                "content": "# Intuition\\nThe task description is the following:\\n- there\\'s a list of `nums` and integer `k`\\n- our goal is find **the maximum sum** after `k`- increment operations\\n\\n```\\n# Example\\nnums = [4,5,6]\\nk = 3\\n\\n# To maximize the sum we need to increment\\n# at each step the maximum num in nums\\nsum = 0 + 6++\\nk = 2\\n\\nsum = 6 + 7++\\nk = 1\\n\\nsum = 13 + 8++ \\nk = 0\\n```\\n\\nThis\\'s where the **Greedy approach** comes from!\\n\\n# Approach\\n1. define the `max` integer from `nums`\\n2. declare an `ans` with `0`\\n3. iterate until `k > 0`\\n4. decrement `k` and increment `ans` with `max++`\\n5. return `ans`\\n\\n# Complexity\\n- Time complexity: **O(n+k)**, to find `max` and iterate over `k`\\n\\n- Space complexity: **O(1)**, we don\\'t allocate extra space.\\n\\n# Code in TypeScript\\n```\\nfunction maximizeSum(nums: number[], k: number): number {\\n    let max = Math.max(...nums);\\n    let ans = 0;\\n\\n    while (k) {\\n        k--;\\n        ans += max++;\\n    }\\n\\n    return ans;\\n};\\n```\\n# Code in Python3\\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        maximum = max(nums)\\n        ans = 0\\n\\n        while k:\\n            ans += maximum\\n            maximum += 1\\n            k -= 1\\n\\n        return ans\\n\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "TypeScript",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\n# Example\\nnums = [4,5,6]\\nk = 3\\n\\n# To maximize the sum we need to increment\\n# at each step the maximum num in nums\\nsum = 0 + 6++\\nk = 2\\n\\nsum = 6 + 7++\\nk = 1\\n\\nsum = 13 + 8++ \\nk = 0\\n```\n```\\nfunction maximizeSum(nums: number[], k: number): number {\\n    let max = Math.max(...nums);\\n    let ans = 0;\\n\\n    while (k) {\\n        k--;\\n        ans += max++;\\n    }\\n\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        maximum = max(nums)\\n        ans = 0\\n\\n        while k:\\n            ans += maximum\\n            maximum += 1\\n            k -= 1\\n\\n        return ans\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083089,
                "title": "java-2-solutions-heap-without-heap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max = 0;\\n        for(int p : nums){\\n            max = Math.max(p, max);\\n        }\\n        int res = max;\\n        while(k-->1){\\n            res += ++max;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        // PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> {\\n        //     return b - a;\\n        // });\\n        // for(int p : nums){\\n        //     pq.offer(p);\\n        // }\\n        // int count = 0;\\n        // while(k --> 0){\\n        //     int ele = pq.poll();\\n        //     count += ele;\\n        //     pq.offer(ele + 1);\\n        // }\\n        // return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max = 0;\\n        for(int p : nums){\\n            max = Math.max(p, max);\\n        }\\n        int res = max;\\n        while(k-->1){\\n            res += ++max;\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        // PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> {\\n        //     return b - a;\\n        // });\\n        // for(int p : nums){\\n        //     pq.offer(p);\\n        // }\\n        // int count = 0;\\n        // while(k --> 0){\\n        //     int ele = pq.poll();\\n        //     count += ele;\\n        //     pq.offer(ele + 1);\\n        // }\\n        // return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828019,
                "title": "beats-100-solution-beginner-friendly-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize a variable \\'max\\' to store the maximum element in the array \\'nums\\'. This can be done with a single pass through the array, resulting in O(n) time complexity.\\n2. Set \\'num\\' to the value of \\'max\\' and \\'sum\\' to \\'num\\'. The \\'num\\' variable will keep track of the current element we are considering, and \\'sum\\' will store the cumulative sum of the \\'num\\' values.\\n3. Use a loop that runs \\'k\\' times (from 1 to k-1) to simulate the process of increasing \\'num\\' by 1 in each iteration and adding it to \\'sum\\'.\\n4. Inside the loop, increment \\'num\\' by 1 and update \\'sum\\' by adding the new value of \\'num\\' to it.\\n5. Finally, return the \\'sum\\', which represents the maximum possible sum obtained by increasing the \\'num\\' value \\'k\\' times.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n        }\\n        int num = max;\\n        int sum=num;\\n        for(int i=1; i<k; i++){\\n            num = num +1;\\n            sum = sum + num;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i]>max){\\n                max = nums[i];\\n            }\\n        }\\n        int num = max;\\n        int sum=num;\\n        for(int i=1; i<k; i++){\\n            num = num +1;\\n            sum = sum + num;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795478,
                "title": "java-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to find the max element and perform the given operations on it only\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst we found out the max element with the help of for loop then we applied the logic to return the desired value.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int maximizeSum(int[] nums, int k) \\n    {  int max=nums[0];\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]>max)\\n            {\\n                max=nums[i];\\n            }\\n        }\\n            return max*k+(k*(k-1))/2;\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int maximizeSum(int[] nums, int k) \\n    {  int max=nums[0];\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]>max)\\n            {\\n                max=nums[i];\\n            }\\n        }\\n            return max*k+(k*(k-1))/2;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795466,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to find the max element and perform the given operations on it only\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst the array is sorted so now we know that the last element of the array is the max one so we\\'ll perform all the operations on the last element of the array.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int maximizeSum(int[] nums, int k) \\n    {\\n     int score=0;\\n       int max=0;\\n        Arrays.sort(nums);\\n           for(int i=0;i<k;i++)\\n           {  \\n             score+=nums[nums.length-1];\\n              nums[nums.length-1]+=1;\\n              \\n           }\\n        return score;\\n    }\\n}\\n  \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int maximizeSum(int[] nums, int k) \\n    {\\n     int score=0;\\n       int max=0;\\n        Arrays.sort(nums);\\n           for(int i=0;i<k;i++)\\n           {  \\n             score+=nums[nums.length-1];\\n              nums[nums.length-1]+=1;\\n              \\n           }\\n        return score;\\n    }\\n}\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795465,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to find the max element and perform the given operations on it only\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst the array is sorted so now we know that the last element of the array is the max one so we\\'ll perform all the operations on the last element of the array.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int maximizeSum(int[] nums, int k) \\n    {\\n     int score=0;\\n       int max=0;\\n        Arrays.sort(nums);\\n           for(int i=0;i<k;i++)\\n           {  \\n             score+=nums[nums.length-1];\\n              nums[nums.length-1]+=1;\\n              \\n           }\\n        return score;\\n    }\\n}\\n  \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int maximizeSum(int[] nums, int k) \\n    {\\n     int score=0;\\n       int max=0;\\n        Arrays.sort(nums);\\n           for(int i=0;i<k;i++)\\n           {  \\n             score+=nums[nums.length-1];\\n              nums[nums.length-1]+=1;\\n              \\n           }\\n        return score;\\n    }\\n}\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751890,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust find maximum num and sum it with incrsase the value.\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max=Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n        max=Math.max(max,nums[i]);\\n        }\\n        int sum=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            sum=sum+max;\\n            max=max+1;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max=Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n        max=Math.max(max,nums[i]);\\n        }\\n        int sum=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            sum=sum+max;\\n            max=max+1;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715297,
                "title": "a-solution-you-like",
                "content": "# Intuition\\nwe have to calculate the 1st k integer. Can we easily get access the max value? then with max value just add int k. You will get your range. now just add all the number between max of the array and max+k.You will get your desire answer.\\n\\n# Approach\\n1. Declair max and update it.\\n2. add k and max.\\n3. now run a loop from max to max+k and add all the number. \\n4. return your answer and chill.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n      int n = nums.length;\\n        //Update the max\\n      int max = Integer.MIN_VALUE;\\n        for(int i=0; i<n; i++){\\n            if(max < nums[i])     max = nums[i];\\n        }\\n        //add max and k to get the next disting no.\\n      int num2 = (max+k);   \\n        //sum up all the numbers.\\n      int sum = 0; \\n        for(int i=max; i<num2; i++){\\n            sum += i;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n      int n = nums.length;\\n        //Update the max\\n      int max = Integer.MIN_VALUE;\\n        for(int i=0; i<n; i++){\\n            if(max < nums[i])     max = nums[i];\\n        }\\n        //add max and k to get the next disting no.\\n      int num2 = (max+k);   \\n        //sum up all the numbers.\\n      int sum = 0; \\n        for(int i=max; i<num2; i++){\\n            sum += i;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712162,
                "title": "simple-easy-to-understand-solution-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        \\n        Arrays.sort(nums);\\n        \\n        return (k*nums[nums.length-1]+((k*(k-1))/2));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        \\n        Arrays.sort(nums);\\n        \\n        return (k*nums[nums.length-1]+((k*(k-1))/2));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707516,
                "title": "easy-one-liner-c-java-python-code-o-n-time-o-1-space-with-approach",
                "content": "# Approach\\n\\n- As we need to find max_element+(max_element+1)+(max_element+2)+....+(max_element+k-1) = max_element*k + k(k-1)/2 \\n\\n- The given code defines a class Solution with a member function maximizeSum. This function takes a vector nums of integers and an integer k as parameters and returns an integer.\\n\\n- The maximizeSum function computes the maximum possible sum of nums by performing the following steps:\\n\\n- *max_element(nums.begin(), nums.end()): This part finds the maximum element in the nums vector using the max_element function from the C++ Standard Library. The max_element function returns an iterator pointing to the maximum element in the range specified by nums.begin() and nums.end(). The * operator dereferences the iterator to obtain the actual value of the maximum element.\\n\\n- *max_element(nums.begin(), nums.end()) * k: This multiplies the maximum element by k.\\n\\n- k * (k - 1) / 2: This calculates the sum of integers from 1 to k-1 using the formula (k * (k - 1)) / 2.\\n\\n- Finally, the two results obtained in steps 2 and 3 are added together to get the maximum possible sum.\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n---\\n\\n# Code\\n```java []\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        return Arrays.stream(nums).max().getAsInt() * k + k * (k - 1) / 2;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def maximizeSum(self, nums, k):\\n        return max(nums) * k + k * (k - 1) // 2\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        return *max_element(nums.begin(), nums.end())*k+k*(k-1)/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```java []\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        return Arrays.stream(nums).max().getAsInt() * k + k * (k - 1) / 2;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def maximizeSum(self, nums, k):\\n        return max(nums) * k + k * (k - 1) // 2\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        return *max_element(nums.begin(), nums.end())*k+k*(k-1)/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690011,
                "title": "simple-cpp-two-lines-code-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe are given an array and integer value k which denotes the number of operations to perform. In each operation we have to pick an element say m and remove it from array and insert m+1 into array.Increase your score by m.our goal is to return the maximum score you can achieve after performing the operation exactly k times.\\n\\n---\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInorder to achieve maximum score we have to choose the ```maximum```value in every operation and replace the maximum value with ```maximum+1``` in the array.In every iteration the following operations undergoes\\n```\\nscore= maximum+(maximum+1)+.....+(maximum+k-1)\\nscore= maximum*k+(1+2+..(k-1))\\nscore= maximum*k+(k*(k-1)/2)\\n```\\n---\\n\\n\\n# Complexity\\n- Time complexity: **$$O(n)$$**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**$$O(1)$$**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int maxi = *max_element(nums.begin(), nums.end() ) ;\\n        return maxi*k + ((k - 1) * k/2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```maximum```\n```maximum+1```\n```\\nscore= maximum+(maximum+1)+.....+(maximum+k-1)\\nscore= maximum*k+(1+2+..(k-1))\\nscore= maximum*k+(k*(k-1)/2)\\n```\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int maxi = *max_element(nums.begin(), nums.end() ) ;\\n        return maxi*k + ((k - 1) * k/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622102,
                "title": "c-very-simple",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n// m is max element\\n// sum of: m, m + 1, m + 2, .... m + k-1\\n// => sum = (m * k) + 1 + 2 + .... k-1\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int m = *max_element(nums.begin(), nums.end());    \\n        return m*k + k*(k - 1)/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// m is max element\\n// sum of: m, m + 1, m + 2, .... m + k-1\\n// => sum = (m * k) + 1 + 2 + .... k-1\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int m = *max_element(nums.begin(), nums.end());    \\n        return m*k + k*(k - 1)/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598941,
                "title": "beats-98-65-with-just-2-lines-of-code-step-by-step-explanation",
                "content": "![Screenshot (19).png](https://assets.leetcode.com/users/images/a9af8941-e4e0-48a3-a1f0-39d303cb6539_1685936382.6902094.png)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires finding the maximum possible sum by performing a specific operation on the given array of numbers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. let max = Math.max(...nums); - This line finds the maximum number in the nums array using the Math.max function and the spread operator (...). It spreads the array elements as individual arguments to the Math.max function, which returns the maximum value.\\n\\n2. return ((max + k) * (max + k - 1)/2) - (max * (max - 1) / 2 ); - This line performs the calculation to maximize the sum. It calculates the sum of consecutive numbers from 1 to the new maximum number (max + k) and subtracts the sum of consecutive numbers from 1 to the original maximum number (max).\\n\\n   * (max + k) * (max + k - 1)/2 calculates the sum of consecutive numbers from 1 to max + k. This is done using the formula for the sum of an arithmetic series.\\n\\n   * (max * (max - 1) / 2) calculates the sum of consecutive numbers from 1 to max.\\n\\n   * By subtracting the sum of the original range from the sum of the new range, the code obtains the difference between the two ranges, which represents the maximum possible increase in the sum.\\n\\n# Complexity\\n- Time complexity: O(n) - The code has a linear time complexity as it iterates through the array to find the maximum number.\\n- Space complexity: O(1) - The code has a constant space complexity as it does not use additional space that grows with the input size; it only utilizes a few scalar variables.\\n\\n# Code\\n```\\nfunction maximizeSum(nums: number[], k: number): number {\\n    let max = Math.max(...nums);\\n    return ((max + k) * (max + k - 1)/2) - (max * (max - 1) / 2 )\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nfunction maximizeSum(nums: number[], k: number): number {\\n    let max = Math.max(...nums);\\n    return ((max + k) * (max + k - 1)/2) - (max * (max - 1) / 2 )\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3581729,
                "title": "c-o-n",
                "content": "# Intuition\\nWe can get answer simply by adding k consecutive integers greater than eqaul to greatest element in the array\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        \\n        int Max = 0;\\n        \\n        for(auto num: nums){                    //finding max element\\n            Max=max(Max,num);\\n        }\\n        \\n        int ans=0;                              //variable to store answer\\n        \\n        while(k){\\n            ans+=Max+--k;                       //adding max and the consecutive numbers to ans\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        \\n        int Max = 0;\\n        \\n        for(auto num: nums){                    //finding max element\\n            Max=max(Max,num);\\n        }\\n        \\n        int ans=0;                              //variable to store answer\\n        \\n        while(k){\\n            ans+=Max+--k;                       //adding max and the consecutive numbers to ans\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547044,
                "title": "easy-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    sort the array \\n    then maxm number will be at last \\n    sum it and update its value to +1;\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int sum=0;\\n        for(int i=0;i<k;i++){\\n            sum+=nums[nums.length-1];\\n            nums[nums.length-1]++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int sum=0;\\n        for(int i=0;i<k;i++){\\n            sum+=nums[nums.length-1];\\n            nums[nums.length-1]++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496809,
                "title": "java-beat-95-with-linear-runtime-complexity-and-constant-memory-complexity",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max = 1;\\n        for (int num : nums) {\\n            if (num > max) {\\n                max = num;\\n            }\\n        }\\n        return max * k  + k * (k - 1) / 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max = 1;\\n        for (int num : nums) {\\n            if (num > max) {\\n                max = num;\\n            }\\n        }\\n        return max * k  + k * (k - 1) / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492160,
                "title": "simple-java-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            max = Math.max(max, nums[i]);\\n        }\\n        \\n        int sum = 0;\\n        for(int i = 0; i < k; i++) {\\n            sum += max;\\n            max++;\\n        }\\n        return sum;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            max = Math.max(max, nums[i]);\\n        }\\n        \\n        int sum = 0;\\n        for(int i = 0; i < k; i++) {\\n            sum += max;\\n            max++;\\n        }\\n        return sum;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490642,
                "title": "beast-97-simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n     int max=nums[0];\\n    int sum=0;\\n    for(int i=0;i<nums.length;i++)\\n    {\\n        if(nums[i]>max)max=nums[i];\\n    }\\n    for(int i=1;i<=k;i++)\\n    {\\n        sum+=max;\\n        max=(max+1);\\n        \\n    }\\n    return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n     int max=nums[0];\\n    int sum=0;\\n    for(int i=0;i<nums.length;i++)\\n    {\\n        if(nums[i]>max)max=nums[i];\\n    }\\n    for(int i=1;i<=k;i++)\\n    {\\n        sum+=max;\\n        max=(max+1);\\n        \\n    }\\n    return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483514,
                "title": "simple-easy",
                "content": "# Approach\\nDo not have to remove or insert the element back again. Since the subsequent max elements after finding the first max will always be prev max plus one.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunction maximizeSum(nums: number[], k: number): number {\\n  let max = Math.max(...nums);\\n  let maxSum = 0;\\n\\n  for (let i = 0; i < k; i += 1) {\\n    maxSum += max;\\n    max += 1;\\n  }\\n\\n  return maxSum\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction maximizeSum(nums: number[], k: number): number {\\n  let max = Math.max(...nums);\\n  let maxSum = 0;\\n\\n  for (let i = 0; i < k; i += 1) {\\n    maxSum += max;\\n    max += 1;\\n  }\\n\\n  return maxSum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3479257,
                "title": "python-best-solution-100-faster-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\uD83D\\uDD25Python \\u2705\\u2705 Best Solution ( \\uD83D\\uDD25 100% faster \\uD83D\\uDD25) Easy to Understand\\uD83D\\uDCAF\\uD83D\\uDCAF \\u2B06\\u2B06\\u2B06\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maximizeSum(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        n=len(nums)-1\\n        maxx=nums[n]\\n        ans=0\\n        second=maxx\\n        while(k):\\n            ans+=second\\n            second=second+1\\n            k=k-1\\n\\n        return ans\\n            \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximizeSum(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        n=len(nums)-1\\n        maxx=nums[n]\\n        ans=0\\n        second=maxx\\n        while(k):\\n            ans+=second\\n            second=second+1\\n            k=k-1\\n\\n        return ans\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478698,
                "title": "c-linq-one-line",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int MaximizeSum(int[] nums, int k) \\n        => Enumerable.Range(nums.Max(), k).Sum();\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximizeSum(int[] nums, int k) \\n        => Enumerable.Range(nums.Max(), k).Sum();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476840,
                "title": "javascript-o-n-time-o-1-space-math",
                "content": "# Approach\\nTo get maximum sum, we are clearly interested in adding to the maximum element in `nums`.\\n\\nHaving that, result would be the sum of numbers in the range $$[max, max + k)$$.\\n\\n**Note, `)` denotes an exclusive range, `]` inclusive.*\\n\\nThis can be computed in $$O(1)$$ with a tiny bit of math.\\n\\nSum of numbers in range $$[max, max + k)$$ equals to the sum of numbers in the range $$[1, max + k)$$ minus sum of numbers in range $$[1, max)$$.\\n\\nBoth of these can be computed by the formula: Sum of $$[1, n]$$ quals $$n * (n + 1) / 2$$ \\n\\n```\\nfunction maximizeSum(nums, k) {\\n    const max = Math.max(...nums);\\n\\n    const sum1 = max * (max - 1) / 2;\\n    const sum2 = (max + k) * (max + k - 1) / 2;\\n\\n    return sum2 - sum1;\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nfunction maximizeSum(nums, k) {\\n    const max = Math.max(...nums);\\n\\n    const sum1 = max * (max - 1) / 2;\\n    const sum2 = (max + k) * (max + k - 1) / 2;\\n\\n    return sum2 - sum1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3474973,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the maximum element in the array.And adding to a variable by adding 1 for each iteration;\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int m=0,max=0;\\n        for(int i=0;i<nums.length;i++)\\n            if (nums[i]>=max)\\n                max=nums[i];\\n        for(int i=0;i<k;i++){\\n            m+=max;\\n            max+=1;\\n        }\\n        return m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int m=0,max=0;\\n        for(int i=0;i<nums.length;i++)\\n            if (nums[i]>=max)\\n                max=nums[i];\\n        for(int i=0;i<k;i++){\\n            m+=max;\\n            max+=1;\\n        }\\n        return m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471196,
                "title": "rust-python-2-lines-o-n-with-math",
                "content": "# Intuition\\nWe only need to find maximum of elements in a vector. One we got it, we just constantly increase it k time. So if the maximum is $m$, then the result is:\\n\\n$R = m + (m + 1) + ... (m + k - 1)$\\n\\nUsing math, we get $R = m \\\\cdot k + (0 + 1 + ... + k - 1) = mk + k(k - 1) / 2$\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(1)$\\n\\n# Code\\n```Rust []\\nimpl Solution {\\n  pub fn maximize_sum(nums: Vec<i32>, k: i32) -> i32 {\\n    let m = *nums.iter().max().unwrap();\\n    return m * k + k * (k - 1) / 2;\\n  }\\n}\\n```\\n```python []\\nclass Solution:\\n  def maximizeSum(self, nums: List[int], k: int) -> int:\\n    return max(nums) * k + k * (k - 1) // 2\\n```\\n",
                "solutionTags": [
                    "Rust",
                    "Math"
                ],
                "code": "```Rust []\\nimpl Solution {\\n  pub fn maximize_sum(nums: Vec<i32>, k: i32) -> i32 {\\n    let m = *nums.iter().max().unwrap();\\n    return m * k + k * (k - 1) / 2;\\n  }\\n}\\n```\n```python []\\nclass Solution:\\n  def maximizeSum(self, nums: List[int], k: int) -> int:\\n    return max(nums) * k + k * (k - 1) // 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470617,
                "title": "easy-c-solution-100-fast",
                "content": "## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int maxi= *max_element(nums.begin(),nums.end());\\n        int ans= k*maxi;\\n        k--;\\n        ans+= (k*(k+1))/2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Design",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int maxi= *max_element(nums.begin(),nums.end());\\n        int ans= k*maxi;\\n        k--;\\n        ans+= (k*(k+1))/2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469706,
                "title": "python-elegant-short-1-line-math-arithmetic-progression",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        return k * max(nums) + k * (k - 1) // 2\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        return k * max(nums) + k * (k - 1) // 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469410,
                "title": "maximum-sum-with-exactly-k-elements-c-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        int n=nums.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            pq.push(nums[i]);\\n        }\\n        while(k--)\\n        {\\n            int x=pq.top();\\n            ans+=x;\\n            pq.pop();\\n            pq.push(x+1);\\n            \\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        int n=nums.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            pq.push(nums[i]);\\n        }\\n        while(k--)\\n        {\\n            int x=pq.top();\\n            ans+=x;\\n            pq.pop();\\n            pq.push(x+1);\\n            \\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468899,
                "title": "very-easy-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int ans=0;\\n        for(int i=0;i<k;i++){\\n            int num=nums[nums.length-1];\\n            ans+=num;\\n            nums[nums.length-1]=num+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int ans=0;\\n        for(int i=0;i<k;i++){\\n            int num=nums[nums.length-1];\\n            ans+=num;\\n            nums[nums.length-1]=num+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468469,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        return ((*max_element(nums.begin(), nums.end()))*k)+((k*(k-1))/2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        return ((*max_element(nums.begin(), nums.end()))*k)+((k*(k-1))/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467977,
                "title": "simple-arithmetic-sum-in-rust-full-explanation-one-line-no-additional-var-created",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks for a simple sum of an arithmetic series. No actual vector manipulation needed as only the largest object matters. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing nums.iter().max().unwrap() the largest value in nums is found.\\nIter() iterates over the vector, max() finds the largest value and unwrap() is needed to get rid of optional type.\\nIn fact there is no need for the input to be a vector as no changes are made to it. \\n\\nThe rest is the formula for an arithmetic sum: $(2a+(n-1)*d)*\\\\frac{n}{2}$ where:\\n$a = nums.iter().max().unwrap()$\\n$n = k$\\n$d = 1$\\nAs $d = 1$ it can be removed from the expression giving $(2a+n-1)*\\\\frac{n}{2}$\\nAs such the final formula is $(2*nums.iter().max().unwrap()+k-1)*\\\\frac{k}{2}$\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn maximize_sum(nums: Vec<i32>, k: i32) -> i32 {\\n    (2*nums.iter().max().unwrap()+k-1)*k/2\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Math"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn maximize_sum(nums: Vec<i32>, k: i32) -> i32 {\\n    (2*nums.iter().max().unwrap()+k-1)*k/2\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467679,
                "title": "c-solution-using-priority-queue",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n       O(N logN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->      \\n       O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int m=nums.size();\\n        priority_queue<int>pq;\\n        int sum=0;\\n        \\n        for(int i=0; i<m; i++)\\n        {\\n            pq.push(nums[i]);\\n            \\n        }\\n        int r=0;\\n        while(r<k)\\n        {\\n            sum+=pq.top();\\n            int u=pq.top();\\n            pq.push(u+1);\\n            r++;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int m=nums.size();\\n        priority_queue<int>pq;\\n        int sum=0;\\n        \\n        for(int i=0; i<m; i++)\\n        {\\n            pq.push(nums[i]);\\n            \\n        }\\n        int r=0;\\n        while(r<k)\\n        {\\n            sum+=pq.top();\\n            int u=pq.top();\\n            pq.push(u+1);\\n            r++;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467585,
                "title": "very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n       Arrays.sort(nums);\\n        int sum = 0;\\n        int count =0;\\n        int temp = 0;\\n        while(count < k){\\n            sum = sum + nums[nums.length-1];\\n            temp = nums[nums.length-1]+1;\\n            nums[nums.length-1] = temp;\\n            count++;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n**Kindly upvote if you like the solution**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n       Arrays.sort(nums);\\n        int sum = 0;\\n        int count =0;\\n        int temp = 0;\\n        while(count < k){\\n            sum = sum + nums[nums.length-1];\\n            temp = nums[nums.length-1]+1;\\n            nums[nums.length-1] = temp;\\n            count++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467516,
                "title": "easy-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int ans=0;\\n        for(int i=0;i<k;i++){\\n            int num=nums[nums.length-1];\\n            ans=ans+num;\\n            nums[nums.length-1]=num+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int ans=0;\\n        for(int i=0;i<k;i++){\\n            int num=nums[nums.length-1];\\n            ans=ans+num;\\n            nums[nums.length-1]=num+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467314,
                "title": "very-simple-and-easy-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maximizeSum(vector<int>& nums, int k) \\n\\t\\t{\\n\\t\\t\\tint score = 0;\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\t\\t\\tint n = nums.size()-1;\\n\\n\\t\\t\\twhile(k--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint temp = nums[n];\\n\\t\\t\\t\\tscore += temp;\\n\\t\\t\\t\\tnums[n] = temp+1;\\n\\t\\t\\t}\\n\\t\\t\\treturn score;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maximizeSum(vector<int>& nums, int k) \\n\\t\\t{\\n\\t\\t\\tint score = 0;\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\t\\t\\tint n = nums.size()-1;\\n\\n\\t\\t\\twhile(k--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint temp = nums[n];\\n\\t\\t\\t\\tscore += temp;\\n\\t\\t\\t\\tnums[n] = temp+1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3467235,
                "title": "with-o-n-2-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfind the max\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-its all about finding the max element from the array\\n-finding the max and getting out the output with formula\\n-k* maxs + k*(k-1)/2;\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) \\n    {\\n        int maxs=*nums(first_index, last_index);\\n        int z=k*(k-1)/2;\\n        return k*maxs+z;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) \\n    {\\n        int maxs=*nums(first_index, last_index);\\n        int z=k*(k-1)/2;\\n        return k*maxs+z;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467119,
                "title": "c-3-simple-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int sum=0;\\n        \\n        //Time Complexity O(N)  [Priority Queue]\\n        priority_queue<int, vector<int>,greater<int>>PQ;\\n        for(int it:nums){\\n            PQ.push(it);\\n            if(PQ.size()>1)PQ.pop();\\n        }\\n        int temp = PQ.top();\\n        while(k--){\\n            sum+=temp;\\n            temp++;\\n        }\\n\\n        // Time Complexity: O(N)  [Noobra Approach]\\n        int maxi = 1;\\n        for(int it:nums)maxi=max(maxi,it);\\n        int temp = maxi;\\n        while(k--){\\n            sum+=temp;\\n            temp++;\\n        }\\n         \\n        \\n        // Time Complexity: O(Nlog N)    [My Friend Approach]\\n        sort(nums.begin(),nums.end());\\n        int temp = nums[nums.size()-1];\\n        while(k--){\\n            sum+=temp;\\n            temp++;\\n        }\\n\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int sum=0;\\n        \\n        //Time Complexity O(N)  [Priority Queue]\\n        priority_queue<int, vector<int>,greater<int>>PQ;\\n        for(int it:nums){\\n            PQ.push(it);\\n            if(PQ.size()>1)PQ.pop();\\n        }\\n        int temp = PQ.top();\\n        while(k--){\\n            sum+=temp;\\n            temp++;\\n        }\\n\\n        // Time Complexity: O(N)  [Noobra Approach]\\n        int maxi = 1;\\n        for(int it:nums)maxi=max(maxi,it);\\n        int temp = maxi;\\n        while(k--){\\n            sum+=temp;\\n            temp++;\\n        }\\n         \\n        \\n        // Time Complexity: O(Nlog N)    [My Friend Approach]\\n        sort(nums.begin(),nums.end());\\n        int temp = nums[nums.size()-1];\\n        while(k--){\\n            sum+=temp;\\n            temp++;\\n        }\\n\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467096,
                "title": "simple-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int ans=0;\\n        while(k>0) {\\n            sort(nums.begin(), nums.end());\\n            ans+= nums[nums.size()-1];\\n            nums[nums.size()-1]= nums[nums.size()-1]+1;\\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int ans=0;\\n        while(k>0) {\\n            sort(nums.begin(), nums.end());\\n            ans+= nums[nums.size()-1];\\n            nums[nums.size()-1]= nums[nums.size()-1]+1;\\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467028,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximizeSum(int[] nums, int k) {\\n        int max = nums.Max();\\n        int c = max;\\n        for(int i=1; i<k; i++)\\n        {\\n            max += 1;\\n            c += max;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximizeSum(int[] nums, int k) {\\n        int max = nums.Max();\\n        int c = max;\\n        for(int i=1; i<k; i++)\\n        {\\n            max += 1;\\n            c += max;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466901,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        \\n        int n = nums[nums.length - 1];\\n        int ans = nums[nums.length - 1];\\n        for(int i = 1; i < k; i++) {\\n            n += 1;\\n            ans += n;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        \\n        int n = nums[nums.length - 1];\\n        int ans = nums[nums.length - 1];\\n        for(int i = 1; i < k; i++) {\\n            n += 1;\\n            ans += n;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466876,
                "title": "java-contest-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int max = nums[nums.length-1];\\n        int[] ans = new int[k];\\n        for(int i=0;i<k;i++){\\n            ans[i]=max+i;\\n        }\\n        int a =0;\\n        for(int j=0;j<k;j++){\\n            a+=ans[j];\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int max = nums[nums.length-1];\\n        int[] ans = new int[k];\\n        for(int i=0;i<k;i++){\\n            ans[i]=max+i;\\n        }\\n        int a =0;\\n        for(int j=0;j<k;j++){\\n            a+=ans[j];\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466855,
                "title": "4-line-solution-simple-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int p =0;\\n        while(k>0){\\n            int z = nums[nums.size()-1];\\n          p += nums[nums.size()-1];\\n            nums[nums.size()-1] = z+1;\\n            k--;\\n        }\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int p =0;\\n        while(k>0){\\n            int z = nums[nums.size()-1];\\n          p += nums[nums.size()-1];\\n            nums[nums.size()-1] = z+1;\\n            k--;\\n        }\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466821,
                "title": "c-simple-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust have a look at testcases. We can deduce that all we need to do is finding max element. After that we can just loop for k and increase these element and add to answer.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nYou can directly get the max element using vector stl. You can also use `max()` function, but I choose using ternanry operator. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int max = -1;\\n        \\n        for (auto it : nums) {\\n            max = it > max ? it : max;\\n        }\\n        \\n        int ans = 0;\\n        \\n        for (int i=0;i<k;i++) {\\n            ans += max;\\n            max += 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int max = -1;\\n        \\n        for (auto it : nums) {\\n            max = it > max ? it : max;\\n        }\\n        \\n        int ans = 0;\\n        \\n        for (int i=0;i<k;i++) {\\n            ans += max;\\n            max += 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466813,
                "title": "simplest-java-solution-constant-time",
                "content": "# Intuition\\nSimplest solution applying formula with constant time complexity\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int sum=0;\\n        int n= nums.length;\\n        sum =nums[n-1]*k+(k*(k+1))/2-k;\\n        return sum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int sum=0;\\n        int n= nums.length;\\n        sum =nums[n-1]*k+(k*(k+1))/2-k;\\n        return sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466790,
                "title": "simple-dart-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n  int maximizeSum(List<int> nums, int k) {\\n    nums.sort();\\n    int largestEl = nums.last;\\n    int sum = largestEl;\\n    for (int i = 1; i < k; i++) {\\n      largestEl++;\\n      sum += largestEl;\\n    }\\n    return sum;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int maximizeSum(List<int> nums, int k) {\\n    nums.sort();\\n    int largestEl = nums.last;\\n    int sum = largestEl;\\n    for (int i = 1; i < k; i++) {\\n      largestEl++;\\n      sum += largestEl;\\n    }\\n    return sum;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466746,
                "title": "approach-explained-priority-queue-easy-c",
                "content": "# Intuition\\n\\n\\n# Approach\\ntake and add top element of priority queue and push top element+1 k times \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int sum=0;\\n        priority_queue<int>  q;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            q.push(nums[i]);\\n        }\\n        while(k--)\\n        {\\n            int a=q.top();\\n            q.pop();\\n            sum+=a;\\n            q.push(a+1);\\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int sum=0;\\n        priority_queue<int>  q;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            q.push(nums[i]);\\n        }\\n        while(k--)\\n        {\\n            int a=q.top();\\n            q.pop();\\n            sum+=a;\\n            q.push(a+1);\\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466671,
                "title": "very-easy-java-solution-o-n-beats-100",
                "content": "# Intuition\\njust do what is said in the question.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max=0;\\n        for(int i:nums)max=Math.max(i,max);\\n        // int ts=max+k;\\n        // ts=(ts*(ts+1))/2;\\n        // max=max-1;\\n        // max=(max*(max+1))/2;\\n        // return ts-max;\\n        int ans=0;\\n        for(int i=0;i<k;i++)ans+=max+i;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max=0;\\n        for(int i:nums)max=Math.max(i,max);\\n        // int ts=max+k;\\n        // ts=(ts*(ts+1))/2;\\n        // max=max-1;\\n        // max=(max*(max+1))/2;\\n        // return ts-max;\\n        int ans=0;\\n        for(int i=0;i<k;i++)ans+=max+i;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466661,
                "title": "easiest-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n    \\n    sort(nums.begin(), nums.end(), greater<int>());\\n    int score = 0;\\n    for(int i=0; i<k; i++) {\\n        int m = nums[0];\\n        nums.erase(nums.begin());\\n        nums.push_back(m+1);\\n        score += m;\\n        sort(nums.begin(), nums.end(), greater<int>());\\n    }\\n    return score;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n    \\n    sort(nums.begin(), nums.end(), greater<int>());\\n    int score = 0;\\n    for(int i=0; i<k; i++) {\\n        int m = nums[0];\\n        nums.erase(nums.begin());\\n        nums.push_back(m+1);\\n        score += m;\\n        sort(nums.begin(), nums.end(), greater<int>());\\n    }\\n    return score;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466657,
                "title": "python-1-line",
                "content": "```python\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        return ((max(nums) + max(nums)+k-1)*k) // 2\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        return ((max(nums) + max(nums)+k-1)*k) // 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4102934,
                "title": "c-fast-and-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int sum = 0;\\n        for(int i=0;i<k;i++){\\n            sum+= nums[nums.size()-1];\\n            nums[nums.size()-1]+=1;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int sum = 0;\\n        for(int i=0;i<k;i++){\\n            sum+= nums[nums.size()-1];\\n            nums[nums.size()-1]+=1;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098041,
                "title": "golang-solution",
                "content": "\\n# Code\\n```\\nfunc maximizeSum(nums []int, k int) int {\\n    max, score := 0, 0\\n\\n\\tfor _, n := range nums {\\n\\t\\tif n > max {\\n\\t\\t\\tmax = n\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tscore += max\\n\\t\\tmax += 1\\n\\t}\\n\\n\\treturn score\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maximizeSum(nums []int, k int) int {\\n    max, score := 0, 0\\n\\n\\tfor _, n := range nums {\\n\\t\\tif n > max {\\n\\t\\t\\tmax = n\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tscore += max\\n\\t\\tmax += 1\\n\\t}\\n\\n\\treturn score\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097058,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint maximizeSum(int* nums, int numsSize, int k){\\n\\tint a;\\n\\tint bul;\\n\\tint last;\\n\\n\\tbul = 0;\\n\\tfor (a = 0; a < numsSize; a++)\\n\\t{\\n\\t\\tif (bul < nums[a])\\n\\t\\t{\\n\\t\\t\\tbul = nums[a];\\n\\t\\t}\\n\\t}\\n\\ta = 0;\\n\\tlast = 0;\\n\\twhile (a < k)\\n\\t{\\n\\t\\t\\n\\t\\tlast += bul + a;\\n\\t\\ta++;\\n\\t}\\n\\treturn (last);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maximizeSum(int* nums, int numsSize, int k){\\n\\tint a;\\n\\tint bul;\\n\\tint last;\\n\\n\\tbul = 0;\\n\\tfor (a = 0; a < numsSize; a++)\\n\\t{\\n\\t\\tif (bul < nums[a])\\n\\t\\t{\\n\\t\\t\\tbul = nums[a];\\n\\t\\t}\\n\\t}\\n\\ta = 0;\\n\\tlast = 0;\\n\\twhile (a < k)\\n\\t{\\n\\t\\t\\n\\t\\tlast += bul + a;\\n\\t\\ta++;\\n\\t}\\n\\treturn (last);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4095110,
                "title": "python3-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(k * log(N))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        ans = 0\\n        while k > 0:\\n            a = nums.pop()\\n            b = a + 1\\n            nums.append(b)\\n            ans += a\\n            k -= 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        ans = 0\\n        while k > 0:\\n            a = nums.pop()\\n            b = a + 1\\n            nums.append(b)\\n            ans += a\\n            k -= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092076,
                "title": "easy-java-code",
                "content": "class Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int result=0;\\n        int max=0;\\n        int sum=0;\\n        for(int i = 0; i<nums.length;i++){\\n               max = Math.max(max,nums[i]);\\n        }\\n        for(int j=1;j<k;j++){\\n            sum+= ++max;\\n          }   \\n            result = sum+max-(k-1);\\n       \\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int result=0;\\n        int max=0;\\n        int sum=0;\\n        for(int i = 0; i<nums.length;i++){\\n               max = Math.max(max,nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4091751,
                "title": "one-liner-o-1-code-in-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        return (max(nums)*k) + ((k-1)*k)//2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        return (max(nums)*k) + ((k-1)*k)//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090653,
                "title": "python-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        largest = 0\\n        total = 0 \\n\\n        for i in nums:\\n            if i > largest:\\n                largest = i\\n\\n        while k > 0:\\n            total += largest \\n            largest += 1\\n            k -= 1\\n\\n        return total\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        largest = 0\\n        total = 0 \\n\\n        for i in nums:\\n            if i > largest:\\n                largest = i\\n\\n        while k > 0:\\n            total += largest \\n            largest += 1\\n            k -= 1\\n\\n        return total\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086259,
                "title": "java-easy-4-line-code-beats-100",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max=0;\\n        for(int i=0;i<nums.length;i++)\\n            max = Math.max(nums[i],max);\\n        return k*max + (k-1)*(k)/2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max=0;\\n        for(int i=0;i<nums.length;i++)\\n            max = Math.max(nums[i],max);\\n        return k*max + (k-1)*(k)/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085364,
                "title": "simple-code-in-gooooo",
                "content": "\\n\\n# Code\\n```\\nfunc maximizeSum(nums []int, k int) int {\\n\\n    m := nums[0]\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tif m < nums[i] {\\n\\t\\t\\tm = nums[i]\\n\\t\\t}\\n\\t}\\n\\n\\tsum := k*m + (k-1)*k/2\\n\\n\\treturn sum\\n\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maximizeSum(nums []int, k int) int {\\n\\n    m := nums[0]\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tif m < nums[i] {\\n\\t\\t\\tm = nums[i]\\n\\t\\t}\\n\\t}\\n\\n\\tsum := k*m + (k-1)*k/2\\n\\n\\treturn sum\\n\\n    \\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4083668,
                "title": "simple-solution-using-python",
                "content": "I approacched this prlbem using example cases\\n\\n# Code\\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        result = []\\n        nums = sorted(nums)\\n        result.append(max(nums))\\n        for i in range(k-1):\\n            result.append(result[i]+1)\\n        return sum(result)\\n\\n     \\n\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        result = []\\n        nums = sorted(nums)\\n        result.append(max(nums))\\n        for i in range(k-1):\\n            result.append(result[i]+1)\\n        return sum(result)\\n\\n     \\n\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073499,
                "title": "easy-peasy-lemon-squeezy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        add = 0\\n        for i in range(k):\\n            add += max(nums)\\n            nums[nums.index(max(nums))] = max(nums)+1\\n        return add\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        add = 0\\n        for i in range(k):\\n            add += max(nums)\\n            nums[nums.index(max(nums))] = max(nums)+1\\n        return add\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071967,
                "title": "java-simple-solution-using-arraylist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        ArrayList<Integer> l1=new ArrayList<Integer>();\\n        for(int i=0;i<nums.length;i++){\\n            l1.add(nums[i]);\\n        }\\n        int val2=Collections.max(l1);\\n        int ans=0;\\n        for(int i=0;i<k;i++){\\n            ans=ans+val2;\\n            val2++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        ArrayList<Integer> l1=new ArrayList<Integer>();\\n        for(int i=0;i<nums.length;i++){\\n            l1.add(nums[i]);\\n        }\\n        int val2=Collections.max(l1);\\n        int ans=0;\\n        for(int i=0;i<k;i++){\\n            ans=ans+val2;\\n            val2++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069565,
                "title": "python-logic-simple-with-explanation",
                "content": "# Code\\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        #we will always apply the operation on the largest element\\n        p=max(nums)\\n        #we apply that operation k times\\n        ans=0\\n        for i in range(k):\\n            ans+=(p+(1*i))\\n        return ans\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        #we will always apply the operation on the largest element\\n        p=max(nums)\\n        #we apply that operation k times\\n        ans=0\\n        for i in range(k):\\n            ans+=(p+(1*i))\\n        return ans\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069127,
                "title": "php",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @param Integer $k\\n     * @return Integer\\n     */\\n    function maximizeSum($nums, $k) {\\n        $max=max($nums);\\n        $sum=$max;\\n        for($i=1;$i<$k;$i++){\\n            $max++;\\n            $sum+=$max;\\n        }\\n        return $sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @param Integer $k\\n     * @return Integer\\n     */\\n    function maximizeSum($nums, $k) {\\n        $max=max($nums);\\n        $sum=$max;\\n        for($i=1;$i<$k;$i++){\\n            $max++;\\n            $sum+=$max;\\n        }\\n        return $sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066415,
                "title": "easy-java-and-python",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int result = 0; \\n        int max = nums[0];\\n\\n        for (int num : nums) {\\n            max = Math.max(max, num);\\n        }\\n\\n        for (int i = 0; i < k; i++) {\\n            result += max + i;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n# Python\\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        result = 0\\n        max_value = max(nums)\\n\\n        for i in range(k):\\n            result += max_value + i\\n\\n        return result\\n        \\n```",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int result = 0; \\n        int max = nums[0];\\n\\n        for (int num : nums) {\\n            max = Math.max(max, num);\\n        }\\n\\n        for (int i = 0; i < k; i++) {\\n            result += max + i;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        result = 0\\n        max_value = max(nums)\\n\\n        for i in range(k):\\n            result += max_value + i\\n\\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065414,
                "title": "easy-solution-o-n-o-1",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int sum = 0;\\n        int max = 0;\\n        for (int i = 0; i <= nums.size() - 1; i++) {\\n            if (nums[i] > max) max = nums[i];\\n        }\\n        sum = max;\\n        for (int i = 0 ; i <= k - 2; i++) {\\n            max += 1;\\n            sum += max;\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int sum = 0;\\n        int max = 0;\\n        for (int i = 0; i <= nums.size() - 1; i++) {\\n            if (nums[i] > max) max = nums[i];\\n        }\\n        sum = max;\\n        for (int i = 0 ; i <= k - 2; i++) {\\n            max += 1;\\n            sum += max;\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065010,
                "title": "c-fast-solution-93-23-runtime-96-24-memory-o-n",
                "content": "# Intuition\\nJust sort the array and add.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximizeSum(int[] nums, int k) {\\n        Array.Sort(nums);\\n            int sum = 0;\\n\\n            for(int i = 0; i<k; i++)\\n            {\\n                sum += nums[nums.Length - 1];\\n                nums[nums.Length - 1] += 1;\\n            }\\n\\n            return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximizeSum(int[] nums, int k) {\\n        Array.Sort(nums);\\n            int sum = 0;\\n\\n            for(int i = 0; i<k; i++)\\n            {\\n                sum += nums[nums.Length - 1];\\n                nums[nums.Length - 1] += 1;\\n            }\\n\\n            return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063703,
                "title": "2656-maximum-sum-with-exactly-k-elements",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int sum = 0;\\n        Arrays.sort(nums);\\n        for(int i=0;i<k;i++){\\n            sum += nums[nums.length-1];\\n            nums[nums.length-1]++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int sum = 0;\\n        Arrays.sort(nums);\\n        for(int i=0;i<k;i++){\\n            sum += nums[nums.length-1];\\n            nums[nums.length-1]++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062961,
                "title": "easy-understandable-java-soln-beats-100-tc-and-92-sc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfind max and add it for k times and also keep adding +1 to the max value\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*log(k)), O(n*log(N)), O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N), O(K), O(1)\\nThese are some solutions that striked my mind, and then just keep optimizing\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int n = nums.length;\\n\\n        /*  M1:\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i=0;i<n;i++) {\\n            maxHeap.add(nums[i]);\\n        }\\n        int sum = 0;\\n        for(int i=0;i<k;i++) {\\n            sum += maxHeap.peek();\\n            maxHeap.add(maxHeap.poll()+1);\\n        }\\n        */\\n\\n        /*  M2:\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        for(int i=0;i<n;i++) {\\n            minHeap.add(nums[i]);\\n            if(minHeap.size() > 1) minHeap.poll();\\n        }\\n        int sum = 0;\\n        for(int i=0;i<k;i++) {\\n            sum += minHeap.peek();\\n            minHeap.add(minHeap.poll()+1);\\n        }\\n        */\\n\\n        // Arrays.sort(nums);\\n        int max = 0;\\n        for(int i=0;i<n;i++) {\\n            max = Math.max(max, nums[i]);\\n        }\\n        /*\\n        int val = max;\\n        int sum = 0;\\n        for(int i=0;i<k;i++) {\\n            sum += val;\\n            val += 1;\\n        }\\n        return sum;\\n        */\\n\\n        return max*k + k*(k-1)/2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int n = nums.length;\\n\\n        /*  M1:\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i=0;i<n;i++) {\\n            maxHeap.add(nums[i]);\\n        }\\n        int sum = 0;\\n        for(int i=0;i<k;i++) {\\n            sum += maxHeap.peek();\\n            maxHeap.add(maxHeap.poll()+1);\\n        }\\n        */\\n\\n        /*  M2:\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        for(int i=0;i<n;i++) {\\n            minHeap.add(nums[i]);\\n            if(minHeap.size() > 1) minHeap.poll();\\n        }\\n        int sum = 0;\\n        for(int i=0;i<k;i++) {\\n            sum += minHeap.peek();\\n            minHeap.add(minHeap.poll()+1);\\n        }\\n        */\\n\\n        // Arrays.sort(nums);\\n        int max = 0;\\n        for(int i=0;i<n;i++) {\\n            max = Math.max(max, nums[i]);\\n        }\\n        /*\\n        int val = max;\\n        int sum = 0;\\n        for(int i=0;i<k;i++) {\\n            sum += val;\\n            val += 1;\\n        }\\n        return sum;\\n        */\\n\\n        return max*k + k*(k-1)/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059430,
                "title": "java-o-n-using-sum-of-first-n-natural-numbers-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int n = k-1;\\n        int max = nums[0];\\n        for(int i=0; i<nums.length; i++) {\\n            if (nums[i] > max) max = nums[i];\\n        }\\n        return max*k + ((n*(n+1))/2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int n = k-1;\\n        int max = nums[0];\\n        for(int i=0; i<nums.length; i++) {\\n            if (nums[i] > max) max = nums[i];\\n        }\\n        return max*k + ((n*(n+1))/2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059077,
                "title": "easiest-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N+K)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        \\n        int sum=0;\\n        sort(nums.begin(),nums.end());\\n        int val=nums[nums.size()- 1];\\n        while(k--)\\n        {\\n            sum=sum+val;\\n            val++;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        \\n        int sum=0;\\n        sort(nums.begin(),nums.end());\\n        int val=nums[nums.size()- 1];\\n        while(k--)\\n        {\\n            sum=sum+val;\\n            val++;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055235,
                "title": "easy-and-100-optimized-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max= 0;\\n        for(int i = 0 ; i<nums.length ; i++){\\n            max = Math.max(max , nums[i]);\\n          }\\n         \\n        return (k*max) + (k*(k-1))/2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max= 0;\\n        for(int i = 0 ; i<nums.length ; i++){\\n            max = Math.max(max , nums[i]);\\n          }\\n         \\n        return (k*max) + (k*(k-1))/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055184,
                "title": "2-ms-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int sum = 0;\\n        int max = 0;\\n        for(int i=0;i<nums.length; i++){\\n            if(max<nums[i]){\\n                max = nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<k;i++){\\n            sum += max;\\n            max++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int sum = 0;\\n        int max = 0;\\n        for(int i=0;i<nums.length; i++){\\n            if(max<nums[i]){\\n                max = nums[i];\\n            }\\n        }\\n\\n        for(int i=0;i<k;i++){\\n            sum += max;\\n            max++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053812,
                "title": "easy-solution-using-priority-queue-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Priority Queue\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        \\n        for(int i =0;i<nums.size();i++){\\n            pq.push(nums[i]);\\n        }\\n\\nint sum =0;\\n        for(int i =0;i<k;i++){\\n            int val = pq.top();\\n            pq.pop();\\n            pq.push(val+1);\\nsum+=val;\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        \\n        for(int i =0;i<nums.size();i++){\\n            pq.push(nums[i]);\\n        }\\n\\nint sum =0;\\n        for(int i =0;i<k;i++){\\n            int val = pq.top();\\n            pq.pop();\\n            pq.push(val+1);\\nsum+=val;\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053694,
                "title": "1-line-code-beats-100-of-users",
                "content": "# Intuition \\nthis is the question of mathematics(arithmatic progression) rather than computer science.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\nreturn nums[nums.length-1]*k+ k*(k-1)/2;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\nreturn nums[nums.length-1]*k+ k*(k-1)/2;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051004,
                "title": "typescript-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction maximizeSum(nums: number[], k: number): number {\\n  let maxi = Math.max(...nums);\\n  let ans:number=0;\\n  while(k>0){\\n      maxi++;\\n      ans += maxi-1;\\n      k--;\\n  }\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction maximizeSum(nums: number[], k: number): number {\\n  let maxi = Math.max(...nums);\\n  let ans:number=0;\\n  while(k>0){\\n      maxi++;\\n      ans += maxi-1;\\n      k--;\\n  }\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050262,
                "title": "easypizzy-solution-javascript",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maximizeSum = function(nums, k) {\\n    nums.sort((a,b)=>a-b);\\n\\n    let score = 0;\\n    for(let i=0; i<k; i++)\\n    {\\n        let m = nums[nums.length -1];\\n        score += m ;\\n        nums.pop(m);\\n        nums.push(m+1)\\n\\n    }\\n\\n    return score;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maximizeSum = function(nums, k) {\\n    nums.sort((a,b)=>a-b);\\n\\n    let score = 0;\\n    for(let i=0; i<k; i++)\\n    {\\n        let m = nums[nums.length -1];\\n        score += m ;\\n        nums.pop(m);\\n        nums.push(m+1)\\n\\n    }\\n\\n    return score;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050041,
                "title": "python3-simple-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        cur = max(nums)\\n        for i in range(k):\\n            ans += cur\\n            cur+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        cur = max(nums)\\n        for i in range(k):\\n            ans += cur\\n            cur+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049718,
                "title": "my-python-solution-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        k1=max(nums)\\n        k1*=k\\n        for i in range(1,k):\\n            k1+=i\\n        return k1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        k1=max(nums)\\n        k1*=k\\n        for i in range(1,k):\\n            k1+=i\\n        return k1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049713,
                "title": "my-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        honey=0\\n        for i in range(k):\\n            k1=max(nums)\\n            nums.remove(k1)\\n            nums.append(k1+1)\\n            honey+=k1\\n        return honey\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        honey=0\\n        for i in range(k):\\n            k1=max(nums)\\n            nums.remove(k1)\\n            nums.append(k1+1)\\n            honey+=k1\\n        return honey\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046297,
                "title": "easy-solution-in-python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        ans=0\\n        for i in range(k):\\n            ans=ans+nums[-1]\\n            nums[-1]=nums[-1]+1\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        ans=0\\n        for i in range(k):\\n            ans=ans+nums[-1]\\n            nums[-1]=nums[-1]+1\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043887,
                "title": "swift",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func maximizeSum(_ nums: [Int], _ k: Int) -> Int {\\n    var initialVal = nums.max()!\\n    var result = 0\\n    \\n    for i in 0..<k {\\n        \\n        result += initialVal + i\\n        \\n    }\\n    \\n    return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maximizeSum(_ nums: [Int], _ k: Int) -> Int {\\n    var initialVal = nums.max()!\\n    var result = 0\\n    \\n    for i in 0..<k {\\n        \\n        result += initialVal + i\\n        \\n    }\\n    \\n    return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041775,
                "title": "python-one-line-solution-beats-100-using-the-sum-forumla-of-an-arthmetic-sequence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMr Miftah\\nWe are using the sum forumla of an arthmetic sequence\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use Mr Miftah lesson better learn your maths\\nU(n+1)=Un+1 where U0=max(nums) also, Un=Uo+n*r but r=1 so Un=Uo+n\\n\\nn=k-1 \\nTherefore:\\nSn=(k/2)*(2*max(nums)+(k-1))\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        return int((k/2)*(2*max(nums)+(k-1)))\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        return int((k/2)*(2*max(nums)+(k-1)))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041123,
                "title": "java-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max=nums[0];\\n        for(int i=0;i<nums.length;i++){\\n            max = Math.max(nums[i],max);\\n        }\\n        System.out.print(max);\\n        int sum=0;\\n        for(int i=1;i<=k;i++){\\n            sum+=max++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max=nums[0];\\n        for(int i=0;i<nums.length;i++){\\n            max = Math.max(nums[i],max);\\n        }\\n        System.out.print(max);\\n        int sum=0;\\n        for(int i=1;i<=k;i++){\\n            sum+=max++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039937,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) \\n    {\\n        int maxValue=nums[0];\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            maxValue=Math.max(maxValue,nums[i]);\\n        }\\n        int sum=maxValue;\\n        while(k>1)\\n        {\\n            sum+=++maxValue;\\n            k--;\\n        }\\n        return sum;       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) \\n    {\\n        int maxValue=nums[0];\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            maxValue=Math.max(maxValue,nums[i]);\\n        }\\n        int sum=maxValue;\\n        while(k>1)\\n        {\\n            sum+=++maxValue;\\n            k--;\\n        }\\n        return sum;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035181,
                "title": "easy-to-understand-with-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int maximizeSum(int[] nums, int k) {\\n\\t\\tint maxNumber = returnMax(nums);\\n\\t\\tint sum = 0;\\n\\t\\tfor (int i = 0; i < k; i++) {\\n\\t\\t\\tsum = sum + (maxNumber+i);\\n\\t\\t}\\n        return sum;\\n    }\\n\\t\\n\\t//find max from array\\n\\tpublic static int returnMax(int[] arr) {\\n\\t\\tint max = Integer.MIN_VALUE;\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tif(max<arr[i]) {\\n\\t\\t\\t\\tmax = arr[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int maximizeSum(int[] nums, int k) {\\n\\t\\tint maxNumber = returnMax(nums);\\n\\t\\tint sum = 0;\\n\\t\\tfor (int i = 0; i < k; i++) {\\n\\t\\t\\tsum = sum + (maxNumber+i);\\n\\t\\t}\\n        return sum;\\n    }\\n\\t\\n\\t//find max from array\\n\\tpublic static int returnMax(int[] arr) {\\n\\t\\tint max = Integer.MIN_VALUE;\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tif(max<arr[i]) {\\n\\t\\t\\t\\tmax = arr[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032454,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nfunc maximizeSum(_ nums: [Int], _ k: Int) -> Int {\\n    var max = nums.max()!\\n    var sum = max\\n    \\n    for i in 1..<k {\\n        sum += max + i\\n    }\\n    \\n    return sum\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\nfunc maximizeSum(_ nums: [Int], _ k: Int) -> Int {\\n    var max = nums.max()!\\n    var sum = max\\n    \\n    for i in 1..<k {\\n        sum += max + i\\n    }\\n    \\n    return sum\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031941,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end()); \\n        int sum=nums[n-1];\\n        for(int i=1;i<k;i++)\\n        {\\n            sum=sum+nums[n-1]+i;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end()); \\n        int sum=nums[n-1];\\n        for(int i=1;i<k;i++)\\n        {\\n            sum=sum+nums[n-1]+i;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030852,
                "title": "easy-solution-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int sum=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            sum+=nums[nums.length-1];\\n            nums[nums.length-1]+=1;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int sum=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            sum+=nums[nums.length-1];\\n            nums[nums.length-1]+=1;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028451,
                "title": "easy-c-solution-understandable",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int change=nums.back();\\n        int final=0;\\n        for(int i=1;i<=k;i++){\\n             final+=change;\\n             change+=1;\\n        }\\n        return final;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int change=nums.back();\\n        int final=0;\\n        for(int i=1;i<=k;i++){\\n             final+=change;\\n             change+=1;\\n        }\\n        return final;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025628,
                "title": "simple-cpp-solution-that-beats-100-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int max = INT_MIN;\\n        for(int i:nums)\\n        {\\n            if(i>max)\\n                max = i;\\n        }\\n        int ans = 0;\\n        while(k--)\\n        {\\n            ans+=max;\\n            max++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int max = INT_MIN;\\n        for(int i:nums)\\n        {\\n            if(i>max)\\n                max = i;\\n        }\\n        int ans = 0;\\n        while(k--)\\n        {\\n            ans+=max;\\n            max++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025142,
                "title": "faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            max=Math.max(max,nums[i]);\\n        }\\n        int ans=max;\\n        int sum=ans;\\n        for(int i=1;i<k;i++){\\n            ans=ans+1;\\n            sum+=ans;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            max=Math.max(max,nums[i]);\\n        }\\n        int ans=max;\\n        int sum=ans;\\n        for(int i=1;i<k;i++){\\n            ans=ans+1;\\n            sum+=ans;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023657,
                "title": "easy-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maximizeSum = function(nums, k) {\\n    let max = Math.max(...nums)\\n    let sum = 0;\\n    for(let i=0; i<k; i++) {\\n        sum+=max+i\\n    }\\n    return sum\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maximizeSum = function(nums, k) {\\n    let max = Math.max(...nums)\\n    let sum = 0;\\n    for(let i=0; i<k; i++) {\\n        sum+=max+i\\n    }\\n    return sum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4022732,
                "title": "o-n-solution-c-proper-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind the max number from the array and then multiply it k times for k times summing the number and we have to add the number in incremented manner then for that calculate sum od n number that is  k-1 number.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfor Example : A = [1,2,3,4,5] and k = 3\\n  In this maxelement is 5  // So we have to add 5 , 6 , 7 to get 18.\\n  So, sum = 5*3 = 15 and sum of ( 1,2,3....k-1 ) i.e  Sum = Sum + (k-1)*(k-1+1)/2\\n\\nHere k=3 so Sum = 15 + (3-1)*(3-1+1)/2 = 15 + 3 = 18\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) for calculating the max element from the vector\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\nint l = *max_element(nums.begin(),nums.end());\\n        int sum=0;\\n         sum = l*k + ((k-1)*(k)/2);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\nint l = *max_element(nums.begin(),nums.end());\\n        int sum=0;\\n         sum = l*k + ((k-1)*(k)/2);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019037,
                "title": "easy-one-line-code-in-c-python3",
                "content": "# Approach\\nUsed the inbuilt function to find the maximum value in the array.\\nAnd used the sum of n natural number formual to get the required answers as the sequence is : \\n**max + max+1 + max+2 ... max+k-1** == **(k*(max+max-1+k))/2**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- C++     : 18 ms\\n- Python3 : 150 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- C++     : 70.8 MB\\n- Python3 : 16 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int x = *max_element(nums.begin(),nums.end());\\n        return (k*(x+k-1 + x))/2;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        return ((max(nums) + max(nums)-1+k)*k)//2\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int x = *max_element(nums.begin(),nums.end());\\n        return (k*(x+k-1 + x))/2;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        return ((max(nums) + max(nums)-1+k)*k)//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017886,
                "title": "by-using-brute-force-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max = nums[0];\\n        int n = nums.length;\\n        for(int i = 0; i < n; i++){\\n            if(max < nums[i]){\\n                max = nums[i];\\n            }\\n\\n        }\\n        int ans = max++;    \\n        for(int j = 0; j < k - 1; j++){\\n            ans += max++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max = nums[0];\\n        int n = nums.length;\\n        for(int i = 0; i < n; i++){\\n            if(max < nums[i]){\\n                max = nums[i];\\n            }\\n\\n        }\\n        int ans = max++;    \\n        for(int j = 0; j < k - 1; j++){\\n            ans += max++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011813,
                "title": "a-simple-python-test",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        tt=0\\n        for i in range(0,k):\\n            tt+=i\\n        res = max(nums)*k+tt\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        tt=0\\n        for i in range(0,k):\\n            tt+=i\\n        res = max(nums)*k+tt\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010909,
                "title": "harshi-s-simple-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& a, int k) {\\n        int max=*max_element(a.begin(), a.end());\\n        int i=0,an=0;\\n        while(k--){\\n            an=an+max+i;\\n            i++;\\n        }return an;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& a, int k) {\\n        int max=*max_element(a.begin(), a.end());\\n        int i=0,an=0;\\n        while(k--){\\n            an=an+max+i;\\n            i++;\\n        }return an;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010898,
                "title": "100-time-complexity-java-solution-simple-approach",
                "content": "# Intuition\\nFind the maximum value was clear from the program. \\nReplacing it with a value 1 greater than max was derived on reading the problem\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Find the maximum element in the array. \\n- Consider that element for the maximum sum. \\n- Replace that element with (maximum + 1).\\n- The new maximum will be maximum + 1. Consider this value for sum. \\n- Repeat the process K times.\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ where n is the number of elements\\n\\n- Space complexity:\\n Constant time complexity (2 variables used.)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max = 0; // Since constraints show the range is from 1\\n        int sum = 0;\\n        // Calculating the maximum number to be taken for sum.\\n        for(int i = 0; i< nums.length; i ++ ){\\n            max = Math.max(nums[i], max);\\n        }\\n        // Now when I replace the maximum number with m+1 the new maximum number will be m+1.\\n        // Consider m+1 for the next attempt.\\n        // do this K times.\\n        for(int i = 0; i<k; i++){\\n            sum += max; \\n            max++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max = 0; // Since constraints show the range is from 1\\n        int sum = 0;\\n        // Calculating the maximum number to be taken for sum.\\n        for(int i = 0; i< nums.length; i ++ ){\\n            max = Math.max(nums[i], max);\\n        }\\n        // Now when I replace the maximum number with m+1 the new maximum number will be m+1.\\n        // Consider m+1 for the next attempt.\\n        // do this K times.\\n        for(int i = 0; i<k; i++){\\n            sum += max; \\n            max++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009837,
                "title": "java-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max = nums[0];\\n\\n        for(int i=1; i<nums.length; i++){\\n            max = Math.max(max, nums[i]);\\n        }\\n        int m = max;\\n        for(int i=1; i<k; i++){\\n            max +=(m+i);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max = nums[0];\\n\\n        for(int i=1; i<nums.length; i++){\\n            max = Math.max(max, nums[i]);\\n        }\\n        int m = max;\\n        for(int i=1; i<k; i++){\\n            max +=(m+i);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006047,
                "title": "2-line-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int n = *max_element(nums.begin(),nums.end());\\n        return (n+k-1)*(n+k)/2 - (n-1)*n/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int n = *max_element(nums.begin(),nums.end());\\n        return (n+k-1)*(n+k)/2 - (n-1)*n/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996168,
                "title": "simple-and-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        List = []\\n        nums.sort()\\n        counter = 0\\n        while(counter < k):\\n            max_element = nums[-1]\\n            nums[-1] = max_element + 1\\n            counter = counter + 1\\n            List.append(max_element)\\n        return sum(List)\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        List = []\\n        nums.sort()\\n        counter = 0\\n        while(counter < k):\\n            max_element = nums[-1]\\n            nums[-1] = max_element + 1\\n            counter = counter + 1\\n            List.append(max_element)\\n        return sum(List)\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994627,
                "title": "c-easy-solution-beginner-freindly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int ans = 0;\\n        int large = nums[n-1];\\n        for(int i =0;i<k;i++)\\n        {\\n            ans += large;\\n            large++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int ans = 0;\\n        int large = nums[n-1];\\n        for(int i =0;i<k;i++)\\n        {\\n            ans += large;\\n            large++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992369,
                "title": "o-n-time-complexity-2-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will be taking the max element in each iteration and adding a new element of value \"max+1\" which inturn will be selected in the next turn and so on.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        m = max(nums)\\n\\n        return m*k+k*(k-1)//2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        m = max(nums)\\n\\n        return m*k+k*(k-1)//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991207,
                "title": "java-solution-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        // looks like AP with comman diffrence 1 :)\\n       int a = nums[nums.length-1];\\n       int last = a + (k-1);\\n       return (int) ((((double)a + last)/2) * k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        // looks like AP with comman diffrence 1 :)\\n       int a = nums[nums.length-1];\\n       int last = a + (k-1);\\n       return (int) ((((double)a + last)/2) * k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991157,
                "title": "python-very-easy-one-line-solution-beginner-friendly-with-explanation",
                "content": "# Approach\\nObviously, the first element from our sequence will be the maximum number in the list. It is also obvious that after we add the maximum number + 1 to the list, this number will become the maximum. Then, we can simply find the sum of numbers from the maximum to the maximum + k not inclusive, where each next element is 1 more than the previous one, that is, we can use a loop.\\n\\nUpvote my solution if you like it, thanks <3\\n# Code\\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        return sum([i for i in range(max(nums), max(nums) + k, 1)])\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        return sum([i for i in range(max(nums), max(nums) + k, 1)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988654,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the maximum of the array and just return the value you want using that max element\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max= Integer. MIN_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(max<nums[i]){\\n                max=nums[i];\\n            }\\n        }\\n        return max*k+ (k-1) * k/2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max= Integer. MIN_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(max<nums[i]){\\n                max=nums[i];\\n            }\\n        }\\n        return max*k+ (k-1) * k/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987704,
                "title": "very-simple-and-easy-approach-by-brute-force-apporach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- ***Brute_Force Approach***\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) \\n    {\\n        Arrays.sort(nums);\\n       int sum = 0; \\n       int temp = 0 ; \\n       temp += nums[(nums.length-1)] ;\\n       for(int i = 0 ;i < k ; i++)\\n       {\\n        sum += (temp+i);\\n       }\\n       return sum ; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) \\n    {\\n        Arrays.sort(nums);\\n       int sum = 0; \\n       int temp = 0 ; \\n       temp += nums[(nums.length-1)] ;\\n       for(int i = 0 ;i < k ; i++)\\n       {\\n        sum += (temp+i);\\n       }\\n       return sum ; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986657,
                "title": "going-into-the-math-explained-simply",
                "content": "# Breaking down the problem\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we are removing and replacing a value in the array each time to create a maximum score, notice that we will always take the maximum value in the array at each step. That is, after removing and replacing this value with itself plus one, it will remain the largest value in the array (leading to the largest score).\\n\\nTherefore, we can generalize the solution based on the maximum value $$(max)$$ in the array:\\n\\n$$ result = (max + 0) + (max + 1) + (max + 2) + ... (max + k), \\n                                                \\\\forall k > 2$$\\n\\n$$result = (k * max) + \\\\Sigma_{i=0}^{k-1}i,     \\\\forall k > 0$$\\n\\n$$result = (k * max) + (1/2)*((k-1)*k),         \\\\forall k > 0$$\\n\\n# Some divergent series properties for those interested\\nThe final step is based on a property of divergent series, which can be seen in more detail [in this wikipedia page on divergent sums here](https://en.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_%E2%8B%AF). Here is how I look at it:\\n\\n$$\\\\Sigma_{i=1}^{n} = 1 + 2 + 3 + ... (n - 3) + (n - 2) + (n - 1) + n$$\\n\\nRearranging the terms:\\n$$ = (1 + n - 1) + (2 + n - 2) + (3 + n - 3) + n + ...$$\\n$$ = n + n + n + n + ...$$\\n\\nNotice that every pair (except the final n term) cancels out. How many times? Well, $$n/2$$ times. So, our final equation is $$(n(n + 1))/2$$ and above, as $$n=k-1$$ we can substitute $$k-1$$ into the equation. Notice that the start at $$i=0$$ for our sum changes nothing since we are just adding 0.\\n\\n# Getting into code logistics\\n<!-- Describe your approach to solving the problem. -->\\nSo, we have calculated the equation to use for our result, so all we have to do is find the maximum element in the array and then plug in the numbers! To hit all of the specifications, we should also replace the value in the $$nums$$ array with $$max + k - 1$$ since we would be replacing it $$k-1$$ times.\\n\\nA good way of finding the maximum element in an array is using $$max_element$$ which returns an iterator to the largest element in the array, and is defined in the $$<algorithm>$$ header. Here is a link to the [documentation](https://en.cppreference.com/w/cpp/algorithm/max_element).\\n\\n\\n# Complexity\\n### Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ since $$max\\\\_element$$ has a time complexity of $$O(n)$$ and all other operations are constant time.\\n\\n### Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ Space does not increase with input size\\n\\n# Code\\n```\\n#include <algorithm>\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        std::vector<int>::iterator maxIter = std::max_element(nums.begin(), nums.end());\\n        int maximumValue = *maxIter;\\n        *maxIter = *maxIter + k - 1;\\n        return (maximumValue * k) + ((k-1)*k)/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\n#include <algorithm>\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        std::vector<int>::iterator maxIter = std::max_element(nums.begin(), nums.end());\\n        int maximumValue = *maxIter;\\n        *maxIter = *maxIter + k - 1;\\n        return (maximumValue * k) + ((k-1)*k)/2;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3984882,
                "title": "sort-and-easy-solution-in-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int sum=0;\\n        int len = nums.length;\\n        Arrays.sort(nums);\\n        for(int i=0;i<k;i++)\\n        {\\n            sum = sum + (nums[len-1]+i);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int sum=0;\\n        int len = nums.length;\\n        Arrays.sort(nums);\\n        for(int i=0;i<k;i++)\\n        {\\n            sum = sum + (nums[len-1]+i);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983901,
                "title": "python-fastest-solution",
                "content": "# Approach\\nTo maximise the score, The value we are withdrawing should be maximum. If first removal, we are adding m+1 so this will be the maimum for next iteration\\n\\nfor k iterations:\\n\\nScore : m + (m+1) + (m+2)......(m+k-1)\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        maxi=max(nums)\\n        return k*(2*maxi+(k-1))//2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximizeSum(self, nums: List[int], k: int) -> int:\\n        maxi=max(nums)\\n        return k*(2*maxi+(k-1))//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982073,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nit can be optimized to O(N)\\n\\n# Complexity\\n- Time complexity:O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        int val = nums[nums.size() - 1];\\n        for(int i = 0; i < k; i++){\\n            ans += val;\\n            val++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        int val = nums[nums.size() - 1];\\n        for(int i = 0; i < k; i++){\\n            ans += val;\\n            val++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978129,
                "title": "a-different-and-optimized-approach",
                "content": "# Intuition \\nFinding the maximum element and adding 1 to it repeatedly k times\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Find the maximum element in the array.\\n2. since we have to return the maximum score and add it k times by adding 1 in every iteration we can use the formulae :\\n(k*max) + ((k*(k-1))/2)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max = 0;\\n        for(int i : nums){\\n             max = Math.max(max,i);\\n        }\\n        return (k*max) + ((k*(k-1))/2) ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max = 0;\\n        for(int i : nums){\\n             max = Math.max(max,i);\\n        }\\n        return (k*max) + ((k*(k-1))/2) ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1934674,
                "content": [
                    {
                        "username": "SoNiceCoder",
                        "content": "Don\\'t spend much time on this question(very beginner friendly) , try to optimise complexity. Simple problem\\nThis formula might be used :\\n`0+1+2+3.....n times = n(n-1)/2`\\nIntentionally zero is there ! \\uD83D\\uDE0E"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Tip: $$ 1 + 2 + ... + n = \\\\frac{n (n-1)}{2} $$"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "what a example"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Do you know you could do better than $O(n+k)$ to solve this?\nIf you want a solution that explores several approaches from the easiest one to math solutions, have look [over there!](https://leetcode.com/problems/maximum-sum-with-exactly-k-elements/solutions/3467144/from-easiest-to-1-line-math-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int sum = nums[nums.size()-1]; //Select an element last from nums.\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int prev = sum;  \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 while(k >1){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 sum += (prev+1);  //Add a new element with a value of last + 1 to the array.\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 prev = prev+1; //Increase your score by last element.\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 k--;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return\\xA0sum;\\n    }\\n};\\n\\n//please upvote.. and thank you"
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "[@Vamsidhar Reddy M](/VamsidharReddyy) Please don\\'t post solutions in discuss, Instead post them in solutions."
                    }
                ]
            },
            {
                "id": 1879467,
                "content": [
                    {
                        "username": "SoNiceCoder",
                        "content": "Don\\'t spend much time on this question(very beginner friendly) , try to optimise complexity. Simple problem\\nThis formula might be used :\\n`0+1+2+3.....n times = n(n-1)/2`\\nIntentionally zero is there ! \\uD83D\\uDE0E"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Tip: $$ 1 + 2 + ... + n = \\\\frac{n (n-1)}{2} $$"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "what a example"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Do you know you could do better than $O(n+k)$ to solve this?\nIf you want a solution that explores several approaches from the easiest one to math solutions, have look [over there!](https://leetcode.com/problems/maximum-sum-with-exactly-k-elements/solutions/3467144/from-easiest-to-1-line-math-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int sum = nums[nums.size()-1]; //Select an element last from nums.\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int prev = sum;  \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 while(k >1){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 sum += (prev+1);  //Add a new element with a value of last + 1 to the array.\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 prev = prev+1; //Increase your score by last element.\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 k--;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return\\xA0sum;\\n    }\\n};\\n\\n//please upvote.. and thank you"
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "[@Vamsidhar Reddy M](/VamsidharReddyy) Please don\\'t post solutions in discuss, Instead post them in solutions."
                    }
                ]
            },
            {
                "id": 2074318,
                "content": [
                    {
                        "username": "SoNiceCoder",
                        "content": "Don\\'t spend much time on this question(very beginner friendly) , try to optimise complexity. Simple problem\\nThis formula might be used :\\n`0+1+2+3.....n times = n(n-1)/2`\\nIntentionally zero is there ! \\uD83D\\uDE0E"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Tip: $$ 1 + 2 + ... + n = \\\\frac{n (n-1)}{2} $$"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "what a example"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Do you know you could do better than $O(n+k)$ to solve this?\nIf you want a solution that explores several approaches from the easiest one to math solutions, have look [over there!](https://leetcode.com/problems/maximum-sum-with-exactly-k-elements/solutions/3467144/from-easiest-to-1-line-math-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int sum = nums[nums.size()-1]; //Select an element last from nums.\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int prev = sum;  \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 while(k >1){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 sum += (prev+1);  //Add a new element with a value of last + 1 to the array.\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 prev = prev+1; //Increase your score by last element.\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 k--;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return\\xA0sum;\\n    }\\n};\\n\\n//please upvote.. and thank you"
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "[@Vamsidhar Reddy M](/VamsidharReddyy) Please don\\'t post solutions in discuss, Instead post them in solutions."
                    }
                ]
            },
            {
                "id": 1877233,
                "content": [
                    {
                        "username": "SoNiceCoder",
                        "content": "Don\\'t spend much time on this question(very beginner friendly) , try to optimise complexity. Simple problem\\nThis formula might be used :\\n`0+1+2+3.....n times = n(n-1)/2`\\nIntentionally zero is there ! \\uD83D\\uDE0E"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Tip: $$ 1 + 2 + ... + n = \\\\frac{n (n-1)}{2} $$"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "what a example"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Do you know you could do better than $O(n+k)$ to solve this?\nIf you want a solution that explores several approaches from the easiest one to math solutions, have look [over there!](https://leetcode.com/problems/maximum-sum-with-exactly-k-elements/solutions/3467144/from-easiest-to-1-line-math-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int sum = nums[nums.size()-1]; //Select an element last from nums.\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int prev = sum;  \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 while(k >1){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 sum += (prev+1);  //Add a new element with a value of last + 1 to the array.\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 prev = prev+1; //Increase your score by last element.\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 k--;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return\\xA0sum;\\n    }\\n};\\n\\n//please upvote.. and thank you"
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "[@Vamsidhar Reddy M](/VamsidharReddyy) Please don\\'t post solutions in discuss, Instead post them in solutions."
                    }
                ]
            },
            {
                "id": 1877359,
                "content": [
                    {
                        "username": "SoNiceCoder",
                        "content": "Don\\'t spend much time on this question(very beginner friendly) , try to optimise complexity. Simple problem\\nThis formula might be used :\\n`0+1+2+3.....n times = n(n-1)/2`\\nIntentionally zero is there ! \\uD83D\\uDE0E"
                    },
                    {
                        "username": "trpaslik",
                        "content": "Tip: $$ 1 + 2 + ... + n = \\\\frac{n (n-1)}{2} $$"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "what a example"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Do you know you could do better than $O(n+k)$ to solve this?\nIf you want a solution that explores several approaches from the easiest one to math solutions, have look [over there!](https://leetcode.com/problems/maximum-sum-with-exactly-k-elements/solutions/3467144/from-easiest-to-1-line-math-solution/?orderBy=most_votes)"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    int maximizeSum(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int sum = nums[nums.size()-1]; //Select an element last from nums.\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int prev = sum;  \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 while(k >1){\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 sum += (prev+1);  //Add a new element with a value of last + 1 to the array.\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 prev = prev+1; //Increase your score by last element.\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 k--;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return\\xA0sum;\\n    }\\n};\\n\\n//please upvote.. and thank you"
                    },
                    {
                        "username": "resilient_nik9",
                        "content": "[@Vamsidhar Reddy M](/VamsidharReddyy) Please don\\'t post solutions in discuss, Instead post them in solutions."
                    }
                ]
            }
        ]
    },
    {
        "title": "Frequency Tracker",
        "question_content": "<p>Design a data structure that keeps track of the values in it and answers some queries regarding their frequencies.</p>\n\n<p>Implement the <code>FrequencyTracker</code> class.</p>\n\n<ul>\n\t<li><code>FrequencyTracker()</code>: Initializes the <code>FrequencyTracker</code> object with an empty array initially.</li>\n\t<li><code>void add(int number)</code>: Adds <code>number</code> to the data structure.</li>\n\t<li><code>void deleteOne(int number)</code>: Deletes <strong>one</strong> occurrence of <code>number</code> from the data structure. The data structure <strong>may not contain</strong> <code>number</code>, and in this case nothing is deleted.</li>\n\t<li><code>bool hasFrequency(int frequency)</code>: Returns <code>true</code> if there is a number in the data structure that occurs <code>frequency</code> number of times, otherwise, it returns <code>false</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;FrequencyTracker&quot;, &quot;add&quot;, &quot;add&quot;, &quot;hasFrequency&quot;]\n[[], [3], [3], [2]]\n<strong>Output</strong>\n[null, null, null, true]\n\n<strong>Explanation</strong>\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.add(3); // The data structure now contains [3]\nfrequencyTracker.add(3); // The data structure now contains [3, 3]\nfrequencyTracker.hasFrequency(2); // Returns true, because 3 occurs twice\n\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;FrequencyTracker&quot;, &quot;add&quot;, &quot;deleteOne&quot;, &quot;hasFrequency&quot;]\n[[], [1], [1], [1]]\n<strong>Output</strong>\n[null, null, null, false]\n\n<strong>Explanation</strong>\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.add(1); // The data structure now contains [1]\nfrequencyTracker.deleteOne(1); // The data structure becomes empty []\nfrequencyTracker.hasFrequency(1); // Returns false, because the data structure is empty\n\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;FrequencyTracker&quot;, &quot;hasFrequency&quot;, &quot;add&quot;, &quot;hasFrequency&quot;]\n[[], [2], [3], [1]]\n<strong>Output</strong>\n[null, false, null, true]\n\n<strong>Explanation</strong>\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.hasFrequency(2); // Returns false, because the data structure is empty\nfrequencyTracker.add(3); // The data structure now contains [3]\nfrequencyTracker.hasFrequency(1); // Returns true, because 3 occurs once\n\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= number &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= frequency &lt;= 10<sup>5</sup></code></li>\n\t<li>At most, <code>2 *&nbsp;10<sup>5</sup></code>&nbsp;calls will be made to <code>add</code>, <code>deleteOne</code>, and <code>hasFrequency</code>&nbsp;in <strong>total</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3494972,
                "title": "explained-very-simple-easy-to-understand-solution",
                "content": "<b> Up vote if you like the solution </b>\\n\\n# Approach\\n\\nTake two maps, one to store number & frequency count ( mp )\\n& second one to store frequency & set of number whose frequecny is same ( rmp )\\n   - Basically the rmp is kind of reverse mapping of the data from the frequency to number\\n    \\nThen when we add a new number, \\n - first errase its occurance from the frequency mapping \\n - update the mapping mp\\n - Then add to the new frequency set\\n \\nSame above step we have to execute when deleted a number.\\n     \\nfinally to check if a number has a frequency equal to a particualr frequencyor not\\n    simply check if there is a index in rmp which has a set of size larger than 0.\\n        \\n \\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int, int> mp;   //store number & frequency count\\n    unordered_map<int, unordered_set<int>> mps; //store frequency & set of number whose frequecny is same\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(mp.find(number) != mp.end()){\\n            int f = mp[number];\\n            mps[f].erase(number);\\n        }\\n        mp[number]++;\\n        mps[mp[number]].insert(number);\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp.find(number) != mp.end() && mp[number] > 0){\\n            int f = mp[number];\\n            mps[f].erase(number);\\n            mp[number]--;\\n            if(mp[number]){\\n                mps[mp[number]].insert(number);\\n            }\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return (mps[frequency].size() > 0);\\n    }\\n};\\n```\\n\\nSolution 2: The second map can be stored only count of numbers whose frequency is same, without tracking exact number stored as well, as we only need the count. \\n\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int, int> mp;   //store number & frequency count\\n    unordered_map<int, int> mps;  //store frequency & count number whose frequecny is same\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(mp.find(number) != mp.end()){\\n            mps[mp[number]]--;\\n        }\\n        mp[number]++;\\n        mps[mp[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp.find(number) != mp.end() && mp[number] > 0){\\n            mps[mp[number]]--;\\n            mp[number]--;\\n            mps[mp[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return (mps[frequency] > 0);\\n    }\\n};\\n```\\n\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int, int> mp;   //store number & frequency count\\n    unordered_map<int, unordered_set<int>> mps; //store frequency & set of number whose frequecny is same\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(mp.find(number) != mp.end()){\\n            int f = mp[number];\\n            mps[f].erase(number);\\n        }\\n        mp[number]++;\\n        mps[mp[number]].insert(number);\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp.find(number) != mp.end() && mp[number] > 0){\\n            int f = mp[number];\\n            mps[f].erase(number);\\n            mp[number]--;\\n            if(mp[number]){\\n                mps[mp[number]].insert(number);\\n            }\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return (mps[frequency].size() > 0);\\n    }\\n};\\n```\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int, int> mp;   //store number & frequency count\\n    unordered_map<int, int> mps;  //store frequency & count number whose frequecny is same\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(mp.find(number) != mp.end()){\\n            mps[mp[number]]--;\\n        }\\n        mp[number]++;\\n        mps[mp[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp.find(number) != mp.end() && mp[number] > 0){\\n            mps[mp[number]]--;\\n            mp[number]--;\\n            mps[mp[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return (mps[frequency] > 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494909,
                "title": "two-arrays",
                "content": "We use two arrays (or we can use hash maps) to store:\\n- count of each number\\n- count of numbers for each frequency\\n\\nWith two arrays, the update (add/delete), and query (has) operations have O(1) complexity.\\n\\n**C++**\\n```cpp\\nclass FrequencyTracker {\\npublic:\\n    int cnt[100001] = {}, freq[100001] = {};\\n    void add(int number) {\\n        --freq[cnt[number]];\\n        ++freq[++cnt[number]];\\n    }    \\n    void deleteOne(int number) {\\n        if (cnt[number]) {\\n            --freq[cnt[number]];\\n            ++freq[--cnt[number]];\\n        }\\n    }\\n    bool hasFrequency(int frequency) {\\n        return freq[frequency];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass FrequencyTracker {\\npublic:\\n    int cnt[100001] = {}, freq[100001] = {};\\n    void add(int number) {\\n        --freq[cnt[number]];\\n        ++freq[++cnt[number]];\\n    }    \\n    void deleteOne(int number) {\\n        if (cnt[number]) {\\n            --freq[cnt[number]];\\n            ++freq[--cnt[number]];\\n        }\\n    }\\n    bool hasFrequency(int frequency) {\\n        return freq[frequency];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494843,
                "title": "java-simple-solution-frequency-map",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n  int[] map, freq;\\n\\n  public FrequencyTracker() {\\n    map = new int[100001];\\n    freq = new int[100001];\\n  }\\n\\n  public void add(int number) {\\n    freq[map[number]++]--;\\n    freq[map[number]]++;\\n  }\\n\\n  public void deleteOne(int number) {\\n    if (map[number] > 0) {\\n      freq[map[number]--]--;\\n      freq[map[number]]++;\\n    }\\n  }\\n\\n  public boolean hasFrequency(int frequency) {\\n    return freq[frequency] > 0;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass FrequencyTracker {\\n  int[] map, freq;\\n\\n  public FrequencyTracker() {\\n    map = new int[100001];\\n    freq = new int[100001];\\n  }\\n\\n  public void add(int number) {\\n    freq[map[number]++]--;\\n    freq[map[number]]++;\\n  }\\n\\n  public void deleteOne(int number) {\\n    if (map[number] > 0) {\\n      freq[map[number]--]--;\\n      freq[map[number]]++;\\n    }\\n  }\\n\\n  public boolean hasFrequency(int frequency) {\\n    return freq[frequency] > 0;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494900,
                "title": "day-402-better-100-0ms-python-java-c-explained-approach",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n##### \\u2022\\tExplanation:\\n##### \\u2022\\tWe use a HashMap  to store the count of each number and an array frequency to store the frequency of each count.\\n##### \\u2022\\t We initialize the frequency array with a size of 1e5+1.\\n##### \\u2022\\tThe add method takes a number as input and does the following:\\n##### \\u2022\\tIt gets the current count of the number from the map\\n##### \\u2022\\tIf the current count is already present, it decrements its frequency in the frequency array.\\n##### \\u2022\\tIt increments the count of the number in the map\\n##### \\u2022\\tIt increments the frequency of the new count in the frequency array.\\n##### \\u2022\\tThe deleteOne method takes a number as input and does the following:\\n##### \\u2022\\tIt gets the current count of the number from the map\\n##### \\u2022\\tIf the count is not null, it decrements the frequency of the current count in the frequency array.\\n##### \\u2022\\tIf the count is 1, it removes the number from the map\\n##### \\u2022\\tIf the count is greater than 1, it decrements the count of the number in the map and increments the frequency of the new count in the frequency array.\\n##### \\u2022\\tThe hasFrequency method takes a number as input and returns true if the frequency of the number is greater than 0 in the frequency array.\\n\\n\\n\\n# Complexity\\n- Time complexity:o(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\nprivate final Map<Integer,Integer> map; // Map to store the count of each number\\nprivate final int[] frequency; // Array to store the frequency of each count\\npublic FrequencyTracker() {\\n    map = new HashMap<>();\\n    frequency = new int[(int) 1e5 + 1]; // Initialize the frequency array with a size of 10^5 + 1\\n}\\n\\npublic void add(int number) {\\n    Integer freq = map.getOrDefault(number, 0); // Get the current count of the number\\n    if (freq != null && frequency[freq] > 0) { // If the current count is already present, decrement its frequency\\n        frequency[freq]--;\\n    }\\n    map.compute(number, (k, v) -> v == null ? 1 : v + 1); // Increment the count of the number in the map\\n    frequency[map.get(number)]++; // Increment the frequency of the new count in the frequency array\\n}\\n\\npublic void deleteOne(int n) {\\n    Integer count = map.get(n); // Get the current count of the number\\n    if (count != null) {\\n        frequency[count]--; // Decrement the frequency of the current count in the frequency array\\n        if (count == 1) {\\n            map.remove(n); // If the count is 1, remove the number from the map\\n        } else {\\n            map.put(n, count - 1); // Decrement the count of the number in the map\\n            frequency[map.get(n)]++; // Increment the frequency of the new count in the frequency array\\n        }\\n    }\\n}\\n\\npublic boolean hasFrequency(int number) {\\n    return number < this.frequency.length && this.frequency[number] > 0; // Check if the frequency of the given number is greater than 0\\n}\\n```\\n```c++ []\\nclass FrequencyTracker {\\nprivate:\\n    std::unordered_map<int, int> map; // Map to store the count of each number\\n    std::vector<int> frequency; // Vector to store the frequency of each count\\n\\npublic:\\n    FrequencyTracker() {\\n        frequency.resize(1e5 + 1); // Initialize the frequency vector with a size of 10^5 + 1\\n    }\\n\\n    void add(int number) {\\n        int freq = map[number]; // Get the current count of the number\\n        if (freq > 0 && frequency[freq] > 0) { // If the current count is already present, decrement its frequency\\n            frequency[freq]--;\\n        }\\n        map[number]++; // Increment the count of the number in the map\\n        frequency[map[number]]++; // Increment the frequency of the new count in the frequency vector\\n    }\\n\\n    void deleteOne(int n) {\\n        int count = map[n]; // Get the current count of the number\\n        if (count > 0) {\\n            frequency[count]--; // Decrement the frequency of the current count in the frequency vector\\n            if (count == 1) {\\n                map.erase(n); // If the count is 1, remove the number from the map\\n            } else {\\n                map[n]--; // Decrement the count of the number in the map\\n                frequency[map[n]]++; // Increment the frequency of the new count in the frequency vector\\n            }\\n        }\\n    }\\n\\n    bool hasFrequency(int number) {\\n        return number < frequency.size() && frequency[number] > 0; // Check if the frequency of the given number is greater than 0\\n    }\\n};\\n```\\n```python []\\nclass FrequencyTracker:\\n    def __init__(self):\\n        self.map = {} # Dictionary to store the count of each number\\n        self.frequency = [0] * (10**5 + 1) # List to store the frequency of each count\\n\\n    def add(self, number):\\n        freq = self.map.get(number, 0) # Get the current count of the number\\n        if freq > 0 and self.frequency[freq] > 0: # If the current count is already present, decrement its frequency\\n            self.frequency[freq] -= 1\\n        self.map[number] = freq + 1 # Increment the count of the number in the map\\n        self.frequency[self.map[number]] += 1 # Increment the frequency of the new count in the frequency list\\n\\n    def deleteOne(self, n):\\n        count = self.map.get(n, 0) # Get the current count of the number\\n        if count > 0:\\n            self.frequency[count] -= 1 # Decrement the frequency of the current count in the frequency list\\n            if count == 1:\\n                del self.map[n] # If the count is 1, remove the number from the map\\n            else:\\n                self.map[n] = count - 1 # Decrement the count of the number in the map\\n                self.frequency[self.map[n]] += 1 # Increment the frequency of the new count in the frequency list\\n\\n    def hasFrequency(self, number):\\n        return number < len(self.frequency) and self.frequency[number] > 0 # Check if the frequency of the given number is greater than 0\\n```\\n\\n\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n![image.png](https://assets.leetcode.com/users/images/303fa18d-281d-49f0-87ef-1a018fc9a488_1681355186.0923774.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Hash Function"
                ],
                "code": "```java []\\nprivate final Map<Integer,Integer> map; // Map to store the count of each number\\nprivate final int[] frequency; // Array to store the frequency of each count\\npublic FrequencyTracker() {\\n    map = new HashMap<>();\\n    frequency = new int[(int) 1e5 + 1]; // Initialize the frequency array with a size of 10^5 + 1\\n}\\n\\npublic void add(int number) {\\n    Integer freq = map.getOrDefault(number, 0); // Get the current count of the number\\n    if (freq != null && frequency[freq] > 0) { // If the current count is already present, decrement its frequency\\n        frequency[freq]--;\\n    }\\n    map.compute(number, (k, v) -> v == null ? 1 : v + 1); // Increment the count of the number in the map\\n    frequency[map.get(number)]++; // Increment the frequency of the new count in the frequency array\\n}\\n\\npublic void deleteOne(int n) {\\n    Integer count = map.get(n); // Get the current count of the number\\n    if (count != null) {\\n        frequency[count]--; // Decrement the frequency of the current count in the frequency array\\n        if (count == 1) {\\n            map.remove(n); // If the count is 1, remove the number from the map\\n        } else {\\n            map.put(n, count - 1); // Decrement the count of the number in the map\\n            frequency[map.get(n)]++; // Increment the frequency of the new count in the frequency array\\n        }\\n    }\\n}\\n\\npublic boolean hasFrequency(int number) {\\n    return number < this.frequency.length && this.frequency[number] > 0; // Check if the frequency of the given number is greater than 0\\n}\\n```\n```c++ []\\nclass FrequencyTracker {\\nprivate:\\n    std::unordered_map<int, int> map; // Map to store the count of each number\\n    std::vector<int> frequency; // Vector to store the frequency of each count\\n\\npublic:\\n    FrequencyTracker() {\\n        frequency.resize(1e5 + 1); // Initialize the frequency vector with a size of 10^5 + 1\\n    }\\n\\n    void add(int number) {\\n        int freq = map[number]; // Get the current count of the number\\n        if (freq > 0 && frequency[freq] > 0) { // If the current count is already present, decrement its frequency\\n            frequency[freq]--;\\n        }\\n        map[number]++; // Increment the count of the number in the map\\n        frequency[map[number]]++; // Increment the frequency of the new count in the frequency vector\\n    }\\n\\n    void deleteOne(int n) {\\n        int count = map[n]; // Get the current count of the number\\n        if (count > 0) {\\n            frequency[count]--; // Decrement the frequency of the current count in the frequency vector\\n            if (count == 1) {\\n                map.erase(n); // If the count is 1, remove the number from the map\\n            } else {\\n                map[n]--; // Decrement the count of the number in the map\\n                frequency[map[n]]++; // Increment the frequency of the new count in the frequency vector\\n            }\\n        }\\n    }\\n\\n    bool hasFrequency(int number) {\\n        return number < frequency.size() && frequency[number] > 0; // Check if the frequency of the given number is greater than 0\\n    }\\n};\\n```\n```python []\\nclass FrequencyTracker:\\n    def __init__(self):\\n        self.map = {} # Dictionary to store the count of each number\\n        self.frequency = [0] * (10**5 + 1) # List to store the frequency of each count\\n\\n    def add(self, number):\\n        freq = self.map.get(number, 0) # Get the current count of the number\\n        if freq > 0 and self.frequency[freq] > 0: # If the current count is already present, decrement its frequency\\n            self.frequency[freq] -= 1\\n        self.map[number] = freq + 1 # Increment the count of the number in the map\\n        self.frequency[self.map[number]] += 1 # Increment the frequency of the new count in the frequency list\\n\\n    def deleteOne(self, n):\\n        count = self.map.get(n, 0) # Get the current count of the number\\n        if count > 0:\\n            self.frequency[count] -= 1 # Decrement the frequency of the current count in the frequency list\\n            if count == 1:\\n                del self.map[n] # If the count is 1, remove the number from the map\\n            else:\\n                self.map[n] = count - 1 # Decrement the count of the number in the map\\n                self.frequency[self.map[n]] += 1 # Increment the frequency of the new count in the frequency list\\n\\n    def hasFrequency(self, number):\\n        return number < len(self.frequency) and self.frequency[number] > 0 # Check if the frequency of the given number is greater than 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499060,
                "title": "clean-solution-very-easy-to-understand-using-two-maps-faster-than-100",
                "content": "```\\nfrom collections import defaultdict\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.count = defaultdict(int)\\n        self.freq = defaultdict(set)\\n        \\n    def add(self, number: int) -> None:\\n        prevCount = self.count[number] \\n        # delete number if it is already present in the set at its current freq\\n        if number in self.freq[ prevCount ]:\\n            self.freq[self.count[number]].remove(number)\\n        \\n        #increment count or ocurence of number\\n        self.count[number] += 1\\n        newCount = prevCount + 1 \\n        #add number in the set at newCount\\n        self.freq[newCount].add(number)\\n        \\n    def deleteOne(self, number: int) -> None:\\n        # delete number if it is already present in the set at its current freq\\n        if number in self.freq[ self.count[number] ]:\\n            self.freq[self.count[number]].remove(number)\\n        \\n        if self.count[number]: # if number is alredy present, decrement its count by 1\\n            self.count[number] -= 1\\n            if self.count[number] == 0: # if its become remove from count dict \\n                del self.count[number]\\n            else: # otherwise add the number in the set at newCount\\n                newCount = self.count[number]\\n                self.freq[newCount].add(number) \\n    \\n    def hasFrequency(self, frequency: int) -> bool:\\n        # return true if set is exist(i.e length > 0) at frequency, otherwise false \\n        return self.freq[frequency]\\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.count = defaultdict(int)\\n        self.freq = defaultdict(set)\\n        \\n    def add(self, number: int) -> None:\\n        prevCount = self.count[number] \\n        # delete number if it is already present in the set at its current freq\\n        if number in self.freq[ prevCount ]:\\n            self.freq[self.count[number]].remove(number)\\n        \\n        #increment count or ocurence of number\\n        self.count[number] += 1\\n        newCount = prevCount + 1 \\n        #add number in the set at newCount\\n        self.freq[newCount].add(number)\\n        \\n    def deleteOne(self, number: int) -> None:\\n        # delete number if it is already present in the set at its current freq\\n        if number in self.freq[ self.count[number] ]:\\n            self.freq[self.count[number]].remove(number)\\n        \\n        if self.count[number]: # if number is alredy present, decrement its count by 1\\n            self.count[number] -= 1\\n            if self.count[number] == 0: # if its become remove from count dict \\n                del self.count[number]\\n            else: # otherwise add the number in the set at newCount\\n                newCount = self.count[number]\\n                self.freq[newCount].add(number) \\n    \\n    def hasFrequency(self, frequency: int) -> bool:\\n        # return true if set is exist(i.e length > 0) at frequency, otherwise false \\n        return self.freq[frequency]\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 3494888,
                "title": "cpp-two-maps",
                "content": "### Intuition\\nJust count frequency of elements and frequency of frequecies.\\n\\n### TIme Complexity : `O(n)`\\n\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> mp1,mp2;\\n    FrequencyTracker() {\\n        \\n        \\n    }\\n    void add(int x) {\\n        if(mp2[mp1[x]] > 0) {\\n            mp2[mp1[x]]--;\\n        }\\n        ++mp1[x];\\n        mp2[mp1[x]]++;\\n        \\n    }\\n    void deleteOne(int x) {\\n        if(mp1[x] > 0) {\\n            mp2[mp1[x]]--;\\n            mp1[x]--;\\n            mp2[mp1[x]]++;\\n        }\\n    }\\n    bool hasFrequency(int f) {\\n        return mp2[f] > 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> mp1,mp2;\\n    FrequencyTracker() {\\n        \\n        \\n    }\\n    void add(int x) {\\n        if(mp2[mp1[x]] > 0) {\\n            mp2[mp1[x]]--;\\n        }\\n        ++mp1[x];\\n        mp2[mp1[x]]++;\\n        \\n    }\\n    void deleteOne(int x) {\\n        if(mp1[x] > 0) {\\n            mp2[mp1[x]]--;\\n            mp1[x]--;\\n            mp2[mp1[x]]++;\\n        }\\n    }\\n    bool hasFrequency(int f) {\\n        return mp2[f] > 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494884,
                "title": "simple-map-easy-to-understand-clean-code",
                "content": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int, int>numCount;  //count of \"numbers\" with a given \"number\"\\n    unordered_map<int, int>freqCount; //count of \"numbers\" with a given \"freq\"\\n    FrequencyTracker() {  }\\n    \\n    void add(int number) \\n    {\\n        int oldNumCount = numCount[number];\\n        int newNumCount = ++numCount[number]; //increment first, then use\\n        \\n        freqCount[oldNumCount]--;\\n        freqCount[newNumCount]++;\\n    }\\n    \\n    void deleteOne(int number) \\n    {\\n        int oldNumCount = numCount[number];\\n        if (oldNumCount == 0) return;\\n        int newNumCount = --numCount[number];\\n        \\n        freqCount[oldNumCount]--;\\n        freqCount[newNumCount]++;\\n    }\\n    \\n    bool hasFrequency(int frequency) \\n    {\\n        return (freqCount[frequency] != 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int, int>numCount;  //count of \"numbers\" with a given \"number\"\\n    unordered_map<int, int>freqCount; //count of \"numbers\" with a given \"freq\"\\n    FrequencyTracker() {  }\\n    \\n    void add(int number) \\n    {\\n        int oldNumCount = numCount[number];\\n        int newNumCount = ++numCount[number]; //increment first, then use\\n        \\n        freqCount[oldNumCount]--;\\n        freqCount[newNumCount]++;\\n    }\\n    \\n    void deleteOne(int number) \\n    {\\n        int oldNumCount = numCount[number];\\n        if (oldNumCount == 0) return;\\n        int newNumCount = --numCount[number];\\n        \\n        freqCount[oldNumCount]--;\\n        freqCount[newNumCount]++;\\n    }\\n    \\n    bool hasFrequency(int frequency) \\n    {\\n        return (freqCount[frequency] != 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494874,
                "title": "2-unordered-maps",
                "content": "# Intuition\\nOne for frequency and one for element.\\n\\n# Approach\\nMaintain 2 unordered maps.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    unordered_map<int, int> f, have;\\n    \\n    void remove(unordered_map<int, int> &m, int x) {\\n        if (--m[x] == 0) {\\n            m.erase(x);\\n        }\\n    }\\n        \\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        remove(f, have[number]);\\n        ++f[++have[number]];\\n        \\n    }\\n    \\n    void deleteOne(int number) {\\n        if (!have.count(number)) {\\n            return;\\n        }\\n        remove(f, have[number]);\\n        ++f[have[number] - 1];\\n        remove(have, number);\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return f.count(frequency);\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    unordered_map<int, int> f, have;\\n    \\n    void remove(unordered_map<int, int> &m, int x) {\\n        if (--m[x] == 0) {\\n            m.erase(x);\\n        }\\n    }\\n        \\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        remove(f, have[number]);\\n        ++f[++have[number]];\\n        \\n    }\\n    \\n    void deleteOne(int number) {\\n        if (!have.count(number)) {\\n            return;\\n        }\\n        remove(f, have[number]);\\n        ++f[have[number] - 1];\\n        remove(have, number);\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return f.count(frequency);\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497498,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    int ele[], freq[];\\n    public FrequencyTracker() {\\n        ele=new int[100001];\\n        freq=new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n        if(ele[number]>0)\\n        {\\n            freq[ele[number]]--;\\n        }\\n        ele[number]++;\\n        freq[ele[number]]++;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(ele[number]>0)\\n        {\\n            freq[ele[number]]--;\\n            ele[number]--;\\n            freq[ele[number]]++;\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return freq[frequency]>0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    int ele[], freq[];\\n    public FrequencyTracker() {\\n        ele=new int[100001];\\n        freq=new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n        if(ele[number]>0)\\n        {\\n            freq[ele[number]]--;\\n        }\\n        ele[number]++;\\n        freq[ele[number]]++;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(ele[number]>0)\\n        {\\n            freq[ele[number]]--;\\n            ele[number]--;\\n            freq[ele[number]]++;\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return freq[frequency]>0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496734,
                "title": "two-map-approach",
                "content": "# Approach\\nStore added number and its frequency.\\n\\nTo run `hasFrequency` mathod fast, we need another map.\\n\\n# Complexity\\n- Time complexity: all method can run in $O(1)$ time\\n\\n- Space complexity: $O(n)$\\n\\n# Code\\n```\\nclass FrequencyTracker:\\n    \"\"\"\\n    Properties:\\n      count: count the frequency of the given number\\n      freq: how many numbers occurs with given frequency \\n    \"\"\"\\n    def __init__(self):\\n        self.count = defaultdict(int)\\n        self.freq = defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        self.freq[self.count[number]] -= 1\\n        self.count[number] += 1\\n        self.freq[self.count[number]] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        if self.count[number] > 0:\\n            self.freq[self.count[number]] -= 1\\n            self.count[number] -= 1\\n            self.freq[self.count[number]] += 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] > 0\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FrequencyTracker:\\n    \"\"\"\\n    Properties:\\n      count: count the frequency of the given number\\n      freq: how many numbers occurs with given frequency \\n    \"\"\"\\n    def __init__(self):\\n        self.count = defaultdict(int)\\n        self.freq = defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        self.freq[self.count[number]] -= 1\\n        self.count[number] += 1\\n        self.freq[self.count[number]] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        if self.count[number] > 0:\\n            self.freq[self.count[number]] -= 1\\n            self.count[number] -= 1\\n            self.freq[self.count[number]] += 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] > 0\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495616,
                "title": "c-only-solution-you-need-to-see",
                "content": "# Intuition\\nThe problem requires us to create a class that maintains the frequency of elements in a given set and provides the following operations:\\n\\nAdd an element to the set\\nDelete an element from the set\\nCheck if a given frequency exists in the set\\nOne way to approach this problem is to use a map to maintain the frequency of elements in the set. We can also maintain another map to keep track of the frequencies of frequencies. This will help us in implementing the hasFrequency() function in constant time.\\n\\n# Approach\\nThe FrequencyTracker class has three functions: add(), deleteOne(), and hasFrequency().\\n\\nThe add() function takes an integer as input and increments its frequency in the map mp. If the frequency of the number was previously greater than zero, we decrement the frequency count in the frequency map np. We then update the frequency count in the frequency map for the new frequency count.\\n\\nThe deleteOne() function takes an integer as input and decrements its frequency in the map mp. If the frequency of the number was greater than zero, we decrement the frequency count in the frequency map np. We then update the frequency count in the frequency map for the new frequency count. If the frequency of the number becomes zero, we remove it from the map mp.\\n\\nThe hasFrequency() function takes an integer as input and returns true if the input integer is present in the frequency map np. Otherwise, it returns false.\\n\\n# Complexity\\n**Time complexity:** The time complexity of the add() and deleteOne() functions is O(log n) because they use the map data structure, which takes logarithmic time for insertions, deletions, and searches. The time complexity of the hasFrequency() function is O(1) because it directly accesses the frequency map np.\\n\\n**Space complexity:** The space complexity of the FrequencyTracker class is O(n), where n is the number of elements in the set. This is because we use two maps of size n to store the frequency counts and the frequency of frequencies.\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    map<int,int> mp,np;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int num) {\\n        if(mp[num]>0)\\n        {\\n            np[mp[num]]--;\\n        }\\n        mp[num]++;\\n        np[mp[num]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n         if(mp[number]>0)\\n        {\\n            np[mp[number]]--;\\n              mp[number]--;\\n             \\n        if(mp[number] == 0)\\n        {\\n            mp.erase(number);\\n        }\\n             else{\\n                 np[mp[number]]++;\\n             }\\n        }\\n       \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return np[frequency] > 0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    map<int,int> mp,np;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int num) {\\n        if(mp[num]>0)\\n        {\\n            np[mp[num]]--;\\n        }\\n        mp[num]++;\\n        np[mp[num]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n         if(mp[number]>0)\\n        {\\n            np[mp[number]]--;\\n              mp[number]--;\\n             \\n        if(mp[number] == 0)\\n        {\\n            mp.erase(number);\\n        }\\n             else{\\n                 np[mp[number]]++;\\n             }\\n        }\\n       \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return np[frequency] > 0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495747,
                "title": "using-map-c-easy-to-understnad",
                "content": "STORE FREDUCY IN MAP.\\nMAINTAIN COUNT OF FREQUENCIES\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    vector<int> v;\\n    unordered_map<int,int> mp;\\n    FrequencyTracker() {\\n        v.resize(1e5+1);\\n    }\\n    \\n    void add(int x) {\\n        if(v[x]>0){\\n            mp[v[x]]--;\\n            if(mp[v[x]]==0){\\n                mp.erase(v[x]);\\n            }\\n        }\\n        v[x]++;\\n        mp[v[x]]++;\\n    }\\n    \\n    void deleteOne(int x) {\\n        if(v[x]){\\n            mp[v[x]]--;\\n            if(mp[v[x]]==0)mp.erase(v[x]);\\n            v[x]--;\\n            mp[v[x]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int x) {\\n        return mp.count(x);\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    vector<int> v;\\n    unordered_map<int,int> mp;\\n    FrequencyTracker() {\\n        v.resize(1e5+1);\\n    }\\n    \\n    void add(int x) {\\n        if(v[x]>0){\\n            mp[v[x]]--;\\n            if(mp[v[x]]==0){\\n                mp.erase(v[x]);\\n            }\\n        }\\n        v[x]++;\\n        mp[v[x]]++;\\n    }\\n    \\n    void deleteOne(int x) {\\n        if(v[x]){\\n            mp[v[x]]--;\\n            if(mp[v[x]]==0)mp.erase(v[x]);\\n            v[x]--;\\n            mp[v[x]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int x) {\\n        return mp.count(x);\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495305,
                "title": "both-using-maps-and-arrays-solution-simple-and-easy",
                "content": "# **Using Two Maps**\\n```\\nclass FrequencyTracker {\\n    unordered_map<int,int> freq,map;\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(map[number] > 0) freq[map[number]]--;\\n        map[number]++;\\n        freq[map[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(map[number] > 0) {\\n            freq[map[number]]--;\\n            map[number]--;\\n            freq[map[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq[frequency] > 0;\\n    }\\n};\\n```\\n\\n# Using Two arrays\\n```\\nclass FrequencyTracker {\\n    int arr[100001],freq[100001];\\npublic:\\n    FrequencyTracker() {\\n        for(int i = 0;i<100001;i++) arr[i] = 0;\\n        for(int i = 0;i<100001;i++) freq[i] = 0;\\n\\n    }\\n    \\n    void add(int number) {\\n        if(arr[number]>0){\\n            int pre = arr[number];\\n            freq[pre]--;\\n            arr[number]++;\\n            int af = arr[number];\\n            freq[af]++;\\n            return ;\\n        }\\n        arr[number]++;\\n        int t = arr[number];\\n        freq[t]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(arr[number] ==0 ) return ;\\n        int pre = arr[number];\\n        freq[pre]--;\\n        arr[number]--;\\n        int af = arr[number];\\n        freq[af]++;\\n    }\\n    \\n    bool hasFrequency(int fr) {\\n        if(freq[fr]>0) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    unordered_map<int,int> freq,map;\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(map[number] > 0) freq[map[number]]--;\\n        map[number]++;\\n        freq[map[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(map[number] > 0) {\\n            freq[map[number]]--;\\n            map[number]--;\\n            freq[map[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq[frequency] > 0;\\n    }\\n};\\n```\n```\\nclass FrequencyTracker {\\n    int arr[100001],freq[100001];\\npublic:\\n    FrequencyTracker() {\\n        for(int i = 0;i<100001;i++) arr[i] = 0;\\n        for(int i = 0;i<100001;i++) freq[i] = 0;\\n\\n    }\\n    \\n    void add(int number) {\\n        if(arr[number]>0){\\n            int pre = arr[number];\\n            freq[pre]--;\\n            arr[number]++;\\n            int af = arr[number];\\n            freq[af]++;\\n            return ;\\n        }\\n        arr[number]++;\\n        int t = arr[number];\\n        freq[t]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(arr[number] ==0 ) return ;\\n        int pre = arr[number];\\n        freq[pre]--;\\n        arr[number]--;\\n        int af = arr[number];\\n        freq[af]++;\\n    }\\n    \\n    bool hasFrequency(int fr) {\\n        if(freq[fr]>0) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495095,
                "title": "simple-java-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n   int[] num = new int[100001];\\n   int[] fre = new int[100001];\\n    public FrequencyTracker() {\\n        \\n    }\\n    \\n    public void add(int number) {\\n        if(num[number] > 0){\\n            fre[num[number]]--;\\n        }\\n        num[number]++;\\n        fre[num[number]]++;    \\n    }\\n    \\n    public void deleteOne(int number) {\\n         if(num[number] > 0){\\n            fre[num[number]]--;\\n            num[number]--;\\n            fre[num[number]]++;\\n        }\\n       \\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return fre[frequency] > 0;\\n        \\n    }\\n}\\n\\n \\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n   int[] num = new int[100001];\\n   int[] fre = new int[100001];\\n    public FrequencyTracker() {\\n        \\n    }\\n    \\n    public void add(int number) {\\n        if(num[number] > 0){\\n            fre[num[number]]--;\\n        }\\n        num[number]++;\\n        fre[num[number]]++;    \\n    }\\n    \\n    public void deleteOne(int number) {\\n         if(num[number] > 0){\\n            fre[num[number]]--;\\n            num[number]--;\\n            fre[num[number]]++;\\n        }\\n       \\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return fre[frequency] > 0;\\n        \\n    }\\n}\\n\\n \\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495028,
                "title": "java-frequency-array-concise-code",
                "content": "``` java\\nclass FrequencyTracker {\\n    int[] freq;\\n    int[] count;\\n\\n    public FrequencyTracker() {\\n        freq = new int[100001];\\n        count = new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n        freq[count[number]]--;\\n        count[number]++;\\n        freq[count[number]]++;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if (count[number] > 0) {\\n            freq[count[number]]--;\\n            count[number]--;\\n            freq[count[number]]++;\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return freq[frequency] >= 1;\\n    }\\n}\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java\\nclass FrequencyTracker {\\n    int[] freq;\\n    int[] count;\\n\\n    public FrequencyTracker() {\\n        freq = new int[100001];\\n        count = new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n        freq[count[number]]--;\\n        count[number]++;\\n        freq[count[number]]++;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if (count[number] > 0) {\\n            freq[count[number]]--;\\n            count[number]--;\\n            freq[count[number]]++;\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return freq[frequency] >= 1;\\n    }\\n}\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494998,
                "title": "keep-2-hashmaps-and-update-them",
                "content": "# Intuition\\n$$add()$$ and $$deleteOne()$$ functions can be made using a hashmap easily. Both of them will change the frequency of $$number$$.\\nThat in turn will lead to a change in the frequencies, i.e. suppose the data structure had 3 numbers appear 5 times and 2 numbers appear  3 times. We have:\\n```\\nFreq[numbers appearing 5 times]=3\\nFreq[nummbers appearing 3 times]=2\\n```\\nIf $$add()$$ is called on a number that was present 5 times, won\\'t this number be present **6** times now? And **freq[5]=2** ?\\n\\nWe just have to keep updating this array. \\n\\n\\n# Approach\\nUse a HashMap two store frequency of a number. Update it accordingly as add and deleteOne functions are called.\\nKeep a frequency array, $$freq[20001]$$. \\n# freq[3]=2 means there are 2 numbers in the data structure that appear 3 times. \\n\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    int[] b;\\n    HashMap<Integer,Integer> map;\\n    public FrequencyTracker() {\\n        b= new int[200001];\\n        map = new HashMap<>(); \\n    }\\n    \\n    public void add(int number) {\\n        int x = map.getOrDefault(number,0);\\n        if(x!=0){\\n            b[x]--;\\n              \\n        }\\n        b[x+1]++;  \\n        map.put(number,x+1);\\n        \\n    }\\n    \\n    public void deleteOne(int number) {\\n        int x =map.getOrDefault(number,0);\\n        if(x==0){ // don\\'t do anything\\n            \\n        }\\n        else { \\n            b[x]--;\\n            b[x-1]++;\\n            map.put(number,x-1);\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return b[frequency]>0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nFreq[numbers appearing 5 times]=3\\nFreq[nummbers appearing 3 times]=2\\n```\n```\\nclass FrequencyTracker {\\n    int[] b;\\n    HashMap<Integer,Integer> map;\\n    public FrequencyTracker() {\\n        b= new int[200001];\\n        map = new HashMap<>(); \\n    }\\n    \\n    public void add(int number) {\\n        int x = map.getOrDefault(number,0);\\n        if(x!=0){\\n            b[x]--;\\n              \\n        }\\n        b[x+1]++;  \\n        map.put(number,x+1);\\n        \\n    }\\n    \\n    public void deleteOne(int number) {\\n        int x =map.getOrDefault(number,0);\\n        if(x==0){ // don\\'t do anything\\n            \\n        }\\n        else { \\n            b[x]--;\\n            b[x-1]++;\\n            map.put(number,x-1);\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return b[frequency]>0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494996,
                "title": "c-easy-two-maps",
                "content": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> map;\\n    unordered_map<int,int> freq;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int num) {\\n        \\n        if(map.find(num) == map.end())freq[1]++;\\n        else {\\n            freq[map[num]]--;\\n            if(freq[map[num]] == 0)freq.erase(map[num]);\\n            freq[map[num] + 1]++;\\n        }\\n        map[num]++;\\n        \\n    }\\n    \\n    void deleteOne(int num) {\\n        if(map.find(num) != map.end()) {\\n            freq[map[num]]--;\\n            if(freq[map[num]] == 0)freq.erase(map[num]);\\n            freq[map[num]-1]++;\\n            map[num]--;\\n            if(map[num] == 0) map.erase(num);\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequ) {\\n        if(freq.find(frequ) != freq.end())return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> map;\\n    unordered_map<int,int> freq;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int num) {\\n        \\n        if(map.find(num) == map.end())freq[1]++;\\n        else {\\n            freq[map[num]]--;\\n            if(freq[map[num]] == 0)freq.erase(map[num]);\\n            freq[map[num] + 1]++;\\n        }\\n        map[num]++;\\n        \\n    }\\n    \\n    void deleteOne(int num) {\\n        if(map.find(num) != map.end()) {\\n            freq[map[num]]--;\\n            if(freq[map[num]] == 0)freq.erase(map[num]);\\n            freq[map[num]-1]++;\\n            map[num]--;\\n            if(map[num] == 0) map.erase(num);\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequ) {\\n        if(freq.find(frequ) != freq.end())return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494985,
                "title": "c-solution-100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        int old_freq = count[number]++;\\n        freq[old_freq]--;\\n        freq[count[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if (count.find(number) != count.end()) {\\n            int old_freq = count[number]--;\\n            freq[old_freq]--;\\n            if (count[number] == 0) {\\n                count.erase(number);\\n            } else {\\n                freq[count[number]]++;\\n            }\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq.find(frequency) != freq.end() && freq[frequency] > 0;\\n    }\\nprivate:\\n   unordered_map<int, int> count;\\n   unordered_map<int, int> freq;\\n};\\n\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        int old_freq = count[number]++;\\n        freq[old_freq]--;\\n        freq[count[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if (count.find(number) != count.end()) {\\n            int old_freq = count[number]--;\\n            freq[old_freq]--;\\n            if (count[number] == 0) {\\n                count.erase(number);\\n            } else {\\n                freq[count[number]]++;\\n            }\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq.find(frequency) != freq.end() && freq[frequency] > 0;\\n    }\\nprivate:\\n   unordered_map<int, int> count;\\n   unordered_map<int, int> freq;\\n};\\n\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494962,
                "title": "java-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    Map<Integer, Integer> frequencyTracker;\\n    int[] arr = new int[100001];\\n\\n    public FrequencyTracker() {\\n        frequencyTracker = new HashMap<>();\\n    }\\n    \\n    public void add(int number) {\\n        if(frequencyTracker.containsKey(number)) {\\n            arr[frequencyTracker.get(number)]--;\\n        }\\n        frequencyTracker.put(number, frequencyTracker.getOrDefault(number, 0) + 1);\\n        arr[frequencyTracker.get(number)]++;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(frequencyTracker.get(number) == null) {\\n            return;\\n        }\\n        \\n        arr[frequencyTracker.get(number)]--;\\n        frequencyTracker.put(number, frequencyTracker.getOrDefault(number, 0) - 1);\\n        if(frequencyTracker.get(number) != 0) {\\n            arr[frequencyTracker.get(number)]++;\\n        } else {\\n            frequencyTracker.remove(number);\\n        }  \\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(arr[frequency] > 0) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    Map<Integer, Integer> frequencyTracker;\\n    int[] arr = new int[100001];\\n\\n    public FrequencyTracker() {\\n        frequencyTracker = new HashMap<>();\\n    }\\n    \\n    public void add(int number) {\\n        if(frequencyTracker.containsKey(number)) {\\n            arr[frequencyTracker.get(number)]--;\\n        }\\n        frequencyTracker.put(number, frequencyTracker.getOrDefault(number, 0) + 1);\\n        arr[frequencyTracker.get(number)]++;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(frequencyTracker.get(number) == null) {\\n            return;\\n        }\\n        \\n        arr[frequencyTracker.get(number)]--;\\n        frequencyTracker.put(number, frequencyTracker.getOrDefault(number, 0) - 1);\\n        if(frequencyTracker.get(number) != 0) {\\n            arr[frequencyTracker.get(number)]++;\\n        } else {\\n            frequencyTracker.remove(number);\\n        }  \\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(arr[frequency] > 0) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494905,
                "title": "simple-using-2-maps",
                "content": "Please upvote\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> mp;\\n    unordered_map<int,unordered_set<int>> freqMp; // maps frequency counts to integers\\n    FrequencyTracker() {\\n        mp.clear();\\n        freqMp.clear();\\n    }\\n    \\n    void add(int number) {\\n        int freq = mp[number];\\n        freqMp[freq].erase(number);\\n        freqMp[freq+1].insert(number);\\n        mp[number]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        int freq = mp[number];\\n        if(freq > 0) {\\n            freqMp[freq].erase(number);\\n            freqMp[freq-1].insert(number);\\n            mp[number]--;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freqMp.count(frequency) > 0 && !freqMp[frequency].empty();\\n    }\\n};\\n\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> mp;\\n    unordered_map<int,unordered_set<int>> freqMp; // maps frequency counts to integers\\n    FrequencyTracker() {\\n        mp.clear();\\n        freqMp.clear();\\n    }\\n    \\n    void add(int number) {\\n        int freq = mp[number];\\n        freqMp[freq].erase(number);\\n        freqMp[freq+1].insert(number);\\n        mp[number]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        int freq = mp[number];\\n        if(freq > 0) {\\n            freqMp[freq].erase(number);\\n            freqMp[freq-1].insert(number);\\n            mp[number]--;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freqMp.count(frequency) > 0 && !freqMp[frequency].empty();\\n    }\\n};\\n\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494904,
                "title": "java-solution-using-two-hashmaps",
                "content": "Here we will use two hashmaps. One with key as the number and another with the key as frequency. This will enable us to do lookups usign both number and frequencies. Thus, each operation be it update, deleteOne, put or get will cost us constant time. \\n```\\nclass FrequencyTracker {\\n\\t//  Map<freq, Set<elements_with_given_freq>\\n    Map<Integer, Set<Integer>> freq;\\n\\t//  Map<number, freq_of_that_number>\\n    Map<Integer, Integer> numbers;\\n    public FrequencyTracker() {\\n        freq = new HashMap<>();\\n        freq.put(0, new HashSet<Integer>());\\n        numbers = new HashMap();\\n    }\\n    \\n    public void add(int number) {\\n        Integer old_freq = numbers.get(number);\\n        int new_freq = old_freq==null ? 1 : old_freq+1;\\n        update_freq(number, new_freq, old_freq);\\n        numbers.put(number, new_freq);\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(!numbers.containsKey(number) || numbers.get(number)==0) return;\\n        int old_freq = numbers.get(number);\\n        int new_freq = old_freq-1;\\n        numbers.put(number, new_freq);\\n        update_freq(number, new_freq, old_freq);\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(freq.containsKey(frequency) && freq.get(frequency).size()!=0) return true;\\n        return false;\\n    }\\n    \\n    public void update_freq(int num, int new_freq, Integer old_freq) {\\n        if(old_freq!=null) freq.get(old_freq).remove(num);\\n        if(!freq.containsKey(new_freq)) freq.put(new_freq, new HashSet<Integer>());\\n        freq.get(new_freq).add(num);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n\\t//  Map<freq, Set<elements_with_given_freq>\\n    Map<Integer, Set<Integer>> freq;\\n\\t//  Map<number, freq_of_that_number>\\n    Map<Integer, Integer> numbers;\\n    public FrequencyTracker() {\\n        freq = new HashMap<>();\\n        freq.put(0, new HashSet<Integer>());\\n        numbers = new HashMap();\\n    }\\n    \\n    public void add(int number) {\\n        Integer old_freq = numbers.get(number);\\n        int new_freq = old_freq==null ? 1 : old_freq+1;\\n        update_freq(number, new_freq, old_freq);\\n        numbers.put(number, new_freq);\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(!numbers.containsKey(number) || numbers.get(number)==0) return;\\n        int old_freq = numbers.get(number);\\n        int new_freq = old_freq-1;\\n        numbers.put(number, new_freq);\\n        update_freq(number, new_freq, old_freq);\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(freq.containsKey(frequency) && freq.get(frequency).size()!=0) return true;\\n        return false;\\n    }\\n    \\n    public void update_freq(int num, int new_freq, Integer old_freq) {\\n        if(old_freq!=null) freq.get(old_freq).remove(num);\\n        if(!freq.containsKey(new_freq)) freq.put(new_freq, new HashSet<Integer>());\\n        freq.get(new_freq).add(num);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707673,
                "title": "python-simple-solution-for-frequency-tracking-using-counter",
                "content": "### Help\\nHere, `self.f` is for counting frequency of numbers.\\nand `self.g` is for counting frequency of frequency.\\n\\nHere, this is the only catch you need to solve this problem.\\n\\n# Code\\n```\\nfrom collections import Counter, defaultdict\\n\\n\\nclass FrequencyTracker(object):\\n    def __init__(self) -> None:\\n        self.f = Counter()\\n        self.g = Counter()\\n        \\n    def add(self, number):\\n        self.f[number] += 1\\n        self.g[self.f[number]] += 1\\n        self.g[self.f[number] - 1] -= 1\\n        \\n    def deleteOne(self, number):\\n        if self.f[number]:\\n            self.f[number] -= 1\\n            if self.f[number] == 0: \\n                del self.f[number]\\n            self.g[self.f[number]] += 1\\n            self.g[self.f[number] + 1] -= 1 \\n\\n    \\n    def hasFrequency(self, frequency):\\n        return self.g[frequency] > 0\\n        \\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nfrom collections import Counter, defaultdict\\n\\n\\nclass FrequencyTracker(object):\\n    def __init__(self) -> None:\\n        self.f = Counter()\\n        self.g = Counter()\\n        \\n    def add(self, number):\\n        self.f[number] += 1\\n        self.g[self.f[number]] += 1\\n        self.g[self.f[number] - 1] -= 1\\n        \\n    def deleteOne(self, number):\\n        if self.f[number]:\\n            self.f[number] -= 1\\n            if self.f[number] == 0: \\n                del self.f[number]\\n            self.g[self.f[number]] += 1\\n            self.g[self.f[number] + 1] -= 1 \\n\\n    \\n    def hasFrequency(self, frequency):\\n        return self.g[frequency] > 0\\n        \\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496896,
                "title": "python3-solution",
                "content": "\\n```\\nclass FrequencyTracker:\\n    \\n    def __init__(self):\\n        self.count = defaultdict(int)\\n        self.freq = defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        self.freq[self.count[number]] -= 1\\n        self.count[number] += 1\\n        self.freq[self.count[number]] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        if self.count[number] > 0:\\n            self.freq[self.count[number]] -= 1\\n            self.count[number] -= 1\\n            self.freq[self.count[number]] += 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] > 0\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass FrequencyTracker:\\n    \\n    def __init__(self):\\n        self.count = defaultdict(int)\\n        self.freq = defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        self.freq[self.count[number]] -= 1\\n        self.count[number] += 1\\n        self.freq[self.count[number]] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        if self.count[number] > 0:\\n            self.freq[self.count[number]] -= 1\\n            self.count[number] -= 1\\n            self.freq[self.count[number]] += 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] > 0\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495518,
                "title": "java-o-1-explained",
                "content": "# **Up Vote \\u2705\\u2705\\u23EB\\u23CF**\\n\\n## **Approach :-**\\n\\n### **Each function take O(1) time complexity**\\n   **-- Because we are just accessing and updating the values**\\n\\n---\\n\\n## **Code :-**\\n\\n```\\nclass FrequencyTracker {\\n    int numbers[];         // It stores the how many time a particular number has occurred\\n    int checkFreq[];       // It stores the frequency of different numbers i.e If a particular freq is present or not\\n    public FrequencyTracker() {\\n        numbers=new int[100001];\\n        checkFreq=new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n        if(numbers[number]>0)       // If the number has previously occured\\n          checkFreq[numbers[number]]--;    // Remove the old frequency that the number has saved\\n        \\n        numbers[number]++;          // Increase the frequency of the number \\n        \\n        checkFreq[numbers[number]]++;   // Now add the updated frequency of the number\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(numbers[number]>0){               // Check if number is present\\n            checkFreq[numbers[number]]--;    // Remove the old frequency that the number has saved\\n            \\n            numbers[number]--;               // Decrease the frequency of the number\\n            \\n            checkFreq[numbers[number]]++;    // Now add the updated frequency of the number\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(checkFreq[frequency]>0)           // Just check if the frequency is present or not\\n            return true;\\n        \\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    int numbers[];         // It stores the how many time a particular number has occurred\\n    int checkFreq[];       // It stores the frequency of different numbers i.e If a particular freq is present or not\\n    public FrequencyTracker() {\\n        numbers=new int[100001];\\n        checkFreq=new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n        if(numbers[number]>0)       // If the number has previously occured\\n          checkFreq[numbers[number]]--;    // Remove the old frequency that the number has saved\\n        \\n        numbers[number]++;          // Increase the frequency of the number \\n        \\n        checkFreq[numbers[number]]++;   // Now add the updated frequency of the number\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(numbers[number]>0){               // Check if number is present\\n            checkFreq[numbers[number]]--;    // Remove the old frequency that the number has saved\\n            \\n            numbers[number]--;               // Decrease the frequency of the number\\n            \\n            checkFreq[numbers[number]]++;    // Now add the updated frequency of the number\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(checkFreq[frequency]>0)           // Just check if the frequency is present or not\\n            return true;\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495392,
                "title": "c-best-solution-frequency-may-count-map-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    public:\\n    unordered_map<int, int> frmp, cntmp;\\n\\n    FrequencyTracker() {\\n    }\\n    \\n    void add(int number) {\\n        int x = frmp[number];\\n        frmp[number]++;\\n        cntmp[x + 1]++;\\n        cntmp[x]--;\\n    }\\n    \\n    void deleteOne(int number) {\\n        int x = frmp[number];\\n        if(x <= 0) return;\\n        frmp[number]--;\\n        cntmp[x]--;\\n        cntmp[x - 1]++;\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return cntmp[frequency];\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Ordered Map"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    public:\\n    unordered_map<int, int> frmp, cntmp;\\n\\n    FrequencyTracker() {\\n    }\\n    \\n    void add(int number) {\\n        int x = frmp[number];\\n        frmp[number]++;\\n        cntmp[x + 1]++;\\n        cntmp[x]--;\\n    }\\n    \\n    void deleteOne(int number) {\\n        int x = frmp[number];\\n        if(x <= 0) return;\\n        frmp[number]--;\\n        cntmp[x]--;\\n        cntmp[x - 1]++;\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return cntmp[frequency];\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495304,
                "title": "easiest-c-solution-using-2-maps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<long long,long long> mp;\\n    unordered_map<long long,long long> mp1;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(mp1[mp[number]]!=0)\\n        mp1[mp[number]]-=number; // delete the old frequency\\n\\n        mp[number]++;//map the number with frequency\\n        mp1[mp[number]]+=number; //map the new frequency with the number\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number]!=0){\\nmp1[mp[number]]-=number; //delete the old frequency\\n        \\n            mp[number]--; //delete the number\\n            \\n            mp1[mp[number]]+=number; //add the new frequency;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(mp1[frequency]>0){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<long long,long long> mp;\\n    unordered_map<long long,long long> mp1;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(mp1[mp[number]]!=0)\\n        mp1[mp[number]]-=number; // delete the old frequency\\n\\n        mp[number]++;//map the number with frequency\\n        mp1[mp[number]]+=number; //map the new frequency with the number\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number]!=0){\\nmp1[mp[number]]-=number; //delete the old frequency\\n        \\n            mp[number]--; //delete the number\\n            \\n            mp1[mp[number]]+=number; //add the new frequency;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(mp1[frequency]>0){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495183,
                "title": "java-easy-using-2-arrays-explained-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMaintain 2 arrays:\\n\\ncounts: to maintain the count of numbers.\\n\\nfreq: to maintain a count of the frequencies.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n     int []counts;\\n     int[]freq;\\n\\n    public FrequencyTracker() {\\n            counts=new int[100001];\\n            freq=new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n      \\n             freq[counts[number]]--; //update the frequency of the count till now \\n            freq[++counts[number]]++;//update the frequency again after increasing the count\\n       \\n    }\\n    \\n    public void deleteOne(int number) {\\n       if(counts[number]!=0)\\n         {\\n               freq[counts[number]]--;//update the frequency of the count till now \\n                freq[--counts[number]]++;//update the frequency again after decreasing the count\\n         }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(freq[frequency]>0) return true;//if the desired frequency count is greater than 0 then return true\\n            return false;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n     int []counts;\\n     int[]freq;\\n\\n    public FrequencyTracker() {\\n            counts=new int[100001];\\n            freq=new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n      \\n             freq[counts[number]]--; //update the frequency of the count till now \\n            freq[++counts[number]]++;//update the frequency again after increasing the count\\n       \\n    }\\n    \\n    public void deleteOne(int number) {\\n       if(counts[number]!=0)\\n         {\\n               freq[counts[number]]--;//update the frequency of the count till now \\n                freq[--counts[number]]++;//update the frequency again after decreasing the count\\n         }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(freq[frequency]>0) return true;//if the desired frequency count is greater than 0 then return true\\n            return false;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495124,
                "title": "c-2-arrays",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(10^5)$$ \\n\\n# Code\\n```\\npublic class FrequencyTracker \\n{\\n    private int[] numberFreq;\\n    private int[] freqCount;\\n\\n    public FrequencyTracker()\\n    {\\n        numberFreq = new int[100001];\\n        freqCount = new int[100001];\\n    }\\n\\n    public void Add(int number)\\n    {\\n        int oldFreq = numberFreq[number];\\n        freqCount[oldFreq]--;\\n        freqCount[oldFreq+1]++;\\n        numberFreq[number]++;\\n    }\\n\\n    public void DeleteOne(int number)\\n    {\\n        if (numberFreq[number] > 0)\\n        {\\n            int oldFreq = numberFreq[number];\\n            freqCount[oldFreq]--;\\n            freqCount[oldFreq - 1]++;\\n            numberFreq[number]--;\\n        }\\n    }\\n\\n    public bool HasFrequency(int frequency)\\n    {\\n        return freqCount[frequency] > 0 ? true : false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class FrequencyTracker \\n{\\n    private int[] numberFreq;\\n    private int[] freqCount;\\n\\n    public FrequencyTracker()\\n    {\\n        numberFreq = new int[100001];\\n        freqCount = new int[100001];\\n    }\\n\\n    public void Add(int number)\\n    {\\n        int oldFreq = numberFreq[number];\\n        freqCount[oldFreq]--;\\n        freqCount[oldFreq+1]++;\\n        numberFreq[number]++;\\n    }\\n\\n    public void DeleteOne(int number)\\n    {\\n        if (numberFreq[number] > 0)\\n        {\\n            int oldFreq = numberFreq[number];\\n            freqCount[oldFreq]--;\\n            freqCount[oldFreq - 1]++;\\n            numberFreq[number]--;\\n        }\\n    }\\n\\n    public bool HasFrequency(int frequency)\\n    {\\n        return freqCount[frequency] > 0 ? true : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495037,
                "title": "easy-c-unordered-map",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> x,y;\\n    void add(int number) {\\n        x[number]++;\\n        if(x[number]!=1) y[x[number]-1]--;\\n        y[x[number]]++;\\n    }\\n    void deleteOne(int number) {\\n        if(x[number]!=0){\\n            x[number]--;\\n            y[x[number]+1]--;\\n            y[x[number]]++;\\n        }\\n    }\\n    bool hasFrequency(int frequency) {\\n        if(y[frequency]!=0) return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> x,y;\\n    void add(int number) {\\n        x[number]++;\\n        if(x[number]!=1) y[x[number]-1]--;\\n        y[x[number]]++;\\n    }\\n    void deleteOne(int number) {\\n        if(x[number]!=0){\\n            x[number]--;\\n            y[x[number]+1]--;\\n            y[x[number]]++;\\n        }\\n    }\\n    bool hasFrequency(int frequency) {\\n        if(y[frequency]!=0) return true;\\n        return false;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 3494865,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nvar FrequencyTracker = function() {\\n    this.freq = {};\\n    this.hasFreq = {};\\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.add = function(number) {\\n    this.freq[number] = ++this.freq[number] || 1;\\n    if (this.freq[number] > 1) {\\n        this.hasFreq[this.freq[number] - 1].delete(number);\\n    }\\n    if (!this.hasFreq[this.freq[number]]) {\\n        this.hasFreq[this.freq[number]] = new Set();\\n    }\\n    this.hasFreq[this.freq[number]].add(number);\\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.deleteOne = function(number) {\\n    if (this.freq[number]) {\\n        this.hasFreq[this.freq[number]].delete(number);\\n        this.freq[number]--;\\n        if (this.freq[number]) {\\n            this.hasFreq[this.freq[number]].add(number);\\n        }\\n    }\\n};\\n\\n/** \\n * @param {number} frequency\\n * @return {boolean}\\n */\\nFrequencyTracker.prototype.hasFrequency = function(frequency) {\\n    return !!this.hasFreq[frequency]?.size;\\n};\\n\\n/** \\n * Your FrequencyTracker object will be instantiated and called as such:\\n * var obj = new FrequencyTracker()\\n * obj.add(number)\\n * obj.deleteOne(number)\\n * var param_3 = obj.hasFrequency(frequency)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar FrequencyTracker = function() {\\n    this.freq = {};\\n    this.hasFreq = {};\\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.add = function(number) {\\n    this.freq[number] = ++this.freq[number] || 1;\\n    if (this.freq[number] > 1) {\\n        this.hasFreq[this.freq[number] - 1].delete(number);\\n    }\\n    if (!this.hasFreq[this.freq[number]]) {\\n        this.hasFreq[this.freq[number]] = new Set();\\n    }\\n    this.hasFreq[this.freq[number]].add(number);\\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.deleteOne = function(number) {\\n    if (this.freq[number]) {\\n        this.hasFreq[this.freq[number]].delete(number);\\n        this.freq[number]--;\\n        if (this.freq[number]) {\\n            this.hasFreq[this.freq[number]].add(number);\\n        }\\n    }\\n};\\n\\n/** \\n * @param {number} frequency\\n * @return {boolean}\\n */\\nFrequencyTracker.prototype.hasFrequency = function(frequency) {\\n    return !!this.hasFreq[frequency]?.size;\\n};\\n\\n/** \\n * Your FrequencyTracker object will be instantiated and called as such:\\n * var obj = new FrequencyTracker()\\n * obj.add(number)\\n * obj.deleteOne(number)\\n * var param_3 = obj.hasFrequency(frequency)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049318,
                "title": "c-using-two-maps-simple-easy",
                "content": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int>mp;   // element -> its count/frequency\\n    unordered_map<int,int>freq;  // any frequency -> number of elements with this frequency\\n    \\n    FrequencyTracker() {\\n    }\\n    \\n    void add(int number) {\\n        freq[mp[number]]--;\\n        mp[number]++;\\n        freq[mp[number]]++;      \\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number]==0){return;}\\n        freq[mp[number]]--;\\n        mp[number]--;\\n        freq[mp[number]]++;\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq[frequency]>0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int>mp;   // element -> its count/frequency\\n    unordered_map<int,int>freq;  // any frequency -> number of elements with this frequency\\n    \\n    FrequencyTracker() {\\n    }\\n    \\n    void add(int number) {\\n        freq[mp[number]]--;\\n        mp[number]++;\\n        freq[mp[number]]++;      \\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number]==0){return;}\\n        freq[mp[number]]--;\\n        mp[number]--;\\n        freq[mp[number]]++;\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq[frequency]>0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774804,
                "title": "two-unordered-maps-easy-c-beats-92",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse **two unordered maps**, one will **store the frequency of the numbers** and one will **store the current frequency of the numbers**.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> freq,checkfreq;\\n    FrequencyTracker() {}\\n    void add(int number) {\\n        if(freq.find(number)==freq.end())\\n        {\\n            freq[number]++;\\n            checkfreq[freq[number]]++;\\n        }\\n        else\\n        {\\n            checkfreq[freq[number]]--;\\n            if(checkfreq[freq[number]]==0) checkfreq.erase(freq[number]);\\n            freq[number]++;\\n            checkfreq[freq[number]]++;\\n        }\\n    }\\n    void deleteOne(int number) {\\n        if(freq.find(number)!=freq.end())\\n        {\\n            checkfreq[freq[number]]--;\\n            if(checkfreq[freq[number]]==0) checkfreq.erase(freq[number]);\\n            freq[number]--;\\n            if(freq[number]>0) checkfreq[freq[number]]++;\\n            if(freq[number]==0) freq.erase(number);\\n        }\\n    }\\n    bool hasFrequency(int f) {\\n        return checkfreq.find(f)!=checkfreq.end();\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/6e97149a-c02f-4cdb-969c-64c92f8b69f0_1689528824.3558578.jpeg)",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> freq,checkfreq;\\n    FrequencyTracker() {}\\n    void add(int number) {\\n        if(freq.find(number)==freq.end())\\n        {\\n            freq[number]++;\\n            checkfreq[freq[number]]++;\\n        }\\n        else\\n        {\\n            checkfreq[freq[number]]--;\\n            if(checkfreq[freq[number]]==0) checkfreq.erase(freq[number]);\\n            freq[number]++;\\n            checkfreq[freq[number]]++;\\n        }\\n    }\\n    void deleteOne(int number) {\\n        if(freq.find(number)!=freq.end())\\n        {\\n            checkfreq[freq[number]]--;\\n            if(checkfreq[freq[number]]==0) checkfreq.erase(freq[number]);\\n            freq[number]--;\\n            if(freq[number]>0) checkfreq[freq[number]]++;\\n            if(freq[number]==0) freq.erase(number);\\n        }\\n    }\\n    bool hasFrequency(int f) {\\n        return checkfreq.find(f)!=checkfreq.end();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577990,
                "title": "easy-solution-using-2-arrays",
                "content": "# Complexity\\n- Time complexity : $$O(Q)$$ (per query - $$O(1)$$)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    vector<int> nums; // stores the frequency of the number \"i\"\\n    vector<int> freq; // stores the count of numbers having frequency \"i\"\\n    FrequencyTracker() {\\n        nums.resize(100001,0);\\n        freq.resize(100001,0);\\n    }\\n    \\n    void add(int num) {\\n        --freq[nums[num]];\\n        ++nums[num];\\n        ++freq[nums[num]];\\n    }\\n    \\n    void deleteOne(int num) {\\n        if(nums[num] == 0) return;\\n        \\n        --freq[nums[num]];\\n        --nums[num];\\n        ++freq[nums[num]];\\n    }\\n    \\n    bool hasFrequency(int fr) {\\n        return freq[fr]>0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    vector<int> nums; // stores the frequency of the number \"i\"\\n    vector<int> freq; // stores the count of numbers having frequency \"i\"\\n    FrequencyTracker() {\\n        nums.resize(100001,0);\\n        freq.resize(100001,0);\\n    }\\n    \\n    void add(int num) {\\n        --freq[nums[num]];\\n        ++nums[num];\\n        ++freq[nums[num]];\\n    }\\n    \\n    void deleteOne(int num) {\\n        if(nums[num] == 0) return;\\n        \\n        --freq[nums[num]];\\n        --nums[num];\\n        ++freq[nums[num]];\\n    }\\n    \\n    bool hasFrequency(int fr) {\\n        return freq[fr]>0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561203,
                "title": "best-c-code-optimized",
                "content": "# Code\\n### Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> mp;\\n    unordered_map<int,unordered_set<int>> m2;\\n    FrequencyTracker() {}\\n    \\n    void add(int number) {\\n        if(mp.find(number) != mp.end()){\\n            m2[mp[number]].erase(number);\\n            m2[mp[number] + 1].insert(number);\\n        }\\n        else \\n            m2[1].insert(number);\\n        mp[number] ++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp.find(number) != mp.end()){\\n            m2[mp[number]].erase(number);\\n            m2[mp[number] - 1].insert(number);\\n            mp[number] --;\\n            if(mp[number] == 0)\\n                mp.erase(number);\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(m2[frequency].size() > 0)\\n            return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> mp;\\n    unordered_map<int,unordered_set<int>> m2;\\n    FrequencyTracker() {}\\n    \\n    void add(int number) {\\n        if(mp.find(number) != mp.end()){\\n            m2[mp[number]].erase(number);\\n            m2[mp[number] + 1].insert(number);\\n        }\\n        else \\n            m2[1].insert(number);\\n        mp[number] ++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp.find(number) != mp.end()){\\n            m2[mp[number]].erase(number);\\n            m2[mp[number] - 1].insert(number);\\n            mp[number] --;\\n            if(mp[number] == 0)\\n                mp.erase(number);\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(m2[frequency].size() > 0)\\n            return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560555,
                "title": "java-easy-100-solution-with-2-hashmaps",
                "content": "```java\\nimport java.util.HashMap;\\nimport java.util.Map;\\nimport java.util.TreeMap;\\n\\nclass FrequencyTracker {\\n    private final Map<Integer, Integer> numbers;\\n    private final Map<Integer, Integer> occurrences;\\n\\n    public FrequencyTracker() {\\n        numbers = new HashMap<>();\\n        occurrences = new HashMap<>();\\n    }\\n\\n    public void add(final int number) {\\n        final int oldFreq = numbers.getOrDefault(number, 0);\\n        final int newFreq = oldFreq + 1;\\n\\n        numbers.put(number, newFreq);\\n\\n        updateOccurrences(oldFreq, newFreq);\\n    }\\n\\n    public void deleteOne(final int number) {\\n        if(!numbers.containsKey(number))\\n            return;\\n\\n        final int oldFreq = numbers.get(number);\\n        final int newFreq = oldFreq - 1;\\n\\n        numbers.put(number, newFreq);\\n\\n        updateOccurrences(oldFreq, newFreq);\\n\\n        if(newFreq == 0)\\n            numbers.remove(number);\\n    }\\n\\n    public boolean hasFrequency(final int frequency) {\\n        return occurrences.containsKey(frequency);\\n    }\\n\\n    private void updateOccurrences(final int oldFreq, final int newFreq) {\\n        if(oldFreq > 0) {\\n            final int count = occurrences.get(oldFreq);\\n\\n            if(count == 1)\\n                occurrences.remove(oldFreq);\\n            else\\n                occurrences.put(oldFreq, count - 1);\\n        }\\n\\n        occurrences.put(newFreq, occurrences.getOrDefault(newFreq, 0) + 1);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nimport java.util.HashMap;\\nimport java.util.Map;\\nimport java.util.TreeMap;\\n\\nclass FrequencyTracker {\\n    private final Map<Integer, Integer> numbers;\\n    private final Map<Integer, Integer> occurrences;\\n\\n    public FrequencyTracker() {\\n        numbers = new HashMap<>();\\n        occurrences = new HashMap<>();\\n    }\\n\\n    public void add(final int number) {\\n        final int oldFreq = numbers.getOrDefault(number, 0);\\n        final int newFreq = oldFreq + 1;\\n\\n        numbers.put(number, newFreq);\\n\\n        updateOccurrences(oldFreq, newFreq);\\n    }\\n\\n    public void deleteOne(final int number) {\\n        if(!numbers.containsKey(number))\\n            return;\\n\\n        final int oldFreq = numbers.get(number);\\n        final int newFreq = oldFreq - 1;\\n\\n        numbers.put(number, newFreq);\\n\\n        updateOccurrences(oldFreq, newFreq);\\n\\n        if(newFreq == 0)\\n            numbers.remove(number);\\n    }\\n\\n    public boolean hasFrequency(final int frequency) {\\n        return occurrences.containsKey(frequency);\\n    }\\n\\n    private void updateOccurrences(final int oldFreq, final int newFreq) {\\n        if(oldFreq > 0) {\\n            final int count = occurrences.get(oldFreq);\\n\\n            if(count == 1)\\n                occurrences.remove(oldFreq);\\n            else\\n                occurrences.put(oldFreq, count - 1);\\n        }\\n\\n        occurrences.put(newFreq, occurrences.getOrDefault(newFreq, 0) + 1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529672,
                "title": "java-all-o-1-operations",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCode is self explanatory.\\n\\n# Complexity\\ntime:  add, delete, and check freq, all O(1)\\nspace: O(N)\\n# Code\\nSome optimization:\\nYou can change countsByFrequencies to Map<Integer, Integer> to track the count of each freq.\\n```\\nclass FrequencyTracker {\\n    Map<Integer, Integer> freqByNumber = new HashMap<>();\\n    Map<Integer, Integer> countsByFrequencies = new HashMap<>();\\n    public FrequencyTracker() {}\\n    \\n    public void add(int number) {\\n        int freq = freqByNumber.getOrDefault(number, 0);\\n        if (freq != 0) countsByFrequencies.put(freq, countsByFrequencies.get(freq) - 1);\\n        countsByFrequencies.put(freq + 1, countsByFrequencies.getOrDefault(freq + 1, 0) + 1);\\n        freqByNumber.put(number, freq + 1);\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if (!freqByNumber.containsKey(number)) return;\\n        int freq = freqByNumber.get(number);\\n        countsByFrequencies.put(freq, countsByFrequencies.get(freq) - 1);\\n        if (freq == 1) {\\n            freqByNumber.remove(number);\\n            return;\\n        }\\n        countsByFrequencies.put(freq - 1, countsByFrequencies.getOrDefault(freq - 1, 0) + 1);\\n        freqByNumber.put(number, freq - 1);\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return countsByFrequencies.getOrDefault(frequency, 0)> 0;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    Map<Integer, Integer> freqByNumber = new HashMap<>();\\n    Map<Integer, Integer> countsByFrequencies = new HashMap<>();\\n    public FrequencyTracker() {}\\n    \\n    public void add(int number) {\\n        int freq = freqByNumber.getOrDefault(number, 0);\\n        if (freq != 0) countsByFrequencies.put(freq, countsByFrequencies.get(freq) - 1);\\n        countsByFrequencies.put(freq + 1, countsByFrequencies.getOrDefault(freq + 1, 0) + 1);\\n        freqByNumber.put(number, freq + 1);\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if (!freqByNumber.containsKey(number)) return;\\n        int freq = freqByNumber.get(number);\\n        countsByFrequencies.put(freq, countsByFrequencies.get(freq) - 1);\\n        if (freq == 1) {\\n            freqByNumber.remove(number);\\n            return;\\n        }\\n        countsByFrequencies.put(freq - 1, countsByFrequencies.getOrDefault(freq - 1, 0) + 1);\\n        freqByNumber.put(number, freq - 1);\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return countsByFrequencies.getOrDefault(frequency, 0)> 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506165,
                "title": "python-elegant-short-o-1-two-hash-tables",
                "content": "# Complexity\\n- Time complexity (each operation): $$O(1)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.__count: dict[int, int] = defaultdict(int)\\n        self.__freq: dict[int, int] = defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        self.__freq[self.__count[number]] -= 1\\n        self.__count[number] += 1\\n        self.__freq[self.__count[number]] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        if self.__count[number] > 0:\\n            self.__freq[self.__count[number]] -= 1\\n            self.__count[number] -= 1\\n            self.__freq[self.__count[number]] += 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.__freq[frequency] > 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.__count: dict[int, int] = defaultdict(int)\\n        self.__freq: dict[int, int] = defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        self.__freq[self.__count[number]] -= 1\\n        self.__count[number] += 1\\n        self.__freq[self.__count[number]] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        if self.__count[number] > 0:\\n            self.__freq[self.__count[number]] -= 1\\n            self.__count[number] -= 1\\n            self.__freq[self.__count[number]] += 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.__freq[frequency] > 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499648,
                "title": "java-2-maps",
                "content": "One map to keep track of the element\\'s current frequency and one to keep track of elements with that frequency. Recalculating of `frequencyToElements` map extract in separate method which is used with `previousFrequency` parameter (`current - 1 `/ `current + 1` for add / delete)\\n\\n```\\nclass FrequencyTracker {\\n\\n  private final Map<Integer, Integer> elementToFrequency;\\n  private final Map<Integer, Set<Integer>> frequencyToElements;\\n\\n  public FrequencyTracker() {\\n    elementToFrequency = new HashMap<>();\\n    frequencyToElements = new HashMap<>();\\n  }\\n\\n  public void add(int number) {\\n    elementToFrequency.put(number, elementToFrequency.getOrDefault(number, 0) + 1);\\n    recomputeFrequency(number, elementToFrequency.get(number) - 1);\\n  }\\n\\n  public void deleteOne(int number) {\\n    if (elementToFrequency.containsKey(number)) {\\n      elementToFrequency.put(number, elementToFrequency.get(number) - 1);\\n      recomputeFrequency(number, elementToFrequency.get(number) + 1);\\n\\n      if (elementToFrequency.get(number) == 0)\\n        elementToFrequency.remove(number);\\n    }\\n  }\\n\\n  private void recomputeFrequency(int number, int previousFrequency) {\\n    int frequency = elementToFrequency.get(number);\\n\\n    if (previousFrequency > 0) {\\n      frequencyToElements.get(previousFrequency).remove(number);\\n      if (frequencyToElements.get(previousFrequency).size() == 0)\\n        frequencyToElements.remove(previousFrequency);\\n    }\\n\\n    frequencyToElements.computeIfAbsent(frequency, p -> new HashSet<>()).add(number);\\n  }\\n\\n  public boolean hasFrequency(int frequency) {\\n    return frequencyToElements.containsKey(frequency);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n\\n  private final Map<Integer, Integer> elementToFrequency;\\n  private final Map<Integer, Set<Integer>> frequencyToElements;\\n\\n  public FrequencyTracker() {\\n    elementToFrequency = new HashMap<>();\\n    frequencyToElements = new HashMap<>();\\n  }\\n\\n  public void add(int number) {\\n    elementToFrequency.put(number, elementToFrequency.getOrDefault(number, 0) + 1);\\n    recomputeFrequency(number, elementToFrequency.get(number) - 1);\\n  }\\n\\n  public void deleteOne(int number) {\\n    if (elementToFrequency.containsKey(number)) {\\n      elementToFrequency.put(number, elementToFrequency.get(number) - 1);\\n      recomputeFrequency(number, elementToFrequency.get(number) + 1);\\n\\n      if (elementToFrequency.get(number) == 0)\\n        elementToFrequency.remove(number);\\n    }\\n  }\\n\\n  private void recomputeFrequency(int number, int previousFrequency) {\\n    int frequency = elementToFrequency.get(number);\\n\\n    if (previousFrequency > 0) {\\n      frequencyToElements.get(previousFrequency).remove(number);\\n      if (frequencyToElements.get(previousFrequency).size() == 0)\\n        frequencyToElements.remove(previousFrequency);\\n    }\\n\\n    frequencyToElements.computeIfAbsent(frequency, p -> new HashSet<>()).add(number);\\n  }\\n\\n  public boolean hasFrequency(int frequency) {\\n    return frequencyToElements.containsKey(frequency);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497882,
                "title": "python3-2-maps-simple-explained",
                "content": "# Intuition\\nKeep track of frequency. Loop and find number with `frequency`.\\n![image.png](https://assets.leetcode.com/users/images/7b8b7e9d-e88f-4df9-9c60-9bb94575faea_1683486745.3148494.png)\\n\\n\\n# Approach\\nThe idea is to use 2 dictionaries to keep track of frequencies of numbers.\\nfreq1 format: {number: frequency}\\nfreq2 format: {frequency: number of `number`s (with frequency of `frequency`)}\\nadd(number):\\n.....   Since the current frequency will increase, that means the number will not have a frequency of $$n$$. So, `self.freq2[self.freq1[number]]` decreases because the number of numbers with that frequency loses 1.\\n\\ndeleteOne(number):\\n.....   Same thing as add() but only delete an occurence if there is at least one occurence of a number. \\n> The data structure may not contain `number`, and in this case nothing is deleted.\\n---\\n\\n\\n\\n# Code\\n```\\nclass FrequencyTracker:\\n    def __init__(self):\\n        self.freq1 = collections.defaultdict(lambda: 0)\\n        self.freq2 = collections.defaultdict(lambda: 0)\\n\\n    def add(self, number: int) -> None:\\n        self.freq2[self.freq1[number]] -= 1\\n        self.freq1[number] += 1\\n        self.freq2[self.freq1[number]] += 1\\n    def deleteOne(self, number: int) -> None:\\n        if self.freq1[number] > 0:\\n            self.freq2[self.freq1[number]] -= 1\\n            self.freq1[number] -= 1\\n            self.freq2[self.freq1[number]] += 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        \"\"\"\\n        \"self.freq[frequency]\" results in the number of numbers with \\n        a frequency of \"frequency\", so access \"frequency\" from \\n        self.freq2 to know whether at least one number has such a\\n        frequency.\\n        \"\"\"\\n        return self.freq2[frequency] > 0\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FrequencyTracker:\\n    def __init__(self):\\n        self.freq1 = collections.defaultdict(lambda: 0)\\n        self.freq2 = collections.defaultdict(lambda: 0)\\n\\n    def add(self, number: int) -> None:\\n        self.freq2[self.freq1[number]] -= 1\\n        self.freq1[number] += 1\\n        self.freq2[self.freq1[number]] += 1\\n    def deleteOne(self, number: int) -> None:\\n        if self.freq1[number] > 0:\\n            self.freq2[self.freq1[number]] -= 1\\n            self.freq1[number] -= 1\\n            self.freq2[self.freq1[number]] += 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        \"\"\"\\n        \"self.freq[frequency]\" results in the number of numbers with \\n        a frequency of \"frequency\", so access \"frequency\" from \\n        self.freq2 to know whether at least one number has such a\\n        frequency.\\n        \"\"\"\\n        return self.freq2[frequency] > 0\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497359,
                "title": "excellent-performance-after-an-insight",
                "content": "# Intuition\\n\\uD83D\\uDD96 We want 3 things to be fast:\\n- a way to update the frequency of any value (its number of appearances),\\n- a way to update the number of values with a certain frequency,\\n- a way to find if there is at least one number with a certain number of appearances.\\n\\n\\uD83D\\uDECE Hash maps are ideal for this.\\nLet\\'s use them for counting the things above!\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMaintain a couple of mappings:\\n- from each unique value to its frequency\\n- from each unique frequency to the number of unique values appearing that number of times\\n\\nCarefully implement the required operations, taking care of specific situations:\\n- for adding one appearance of a number:\\n    - remove its previous frequency altogether if it was the only value with that frequency\\n\\n    - just decrease the number of values having the previous frequency otherwise\\n- for removing one appearance of a number:\\n    - do nothing if the number doesn\\'t appear at all\\n    - remove the number altogether if it only had one appearance\\n    - just decrease the frequency AND increase the number of values that have $previousFrequency-1$ appearances, otherwise\\n\\n    - remove its previous frequency altogether if the number was the only value with that frequency\\n    - just decrease the number of values having the previous frequency otherwise\\n\\n# Complexity\\n- Time complexity:\\n$$\\u0398(1)$$ for every operation: ``Add``, ``DeleteOne``, and ``HasFrequency``\\n\\n- Space complexity:\\n$$\\u0398(1)$$ for every operation: ``Add``, ``DeleteOne``, and ``HasFrequency``\\nThe overall space that\\'s used is $$\\u0398(d)+\\u0398(k)$$ for d distinct values, having k different frequencies.\\nExample: Adding these 9 values: [3, 3, 5, 6, 8, 8, 8, 9, 9] leads to:\\n    - d = 5 distinct values: 3, 5, 6, 8, and 9\\n    - k = 3 distinct frequencies: 1 (for 5 and 6), 2 (for 3 and 9), and 3 (for 8)\\n\\nSo these take up space proportional to $$d + k = 8 $$\\n\\n## \\uD83D\\uDC40 Notes\\n1. The update of the previous frequency of a value is identical when it is added / removed, so it can be extracted and reused.\\n1. When the range of values is relatively small, we can use slices instead of maps, but that reduces the generality. So this is better.\\n\\n# Code\\n```Go []\\ntype FrequencyTracker struct {\\n    valuesToFrequencies map[int]int\\n    frequenciesToValues map[int]int\\n}\\n\\nfunc Constructor() FrequencyTracker {\\n    return FrequencyTracker {\\n        valuesToFrequencies: make(map[int]int),\\n        frequenciesToValues: make(map[int]int),\\n    }    \\n}\\n\\nfunc (f *FrequencyTracker) Add(number int) {\\n    appearances := f.valuesToFrequencies[number]\\n    f.valuesToFrequencies[number] = appearances + 1\\n    f.frequenciesToValues[appearances + 1]++\\n\\n    frequencyAppearances := f.frequenciesToValues[appearances]\\n    if frequencyAppearances == 1  {\\n        delete(f.frequenciesToValues, appearances)\\n    } else {\\n        f.frequenciesToValues[appearances]--\\n    }\\n}\\n\\nfunc (f *FrequencyTracker) DeleteOne(number int) {\\n    appearances := f.valuesToFrequencies[number]\\n    if appearances == 0 {\\n        return\\n    }\\n\\n    if appearances == 1 {\\n        delete(f.valuesToFrequencies, number)\\n    } else {\\n        f.valuesToFrequencies[number] = appearances - 1\\n        f.frequenciesToValues[appearances - 1]++\\n    }\\n\\n    frequencyAppearances := f.frequenciesToValues[appearances]\\n    if frequencyAppearances == 1 {\\n        delete(f.frequenciesToValues, appearances)\\n    } else {\\n        f.frequenciesToValues[appearances]--\\n    }\\n}\\n\\nfunc (f *FrequencyTracker) HasFrequency(frequency int) bool {\\n    return f.frequenciesToValues[frequency] != 0\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.Add(number);\\n * obj.DeleteOne(number);\\n * param_3 := obj.HasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Go",
                    "Design",
                    "Hash Function"
                ],
                "code": "```Go []\\ntype FrequencyTracker struct {\\n    valuesToFrequencies map[int]int\\n    frequenciesToValues map[int]int\\n}\\n\\nfunc Constructor() FrequencyTracker {\\n    return FrequencyTracker {\\n        valuesToFrequencies: make(map[int]int),\\n        frequenciesToValues: make(map[int]int),\\n    }    \\n}\\n\\nfunc (f *FrequencyTracker) Add(number int) {\\n    appearances := f.valuesToFrequencies[number]\\n    f.valuesToFrequencies[number] = appearances + 1\\n    f.frequenciesToValues[appearances + 1]++\\n\\n    frequencyAppearances := f.frequenciesToValues[appearances]\\n    if frequencyAppearances == 1  {\\n        delete(f.frequenciesToValues, appearances)\\n    } else {\\n        f.frequenciesToValues[appearances]--\\n    }\\n}\\n\\nfunc (f *FrequencyTracker) DeleteOne(number int) {\\n    appearances := f.valuesToFrequencies[number]\\n    if appearances == 0 {\\n        return\\n    }\\n\\n    if appearances == 1 {\\n        delete(f.valuesToFrequencies, number)\\n    } else {\\n        f.valuesToFrequencies[number] = appearances - 1\\n        f.frequenciesToValues[appearances - 1]++\\n    }\\n\\n    frequencyAppearances := f.frequenciesToValues[appearances]\\n    if frequencyAppearances == 1 {\\n        delete(f.frequenciesToValues, appearances)\\n    } else {\\n        f.frequenciesToValues[appearances]--\\n    }\\n}\\n\\nfunc (f *FrequencyTracker) HasFrequency(frequency int) bool {\\n    return f.frequenciesToValues[frequency] != 0\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.Add(number);\\n * obj.DeleteOne(number);\\n * param_3 := obj.HasFrequency(frequency);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3496716,
                "title": "python-solution-using-defaultdict",
                "content": "# Code\\n```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.di=defaultdict(int)\\n        self.freq=defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        self.freq[self.di[number]]=max(0,self.freq[self.di[number]]-1)\\n        self.di[number]+=1\\n        self.freq[self.di[number]]+=1\\n\\n    def deleteOne(self, number: int) -> None:\\n        self.freq[self.di[number]]=max(0,self.freq[self.di[number]]-1)\\n        self.di[number]=max(self.di[number]-1,0)\\n        self.freq[self.di[number]]+=1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] != 0\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.di=defaultdict(int)\\n        self.freq=defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        self.freq[self.di[number]]=max(0,self.freq[self.di[number]]-1)\\n        self.di[number]+=1\\n        self.freq[self.di[number]]+=1\\n\\n    def deleteOne(self, number: int) -> None:\\n        self.freq[self.di[number]]=max(0,self.freq[self.di[number]]-1)\\n        self.di[number]=max(self.di[number]-1,0)\\n        self.freq[self.di[number]]+=1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] != 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496372,
                "title": "map",
                "content": "# Code\\n```\\nclass FrequencyTracker {\\n    map<int,int> mp;\\n    map<int,set<int>> fr;\\npublic:\\n    void add(int n) {\\n        if(!mp.count(n)){\\n            mp[n]++;\\n            fr[mp[n]].insert(n);\\n        }else{\\n            mp[n]++;\\n            fr[mp[n]-1].erase(n);\\n            if(fr[mp[n]-1].size() == 0) fr.erase(mp[n]-1);\\n            fr[mp[n]].insert(n);\\n        }\\n    }\\n    void deleteOne(int n) {\\n        if(!mp.count(n)) return;\\n        mp[n]--;\\n        fr[mp[n]+1].erase(n);\\n        if(fr[mp[n]+1].size() == 0) fr.erase(mp[n]+1);\\n        if(mp[n] == 0) mp.erase(n);\\n        else fr[mp[n]].insert(n);   \\n    }\\n    bool hasFrequency(int f) {\\n        return fr.count(f);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    map<int,int> mp;\\n    map<int,set<int>> fr;\\npublic:\\n    void add(int n) {\\n        if(!mp.count(n)){\\n            mp[n]++;\\n            fr[mp[n]].insert(n);\\n        }else{\\n            mp[n]++;\\n            fr[mp[n]-1].erase(n);\\n            if(fr[mp[n]-1].size() == 0) fr.erase(mp[n]-1);\\n            fr[mp[n]].insert(n);\\n        }\\n    }\\n    void deleteOne(int n) {\\n        if(!mp.count(n)) return;\\n        mp[n]--;\\n        fr[mp[n]+1].erase(n);\\n        if(fr[mp[n]+1].size() == 0) fr.erase(mp[n]+1);\\n        if(mp[n] == 0) mp.erase(n);\\n        else fr[mp[n]].insert(n);   \\n    }\\n    bool hasFrequency(int f) {\\n        return fr.count(f);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496106,
                "title": "2-hashmap-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar FrequencyTracker = function() {\\n    this.map={}  \\n    this.res={}\\n    \\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.add = function(number) {\\n    if (this.map[number]!==undefined){\\n        \\n          this.res[this.map[number]]-=1\\n          \\n          if (this.res[this.map[number]]===0) delete this.res[this.map[number]]\\n          \\n          this.map[number]+=1\\n          if (this.res[this.map[number]]!==undefined) this.res[this.map[number]]+=1\\n          else {\\n            this.res[this.map[number]]=1\\n          }\\n        \\n        \\n    }else{\\n        \\n        this.map[number]=1\\n        if (this.res[this.map[number]]!==undefined)this.res[this.map[number]]+=1\\n        else this.res[this.map[number]]=1\\n    }\\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.deleteOne = function(number) {\\n    \\n    if (this.map[number]!==undefined){\\n        \\n          if (this.res[this.map[number]]!==undefined){\\n              this.res[this.map[number]]-=1\\n              if (this.res[this.map[number]]===0) delete this.res[this.map[number]]\\n              this.map[number]-=1\\n              if (this.map[number]===0)delete this.map[number]  \\n              if (this.res[this.map[number]]!==undefined)this.res[this.map[number]]+=1\\n              else this.res[this.map[number]]=1\\n\\n          }\\n      }\\n      \\n         \\n    \\n};\\n\\n/** \\n * @param {number} frequency\\n * @return {boolean}\\n */\\nFrequencyTracker.prototype.hasFrequency = function(frequency) {\\n    return this.res[frequency]!==undefined\\n};\\n\\n/** \\n * Your FrequencyTracker object will be instantiated and called as such:\\n * var obj = new FrequencyTracker()\\n * obj.add(number)\\n * obj.deleteOne(number)\\n * var param_3 = obj.hasFrequency(frequency)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar FrequencyTracker = function() {\\n    this.map={}  \\n    this.res={}\\n    \\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.add = function(number) {\\n    if (this.map[number]!==undefined){\\n        \\n          this.res[this.map[number]]-=1\\n          \\n          if (this.res[this.map[number]]===0) delete this.res[this.map[number]]\\n          \\n          this.map[number]+=1\\n          if (this.res[this.map[number]]!==undefined) this.res[this.map[number]]+=1\\n          else {\\n            this.res[this.map[number]]=1\\n          }\\n        \\n        \\n    }else{\\n        \\n        this.map[number]=1\\n        if (this.res[this.map[number]]!==undefined)this.res[this.map[number]]+=1\\n        else this.res[this.map[number]]=1\\n    }\\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.deleteOne = function(number) {\\n    \\n    if (this.map[number]!==undefined){\\n        \\n          if (this.res[this.map[number]]!==undefined){\\n              this.res[this.map[number]]-=1\\n              if (this.res[this.map[number]]===0) delete this.res[this.map[number]]\\n              this.map[number]-=1\\n              if (this.map[number]===0)delete this.map[number]  \\n              if (this.res[this.map[number]]!==undefined)this.res[this.map[number]]+=1\\n              else this.res[this.map[number]]=1\\n\\n          }\\n      }\\n      \\n         \\n    \\n};\\n\\n/** \\n * @param {number} frequency\\n * @return {boolean}\\n */\\nFrequencyTracker.prototype.hasFrequency = function(frequency) {\\n    return this.res[frequency]!==undefined\\n};\\n\\n/** \\n * Your FrequencyTracker object will be instantiated and called as such:\\n * var obj = new FrequencyTracker()\\n * obj.add(number)\\n * obj.deleteOne(number)\\n * var param_3 = obj.hasFrequency(frequency)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3496004,
                "title": "python-100-runtime-two-dictionaries-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMake use of two dictionaries one to maintain the numbers count and one to\\nmaintain frequencies for fast access\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.ds = defaultdict(int)\\n        self.fs = defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        self.fs[self.ds[number]] -= 1\\n        self.ds[number] += 1\\n        self.fs[self.ds[number]] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        self.fs[self.ds[number]] -= 1\\n        self.ds[number] = max(0,self.ds[number] - 1)\\n        self.fs[self.ds[number]] += 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.fs[frequency] > 0\\n        \\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.ds = defaultdict(int)\\n        self.fs = defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        self.fs[self.ds[number]] -= 1\\n        self.ds[number] += 1\\n        self.fs[self.ds[number]] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        self.fs[self.ds[number]] -= 1\\n        self.ds[number] = max(0,self.ds[number] - 1)\\n        self.fs[self.ds[number]] += 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.fs[frequency] > 0\\n        \\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495935,
                "title": "java-all-three-operations-in-o-1-time-hashing",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nadd - O(1)\\ndeleteOne -O(1)\\nhasFrequency - O(1)\\n- Space complexity:\\n- two arrays of size 10^5 (constraints)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n  \\n  int[] count,freq;\\n    \\n    \\n    public FrequencyTracker() {\\n        count = new int[100001];\\n        freq = new int[100001];\\n\\n        \\n    }\\n    \\n    public void add(int n) {\\n      \\n        \\n       freq[count[n]] += (count[n] == 0) ? 0 : -1;\\n        \\n        count[n]++;\\n        \\n        freq[count[n]]++;\\n        \\n        \\n        \\n\\n    }\\n    \\n    public void deleteOne(int n) {\\n        \\n      \\n        freq[count[n]] += (freq[count[n]] == 0) ? 0 : - 1;\\n        \\n        count[n] += (count[n] == 0) ? 0 : -1;\\n        \\n        if(count[n] != 0)\\n        {\\n            freq[count[n]]++;\\n        }\\n        \\n        \\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        \\n        \\n        \\n    \\n\\n        return freq[frequency] != 0; \\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n  \\n  int[] count,freq;\\n    \\n    \\n    public FrequencyTracker() {\\n        count = new int[100001];\\n        freq = new int[100001];\\n\\n        \\n    }\\n    \\n    public void add(int n) {\\n      \\n        \\n       freq[count[n]] += (count[n] == 0) ? 0 : -1;\\n        \\n        count[n]++;\\n        \\n        freq[count[n]]++;\\n        \\n        \\n        \\n\\n    }\\n    \\n    public void deleteOne(int n) {\\n        \\n      \\n        freq[count[n]] += (freq[count[n]] == 0) ? 0 : - 1;\\n        \\n        count[n] += (count[n] == 0) ? 0 : -1;\\n        \\n        if(count[n] != 0)\\n        {\\n            freq[count[n]]++;\\n        }\\n        \\n        \\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        \\n        \\n        \\n    \\n\\n        return freq[frequency] != 0; \\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495512,
                "title": "java-arrays",
                "content": "```\\nclass FrequencyTracker {\\n    int[] ar = new int[100004];\\n//     freq, no of occurence of freq\\n    int[] freq = new int[100004];\\n    \\n    public FrequencyTracker() {\\n    }\\n    \\n    public void add(int number) {\\n        int prevFreq = ar[number];\\n        ar[number]++;    \\n        if(freq[ prevFreq] > 0){\\n            freq[prevFreq]--;\\n        }\\n        freq[ar[number]]++;\\n        return;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(ar[number] > 0){\\n            int curFreq = ar[number];\\n            ar[number]--;\\n            \\n            freq[curFreq]--;\\n            freq[ar[number]]++;\\n        }\\n        return;\\n        \\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return freq[frequency] > 0; \\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    int[] ar = new int[100004];\\n//     freq, no of occurence of freq\\n    int[] freq = new int[100004];\\n    \\n    public FrequencyTracker() {\\n    }\\n    \\n    public void add(int number) {\\n        int prevFreq = ar[number];\\n        ar[number]++;    \\n        if(freq[ prevFreq] > 0){\\n            freq[prevFreq]--;\\n        }\\n        freq[ar[number]]++;\\n        return;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(ar[number] > 0){\\n            int curFreq = ar[number];\\n            ar[number]--;\\n            \\n            freq[curFreq]--;\\n            freq[ar[number]]++;\\n        }\\n        return;\\n        \\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return freq[frequency] > 0; \\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495288,
                "title": "easy-to-understnd-java-solution-hashmap",
                "content": "# Intuition\\nOne possible optimization is to use two hash maps: one to keep track of the frequency of each number, and another to keep track of the numbers with a given frequency\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    HashMap<Integer, Integer> f;\\n    HashMap<Integer, Set<Integer>> ftn;\\n\\n    public FrequencyTracker() {\\n        f = new HashMap<>();\\n        ftn = new HashMap<>();\\n    }\\n\\n    public void add(int number) {\\n        int old = f.getOrDefault(number, 0);\\n        int cur = old + 1;\\n        f.put(number, cur);\\n        ftn.computeIfAbsent(old, k -> new HashSet<>()).remove(number);\\n        ftn.computeIfAbsent(cur, k -> new HashSet<>()).add(number);\\n    }\\n\\n    public void deleteOne(int number) {\\n        if (f.containsKey(number)) {\\n            int old = f.get(number);\\n            int cur = old - 1;\\n            f.put(number, cur);\\n            ftn.computeIfAbsent(old, k -> new HashSet<>()).remove(number);\\n            if (cur > 0) {\\n                ftn.computeIfAbsent(cur, k -> new HashSet<>()).add(number);\\n            } else {\\n                f.remove(number);\\n            }\\n        }\\n    }\\n\\n    public boolean hasFrequency(int frequency) {\\n        return ftn.containsKey(frequency) && !ftn.get(frequency).isEmpty();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    HashMap<Integer, Integer> f;\\n    HashMap<Integer, Set<Integer>> ftn;\\n\\n    public FrequencyTracker() {\\n        f = new HashMap<>();\\n        ftn = new HashMap<>();\\n    }\\n\\n    public void add(int number) {\\n        int old = f.getOrDefault(number, 0);\\n        int cur = old + 1;\\n        f.put(number, cur);\\n        ftn.computeIfAbsent(old, k -> new HashSet<>()).remove(number);\\n        ftn.computeIfAbsent(cur, k -> new HashSet<>()).add(number);\\n    }\\n\\n    public void deleteOne(int number) {\\n        if (f.containsKey(number)) {\\n            int old = f.get(number);\\n            int cur = old - 1;\\n            f.put(number, cur);\\n            ftn.computeIfAbsent(old, k -> new HashSet<>()).remove(number);\\n            if (cur > 0) {\\n                ftn.computeIfAbsent(cur, k -> new HashSet<>()).add(number);\\n            } else {\\n                f.remove(number);\\n            }\\n        }\\n    }\\n\\n    public boolean hasFrequency(int frequency) {\\n        return ftn.containsKey(frequency) && !ftn.get(frequency).isEmpty();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495277,
                "title": "extra-dictionary-for-frequency",
                "content": "# Code\\n```\\npublic class FrequencyTracker {\\n    \\n    private Dictionary<int, int> _dict = new();\\n    private Dictionary<int, int> _freq = new();\\n\\n    public FrequencyTracker() {\\n        \\n    }\\n    \\n    public void Add(int number) {\\n        \\n        if (_dict.ContainsKey(number))\\n        {\\n            if (_freq.ContainsKey(_dict[number]) && _freq[_dict[number]] > 0)\\n            {\\n                _freq[_dict[number]]--;\\n            }\\n            _dict[number]++;\\n        }\\n        else\\n        {\\n            _dict.Add(number, 1);\\n        }\\n        if (!_freq.ContainsKey(_dict[number]))\\n        {\\n            _freq.Add(_dict[number], 1);\\n        }\\n        else\\n        {\\n            _freq[_dict[number]]++;\\n        }\\n    }\\n    \\n    public void DeleteOne(int number) {\\n        \\n        if (_dict.ContainsKey(number) && _dict[number] > 0)\\n        {\\n            if (_freq.ContainsKey(_dict[number]) && _freq[_dict[number]] > 0)\\n            {\\n                _freq[_dict[number]]--;\\n            }\\n            _dict[number]--;\\n            if (_dict[number] != 0)\\n            {\\n               _freq[_dict[number]]++;\\n            }\\n        }\\n    }\\n    \\n    public bool HasFrequency(int frequency) {\\n        \\n        return _freq.ContainsKey(frequency) && _freq[frequency] > 0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.Add(number);\\n * obj.DeleteOne(number);\\n * bool param_3 = obj.HasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class FrequencyTracker {\\n    \\n    private Dictionary<int, int> _dict = new();\\n    private Dictionary<int, int> _freq = new();\\n\\n    public FrequencyTracker() {\\n        \\n    }\\n    \\n    public void Add(int number) {\\n        \\n        if (_dict.ContainsKey(number))\\n        {\\n            if (_freq.ContainsKey(_dict[number]) && _freq[_dict[number]] > 0)\\n            {\\n                _freq[_dict[number]]--;\\n            }\\n            _dict[number]++;\\n        }\\n        else\\n        {\\n            _dict.Add(number, 1);\\n        }\\n        if (!_freq.ContainsKey(_dict[number]))\\n        {\\n            _freq.Add(_dict[number], 1);\\n        }\\n        else\\n        {\\n            _freq[_dict[number]]++;\\n        }\\n    }\\n    \\n    public void DeleteOne(int number) {\\n        \\n        if (_dict.ContainsKey(number) && _dict[number] > 0)\\n        {\\n            if (_freq.ContainsKey(_dict[number]) && _freq[_dict[number]] > 0)\\n            {\\n                _freq[_dict[number]]--;\\n            }\\n            _dict[number]--;\\n            if (_dict[number] != 0)\\n            {\\n               _freq[_dict[number]]++;\\n            }\\n        }\\n    }\\n    \\n    public bool HasFrequency(int frequency) {\\n        \\n        return _freq.ContainsKey(frequency) && _freq[frequency] > 0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.Add(number);\\n * obj.DeleteOne(number);\\n * bool param_3 = obj.HasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495275,
                "title": "i-spent-so-much-time-on-this-and-it-s-probably-not-even-good-python-2-hashmap-solution-detailed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo the question is not too bad other than the fact that we have to implement a hasFrequency function. A single hashmap solution results in a time limit error since one of the test cases literally is entirely add and has frequency. Thus, to make this more efficient we use two hashmaps because you can never have too many hashmaps. \\n\\nOnto the actual small brain design of this solution. Essentially, we keep track of the number:frequencies and the frequencies:list(numbers) in two different hashmaps. We need to use frequency:list(numbers) since one frequency can have multiple different numbers in it. This enables us to check if the frequency exists more efficiently.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConstructor is simply creating the two hashmaps: I use collections.defaultdict(list) because it creates a hashmap with the values being a list.\\n\\nThe add function will first get the current frequency of the number. If it doesn\\'t exist, the default is set to 0 using the second parameter in the .get() method. Next, we update the number:frequency hashmap with the updated frequency. The more complicated part is to update the frequency:number part. We need to make sure to remove the number from its old frequency value.\\nThis is done using the \\n\\nif number in self.freqNums[currFreq]:\\n            self.freqNums[currFreq].remove(number)\\n\\npart of the code. \\nNext, we add the number to its new frequency value.\\nThis ensures that with each add operation the frequency:number hashmap is properly updated.\\n\\nThe deleteOne method is very similar, except the first thing we check is if we even need to do anything. If the number exists in the number:frequency hashmap and the frequency is greater than 0 we will get the current frequency stored and save it to a variable to help us with updating the frequency:number hashmap. Next, we update the number:frequency hashmap and then the frequency:number hashmap.\\n\\nThe last hasFrequency method checks if the frequency is in the frequency:number hashmap and the length of the list is greater than 0. This means that there are values that have that frequency and we return True. If this doesn\\'t hit we just return False outside.\\n\\nI hope my explanation helps people understand my solution. \\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.numFreq = {}\\n        self.freqNums = collections.defaultdict(list)\\n        \\n\\n    def add(self, number: int) -> None:\\n        currFreq = self.numFreq.get(number,0)\\n        self.numFreq[number] = 1 + currFreq\\n        if number in self.freqNums[currFreq]:\\n            self.freqNums[currFreq].remove(number)\\n        self.freqNums[1+currFreq].append(number)\\n        \\n\\n    def deleteOne(self, number: int) -> None:\\n        if number in self.numFreq and self.numFreq[number]>0:\\n            currFreq = self.numFreq[number]\\n            self.numFreq[number]-=1\\n            self.freqNums[currFreq].remove(number)\\n            self.freqNums[currFreq-1].append(number)\\n            \\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        if frequency in self.freqNums and len(self.freqNums[frequency]) > 0:\\n            return True\\n        return False\\n        \\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.numFreq = {}\\n        self.freqNums = collections.defaultdict(list)\\n        \\n\\n    def add(self, number: int) -> None:\\n        currFreq = self.numFreq.get(number,0)\\n        self.numFreq[number] = 1 + currFreq\\n        if number in self.freqNums[currFreq]:\\n            self.freqNums[currFreq].remove(number)\\n        self.freqNums[1+currFreq].append(number)\\n        \\n\\n    def deleteOne(self, number: int) -> None:\\n        if number in self.numFreq and self.numFreq[number]>0:\\n            currFreq = self.numFreq[number]\\n            self.numFreq[number]-=1\\n            self.freqNums[currFreq].remove(number)\\n            self.freqNums[currFreq-1].append(number)\\n            \\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        if frequency in self.freqNums and len(self.freqNums[frequency]) > 0:\\n            return True\\n        return False\\n        \\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495237,
                "title": "simple-map-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    private: unordered_map<int, int> freq;\\n    int mx_freq = 0;\\n    \\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        freq[number]++;\\n        if (freq[number] > mx_freq) {\\n            mx_freq = freq[number];\\n        }\\n    }\\n    \\n    void deleteOne(int number) {\\n         if (freq.find(number) != freq.end()) {\\n            freq[number]--;\\n            if (freq[number] == 0) {\\n                freq.erase(number);\\n            }\\n            if (freq.empty()) {\\n                mx_freq = 0;\\n            } else {\\n                auto it = max_element(freq.begin(), freq.end(), [](const auto& a, const auto& b) {\\n                    return a.second < b.second;\\n                });\\n                mx_freq = it->second;\\n            }\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n          return frequency <= mx_freq && any_of(freq.begin(), freq.end(), [frequency](const auto& p) {\\n            return p.second == frequency;\\n        });\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    private: unordered_map<int, int> freq;\\n    int mx_freq = 0;\\n    \\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        freq[number]++;\\n        if (freq[number] > mx_freq) {\\n            mx_freq = freq[number];\\n        }\\n    }\\n    \\n    void deleteOne(int number) {\\n         if (freq.find(number) != freq.end()) {\\n            freq[number]--;\\n            if (freq[number] == 0) {\\n                freq.erase(number);\\n            }\\n            if (freq.empty()) {\\n                mx_freq = 0;\\n            } else {\\n                auto it = max_element(freq.begin(), freq.end(), [](const auto& a, const auto& b) {\\n                    return a.second < b.second;\\n                });\\n                mx_freq = it->second;\\n            }\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n          return frequency <= mx_freq && any_of(freq.begin(), freq.end(), [frequency](const auto& p) {\\n            return p.second == frequency;\\n        });\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495195,
                "title": "lc-2671-m-python3-two-hashmaps",
                "content": "Use another hashmap to record the number of each frequency.\\nTC: $\\\\Omicron(1)$ (each call).\\n\\n```Python3 []\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.cnter, self.freq = defaultdict(int), defaultdict(int)\\n        \\n    def add(self, number: int) -> None:\\n        self.cnter[number] += 1\\n        self.freq[cnt := self.cnter[number]] += 1\\n        self.freq[cnt-1] -= 1\\n        \\n    def deleteOne(self, number: int) -> None:\\n        if self.cnter[number]:\\n            self.cnter[number] -= 1\\n            self.freq[cnt := self.cnter[number]] += 1\\n            self.freq[cnt+1] -= 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] > 0\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python3 []\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.cnter, self.freq = defaultdict(int), defaultdict(int)\\n        \\n    def add(self, number: int) -> None:\\n        self.cnter[number] += 1\\n        self.freq[cnt := self.cnter[number]] += 1\\n        self.freq[cnt-1] -= 1\\n        \\n    def deleteOne(self, number: int) -> None:\\n        if self.cnter[number]:\\n            self.cnter[number] -= 1\\n            self.freq[cnt := self.cnter[number]] += 1\\n            self.freq[cnt+1] -= 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] > 0\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494991,
                "title": "c-o-logn",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    unordered_map<int, int> ump;\\n    multiset<int> st;\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(st.count(ump[number])) st.erase(st.find(ump[number]));\\n        ump[number]++;\\n        st.insert(ump[number]);\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(ump.find(number) != ump.end()){\\n        if(st.count(ump[number])) st.erase(st.find(ump[number]));\\n            ump[number]--;\\n            st.insert(ump[number]);\\n\\n            if(ump[number] == 0) ump.erase(number);\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(st.find(frequency) != st.end()) return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    unordered_map<int, int> ump;\\n    multiset<int> st;\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(st.count(ump[number])) st.erase(st.find(ump[number]));\\n        ump[number]++;\\n        st.insert(ump[number]);\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(ump.find(number) != ump.end()){\\n        if(st.count(ump[number])) st.erase(st.find(ump[number]));\\n            ump[number]--;\\n            st.insert(ump[number]);\\n\\n            if(ump[number] == 0) ump.erase(number);\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(st.find(frequency) != st.end()) return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494966,
                "title": "c-maps-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(logn)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    map<int, int>m, m1;\\n    //vector<int>v;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        //v.push_back(number);\\n        if(m.find(number)!=m.end()){\\n            m1[m[number]]--;\\n            if(m1[m[number]]==0){\\n                m1.erase(m[number]);\\n            }\\n        }\\n        m[number]++;\\n        m1[m[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        \\n        if(m.find(number)!=m.end()){\\n            // auto it=find(v.begin(), v.end(), number)-v.begin();\\n            // v.erase(v.begin()+it);\\n            m1[m[number]]--;\\n            if(m1[m[number]]==0){\\n                m1.erase(m[number]);\\n            }\\n            m[number]--;\\n            if(m[number]==0){\\n                m.erase(number);\\n            }\\n            else{m1[m[number]]++;}\\n        }\\n        \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(m1[frequency]){return true;}\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    map<int, int>m, m1;\\n    //vector<int>v;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        //v.push_back(number);\\n        if(m.find(number)!=m.end()){\\n            m1[m[number]]--;\\n            if(m1[m[number]]==0){\\n                m1.erase(m[number]);\\n            }\\n        }\\n        m[number]++;\\n        m1[m[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        \\n        if(m.find(number)!=m.end()){\\n            // auto it=find(v.begin(), v.end(), number)-v.begin();\\n            // v.erase(v.begin()+it);\\n            m1[m[number]]--;\\n            if(m1[m[number]]==0){\\n                m1.erase(m[number]);\\n            }\\n            m[number]--;\\n            if(m[number]==0){\\n                m.erase(number);\\n            }\\n            else{m1[m[number]]++;}\\n        }\\n        \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(m1[frequency]){return true;}\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494859,
                "title": "c-two-map-solution",
                "content": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> mp;\\n    unordered_map<int,set<int>> track;\\n    FrequencyTracker() {\\n        mp.clear();\\n        track.clear();\\n    }\\n    \\n    void add(int number) {\\n        mp[number] += 1;\\n        if(track.find(mp[number]-1)!=track.end() && track[mp[number]-1].count(number)>0){\\n            track[mp[number]-1].erase(number);\\n        }\\n        track[mp[number]].insert(number);\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp.find(number)!=mp.end()){\\n            mp[number] -=1;\\n            track[mp[number]+1].erase(number);\\n            if(mp[number]>0) track[mp[number]].insert(number);\\n            if(mp[number] == 0){\\n                mp.erase(number);\\n            }\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return track[frequency].size()>0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> mp;\\n    unordered_map<int,set<int>> track;\\n    FrequencyTracker() {\\n        mp.clear();\\n        track.clear();\\n    }\\n    \\n    void add(int number) {\\n        mp[number] += 1;\\n        if(track.find(mp[number]-1)!=track.end() && track[mp[number]-1].count(number)>0){\\n            track[mp[number]-1].erase(number);\\n        }\\n        track[mp[number]].insert(number);\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp.find(number)!=mp.end()){\\n            mp[number] -=1;\\n            track[mp[number]+1].erase(number);\\n            if(mp[number]>0) track[mp[number]].insert(number);\\n            if(mp[number] == 0){\\n                mp.erase(number);\\n            }\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return track[frequency].size()>0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923221,
                "title": "using-two-maps-only-simple-approach",
                "content": "class FrequencyTracker {\\n    private:\\n    unordered_map<int,int> m;\\n    unordered_map<int,set<int>> map_freq;\\npublic:\\n    FrequencyTracker() {\\n        m.clear();\\n        map_freq.clear();\\n    }\\n    \\n    void add(int number) {\\n        if(m.count(number)){\\n            int freq=m[number];\\n            map_freq[freq].erase(number);\\n        }\\n        m[number]++;\\n        map_freq[m[number]].insert(number);\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(!m.count(number)){\\n            return;\\n        }\\n        int freq=m[number];\\n        map_freq[freq].erase(number);\\n        m[number]--;\\n        if(m[number]==0){\\n            m.erase(number);\\n            return;\\n        }\\n        map_freq[m[number]].insert(number);\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(map_freq[frequency].empty()){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */",
                "solutionTags": [],
                "code": "class FrequencyTracker {\\n    private:\\n    unordered_map<int,int> m;\\n    unordered_map<int,set<int>> map_freq;\\npublic:\\n    FrequencyTracker() {\\n        m.clear();\\n        map_freq.clear();\\n    }\\n    \\n    void add(int number) {\\n        if(m.count(number)){\\n            int freq=m[number];\\n            map_freq[freq].erase(number);\\n        }\\n        m[number]++;\\n        map_freq[m[number]].insert(number);\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(!m.count(number)){\\n            return;\\n        }\\n        int freq=m[number];\\n        map_freq[freq].erase(number);\\n        m[number]--;\\n        if(m[number]==0){\\n            m.erase(number);\\n            return;\\n        }\\n        map_freq[m[number]].insert(number);\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(map_freq[frequency].empty()){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 3921743,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class FrequencyTracker {\\n    private IList<int> _frequencyData;\\n    private Dictionary<int, int> _hash;\\n\\n    public FrequencyTracker() {\\n        _frequencyData = new List<int>() { 1 };\\n        _hash = new();\\n    }\\n    \\n    public void Add(int number) {\\n        if (!_hash.ContainsKey(number)){\\n            _hash.Add(number, 0);\\n        }\\n        _frequencyData[_hash[number]]--;\\n        _hash[number]++;\\n\\n        if (_hash[number] == _frequencyData.Count){\\n            _frequencyData.Add(1);\\n        }\\n        else{\\n            _frequencyData[_hash[number]]++;\\n        }\\n    }\\n    \\n    public void DeleteOne(int number) {\\n        if (!_hash.ContainsKey(number) || _hash[number] == 0){\\n            return;\\n        }\\n        _frequencyData[_hash[number]]--;\\n        _hash[number]--;\\n        _frequencyData[_hash[number]]++;\\n    }\\n    \\n    public bool HasFrequency(int frequency) {\\n        if (_frequencyData.Count <= frequency || _frequencyData[frequency] <= 0){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.Add(number);\\n * obj.DeleteOne(number);\\n * bool param_3 = obj.HasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class FrequencyTracker {\\n    private IList<int> _frequencyData;\\n    private Dictionary<int, int> _hash;\\n\\n    public FrequencyTracker() {\\n        _frequencyData = new List<int>() { 1 };\\n        _hash = new();\\n    }\\n    \\n    public void Add(int number) {\\n        if (!_hash.ContainsKey(number)){\\n            _hash.Add(number, 0);\\n        }\\n        _frequencyData[_hash[number]]--;\\n        _hash[number]++;\\n\\n        if (_hash[number] == _frequencyData.Count){\\n            _frequencyData.Add(1);\\n        }\\n        else{\\n            _frequencyData[_hash[number]]++;\\n        }\\n    }\\n    \\n    public void DeleteOne(int number) {\\n        if (!_hash.ContainsKey(number) || _hash[number] == 0){\\n            return;\\n        }\\n        _frequencyData[_hash[number]]--;\\n        _hash[number]--;\\n        _frequencyData[_hash[number]]++;\\n    }\\n    \\n    public bool HasFrequency(int frequency) {\\n        if (_frequencyData.Count <= frequency || _frequencyData[frequency] <= 0){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.Add(number);\\n * obj.DeleteOne(number);\\n * bool param_3 = obj.HasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903868,
                "title": "solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n public:\\n  void add(int number) {\\n    if (count[number] > 0)\\n      --freqCount[count[number]];\\n    ++count[number];\\n    ++freqCount[count[number]];\\n  }\\n\\n  void deleteOne(int number) {\\n    if (count[number] == 0)\\n      return;\\n    --freqCount[count[number]];\\n    --count[number];\\n    ++freqCount[count[number]];\\n  }\\n\\n  bool hasFrequency(int frequency) {\\n    return freqCount[frequency] > 0;\\n  }\\n\\n private:\\n  unordered_map<int, int> count;\\n  unordered_map<int, int> freqCount;\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\n public:\\n  void add(int number) {\\n    if (count[number] > 0)\\n      --freqCount[count[number]];\\n    ++count[number];\\n    ++freqCount[count[number]];\\n  }\\n\\n  void deleteOne(int number) {\\n    if (count[number] == 0)\\n      return;\\n    --freqCount[count[number]];\\n    --count[number];\\n    ++freqCount[count[number]];\\n  }\\n\\n  bool hasFrequency(int frequency) {\\n    return freqCount[frequency] > 0;\\n  }\\n\\n private:\\n  unordered_map<int, int> count;\\n  unordered_map<int, int> freqCount;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889373,
                "title": "java-solution-using-two-hashmaps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nFollow [this repo](https://github.com/g-sahu/Practice) for more solutions.\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    private final Map<Integer, Integer> numMap;\\n    private final Map<Integer, List<Integer>> freqMap;\\n\\n    public FrequencyTracker() {\\n        numMap = new HashMap<>();\\n        freqMap = new HashMap<>();\\n    }\\n\\n    public void add(int number) {\\n        int freq = numMap.getOrDefault(number, 0);\\n        increaseFreq(number, freq);\\n    }\\n\\n    public void deleteOne(int number) {\\n        if (numMap.containsKey(number)) {\\n            int freq = numMap.get(number);\\n            decreaseFreq(number, freq);\\n        }\\n    }\\n\\n    private void increaseFreq(int num, int freq) {\\n        //Update freqMap\\n        removeFromList(freq, num);\\n        addToList(freq+1, num);\\n\\n        //Update numMap\\n        int newFreq = numMap.getOrDefault(num, 0) + 1;\\n        numMap.put(num, newFreq);\\n    }\\n\\n    private void decreaseFreq(int num, int freq) {\\n        //Remove from current freq list and add to new freq list\\n        removeFromList(freq, num);\\n        addToList(freq-1, num);\\n\\n        //Update numMap\\n        int newFreq = numMap.get(num) - 1;\\n\\n        if (newFreq == 0) {\\n            numMap.remove(num);\\n        } else {\\n            numMap.put(num, newFreq);\\n        }\\n    }\\n\\n    private void addToList(int freq, int num) {\\n        List<Integer> list = freqMap.getOrDefault(freq, new ArrayList<>());\\n        list.add(num);\\n        freqMap.put(freq, list);\\n    }\\n\\n    private void removeFromList(int freq, int num) {\\n        if (freqMap.containsKey(freq)) {\\n            List<Integer> list = freqMap.get(freq);\\n            list.remove(Integer.valueOf(num));\\n\\n            if (list.isEmpty()) {\\n                freqMap.remove(freq);\\n            } else {\\n                freqMap.put(freq, list);\\n            }\\n        }\\n    }\\n\\n    public boolean hasFrequency(int frequency) {\\n        return freqMap.containsKey(frequency);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    private final Map<Integer, Integer> numMap;\\n    private final Map<Integer, List<Integer>> freqMap;\\n\\n    public FrequencyTracker() {\\n        numMap = new HashMap<>();\\n        freqMap = new HashMap<>();\\n    }\\n\\n    public void add(int number) {\\n        int freq = numMap.getOrDefault(number, 0);\\n        increaseFreq(number, freq);\\n    }\\n\\n    public void deleteOne(int number) {\\n        if (numMap.containsKey(number)) {\\n            int freq = numMap.get(number);\\n            decreaseFreq(number, freq);\\n        }\\n    }\\n\\n    private void increaseFreq(int num, int freq) {\\n        //Update freqMap\\n        removeFromList(freq, num);\\n        addToList(freq+1, num);\\n\\n        //Update numMap\\n        int newFreq = numMap.getOrDefault(num, 0) + 1;\\n        numMap.put(num, newFreq);\\n    }\\n\\n    private void decreaseFreq(int num, int freq) {\\n        //Remove from current freq list and add to new freq list\\n        removeFromList(freq, num);\\n        addToList(freq-1, num);\\n\\n        //Update numMap\\n        int newFreq = numMap.get(num) - 1;\\n\\n        if (newFreq == 0) {\\n            numMap.remove(num);\\n        } else {\\n            numMap.put(num, newFreq);\\n        }\\n    }\\n\\n    private void addToList(int freq, int num) {\\n        List<Integer> list = freqMap.getOrDefault(freq, new ArrayList<>());\\n        list.add(num);\\n        freqMap.put(freq, list);\\n    }\\n\\n    private void removeFromList(int freq, int num) {\\n        if (freqMap.containsKey(freq)) {\\n            List<Integer> list = freqMap.get(freq);\\n            list.remove(Integer.valueOf(num));\\n\\n            if (list.isEmpty()) {\\n                freqMap.remove(freq);\\n            } else {\\n                freqMap.put(freq, list);\\n            }\\n        }\\n    }\\n\\n    public boolean hasFrequency(int frequency) {\\n        return freqMap.containsKey(frequency);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884460,
                "title": "java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    int ele[], freq[];\\n    public FrequencyTracker() {\\n        ele=new int[100001];\\n        freq=new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n        if(ele[number]>0)\\n        {\\n            freq[ele[number]]--;\\n        }\\n        ele[number]++;\\n        freq[ele[number]]++;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(ele[number]>0)\\n        {\\n            freq[ele[number]]--;\\n            ele[number]--;\\n            freq[ele[number]]++;\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return freq[frequency]>0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    int ele[], freq[];\\n    public FrequencyTracker() {\\n        ele=new int[100001];\\n        freq=new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n        if(ele[number]>0)\\n        {\\n            freq[ele[number]]--;\\n        }\\n        ele[number]++;\\n        freq[ele[number]]++;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(ele[number]>0)\\n        {\\n            freq[ele[number]]--;\\n            ele[number]--;\\n            freq[ele[number]]++;\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return freq[frequency]>0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870945,
                "title": "swift-easy-solution-100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n\\n   var dictNums = [Int:Int]()\\n    var dictFrequency = [Int:Int]()\\n    \\n    init() {\\n        \\n    }\\n    \\n    func add(_ number: Int) {\\n        dictFrequency[dictNums[number,default: 0],default: 0] -= 1\\n        dictNums[number,default: 0] += 1\\n        dictFrequency[dictNums[number,default: 0],default: 0] += 1\\n    }\\n    \\n    func deleteOne(_ number: Int) {\\n        \\n        if dictNums[number,default: 0] > 0 {\\n            dictFrequency[dictNums[number,default: 0],default: 0] -= 1\\n            dictNums[number,default: 0] -= 1\\n            dictFrequency[dictNums[number,default: 0],default: 0] += 1\\n        }\\n    }\\n    \\n    func hasFrequency(_ frequency: Int) -> Bool {\\n        return dictFrequency[frequency,default: 0] > 0 //!= nil\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * let obj = FrequencyTracker()\\n * obj.add(number)\\n * obj.deleteOne(number)\\n * let ret_3: Bool = obj.hasFrequency(frequency)\\n */\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass FrequencyTracker {\\n\\n   var dictNums = [Int:Int]()\\n    var dictFrequency = [Int:Int]()\\n    \\n    init() {\\n        \\n    }\\n    \\n    func add(_ number: Int) {\\n        dictFrequency[dictNums[number,default: 0],default: 0] -= 1\\n        dictNums[number,default: 0] += 1\\n        dictFrequency[dictNums[number,default: 0],default: 0] += 1\\n    }\\n    \\n    func deleteOne(_ number: Int) {\\n        \\n        if dictNums[number,default: 0] > 0 {\\n            dictFrequency[dictNums[number,default: 0],default: 0] -= 1\\n            dictNums[number,default: 0] -= 1\\n            dictFrequency[dictNums[number,default: 0],default: 0] += 1\\n        }\\n    }\\n    \\n    func hasFrequency(_ frequency: Int) -> Bool {\\n        return dictFrequency[frequency,default: 0] > 0 //!= nil\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * let obj = FrequencyTracker()\\n * obj.add(number)\\n * obj.deleteOne(number)\\n * let ret_3: Bool = obj.hasFrequency(frequency)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856611,
                "title": "c-too-easy-clean-short-code",
                "content": "\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:map<int,int> p,q;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int n) {\\n        q[p[n]]--;\\n        p[n]++;\\n        q[p[n]]++;\\n    }\\n    \\n    void deleteOne(int n) {\\n        if(p[n]>0)\\n        {\\n        q[p[n]]--;\\n        p[n]--;\\n        q[p[n]]++;\\n        if(p[n]<=0) p.erase(n);\\n        }\\n    }\\n    \\n    bool hasFrequency(int f) {\\n        return q[f]>0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:map<int,int> p,q;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int n) {\\n        q[p[n]]--;\\n        p[n]++;\\n        q[p[n]]++;\\n    }\\n    \\n    void deleteOne(int n) {\\n        if(p[n]>0)\\n        {\\n        q[p[n]]--;\\n        p[n]--;\\n        q[p[n]]++;\\n        if(p[n]<=0) p.erase(n);\\n        }\\n    }\\n    \\n    bool hasFrequency(int f) {\\n        return q[f]>0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827155,
                "title": "c-beats-100-simple-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int, int> um;\\n    unordered_map<int, int> un;\\n    FrequencyTracker(){}\\n    \\n    void add(int number)\\n    {\\n        int curr = um[number];\\n        if(curr==0){um[number]=1;un[1]++;}\\n        else\\n        {\\n            um[number]=curr+1;\\n            if(un[curr]==1){un.erase(curr);}\\n            else{un[curr]--;}\\n            un[curr+1]++;\\n        }\\n\\n    }\\n    \\n    void deleteOne(int number)\\n    {\\n        if(um.count(number))\\n        {\\n            int curr = um[number];\\n            if(curr==1)\\n            {\\n                um.erase(number);\\n                if(un[curr]==1){un.erase(curr);}\\n                else{un[curr]--;}\\n            }\\n            else\\n            {\\n                um[number]=curr-1;\\n                if(un[curr]==1){un.erase(curr);}\\n                else{un[curr]--;}\\n                un[curr-1]++;\\n            }\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency)\\n    {\\n        return un.count(frequency);\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int, int> um;\\n    unordered_map<int, int> un;\\n    FrequencyTracker(){}\\n    \\n    void add(int number)\\n    {\\n        int curr = um[number];\\n        if(curr==0){um[number]=1;un[1]++;}\\n        else\\n        {\\n            um[number]=curr+1;\\n            if(un[curr]==1){un.erase(curr);}\\n            else{un[curr]--;}\\n            un[curr+1]++;\\n        }\\n\\n    }\\n    \\n    void deleteOne(int number)\\n    {\\n        if(um.count(number))\\n        {\\n            int curr = um[number];\\n            if(curr==1)\\n            {\\n                um.erase(number);\\n                if(un[curr]==1){un.erase(curr);}\\n                else{un[curr]--;}\\n            }\\n            else\\n            {\\n                um[number]=curr-1;\\n                if(un[curr]==1){un.erase(curr);}\\n                else{un[curr]--;}\\n                un[curr-1]++;\\n            }\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency)\\n    {\\n        return un.count(frequency);\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805766,
                "title": "python-two-dicts",
                "content": "```python\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.count = Counter()\\n        self.freq = Counter()\\n\\n    def add(self, number: int) -> None:\\n        self.count[number] += 1\\n\\n        self.freq[self.count[number] - 1] -= 1\\n        self.freq[self.count[number]] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        if number not in self.count:\\n            return\\n\\n        self.count[number] -= 1\\n        \\n        if self.count[number] == 0:\\n            del self.count[number]\\n        \\n        self.freq[self.count[number] + 1] -= 1\\n        self.freq[self.count[number]] += 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] > 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.count = Counter()\\n        self.freq = Counter()\\n\\n    def add(self, number: int) -> None:\\n        self.count[number] += 1\\n\\n        self.freq[self.count[number] - 1] -= 1\\n        self.freq[self.count[number]] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        if number not in self.count:\\n            return\\n\\n        self.count[number] -= 1\\n        \\n        if self.count[number] == 0:\\n            del self.count[number]\\n        \\n        self.freq[self.count[number] + 1] -= 1\\n        self.freq[self.count[number]] += 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] > 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773162,
                "title": "easy-c-code-using-2-unordered-maps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> mp;\\n    unordered_map<int,int> freq;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n      freq[mp[number]]--;\\n      mp[number]++;\\n      freq[mp[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number]>0){\\n        freq[mp[number]]--;\\n            mp[number]--;\\n        freq[mp[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(freq[frequency]>0){\\n            return true;\\n        }\\n        return false; \\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> mp;\\n    unordered_map<int,int> freq;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n      freq[mp[number]]--;\\n      mp[number]++;\\n      freq[mp[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number]>0){\\n        freq[mp[number]]--;\\n            mp[number]--;\\n        freq[mp[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(freq[frequency]>0){\\n            return true;\\n        }\\n        return false; \\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755373,
                "title": "golang-double-hash-solution",
                "content": "# Code\\n```go\\ntype FrequencyTracker struct {\\n\\tdata map[int]int\\n\\tfreq map[int]int\\n}\\n\\nfunc Constructor() FrequencyTracker {\\n\\treturn FrequencyTracker{\\n\\t\\tdata: map[int]int{},\\n\\t\\tfreq: map[int]int{},\\n\\t}\\n}\\n\\nfunc (ft *FrequencyTracker) Add(number int)  {\\n\\tif ft.data[number] >= 1 {\\n\\t\\tft.freq[ft.data[number]]--\\n\\t}\\n\\tft.data[number]++\\n\\tft.freq[ft.data[number]]++\\n}\\n\\nfunc (ft *FrequencyTracker) DeleteOne(number int)  {\\n\\tif ft.data[number] == 0 {\\n\\t\\treturn\\n\\t}\\n\\tft.freq[ft.data[number]]--\\n\\tft.data[number]--\\n\\tif ft.data[number] != 0 {\\n\\t\\tft.freq[ft.data[number]]++\\n\\t} else {\\n\\t\\tdelete(ft.data, number)\\n\\t}\\n}\\n\\nfunc (ft *FrequencyTracker) HasFrequency(frequency int) bool {\\n\\treturn ft.freq[frequency] > 0\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table"
                ],
                "code": "```go\\ntype FrequencyTracker struct {\\n\\tdata map[int]int\\n\\tfreq map[int]int\\n}\\n\\nfunc Constructor() FrequencyTracker {\\n\\treturn FrequencyTracker{\\n\\t\\tdata: map[int]int{},\\n\\t\\tfreq: map[int]int{},\\n\\t}\\n}\\n\\nfunc (ft *FrequencyTracker) Add(number int)  {\\n\\tif ft.data[number] >= 1 {\\n\\t\\tft.freq[ft.data[number]]--\\n\\t}\\n\\tft.data[number]++\\n\\tft.freq[ft.data[number]]++\\n}\\n\\nfunc (ft *FrequencyTracker) DeleteOne(number int)  {\\n\\tif ft.data[number] == 0 {\\n\\t\\treturn\\n\\t}\\n\\tft.freq[ft.data[number]]--\\n\\tft.data[number]--\\n\\tif ft.data[number] != 0 {\\n\\t\\tft.freq[ft.data[number]]++\\n\\t} else {\\n\\t\\tdelete(ft.data, number)\\n\\t}\\n}\\n\\nfunc (ft *FrequencyTracker) HasFrequency(frequency int) bool {\\n\\treturn ft.freq[frequency] > 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3750123,
                "title": "java-frequencytracker",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    private final Map<Integer, Integer> numberFrequencyMap;\\n    private final Map<Integer, Integer> freqCountMap;\\n\\n    public FrequencyTracker() {\\n        numberFrequencyMap = new HashMap<>(256);\\n        freqCountMap = new HashMap<>(256);\\n    }\\n\\n    public void add(int number) {\\n        var currentFreqCount = numberFrequencyMap.getOrDefault(number, 0);\\n        var newFreqCount = currentFreqCount + 1;\\n        numberFrequencyMap.put(number,newFreqCount);\\n\\n        freqCountMap.compute(newFreqCount, (k, v) -> v != null ? v + newFreqCount : newFreqCount);\\n        freqCountMap.computeIfPresent(currentFreqCount, (k, v) -> v != null && v > currentFreqCount ? v - currentFreqCount : null);\\n\\t\\tfreqCountMap.remove(currentFreqCount,null);\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n    }\\n\\n    public void deleteOne(int number) {\\n        if (!numberFrequencyMap.containsKey(number)) {\\n            return;\\n        }\\n\\n\\n        var freq = numberFrequencyMap.get(number);\\n        numberFrequencyMap.compute(number, (k, v) -> (v != null && v - 1 > 0) ? v - 1 : null);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\n        freqCountMap.compute(freq, (k, v) -> (v != null && v > freq) ? v - freq : null);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\n        if (freq != null && freq - 1 > 0) {\\n            freqCountMap.compute(freq - 1, (k, v) -> v != null ? v + (freq - 1) : freq - 1);\\n        }\\n    }\\n\\n    public boolean hasFrequency(int frequency) {\\n        return freqCountMap.containsKey(frequency);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    private final Map<Integer, Integer> numberFrequencyMap;\\n    private final Map<Integer, Integer> freqCountMap;\\n\\n    public FrequencyTracker() {\\n        numberFrequencyMap = new HashMap<>(256);\\n        freqCountMap = new HashMap<>(256);\\n    }\\n\\n    public void add(int number) {\\n        var currentFreqCount = numberFrequencyMap.getOrDefault(number, 0);\\n        var newFreqCount = currentFreqCount + 1;\\n        numberFrequencyMap.put(number,newFreqCount);\\n\\n        freqCountMap.compute(newFreqCount, (k, v) -> v != null ? v + newFreqCount : newFreqCount);\\n        freqCountMap.computeIfPresent(currentFreqCount, (k, v) -> v != null && v > currentFreqCount ? v - currentFreqCount : null);\\n\\t\\tfreqCountMap.remove(currentFreqCount,null);\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n    }\\n\\n    public void deleteOne(int number) {\\n        if (!numberFrequencyMap.containsKey(number)) {\\n            return;\\n        }\\n\\n\\n        var freq = numberFrequencyMap.get(number);\\n        numberFrequencyMap.compute(number, (k, v) -> (v != null && v - 1 > 0) ? v - 1 : null);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\n        freqCountMap.compute(freq, (k, v) -> (v != null && v > freq) ? v - freq : null);\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\n        if (freq != null && freq - 1 > 0) {\\n            freqCountMap.compute(freq - 1, (k, v) -> v != null ? v + (freq - 1) : freq - 1);\\n        }\\n    }\\n\\n    public boolean hasFrequency(int frequency) {\\n        return freqCountMap.containsKey(frequency);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749342,
                "title": "java-frequencytracker",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass FrequencyTracker {\\n    private final Map<Integer, Integer> numberFrequencyMap;\\n    private final Map<Integer, Integer> freqCountMap;\\n\\n    public FrequencyTracker() {\\n        numberFrequencyMap = new HashMap<>(256);\\n        freqCountMap = new HashMap<>(256);\\n    }\\n\\n    public void add(int number) {\\n        var currentFreqCount = numberFrequencyMap.getOrDefault(number, 0);\\n        var newFreqCount = currentFreqCount + 1;\\n        numberFrequencyMap.compute(number, (k, v) -> currentFreqCount + 1);\\n        freqCountMap.compute(newFreqCount, (k, v) -> v != null ? v + newFreqCount : newFreqCount);\\n        freqCountMap.compute(currentFreqCount, (k, v) -> v != null && v > currentFreqCount ? v - currentFreqCount : null);\\n    }\\n\\n    public void deleteOne(int number) {\\n        var freq = numberFrequencyMap.get(number);\\n        numberFrequencyMap.compute(number, (k, v) -> (v != null && v - 1 > 0) ? v - 1 : null);\\n        freqCountMap.compute(freq, (k, v) -> (v != null && v > freq) ? v - freq : null);\\n        if (freq != null && freq - 1 > 0) {\\n            freqCountMap.compute(freq - 1, (k, v) -> v != null ? v + (freq - 1) : freq - 1);\\n        }\\n    }\\n\\n    public boolean hasFrequency(int frequency) {\\n        return freqCountMap.containsKey(frequency);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass FrequencyTracker {\\n    private final Map<Integer, Integer> numberFrequencyMap;\\n    private final Map<Integer, Integer> freqCountMap;\\n\\n    public FrequencyTracker() {\\n        numberFrequencyMap = new HashMap<>(256);\\n        freqCountMap = new HashMap<>(256);\\n    }\\n\\n    public void add(int number) {\\n        var currentFreqCount = numberFrequencyMap.getOrDefault(number, 0);\\n        var newFreqCount = currentFreqCount + 1;\\n        numberFrequencyMap.compute(number, (k, v) -> currentFreqCount + 1);\\n        freqCountMap.compute(newFreqCount, (k, v) -> v != null ? v + newFreqCount : newFreqCount);\\n        freqCountMap.compute(currentFreqCount, (k, v) -> v != null && v > currentFreqCount ? v - currentFreqCount : null);\\n    }\\n\\n    public void deleteOne(int number) {\\n        var freq = numberFrequencyMap.get(number);\\n        numberFrequencyMap.compute(number, (k, v) -> (v != null && v - 1 > 0) ? v - 1 : null);\\n        freqCountMap.compute(freq, (k, v) -> (v != null && v > freq) ? v - freq : null);\\n        if (freq != null && freq - 1 > 0) {\\n            freqCountMap.compute(freq - 1, (k, v) -> v != null ? v + (freq - 1) : freq - 1);\\n        }\\n    }\\n\\n    public boolean hasFrequency(int frequency) {\\n        return freqCountMap.containsKey(frequency);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737417,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.numbers = [0]*100_000\\n        self.frequencies = [0]*100_000\\n\\n    def add(self, number: int) -> None:\\n        number -= 1\\n        if self.numbers[number]:\\n            self.frequencies[self.numbers[number]-1] -= 1\\n        \\n        self.numbers[number] += 1\\n        self.frequencies[self.numbers[number]-1] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        number -= 1\\n        if self.numbers[number]:\\n            self.frequencies[self.numbers[number]-1] -= 1\\n            self.numbers[number] -= 1\\n\\n            if self.numbers[number]:\\n                self.frequencies[self.numbers[number]-1] += 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.frequencies[frequency-1]\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.numbers = [0]*100_000\\n        self.frequencies = [0]*100_000\\n\\n    def add(self, number: int) -> None:\\n        number -= 1\\n        if self.numbers[number]:\\n            self.frequencies[self.numbers[number]-1] -= 1\\n        \\n        self.numbers[number] += 1\\n        self.frequencies[self.numbers[number]-1] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        number -= 1\\n        if self.numbers[number]:\\n            self.frequencies[self.numbers[number]-1] -= 1\\n            self.numbers[number] -= 1\\n\\n            if self.numbers[number]:\\n                self.frequencies[self.numbers[number]-1] += 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.frequencies[frequency-1]\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726569,
                "title": "self-explanatory-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    map<int,int>freq,freqOfFreq;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(freq[number])\\n            freqOfFreq[freq[number]]--;\\n\\n        freq[number]++;\\n        freqOfFreq[freq[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(freq[number]){\\n            freqOfFreq[freq[number]]--;\\n            freq[number]--;\\n\\n            freqOfFreq[freq[number]]++;\\n        }\\n        else{\\n            freq.erase(number);\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freqOfFreq[frequency] > 0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    map<int,int>freq,freqOfFreq;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(freq[number])\\n            freqOfFreq[freq[number]]--;\\n\\n        freq[number]++;\\n        freqOfFreq[freq[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(freq[number]){\\n            freqOfFreq[freq[number]]--;\\n            freq[number]--;\\n\\n            freqOfFreq[freq[number]]++;\\n        }\\n        else{\\n            freq.erase(number);\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freqOfFreq[frequency] > 0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714645,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class FrequencyTracker {\\n\\n    Dictionary<int, int> dict;\\n    int [] freq;\\n\\n    public FrequencyTracker() {\\n        dict = new Dictionary<int, int>();\\n        freq = new int[100001];\\n    }\\n    \\n    public void Add(int number) {\\n        if(!dict.ContainsKey(number)){\\n            dict.Add(number, 1);\\n            freq[dict[number]]++;\\n        }   \\n        else{\\n            freq[dict[number]]--;  \\n            dict[number]++;\\n            freq[dict[number]]++;\\n        }\\n    }\\n    \\n    public void DeleteOne(int number) {\\n        if(dict.ContainsKey(number) && dict[number] > 0){\\n            freq[dict[number]]--;  \\n            dict[number]--;\\n            freq[dict[number]]++;\\n        }    \\n    }\\n    \\n    public bool HasFrequency(int frequency) {\\n        return freq[frequency] > 0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.Add(number);\\n * obj.DeleteOne(number);\\n * bool param_3 = obj.HasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class FrequencyTracker {\\n\\n    Dictionary<int, int> dict;\\n    int [] freq;\\n\\n    public FrequencyTracker() {\\n        dict = new Dictionary<int, int>();\\n        freq = new int[100001];\\n    }\\n    \\n    public void Add(int number) {\\n        if(!dict.ContainsKey(number)){\\n            dict.Add(number, 1);\\n            freq[dict[number]]++;\\n        }   \\n        else{\\n            freq[dict[number]]--;  \\n            dict[number]++;\\n            freq[dict[number]]++;\\n        }\\n    }\\n    \\n    public void DeleteOne(int number) {\\n        if(dict.ContainsKey(number) && dict[number] > 0){\\n            freq[dict[number]]--;  \\n            dict[number]--;\\n            freq[dict[number]]++;\\n        }    \\n    }\\n    \\n    public bool HasFrequency(int frequency) {\\n        return freq[frequency] > 0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.Add(number);\\n * obj.DeleteOne(number);\\n * bool param_3 = obj.HasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671687,
                "title": "c-using-arrays",
                "content": "```\\nclass FrequencyTracker {\\npublic:\\n    int c[100001] = {}, f[100001] = {};\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(f[c[number]])--f[c[number]];\\n        ++f[++c[number]];\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(c[number]){\\n            --f[c[number]];\\n             ++f[--c[number]];\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return f[frequency];\\n        \\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    int c[100001] = {}, f[100001] = {};\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(f[c[number]])--f[c[number]];\\n        ++f[++c[number]];\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(c[number]){\\n            --f[c[number]];\\n             ++f[--c[number]];\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return f[frequency];\\n        \\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670660,
                "title": "easy-c-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    map<int,int>m,n;\\n    FrequencyTracker() {\\n      \\n    }\\n    \\n    void add(int number) {\\n        n[m[number]]--;\\n        m[number]++;\\n        n[m[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(m[number]>0){\\n            n[m[number]]--;\\n            m[number]--;\\n            n[m[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int f) {\\n        return n[f]>0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    map<int,int>m,n;\\n    FrequencyTracker() {\\n      \\n    }\\n    \\n    void add(int number) {\\n        n[m[number]]--;\\n        m[number]++;\\n        n[m[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(m[number]>0){\\n            n[m[number]]--;\\n            m[number]--;\\n            n[m[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int f) {\\n        return n[f]>0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629889,
                "title": "java-52ms-beats-98-and-hashmap",
                "content": "# Approach\\n1. Use 2 maps to store the count of each num. The second map will keep track of how many count groups you have.\\n2. When adding a number, increase the count from countMap.\\n    - Also, the group count has to increase. \\n    - EG: supposing you have 3 of 7s. countMap: 7 -> 3. Frequency Map : 3 -> 1.\\n    - Adding another 7: 4 of 7s: countMap 7 -> 4. Frequncy Map: 4 -> 1. \\n    - Also you need to decrement the old frequency of 7. as you no longer 3 7s but 4 7s\\n3. Same principle for deleting. Check if num exisists in countMap. If yes, decrease its count, decrease its old count frequencyMap  and increase the frequency map of the new count.\\n    - EG: 4 of 7s: countMap: 7 -> 4. Freq Map: 4 ->1\\n    - Deleting 1 seven: countMap -> 7 -> 3. Freq map: 3 -> 1, 4 -> 0.   \\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    private Map<Integer, Integer> numCount;\\n    private Map<Integer, Integer> frequencies;\\n    public FrequencyTracker() {\\n        numCount = new HashMap<>();\\n        frequencies = new HashMap<>();\\n    }\\n    \\n    public void add(int number) {\\n        int newCount = numCount.merge(number, 1, Integer::sum);\\n        frequencies.merge(newCount, 1, Integer::sum);\\n        if (newCount > 1) {\\n            frequencies.merge(newCount - 1, -1, Integer::sum);\\n        }\\n    }\\n    \\n    public void deleteOne(int number) {\\n        Integer currentVal = numCount.get(number);\\n        if (currentVal != null && currentVal > 0) {\\n            int newCount = numCount.merge(number, -1, Integer::sum);\\n            frequencies.merge(newCount, 1, Integer::sum);\\n            frequencies.merge(newCount + 1, -1, Integer::sum);\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        Integer existing = frequencies.get(frequency);\\n        return existing != null && existing > 0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    private Map<Integer, Integer> numCount;\\n    private Map<Integer, Integer> frequencies;\\n    public FrequencyTracker() {\\n        numCount = new HashMap<>();\\n        frequencies = new HashMap<>();\\n    }\\n    \\n    public void add(int number) {\\n        int newCount = numCount.merge(number, 1, Integer::sum);\\n        frequencies.merge(newCount, 1, Integer::sum);\\n        if (newCount > 1) {\\n            frequencies.merge(newCount - 1, -1, Integer::sum);\\n        }\\n    }\\n    \\n    public void deleteOne(int number) {\\n        Integer currentVal = numCount.get(number);\\n        if (currentVal != null && currentVal > 0) {\\n            int newCount = numCount.merge(number, -1, Integer::sum);\\n            frequencies.merge(newCount, 1, Integer::sum);\\n            frequencies.merge(newCount + 1, -1, Integer::sum);\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        Integer existing = frequencies.get(frequency);\\n        return existing != null && existing > 0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626738,
                "title": "simple-and-optimized-using-two-maps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing two maps\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int>mp;\\n    unordered_map<int,int>freq;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        mp[number]++;\\n        if(mp[number]==1)\\n            freq[mp[number]]++;\\n        else{\\n            if(freq[mp[number]-1])\\n                freq[mp[number]-1]--;\\n            freq[mp[number]]++;\\n        }\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number] && freq[mp[number]]){\\n            freq[mp[number]]--;\\n            mp[number]--;\\n            freq[mp[number]]++;\\n        }\\n            \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        // for(auto it:mp)\\n        // {\\n        //     if(it.second==frequency)\\n        //         return true;\\n        // }\\n        return freq[frequency]==0?false:true;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Design",
                    "Ordered Map"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int>mp;\\n    unordered_map<int,int>freq;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        mp[number]++;\\n        if(mp[number]==1)\\n            freq[mp[number]]++;\\n        else{\\n            if(freq[mp[number]-1])\\n                freq[mp[number]-1]--;\\n            freq[mp[number]]++;\\n        }\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number] && freq[mp[number]]){\\n            freq[mp[number]]--;\\n            mp[number]--;\\n            freq[mp[number]]++;\\n        }\\n            \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        // for(auto it:mp)\\n        // {\\n        //     if(it.second==frequency)\\n        //         return true;\\n        // }\\n        return freq[frequency]==0?false:true;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617185,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n   int[] num = new int[100001];\\n   int[] fre = new int[100001];\\n    public FrequencyTracker() {\\n        \\n    }\\n    \\n    public void add(int number) {\\n        if(num[number] > 0){\\n            fre[num[number]]--;\\n        }\\n        num[number]++;\\n        fre[num[number]]++;    \\n    }\\n    \\n    public void deleteOne(int number) {\\n         if(num[number] > 0){\\n            fre[num[number]]--;\\n            num[number]--;\\n            fre[num[number]]++;\\n        }\\n       \\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return fre[frequency] > 0;\\n        \\n    }\\n}\\n\\n \\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n   int[] num = new int[100001];\\n   int[] fre = new int[100001];\\n    public FrequencyTracker() {\\n        \\n    }\\n    \\n    public void add(int number) {\\n        if(num[number] > 0){\\n            fre[num[number]]--;\\n        }\\n        num[number]++;\\n        fre[num[number]]++;    \\n    }\\n    \\n    public void deleteOne(int number) {\\n         if(num[number] > 0){\\n            fre[num[number]]--;\\n            num[number]--;\\n            fre[num[number]]++;\\n        }\\n       \\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return fre[frequency] > 0;\\n        \\n    }\\n}\\n\\n \\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588335,
                "title": "7-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTake 2 map: \\n1: Counter number frequency - tableNum[num, freq]\\n2: Frequency counter - tableFreq[freq, count]\\n\\nAdd `number`: If `tableNum` contains this `number` then in `tableFreq` reduce the number of its frequency `--tableFreq[tableNum[number]];`. Then anyway increase the number of `number` in `tableNum` and increase number of frequency `++tableFreq[++tableNum[number]];`.\\n\\nDelete `number`: Do the same thing, only in reverse order.\\nIf `tableNum` contains this `number` then in `tableFreq` reduce the number of its frequency then reduce number of `number` in `tableNum`: `--tableFreq[tableNum[number]--];`. Then increase number of frequency `++tableFreq[tableNum[number]];`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(2n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker \\n{\\npublic:\\n    FrequencyTracker() {}\\n    \\n    void add(int number) \\n    {\\n        if (tableNum[number])\\n            --tableFreq[tableNum[number]];\\n        ++tableFreq[++tableNum[number]];\\n    }\\n    \\n    void deleteOne(int number) \\n    {\\n        if (tableNum[number])\\n        {\\n            --tableFreq[tableNum[number]--];\\n            ++tableFreq[tableNum[number]];\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) \\n    {\\n        return tableFreq[frequency];\\n    }\\n\\nprivate:\\n    unordered_map<int, int> tableNum, tableFreq;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker \\n{\\npublic:\\n    FrequencyTracker() {}\\n    \\n    void add(int number) \\n    {\\n        if (tableNum[number])\\n            --tableFreq[tableNum[number]];\\n        ++tableFreq[++tableNum[number]];\\n    }\\n    \\n    void deleteOne(int number) \\n    {\\n        if (tableNum[number])\\n        {\\n            --tableFreq[tableNum[number]--];\\n            ++tableFreq[tableNum[number]];\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) \\n    {\\n        return tableFreq[frequency];\\n    }\\n\\nprivate:\\n    unordered_map<int, int> tableNum, tableFreq;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580194,
                "title": "frequency-tracker-hash-table-two-maps-o-1-time-complexity-o-n-space-complexity",
                "content": "# Intuition\\nWe can use maps to represent the added values and their frequencies. One other map is to be used for keeping the track if any element with specific frequency exist or not.\\n\\n# Approach\\n- Take two maps, mp for <value, frequency>, mp2 for <frequency, frequency of frequency>\\n- Nothing to be done in FrequenyTracker\\n- update mp and mp2 in add such that mp[number] increase by one, and old frequency of number decreases and new one increases\\n- deleteOne will do opposite of add for mp, but same for mp2, mp[number] decreases, and old frequency decreases and new one increases\\n- to check if any element exist with given frequency, just check mp2, if frequency of frequency is greater than 0, return \\'true\\', else \\'false\\'\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    unordered_map<int,int> mp;\\n    unordered_map<int,int> mp2;\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        mp[number]++;\\n        mp2[mp[number]]++;\\n        mp2[mp[number]-1]--; \\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number]>0){\\n            mp[number]--;\\n            if(mp[number]!=0)\\n                mp2[mp[number]]++;\\n            mp2[mp[number]+1]--; \\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return mp2[frequency];\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    unordered_map<int,int> mp;\\n    unordered_map<int,int> mp2;\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        mp[number]++;\\n        mp2[mp[number]]++;\\n        mp2[mp[number]-1]--; \\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number]>0){\\n            mp[number]--;\\n            if(mp[number]!=0)\\n                mp2[mp[number]]++;\\n            mp2[mp[number]+1]--; \\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return mp2[frequency];\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574827,
                "title": "easy-c-code-to-understand-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need two map \\nI> to store number and frequency\\nII> to store which number has same frequency\\n\\nfirst errase its occurance from the frequency mapping\\nupdate the mapping mp\\nThen add to the new frequency..\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int, int> mp;\\n    unordered_map<int, int> mp2;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(mp.find(number) != mp.end()){\\n            mp2[mp[number]]--;\\n        }\\n        mp[number]++;\\n        mp2[mp[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp.find(number) != mp.end() && mp[number] > 0)\\n        {\\n            mp2[mp[number]]--;\\n            mp[number]--;\\n            mp2[mp[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return (mp2[frequency] > 0);\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int, int> mp;\\n    unordered_map<int, int> mp2;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(mp.find(number) != mp.end()){\\n            mp2[mp[number]]--;\\n        }\\n        mp[number]++;\\n        mp2[mp[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp.find(number) != mp.end() && mp[number] > 0)\\n        {\\n            mp2[mp[number]]--;\\n            mp[number]--;\\n            mp2[mp[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return (mp2[frequency] > 0);\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555050,
                "title": "solution-using-two-unordered-maps",
                "content": "\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> ump1;\\n    unordered_map<int,int> ump2;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int x) {\\n        if(ump1.find(x)!=ump1.end()){\\n            int oldfreq = ump1[x];\\n            ump1[x]++;\\n            ump2[oldfreq]--;\\n            ump2[ump1[x]]++;\\n        }\\n        else{\\n            ump1[x]++;\\n            ump2[1]++;\\n        }\\n    }\\n    \\n    void deleteOne(int x) {\\n        if(ump1.find(x)!=ump1.end()){\\n            int oldfreq = ump1[x];\\n            ump1[x]--;\\n            if(ump1[x]==0) {\\n                ump1.erase(x);\\n                ump2[oldfreq]--;\\n                return;\\n            }\\n            ump2[oldfreq]--;\\n            ump2[ump1[x]]++;\\n        }\\n        else{\\n            return;\\n        }\\n    }\\n    \\n    bool hasFrequency(int freq) {\\n        // cout<<\"ump1\"<<endl;\\n        // for(auto x:ump1){\\n        //     cout<<x.first<<\"-->\"<<x.second<<endl;\\n        // }\\n        // cout<<\"ump2\"<<endl;\\n        // for(auto x:ump2){\\n        //     cout<<x.first<<\"-->\"<<x.second<<endl;\\n        // }\\n        if(ump2[freq]>0){\\n            return true;\\n        }\\n        else\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> ump1;\\n    unordered_map<int,int> ump2;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int x) {\\n        if(ump1.find(x)!=ump1.end()){\\n            int oldfreq = ump1[x];\\n            ump1[x]++;\\n            ump2[oldfreq]--;\\n            ump2[ump1[x]]++;\\n        }\\n        else{\\n            ump1[x]++;\\n            ump2[1]++;\\n        }\\n    }\\n    \\n    void deleteOne(int x) {\\n        if(ump1.find(x)!=ump1.end()){\\n            int oldfreq = ump1[x];\\n            ump1[x]--;\\n            if(ump1[x]==0) {\\n                ump1.erase(x);\\n                ump2[oldfreq]--;\\n                return;\\n            }\\n            ump2[oldfreq]--;\\n            ump2[ump1[x]]++;\\n        }\\n        else{\\n            return;\\n        }\\n    }\\n    \\n    bool hasFrequency(int freq) {\\n        // cout<<\"ump1\"<<endl;\\n        // for(auto x:ump1){\\n        //     cout<<x.first<<\"-->\"<<x.second<<endl;\\n        // }\\n        // cout<<\"ump2\"<<endl;\\n        // for(auto x:ump2){\\n        //     cout<<x.first<<\"-->\"<<x.second<<endl;\\n        // }\\n        if(ump2[freq]>0){\\n            return true;\\n        }\\n        else\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3554997,
                "title": "c-easiest-solution-using-2-hashmaps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> mp;\\n    unordered_map<int,int>freq;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(freq[mp[number]]!=0)freq[mp[number]]--;\\n        mp[number]++;\\n        freq[mp[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(freq[mp[number]]!=0)freq[mp[number]]--;\\n        if(mp[number]!=0)mp[number]--;\\n        freq[mp[number]]++;\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq[frequency]!=0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> mp;\\n    unordered_map<int,int>freq;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(freq[mp[number]]!=0)freq[mp[number]]--;\\n        mp[number]++;\\n        freq[mp[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(freq[mp[number]]!=0)freq[mp[number]]--;\\n        if(mp[number]!=0)mp[number]--;\\n        freq[mp[number]]++;\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq[frequency]!=0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548740,
                "title": "easy-python3-two-dicts",
                "content": "# Code\\n```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.freqToNum = collections.defaultdict(int)\\n        self.numtofreq = collections.defaultdict(int)\\n\\n    def add(self, num: int) -> None:\\n        if self.numtofreq[num] > 0:\\n            self.freqToNum[self.numtofreq[num]]-=1\\n        self.numtofreq[num]+=1\\n        self.freqToNum[self.numtofreq[num]]+=1\\n\\n\\n    def deleteOne(self, num: int) -> None:\\n        if self.numtofreq[num] > 0:\\n            self.freqToNum[self.numtofreq[num]]-=1\\n            self.numtofreq[num]-=1\\n            if self.numtofreq[num] > 0:\\n                self.freqToNum[self.numtofreq[num]]+=1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freqToNum[frequency] > 0\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.freqToNum = collections.defaultdict(int)\\n        self.numtofreq = collections.defaultdict(int)\\n\\n    def add(self, num: int) -> None:\\n        if self.numtofreq[num] > 0:\\n            self.freqToNum[self.numtofreq[num]]-=1\\n        self.numtofreq[num]+=1\\n        self.freqToNum[self.numtofreq[num]]+=1\\n\\n\\n    def deleteOne(self, num: int) -> None:\\n        if self.numtofreq[num] > 0:\\n            self.freqToNum[self.numtofreq[num]]-=1\\n            self.numtofreq[num]-=1\\n            if self.numtofreq[num] > 0:\\n                self.freqToNum[self.numtofreq[num]]+=1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freqToNum[frequency] > 0\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546065,
                "title": "simple-java-solution",
                "content": "\\n# Code\\n```\\nclass FrequencyTracker {\\n    \\n    HashMap<Integer, Integer> map;\\n    int[] freq;\\n    public FrequencyTracker() {\\n        map = new HashMap<>();\\n        freq = new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n        if(map.containsKey(number)){\\n            freq[map.get(number)]--;\\n            map.put(number, map.get(number) + 1);\\n            freq[map.get(number)]++;\\n        }else{\\n            map.put(number, 1);\\n            freq[1]++;\\n        }\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(map.containsKey(number)){\\n            if(map.get(number) == 1){\\n                map.remove(number);\\n                freq[1]--;\\n            }\\n            else{\\n                freq[map.get(number)]--;\\n                map.put(number, map.get(number)-1);\\n                freq[map.get(number)]++;\\n            }\\n                \\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(freq[frequency]>0)\\n            return true;\\n        else\\n            return false;\\n            \\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    \\n    HashMap<Integer, Integer> map;\\n    int[] freq;\\n    public FrequencyTracker() {\\n        map = new HashMap<>();\\n        freq = new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n        if(map.containsKey(number)){\\n            freq[map.get(number)]--;\\n            map.put(number, map.get(number) + 1);\\n            freq[map.get(number)]++;\\n        }else{\\n            map.put(number, 1);\\n            freq[1]++;\\n        }\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(map.containsKey(number)){\\n            if(map.get(number) == 1){\\n                map.remove(number);\\n                freq[1]--;\\n            }\\n            else{\\n                freq[map.get(number)]--;\\n                map.put(number, map.get(number)-1);\\n                freq[map.get(number)]++;\\n            }\\n                \\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(freq[frequency]>0)\\n            return true;\\n        else\\n            return false;\\n            \\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545370,
                "title": "a-few-solutions",
                "content": "Use two maps `bucket` and `counter`:\\n\\n1. \\uD83E\\uDEA3 `bucket` associates frequency with a set of values `x` per frequency\\n2. \\uD83D\\uDD22 `counter` associates each value `x` with frequency of each value `x`\\n\\n---\\n\\n*Kotlin*\\n```\\nclass FrequencyTracker() {\\n    private var bucket = mutableMapOf<Int, MutableSet<Int>>()\\n    private var count = mutableMapOf<Int, Int>()\\n    private fun _update(x: Int, diff: Int) {\\n        if (count.contains(x) && bucket.contains(count[x]!!) && bucket[count[x]!!]!!.contains(x))\\n            bucket[count[x]!!]!!.remove(x)\\n        count[x] = Math.max(0, (count[x] ?: 0) + diff)\\n        if (0 < count[x]!! && !bucket.contains(count[x]!!))\\n            bucket[count[x]!!] = mutableSetOf<Int>()\\n        if (bucket.contains(count[x]!!))\\n            bucket[count[x]!!]!!.add(x)\\n    }\\n    fun add(x: Int) { _update(x, 1) }\\n    fun deleteOne(x: Int) { _update(x, -1) }\\n    var hasFrequency = { cnt: Int -> bucket.contains(cnt) && 0 < bucket[cnt]!!.size }\\n}\\n```\\n\\n*Javascript*\\n```\\nclass FrequencyTracker {\\n    constructor() {\\n        this.bucket = new Map();\\n        this.count = new Map();\\n    }\\n    _update(x, diff) {\\n        if (this.bucket.has(this.count.get(x)))\\n            this.bucket.get(this.count.get(x)).delete(x);\\n        this.count.set(x, Math.max(0, (this.count.get(x) || 0) + diff));\\n        if (!this.bucket.has(this.count.get(x)))\\n            this.bucket.set(this.count.get(x), new Set());\\n        this.bucket.get(this.count.get(x)).add(x);\\n    }\\n    add(x) { this._update(x, 1); }\\n    deleteOne(x) { this._update(x, -1); }\\n    hasFrequency = cnt => this.bucket.has(cnt) && this.bucket.get(cnt).size\\n}\\n```\\n\\n*Python3*\\n```\\nclass FrequencyTracker:\\n    def __init__(self):\\n        self.bucket = defaultdict(set)\\n        self.count = Counter()\\n\\n    def _update(self, x, diff):\\n        if self.count[x] in self.bucket and x in self.bucket[self.count[x]]:\\n            self.bucket[self.count[x]].remove(x)\\n        self.count[x] = max(0, self.count[x] + diff)\\n        self.bucket[self.count[x]].add(x)\\n        \\n    def add(self, x: int) -> None:\\n        self._update(x, 1)\\n\\n    def deleteOne(self, x: int) -> None:\\n        self._update(x, -1)\\n\\n    hasFrequency = lambda self, cnt: len(self.bucket[cnt])\\n```\\n\\n*Rust*\\n```\\n// TODO: implement me!\\n```\\n\\n*C++*\\n```\\nclass FrequencyTracker {\\n    using Set = unordered_set<int>;\\n    using Bucket = unordered_map<int, Set>;\\n    using Counter = unordered_map<int, int>;\\n    Bucket bucket;\\n    Counter counter;\\n    void _update(int x, int diff) {\\n        if (bucket.find(counter[x]) != bucket.end())\\n            bucket[counter[x]].erase(x);\\n        counter[x] = max(0, counter[x] + diff);\\n        bucket[counter[x]].insert(x);\\n    }\\npublic:\\n    void add(int x) { _update(x, 1); }\\n    void deleteOne(int x) { _update(x, -1); }\\n    bool hasFrequency(int cnt) { return bucket[cnt].size(); }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass FrequencyTracker() {\\n    private var bucket = mutableMapOf<Int, MutableSet<Int>>()\\n    private var count = mutableMapOf<Int, Int>()\\n    private fun _update(x: Int, diff: Int) {\\n        if (count.contains(x) && bucket.contains(count[x]!!) && bucket[count[x]!!]!!.contains(x))\\n            bucket[count[x]!!]!!.remove(x)\\n        count[x] = Math.max(0, (count[x] ?: 0) + diff)\\n        if (0 < count[x]!! && !bucket.contains(count[x]!!))\\n            bucket[count[x]!!] = mutableSetOf<Int>()\\n        if (bucket.contains(count[x]!!))\\n            bucket[count[x]!!]!!.add(x)\\n    }\\n    fun add(x: Int) { _update(x, 1) }\\n    fun deleteOne(x: Int) { _update(x, -1) }\\n    var hasFrequency = { cnt: Int -> bucket.contains(cnt) && 0 < bucket[cnt]!!.size }\\n}\\n```\n```\\nclass FrequencyTracker {\\n    constructor() {\\n        this.bucket = new Map();\\n        this.count = new Map();\\n    }\\n    _update(x, diff) {\\n        if (this.bucket.has(this.count.get(x)))\\n            this.bucket.get(this.count.get(x)).delete(x);\\n        this.count.set(x, Math.max(0, (this.count.get(x) || 0) + diff));\\n        if (!this.bucket.has(this.count.get(x)))\\n            this.bucket.set(this.count.get(x), new Set());\\n        this.bucket.get(this.count.get(x)).add(x);\\n    }\\n    add(x) { this._update(x, 1); }\\n    deleteOne(x) { this._update(x, -1); }\\n    hasFrequency = cnt => this.bucket.has(cnt) && this.bucket.get(cnt).size\\n}\\n```\n```\\nclass FrequencyTracker:\\n    def __init__(self):\\n        self.bucket = defaultdict(set)\\n        self.count = Counter()\\n\\n    def _update(self, x, diff):\\n        if self.count[x] in self.bucket and x in self.bucket[self.count[x]]:\\n            self.bucket[self.count[x]].remove(x)\\n        self.count[x] = max(0, self.count[x] + diff)\\n        self.bucket[self.count[x]].add(x)\\n        \\n    def add(self, x: int) -> None:\\n        self._update(x, 1)\\n\\n    def deleteOne(self, x: int) -> None:\\n        self._update(x, -1)\\n\\n    hasFrequency = lambda self, cnt: len(self.bucket[cnt])\\n```\n```\\n// TODO: implement me!\\n```\n```\\nclass FrequencyTracker {\\n    using Set = unordered_set<int>;\\n    using Bucket = unordered_map<int, Set>;\\n    using Counter = unordered_map<int, int>;\\n    Bucket bucket;\\n    Counter counter;\\n    void _update(int x, int diff) {\\n        if (bucket.find(counter[x]) != bucket.end())\\n            bucket[counter[x]].erase(x);\\n        counter[x] = max(0, counter[x] + diff);\\n        bucket[counter[x]].insert(x);\\n    }\\npublic:\\n    void add(int x) { _update(x, 1); }\\n    void deleteOne(int x) { _update(x, -1); }\\n    bool hasFrequency(int cnt) { return bucket[cnt].size(); }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545153,
                "title": "2-hashmaps-of-numbers-and-frequencies",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse hashmaps of numbers and frequencies and update them accordingly to keep track of the state. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAll operations are $$O(1)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$, where $$n$$ is the number of items inserted.\\n\\n# Code\\n\\nI added an additional update function to not repeat myself, direction is to indicate if which directions the number move. I am also still learning a lot of rust so feel free to give me feedback.\\n\\n```\\nuse std::collections::HashMap;\\n\\nstruct FrequencyTracker {\\n    numbers: HashMap<i32, i32>,\\n    frequency: HashMap<i32, i32>,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl FrequencyTracker {\\n\\n    fn new() -> Self {\\n        Self {\\n            numbers: HashMap::new(),\\n            frequency: HashMap::new(),\\n        }\\n    }\\n\\n    fn update(&mut self, number: i32, dir: i32) {\\n        let old_freq = *self.numbers.entry(number).or_default();\\n        self.frequency.entry(old_freq).and_modify(|c| *c -= 1);\\n        self.numbers.entry(number).and_modify(|c| *c += dir).or_insert(1);\\n        self.frequency.entry(old_freq + dir).and_modify(|c| *c += 1).or_insert(1);\\n    }\\n    \\n    fn add(&mut self, number: i32) {\\n        self.update(number, 1);\\n    }\\n    \\n    fn delete_one(&mut self, number: i32) {\\n        if self.numbers.contains_key(&number) && self.numbers[&number] > 0 {\\n            self.update(number, -1);\\n        }\\n    }\\n    \\n    fn has_frequency(&self, frequency: i32) -> bool {        \\n        self.frequency.contains_key(&frequency) && self.frequency[&frequency] > 0\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * let obj = FrequencyTracker::new();\\n * obj.add(number);\\n * obj.delete_one(number);\\n * let ret_3: bool = obj.has_frequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nstruct FrequencyTracker {\\n    numbers: HashMap<i32, i32>,\\n    frequency: HashMap<i32, i32>,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl FrequencyTracker {\\n\\n    fn new() -> Self {\\n        Self {\\n            numbers: HashMap::new(),\\n            frequency: HashMap::new(),\\n        }\\n    }\\n\\n    fn update(&mut self, number: i32, dir: i32) {\\n        let old_freq = *self.numbers.entry(number).or_default();\\n        self.frequency.entry(old_freq).and_modify(|c| *c -= 1);\\n        self.numbers.entry(number).and_modify(|c| *c += dir).or_insert(1);\\n        self.frequency.entry(old_freq + dir).and_modify(|c| *c += 1).or_insert(1);\\n    }\\n    \\n    fn add(&mut self, number: i32) {\\n        self.update(number, 1);\\n    }\\n    \\n    fn delete_one(&mut self, number: i32) {\\n        if self.numbers.contains_key(&number) && self.numbers[&number] > 0 {\\n            self.update(number, -1);\\n        }\\n    }\\n    \\n    fn has_frequency(&self, frequency: i32) -> bool {        \\n        self.frequency.contains_key(&frequency) && self.frequency[&frequency] > 0\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * let obj = FrequencyTracker::new();\\n * obj.add(number);\\n * obj.delete_one(number);\\n * let ret_3: bool = obj.has_frequency(frequency);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3544275,
                "title": "o-1-java",
                "content": "\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n\\n    Map<Integer,Integer> numbersFreq, freqsFreq;\\n    public FrequencyTracker() {\\n        numbersFreq = new HashMap();\\n        freqsFreq = new HashMap();\\n    }\\n    \\n    public void add(int number) {\\n        if (numbersFreq.containsKey(number) && numbersFreq.get(number) > 0){\\n            int prevFreq = numbersFreq.get(number);\\n            freqsFreq.put(prevFreq,freqsFreq.get(prevFreq)-1);\\n            freqsFreq.put(prevFreq+1,freqsFreq.getOrDefault(prevFreq+1,0)+1);\\n            numbersFreq.put(number,numbersFreq.get(number)+1);\\n        }\\n        else{\\n            freqsFreq.put(1, freqsFreq.getOrDefault(1,0)+1);\\n            numbersFreq.put(number,1);\\n        }\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if (numbersFreq.containsKey(number) && numbersFreq.get(number) > 0){\\n            int prevFreq = numbersFreq.get(number);\\n            freqsFreq.put(prevFreq , freqsFreq.get(prevFreq) - 1);\\n            freqsFreq.put(prevFreq-1,freqsFreq.getOrDefault(prevFreq-1,0)+1);\\n            numbersFreq.put(number, numbersFreq.get(number) - 1);\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return (freqsFreq.containsKey(frequency) && freqsFreq.get(frequency)>0);\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n\\n    Map<Integer,Integer> numbersFreq, freqsFreq;\\n    public FrequencyTracker() {\\n        numbersFreq = new HashMap();\\n        freqsFreq = new HashMap();\\n    }\\n    \\n    public void add(int number) {\\n        if (numbersFreq.containsKey(number) && numbersFreq.get(number) > 0){\\n            int prevFreq = numbersFreq.get(number);\\n            freqsFreq.put(prevFreq,freqsFreq.get(prevFreq)-1);\\n            freqsFreq.put(prevFreq+1,freqsFreq.getOrDefault(prevFreq+1,0)+1);\\n            numbersFreq.put(number,numbersFreq.get(number)+1);\\n        }\\n        else{\\n            freqsFreq.put(1, freqsFreq.getOrDefault(1,0)+1);\\n            numbersFreq.put(number,1);\\n        }\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if (numbersFreq.containsKey(number) && numbersFreq.get(number) > 0){\\n            int prevFreq = numbersFreq.get(number);\\n            freqsFreq.put(prevFreq , freqsFreq.get(prevFreq) - 1);\\n            freqsFreq.put(prevFreq-1,freqsFreq.getOrDefault(prevFreq-1,0)+1);\\n            numbersFreq.put(number, numbersFreq.get(number) - 1);\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return (freqsFreq.containsKey(frequency) && freqsFreq.get(frequency)>0);\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539219,
                "title": "easiest-c-solution-ever-seen",
                "content": "# Intuition\\nJUST SEE THE CODE YOU WILL COME TO KNOW. WE USE TWO MAPS ONE TO STORE NUMBER AND ONE TO STORE FREQUENCY OF THE NUMBERS\\n# Approach\\nUSE DOUBLE UNORDERED MAP\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(N)\\n![random image.jpeg](https://assets.leetcode.com/users/images/d80e2da0-26d0-4d80-aea5-0ffe90197bb1_1684430088.198616.jpeg)\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    \\n    unordered_map<int,int>mp;       //stores number\\n    unordered_map<int,int>mpp;      //stores frequency of the numbers\\n\\n    FrequencyTracker() {\\n     \\n    }\\n    \\n    void add(int number) {\\n       \\n        mpp[mp[number]]--;\\n        mp[number]++;\\n        mpp[mp[number]]++;\\n        \\n    }\\n    \\n    void deleteOne(int number) {\\n\\n        if(mp[number]>0)\\n        {\\n            mpp[mp[number]]--;\\n            mp[number]--;\\n            mpp[mp[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n         return mpp[frequency]>0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    \\n    unordered_map<int,int>mp;       //stores number\\n    unordered_map<int,int>mpp;      //stores frequency of the numbers\\n\\n    FrequencyTracker() {\\n     \\n    }\\n    \\n    void add(int number) {\\n       \\n        mpp[mp[number]]--;\\n        mp[number]++;\\n        mpp[mp[number]]++;\\n        \\n    }\\n    \\n    void deleteOne(int number) {\\n\\n        if(mp[number]>0)\\n        {\\n            mpp[mp[number]]--;\\n            mp[number]--;\\n            mpp[mp[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n         return mpp[frequency]>0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539176,
                "title": "java-using-hashmap-as-a-frequency-map",
                "content": "# Code\\n```\\nclass FrequencyTracker {\\n\\n    Map<Integer, Set<Integer>> map;\\n\\n    public FrequencyTracker() {\\n        map = new HashMap<>();\\n        map.put(0, new HashSet<>());\\n        map.put(1, new HashSet<>());\\n    }\\n\\n    public void add(int number) {\\n        int f = -1;\\n        for (int freq : map.keySet()) {\\n            if (map.get(freq).contains(number)) {\\n                f = freq;\\n                break;\\n            }\\n        }\\n        if (f > -1) {\\n            map.get(f).remove(number);\\n            map.computeIfAbsent(f + 1, HashSet::new).add(number);\\n        } else {\\n            map.get(1).add(number);\\n        }\\n    }\\n\\n    public void deleteOne(int number) {\\n        int f = -1;\\n        for (int freq : map.keySet()) {\\n            if (map.get(freq).contains(number)) {\\n                f = freq;\\n                break;\\n            }\\n        }\\n        if (f > 0) {\\n            map.get(f).remove(number);\\n            map.get(f - 1).add(number);\\n        }\\n    }\\n\\n    public boolean hasFrequency(int frequency) {\\n        return map.containsKey(frequency) && map.get(frequency).size() > 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n\\n    Map<Integer, Set<Integer>> map;\\n\\n    public FrequencyTracker() {\\n        map = new HashMap<>();\\n        map.put(0, new HashSet<>());\\n        map.put(1, new HashSet<>());\\n    }\\n\\n    public void add(int number) {\\n        int f = -1;\\n        for (int freq : map.keySet()) {\\n            if (map.get(freq).contains(number)) {\\n                f = freq;\\n                break;\\n            }\\n        }\\n        if (f > -1) {\\n            map.get(f).remove(number);\\n            map.computeIfAbsent(f + 1, HashSet::new).add(number);\\n        } else {\\n            map.get(1).add(number);\\n        }\\n    }\\n\\n    public void deleteOne(int number) {\\n        int f = -1;\\n        for (int freq : map.keySet()) {\\n            if (map.get(freq).contains(number)) {\\n                f = freq;\\n                break;\\n            }\\n        }\\n        if (f > 0) {\\n            map.get(f).remove(number);\\n            map.get(f - 1).add(number);\\n        }\\n    }\\n\\n    public boolean hasFrequency(int frequency) {\\n        return map.containsKey(frequency) && map.get(frequency).size() > 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533013,
                "title": "two-hashmap-solution-just-for-reference",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTwo HashMaps - One to keep number and its frequency and other as reverse mapping that contains frequency as a key and set of numbers as values.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDisclaimer - Not a recommended way, I posted here just for reference.\\n\\nIf the solution with two arrays does not click within time then you can try it this way, But It is a hard way to do it, and I find it time-consuming and difficult to tackle all scenarios.\\n\\n# Complexity\\n- Time complexity: O(1) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n\\n    private Map<Integer,Integer> fMap;\\n    private Map<Integer,Set<Integer>> fSet;\\n\\n    public FrequencyTracker() {\\n        this.fMap = new HashMap<>();\\n        this.fSet = new HashMap<>();\\n    }\\n    \\n    public void add(int number) {\\n        if(this.fMap.containsKey(number)) {\\n            int oldFreq = this.fMap.get(number);\\n            int newFreq = oldFreq + 1;\\n            this.fMap.put(number, newFreq);\\n            updateFSet(newFreq, oldFreq, number);\\n        }else {\\n            this.fMap.put(number, 1);\\n            //updateFSet(1, 0, number);\\n            if(this.fSet.containsKey(1)) {\\n                this.fSet.get(1).add(number);\\n            }else {\\n                Set<Integer> set = new HashSet<>();\\n                set.add(number);\\n                this.fSet.put(1, set);\\n            }\\n          \\n        }\\n        //this.map.put(number, this.map.getOrDefault(number, 0)+1);\\n    }\\n\\n    private void updateFSet(int newFreq, int oldFreq, int number) {\\n        Set<Integer> set = fSet.get(oldFreq);\\n        set.remove(number);\\n        //remove set if no element left\\n        if(set.isEmpty()) {\\n            this.fSet.remove(oldFreq);\\n        }\\n        //add number \\n        if(fSet.containsKey(newFreq)) {\\n            fSet.get(newFreq).add(number);\\n        }else{\\n            Set<Integer> nset = new HashSet<>();\\n            nset.add(number);\\n            fSet.put(newFreq, nset);\\n        }\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(this.fMap.containsKey(number)) {\\n            int oldFreq = this.fMap.get(number);\\n            int newFreq = oldFreq - 1;\\n            this.fMap.put(number, newFreq);\\n            if(newFreq == 0) {\\n                this.fMap.remove(number);\\n            }\\n            updateFSet(newFreq, oldFreq, number);\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(this.fSet.containsKey(frequency)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\n\\n    private Map<Integer,Integer> fMap;\\n    private Map<Integer,Set<Integer>> fSet;\\n\\n    public FrequencyTracker() {\\n        this.fMap = new HashMap<>();\\n        this.fSet = new HashMap<>();\\n    }\\n    \\n    public void add(int number) {\\n        if(this.fMap.containsKey(number)) {\\n            int oldFreq = this.fMap.get(number);\\n            int newFreq = oldFreq + 1;\\n            this.fMap.put(number, newFreq);\\n            updateFSet(newFreq, oldFreq, number);\\n        }else {\\n            this.fMap.put(number, 1);\\n            //updateFSet(1, 0, number);\\n            if(this.fSet.containsKey(1)) {\\n                this.fSet.get(1).add(number);\\n            }else {\\n                Set<Integer> set = new HashSet<>();\\n                set.add(number);\\n                this.fSet.put(1, set);\\n            }\\n          \\n        }\\n        //this.map.put(number, this.map.getOrDefault(number, 0)+1);\\n    }\\n\\n    private void updateFSet(int newFreq, int oldFreq, int number) {\\n        Set<Integer> set = fSet.get(oldFreq);\\n        set.remove(number);\\n        //remove set if no element left\\n        if(set.isEmpty()) {\\n            this.fSet.remove(oldFreq);\\n        }\\n        //add number \\n        if(fSet.containsKey(newFreq)) {\\n            fSet.get(newFreq).add(number);\\n        }else{\\n            Set<Integer> nset = new HashSet<>();\\n            nset.add(number);\\n            fSet.put(newFreq, nset);\\n        }\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(this.fMap.containsKey(number)) {\\n            int oldFreq = this.fMap.get(number);\\n            int newFreq = oldFreq - 1;\\n            this.fMap.put(number, newFreq);\\n            if(newFreq == 0) {\\n                this.fMap.remove(number);\\n            }\\n            updateFSet(newFreq, oldFreq, number);\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(this.fSet.containsKey(frequency)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527010,
                "title": "easy-c-solution-map-solution",
                "content": "# Intuition\\nThe intuition is to store the number and their frequencies to be accessible in both ways.\\n\\n# Approach\\nTake an unordered_map to store number with their frequencies and a map to store frequencies in a map with the numbers that have that frequency.\\n\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    unordered_map<int, int> mp;\\n    map<int, unordered_set<int>> freq;\\npublic:\\n    FrequencyTracker() {\\n\\n    }\\n    \\n    void add(int number) {\\n        if(mp.find(number)!= mp.end()){\\n            int cur= mp[number];\\n            if(cur>0) freq[cur].erase(number);\\n        }\\n        mp[number]++;\\n        freq[mp[number]].insert(number); \\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp.find(number)!= mp.end()){\\n            int cur= mp[number];\\n            mp[number]--;\\n            if(cur>0) freq[cur].erase(number);\\n            if(mp[number]>0) freq[mp[number]].insert(number); \\n            else mp.erase(number);\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(freq[frequency].size()>0) return true;\\n        else return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    unordered_map<int, int> mp;\\n    map<int, unordered_set<int>> freq;\\npublic:\\n    FrequencyTracker() {\\n\\n    }\\n    \\n    void add(int number) {\\n        if(mp.find(number)!= mp.end()){\\n            int cur= mp[number];\\n            if(cur>0) freq[cur].erase(number);\\n        }\\n        mp[number]++;\\n        freq[mp[number]].insert(number); \\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp.find(number)!= mp.end()){\\n            int cur= mp[number];\\n            mp[number]--;\\n            if(cur>0) freq[cur].erase(number);\\n            if(mp[number]>0) freq[mp[number]].insert(number); \\n            else mp.erase(number);\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(freq[frequency].size()>0) return true;\\n        else return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524024,
                "title": "java-hashmap-easy-to-understand",
                "content": "```\\nclass FrequencyTracker {\\n    private HashMap<Integer, Integer> map;\\n    private HashMap<Integer, Integer> valmap;\\n    public FrequencyTracker() {\\n        map = new HashMap<>();\\n        valmap = new HashMap<>();\\n    }\\n    \\n    public void add(int number) {\\n        if(map.containsKey(number)) {\\n            int freq = map.get(number); \\n            map.put(number, freq + 1); \\n            valmap.put(freq+1, valmap.getOrDefault(freq+1, 0) + 1);\\n            valmap.put(freq, valmap.getOrDefault(freq, 0) - 1);\\n            if(valmap.get(freq) == 0){\\n                valmap.remove(freq);\\n            }\\n        }\\n        else {\\n           map.put(number, map.getOrDefault(number, 0) + 1);\\n           valmap.put(map.get(number), valmap.getOrDefault(map.get(number), 0) + 1); \\n        }\\n        \\n    }\\n    \\n    public void deleteOne(int number) {\\n       \\n        if(map.containsKey(number)) {\\n            int freq = map.get(number);\\n            map.put(number, freq - 1);   // freq ko 1 ghatao and freq-1 ko 1 badhao in valmap\\n            if(map.get(number) == 0){\\n                map.remove(number);\\n            }\\n            valmap.put(freq , valmap.get(freq) - 1);\\n            if(valmap.get(freq) == 0){\\n                valmap.remove(freq);\\n            }\\n            valmap.put(freq-1 , valmap.getOrDefault(freq-1, 0) + 1);\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(valmap.containsKey(frequency)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    private HashMap<Integer, Integer> map;\\n    private HashMap<Integer, Integer> valmap;\\n    public FrequencyTracker() {\\n        map = new HashMap<>();\\n        valmap = new HashMap<>();\\n    }\\n    \\n    public void add(int number) {\\n        if(map.containsKey(number)) {\\n            int freq = map.get(number); \\n            map.put(number, freq + 1); \\n            valmap.put(freq+1, valmap.getOrDefault(freq+1, 0) + 1);\\n            valmap.put(freq, valmap.getOrDefault(freq, 0) - 1);\\n            if(valmap.get(freq) == 0){\\n                valmap.remove(freq);\\n            }\\n        }\\n        else {\\n           map.put(number, map.getOrDefault(number, 0) + 1);\\n           valmap.put(map.get(number), valmap.getOrDefault(map.get(number), 0) + 1); \\n        }\\n        \\n    }\\n    \\n    public void deleteOne(int number) {\\n       \\n        if(map.containsKey(number)) {\\n            int freq = map.get(number);\\n            map.put(number, freq - 1);   // freq ko 1 ghatao and freq-1 ko 1 badhao in valmap\\n            if(map.get(number) == 0){\\n                map.remove(number);\\n            }\\n            valmap.put(freq , valmap.get(freq) - 1);\\n            if(valmap.get(freq) == 0){\\n                valmap.remove(freq);\\n            }\\n            valmap.put(freq-1 , valmap.getOrDefault(freq-1, 0) + 1);\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(valmap.containsKey(frequency)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3523539,
                "title": "c-two-array-much-simpler-than-two-maps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs the constrains not so big(up to `10^5`) we can use two array. And it will be little faster, simpler than using two `HashTables`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- `int[] freq;` Frequency of numbers of size `100001`\\n- ` int[] freqFreq;` Frequencies of frequency) of size `100001`\\n \\n# Complexity\\n- Time complexity:$$O(1)$$ for each operation.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity::$$O(n)$$, where n = distinct numbers\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class FrequencyTracker {\\n    int[] freq;\\n    int[] freqFreq;\\n\\n    public FrequencyTracker() {\\n        freq = new int[100001];\\n        freqFreq = new int[100001];\\n    }\\n\\n    public void Add(int number) {\\n        int oldCnt = freq[number];\\n        freq[number]++;\\n\\n        freqFreq[oldCnt]--;\\n        freqFreq[freq[number]]++;\\n    }\\n\\n    public void DeleteOne(int number) {\\n        if (freq[number] > 0) {\\n            int oldCnt = freq[number];\\n            freq[number]--;\\n\\n            freqFreq[oldCnt]--;\\n            freqFreq[freq[number]]++;\\n        }\\n    }\\n\\n    public bool HasFrequency(int frequency) {\\n        return freqFreq[frequency] > 0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.Add(number);\\n * obj.DeleteOne(number);\\n * bool param_3 = obj.HasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C#",
                    "Array"
                ],
                "code": "```\\npublic class FrequencyTracker {\\n    int[] freq;\\n    int[] freqFreq;\\n\\n    public FrequencyTracker() {\\n        freq = new int[100001];\\n        freqFreq = new int[100001];\\n    }\\n\\n    public void Add(int number) {\\n        int oldCnt = freq[number];\\n        freq[number]++;\\n\\n        freqFreq[oldCnt]--;\\n        freqFreq[freq[number]]++;\\n    }\\n\\n    public void DeleteOne(int number) {\\n        if (freq[number] > 0) {\\n            int oldCnt = freq[number];\\n            freq[number]--;\\n\\n            freqFreq[oldCnt]--;\\n            freqFreq[freq[number]]++;\\n        }\\n    }\\n\\n    public bool HasFrequency(int frequency) {\\n        return freqFreq[frequency] > 0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.Add(number);\\n * obj.DeleteOne(number);\\n * bool param_3 = obj.HasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523458,
                "title": "c-two-dictionaries",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- `Dictionary<int, int> freq;` Frequency of numbers\\n- ` Dictionary<int, int> freqFreq;` Frequencies of frequency)\\n- `private void UpdateCntFromTo(int oldCnt, int newCnt)` Update the `freqFreq`, by decreasing old and increasing new count\\n\\n# Complexity\\n- Time complexity: Each operation takes $$O(1)$$. Only access items by `Dictionary(Hashmap)` key.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$, where n = distinct numbers\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class FrequencyTracker {\\n    Dictionary<int, int> freq;\\n    Dictionary<int, int> freqFreq;\\n\\n    public FrequencyTracker() {\\n        freq = new Dictionary<int, int>();\\n        freqFreq = new Dictionary<int, int>();\\n    }\\n\\n    public void Add(int number) {\\n        int oldCnt = freq.GetValueOrDefault(number, 0);\\n        freq[number] = freq.GetValueOrDefault(number, 0) + 1;\\n        UpdateCntFromTo(oldCnt, freq[number]);\\n    }\\n\\n    public void DeleteOne(int number) {\\n        if (freq.ContainsKey(number)) {\\n            int oldCnt = freq[number];\\n            freq[number]--;\\n            if (freq[number] == 0) freq.Remove(number);\\n\\n            UpdateCntFromTo(oldCnt, freq.GetValueOrDefault(number, 0));\\n        }\\n    }\\n\\n    public bool HasFrequency(int frequency) {\\n        return freqFreq.ContainsKey(frequency);\\n    }\\n\\n    private void UpdateCntFromTo(int oldCnt, int newCnt) {\\n        if (oldCnt > 0) {\\n            freqFreq[oldCnt]--;\\n            if (freqFreq[oldCnt] == 0) freqFreq.Remove(oldCnt);\\n        }\\n\\n        if (newCnt > 0) freqFreq[newCnt] = freqFreq.GetValueOrDefault(newCnt, 0) + 1;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.Add(number);\\n * obj.DeleteOne(number);\\n * bool param_3 = obj.HasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class FrequencyTracker {\\n    Dictionary<int, int> freq;\\n    Dictionary<int, int> freqFreq;\\n\\n    public FrequencyTracker() {\\n        freq = new Dictionary<int, int>();\\n        freqFreq = new Dictionary<int, int>();\\n    }\\n\\n    public void Add(int number) {\\n        int oldCnt = freq.GetValueOrDefault(number, 0);\\n        freq[number] = freq.GetValueOrDefault(number, 0) + 1;\\n        UpdateCntFromTo(oldCnt, freq[number]);\\n    }\\n\\n    public void DeleteOne(int number) {\\n        if (freq.ContainsKey(number)) {\\n            int oldCnt = freq[number];\\n            freq[number]--;\\n            if (freq[number] == 0) freq.Remove(number);\\n\\n            UpdateCntFromTo(oldCnt, freq.GetValueOrDefault(number, 0));\\n        }\\n    }\\n\\n    public bool HasFrequency(int frequency) {\\n        return freqFreq.ContainsKey(frequency);\\n    }\\n\\n    private void UpdateCntFromTo(int oldCnt, int newCnt) {\\n        if (oldCnt > 0) {\\n            freqFreq[oldCnt]--;\\n            if (freqFreq[oldCnt] == 0) freqFreq.Remove(oldCnt);\\n        }\\n\\n        if (newCnt > 0) freqFreq[newCnt] = freqFreq.GetValueOrDefault(newCnt, 0) + 1;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.Add(number);\\n * obj.DeleteOne(number);\\n * bool param_3 = obj.HasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522499,
                "title": "counter-map-and-frequency-map",
                "content": "```\\n\\nvar FrequencyTracker = function() {\\n    // this.map = new Map(); // <num, freq>\\n    this.nums = new Array(100002).fill(0);\\n    this.freqMap = new Map(); //<freq, counter>\\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.add = function(number) {\\n    const oldCount = this.nums[number];\\n    const curCount = oldCount + 1;\\n    this.nums[number]++;\\n    // update freqMap\\n    if(oldCount > 0) {\\n        this.freqMap.set(oldCount, this.freqMap.get(oldCount)  - 1);\\n        if(this.freqMap.get(oldCount) <= 0) {\\n            this.freqMap.delete(oldCount);\\n        }\\n    }\\n    this.freqMap.set(curCount, (this.freqMap.get(curCount) ?? 0 ) + 1);\\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.deleteOne = function(number) {\\n    if(this.nums[number] > 0) {\\n        const oldCount = this.nums[number];\\n        const curCount = oldCount - 1;\\n        this.nums[number]--;\\n        // update freqMap\\n        this.freqMap.set(oldCount, this.freqMap.get(oldCount)  - 1);\\n        if(this.freqMap.get(oldCount) <= 0) {\\n            this.freqMap.delete(oldCount);\\n        }\\n        this.freqMap.set(curCount, (this.freqMap.get(curCount) ?? 0 ) + 1);\\n    }\\n};\\n\\n/** \\n * @param {number} frequency\\n * @return {boolean}\\n */\\nFrequencyTracker.prototype.hasFrequency = function(frequency) {\\n    return this.freqMap.has(frequency);\\n};\\n\\n/** \\n * Your FrequencyTracker object will be instantiated and called as such:\\n * var obj = new FrequencyTracker()\\n * obj.add(number)\\n * obj.deleteOne(number)\\n * var param_3 = obj.hasFrequency(frequency)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar FrequencyTracker = function() {\\n    // this.map = new Map(); // <num, freq>\\n    this.nums = new Array(100002).fill(0);\\n    this.freqMap = new Map(); //<freq, counter>\\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.add = function(number) {\\n    const oldCount = this.nums[number];\\n    const curCount = oldCount + 1;\\n    this.nums[number]++;\\n    // update freqMap\\n    if(oldCount > 0) {\\n        this.freqMap.set(oldCount, this.freqMap.get(oldCount)  - 1);\\n        if(this.freqMap.get(oldCount) <= 0) {\\n            this.freqMap.delete(oldCount);\\n        }\\n    }\\n    this.freqMap.set(curCount, (this.freqMap.get(curCount) ?? 0 ) + 1);\\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.deleteOne = function(number) {\\n    if(this.nums[number] > 0) {\\n        const oldCount = this.nums[number];\\n        const curCount = oldCount - 1;\\n        this.nums[number]--;\\n        // update freqMap\\n        this.freqMap.set(oldCount, this.freqMap.get(oldCount)  - 1);\\n        if(this.freqMap.get(oldCount) <= 0) {\\n            this.freqMap.delete(oldCount);\\n        }\\n        this.freqMap.set(curCount, (this.freqMap.get(curCount) ?? 0 ) + 1);\\n    }\\n};\\n\\n/** \\n * @param {number} frequency\\n * @return {boolean}\\n */\\nFrequencyTracker.prototype.hasFrequency = function(frequency) {\\n    return this.freqMap.has(frequency);\\n};\\n\\n/** \\n * Your FrequencyTracker object will be instantiated and called as such:\\n * var obj = new FrequencyTracker()\\n * obj.add(number)\\n * obj.deleteOne(number)\\n * var param_3 = obj.hasFrequency(frequency)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520029,
                "title": "java-o-1-optimal-solution-2-arrays-easy-explanation-beginner-friendly",
                "content": "# Intuition\\nStoring frequency of number in array as well as storing no. of elements with a frequency in an array.\\n\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    int[] ar;          //for storing frequency of a number\\n    int[] freq;        // for storing no. of elements with a particular frequency\\n\\n    public FrequencyTracker() {\\n        ar=new int[100001];\\n        freq=new int[100001]; \\n    }\\n    \\n    public void add(int number) {\\n        // add 1 to numbers frequency and fetch current frequcny and shift 1 point from lower freq to current frequency\\n        if(ar[number]>0){\\n            freq[ar[number]]--;\\n            ar[number]++;\\n            freq[ar[number]]++;\\n        }else{\\n            ar[number]++;\\n            freq[1]++;\\n        }\\n    }\\n    \\n    public void deleteOne(int number) {\\n        // reduce freq of the number and shift 1 point from freq of numer to 1 less frequency\\n        if(ar[number]==0) return;\\n        if(ar[number]==1){\\n            ar[number]--;\\n            freq[1]--;\\n        }else{\\n            freq[ar[number]]--;\\n            ar[number]--;\\n            freq[ar[number]]++;\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        //true if there are numbers with given frequency\\n        return freq[frequency]>0;\\n        \\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    int[] ar;          //for storing frequency of a number\\n    int[] freq;        // for storing no. of elements with a particular frequency\\n\\n    public FrequencyTracker() {\\n        ar=new int[100001];\\n        freq=new int[100001]; \\n    }\\n    \\n    public void add(int number) {\\n        // add 1 to numbers frequency and fetch current frequcny and shift 1 point from lower freq to current frequency\\n        if(ar[number]>0){\\n            freq[ar[number]]--;\\n            ar[number]++;\\n            freq[ar[number]]++;\\n        }else{\\n            ar[number]++;\\n            freq[1]++;\\n        }\\n    }\\n    \\n    public void deleteOne(int number) {\\n        // reduce freq of the number and shift 1 point from freq of numer to 1 less frequency\\n        if(ar[number]==0) return;\\n        if(ar[number]==1){\\n            ar[number]--;\\n            freq[1]--;\\n        }else{\\n            freq[ar[number]]--;\\n            ar[number]--;\\n            freq[ar[number]]++;\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        //true if there are numbers with given frequency\\n        return freq[frequency]>0;\\n        \\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517382,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass FrequencyTracker {\\n    unordered_map<int,int> mp1;\\n    unordered_map<int,int> mp2;\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(mp1.find(number) != mp1.end())\\n        {\\n            mp2[mp1[number]]--;\\n            if(mp2[mp1[number]] == 0) mp2.erase(mp1[number]);\\n        }\\n        mp1[number]++;\\n        mp2[mp1[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp1.find(number) != mp1.end()) \\n        {\\n            mp2[mp1[number]]--;\\n            if(mp2[mp1[number]] == 0) mp2.erase(mp1[number]);\\n            mp1[number]--;\\n            if(mp1[number] == 0) mp1.erase(number);\\n            else mp2[mp1[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(mp2.find(frequency) != mp2.end()) return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    unordered_map<int,int> mp1;\\n    unordered_map<int,int> mp2;\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(mp1.find(number) != mp1.end())\\n        {\\n            mp2[mp1[number]]--;\\n            if(mp2[mp1[number]] == 0) mp2.erase(mp1[number]);\\n        }\\n        mp1[number]++;\\n        mp2[mp1[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp1.find(number) != mp1.end()) \\n        {\\n            mp2[mp1[number]]--;\\n            if(mp2[mp1[number]] == 0) mp2.erase(mp1[number]);\\n            mp1[number]--;\\n            if(mp1[number] == 0) mp1.erase(number);\\n            else mp2[mp1[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(mp2.find(frequency) != mp2.end()) return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516740,
                "title": "single-map-tle-1115-1118-tc-s-passed-optimised-two-maps",
                "content": "// USING ONE MAP\\n\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<long long int,long long int> mp;\\n    \\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        mp[number]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n       \\n           if(mp[number]==0)mp.erase(number);\\n        else mp[number]--;\\n        \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n       for(auto it :mp){\\n           if(it.second==frequency) return true;\\n       }\\n        return false;\\n    }\\n};\\n\\n// USING TWO MAPS\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> mp,freq; // freq map for storing frequency of frequencies \\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(freq[mp[number]]>0){ // if a number is added to mp that is already there, then the value of freq map to that particular key will change\\n            freq[mp[number]]--;\\n        }\\n        mp[number]++;\\n        freq[mp[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number]>0){\\n            freq[mp[number]]--; //decrement the freq of that frequency\\n            mp[number]--;\\n            freq[mp[number]]++;// add/increment new frequency generated\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq[frequency];\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */",
                "solutionTags": [],
                "code": "// USING ONE MAP\\n\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<long long int,long long int> mp;\\n    \\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        mp[number]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n       \\n           if(mp[number]==0)mp.erase(number);\\n        else mp[number]--;\\n        \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n       for(auto it :mp){\\n           if(it.second==frequency) return true;\\n       }\\n        return false;\\n    }\\n};\\n\\n// USING TWO MAPS\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> mp,freq; // freq map for storing frequency of frequencies \\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(freq[mp[number]]>0){ // if a number is added to mp that is already there, then the value of freq map to that particular key will change\\n            freq[mp[number]]--;\\n        }\\n        mp[number]++;\\n        freq[mp[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number]>0){\\n            freq[mp[number]]--; //decrement the freq of that frequency\\n            mp[number]--;\\n            freq[mp[number]]++;// add/increment new frequency generated\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq[frequency];\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 3515693,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n        HashMap <Integer, Integer> map=new HashMap <Integer, Integer>();\\n        HashMap <Integer, Integer> freq=new HashMap <Integer, Integer>();\\n    \\n    public FrequencyTracker() {\\n        \\n\\n    }\\n    \\n    public void add(int number) {\\n        map.put(number, map.getOrDefault(number,0)+1);\\n        int a=map.get(number);\\n        if (a>0) freq.put(a-1, freq.getOrDefault(a-1,0)-1);\\n        freq.put(a, freq.getOrDefault(a,0)+1);\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if (map.getOrDefault(number,0)<=0) return;\\n        map.put(number, map.getOrDefault(number,0)-1);\\n        int a=map.getOrDefault(number,-1);\\n        if (a>=0) {freq.put(a, freq.getOrDefault(a,0)+1);\\n        freq.put(a+1, freq.getOrDefault(a+1,0)-1);\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        int a= freq.getOrDefault(frequency,0);\\n        return (a>0);\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n        HashMap <Integer, Integer> map=new HashMap <Integer, Integer>();\\n        HashMap <Integer, Integer> freq=new HashMap <Integer, Integer>();\\n    \\n    public FrequencyTracker() {\\n        \\n\\n    }\\n    \\n    public void add(int number) {\\n        map.put(number, map.getOrDefault(number,0)+1);\\n        int a=map.get(number);\\n        if (a>0) freq.put(a-1, freq.getOrDefault(a-1,0)-1);\\n        freq.put(a, freq.getOrDefault(a,0)+1);\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if (map.getOrDefault(number,0)<=0) return;\\n        map.put(number, map.getOrDefault(number,0)-1);\\n        int a=map.getOrDefault(number,-1);\\n        if (a>=0) {freq.put(a, freq.getOrDefault(a,0)+1);\\n        freq.put(a+1, freq.getOrDefault(a+1,0)-1);\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        int a= freq.getOrDefault(frequency,0);\\n        return (a>0);\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514205,
                "title": "c-double-unordered-map",
                "content": "\\n```\\nclass FrequencyTracker \\n{\\n    unordered_map<int, int> nums;\\n    unordered_map<int, int> freq;\\npublic:\\n    FrequencyTracker() \\n    {\\n        \\n    }\\n    \\n    void add(int number) \\n    {\\n        if (nums.find(number) != nums.end())\\n        {\\n            int curFreq = nums[number];\\n            --freq[curFreq];\\n        }\\n\\n        ++nums[number];\\n        ++freq[nums[number]];\\n    }\\n    \\n    void deleteOne(int number) \\n    {\\n        if (nums.find(number) == nums.end())\\n        {\\n            return;\\n        }\\n\\n        int curFreq = nums[number];\\n        --freq[curFreq];\\n\\n        --nums[number];\\n        if (nums[number] > 0)\\n        {\\n            ++freq[nums[number]];\\n        }\\n        else if (nums[number] == 0)\\n        {\\n            nums.erase(number);\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) \\n    {\\n        return freq[frequency] > 0;   \\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker \\n{\\n    unordered_map<int, int> nums;\\n    unordered_map<int, int> freq;\\npublic:\\n    FrequencyTracker() \\n    {\\n        \\n    }\\n    \\n    void add(int number) \\n    {\\n        if (nums.find(number) != nums.end())\\n        {\\n            int curFreq = nums[number];\\n            --freq[curFreq];\\n        }\\n\\n        ++nums[number];\\n        ++freq[nums[number]];\\n    }\\n    \\n    void deleteOne(int number) \\n    {\\n        if (nums.find(number) == nums.end())\\n        {\\n            return;\\n        }\\n\\n        int curFreq = nums[number];\\n        --freq[curFreq];\\n\\n        --nums[number];\\n        if (nums[number] > 0)\\n        {\\n            ++freq[nums[number]];\\n        }\\n        else if (nums[number] == 0)\\n        {\\n            nums.erase(number);\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) \\n    {\\n        return freq[frequency] > 0;   \\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513798,
                "title": "use-2-maps",
                "content": "# Intuition\\none map stores key and number of times keys come.\\nanother map stores frequency of number of keys. \\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int>mp,mps;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int n) {\\n        if(mp.find(n)!=mp.end()){\\n            mps[mp[n]]--;\\n        }\\n        mp[n]++;\\n        \\n        mps[mp[n]]++;\\n    }\\n    \\n    void deleteOne(int n) {\\n        mps[mp[n]]--;\\n        mp[n]--;\\n        \\n        if(mp[n]<=0)mp.erase(n);\\n        else mps[mp[n]]++;\\n    }\\n    \\n    bool hasFrequency(int f) {\\n        if((mps.find(f)!=mps.end())&& mps[f]>0)return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int>mp,mps;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int n) {\\n        if(mp.find(n)!=mp.end()){\\n            mps[mp[n]]--;\\n        }\\n        mp[n]++;\\n        \\n        mps[mp[n]]++;\\n    }\\n    \\n    void deleteOne(int n) {\\n        mps[mp[n]]--;\\n        mp[n]--;\\n        \\n        if(mp[n]<=0)mp.erase(n);\\n        else mps[mp[n]]++;\\n    }\\n    \\n    bool hasFrequency(int f) {\\n        if((mps.find(f)!=mps.end())&& mps[f]>0)return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513679,
                "title": "python-hashmap",
                "content": "```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.dic1 = defaultdict(int)\\n        self.dic2 = defaultdict(set)\\n\\n    def add(self, number: int) -> None:\\n        self.dic1[number] += 1\\n        temp = self.dic1[number]\\n        self.dic2[temp].add(number)\\n        if temp > 1:\\n            self.dic2[temp-1].remove(number)\\n    def deleteOne(self, number: int) -> None:\\n        if number in self.dic1:\\n            self.dic1[number] -= 1\\n            temp = self.dic1[number]\\n            if not self.dic1[number]:\\n                del self.dic1[number]\\n            self.dic2[temp+1].remove(number)\\n            if temp > 0:\\n                self.dic2[temp].add(number)\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        if self.dic2[frequency]:\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.dic1 = defaultdict(int)\\n        self.dic2 = defaultdict(set)\\n\\n    def add(self, number: int) -> None:\\n        self.dic1[number] += 1\\n        temp = self.dic1[number]\\n        self.dic2[temp].add(number)\\n        if temp > 1:\\n            self.dic2[temp-1].remove(number)\\n    def deleteOne(self, number: int) -> None:\\n        if number in self.dic1:\\n            self.dic1[number] -= 1\\n            temp = self.dic1[number]\\n            if not self.dic1[number]:\\n                del self.dic1[number]\\n            self.dic2[temp+1].remove(number)\\n            if temp > 0:\\n                self.dic2[temp].add(number)\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        if self.dic2[frequency]:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512682,
                "title": "swift-solution-not-so-well-optimized-but-worked",
                "content": "# Approach\\n1. We have two arrays, `freqArray` and `freqOfFreq`, both of size 100001. \\n2. `freqArray` is used to keep track of the frequency of each element. \\n3. `freqOfFreq` is used to keep track of the frequency of each frequency, i.e., it is used to keep track of how many elements are there with a frequency of 1, how many elements are there with a frequency of 2, etc. \\n4. When we add a number, we increment the frequency of that number in `freqArray` by 1. Then, we decrement the frequency of the old frequency of that number in `freqOfFreq` by 1, and increment the frequency of the new frequency of that number in `freqOfFreq` by 1. \\n5. When we delete a number, we decrement the frequency of that number in `freqArray` by 1. Then, we decrement the frequency of the old frequency of that number in `freqOfFreq` by 1, and increment the frequency of the new frequency of that number in `freqOfFreq` by 1. \\n6. To check if a frequency exists, we simply check if `freqOfFreq[frequency] > 0`.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    var freqArray: [Int]\\n    var freqOfFreq: [Int]\\n    \\n    init() {\\n        freqArray = [Int](repeating: 0, count: 100001)\\n        freqOfFreq = [Int](repeating: 0, count: 100001)\\n    }\\n    \\n    func add(_ number: Int) {\\n        let oldFreq = freqArray[number]\\n        freqArray[number] += 1\\n        freqOfFreq[oldFreq] -= 1\\n        freqOfFreq[freqArray[number]] += 1\\n    }\\n    \\n    func deleteOne(_ number: Int) {\\n        if freqArray[number] > 0 {\\n            freqOfFreq[freqArray[number]] -= 1\\n            freqArray[number] -= 1\\n            freqOfFreq[freqArray[number]] += 1\\n        }\\n    }\\n    \\n    func hasFrequency(_ frequency: Int) -> Bool {\\n        return freqOfFreq[frequency] > 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    var freqArray: [Int]\\n    var freqOfFreq: [Int]\\n    \\n    init() {\\n        freqArray = [Int](repeating: 0, count: 100001)\\n        freqOfFreq = [Int](repeating: 0, count: 100001)\\n    }\\n    \\n    func add(_ number: Int) {\\n        let oldFreq = freqArray[number]\\n        freqArray[number] += 1\\n        freqOfFreq[oldFreq] -= 1\\n        freqOfFreq[freqArray[number]] += 1\\n    }\\n    \\n    func deleteOne(_ number: Int) {\\n        if freqArray[number] > 0 {\\n            freqOfFreq[freqArray[number]] -= 1\\n            freqArray[number] -= 1\\n            freqOfFreq[freqArray[number]] += 1\\n        }\\n    }\\n    \\n    func hasFrequency(_ frequency: Int) -> Bool {\\n        return freqOfFreq[frequency] > 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511272,
                "title": "java-easy-2-hashmap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n  HashMap<Integer, Integer> table = new HashMap<>();\\n  HashMap<Integer, Integer>  freq = new HashMap<>();\\n  \\n  public void add(int number) {\\n    Integer f = table.get(number);\\n    if(f == null) f = 0;\\n    table.put(number, f + 1);\\n    if(f != 0) freq.put(f, freq.get(f) - 1);\\n    Integer k = freq.get(++f);\\n    if(k == null) k = 0;\\n    freq.put(f, k + 1);     \\n  }\\n    \\n  public void deleteOne(int number) {\\n    Integer f = table.get(number);\\n    if(f == null || f == 0) return;\\n    table.put(number, f - 1);\\n    freq.put(f, freq.get(f) - 1);\\n    if(--f != 0) freq.put(f, freq.get(f) + 1);    \\n  }\\n    \\n  public boolean hasFrequency(int frequency) {\\n    Integer f = freq.get(frequency);\\n    return f != null && f != 0;      \\n  }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n  HashMap<Integer, Integer> table = new HashMap<>();\\n  HashMap<Integer, Integer>  freq = new HashMap<>();\\n  \\n  public void add(int number) {\\n    Integer f = table.get(number);\\n    if(f == null) f = 0;\\n    table.put(number, f + 1);\\n    if(f != 0) freq.put(f, freq.get(f) - 1);\\n    Integer k = freq.get(++f);\\n    if(k == null) k = 0;\\n    freq.put(f, k + 1);     \\n  }\\n    \\n  public void deleteOne(int number) {\\n    Integer f = table.get(number);\\n    if(f == null || f == 0) return;\\n    table.put(number, f - 1);\\n    freq.put(f, freq.get(f) - 1);\\n    if(--f != 0) freq.put(f, freq.get(f) + 1);    \\n  }\\n    \\n  public boolean hasFrequency(int frequency) {\\n    Integer f = freq.get(frequency);\\n    return f != null && f != 0;      \\n  }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511075,
                "title": "c-easy-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMaintain two maps, one for the number and its frequency and second for the frequency and frequency of frequency\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    map<int, int> m;\\n    map<int, int> f;\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(m[number])\\n            f[m[number]]--;\\n        m[number]++;        \\n        f[m[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(m[number])\\n        {\\n            f[m[number]]--;\\n            m[number]--;\\n            f[m[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(f[frequency])\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    map<int, int> m;\\n    map<int, int> f;\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(m[number])\\n            f[m[number]]--;\\n        m[number]++;        \\n        f[m[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(m[number])\\n        {\\n            f[m[number]]--;\\n            m[number]--;\\n            f[m[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(f[frequency])\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510533,
                "title": "swift-forward-reverse-map-o-1",
                "content": "**Two Maps (accepted answer)**\\n```\\nclass FrequencyTracker {\\n    var freq = [Int:Int]()  // maps `number` -> frequency count\\n    var revFreq = [Int:Int]() // maps frequency count -> how many are at that freq\\n\\n    func add(_ number: Int) { // O(1)\\n        let f = freq[number, default:0]\\n        revFreq[f, default: 1] -= 1 \\n        freq[number] = f+1\\n        revFreq[f+1, default:0] += 1\\n    }\\n    \\n    func deleteOne(_ number: Int) { // O(1)\\n        if let f = freq[number], f > 0 { \\n            revFreq[f]! -= 1 \\n            freq[number] = f-1\\n            revFreq[f-1, default:0] += 1\\n        }\\n    }\\n    \\n    func hasFrequency(_ frequency: Int) -> Bool { // O(1)\\n        revFreq[frequency, default:0] > 0\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    var freq = [Int:Int]()  // maps `number` -> frequency count\\n    var revFreq = [Int:Int]() // maps frequency count -> how many are at that freq\\n\\n    func add(_ number: Int) { // O(1)\\n        let f = freq[number, default:0]\\n        revFreq[f, default: 1] -= 1 \\n        freq[number] = f+1\\n        revFreq[f+1, default:0] += 1\\n    }\\n    \\n    func deleteOne(_ number: Int) { // O(1)\\n        if let f = freq[number], f > 0 { \\n            revFreq[f]! -= 1 \\n            freq[number] = f-1\\n            revFreq[f-1, default:0] += 1\\n        }\\n    }\\n    \\n    func hasFrequency(_ frequency: Int) -> Bool { // O(1)\\n        revFreq[frequency, default:0] > 0\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510156,
                "title": "easy-to-understand",
                "content": "# Code\\n```\\nclass FrequencyTracker {\\n\\n    Map<Integer, Integer> numToFreq;\\n    Map<Integer, Set<Integer>> freqToNum;\\n    \\n    public FrequencyTracker() {\\n        numToFreq = new HashMap<Integer, Integer>();\\n        freqToNum = new HashMap<Integer, Set<Integer>>();\\n    }\\n    \\n    public void add(int number) {\\n        int previousFreq = numToFreq.getOrDefault(number, 0);\\n        numToFreq.put(number, previousFreq + 1);\\n        \\n        adjustFreq(previousFreq, previousFreq + 1, number);\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(!numToFreq.containsKey(number) || (numToFreq.containsKey(number) && numToFreq.get(number) <= 0)) return;\\n        \\n        int previousFreq = numToFreq.get(number);\\n        numToFreq.put(number, previousFreq - 1);\\n        \\n        adjustFreq(previousFreq, previousFreq - 1, number);\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return freqToNum.containsKey(frequency) && freqToNum.get(frequency).size() > 0;\\n    }\\n    \\n    private void adjustFreq(int previousFreq, int currFreq, int number) {\\n         if(freqToNum.containsKey(previousFreq)) {\\n            Set<Integer> set = freqToNum.get(previousFreq);\\n            set.remove(number);\\n            freqToNum.put(previousFreq, set);\\n        }\\n        \\n        Set<Integer> set = new HashSet<Integer>();\\n        if(freqToNum.containsKey(currFreq)) {\\n            set = freqToNum.get(currFreq);\\n        }\\n        \\n        set.add(number);\\n        freqToNum.put(currFreq, set);\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\nclass FrequencyTracker {\\n\\n    Map<Integer, Integer> numToFreq;\\n    Map<Integer, Set<Integer>> freqToNum;\\n    \\n    public FrequencyTracker() {\\n        numToFreq = new HashMap<Integer, Integer>();\\n        freqToNum = new HashMap<Integer, Set<Integer>>();\\n    }\\n    \\n    public void add(int number) {\\n        int previousFreq = numToFreq.getOrDefault(number, 0);\\n        numToFreq.put(number, previousFreq + 1);\\n        \\n        adjustFreq(previousFreq, previousFreq + 1, number);\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(!numToFreq.containsKey(number) || (numToFreq.containsKey(number) && numToFreq.get(number) <= 0)) return;\\n        \\n        int previousFreq = numToFreq.get(number);\\n        numToFreq.put(number, previousFreq - 1);\\n        \\n        adjustFreq(previousFreq, previousFreq - 1, number);\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return freqToNum.containsKey(frequency) && freqToNum.get(frequency).size() > 0;\\n    }\\n    \\n    private void adjustFreq(int previousFreq, int currFreq, int number) {\\n         if(freqToNum.containsKey(previousFreq)) {\\n            Set<Integer> set = freqToNum.get(previousFreq);\\n            set.remove(number);\\n            freqToNum.put(previousFreq, set);\\n        }\\n        \\n        Set<Integer> set = new HashSet<Integer>();\\n        if(freqToNum.containsKey(currFreq)) {\\n            set = freqToNum.get(currFreq);\\n        }\\n        \\n        set.add(number);\\n        freqToNum.put(currFreq, set);\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510049,
                "title": "c-two-unordered-map",
                "content": "# Intuition\\nHow would we solve the problem if it required only add and remove? Some hash-map (`unordered_map`) can keep the numbers + their frequency. \\nWe need to return if there exists one number with a given frequency; we don\\'t care what number -- so, we can keep track of the frequency of frequencies. \\n\\n# Approach\\nWe keep track of the frequency for each number (using a hashmap); also store a hashmap of frequencies of frequencies. If a number `n` is added, then `freq[n]` will increase, so we need to update the counts for the frequency of `freq[n]`, i.e., `freq_freq[freq[n]]` will be incremented, and we decrement the frequency of the previous frequency of n.\\nE.g. if we add number 5, which existed 2 times already, then `freq[5] = 3;`, and then `freq_freq[3]` will increase; we need to keep in mind that the number of numbers with frequency 2 will decrease (since frequency of 5 is now 3).\\n\\n# Complexity\\n- Time complexity:\\n`add(number)` --> $$O(1)$$ -- because we use unordered_map for both numbers and frequencies.\\n`deleteOne(number)` --> $$O(1)$$ -- just update values in unordered_map\\n`hasFrequency` --> $$O(1)$$ -- check value in unordered_map\\n\\n- Space complexity:\\n- Time complexity:\\n$$O(n)$$ -- where n is the number of numbers added; in the worst case scenario, e.g. all numbers are different, we store one frequency for each number.\\n\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        int prev_freq = nfreq_[number];\\n        ++nfreq_[number];\\n        if (prev_freq > 0 && freq_freq[prev_freq] > 0) {\\n            --freq_freq[prev_freq];\\n        }\\n        ++freq_freq[nfreq_[number]];\\n    }\\n    \\n    void deleteOne(int number) {\\n        int prev_freq = nfreq_[number];\\n        if (prev_freq > 0) {\\n            --nfreq_[number];\\n            --freq_freq[prev_freq];\\n            if (nfreq_[number] > 0) {\\n                ++freq_freq[nfreq_[number]];\\n            }\\n            \\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq_freq[frequency] > 0;\\n    }\\n\\nprivate:\\n    unordered_map<int, int> nfreq_;\\n    unordered_map<int, int> freq_freq;\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        int prev_freq = nfreq_[number];\\n        ++nfreq_[number];\\n        if (prev_freq > 0 && freq_freq[prev_freq] > 0) {\\n            --freq_freq[prev_freq];\\n        }\\n        ++freq_freq[nfreq_[number]];\\n    }\\n    \\n    void deleteOne(int number) {\\n        int prev_freq = nfreq_[number];\\n        if (prev_freq > 0) {\\n            --nfreq_[number];\\n            --freq_freq[prev_freq];\\n            if (nfreq_[number] > 0) {\\n                ++freq_freq[nfreq_[number]];\\n            }\\n            \\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq_freq[frequency] > 0;\\n    }\\n\\nprivate:\\n    unordered_map<int, int> nfreq_;\\n    unordered_map<int, int> freq_freq;\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509303,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    int[] arr_map;\\n    int[] arr_freq;\\n    public FrequencyTracker() {\\n        arr_map = new int[100001];\\n        arr_freq = new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n        if(arr_map[number] > 0)\\n        {\\n            arr_freq[arr_map[number]]--;\\n        }\\n        arr_map[number]++;\\n        arr_freq[arr_map[number]]++;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(arr_map[number] > 0)\\n        {\\n            arr_freq[arr_map[number]]--;\\n            arr_map[number]--;\\n            arr_freq[arr_map[number]]++;\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(arr_freq[frequency] > 0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    int[] arr_map;\\n    int[] arr_freq;\\n    public FrequencyTracker() {\\n        arr_map = new int[100001];\\n        arr_freq = new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n        if(arr_map[number] > 0)\\n        {\\n            arr_freq[arr_map[number]]--;\\n        }\\n        arr_map[number]++;\\n        arr_freq[arr_map[number]]++;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(arr_map[number] > 0)\\n        {\\n            arr_freq[arr_map[number]]--;\\n            arr_map[number]--;\\n            arr_freq[arr_map[number]]++;\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(arr_freq[frequency] > 0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507650,
                "title": "simple-java-solution-with-explananation",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\nint freqArray[], freqOfFreq[];\\n    public FrequencyTracker() {\\n        freqArray=new int[100001];//stores the frequency of the numbers, where indices are the numbers (1 <= number <= 105)\\n        freqOfFreq=new int[100001]; //stores the frequency of the frequencies, where indices are frequencies (1 <= frequency <= 105)\\n    }\\n    \\n    public void add(int number) {\\n        //adjusting the freqArray\\n        int oldFreq=freqArray[number]++;\\n        //adjusting the freqOfFreq array, with old and new frequency values\\n        freqOfFreq[oldFreq]--;\\n        freqOfFreq[freqArray[number]]++;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(freqArray[number]>0) //if the number exists\\n        {   //adjusting the freqOfFreq array, with old and new frequency values\\n            freqOfFreq[freqArray[number]--]--;\\n            freqOfFreq[freqArray[number]]++;\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return freqOfFreq[frequency] >0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass FrequencyTracker {\\nint freqArray[], freqOfFreq[];\\n    public FrequencyTracker() {\\n        freqArray=new int[100001];//stores the frequency of the numbers, where indices are the numbers (1 <= number <= 105)\\n        freqOfFreq=new int[100001]; //stores the frequency of the frequencies, where indices are frequencies (1 <= frequency <= 105)\\n    }\\n    \\n    public void add(int number) {\\n        //adjusting the freqArray\\n        int oldFreq=freqArray[number]++;\\n        //adjusting the freqOfFreq array, with old and new frequency values\\n        freqOfFreq[oldFreq]--;\\n        freqOfFreq[freqArray[number]]++;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(freqArray[number]>0) //if the number exists\\n        {   //adjusting the freqOfFreq array, with old and new frequency values\\n            freqOfFreq[freqArray[number]--]--;\\n            freqOfFreq[freqArray[number]]++;\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return freqOfFreq[frequency] >0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507523,
                "title": "c-easy-an-clear",
                "content": "```\\nclass FrequencyTracker {\\nprivate:\\n    unordered_map<int,int>map;\\n    unordered_map<int,int>freq;\\npublic:\\n    FrequencyTracker() {\\n    }\\n    void add(int n) {\\n        if(map.find(n) != map.end()){ //already exists\\n            freq[map[n]]--;         \\n        }\\n        map[n]++;\\n       freq[map[n]]++;\\n    }\\n\\n    void deleteOne(int n) {\\n        if(map.find(n) == map.end()){ //not in found\\n            return;\\n        }\\n\\t\\t\\n        freq[map[n]]--;\\n        map[n]--;\\n        \\n        if(map[n]<=0){\\n            map.erase(n);\\n        }else{\\n            freq[map[n]]++;\\n        }\\n    }\\n\\n    bool hasFrequency(int frequency) {\\n        return freq.find(frequency) != freq.end() && freq[frequency]>0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\nprivate:\\n    unordered_map<int,int>map;\\n    unordered_map<int,int>freq;\\npublic:\\n    FrequencyTracker() {\\n    }\\n    void add(int n) {\\n        if(map.find(n) != map.end()){ //already exists\\n            freq[map[n]]--;         \\n        }\\n        map[n]++;\\n       freq[map[n]]++;\\n    }\\n\\n    void deleteOne(int n) {\\n        if(map.find(n) == map.end()){ //not in found\\n            return;\\n        }\\n\\t\\t\\n        freq[map[n]]--;\\n        map[n]--;\\n        \\n        if(map[n]<=0){\\n            map.erase(n);\\n        }else{\\n            freq[map[n]]++;\\n        }\\n    }\\n\\n    bool hasFrequency(int frequency) {\\n        return freq.find(frequency) != freq.end() && freq[frequency]>0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506288,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Hashing\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker \\n{\\npublic:\\n    unordered_map<int,int> count;\\n    unordered_map<int,int> freq;\\n\\n    FrequencyTracker() \\n    {\\n        ;    \\n    }\\n    \\n    void add(int number) \\n    {\\n        freq[count[number]]--;\\n        count[number]++;\\n        freq[count[number]]++;\\n    }\\n    \\n    void deleteOne(int number) \\n    {\\n        if(count[number]>0)\\n        {\\n            freq[count[number]]--;\\n            count[number]--;\\n            freq[count[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) \\n    {\\n        if(freq[frequency]>0)\\n        {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker \\n{\\npublic:\\n    unordered_map<int,int> count;\\n    unordered_map<int,int> freq;\\n\\n    FrequencyTracker() \\n    {\\n        ;    \\n    }\\n    \\n    void add(int number) \\n    {\\n        freq[count[number]]--;\\n        count[number]++;\\n        freq[count[number]]++;\\n    }\\n    \\n    void deleteOne(int number) \\n    {\\n        if(count[number]>0)\\n        {\\n            freq[count[number]]--;\\n            count[number]--;\\n            freq[count[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) \\n    {\\n        if(freq[frequency]>0)\\n        {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505531,
                "title": "c-solution-using-two-maps",
                "content": "# Approach\\nWe use two maps, one to keep track of elements\\' count and one to keep track of frequencies.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$ (Worst case for unordered map)\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    \\n    unordered_map<int, int> mp, freq;\\n    \\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        freq[mp[number]]--;\\n        if(!freq[mp[number]]) freq.erase(mp[number]);\\n        mp[number]++;\\n        freq[mp[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(!mp.count(number)) return;\\n        freq[mp[number]]--;\\n        if(!freq[mp[number]]) freq.erase(mp[number]);\\n        mp[number]--;\\n        freq[mp[number]]++;\\n        if(!mp[number]) mp.erase(number);\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq[frequency];\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    \\n    unordered_map<int, int> mp, freq;\\n    \\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        freq[mp[number]]--;\\n        if(!freq[mp[number]]) freq.erase(mp[number]);\\n        mp[number]++;\\n        freq[mp[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(!mp.count(number)) return;\\n        freq[mp[number]]--;\\n        if(!freq[mp[number]]) freq.erase(mp[number]);\\n        mp[number]--;\\n        freq[mp[number]]++;\\n        if(!mp[number]) mp.erase(number);\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq[frequency];\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504299,
                "title": "c-2-hashmaps",
                "content": "```\\nclass FrequencyTracker {\\n    unordered_map<int, int> num_freq;\\n    unordered_map<int, int> freq_count;\\npublic:\\n    FrequencyTracker() {\\n    }\\n    \\n    void add(int number) {\\n        if(num_freq.count(number) == 0) {\\n            num_freq.insert({number, 1});\\n            ++freq_count[1];\\n            return;\\n        }\\n        \\n        int old_freq = num_freq[number];\\n        int new_freq = ++num_freq[number];\\n        \\n        if(--freq_count[old_freq] == 0) {\\n            freq_count.erase(old_freq);\\n        }\\n        ++freq_count[new_freq];\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(num_freq.count(number) == 0) {\\n            return;\\n        }\\n        \\n        int old_freq = num_freq[number];\\n        int new_freq = --num_freq[number];\\n        \\n        if(new_freq == 0) {\\n            num_freq.erase(number);\\n        }\\n        \\n        if(--freq_count[old_freq] == 0) {\\n            freq_count.erase(old_freq);\\n        }\\n        \\n        if(new_freq > 0)\\n            ++freq_count[new_freq];\\n    }\\n    \\n    bool hasFrequency(int frequency) {        \\n        return freq_count.count(frequency) > 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass FrequencyTracker {\\n    unordered_map<int, int> num_freq;\\n    unordered_map<int, int> freq_count;\\npublic:\\n    FrequencyTracker() {\\n    }\\n    \\n    void add(int number) {\\n        if(num_freq.count(number) == 0) {\\n            num_freq.insert({number, 1});\\n            ++freq_count[1];\\n            return;\\n        }\\n        \\n        int old_freq = num_freq[number];\\n        int new_freq = ++num_freq[number];\\n        \\n        if(--freq_count[old_freq] == 0) {\\n            freq_count.erase(old_freq);\\n        }\\n        ++freq_count[new_freq];\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(num_freq.count(number) == 0) {\\n            return;\\n        }\\n        \\n        int old_freq = num_freq[number];\\n        int new_freq = --num_freq[number];\\n        \\n        if(new_freq == 0) {\\n            num_freq.erase(number);\\n        }\\n        \\n        if(--freq_count[old_freq] == 0) {\\n            freq_count.erase(old_freq);\\n        }\\n        \\n        if(new_freq > 0)\\n            ++freq_count[new_freq];\\n    }\\n    \\n    bool hasFrequency(int frequency) {        \\n        return freq_count.count(frequency) > 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504081,
                "title": "commented-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\nunordered_map<int,int> mp , freq; \\n    FrequencyTracker() \\n    {\\n        \\n    }\\n    \\n    void add(int number) \\n    {   \\n        int curr = mp[number];// find frequency of element before insertion if not present it would be zero \\n         \\n        freq[curr]--; // reduce that frequency if freq<int,int> map bcs now you are going to update the frequency of that element \\n        if(freq[curr]<=0) // ex [2,2,3] if you insert 2 then updated freq of 2 will be 3 nd there woulbe no element with freq 2 so \\n        freq.erase(curr); // if freq is <=0 remove from the map \\n         \\n        mp[number]++;\\n        freq[curr+1]++; // updte the increased frequency in freq map\\n       \\n    }\\n    \\n    void deleteOne(int number) \\n    {\\n          if(mp.find(number)==mp.end()) // no is not present \\n          return ;\\n          int currf = mp[number]; // [2,2,3,2] if we delete 2 from list there would be no elemet with freq 3  and update frequency would be 3 \\n         \\n          freq[currf]--; // so reduce the frequecny \\n          \\n          if(freq[currf]<=0)\\n          freq.erase(currf);\\n          \\n          if(currf-1>0)\\n          freq[currf-1]++; // [2,2,3,2] we deleted 2 no updated frequency is 3-1 {prevfrequency -1}\\n          mp[number]--;\\n          if(mp[number]<=0) // delete the number from map as well\\n          mp.erase(number);\\n           \\n\\n           \\n\\n    }\\n    \\n    bool hasFrequency(int frequency) \\n    {\\n        return freq.find(frequency)!=freq.end();\\n    }\\n};\\n\\n \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\nunordered_map<int,int> mp , freq; \\n    FrequencyTracker() \\n    {\\n        \\n    }\\n    \\n    void add(int number) \\n    {   \\n        int curr = mp[number];// find frequency of element before insertion if not present it would be zero \\n         \\n        freq[curr]--; // reduce that frequency if freq<int,int> map bcs now you are going to update the frequency of that element \\n        if(freq[curr]<=0) // ex [2,2,3] if you insert 2 then updated freq of 2 will be 3 nd there woulbe no element with freq 2 so \\n        freq.erase(curr); // if freq is <=0 remove from the map \\n         \\n        mp[number]++;\\n        freq[curr+1]++; // updte the increased frequency in freq map\\n       \\n    }\\n    \\n    void deleteOne(int number) \\n    {\\n          if(mp.find(number)==mp.end()) // no is not present \\n          return ;\\n          int currf = mp[number]; // [2,2,3,2] if we delete 2 from list there would be no elemet with freq 3  and update frequency would be 3 \\n         \\n          freq[currf]--; // so reduce the frequecny \\n          \\n          if(freq[currf]<=0)\\n          freq.erase(currf);\\n          \\n          if(currf-1>0)\\n          freq[currf-1]++; // [2,2,3,2] we deleted 2 no updated frequency is 3-1 {prevfrequency -1}\\n          mp[number]--;\\n          if(mp[number]<=0) // delete the number from map as well\\n          mp.erase(number);\\n           \\n\\n           \\n\\n    }\\n    \\n    bool hasFrequency(int frequency) \\n    {\\n        return freq.find(frequency)!=freq.end();\\n    }\\n};\\n\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504006,
                "title": "c-simplest-solution-on-leetcode-with-step-by-step-explanation",
                "content": "# Please dont forget to UPVOTE\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,set<int>> reversedMap;\\n    unordered_map<int,int> normalMap;\\n\\n    FrequencyTracker() {\\n        normalMap.clear();\\n        reversedMap.clear();\\n    }\\n    \\n    void add(int number) {\\n        //Step1: Find out the existing frequency\\n        int existingFreq=normalMap[number];\\n\\n        //Step2: Delete number from that existing frequency from reversedMap\\n        if(existingFreq != 0)\\n        {\\n            reversedMap[existingFreq].erase(number);\\n        }\\n\\n        //Step3: Increase the existing frequency\\n        normalMap[number]++;\\n\\n        //Step4: Find out new frequency\\n        int newFreq=normalMap[number];\\n\\n        //Step5: Insert the number to newFreq in reversedMap\\n        reversedMap[newFreq].insert(number);                        //set operation\\n    }\\n    \\n    void deleteOne(int number) {\\n        //Step1: Find out the existing frequency\\n        int existingFreq=normalMap[number];\\n        if(existingFreq==0) return;\\n\\n        //Step2: Delete number from that existing frequency from reversedMap\\n        reversedMap[existingFreq].erase(number);\\n\\n        //Step3: Decrease the existing frequency\\n        normalMap[number]--;\\n\\n        //Step4: Find out new frequency\\n        int newFreq=normalMap[number];\\n\\n        //Step5: Insert the number to newFreq in reversedMap\\n        reversedMap[newFreq].insert(number);                         //set operation\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(reversedMap[frequency].size() > 0) return true;\\n        else return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```\\n\\n# Please dont forget to UPVOTE and feel free to ask any question in comments",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,set<int>> reversedMap;\\n    unordered_map<int,int> normalMap;\\n\\n    FrequencyTracker() {\\n        normalMap.clear();\\n        reversedMap.clear();\\n    }\\n    \\n    void add(int number) {\\n        //Step1: Find out the existing frequency\\n        int existingFreq=normalMap[number];\\n\\n        //Step2: Delete number from that existing frequency from reversedMap\\n        if(existingFreq != 0)\\n        {\\n            reversedMap[existingFreq].erase(number);\\n        }\\n\\n        //Step3: Increase the existing frequency\\n        normalMap[number]++;\\n\\n        //Step4: Find out new frequency\\n        int newFreq=normalMap[number];\\n\\n        //Step5: Insert the number to newFreq in reversedMap\\n        reversedMap[newFreq].insert(number);                        //set operation\\n    }\\n    \\n    void deleteOne(int number) {\\n        //Step1: Find out the existing frequency\\n        int existingFreq=normalMap[number];\\n        if(existingFreq==0) return;\\n\\n        //Step2: Delete number from that existing frequency from reversedMap\\n        reversedMap[existingFreq].erase(number);\\n\\n        //Step3: Decrease the existing frequency\\n        normalMap[number]--;\\n\\n        //Step4: Find out new frequency\\n        int newFreq=normalMap[number];\\n\\n        //Step5: Insert the number to newFreq in reversedMap\\n        reversedMap[newFreq].insert(number);                         //set operation\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(reversedMap[frequency].size() > 0) return true;\\n        else return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503638,
                "title": "simple-c-solution-using-two-hash-maps",
                "content": "\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    map<int,int> m1,m2;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        \\n        m2[m1[number]]--;\\n        m1[number]++;\\n        m2[m1[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(m1[number]){\\n        m2[m1[number]]--;\\n        m1[number]--;\\n        m2[m1[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(m2[frequency])\\n        return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    map<int,int> m1,m2;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        \\n        m2[m1[number]]--;\\n        m1[number]++;\\n        m2[m1[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(m1[number]){\\n        m2[m1[number]]--;\\n        m1[number]--;\\n        m2[m1[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(m2[frequency])\\n        return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502762,
                "title": "python3-dict-set",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.numbers_count = defaultdict(int)\\n        self.frequency_map = defaultdict(set)\\n\\n    def add(self, number: int) -> None:\\n        if number in self.numbers_count:\\n            existing_frequency = self.numbers_count[number]\\n            self.frequency_map[existing_frequency].remove(number)\\n            if not self.frequency_map[existing_frequency]:\\n                del self.frequency_map[existing_frequency]\\n            self.numbers_count[number] = existing_frequency + 1\\n            self.frequency_map[existing_frequency+1].add(number)\\n        else:\\n            self.numbers_count[number] = 1\\n            self.frequency_map[1].add(number)\\n\\n\\n    def deleteOne(self, number: int) -> None:\\n        if number in self.numbers_count:\\n            if self.numbers_count[number] > 1:\\n                existing_frequency = self.numbers_count[number]\\n                self.numbers_count[number] = existing_frequency - 1\\n                self.frequency_map[existing_frequency].remove(number)\\n                if not self.frequency_map[existing_frequency]:\\n                    del self.frequency_map[existing_frequency]\\n                self.frequency_map[existing_frequency-1].add(number)\\n            elif self.numbers_count[number] == 1:\\n                del self.numbers_count[number]\\n                self.frequency_map[1].remove(number)\\n                if not self.frequency_map[1]:\\n                    del self.frequency_map[1]\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return frequency in self.frequency_map\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.numbers_count = defaultdict(int)\\n        self.frequency_map = defaultdict(set)\\n\\n    def add(self, number: int) -> None:\\n        if number in self.numbers_count:\\n            existing_frequency = self.numbers_count[number]\\n            self.frequency_map[existing_frequency].remove(number)\\n            if not self.frequency_map[existing_frequency]:\\n                del self.frequency_map[existing_frequency]\\n            self.numbers_count[number] = existing_frequency + 1\\n            self.frequency_map[existing_frequency+1].add(number)\\n        else:\\n            self.numbers_count[number] = 1\\n            self.frequency_map[1].add(number)\\n\\n\\n    def deleteOne(self, number: int) -> None:\\n        if number in self.numbers_count:\\n            if self.numbers_count[number] > 1:\\n                existing_frequency = self.numbers_count[number]\\n                self.numbers_count[number] = existing_frequency - 1\\n                self.frequency_map[existing_frequency].remove(number)\\n                if not self.frequency_map[existing_frequency]:\\n                    del self.frequency_map[existing_frequency]\\n                self.frequency_map[existing_frequency-1].add(number)\\n            elif self.numbers_count[number] == 1:\\n                del self.numbers_count[number]\\n                self.frequency_map[1].remove(number)\\n                if not self.frequency_map[1]:\\n                    del self.frequency_map[1]\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return frequency in self.frequency_map\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502362,
                "title": "java-solution-using-arrays-only",
                "content": "\\n```\\nclass FrequencyTracker {\\n  \\n    int[] fre;\\n    int[] arr;\\n\\n    public FrequencyTracker() {\\n        arr=new int[100001];\\n        fre=new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n        fre[arr[number]]--;\\n        arr[number]++;\\n        fre[arr[number]]++;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(arr[number]>0){\\n        fre[arr[number]]--;\\n        arr[number]--;\\n        fre[arr[number]]++;\\n        }\\n       \\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n            if(fre[frequency]>0){\\n                return true;\\n            }\\n        \\n        return false;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n  \\n    int[] fre;\\n    int[] arr;\\n\\n    public FrequencyTracker() {\\n        arr=new int[100001];\\n        fre=new int[100001];\\n    }\\n    \\n    public void add(int number) {\\n        fre[arr[number]]--;\\n        arr[number]++;\\n        fre[arr[number]]++;\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(arr[number]>0){\\n        fre[arr[number]]--;\\n        arr[number]--;\\n        fre[arr[number]]++;\\n        }\\n       \\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n            if(fre[frequency]>0){\\n                return true;\\n            }\\n        \\n        return false;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502344,
                "title": "double-solution-array-mapping-dictionary-approach",
                "content": "# Approach\\n- *map array*: The indices are the numbers while the values are the relative frequencies. The frequency values act as mapping values to the indices of the freq array\\n-  *freq array*: the indices are the values of the frequencies, while the values are zero or one, to indicate that there is a number with that frequency\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(10^5)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n## Solution 1\\n```\\npublic class FrequencyTracker {\\n\\n    private int[] map = new int[100_001];\\n    private int[] freq = new int[100_001];\\n\\n    public void Add(int number) {\\n        freq[map[number]++]--;\\n        freq[map[number]]++;\\n    }\\n\\n    public void DeleteOne(int number) {\\n        if (map[number] > 0) {\\n            freq[map[number]--]--;\\n            freq[map[number]]++;\\n        }\\n    }\\n\\n    public bool HasFrequency(int frequency) => freq[frequency] > 0;\\n}\\n```\\n## Solution 2\\n```\\nusing System.Collections.Generic;\\n\\npublic class FrequencyTracker {\\n\\n    private Dictionary<int, int> frequencies = new();\\n    \\n    public void Add(int number) \\n    {\\n        frequencies.TryGetValue(number, out int frequency);\\n        frequencies[number] = frequency + 1;\\n    }\\n    \\n    public void DeleteOne(int number) \\n    {\\n        frequencies.TryGetValue(number, out int frequency);\\n        frequencies[number] = Math.Max(0, frequency - 1);\\n    }\\n    \\n    public bool HasFrequency(int frequency) => frequencies.ContainsValue(frequency);\\n}\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class FrequencyTracker {\\n\\n    private int[] map = new int[100_001];\\n    private int[] freq = new int[100_001];\\n\\n    public void Add(int number) {\\n        freq[map[number]++]--;\\n        freq[map[number]]++;\\n    }\\n\\n    public void DeleteOne(int number) {\\n        if (map[number] > 0) {\\n            freq[map[number]--]--;\\n            freq[map[number]]++;\\n        }\\n    }\\n\\n    public bool HasFrequency(int frequency) => freq[frequency] > 0;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501866,
                "title": "o-1-solution-tle-ac-map-design-pls-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhow to increase and decrease count of any no and how the count of that count will be affected that we need to figure out other wise it will give tle if we use only one map\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe constructor initializes the two unordered maps. The add function is used to add a new number to the tracker. If the number already exists in the tracker, the count of its frequency is updated in the mp map, and the count of numbers whose frequency is the same is updated in the mps map. If the number is new, it is added to the mp map with a frequency count of 1, and the count of numbers whose frequency is 1 is updated in the mps map.\\n\\nThe deleteOne function is used to remove a number from the tracker. If the number exists in the tracker, its frequency count is updated in the mp map and the count of numbers whose frequency is the same is updated in the mps map. If the frequency count of the number becomes zero, it is removed from the mp map.\\n\\nFinally, the hasFrequency function returns true if there is at least one number in the tracker with the given frequency count, and false otherwise.\\n\\nThis class can be used to efficiently keep track of the frequency count of a set of integers and quickly answer queries about the frequency of specific numbers.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(1) \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n) \\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int, int> mp;   \\n    unordered_map<int, int> mps; \\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(mp.find(number) != mp.end()){\\n            mps[mp[number]]--;\\n        }\\n        mp[number]++;\\n        mps[mp[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp.find(number) != mp.end() && mp[number] > 0){\\n            mps[mp[number]]--;\\n            mp[number]--;\\n            mps[mp[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return (mps[frequency] > 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int, int> mp;   \\n    unordered_map<int, int> mps; \\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if(mp.find(number) != mp.end()){\\n            mps[mp[number]]--;\\n        }\\n        mp[number]++;\\n        mps[mp[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp.find(number) != mp.end() && mp[number] > 0){\\n            mps[mp[number]]--;\\n            mp[number]--;\\n            mps[mp[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return (mps[frequency] > 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501434,
                "title": "c-map",
                "content": "# Code\\n```\\n//---------------------------------------\\n// Solution 1\\n//---------------------------------------\\nclass FrequencyTracker {\\n    unordered_map<int, int> numToFreq;\\n    unordered_map<int, unordered_set<int>> freqToNumList;\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        freqToNumList[numToFreq[number]].erase(number);\\n        numToFreq[number]++;\\n        freqToNumList[numToFreq[number]].insert(number);\\n    }\\n    \\n    void deleteOne(int number) {\\n        freqToNumList[numToFreq[number]].erase(number);\\n        if(numToFreq[number] > 0) {\\n            numToFreq[number]--;\\n            freqToNumList[numToFreq[number]].insert(number);\\n        } \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freqToNumList[frequency].size() > 0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n\\n\\n//---------------------------------------\\n// Solution 2\\n//---------------------------------------\\nclass FrequencyTracker {\\n    unordered_map<int, int> count;\\n    unordered_map<int, int> freq;\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        freq[count[number]]--;\\n        count[number]++;\\n        freq[count[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(count[number] > 0) {\\n            freq[count[number]]--;\\n            count[number]--;\\n            freq[count[number]]++;\\n        } \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq[frequency];\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Design"
                ],
                "code": "```\\n//---------------------------------------\\n// Solution 1\\n//---------------------------------------\\nclass FrequencyTracker {\\n    unordered_map<int, int> numToFreq;\\n    unordered_map<int, unordered_set<int>> freqToNumList;\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        freqToNumList[numToFreq[number]].erase(number);\\n        numToFreq[number]++;\\n        freqToNumList[numToFreq[number]].insert(number);\\n    }\\n    \\n    void deleteOne(int number) {\\n        freqToNumList[numToFreq[number]].erase(number);\\n        if(numToFreq[number] > 0) {\\n            numToFreq[number]--;\\n            freqToNumList[numToFreq[number]].insert(number);\\n        } \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freqToNumList[frequency].size() > 0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n\\n\\n//---------------------------------------\\n// Solution 2\\n//---------------------------------------\\nclass FrequencyTracker {\\n    unordered_map<int, int> count;\\n    unordered_map<int, int> freq;\\npublic:\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        freq[count[number]]--;\\n        count[number]++;\\n        freq[count[number]]++;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(count[number] > 0) {\\n            freq[count[number]]--;\\n            count[number]--;\\n            freq[count[number]]++;\\n        } \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq[frequency];\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501304,
                "title": "typescript-solution",
                "content": "# Code\\n```\\nclass FrequencyTracker {\\n  numberFrequency: Map<number, number>;\\n  frequencyCount: Map<number, number>;\\n\\n  constructor() {\\n    this.numberFrequency = new Map();\\n    this.frequencyCount = new Map();\\n  }\\n\\n  getNumberFrequency(number: number): number {\\n    return this.numberFrequency.get(number) || 0;\\n  }\\n\\n  getFrequencyCount(frequency: number): number {\\n    return this.frequencyCount.get(frequency) || 0;\\n  }\\n\\n  add(number: number): void {\\n    const prevFreq = this.getNumberFrequency(number);\\n    const newFreq = prevFreq + 1;\\n\\n    this.numberFrequency.set(number, newFreq);\\n    this.frequencyCount.set(prevFreq, this.getFrequencyCount(prevFreq) - 1);\\n    this.frequencyCount.set(newFreq, this.getFrequencyCount(newFreq) + 1);\\n  }\\n\\n  deleteOne(number: number): void {\\n    const prevFreq = this.getNumberFrequency(number);\\n    if (!prevFreq) return;\\n\\n    const newFreq = prevFreq - 1;\\n    this.numberFrequency.set(number, newFreq);\\n    this.frequencyCount.set(prevFreq, this.getFrequencyCount(prevFreq) - 1);\\n    this.frequencyCount.set(newFreq, this.getFrequencyCount(newFreq) + 1);\\n  }\\n\\n  hasFrequency(frequency: number): boolean {\\n    return !!this.getFrequencyCount(frequency);\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass FrequencyTracker {\\n  numberFrequency: Map<number, number>;\\n  frequencyCount: Map<number, number>;\\n\\n  constructor() {\\n    this.numberFrequency = new Map();\\n    this.frequencyCount = new Map();\\n  }\\n\\n  getNumberFrequency(number: number): number {\\n    return this.numberFrequency.get(number) || 0;\\n  }\\n\\n  getFrequencyCount(frequency: number): number {\\n    return this.frequencyCount.get(frequency) || 0;\\n  }\\n\\n  add(number: number): void {\\n    const prevFreq = this.getNumberFrequency(number);\\n    const newFreq = prevFreq + 1;\\n\\n    this.numberFrequency.set(number, newFreq);\\n    this.frequencyCount.set(prevFreq, this.getFrequencyCount(prevFreq) - 1);\\n    this.frequencyCount.set(newFreq, this.getFrequencyCount(newFreq) + 1);\\n  }\\n\\n  deleteOne(number: number): void {\\n    const prevFreq = this.getNumberFrequency(number);\\n    if (!prevFreq) return;\\n\\n    const newFreq = prevFreq - 1;\\n    this.numberFrequency.set(number, newFreq);\\n    this.frequencyCount.set(prevFreq, this.getFrequencyCount(prevFreq) - 1);\\n    this.frequencyCount.set(newFreq, this.getFrequencyCount(newFreq) + 1);\\n  }\\n\\n  hasFrequency(frequency: number): boolean {\\n    return !!this.getFrequencyCount(frequency);\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500855,
                "title": "ruby-solution-100-100",
                "content": "# Intuition\\nKeep track of the count of each number in one hash and the count of each array in another.  Using two hashes keeps everything $$O(1)$$.\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(n)$$, where *n* is the number of distinct values.\\n\\n# Code\\n```\\nclass FrequencyTracker\\n    def initialize()\\n        @eles = Hash.new(0)\\n        @freq = Hash.new(0)\\n    end\\n\\n\\n=begin\\n    :type number: Integer\\n    :rtype: Void\\n=end\\n    def add(number)\\n        @freq[@eles[number]] -= 1 if @freq[@eles[number]] > 0\\n        @eles[number] += 1\\n        @freq[@eles[number]] += 1\\n    end\\n\\n\\n=begin\\n    :type number: Integer\\n    :rtype: Void\\n=end\\n    def delete_one(number)\\n        @freq[@eles[number]] -= 1 if @eles[number] > 0\\n        @eles[number] -= 1 if @eles[number] > 0\\n        @freq[@eles[number]] += 1 if @eles[number] > 0\\n    end\\n\\n\\n=begin\\n    :type frequency: Integer\\n    :rtype: Boolean\\n=end\\n    def has_frequency(frequency)\\n        @freq[frequency] > 0\\n    end\\n\\n\\nend\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker.new()\\n# obj.add(number)\\n# obj.delete_one(number)\\n# param_3 = obj.has_frequency(frequency)\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\nclass FrequencyTracker\\n    def initialize()\\n        @eles = Hash.new(0)\\n        @freq = Hash.new(0)\\n    end\\n\\n\\n=begin\\n    :type number: Integer\\n    :rtype: Void\\n=end\\n    def add(number)\\n        @freq[@eles[number]] -= 1 if @freq[@eles[number]] > 0\\n        @eles[number] += 1\\n        @freq[@eles[number]] += 1\\n    end\\n\\n\\n=begin\\n    :type number: Integer\\n    :rtype: Void\\n=end\\n    def delete_one(number)\\n        @freq[@eles[number]] -= 1 if @eles[number] > 0\\n        @eles[number] -= 1 if @eles[number] > 0\\n        @freq[@eles[number]] += 1 if @eles[number] > 0\\n    end\\n\\n\\n=begin\\n    :type frequency: Integer\\n    :rtype: Boolean\\n=end\\n    def has_frequency(frequency)\\n        @freq[frequency] > 0\\n    end\\n\\n\\nend\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker.new()\\n# obj.add(number)\\n# obj.delete_one(number)\\n# param_3 = obj.has_frequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500448,
                "title": "beats-100-using-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n  constructor() {\\n    this.numbers = new Map();\\n    this.frequencies = new Map();\\n  }\\n\\n  add(number) {\\n    const count = this.numbers.get(number) || 0;\\n    this.numbers.set(number, count + 1);\\n\\n    const freq = this.frequencies.get(count) || new Set();\\n    freq.delete(number); // remove from the previous frequency set\\n    this.frequencies.set(count, freq);\\n\\n    const newFreq = this.frequencies.get(count + 1) || new Set();\\n    newFreq.add(number);\\n    this.frequencies.set(count + 1, newFreq);\\n  }\\n\\n  deleteOne(number) {\\n    const count = this.numbers.get(number) || 0;\\n    if (count > 0) {\\n      this.numbers.set(number, count - 1);\\n\\n      const freq = this.frequencies.get(count) || new Set();\\n      freq.delete(number); // remove from the current frequency set\\n      this.frequencies.set(count, freq);\\n\\n      const newFreq = this.frequencies.get(count - 1) || new Set();\\n      newFreq.add(number);\\n      this.frequencies.set(count - 1, newFreq);\\n    }\\n  }\\n\\n  hasFrequency(frequency) {\\n    return this.frequencies.has(frequency) && this.frequencies.get(frequency).size > 0;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass FrequencyTracker {\\n  constructor() {\\n    this.numbers = new Map();\\n    this.frequencies = new Map();\\n  }\\n\\n  add(number) {\\n    const count = this.numbers.get(number) || 0;\\n    this.numbers.set(number, count + 1);\\n\\n    const freq = this.frequencies.get(count) || new Set();\\n    freq.delete(number); // remove from the previous frequency set\\n    this.frequencies.set(count, freq);\\n\\n    const newFreq = this.frequencies.get(count + 1) || new Set();\\n    newFreq.add(number);\\n    this.frequencies.set(count + 1, newFreq);\\n  }\\n\\n  deleteOne(number) {\\n    const count = this.numbers.get(number) || 0;\\n    if (count > 0) {\\n      this.numbers.set(number, count - 1);\\n\\n      const freq = this.frequencies.get(count) || new Set();\\n      freq.delete(number); // remove from the current frequency set\\n      this.frequencies.set(count, freq);\\n\\n      const newFreq = this.frequencies.get(count - 1) || new Set();\\n      newFreq.add(number);\\n      this.frequencies.set(count - 1, newFreq);\\n    }\\n  }\\n\\n  hasFrequency(frequency) {\\n    return this.frequencies.has(frequency) && this.frequencies.get(frequency).size > 0;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499771,
                "title": "python-solution-normal-dictionary",
                "content": "# Complexity\\n- Time complexity:O(1) \\n                 all functions take O(1) time complexity on average\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.count = dict() # to store the frequency of number\\n        self.frequency = dict()#to store the count of how many keys in the above dict have the same value\\n                               #and store that value\\n\\n    def add(self, number: int) -> None:\\n        occurs = self.count.get(number, 0)#check if number is already present in count\\n        self.count[number] = occurs + 1\\n        if occurs > 0:\\n            self.frequency[occurs] -= 1\\n            self.frequency[self.count[number]] = 1 + self.frequency.get(self.count[number], 0)\\n        else:\\n            self.frequency[self.count[number]] = 1 + self.frequency.get(self.count[number], 0)\\n\\n    def deleteOne(self, number: int) -> None:\\n        occurs = self.count.get(number, 0)#check if number is already present\\n        if occurs > 0:\\n            self.frequency[occurs] -= 1 \\n            self.count[number] -= 1\\n            self.frequency[self.count[number]] =  1 + self.frequency.get(self.count[number], 0)\\n\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        freq = self.frequency.get(frequency, 0) #get frequency from \\n        return freq>0\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.count = dict() # to store the frequency of number\\n        self.frequency = dict()#to store the count of how many keys in the above dict have the same value\\n                               #and store that value\\n\\n    def add(self, number: int) -> None:\\n        occurs = self.count.get(number, 0)#check if number is already present in count\\n        self.count[number] = occurs + 1\\n        if occurs > 0:\\n            self.frequency[occurs] -= 1\\n            self.frequency[self.count[number]] = 1 + self.frequency.get(self.count[number], 0)\\n        else:\\n            self.frequency[self.count[number]] = 1 + self.frequency.get(self.count[number], 0)\\n\\n    def deleteOne(self, number: int) -> None:\\n        occurs = self.count.get(number, 0)#check if number is already present\\n        if occurs > 0:\\n            self.frequency[occurs] -= 1 \\n            self.count[number] -= 1\\n            self.frequency[self.count[number]] =  1 + self.frequency.get(self.count[number], 0)\\n\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        freq = self.frequency.get(frequency, 0) #get frequency from \\n        return freq>0\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499757,
                "title": "a-python-solution-using-two-maps-beats-100",
                "content": "# Code\\n```\\nclass FrequencyTracker:\\n    def __init__(self):\\n        self.numFreq = defaultdict(int)\\n        self.freq = defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        self.updateFreq(number, 1)\\n        \\n    def deleteOne(self, number: int) -> None:\\n        if self.numFreq[number] <= 0:\\n            return\\n\\n        self.updateFreq(number, -1)\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] > 0\\n\\n    def updateFreq(self, number, amount):\\n        self.freq[self.numFreq[number]] -= 1\\n        self.numFreq[number] += amount\\n        self.freq[self.numFreq[number]] += 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker:\\n    def __init__(self):\\n        self.numFreq = defaultdict(int)\\n        self.freq = defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        self.updateFreq(number, 1)\\n        \\n    def deleteOne(self, number: int) -> None:\\n        if self.numFreq[number] <= 0:\\n            return\\n\\n        self.updateFreq(number, -1)\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] > 0\\n\\n    def updateFreq(self, number, amount):\\n        self.freq[self.numFreq[number]] -= 1\\n        self.numFreq[number] += amount\\n        self.freq[self.numFreq[number]] += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499713,
                "title": "easy-with-two-dictionry-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n`Design a data structure that keeps track of the values in it and answers some queries regarding their frequencies. Implement the FrequencyTracker class.`\\n\\nThe very first thing that comes to mind is to create a simple dictionary: `key - number: value - number frequency`.\\n\\nHowever, because of the method `hasFrequency` we will get **TLE**. I think you\\'ve probably already tried it)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn order to perform the method effectively `hasFrequency` we need another dictionary: `key - frequency: value - the number of numbers with this frequency`. It remains only to synchronize the work of these dictionaries together.\\n\\n- we add a new number:\\n`numbers = {newNumber: 1}` and `frequency = {1: count + 1}`\\n- we are changing an existing number:\\nIf we increase the number: \\n`numbers = {number : i + 1}`\\n`frequency = {i: count - 1, i + 1: count + 1}`\\nIf we reduce the number\\n`numbers = {number : i - 1}`\\n`frequency = {i: count - 1, i - 1: count + 1}`\\n\\nLet\\'s create two methods for working with the dictionary `frequency`:\\n```\\ndef addFrequency(self, frequency: int) -> None:\\n    if frequency in self.frequency:\\n        self.frequency[frequency] += 1\\n    else:\\n        self.frequency[frequency] = 1\\n    \\ndef deleteFrequency(self, frequency: int) -> None:\\n    if frequency in self.frequency:\\n        self.frequency[frequency] -= 1\\n```\\nAnd now when we change the frequency of the number, we do it as follows:\\n`self.deleteFrequency(self.numbers[number])` - reducing the number of numbers with the previous frequency\\n`self.numbers[number] +-= 1` increase or decrease\\n`self.addFrequency(self.numbers[number])` - increasing the number of numbers with a new frequency.\\n\\n\\n\\n# Code\\n```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.numbers = dict()\\n        self.frequency = dict()\\n\\n    def add(self, number: int) -> None:\\n        if number in self.numbers:\\n            self.deleteFrequency(self.numbers[number])\\n            self.numbers[number] += 1\\n        else:\\n            self.numbers[number] = 1\\n        self.addFrequency(self.numbers[number])\\n\\n    def deleteOne(self, number: int) -> None:\\n        if number in self.numbers and self.numbers[number] > 0:\\n            self.deleteFrequency(self.numbers[number])\\n            self.numbers[number] -= 1\\n            self.addFrequency(self.numbers[number])\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return frequency in self.frequency and self.frequency[frequency] > 0\\n    \\n    def addFrequency(self, frequency: int) -> None:\\n        if frequency in self.frequency:\\n            self.frequency[frequency] += 1\\n        else:\\n            self.frequency[frequency] = 1\\n    \\n    def deleteFrequency(self, frequency: int) -> None:\\n        if frequency in self.frequency:\\n            self.frequency[frequency] -= 1\\n        \\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef addFrequency(self, frequency: int) -> None:\\n    if frequency in self.frequency:\\n        self.frequency[frequency] += 1\\n    else:\\n        self.frequency[frequency] = 1\\n    \\ndef deleteFrequency(self, frequency: int) -> None:\\n    if frequency in self.frequency:\\n        self.frequency[frequency] -= 1\\n```\n```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.numbers = dict()\\n        self.frequency = dict()\\n\\n    def add(self, number: int) -> None:\\n        if number in self.numbers:\\n            self.deleteFrequency(self.numbers[number])\\n            self.numbers[number] += 1\\n        else:\\n            self.numbers[number] = 1\\n        self.addFrequency(self.numbers[number])\\n\\n    def deleteOne(self, number: int) -> None:\\n        if number in self.numbers and self.numbers[number] > 0:\\n            self.deleteFrequency(self.numbers[number])\\n            self.numbers[number] -= 1\\n            self.addFrequency(self.numbers[number])\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return frequency in self.frequency and self.frequency[frequency] > 0\\n    \\n    def addFrequency(self, frequency: int) -> None:\\n        if frequency in self.frequency:\\n            self.frequency[frequency] += 1\\n        else:\\n            self.frequency[frequency] = 1\\n    \\n    def deleteFrequency(self, frequency: int) -> None:\\n        if frequency in self.frequency:\\n            self.frequency[frequency] -= 1\\n        \\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499258,
                "title": "c-try-to-fullfil-reqs-of-hasfreq-func-in-o-1-not-in-o-n-this-is-motivation-for-using-unord-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(10^5)..Ofcourse in Worst Case!\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(10^5)..Ofcourse in Worst Case!\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> hashf,hashad;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int num) {\\n        if(hashad.count(num)) if(--hashf[hashad[num]]==0) hashf.erase(hashad[num]);\\n        hashad[num]++,hashf[hashad[num]]++;\\n    }\\n    \\n    void deleteOne(int num) {\\n        if(hashad.count(num)){\\n            if(--hashf[hashad[num]]==0) hashf.erase(hashad[num]);\\n            if(--hashad[num]==0) hashad.erase(num);\\n            else hashf[hashad[num]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int freq) {\\n        return hashf.count(freq);\\n    }  \\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> hashf,hashad;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int num) {\\n        if(hashad.count(num)) if(--hashf[hashad[num]]==0) hashf.erase(hashad[num]);\\n        hashad[num]++,hashf[hashad[num]]++;\\n    }\\n    \\n    void deleteOne(int num) {\\n        if(hashad.count(num)){\\n            if(--hashf[hashad[num]]==0) hashf.erase(hashad[num]);\\n            if(--hashad[num]==0) hashad.erase(num);\\n            else hashf[hashad[num]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int freq) {\\n        return hashf.count(freq);\\n    }  \\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499210,
                "title": "python-freq-nums-and-num-freq-dicts",
                "content": "This is 1000%%% not easy to code without numerous errors.\\n```\\nclass FrequencyTracker:\\n    def __init__(self):\\n        self.num_freq = {}\\n        self.freq_nums = {}\\n\\n    def add(self, num: int) -> None:\\n        self._change_num_freq(num, +1)\\n\\n    def deleteOne(self, num: int) -> None:\\n        self._change_num_freq(num, -1)\\n\\n    def _change_num_freq(self, num, delta):\\n        current_freq = self.num_freq.get(num, 0)\\n        if current_freq:\\n            # cleanup freq_nums\\n            self.freq_nums[current_freq].discard(num)\\n            if len(self.freq_nums[current_freq]) == 0:\\n                del self.freq_nums[current_freq]\\n\\n        new_freq = current_freq + delta\\n        if new_freq <= 0:\\n            self.num_freq.pop(num, None)\\n            return\\n\\n        # move num to different frequency\\n        self.num_freq[num] = new_freq\\n        if new_freq not in self.freq_nums:\\n            self.freq_nums[new_freq] = set([num])\\n        else:\\n            self.freq_nums[new_freq].add(num)\\n\\n    def hasFrequency(self, freq: int) -> bool:\\n        return freq in self.freq_nums\\n```\\n\\nSimplified version:\\n```\\nclass FrequencyTracker:\\n    def __init__(self):\\n        self.freq_count = defaultdict(int)\\n        self.num_freq = defaultdict(int)\\n\\n    def add(self, num: int) -> None:\\n        if self.freq_count[self.num_freq[num]] > 0:\\n            self.freq_count[self.num_freq[num]] -= 1\\n        self.num_freq[num] += 1\\n        self.freq_count[self.num_freq[num]] += 1\\n\\n    def deleteOne(self, num: int) -> None:\\n        if self.num_freq[num] > 0:\\n            self.freq_count[self.num_freq[num]] -= 1\\n            self.num_freq[num] -= 1\\n            self.freq_count[self.num_freq[num]] += 1\\n\\n    def hasFrequency(self, freq: int) -> bool:\\n        return self.freq_count[freq] > 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass FrequencyTracker:\\n    def __init__(self):\\n        self.num_freq = {}\\n        self.freq_nums = {}\\n\\n    def add(self, num: int) -> None:\\n        self._change_num_freq(num, +1)\\n\\n    def deleteOne(self, num: int) -> None:\\n        self._change_num_freq(num, -1)\\n\\n    def _change_num_freq(self, num, delta):\\n        current_freq = self.num_freq.get(num, 0)\\n        if current_freq:\\n            # cleanup freq_nums\\n            self.freq_nums[current_freq].discard(num)\\n            if len(self.freq_nums[current_freq]) == 0:\\n                del self.freq_nums[current_freq]\\n\\n        new_freq = current_freq + delta\\n        if new_freq <= 0:\\n            self.num_freq.pop(num, None)\\n            return\\n\\n        # move num to different frequency\\n        self.num_freq[num] = new_freq\\n        if new_freq not in self.freq_nums:\\n            self.freq_nums[new_freq] = set([num])\\n        else:\\n            self.freq_nums[new_freq].add(num)\\n\\n    def hasFrequency(self, freq: int) -> bool:\\n        return freq in self.freq_nums\\n```\n```\\nclass FrequencyTracker:\\n    def __init__(self):\\n        self.freq_count = defaultdict(int)\\n        self.num_freq = defaultdict(int)\\n\\n    def add(self, num: int) -> None:\\n        if self.freq_count[self.num_freq[num]] > 0:\\n            self.freq_count[self.num_freq[num]] -= 1\\n        self.num_freq[num] += 1\\n        self.freq_count[self.num_freq[num]] += 1\\n\\n    def deleteOne(self, num: int) -> None:\\n        if self.num_freq[num] > 0:\\n            self.freq_count[self.num_freq[num]] -= 1\\n            self.num_freq[num] -= 1\\n            self.freq_count[self.num_freq[num]] += 1\\n\\n    def hasFrequency(self, freq: int) -> bool:\\n        return self.freq_count[freq] > 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499157,
                "title": "python-solution-using-defaultdict-beats-100",
                "content": "\\n# Code\\n```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.count = defaultdict(int)\\n        self.freq = defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        if self.freq[self.count[number]] : self.freq[self.count[number]] -= 1\\n        self.count[number] += 1\\n        self.freq[self.count[number]] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        if self.count[number] : \\n            self.freq[self.count[number]] -= 1\\n            self.count[number] -= 1  \\n            self.freq[self.count[number]] += 1\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency]\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.count = defaultdict(int)\\n        self.freq = defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        if self.freq[self.count[number]] : self.freq[self.count[number]] -= 1\\n        self.count[number] += 1\\n        self.freq[self.count[number]] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        if self.count[number] : \\n            self.freq[self.count[number]] -= 1\\n            self.count[number] -= 1  \\n            self.freq[self.count[number]] += 1\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency]\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499048,
                "title": "two-dict-and-two-list-implementations-python",
                "content": "Try to read the code as plain English for the details/logic and improve.\\n\\n```\\nclass FrequencyTracker:\\n    \\n    \"\"\"\\n    Two Dicts Implementation\\n    Faster than Two Lists Implementation\\n    \"\"\"\\n\\n    def __init__(self):\\n        self.data = {}\\n        self.freqs = {}\\n        \\n    def add(self, number: int) -> None:\\n        self.data[number] = self.data.get(number, 0) + 1\\n        cur_f = self.data[number]\\n        prev_f = cur_f - 1\\n        self.freqs[cur_f] = self.freqs.get(cur_f, 0) + 1\\n        if prev_f > 0:\\n            self.freqs[prev_f] -= 1\\n            if self.freqs[prev_f] == 0:\\n                del self.freqs[prev_f]\\n        \\n    \\n    def deleteOne(self, number: int) -> None:\\n        if number in self.data:\\n            cur_f = self.data[number]\\n            self.data[number] -= 1\\n            if self.data[number] == 0:\\n                del self.data[number]\\n            self.freqs[cur_f] -= 1\\n            if self.freqs[cur_f] == 0:\\n                del self.freqs[cur_f]\\n            new_f = cur_f - 1\\n            if new_f > 0:\\n                self.freqs[new_f] = self.freqs.get(new_f, 0) + 1\\n            \\n        \\n        \\n    def hasFrequency(self, frequency: int) -> bool:\\n        return frequency in self.freqs\\n    \\n    \\n    \\nclass FrequencyTracker:\\n    \\n    \"\"\"\\n    Two Lists Implementation\\n    Easy in Logic and Implementation, but slower than two dicts implementation\\n    \"\"\"\\n\\n    def __init__(self):\\n        self.array = [0] * (10 ** 5 + 1) # number(a.k.a index) - freq\\n        self.freq = [0] * (10 ** 5 + 1) # freq(a.k.a index) - freq\\'s freq\\n        \\n        \\n    def add(self, number: int) -> None:\\n        self.array[number] += 1\\n        new_f = self.array[number]\\n        self.freq[new_f] += 1\\n        prev_f = new_f - 1\\n        if prev_f > 0:\\n            self.freq[prev_f] -= 1\\n        \\n        \\n    \\n    def deleteOne(self, number: int) -> None:\\n        org_f = self.array[number]\\n        if org_f != 0:\\n            self.array[number] -= 1\\n            self.freq[org_f] -= 1\\n            if org_f - 1 > 0:\\n                self.freq[org_f - 1] += 1\\n        \\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] > 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass FrequencyTracker:\\n    \\n    \"\"\"\\n    Two Dicts Implementation\\n    Faster than Two Lists Implementation\\n    \"\"\"\\n\\n    def __init__(self):\\n        self.data = {}\\n        self.freqs = {}\\n        \\n    def add(self, number: int) -> None:\\n        self.data[number] = self.data.get(number, 0) + 1\\n        cur_f = self.data[number]\\n        prev_f = cur_f - 1\\n        self.freqs[cur_f] = self.freqs.get(cur_f, 0) + 1\\n        if prev_f > 0:\\n            self.freqs[prev_f] -= 1\\n            if self.freqs[prev_f] == 0:\\n                del self.freqs[prev_f]\\n        \\n    \\n    def deleteOne(self, number: int) -> None:\\n        if number in self.data:\\n            cur_f = self.data[number]\\n            self.data[number] -= 1\\n            if self.data[number] == 0:\\n                del self.data[number]\\n            self.freqs[cur_f] -= 1\\n            if self.freqs[cur_f] == 0:\\n                del self.freqs[cur_f]\\n            new_f = cur_f - 1\\n            if new_f > 0:\\n                self.freqs[new_f] = self.freqs.get(new_f, 0) + 1\\n            \\n        \\n        \\n    def hasFrequency(self, frequency: int) -> bool:\\n        return frequency in self.freqs\\n    \\n    \\n    \\nclass FrequencyTracker:\\n    \\n    \"\"\"\\n    Two Lists Implementation\\n    Easy in Logic and Implementation, but slower than two dicts implementation\\n    \"\"\"\\n\\n    def __init__(self):\\n        self.array = [0] * (10 ** 5 + 1) # number(a.k.a index) - freq\\n        self.freq = [0] * (10 ** 5 + 1) # freq(a.k.a index) - freq\\'s freq\\n        \\n        \\n    def add(self, number: int) -> None:\\n        self.array[number] += 1\\n        new_f = self.array[number]\\n        self.freq[new_f] += 1\\n        prev_f = new_f - 1\\n        if prev_f > 0:\\n            self.freq[prev_f] -= 1\\n        \\n        \\n    \\n    def deleteOne(self, number: int) -> None:\\n        org_f = self.array[number]\\n        if org_f != 0:\\n            self.array[number] -= 1\\n            self.freq[org_f] -= 1\\n            if org_f - 1 > 0:\\n                self.freq[org_f - 1] += 1\\n        \\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] > 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498955,
                "title": "2-map-solution-c",
                "content": "\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    map<int,int> freq;\\n    map<int,int> isthere;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if (freq.find(number)==freq.end())\\n        {\\n            freq[number]++;\\n            isthere[freq[number]]++;\\n        }\\n        else\\n        {\\n            isthere[freq[number]]--;\\n            freq[number]++;\\n            isthere[freq[number]]++;\\n        }\\n    }\\n    \\n    void deleteOne(int number) {\\n        if (freq.find(number)!=freq.end())\\n        {\\n            isthere[freq[number]]--;\\n            freq[number]--;\\n            if (freq[number]>0)\\n            isthere[freq[number]]++;\\n            if (freq[number]==0)\\n                freq.erase(number);\\n        }\\n        \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return isthere[frequency]>0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    map<int,int> freq;\\n    map<int,int> isthere;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        if (freq.find(number)==freq.end())\\n        {\\n            freq[number]++;\\n            isthere[freq[number]]++;\\n        }\\n        else\\n        {\\n            isthere[freq[number]]--;\\n            freq[number]++;\\n            isthere[freq[number]]++;\\n        }\\n    }\\n    \\n    void deleteOne(int number) {\\n        if (freq.find(number)!=freq.end())\\n        {\\n            isthere[freq[number]]--;\\n            freq[number]--;\\n            if (freq[number]>0)\\n            isthere[freq[number]]++;\\n            if (freq[number]==0)\\n                freq.erase(number);\\n        }\\n        \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return isthere[frequency]>0;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498695,
                "title": "python3-o-n-2-defaultdict-to-manage-count-and-frequency",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.cnt, self.fre = defaultdict(int), defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        if self.cnt[number]: self.fre[self.cnt[number]] -= 1\\n        self.cnt[number] += 1\\n        self.fre[self.cnt[number]] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        if not self.cnt[number]: return\\n        self.fre[self.cnt[number]] -= 1\\n        self.cnt[number] -= 1\\n        if self.cnt[number]: self.fre[self.cnt[number]] += 1\\n        \\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.fre[frequency]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.cnt, self.fre = defaultdict(int), defaultdict(int)\\n\\n    def add(self, number: int) -> None:\\n        if self.cnt[number]: self.fre[self.cnt[number]] -= 1\\n        self.cnt[number] += 1\\n        self.fre[self.cnt[number]] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        if not self.cnt[number]: return\\n        self.fre[self.cnt[number]] -= 1\\n        self.cnt[number] -= 1\\n        if self.cnt[number]: self.fre[self.cnt[number]] += 1\\n        \\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.fre[frequency]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498530,
                "title": "java-two-map-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) n is the distinct number of total calls.\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    Map<Integer, Integer> numsMap;\\n    Map<Integer, Integer> freqMap;\\n    public FrequencyTracker() {\\n        numsMap = new HashMap<>();\\n        freqMap = new HashMap<>();\\n    }\\n    \\n    public void add(int number) {\\n        numsMap.put(number, numsMap.getOrDefault(number, 0) + 1);\\n        int newCount = numsMap.get(number);\\n        freqMap.put(newCount, freqMap.getOrDefault(newCount, 0) + 1);\\n        if(newCount > 1){\\n            freqMap.put(newCount - 1, freqMap.get(newCount - 1) - 1);\\n        }\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(!numsMap.containsKey(number) || numsMap.get(number) == 0) return;\\n        numsMap.put(number, numsMap.get(number) - 1);\\n        int newCount = numsMap.get(number);\\n        if(newCount > 0){\\n            freqMap.put(newCount, freqMap.getOrDefault(newCount, 0) + 1);\\n        }\\n        freqMap.put(newCount + 1, freqMap.get(newCount + 1) - 1);\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(!freqMap.containsKey(frequency))\\n            return false;\\n        return freqMap.get(frequency) > 0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    Map<Integer, Integer> numsMap;\\n    Map<Integer, Integer> freqMap;\\n    public FrequencyTracker() {\\n        numsMap = new HashMap<>();\\n        freqMap = new HashMap<>();\\n    }\\n    \\n    public void add(int number) {\\n        numsMap.put(number, numsMap.getOrDefault(number, 0) + 1);\\n        int newCount = numsMap.get(number);\\n        freqMap.put(newCount, freqMap.getOrDefault(newCount, 0) + 1);\\n        if(newCount > 1){\\n            freqMap.put(newCount - 1, freqMap.get(newCount - 1) - 1);\\n        }\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(!numsMap.containsKey(number) || numsMap.get(number) == 0) return;\\n        numsMap.put(number, numsMap.get(number) - 1);\\n        int newCount = numsMap.get(number);\\n        if(newCount > 0){\\n            freqMap.put(newCount, freqMap.getOrDefault(newCount, 0) + 1);\\n        }\\n        freqMap.put(newCount + 1, freqMap.get(newCount + 1) - 1);\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        if(!freqMap.containsKey(frequency))\\n            return false;\\n        return freqMap.get(frequency) > 0;\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498421,
                "title": "python-beat-100",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n**O(1)**\\n\\n- Space complexity:\\n**O(n)**\\n\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.n2f = dict()\\n        self.f2n = defaultdict(set)\\n\\n    def add(self, number: int) -> None:\\n        self.n2f[number] = self.n2f.get(number, 0) + 1\\n        freq = self.n2f[number]\\n        if freq == 1:\\n            self.f2n[freq].add(number)\\n        else:\\n            self.f2n[freq-1].remove(number)\\n            self.f2n[freq].add(number)\\n\\n    def deleteOne(self, number: int) -> None:\\n        if number in self.n2f:\\n            self.n2f[number] -= 1\\n            freq = self.n2f[number]\\n            self.f2n[freq+1].remove(number)\\n            if freq > 0:\\n                self.f2n[freq].add(number)\\n            elif freq == 0:\\n                del self.n2f[number]\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        if len(self.f2n[frequency]) > 0:\\n            return True\\n        return False\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.n2f = dict()\\n        self.f2n = defaultdict(set)\\n\\n    def add(self, number: int) -> None:\\n        self.n2f[number] = self.n2f.get(number, 0) + 1\\n        freq = self.n2f[number]\\n        if freq == 1:\\n            self.f2n[freq].add(number)\\n        else:\\n            self.f2n[freq-1].remove(number)\\n            self.f2n[freq].add(number)\\n\\n    def deleteOne(self, number: int) -> None:\\n        if number in self.n2f:\\n            self.n2f[number] -= 1\\n            freq = self.n2f[number]\\n            self.f2n[freq+1].remove(number)\\n            if freq > 0:\\n                self.f2n[freq].add(number)\\n            elif freq == 0:\\n                del self.n2f[number]\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        if len(self.f2n[frequency]) > 0:\\n            return True\\n        return False\\n\\n\\n# Your FrequencyTracker object will be instantiated and called as such:\\n# obj = FrequencyTracker()\\n# obj.add(number)\\n# obj.deleteOne(number)\\n# param_3 = obj.hasFrequency(frequency)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498383,
                "title": "java-hashmap-easy-to-understand",
                "content": "# Intuition\\n We are dealing with frequencies, so we use hashmap.\\n\\n# Approach\\n`map` - to store number of element.\\nEg. `map[2] -> 3` means number \\'2\\' appears 3 times in the data structure.\\n`freq` - to store frequencies of the frequency.\\nEg. `freq[2] -> 3` means there are 3 numbers which presents 2 times in the data structure.\\n\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n\\n    private Map<Integer,Integer> map;\\n    private Map<Integer,Integer> freq;\\n    public FrequencyTracker() {\\n        map = new HashMap<>();\\n        freq = new HashMap<>();\\n    }\\n\\n    public void add(int number) {\\n        int count = 0;\\n        if(map.containsKey(number)) count = map.get(number);\\n\\n        //we have previous count so decrease it if its not 0\\n        if(count != 0){\\n            if(freq.get(count) == 1) freq.remove(count);\\n            else freq.put(count, freq.get(count) - 1);\\n        }\\n        map.put(number, map.getOrDefault(number, 0) + 1);\\n\\n        if(count == 0){\\n            freq.put(1, freq.getOrDefault(1, 0) + 1);\\n        }else{\\n            //We incremented current number so we take count + 1\\n            freq.put(count + 1, freq.getOrDefault(count + 1, 0) + 1);\\n        }\\n    }\\n\\n    public void deleteOne(int number) {\\n       // if the map doesn\\'t contain the number then just return.\\n       if(!map.containsKey(number)) return;\\n\\n       //if the number present only one time then just remove it.\\n       if(map.get(number) == 1){\\n           map.remove(number);\\n\\n           //update its corresponding freq map.\\n           if(freq.get(1) == 1) freq.remove(1);\\n           else freq.put(1, freq.get(1) - 1);\\n       }else{\\n        //if the number present more than one time then just decrease it count.\\n           int count = map.get(number);\\n        //we remove 1 from current count in the freq.\\n           if(freq.get(count) == 1) freq.remove(count);\\n           else freq.put(count, freq.get(count) - 1);\\n           map.put(number, map.get(number) - 1);\\n\\n           count = map.get(number);\\n        //we add 1 to the decreased count in the freq.\\n           freq.put(count, freq.getOrDefault(count, 0) + 1);\\n       }\\n    }\\n\\n    public boolean hasFrequency(int frequency) {\\n\\n        return freq.containsKey(frequency);\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\n\\n    private Map<Integer,Integer> map;\\n    private Map<Integer,Integer> freq;\\n    public FrequencyTracker() {\\n        map = new HashMap<>();\\n        freq = new HashMap<>();\\n    }\\n\\n    public void add(int number) {\\n        int count = 0;\\n        if(map.containsKey(number)) count = map.get(number);\\n\\n        //we have previous count so decrease it if its not 0\\n        if(count != 0){\\n            if(freq.get(count) == 1) freq.remove(count);\\n            else freq.put(count, freq.get(count) - 1);\\n        }\\n        map.put(number, map.getOrDefault(number, 0) + 1);\\n\\n        if(count == 0){\\n            freq.put(1, freq.getOrDefault(1, 0) + 1);\\n        }else{\\n            //We incremented current number so we take count + 1\\n            freq.put(count + 1, freq.getOrDefault(count + 1, 0) + 1);\\n        }\\n    }\\n\\n    public void deleteOne(int number) {\\n       // if the map doesn\\'t contain the number then just return.\\n       if(!map.containsKey(number)) return;\\n\\n       //if the number present only one time then just remove it.\\n       if(map.get(number) == 1){\\n           map.remove(number);\\n\\n           //update its corresponding freq map.\\n           if(freq.get(1) == 1) freq.remove(1);\\n           else freq.put(1, freq.get(1) - 1);\\n       }else{\\n        //if the number present more than one time then just decrease it count.\\n           int count = map.get(number);\\n        //we remove 1 from current count in the freq.\\n           if(freq.get(count) == 1) freq.remove(count);\\n           else freq.put(count, freq.get(count) - 1);\\n           map.put(number, map.get(number) - 1);\\n\\n           count = map.get(number);\\n        //we add 1 to the decreased count in the freq.\\n           freq.put(count, freq.getOrDefault(count, 0) + 1);\\n       }\\n    }\\n\\n    public boolean hasFrequency(int frequency) {\\n\\n        return freq.containsKey(frequency);\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497941,
                "title": "kotlin-o-n-with-2-array",
                "content": "# Approach\\nWe two arrays set at size as **max n**.\\nOne for keeping track of **count of each number.**\\nOne for keeping track of **count of each frequency.**\\n\\n\\n\\n# Code\\n```\\nclass FrequencyTracker() {\\n\\n\\n    val count = IntArray(100001)\\n    val freq = IntArray(100001)\\n\\n\\n    fun add(number: Int) {\\n        val curFreq = ++count[number]\\n        freq[curFreq - 1]--\\n        freq[curFreq]++\\n    }\\n\\n\\n    fun deleteOne(number: Int) {\\n        if (count[number] > 0) {\\n            val curFreq = --count[number]\\n            freq[curFreq + 1]--\\n            freq[curFreq]++\\n        }\\n    }\\n\\n\\n    fun hasFrequency(frequency: Int) = freq[frequency] > 0\\n\\n\\n}\\n\\n\\n```\\n\\n",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass FrequencyTracker() {\\n\\n\\n    val count = IntArray(100001)\\n    val freq = IntArray(100001)\\n\\n\\n    fun add(number: Int) {\\n        val curFreq = ++count[number]\\n        freq[curFreq - 1]--\\n        freq[curFreq]++\\n    }\\n\\n\\n    fun deleteOne(number: Int) {\\n        if (count[number] > 0) {\\n            val curFreq = --count[number]\\n            freq[curFreq + 1]--\\n            freq[curFreq]++\\n        }\\n    }\\n\\n\\n    fun hasFrequency(frequency: Int) = freq[frequency] > 0\\n\\n\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497847,
                "title": "javascript-two-maps",
                "content": "```\\n\\nvar FrequencyTracker = function() {\\n    this.numbers = new Map();\\n    this.freq = new Map();\\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.add = function(number) {\\n    if (!this.numbers.has(number)) {\\n        this.numbers.set(number, 0)\\n    }\\n    \\n    const old = this.numbers.get(number);\\n    const freq = old + 1;\\n    \\n    if (old !== 0) { \\n        this.freq.set(old, this.freq.get(old) - 1)\\n    }\\n    \\n    this.numbers.set(number, freq);\\n    \\n    if (!this.freq.has(freq)) {\\n        this.freq.set(freq, 0)\\n    }\\n    \\n    this.freq.set(freq, this.freq.get(freq) + 1)\\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.deleteOne = function(number) {\\n    if (!this.numbers.has(number) || this.numbers.get(number) === 0) {\\n        return;\\n    }\\n    \\n    const old = this.numbers.get(number);\\n    const freq = old - 1;\\n    \\n    this.freq.set(old, this.freq.get(old) - 1)\\n    \\n    this.numbers.set(number, freq);\\n    \\n    if (!this.freq.has(freq)) {\\n        this.freq.set(freq, 0)\\n    }\\n    \\n    if (freq > 0) {\\n        this.freq.set(freq, this.freq.get(freq) + 1)\\n    }\\n};\\n\\n/** \\n * @param {number} frequency\\n * @return {boolean}\\n */\\nFrequencyTracker.prototype.hasFrequency = function(frequency) {\\n    return this.freq.has(frequency) && this.freq.get(frequency) > 0;\\n};\\n\\n/** \\n * Your FrequencyTracker object will be instantiated and called as such:\\n * var obj = new FrequencyTracker()\\n * obj.add(number)\\n * obj.deleteOne(number)\\n * var param_3 = obj.hasFrequency(frequency)\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n\\nvar FrequencyTracker = function() {\\n    this.numbers = new Map();\\n    this.freq = new Map();\\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.add = function(number) {\\n    if (!this.numbers.has(number)) {\\n        this.numbers.set(number, 0)\\n    }\\n    \\n    const old = this.numbers.get(number);\\n    const freq = old + 1;\\n    \\n    if (old !== 0) { \\n        this.freq.set(old, this.freq.get(old) - 1)\\n    }\\n    \\n    this.numbers.set(number, freq);\\n    \\n    if (!this.freq.has(freq)) {\\n        this.freq.set(freq, 0)\\n    }\\n    \\n    this.freq.set(freq, this.freq.get(freq) + 1)\\n};\\n\\n/** \\n * @param {number} number\\n * @return {void}\\n */\\nFrequencyTracker.prototype.deleteOne = function(number) {\\n    if (!this.numbers.has(number) || this.numbers.get(number) === 0) {\\n        return;\\n    }\\n    \\n    const old = this.numbers.get(number);\\n    const freq = old - 1;\\n    \\n    this.freq.set(old, this.freq.get(old) - 1)\\n    \\n    this.numbers.set(number, freq);\\n    \\n    if (!this.freq.has(freq)) {\\n        this.freq.set(freq, 0)\\n    }\\n    \\n    if (freq > 0) {\\n        this.freq.set(freq, this.freq.get(freq) + 1)\\n    }\\n};\\n\\n/** \\n * @param {number} frequency\\n * @return {boolean}\\n */\\nFrequencyTracker.prototype.hasFrequency = function(frequency) {\\n    return this.freq.has(frequency) && this.freq.get(frequency) > 0;\\n};\\n\\n/** \\n * Your FrequencyTracker object will be instantiated and called as such:\\n * var obj = new FrequencyTracker()\\n * obj.add(number)\\n * obj.deleteOne(number)\\n * var param_3 = obj.hasFrequency(frequency)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3497761,
                "title": "c-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n        public class FrequencyTracker\\n        {\\n            readonly Dictionary<int, int> numbermap;\\n            readonly Dictionary<int, List<int>> frequencyMap;\\n            public FrequencyTracker()\\n            {\\n                numbermap = new Dictionary<int, int>();\\n                frequencyMap = new Dictionary<int, List<int>>();\\n            }\\n\\n            public void Add(int number)\\n            {\\n                int freq = 1;\\n                if (!numbermap.ContainsKey(number))\\n                {\\n                    numbermap.Add(number, 0);\\n                }\\n                else\\n                {\\n                    freq = numbermap[number];\\n\\n                    frequencyMap[freq].Remove(number);\\n                    if(frequencyMap[freq].Count == 0)\\n                    {\\n                        frequencyMap.Remove(freq);\\n                    }\\n                }\\n                numbermap[number]++;\\n\\n                freq = numbermap[number];\\n\\n                if (!frequencyMap.ContainsKey(freq))\\n                {\\n                    frequencyMap.Add(freq, new List<int>());\\n                }\\n                frequencyMap[freq].Add(number);\\n            }\\n\\npublic void DeleteOne(int number)\\n            {\\n                if (numbermap.ContainsKey(number))\\n                {\\n                    int oldfreq = numbermap[number];\\n                    frequencyMap[oldfreq].Remove(number);\\n\\n                    if (frequencyMap[oldfreq].Count == 0) frequencyMap.Remove(oldfreq);\\n\\n                    if (oldfreq == 1)\\n                    {\\n                        numbermap.Remove(number);\\n                    }\\n                    else\\n                    {\\n                        numbermap[number]--;\\n\\n                        int newFreq = oldfreq - 1;\\n\\n                        if (!frequencyMap.ContainsKey(newFreq))\\n                        {\\n                            frequencyMap.Add(newFreq, new List<int>());\\n                        }\\n                        frequencyMap[newFreq].Add(number);\\n                    }\\n\\n\\n                }\\n            }\\n\\n            public bool HasFrequency(int frequency)\\n            {\\n                return frequencyMap.ContainsKey(frequency);\\n            }\\n        }\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.Add(number);\\n * obj.DeleteOne(number);\\n * bool param_3 = obj.HasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n        public class FrequencyTracker\\n        {\\n            readonly Dictionary<int, int> numbermap;\\n            readonly Dictionary<int, List<int>> frequencyMap;\\n            public FrequencyTracker()\\n            {\\n                numbermap = new Dictionary<int, int>();\\n                frequencyMap = new Dictionary<int, List<int>>();\\n            }\\n\\n            public void Add(int number)\\n            {\\n                int freq = 1;\\n                if (!numbermap.ContainsKey(number))\\n                {\\n                    numbermap.Add(number, 0);\\n                }\\n                else\\n                {\\n                    freq = numbermap[number];\\n\\n                    frequencyMap[freq].Remove(number);\\n                    if(frequencyMap[freq].Count == 0)\\n                    {\\n                        frequencyMap.Remove(freq);\\n                    }\\n                }\\n                numbermap[number]++;\\n\\n                freq = numbermap[number];\\n\\n                if (!frequencyMap.ContainsKey(freq))\\n                {\\n                    frequencyMap.Add(freq, new List<int>());\\n                }\\n                frequencyMap[freq].Add(number);\\n            }\\n\\npublic void DeleteOne(int number)\\n            {\\n                if (numbermap.ContainsKey(number))\\n                {\\n                    int oldfreq = numbermap[number];\\n                    frequencyMap[oldfreq].Remove(number);\\n\\n                    if (frequencyMap[oldfreq].Count == 0) frequencyMap.Remove(oldfreq);\\n\\n                    if (oldfreq == 1)\\n                    {\\n                        numbermap.Remove(number);\\n                    }\\n                    else\\n                    {\\n                        numbermap[number]--;\\n\\n                        int newFreq = oldfreq - 1;\\n\\n                        if (!frequencyMap.ContainsKey(newFreq))\\n                        {\\n                            frequencyMap.Add(newFreq, new List<int>());\\n                        }\\n                        frequencyMap[newFreq].Add(number);\\n                    }\\n\\n\\n                }\\n            }\\n\\n            public bool HasFrequency(int frequency)\\n            {\\n                return frequencyMap.ContainsKey(frequency);\\n            }\\n        }\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.Add(number);\\n * obj.DeleteOne(number);\\n * bool param_3 = obj.HasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497682,
                "title": "using-2-frequency-map-c-map",
                "content": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int>mp,m;\\n    FrequencyTracker() {\\n        mp.clear();\\n        m.clear();\\n    }\\n    \\n    void add(int num) {\\n        if(mp.find(num)!=mp.end())\\n            m[mp[num]]--;\\n        mp[num]++;\\n        m[mp[num]]++;\\n    }\\n    \\n    void deleteOne(int num) {\\n        if(mp.find(num)==mp.end())\\n            return ;\\n        m[mp[num]]--;\\n        if(mp[num]==1)\\n        {\\n            mp.erase(num);\\n        }\\n        else\\n        {\\n            mp[num]--;\\n            m[mp[num]]++;\\n        }   \\n    }\\n    \\n    bool hasFrequency(int f) {\\n        if(m.find(f)!=m.end() && m[f]>=1)\\n            return 1;\\n        return 0;\\n    }\\n};\\n",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int>mp,m;\\n    FrequencyTracker() {\\n        mp.clear();\\n        m.clear();\\n    }\\n    \\n    void add(int num) {\\n        if(mp.find(num)!=mp.end())\\n            m[mp[num]]--;\\n        mp[num]++;\\n        m[mp[num]]++;\\n    }\\n    \\n    void deleteOne(int num) {\\n        if(mp.find(num)==mp.end())\\n            return ;\\n        m[mp[num]]--;\\n        if(mp[num]==1)\\n        {\\n            mp.erase(num);\\n        }\\n        else\\n        {\\n            mp[num]--;\\n            m[mp[num]]++;\\n        }   \\n    }\\n    \\n    bool hasFrequency(int f) {\\n        if(m.find(f)!=m.end() && m[f]>=1)\\n            return 1;\\n        return 0;\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 3497479,
                "title": "easy-approach-using-hash-map-c",
                "content": "\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n unordered_map<int, int> freq;\\n unordered_map<int, unordered_set<int>> hasfreq;\\n FrequencyTracker() {}\\n    \\n    void add(int number) {\\n        if (freq.find(number) != freq.end()) {\\n            int f = freq[number];\\n            hasfreq[f].erase(number);\\n            if (hasfreq[f].empty()) {\\n                hasfreq.erase(f);\\n            }\\n            freq[number]++;\\n            hasfreq[freq[number]].insert(number);\\n        } else {\\n            freq[number] = 1;\\n            hasfreq[freq[number]].insert(number);\\n        }\\n    }\\n    \\n    void deleteOne(int number) {\\n        if (freq.find(number) != freq.end()) {\\n            int f = freq[number];\\n            hasfreq[f].erase(number);\\n            if (hasfreq[f].empty()) {\\n                hasfreq.erase(f);\\n            }\\n            freq[number]--;\\n            if (freq[number] == 0) {\\n                freq.erase(number);\\n            } else {\\n                hasfreq[freq[number]].insert(number);\\n            }\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return hasfreq.find(frequency) != hasfreq.end();\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n unordered_map<int, int> freq;\\n unordered_map<int, unordered_set<int>> hasfreq;\\n FrequencyTracker() {}\\n    \\n    void add(int number) {\\n        if (freq.find(number) != freq.end()) {\\n            int f = freq[number];\\n            hasfreq[f].erase(number);\\n            if (hasfreq[f].empty()) {\\n                hasfreq.erase(f);\\n            }\\n            freq[number]++;\\n            hasfreq[freq[number]].insert(number);\\n        } else {\\n            freq[number] = 1;\\n            hasfreq[freq[number]].insert(number);\\n        }\\n    }\\n    \\n    void deleteOne(int number) {\\n        if (freq.find(number) != freq.end()) {\\n            int f = freq[number];\\n            hasfreq[f].erase(number);\\n            if (hasfreq[f].empty()) {\\n                hasfreq.erase(f);\\n            }\\n            freq[number]--;\\n            if (freq[number] == 0) {\\n                freq.erase(number);\\n            } else {\\n                hasfreq[freq[number]].insert(number);\\n            }\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return hasfreq.find(frequency) != hasfreq.end();\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497442,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass FrequencyTracker {\\n    private HashMap<Integer, Integer> frequencyMap;\\n    private HashMap<Integer, Integer> countMap;\\n\\n    public FrequencyTracker() {\\n        frequencyMap = new HashMap<>();\\n        countMap = new HashMap<>();\\n    }\\n    \\n    public void add(int number) {\\n        int frequency = frequencyMap.getOrDefault(number, 0);\\n        frequencyMap.put(number, frequency + 1);\\n        \\n        int count = countMap.getOrDefault(frequency, 0);\\n        countMap.put(frequency, count - 1);\\n        \\n        count = countMap.getOrDefault(frequency + 1, 0);\\n        countMap.put(frequency + 1, count + 1);\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if (!frequencyMap.containsKey(number)) {\\n            return;\\n        }\\n        \\n        int frequency = frequencyMap.get(number);\\n        frequencyMap.put(number, frequency - 1);\\n        \\n        int count = countMap.getOrDefault(frequency, 0);\\n        countMap.put(frequency, count - 1);\\n        \\n        if (frequency == 1) {\\n            frequencyMap.remove(number);\\n        } else {\\n            count = countMap.getOrDefault(frequency - 1, 0);\\n            countMap.put(frequency - 1, count + 1);\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return countMap.containsKey(frequency) && countMap.get(frequency) > 0;\\n    }\\n}\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass FrequencyTracker {\\n    private HashMap<Integer, Integer> frequencyMap;\\n    private HashMap<Integer, Integer> countMap;\\n\\n    public FrequencyTracker() {\\n        frequencyMap = new HashMap<>();\\n        countMap = new HashMap<>();\\n    }\\n    \\n    public void add(int number) {\\n        int frequency = frequencyMap.getOrDefault(number, 0);\\n        frequencyMap.put(number, frequency + 1);\\n        \\n        int count = countMap.getOrDefault(frequency, 0);\\n        countMap.put(frequency, count - 1);\\n        \\n        count = countMap.getOrDefault(frequency + 1, 0);\\n        countMap.put(frequency + 1, count + 1);\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if (!frequencyMap.containsKey(number)) {\\n            return;\\n        }\\n        \\n        int frequency = frequencyMap.get(number);\\n        frequencyMap.put(number, frequency - 1);\\n        \\n        int count = countMap.getOrDefault(frequency, 0);\\n        countMap.put(frequency, count - 1);\\n        \\n        if (frequency == 1) {\\n            frequencyMap.remove(number);\\n        } else {\\n            count = countMap.getOrDefault(frequency - 1, 0);\\n            countMap.put(frequency - 1, count + 1);\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return countMap.containsKey(frequency) && countMap.get(frequency) > 0;\\n    }\\n}\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497298,
                "title": "ez-c-solz",
                "content": "\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    // vector<int> v;\\n    unordered_map<int,int> mp;\\n    unordered_map<int,int> freq;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        // v.push_back(number);\\n        mp[number]++;\\n        freq[mp[number]]++;\\n        freq[mp[number]-1]--;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number]>0){\\n            freq[mp[number]]--;\\n            mp[number]--;\\n            freq[mp[number]]++;\\n        }\\n\\n       \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq[frequency]>=1;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    // vector<int> v;\\n    unordered_map<int,int> mp;\\n    unordered_map<int,int> freq;\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n        // v.push_back(number);\\n        mp[number]++;\\n        freq[mp[number]]++;\\n        freq[mp[number]-1]--;\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number]>0){\\n            freq[mp[number]]--;\\n            mp[number]--;\\n            freq[mp[number]]++;\\n        }\\n\\n       \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freq[frequency]>=1;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497271,
                "title": "java-solution-easy-design-steps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHashMaps\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Maintain two maps (***numMap*** , ***freqMap***)\\n- One for Numbers and thier frequencies and the other one for the available frequencies and the count of numbers having this frequency.\\n- When a number is added, get its current frequency, decrease its frequency count from ***freqMap*** . If the current frequency\\'s count becomes 0, remove that frequency. \\n- Then increament the frequency of the number in ***numMap*** and subsequently increase the frequency count in ***freqMap***.\\n- When a number is deleted, repeat step 3.\\n- Then decreament the frequency of the number from the ***numMap*** and subsequently decreament the frequency count in ***freqMap***.\\n- Remove frequency if count becomes 0.\\n- To check if a number exists with the given frequency, just check in ***freqMap*** if frequency exists or not.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n\\n    private Map<Integer, Integer> numMap;\\n    private Map<Integer, Integer> freqMap;\\n    \\n    public FrequencyTracker() {\\n        numMap = new HashMap<>();\\n        freqMap = new HashMap<>();\\n    }\\n    \\n    public void add(int number) {\\n        int currFreq = numMap.getOrDefault(number, 0);\\n        \\n        if(currFreq > 0 ){\\n            freqMap.put(currFreq, freqMap.get(currFreq) - 1);\\n            \\n            if(freqMap.get(currFreq) == 0){\\n                freqMap.remove(currFreq);\\n            }\\n        }\\n        \\n        numMap.put(number, numMap.getOrDefault(number, 0) + 1);\\n        \\n        int newFreq = numMap.get(number);\\n        \\n        freqMap.put(newFreq, freqMap.getOrDefault(newFreq, 0) + 1);\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(numMap.containsKey(number)){\\n            \\n            int currFreq = numMap.getOrDefault(number, 0);\\n        \\n            if(currFreq > 0 ){\\n                freqMap.put(currFreq, freqMap.get(currFreq) - 1);\\n\\n                if(freqMap.get(currFreq) == 0){\\n                    freqMap.remove(currFreq);\\n                }\\n            }\\n            \\n            numMap.put(number, numMap.get(number) - 1);\\n            \\n            int newFreq = numMap.get(number);\\n\\n            if(newFreq == 0){\\n                numMap.remove(number);\\n            }else{\\n                freqMap.put(newFreq, freqMap.getOrDefault(newFreq, 0) + 1);\\n            }\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return freqMap.containsKey(frequency);\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n\\n    private Map<Integer, Integer> numMap;\\n    private Map<Integer, Integer> freqMap;\\n    \\n    public FrequencyTracker() {\\n        numMap = new HashMap<>();\\n        freqMap = new HashMap<>();\\n    }\\n    \\n    public void add(int number) {\\n        int currFreq = numMap.getOrDefault(number, 0);\\n        \\n        if(currFreq > 0 ){\\n            freqMap.put(currFreq, freqMap.get(currFreq) - 1);\\n            \\n            if(freqMap.get(currFreq) == 0){\\n                freqMap.remove(currFreq);\\n            }\\n        }\\n        \\n        numMap.put(number, numMap.getOrDefault(number, 0) + 1);\\n        \\n        int newFreq = numMap.get(number);\\n        \\n        freqMap.put(newFreq, freqMap.getOrDefault(newFreq, 0) + 1);\\n    }\\n    \\n    public void deleteOne(int number) {\\n        if(numMap.containsKey(number)){\\n            \\n            int currFreq = numMap.getOrDefault(number, 0);\\n        \\n            if(currFreq > 0 ){\\n                freqMap.put(currFreq, freqMap.get(currFreq) - 1);\\n\\n                if(freqMap.get(currFreq) == 0){\\n                    freqMap.remove(currFreq);\\n                }\\n            }\\n            \\n            numMap.put(number, numMap.get(number) - 1);\\n            \\n            int newFreq = numMap.get(number);\\n\\n            if(newFreq == 0){\\n                numMap.remove(number);\\n            }else{\\n                freqMap.put(newFreq, freqMap.getOrDefault(newFreq, 0) + 1);\\n            }\\n        }\\n    }\\n    \\n    public boolean hasFrequency(int frequency) {\\n        return freqMap.containsKey(frequency);\\n    }\\n}\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker obj = new FrequencyTracker();\\n * obj.add(number);\\n * obj.deleteOne(number);\\n * boolean param_3 = obj.hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497202,
                "title": "easy-solution",
                "content": "```\\nclass FrequencyTracker {\\n    unordered_map<int, int> freq, freqCnt;\\npublic:\\n    FrequencyTracker() {}\\n    \\n    void add(int number) \\n    {\\n        freqCnt[freq[number]]--;\\n        freq[number]++;\\n        freqCnt[freq[number]]++;\\n    }\\n    \\n    void deleteOne(int number) \\n    {\\n        if(freq[number] == 0) return;\\n        \\n        freqCnt[freq[number]]--;\\n        freq[number]--;\\n        freqCnt[freq[number]]++;\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freqCnt[frequency];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass FrequencyTracker {\\n    unordered_map<int, int> freq, freqCnt;\\npublic:\\n    FrequencyTracker() {}\\n    \\n    void add(int number) \\n    {\\n        freqCnt[freq[number]]--;\\n        freq[number]++;\\n        freqCnt[freq[number]]++;\\n    }\\n    \\n    void deleteOne(int number) \\n    {\\n        if(freq[number] == 0) return;\\n        \\n        freqCnt[freq[number]]--;\\n        freq[number]--;\\n        freqCnt[freq[number]]++;\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        return freqCnt[frequency];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497100,
                "title": "scala-two-mutable-map",
                "content": "# Code\\n```\\nclass FrequencyTracker() {\\n\\n  val counts = scala.collection.mutable.Map.empty[Int, Int].withDefaultValue(0)\\n\\n  val frequencies = scala.collection.mutable.Map.empty[Int, Int].withDefaultValue(0)\\n\\n  def add(number: Int): Unit = {\\n    val frequency = counts(number)\\n    frequencies(frequency) -= 1\\n    frequencies(frequency + 1) += 1\\n    counts(number) += 1\\n  }\\n\\n  def deleteOne(number: Int): Unit = {\\n    val frequency = counts(number)\\n    if (frequency > 0) {\\n      frequencies(frequency) -= 1\\n      frequencies(frequency - 1) += 1\\n      counts(number) -= 1\\n    }\\n  }\\n\\n  def hasFrequency(frequency: Int): Boolean =\\n    frequencies(frequency) > 0\\n}\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * var obj = new FrequencyTracker()\\n * obj.add(number)\\n * obj.deleteOne(number)\\n * var param_3 = obj.hasFrequency(frequency)\\n */\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nclass FrequencyTracker() {\\n\\n  val counts = scala.collection.mutable.Map.empty[Int, Int].withDefaultValue(0)\\n\\n  val frequencies = scala.collection.mutable.Map.empty[Int, Int].withDefaultValue(0)\\n\\n  def add(number: Int): Unit = {\\n    val frequency = counts(number)\\n    frequencies(frequency) -= 1\\n    frequencies(frequency + 1) += 1\\n    counts(number) += 1\\n  }\\n\\n  def deleteOne(number: Int): Unit = {\\n    val frequency = counts(number)\\n    if (frequency > 0) {\\n      frequencies(frequency) -= 1\\n      frequencies(frequency - 1) += 1\\n      counts(number) -= 1\\n    }\\n  }\\n\\n  def hasFrequency(frequency: Int): Boolean =\\n    frequencies(frequency) > 0\\n}\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * var obj = new FrequencyTracker()\\n * obj.add(number)\\n * obj.deleteOne(number)\\n * var param_3 = obj.hasFrequency(frequency)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497084,
                "title": "python3-o-1-methods",
                "content": "Also allows to see each frequency count\\n\\n```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.dct = collections.Counter()\\n        self.freq = collections.Counter()\\n\\n    def add(self, number: int) -> None:\\n        curFreq = self.dct[number]\\n        if curFreq > 0:\\n            self.freq[curFreq] -= 1\\n            self.freq[curFreq+1] +=1\\n        elif curFreq == 0:\\n            self.freq[1] += 1\\n        self.dct[number] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        curFreq = self.dct[number]\\n        if curFreq > 0:\\n            self.freq[curFreq] -= 1\\n            self.freq[curFreq - 1] += 1\\n            self.dct[number] -= 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] > 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FrequencyTracker:\\n\\n    def __init__(self):\\n        self.dct = collections.Counter()\\n        self.freq = collections.Counter()\\n\\n    def add(self, number: int) -> None:\\n        curFreq = self.dct[number]\\n        if curFreq > 0:\\n            self.freq[curFreq] -= 1\\n            self.freq[curFreq+1] +=1\\n        elif curFreq == 0:\\n            self.freq[1] += 1\\n        self.dct[number] += 1\\n\\n    def deleteOne(self, number: int) -> None:\\n        curFreq = self.dct[number]\\n        if curFreq > 0:\\n            self.freq[curFreq] -= 1\\n            self.freq[curFreq - 1] += 1\\n            self.dct[number] -= 1\\n\\n    def hasFrequency(self, frequency: int) -> bool:\\n        return self.freq[frequency] > 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497036,
                "title": "solution-using-two-hash-maps",
                "content": "# Intuitio\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\n    int flag =1;\\n    HashMap<Integer,Integer> hs = new HashMap<>();\\n    HashMap<Integer,Integer> hs1 = new HashMap<>();\\n    public FrequencyTracker() {}\\n    \\n    public void add(int number) {\\n        \\n        \\n        hs.put(number,hs.getOrDefault(number, 0)+1);\\n        hs1.put(hs.get(number),hs1.getOrDefault(hs.get(number), 0)+1 );\\n        if(hs.get(number)!=1)\\n         hs1.put(hs.get(number)-1,hs1.get(hs.get(number)-1)-1 );\\n        \\n    }\\n    \\n    \\n    public void deleteOne(int number) {\\n        if(hs.get(number)!=null)\\n        {\\n        if(hs.get(number)>=1)\\n        { hs1.put(hs.get(number), hs1.get(hs.get(number))-1);\\n         hs.replace(number,hs.get(number)-1);\\n          if(hs.get(number)!=0)\\n          hs1.put(hs.get(number),hs1.get(hs.get(number))+1);\\n           \\n       \\n      \\n      // \\n             \\n        }\\n    }\\n    }\\n\\n    \\n    public boolean hasFrequency(int frequency) {\\n        \\n        if(hs1.get(frequency)==null)\\n         {return false;}\\n         else{\\n             if(hs1.get(frequency)>0)\\n             return true;\\n         else\\n                 return false;\\n         }\\n            \\n    }\\n   \\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    int flag =1;\\n    HashMap<Integer,Integer> hs = new HashMap<>();\\n    HashMap<Integer,Integer> hs1 = new HashMap<>();\\n    public FrequencyTracker() {}\\n    \\n    public void add(int number) {\\n        \\n        \\n        hs.put(number,hs.getOrDefault(number, 0)+1);\\n        hs1.put(hs.get(number),hs1.getOrDefault(hs.get(number), 0)+1 );\\n        if(hs.get(number)!=1)\\n         hs1.put(hs.get(number)-1,hs1.get(hs.get(number)-1)-1 );\\n        \\n    }\\n    \\n    \\n    public void deleteOne(int number) {\\n        if(hs.get(number)!=null)\\n        {\\n        if(hs.get(number)>=1)\\n        { hs1.put(hs.get(number), hs1.get(hs.get(number))-1);\\n         hs.replace(number,hs.get(number)-1);\\n          if(hs.get(number)!=0)\\n          hs1.put(hs.get(number),hs1.get(hs.get(number))+1);\\n           \\n       \\n      \\n      // \\n             \\n        }\\n    }\\n    }\\n\\n    \\n    public boolean hasFrequency(int frequency) {\\n        \\n        if(hs1.get(frequency)==null)\\n         {return false;}\\n         else{\\n             if(hs1.get(frequency)>0)\\n             return true;\\n         else\\n                 return false;\\n         }\\n            \\n    }\\n   \\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496907,
                "title": "c-2-hash-maps-add-0-frequency-to-avoid-edge-case",
                "content": "```\\nclass FrequencyTracker {\\n    unordered_map<int, int> freq, ffreq;\\npublic:\\n    void add(int n) {\\n        --ffreq[freq[n]];\\n        ++ffreq[++freq[n]];\\n    }\\n    \\n    void deleteOne(int n) {\\n        if(freq[n] > 0) {\\n            --ffreq[freq[n]];\\n            ++ffreq[--freq[n]];\\n        }\\n    }\\n    \\n    bool hasFrequency(int f) {\\n        return ffreq[f] > 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\n    unordered_map<int, int> freq, ffreq;\\npublic:\\n    void add(int n) {\\n        --ffreq[freq[n]];\\n        ++ffreq[++freq[n]];\\n    }\\n    \\n    void deleteOne(int n) {\\n        if(freq[n] > 0) {\\n            --ffreq[freq[n]];\\n            ++ffreq[--freq[n]];\\n        }\\n    }\\n    \\n    bool hasFrequency(int f) {\\n        return ffreq[f] > 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496804,
                "title": "simple-commented-with-time-complexity-code",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\non add just erase the value of freq from mi map and simunateously increase cnt of ele in map table \\ndelete m just see    if present , then decrease the mi vluae one then afon \\\\\\\\                                 \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    map<int,int>mp;//no --> cnt\\n     map<int,int>mi;//to check the freq present or not freq-->cnt\\n\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n     mp[number]++;\\n      if(mp[number]>0) {// tht means already present so have to first erase the cur freq from mi map to in order to add new coming to mp \\n      mi[mp[number]-1]--;\\n      }\\n      mi[mp[number]]++; //inserting new freq to mi  so tht we can maintain the new freq cnt in  map\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number]==0)return ;\\n         //checking if it present so have to change in both map \\n        \\n            mi[mp[number]]--;\\n            mp[number]--;\\n            if(mp[number]>0)\\n            mi[mp[number]]++; //adding new freq to mi map \\n        \\n        \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n         return mi[frequency] ;\\n        \\n    }\\n};\\ntc isO((n))\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    map<int,int>mp;//no --> cnt\\n     map<int,int>mi;//to check the freq present or not freq-->cnt\\n\\n    FrequencyTracker() {\\n        \\n    }\\n    \\n    void add(int number) {\\n     mp[number]++;\\n      if(mp[number]>0) {// tht means already present so have to first erase the cur freq from mi map to in order to add new coming to mp \\n      mi[mp[number]-1]--;\\n      }\\n      mi[mp[number]]++; //inserting new freq to mi  so tht we can maintain the new freq cnt in  map\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(mp[number]==0)return ;\\n         //checking if it present so have to change in both map \\n        \\n            mi[mp[number]]--;\\n            mp[number]--;\\n            if(mp[number]>0)\\n            mi[mp[number]]++; //adding new freq to mi map \\n        \\n        \\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n         return mi[frequency] ;\\n        \\n    }\\n};\\ntc isO((n))\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496801,
                "title": "easy-hash-maps-implementation-using-unordered-maps",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTwo hashmaps, count and freq are maintained, one which keeps the total occurences of the elements being inserted/deleted and the 2nd which keeps a count of the frequencies.\\n<!-- # Complex -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map <int, int> count;\\n    unordered_map <int, int> freq;\\n    FrequencyTracker() {}\\n    void add(int number) {\\n        if(freq[count[number]]>0)\\n            freq[count[number]]--;\\n        ++count[number];\\n        ++freq[count[number]];\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(count[number]>0){\\n            freq[count[number]]--;\\n            count[number]--;\\n            freq[count[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(freq[frequency]>0)\\n            return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map <int, int> count;\\n    unordered_map <int, int> freq;\\n    FrequencyTracker() {}\\n    void add(int number) {\\n        if(freq[count[number]]>0)\\n            freq[count[number]]--;\\n        ++count[number];\\n        ++freq[count[number]];\\n    }\\n    \\n    void deleteOne(int number) {\\n        if(count[number]>0){\\n            freq[count[number]]--;\\n            count[number]--;\\n            freq[count[number]]++;\\n        }\\n    }\\n    \\n    bool hasFrequency(int frequency) {\\n        if(freq[frequency]>0)\\n            return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FrequencyTracker object will be instantiated and called as such:\\n * FrequencyTracker* obj = new FrequencyTracker();\\n * obj->add(number);\\n * obj->deleteOne(number);\\n * bool param_3 = obj->hasFrequency(frequency);\\n */\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1885712,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1886897,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1885604,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1885453,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1885385,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 2024758,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1926023,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1918318,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1912759,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1896763,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1885712,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1886897,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1885604,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1885453,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1885385,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 2024758,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1926023,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1918318,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1912759,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            },
            {
                "id": 1896763,
                "content": [
                    {
                        "username": "Sashi_sharma",
                        "content": "1115/1117 passed\nTLE!!!!\nI thought by using single unordered_map it should be easy and fast but after TLE \nmy brain just SUCKS!!!"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I see a lot of solutions use hashmaps, but i would prefer using an array because it takes lesser space, and relatively faster operations."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "\\n1100 / 1117 testcases passed\\nthus really sucks , TLE !!!!!!!"
                    },
                    {
                        "username": "its-hrs",
                        "content": "1115/1117 passed bro then TLE\\uD83E\\uDD72"
                    },
                    {
                        "username": "XTJ0127ABC",
                        "content": "Corner cases really suck... No wonder such a low acceptance rate."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Approach:-\n\n- We can use two data structures to keep track of the frequencies of the numbers:\n\n- freqMap: A HashMap that stores the frequency of each number that has been added.\n- countMap: A TreeMap that stores the count of numbers that have a given frequency.\n- To add a number, we first retrieve its current frequency from freqMap. We then increment the frequency and update the freqMap. Next, we decrement the count of numbers with the previous frequency in countMap and remove the entry if the count is zero. Finally, we increment the count of numbers with the new frequency in countMap.\n\n- To delete a number, we first check if it is in freqMap. If it is, we retrieve its current frequency and decrement it. We then update freqMap and decrement the count of numbers with the previous frequency in countMap. If the count is zero, we remove the entry. If the new frequency is greater than zero, we increment the count of numbers with the new frequency in countMap. If the frequency of the number becomes zero, we remove it from freqMap.\n\n- To check if a frequency exists, we simply check if the countMap contains a key with the given frequency."
                    },
                    {
                        "username": "Socrii13",
                        "content": "I had used one long array  it give me tle \\nans when i run fior that particular case it shows the result\\n\\n  vector<int>freq;\\n\\n    FrequencyTracker() \\n    {\\n        for(int i=0;i<=1e5;i++)\\n        {\\n            freq.push_back(0);\\n        }\\n    }\\n    void add(int num) \\n    {\\n        freq[num-1]+=1;   \\n    }\\n    \\n    void deleteOne(int num) \\n    {\\n        if(freq[num-1]>0)\\n        freq[num-1]-=1;  \\n        \\n    }\\n    bool hasFrequency(int key ) \\n    {\\n        vector<int>check=freq;\\n        sort(check.begin(),check.end());\\n        int low=0;\\n        int high=check.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(check[mid]==key)\\n            {\\n                return 1;\\n            }\\n            if(check[mid]>key)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "ivzap",
                        "content": "Don\\'t overthink this problem. Hard part is implementation without bugs."
                    },
                    {
                        "username": "itsgosho",
                        "content": "That is a really interesting problem to practice maintaining relationship between maps. The key note here, even that the problem looks very easy is the optimization, without it you will receive TLE"
                    },
                    {
                        "username": "killerraj369",
                        "content": "Easy Hashmap Question"
                    },
                    {
                        "username": "grind99",
                        "content": "1115/1118 passes :/\\nsucks"
                    }
                ]
            }
        ]
    },
    {
        "title": "Power of Heroes",
        "question_content": "<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> representing the strength of some heroes. The<b> power</b> of a group of heroes is defined as follows:</p>\n\n<ul>\n\t<li>Let <code>i<sub>0</sub></code>, <code>i<sub>1</sub></code>, ... ,<code>i<sub>k</sub></code> be the indices of the heroes in a group. Then, the power of this group is <code>max(nums[i<sub>0</sub>], nums[i<sub>1</sub>], ... ,nums[i<sub>k</sub>])<sup>2</sup> * min(nums[i<sub>0</sub>], nums[i<sub>1</sub>], ... ,nums[i<sub>k</sub>])</code>.</li>\n</ul>\n\n<p>Return <em>the sum of the <strong>power</strong> of all <strong>non-empty</strong> groups of heroes possible.</em> Since the sum could be very large, return it <strong>modulo</strong> <code>10<sup>9 </sup>+ 7</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,1,4]\n<strong>Output:</strong> 141\n<strong>Explanation:</strong> \n1<sup>st</sup>&nbsp;group: [2] has power = 2<sup>2</sup>&nbsp;* 2 = 8.\n2<sup>nd</sup>&nbsp;group: [1] has power = 1<sup>2</sup> * 1 = 1. \n3<sup>rd</sup>&nbsp;group: [4] has power = 4<sup>2</sup> * 4 = 64. \n4<sup>th</sup>&nbsp;group: [2,1] has power = 2<sup>2</sup> * 1 = 4. \n5<sup>th</sup>&nbsp;group: [2,4] has power = 4<sup>2</sup> * 2 = 32. \n6<sup>th</sup>&nbsp;group: [1,4] has power = 4<sup>2</sup> * 1 = 16. \n7<sup>th</sup>&nbsp;group: [2,1,4] has power = 4<sup>2</sup> * 1 = 16. \nThe sum of powers of all groups is 8 + 1 + 64 + 4 + 32 + 16 + 16 = 141.\n\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,1,1]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> A total of 7 groups are possible, and the power of each group will be 1. Therefore, the sum of the powers of all groups is 7.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3520233,
                "title": "c-java-python-sort-and-enumerate-each-maximum-value",
                "content": "> **I know almost nothing about English, pointing out the mistakes in my article would be much appreciated.**\\n\\n> **In addition, I\\'m too weak, please be critical of my ideas.**\\n---\\n\\n# Intuition\\n1. Since we just consider \"combination\" instead of \"permutation\", **sorting doesn\\'t affect the final result.**\\n2. After sorting, we try to enumerate all (minimum $$a_i$$, maximum $$a_j$$) pairs, guarantee that $$i<j$$. \\n    For each pair, all elements between $$i$$ and $$j$$ can be independently selected to be included or not. **So there will be $$2^{j-i-1}$$ different combinations with minimum $$a_i$$ and maximum $$a_j$$.** \\n![arraychoose.png](https://assets.leetcode.com/users/images/0c2829c8-9255-42fd-a5a7-9279691d7c9c_1683998408.4450045.png)\\n    The contribution of pair$$(a_i, a_j)$$ to the answer will be:\\n    $$c(i,j) = {a_{j}}^{2} \\\\cdot a_i \\\\cdot 2^{j-i-1}$$\\n3. As a result, the contribution of $$a_j$$ is the sum of all valid $$(i,j)$$\\'s contribution:\\n    $$c(j) =\\\\sum\\\\limits_{i=0}^{j}c(i,j)$$\\n    In step 2, we have discussed the case $$i<j$$. And obviously, when $$i=j$$, the contribution is:\\n    $$c(j,j)={a_j}^3$$\\n    **So the total contribution of $$j$$ is:**\\n    $$c(j) = c(j,j) + \\\\sum\\\\limits_{i=0}^{j-1}c(i,j) ={a_{j}}^{3} + {a_{j}}^{2} \\\\cdot \\\\sum\\\\limits_{i=0}^{j-1} a_i \\\\cdot 2^{j-i-1}$$\\n4. Let\\'s set $$S(j) = \\\\sum\\\\limits_{i=0}^{j-1} a_i \\\\cdot 2^{j-i-1}$$, so the $$c(j)$$ changes to:\\n    $$c(j) = {a_{j}}^{2} \\\\cdot [a_j + S(j)]$$\\n    Now, our task is to calculate $$S(j)$$ in a low average time, such as $$O(1)$$.\\n5. Obviously there is a sense that it is possible to **recursively derive $$S(j)$$ from $$S(j-1)$$.** We can easily get that:\\n    $$S(0) = 0$$\\n    $$S(j) = a_{j-1} + 2 \\\\cdot \\\\sum\\\\limits_{i=0}^{j-2} a_i \\\\cdot 2^{j-i-2} =  a_{j-1} + 2 S(j-1), j > 0$$\\n    *(That\\'s because from $$j-1$$ to $$j$$, $$a_{j-1}$$ will be included for all $$i$$, so it offers a new independent choice.)*\\n\\n6. Therefore, sort firstly, then traverse the array from front to back, and constantly maintain $$S(j)$$ and count.\\n\\n# Complexity\\n- Time complexity: $$O(n \\\\log n)$$\\n- Space complexity: $$O(1)$$ or $$O(\\\\log n)$$ or $$O(n)$$, depends on `sort` implementation.\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        long long res = 0, s = 0, base = 1e9 + 7;\\n        sort(nums.begin(), nums.end());\\n        for (int x: nums) {\\n            res = (res + (s + x) * x % base * x % base) % base;\\n            s = (s * 2 + x) % base;\\n        }\\n        return res;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public int sumOfPower(int[] nums) {\\n        long res = 0, s = 0, base = 1000000007;\\n        Arrays.sort(nums);\\n        for (int x: nums) {\\n            res = (res + (s + x) * x % base * x % base) % base;\\n            s = (s * 2 + x) % base;\\n        }\\n        return (int)res;\\n    }\\n}\\n```\\n``` Python3 []\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        ans, t, base = 0, 0, 10**9 + 7\\n        for c in sorted(nums):\\n            ans = (ans + (t + c) * c * c) % base\\n            t = (2 * t + c) % base\\n        return ans\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Sort"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        long long res = 0, s = 0, base = 1e9 + 7;\\n        sort(nums.begin(), nums.end());\\n        for (int x: nums) {\\n            res = (res + (s + x) * x % base * x % base) % base;\\n            s = (s * 2 + x) % base;\\n        }\\n        return res;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public int sumOfPower(int[] nums) {\\n        long res = 0, s = 0, base = 1000000007;\\n        Arrays.sort(nums);\\n        for (int x: nums) {\\n            res = (res + (s + x) * x % base * x % base) % base;\\n            s = (s * 2 + x) % base;\\n        }\\n        return (int)res;\\n    }\\n}\\n```\n``` Python3 []\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        ans, t, base = 0, 0, 10**9 + 7\\n        for c in sorted(nums):\\n            ans = (ans + (t + c) * c * c) % base\\n            t = (2 * t + c) % base\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520202,
                "title": "c-java-python3-explanation-and-stepping-through-the-code",
                "content": "\\n# Intuition\\nThe question is asking the sum of product of `max^2` and `min` of all non empty subsequences in the array\\n\\n# Approach\\nWe will start by initializing two variables `pre` and `res` to zero. `pre` will keep track of the minimum elements of all the previous subsequences, and `res` will be the final answer.\\n\\nFor each element in the array, we will calculate the contribution of that element to the final answer. The contribution will be the sum of two parts:\\n\\n- The first part is the product of the square of the maximum element and the minimum element when the current element is the only element in the subsequence. \\n- The second part is the sum of the product of the square of the maximum element and the minimum element when the minimum element is one of the elements from the prefix array.\\n\\nTo calculate the first part, we can simply compute `max*max*min` where `max` and `min` are both equal to the current element. \\n\\nTo calculate the second part, we need to use the variable `pre`. We can iterate over all the previous elements and add the product of `max*max` (which is equal to the square of the current element) and the current minimum element. Since the minimum element can be one of the elements from the prefix array, we can multiply this product by the number of times the minimum element appears in the prefix array.\\n\\nAfter calculating the contribution of the current element, we can update `pre` by setting it to `pre*2 + current_element` and add the current contribution to `res`.\\n\\nThis process will continue for each element in the array, and the final value of `res` will be the answer.\\n\\n# Stepping through the code \\nConsider the array `[1, 2, 3, 4, 5, 6]`\\nLet\\'s move over this array iteratively. \\n`pre = res = 0`\\n* For index `0`:\\n    `max = 1, min = 1`\\n    `res += max * max * min = 1` (For the case where this element is the only element in subsequence)\\n    Now add this element to the pre elements:\\n    `pre = pre * 2 + 1 = 1`\\n    Since there are no previous numbers at this point, pre is initially 0.\\n* For index `1`:\\n    `max = 2`, `min` = can be in `(1, 2)`\\n    `res += max * max * min = 1 + 2 * 2 * 2 = 9` (For the case where this element is the only element in subsequence)\\n    `res += max * max * pre = 9 + 2 * 2 * 1 = 13` (For the case where min is one of the numbers in the prefix array)\\n    `pre = pre * 2 + 2 = 2 + 2 = 4`\\n    **The contribution from the previous numbers is doubled because for any next element x we can have the following subsequnces uptil this point:**\\n``` \\n    [1, 2, x] min = 1, max = x\\n    [1, x] min = 1, max = x\\n    [2, x] min = 2, max = x\\n    As you can see 1 occurs twice as min, so its contribution is doubled\\n    pre = 1 + 1 + 2 = 4\\n```\\n* For index `2`:\\n    `max = 3`, `min` = can be in `(1, 2, 3)`\\n    `res += max * max * min = 13 + 3 * 3 * 3 = 40` (For the case where this element is the only element in subsequence)\\n    `res += max * max * pre = 40 + 3 * 3 * 4 = 76` (For the case where min is one of the numbers in the prefix array)\\n    `pre = pre * 2 + 3 = 8 + 3 = 11`\\n    **The contribution from the previous numbers is doubled because for any next element x we can have the following subsequnces uptil this point:** \\n```\\n    [1, 2, 3, x] min = 1, max = x\\n    [1, 2, x] min = 1, max = x\\n    [1, x] min = 1, max = x\\n    [1, 3, x] min = 1, max = x\\n    [2, x] min = 2, max = x\\n    [2, 3, x] min = 2, max = x\\n    [3, x] min = 3, max = x\\n    As you can see 1 occurs four times as min, 2 occurs two times \\n    as min and 3 occurs one time as min. \\n    So the contribution from previous numbers has been doubled.\\n    pre = 1 + 1 + 1 + 1 + 2 + 2 + 3 = 11\\n```\\nThis pattern continues till the end of array\\nIn code \\n`res = (res + x * x * x + x * x * pre) % mod`\\n`x * x * x` means `max * max * min` when x is the only element in subsequence.\\n`x * x * pre` means min is one of the elements from the prefix array\\n\\n# Complexity\\n- Time complexity: `O(nlogn)`\\n\\n- Space complexity: `O(sort)`\\n\\n# Code\\n**Python3**:\\n```\\ndef sumOfPower(self, nums: List[int]) -> int:\\n    mod, pre, res = 10 ** 9 + 7, 0, 0\\n    for x in sorted(nums):\\n        res = (res + x * x * x + x * x * pre) % mod \\n        pre = (pre * 2 + x) % mod\\n    return res\\n```\\n\\n**C++**:\\n```\\nint sumOfPower(vector<int>& nums) {\\n    long long mod = 1e9 + 7, pre = 0, res = 0;\\n    sort(nums.begin(), nums.end());\\n    for (long long x: nums) {\\n        res = (res + (x * x % mod) * x % mod + (x * x % mod) * pre % mod) % mod;\\n        pre = (pre * 2 + x) % mod;\\n    }\\n    return res;\\n}\\n```\\n\\n**Java**:\\n```\\npublic int sumOfPower(int[] nums) {\\n    long mod = (long) 1e9 + 7, pre = 0, res = 0;\\n    Arrays.sort(nums);\\n    for (long x : nums) {\\n        res = (res + (x * x % mod) * x % mod + (x * x % mod) * pre % mod) % mod;\\n        pre = (pre * 2 + x) % mod;\\n    }\\n    return (int) res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "``` \\n    [1, 2, x] min = 1, max = x\\n    [1, x] min = 1, max = x\\n    [2, x] min = 2, max = x\\n    As you can see 1 occurs twice as min, so its contribution is doubled\\n    pre = 1 + 1 + 2 = 4\\n```\n```\\n    [1, 2, 3, x] min = 1, max = x\\n    [1, 2, x] min = 1, max = x\\n    [1, x] min = 1, max = x\\n    [1, 3, x] min = 1, max = x\\n    [2, x] min = 2, max = x\\n    [2, 3, x] min = 2, max = x\\n    [3, x] min = 3, max = x\\n    As you can see 1 occurs four times as min, 2 occurs two times \\n    as min and 3 occurs one time as min. \\n    So the contribution from previous numbers has been doubled.\\n    pre = 1 + 1 + 1 + 1 + 2 + 2 + 3 = 11\\n```\n```\\ndef sumOfPower(self, nums: List[int]) -> int:\\n    mod, pre, res = 10 ** 9 + 7, 0, 0\\n    for x in sorted(nums):\\n        res = (res + x * x * x + x * x * pre) % mod \\n        pre = (pre * 2 + x) % mod\\n    return res\\n```\n```\\nint sumOfPower(vector<int>& nums) {\\n    long long mod = 1e9 + 7, pre = 0, res = 0;\\n    sort(nums.begin(), nums.end());\\n    for (long long x: nums) {\\n        res = (res + (x * x % mod) * x % mod + (x * x % mod) * pre % mod) % mod;\\n        pre = (pre * 2 + x) % mod;\\n    }\\n    return res;\\n}\\n```\n```\\npublic int sumOfPower(int[] nums) {\\n    long mod = (long) 1e9 + 7, pre = 0, res = 0;\\n    Arrays.sort(nums);\\n    for (long x : nums) {\\n        res = (res + (x * x % mod) * x % mod + (x * x % mod) * pre % mod) % mod;\\n        pre = (pre * 2 + x) % mod;\\n    }\\n    return (int) res;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3520260,
                "title": "c-java-python-sorting-fix-2-then-count-time-o-nlogn",
                "content": "# Intuition\\nSince, we only want maximum and minimum, sorting the array might help in find some pattern. So, sort them.\\n\\n---\\n\\nSuppose we take only one element $x_i$ in the group. We have $n$ choices to take only one element. Maximum minimum will be equal and power will be $x_i^2.x_i=x_i^3$.\\n\\n---\\n\\nNow, suppose we take atleast two elements in the group.\\n- Let those two elements be $x_{n - 1}$ and $x_0$. Between them there are $n-2$ indices from which we can take/not take anything but it will not change maximum and minimum of the group as they are already $x_{n-1}$ and $x_0$. We have total $2^{n-2}$ possible groups for which maximum is $x_{n-1}$ and minimum is $x_0$.\\n$sum = 2^{n-2}.x_{n-1}^2.x_0$\\n- Let those two elements be $x_{n-2}$ and $x_0$. Between them there are $n-3$ indices.\\n$sum = 2^{n-3}.x_{n-2}^2.x_0$\\n\\n---\\n\\nIn general, if we take two elements $x_i$ and $x_j$ ($i < j$), then we can take anything between $i$ and $j$ without changing maximum and minimum. There are $j-i-1$ indices between them and $2^{j-i-1}$ possible groups with equal power $x_j^2.x_i$.\\n$sum = 2^{j-i-1}.x_j^2.x_i$\\n\\n---\\n\\nWhen we take only $x_i$, $power = x_i^3$.\\nNow, think of different possiblities where we take $x_i$ and change $x_j$ ($i < j$). For all of them, minimum will not change and it will be $x_i$.\\n\\nSo, total contribution of $x_i$ can be written as\\n$sum = x_i^3 + x_i\\\\left(\\\\displaystyle\\\\sum_{j=i+1}^{n-1} 2^{j-i-1}.x_j^2\\\\right)$\\n\\n---\\n\\nLet $f(i) = \\\\displaystyle\\\\sum_{j=i+1}^{n-1} 2^{j-i-1}.x_j^2$\\n\\n$f(i-1) = \\\\displaystyle\\\\sum_{j=i}^{n-1} 2^{j-i}.x_j^2$\\n\\nPut first term out of $\\\\sum$\\n\\n$f(i-1) = 2^{i-i}.x_i^2 + \\\\displaystyle\\\\sum_{j=i+1}^{n-1} 2^{j-i}.x_j^2$\\n$f(i-1) = x_i^2 + \\\\displaystyle\\\\sum_{j=i+1}^{n-1} 2^{j-i}.x_j^2$\\n$f(i-1) = x_i^2 + \\\\displaystyle\\\\sum_{j=i+1}^{n-1} 2.2^{j-i-1}.x_j^2$\\n$f(i-1) = x_i^2 + 2\\\\displaystyle\\\\sum_{j=i+1}^{n-1} 2^{j-i-1}.x_j^2$\\n$f(i-1) = x_i^2 + 2f(i)$\\n\\nWe will use this recurrence relation to calculate $f(i)$ from $f(i+1)$ in $O(1)$.\\n\\n---\\n\\nTotal contribution of $x_i$ is\\n$sum = x_i^3 + x_i.f(i)$\\n\\nFinal answer is contribution of all $x_i$\\'s.\\n\\n# Example\\n\\n1. Take $nums[n-2]$ as minimum:\\n$sum = sum + nums[n-2]^3 + nums[n-2]\\\\left(2^0.nums[n-1]^2\\\\right)$\\n2. Take $nums[n-3]$ as minimum:\\n$sum = sum + nums[n-3]^3 + nums[n-3]\\\\left(2^1.nums[n-1]^2 + 2^0.nums[n-2]^2\\\\right)$\\n3. Take $nums[n-4]$ as minimum:\\n$sum = sum + nums[n-4]^3 + nums[n-4]\\\\left(2^2.nums[n-1]^2 + 2^1.nums[n-2]^2 + 2^0.nums[n-1]^2\\\\right)$\\n\\nSee the pattern in that factor term in brackets $()$?\\nMultiplying previous term by $2$ and adding $2^0.nums[j]^2$.\\n\\n# Code\\n```C++ []\\nclass Solution {\\nprivate:\\n    int mod = 1e9 + 7;\\n    \\n    int power(int x, int p) {\\n        int res = 1;\\n        while (p--) {\\n            res = (1LL * res * x) % mod;\\n        }\\n        return res;\\n    }\\n    \\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), result = power(nums[n - 1], 3), factor = 0; // factor is f(i)\\n        for (int i = n - 2; i >= 0; i--) {\\n            factor = (2LL * factor + power(nums[i + 1], 2)) % mod; // f(i) = x[i + 1]^2 + 2f(i + 1)\\n            result = (result + power(nums[i], 3) + (1LL * nums[i] * factor) % mod) % mod; // x[i]^3 + x[i].f(i)\\n        }\\n        return result;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    private int mod = (int)1e9 + 7;\\n\\n    private int power(int x, int n) {\\n        long result = 1;\\n        while (n-- != 0) {\\n            result = (result * x) % mod;\\n        }\\n        return (int)result;\\n    }\\n\\n    public int sumOfPower(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long result = power(nums[n - 1], 3), factor = 0; // factor is f(i)\\n        for (int i = n - 2; i >= 0; i--) {\\n            factor = (2 * factor + power(nums[i + 1], 2)) % mod; // f(i) = x[i + 1]^2 + 2f(i + 1)\\n            result = (result + power(nums[i], 3) + (nums[i] * factor) % mod) % mod; // x[i]^3 + x[i].f(i)\\n        }\\n        return (int)result;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def power(self, x: int, n: int) -> int:\\n        result = 1\\n        for _ in range(n):\\n            result = (result * x) % self.mod\\n        return result\\n    \\n    def sumOfPower(self, nums: List[int]) -> int:\\n        self.mod = 10 ** 9 + 7\\n        nums.sort()\\n        result, factor = self.power(nums[-1], 3), 0 # factor is f(i)\\n        for i in range(len(nums) - 2, -1, -1):\\n            factor = (2 * factor + self.power(nums[i + 1], 2)) % self.mod # f(i) = x[i + 1]^2 + 2f(i + 1)\\n            result = (result + self.power(nums[i], 3) + (nums[i] * factor) % self.mod) % self.mod # x[i]^3 + x[i].f(i)\\n        return result\\n```\\n\\n# Complexity\\nSorting time and space complexity is the only dominant being $O(n \\\\log n)$ and $O(\\\\log n)$. Rest is linear time and constant space.\\n- Time complexity: $$O(n \\\\log n)$$\\n- Space complexity: $$O(\\\\log n)$$",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Math",
                    "Sorting"
                ],
                "code": "```C++ []\\nclass Solution {\\nprivate:\\n    int mod = 1e9 + 7;\\n    \\n    int power(int x, int p) {\\n        int res = 1;\\n        while (p--) {\\n            res = (1LL * res * x) % mod;\\n        }\\n        return res;\\n    }\\n    \\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), result = power(nums[n - 1], 3), factor = 0; // factor is f(i)\\n        for (int i = n - 2; i >= 0; i--) {\\n            factor = (2LL * factor + power(nums[i + 1], 2)) % mod; // f(i) = x[i + 1]^2 + 2f(i + 1)\\n            result = (result + power(nums[i], 3) + (1LL * nums[i] * factor) % mod) % mod; // x[i]^3 + x[i].f(i)\\n        }\\n        return result;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    private int mod = (int)1e9 + 7;\\n\\n    private int power(int x, int n) {\\n        long result = 1;\\n        while (n-- != 0) {\\n            result = (result * x) % mod;\\n        }\\n        return (int)result;\\n    }\\n\\n    public int sumOfPower(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long result = power(nums[n - 1], 3), factor = 0; // factor is f(i)\\n        for (int i = n - 2; i >= 0; i--) {\\n            factor = (2 * factor + power(nums[i + 1], 2)) % mod; // f(i) = x[i + 1]^2 + 2f(i + 1)\\n            result = (result + power(nums[i], 3) + (nums[i] * factor) % mod) % mod; // x[i]^3 + x[i].f(i)\\n        }\\n        return (int)result;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def power(self, x: int, n: int) -> int:\\n        result = 1\\n        for _ in range(n):\\n            result = (result * x) % self.mod\\n        return result\\n    \\n    def sumOfPower(self, nums: List[int]) -> int:\\n        self.mod = 10 ** 9 + 7\\n        nums.sort()\\n        result, factor = self.power(nums[-1], 3), 0 # factor is f(i)\\n        for i in range(len(nums) - 2, -1, -1):\\n            factor = (2 * factor + self.power(nums[i + 1], 2)) % self.mod # f(i) = x[i + 1]^2 + 2f(i + 1)\\n            result = (result + self.power(nums[i], 3) + (nums[i] * factor) % self.mod) % self.mod # x[i]^3 + x[i].f(i)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520506,
                "title": "c-sorting-easy-intuition",
                "content": "\\nHow i approached the problem:\\n\\nSort the array, now we have an array = [a,b,c,d,e] (a < b < c < d < e)\\n\\nHow many groups will we have such that `e` will be the maximum element `pow(2,index of e)` which is 16, power sum of these groups will be\\n`(e*e) * (min of g1 + min of g2 + .... + min of g16) .... equation (#1)`\\n   \\nif we write down all 16 groups having e as maximum we see a pattern for minimum of groups\\nedcba, edcb, edca, edba, ecba, edc, edb, eda, ecb, eca, eba, ed, ec, eb, ea, e\\n\\nnotice for 16 groups\\n\\ne is minimum in 1 group\\nd is minimum in 1 group\\nc is minimum in 2 group\\nb is minimum in 4 group\\na is minimum in 8 group\\n   \\nso equation #1 becomes `(e*e) * (e+d+2c+4b+8a);`\\nsimilarly for d it will be `(d*d) * (d+c+2b+4a);`\\n   \\nnow we have an O(n*n) approach to find the solution how to optimize it to O(n)\\n   \\nif we see the equation for all element,\\n   \\n```\\n   a => (a*a) * (a)\\n   b => (b*b) * (b+a)\\n   c => (c*c) * (c+b+2a)\\n   d => (d*d) * (d+c+2b+4a)\\n   e => (e*e) * (e+d+2c+4b+8a)\\n```\\n\\n   see that the minimum part of each element at index i is (minimum of previous i)*2 - nums[i-1] + nums[i]\\n   \\n \\xA0 mimimum while calculating power of groups having a as maximum = `a => a`\\n \\xA0 mimimum while calculating power of groups having b as maximum = `(2*a)-a+b => a+b`\\n \\xA0 mimimum while calculatin power of groups having c as maximum = `(2*((2*a)-a+b))-b+c => 2a+b+c`\\n   and so on...\\n   \\n   so we maintain a minimum m = nums[0];\\n   \\n   for each iteration we cange m as (2*m)-nums[i-1]+nums[i] and calculate power as \\n   p = (nums[i]*nums[i])*m and add it to our result\\n\\n```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int mod = 1e9+7;\\n        long long res = (((1LL*nums[0]*nums[0])%mod)*nums[0])%mod, m = nums[0];\\n        for(int i=1; i<nums.size(); ++i){\\n            m = ((m*2)%mod)-nums[i-1]+nums[i];\\n            res = (res + (((1LL*nums[i]*nums[i])%mod)*m)%mod)%mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n   a => (a*a) * (a)\\n   b => (b*b) * (b+a)\\n   c => (c*c) * (c+b+2a)\\n   d => (d*d) * (d+c+2b+4a)\\n   e => (e*e) * (e+d+2c+4b+8a)\\n```\n```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int mod = 1e9+7;\\n        long long res = (((1LL*nums[0]*nums[0])%mod)*nums[0])%mod, m = nums[0];\\n        for(int i=1; i<nums.size(); ++i){\\n            m = ((m*2)%mod)-nums[i-1]+nums[i];\\n            res = (res + (((1LL*nums[i]*nums[i])%mod)*m)%mod)%mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520417,
                "title": "try-with-smaller-inputs-there-is-a-pattern",
                "content": "Sort the numbers in increasing order.\\n- n = 1, nums = [a],\\nans = [$$a^3$$]\\n- n = 2, nums = [a, b],\\nans = [$$a^3 + b^3 + b^2.a$$]\\n- n = 3, nums = [a, b, c],\\nans = [$$a^3 + b^3 + c^3 + c^2.(b + 2a) + b^2.a$$]\\n- n = 4, nums = [a, b, c, d],\\nans = [$$a^3 + b^3 + c^3 + d^3 \\n  +d^2.(c + 2b + 4a) + c^2.(b + 2a) + b^2.a$$]\\n\\nDo you see a pattern? :)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int kMod = 1e9+7;\\n    long long pw(long long a, long p) {\\n        long long r = 1;\\n        while (p--)\\n            r = (r * a) % kMod;\\n        return r;\\n    }\\n    \\n    int sumOfPower(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        long long prev = 0, ans  = 0;\\n        for (int num : nums) {\\n            ans = (ans + (long long)pw(num, 3)) % kMod;\\n            ans = (ans + ((long long)pw(num, 2) * prev) % kMod) % kMod;\\n            prev = (prev * 2 + num) % kMod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int kMod = 1e9+7;\\n    long long pw(long long a, long p) {\\n        long long r = 1;\\n        while (p--)\\n            r = (r * a) % kMod;\\n        return r;\\n    }\\n    \\n    int sumOfPower(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        long long prev = 0, ans  = 0;\\n        for (int num : nums) {\\n            ans = (ans + (long long)pw(num, 3)) % kMod;\\n            ans = (ans + ((long long)pw(num, 2) * prev) % kMod) % kMod;\\n            prev = (prev * 2 + num) % kMod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520334,
                "title": "quadratic-to-o-sort",
                "content": "It\\'s easier to first come up with a quadratic solution, and then optimize it.\\n\\nWe sort the numbers, and pick two indexes `i` and `j`, such as `i < j`.\\n\\nFor this pair of indexes, `nums[i]` is the minimum, `nums[j]` is the maximum for `2 ^ (j - i - 1)` groups.\\n\\nSo, power of all subgroups is `nums[i] * nums[j] * nums[j] * (2 ^ (j - i - 1))`.\\n\\n> Note that for the special case when `i ==j`, the power is `nums[i] * nums[i] * nums[i]`.\\n\\nI suggest checking the quadratic solution (second solution below) first to build an intuition.\\n\\n## O(sort)\\nTake a look at the quadratic solution below. Once you understand it, it\\'s easier to come up with a formula to compute sum in a linear time.\\n\\n**C++**\\n```cpp\\nint sumOfPower(vector<int>& nums) {\\n    long long res = 0, sum = 0, mod = 1000000007;\\n    sort(begin(nums), end(nums));\\n    for (int i = 0; i < nums.size(); ++i) {\\n        res = (res + (sum + nums[i]) * nums[i] % mod * nums[i]) % mod;\\n        sum = (sum * 2 + nums[i]) % mod;\\n    }\\n    return res;\\n}\\n```\\n\\n## Quadratic (TLE)\\nThe purpose of this solution is to build an intuition.\\n**C++**\\n```cpp\\nint sumOfPower(vector<int>& nums) {\\n    long long res = 0, sum = 0, mod = 1000000007;\\n    sort(begin(nums), end(nums));\\n    for (int i = 0; i < nums.size(); ++i) {\\n        res = (res + (long long) nums[i] * nums[i] % mod * nums[i]) % mod;\\n        for (int j = i + 1, groups = 1; j < nums.size(); ++j) {\\n            res = (res + (long long)nums[i] * nums[j] % mod * nums[j] % mod * groups) % mod;\\n            groups = groups * 2 % mod;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint sumOfPower(vector<int>& nums) {\\n    long long res = 0, sum = 0, mod = 1000000007;\\n    sort(begin(nums), end(nums));\\n    for (int i = 0; i < nums.size(); ++i) {\\n        res = (res + (sum + nums[i]) * nums[i] % mod * nums[i]) % mod;\\n        sum = (sum * 2 + nums[i]) % mod;\\n    }\\n    return res;\\n}\\n```\n```cpp\\nint sumOfPower(vector<int>& nums) {\\n    long long res = 0, sum = 0, mod = 1000000007;\\n    sort(begin(nums), end(nums));\\n    for (int i = 0; i < nums.size(); ++i) {\\n        res = (res + (long long) nums[i] * nums[i] % mod * nums[i]) % mod;\\n        for (int j = i + 1, groups = 1; j < nums.size(); ++j) {\\n            res = (res + (long long)nums[i] * nums[j] % mod * nums[j] % mod * groups) % mod;\\n            groups = groups * 2 % mod;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3522650,
                "title": "sort-math-explained",
                "content": "```py\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        M = 10 ** 9 + 7\\n        # sort the input so that we can easily find the min and max\\n        # besides, sorting won\\'t affect the result since original position doesn\\'t matter\\n        nums.sort()\\n        res, s = 0, 0\\n        for x in nums:\\n            # if we just include one element [x], \\n            # it is easy to see it contributes x * x * x\\n            # if we include a pair [x, y] where x < y, \\n            # it contributes x * y * y \\n            # if we include some numbers between x and y, i.e. [x, a, b, c, y] where x < a, b, c < y\\n            # the power is also x * y * y \\n            # the number of subsets will be 2 ^ (j - i + 1)\\n            # e.g. [x, a, y], [x, a, b, y], [x, a, b, c, y], [x, b, y], [x, b, c] ...\\n            # hence, for each pair, the power will be x * y * y * 2 ^ (j - i + 1)\\n            # combining above two cases, for the index j, we got\\n            # (nums[j] * nums[j] * nums[j]) + (nums[j] * nums[j]) * \\\\sum_{i = 0} ^ {j - 1} (nums[j] * 2 ^ (j - i + 1))\\n            # so how to calculate \\\\sum_{i = 0} ^ {j - 1} (nums[j] * 2 ^ (j - i + 1)) in a linear time?\\n            # let F(i) = \\\\sum_{i = 0} ^ {j - 1} (nums[j] * 2 ^ (j - i + 1))\\n            # rewrite the above formula, then we will see that F(i + 1) would be 2 * F(i) + nums[i]\\n\\t\\t\\t# if you have no idea on above mathematic explanation, \\n\\t\\t\\t# try some cases and you will see the pattern\\n\\t\\t\\t# nums = [1, 2, 3, 4]\\n\\t\\t\\t# 1 * 1 * ((0) + 1)\\n\\t\\t\\t# 2 * 2 * ((1) * 2 ^ 0 + 2)\\n\\t\\t\\t# 3 * 3 * ((1 * 2 ^ 1 + 2) * 2 ^ 0 + 3)\\n\\t\\t\\t# 4 * 4 * ((1 * 2 ^ 2 + 2 * 2 ^ 1 + 3) * 2 ^ 0 + 4)\\n\\t\\t\\t# ...\\n\\t\\t\\t# x * x * (prev_s * 2 + x)\\n            res += (x + s) * (x * x) \\n            res %= M\\n            s = (s * 2 + x) % M\\n        return res\\n```\\n\\n**p.s. Join us on the LeetCode The Hard Way Discord Study Group for timely discussion! Link in bio.**",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Sorting"
                ],
                "code": "```py\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        M = 10 ** 9 + 7\\n        # sort the input so that we can easily find the min and max\\n        # besides, sorting won\\'t affect the result since original position doesn\\'t matter\\n        nums.sort()\\n        res, s = 0, 0\\n        for x in nums:\\n            # if we just include one element [x], \\n            # it is easy to see it contributes x * x * x\\n            # if we include a pair [x, y] where x < y, \\n            # it contributes x * y * y \\n            # if we include some numbers between x and y, i.e. [x, a, b, c, y] where x < a, b, c < y\\n            # the power is also x * y * y \\n            # the number of subsets will be 2 ^ (j - i + 1)\\n            # e.g. [x, a, y], [x, a, b, y], [x, a, b, c, y], [x, b, y], [x, b, c] ...\\n            # hence, for each pair, the power will be x * y * y * 2 ^ (j - i + 1)\\n            # combining above two cases, for the index j, we got\\n            # (nums[j] * nums[j] * nums[j]) + (nums[j] * nums[j]) * \\\\sum_{i = 0} ^ {j - 1} (nums[j] * 2 ^ (j - i + 1))\\n            # so how to calculate \\\\sum_{i = 0} ^ {j - 1} (nums[j] * 2 ^ (j - i + 1)) in a linear time?\\n            # let F(i) = \\\\sum_{i = 0} ^ {j - 1} (nums[j] * 2 ^ (j - i + 1))\\n            # rewrite the above formula, then we will see that F(i + 1) would be 2 * F(i) + nums[i]\\n\\t\\t\\t# if you have no idea on above mathematic explanation, \\n\\t\\t\\t# try some cases and you will see the pattern\\n\\t\\t\\t# nums = [1, 2, 3, 4]\\n\\t\\t\\t# 1 * 1 * ((0) + 1)\\n\\t\\t\\t# 2 * 2 * ((1) * 2 ^ 0 + 2)\\n\\t\\t\\t# 3 * 3 * ((1 * 2 ^ 1 + 2) * 2 ^ 0 + 3)\\n\\t\\t\\t# 4 * 4 * ((1 * 2 ^ 2 + 2 * 2 ^ 1 + 3) * 2 ^ 0 + 4)\\n\\t\\t\\t# ...\\n\\t\\t\\t# x * x * (prev_s * 2 + x)\\n            res += (x + s) * (x * x) \\n            res %= M\\n            s = (s * 2 + x) % M\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520241,
                "title": "o-nlogn-in-c-java-python3",
                "content": "# Intuition\\nJust sort\\n\\n# Approach\\nJust sort\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\nC++\\n```\\nclass Solution {\\n    const int M = 1000000007;\\n    int mul(long long x, long long y) {\\n        return x * y % M;\\n    }\\n    \\n    int add(int x, int y) {\\n        if ((x += y) >= M) {\\n            x -= M;\\n        }\\n        return x; \\n    }\\n\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        const int n = nums.size();\\n        int r = mul(mul(nums[0], nums[0]), nums[0]);\\n        for (int i = 1, last = 0; i < n; ++i) {\\n            last = add(nums[i - 1], add(last, last));\\n            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));\\n        }\\n        \\n        return r;\\n    }\\n};\\n```\\n\\n\\nJava\\n```\\n\\nclass Solution {\\n    private final int M = 1000000007;\\n    private int mul(long x, long y) {\\n        return (int) (x * y % M);\\n    }\\n\\n    private int add(int x, int y) {\\n        if ((x += y) >= M) {\\n            x -= M;\\n        }\\n        return x; \\n    }\\n\\n    public int sumOfPower(int[] nums) {\\n        Arrays.sort(nums);\\n        final int n = nums.length;\\n        int r = mul(mul(nums[0], nums[0]), nums[0]);\\n        for (int i = 1, last = 0; i < n; ++i) {\\n            last = add(nums[i - 1], add(last, last));\\n            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));\\n        }\\n\\n        return r;\\n    }\\n}\\n\\n```\\n\\nPython3\\n\\n```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        M = 1000000007\\n        def mul(x: int, y: int) -> int:\\n            return x * y % M\\n        \\n        def add(x: int, y: int) -> int:\\n            x += y\\n            if x >= M:\\n                x -= M\\n            return x; \\n        nums.sort()\\n        n = len(nums)\\n        r = mul(mul(nums[0], nums[0]), nums[0])\\n        last = 0\\n        for i in range(1, n):\\n            last = add(nums[i - 1], add(last, last));\\n            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));\\n        return r;\\n\\n        \\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    const int M = 1000000007;\\n    int mul(long long x, long long y) {\\n        return x * y % M;\\n    }\\n    \\n    int add(int x, int y) {\\n        if ((x += y) >= M) {\\n            x -= M;\\n        }\\n        return x; \\n    }\\n\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        const int n = nums.size();\\n        int r = mul(mul(nums[0], nums[0]), nums[0]);\\n        for (int i = 1, last = 0; i < n; ++i) {\\n            last = add(nums[i - 1], add(last, last));\\n            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));\\n        }\\n        \\n        return r;\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\n    private final int M = 1000000007;\\n    private int mul(long x, long y) {\\n        return (int) (x * y % M);\\n    }\\n\\n    private int add(int x, int y) {\\n        if ((x += y) >= M) {\\n            x -= M;\\n        }\\n        return x; \\n    }\\n\\n    public int sumOfPower(int[] nums) {\\n        Arrays.sort(nums);\\n        final int n = nums.length;\\n        int r = mul(mul(nums[0], nums[0]), nums[0]);\\n        for (int i = 1, last = 0; i < n; ++i) {\\n            last = add(nums[i - 1], add(last, last));\\n            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));\\n        }\\n\\n        return r;\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        M = 1000000007\\n        def mul(x: int, y: int) -> int:\\n            return x * y % M\\n        \\n        def add(x: int, y: int) -> int:\\n            x += y\\n            if x >= M:\\n                x -= M\\n            return x; \\n        nums.sort()\\n        n = len(nums)\\n        r = mul(mul(nums[0], nums[0]), nums[0])\\n        last = 0\\n        for i in range(1, n):\\n            last = add(nums[i - 1], add(last, last));\\n            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));\\n        return r;\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520220,
                "title": "c-sorting-subsequence-explanation-included",
                "content": "We need to consider all subsequence so we will divide the problem in 2 parts :-\\na) Consider the subsequence of length 1.\\n* This Subsequence will dedicate the value of nums[i]]^3 to the answer.\\n```\\n\\t\\tfor(int i=0;i<n;i++){\\n            \\n            ll tmp = ((((long long)nums[i]*(long long)nums[i])%mod)*(long long)nums[i])%mod;\\n            ans = (ans+tmp)%mod;\\n            \\n        }\\n```\\n\\nb) Now we have to consider subsequences with length greater than 1.\\n\\n* Lets take nums = [5,2,4,6,8].\\n* First sort the array and the modified nums array will become -> [2,4,5,6,8].\\n* Now suppose we consider max element in the subsequence as 6, so the elements that can come in that subsequence as 2,4,5.\\n* Lets take min ele as 5 then number of subsequence containing min as 5 and max as 6 is 1.\\n* Simmilarly subsequence having min 4 and max 6 is 2.\\n* Subsequence having min 2 and max 6 is 4.\\n* So the ans that will be dedicated while considering max as 6 is `6*6*(5*2^0+4*2^1+2*2^2)`\\n* Take curr = `5*2^0+4*2^1+2*2^2` \\n* Simmilarily when we consider max as 8 ans will be increased by `8*8*(6*2^0+5*2^1+4*2^2+2*2^3) = 8*8*(6*2^0+2*curr). `\\n\\nFull code :- \\n\\n```\\n#define ll long long \\nclass Solution {\\n    ll mod = 1e9+7;\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        ll ans = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            ll tmp = ((((long long)nums[i]*(long long)nums[i])%mod)*(long long)nums[i])%mod;\\n            ans = (ans+tmp)%mod;\\n            \\n        }\\n        \\n        ll curr = 0;\\n        sort(begin(nums),end(nums));\\n        for(int i=1;i<n;i++){\\n            \\n            ll v = ((long long)nums[i]*(long long)nums[i])%mod;\\n            curr = (curr*2LL+nums[i-1])%mod;\\n            \\n            ans = (ans+(v*curr)%mod)%mod;\\n            //cout<<ans<<endl;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nKindly upvote if you found this useful.\\n\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n\\t\\tfor(int i=0;i<n;i++){\\n            \\n            ll tmp = ((((long long)nums[i]*(long long)nums[i])%mod)*(long long)nums[i])%mod;\\n            ans = (ans+tmp)%mod;\\n            \\n        }\\n```\n```\\n#define ll long long \\nclass Solution {\\n    ll mod = 1e9+7;\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        ll ans = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            ll tmp = ((((long long)nums[i]*(long long)nums[i])%mod)*(long long)nums[i])%mod;\\n            ans = (ans+tmp)%mod;\\n            \\n        }\\n        \\n        ll curr = 0;\\n        sort(begin(nums),end(nums));\\n        for(int i=1;i<n;i++){\\n            \\n            ll v = ((long long)nums[i]*(long long)nums[i])%mod;\\n            curr = (curr*2LL+nums[i-1])%mod;\\n            \\n            ans = (ans+(v*curr)%mod)%mod;\\n            //cout<<ans<<endl;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3677048,
                "title": "easy-approach-6-lines-well-explained-prefix-sum-java-c-python",
                "content": "# Intuition \\uD83D\\uDCA1 \\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo find the sum of the powers of all non-empty groups of heroes, we can sort the array `nums` in ascending order. Then, for each number `x` in `nums`, we calculate its contribution to the sum by multiplying `x^2` with `x` and adding it to the previous sum of contributions.\\n\\n# Approach \\uD83D\\uDD0D \\nHere is the step-by-step approach to solve the problem:\\n\\n1. Sort the array `nums` in ascending order.\\n2. Initialize variables `mod`, `pre`, and `res` to handle the modular arithmetic and store the sum of contributions.\\n3. Iterate over each number `x` in `nums`.\\n4. Update `res` by adding the contribution of `x` to the sum: `(x * x % mod) * x % mod + (x * x % mod) * pre % mod`.\\n5. Update `pre` by multiplying it by 2 and adding `x` modulo `mod`.\\n6. Return the final result `res` as an integer.\\n\\n\\n# Complexity\\n- Time complexity:$$O(n log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n log n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n> Feel free to ask your doubts in the comment section \\n\\n# Code\\n```java []\\nclass Solution {\\n    public int sumOfPower(int[] nums) {\\n        long mod = (long) 1e9 + 7, pre = 0, res = 0;\\n        Arrays.sort(nums);\\n        for (long x : nums) {\\n            res = (res + (x * x % mod) * x % mod + (x * x % mod) * pre % mod) % mod;\\n            pre = (pre * 2 + x) % mod;\\n        }\\n        return (int) res;\\n    }\\n}\\n```\\n```C++ []\\nint sumOfPower(vector<int>& nums) {\\n    long long mod = 1e9 + 7, pre = 0, res = 0;\\n    sort(nums.begin(), nums.end());\\n    for (long long x: nums) {\\n        res = (res + (x * x % mod) * x % mod + (x * x % mod) * pre % mod) % mod;\\n        pre = (pre * 2 + x) % mod;\\n    }\\n    return res;\\n}\\n```\\n```Python []\\ndef sumOfPower(self, nums: List[int]) -> int:\\n    mod, pre, res = 10 ** 9 + 7, 0, 0\\n    for x in sorted(nums):\\n        res = (res + x * x * x + x * x * pre) % mod \\n        pre = (pre * 2 + x) % mod\\n    return res\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```java []\\nclass Solution {\\n    public int sumOfPower(int[] nums) {\\n        long mod = (long) 1e9 + 7, pre = 0, res = 0;\\n        Arrays.sort(nums);\\n        for (long x : nums) {\\n            res = (res + (x * x % mod) * x % mod + (x * x % mod) * pre % mod) % mod;\\n            pre = (pre * 2 + x) % mod;\\n        }\\n        return (int) res;\\n    }\\n}\\n```\n```C++ []\\nint sumOfPower(vector<int>& nums) {\\n    long long mod = 1e9 + 7, pre = 0, res = 0;\\n    sort(nums.begin(), nums.end());\\n    for (long long x: nums) {\\n        res = (res + (x * x % mod) * x % mod + (x * x % mod) * pre % mod) % mod;\\n        pre = (pre * 2 + x) % mod;\\n    }\\n    return res;\\n}\\n```\n```Python []\\ndef sumOfPower(self, nums: List[int]) -> int:\\n    mod, pre, res = 10 ** 9 + 7, 0, 0\\n    for x in sorted(nums):\\n        res = (res + x * x * x + x * x * pre) % mod \\n        pre = (pre * 2 + x) % mod\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521447,
                "title": "java-o-nlogn-1-loop",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the array by ascending order:\\n{a, b, c, d};\\nCase a-d;\\nFor subgroups with min as a, and max as c, there are actually\\n2 ** 2 = 4 combinations, which is count of all subsets of {b, c};\\n{}, {b}, {b, c}, {c} plus {a, d};\\n\\nthen for all cases when subgroup of max at d, \\nyou can add up:\\ncase a-d, case b-d, case c-d;\\neasy right?\\n\\nHow about if you go to the fifth number, f?\\n{a, b, c, d, f};\\ntake example of case a-f:\\njust count num of subsets {b, c, d}, which is 2 times of the count of subsets of {b, c}. 8 = 4 * 2;\\nfor counts:\\na-f = 2 * a-d\\nb-f = 2 * b-d\\nc-f = 2 * c-d\\n\\nPreSum = Sum for each minNum * counts, where we don\\'t multiple maxNum^2 yet.\\n\\npreSum(f) = a * cnt(a-f) + b * cnt(b-f) + ...\\n= 2 * (a * cnt(a-d) + b * cnt(b-d) + ... ) + f\\n= preSum(d) * 2 + f\\n\\nThat is how preSum is caculated.\\n\\nThen we just use preSum(f) * maxNum^2, where maxNum = f, to get all results for subgroups with maxnum at f. Then add them up.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NLogN)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) if you don\\'t count the space of original array.\\n# Code\\n```\\npublic int sumOfPower(int[] nums) {\\n    int n = nums.length;\\n    if (n == 0) return 0;\\n    Arrays.sort(nums);\\n    long preSum = 0, res = 0, mod = 1_000_000_000 + 7, add = 0;\\n    for (int i = 0; i < nums.length; i++) {\\n        add = (preSum + nums[i]) * nums[i] % mod * nums[i] % mod;\\n        res = (res + add) % mod;\\n        preSum = (preSum * 2 + nums[i]) % mod;\\n    }\\n    return (int) res;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int sumOfPower(int[] nums) {\\n    int n = nums.length;\\n    if (n == 0) return 0;\\n    Arrays.sort(nums);\\n    long preSum = 0, res = 0, mod = 1_000_000_000 + 7, add = 0;\\n    for (int i = 0; i < nums.length; i++) {\\n        add = (preSum + nums[i]) * nums[i] % mod * nums[i] % mod;\\n        res = (res + add) % mod;\\n        preSum = (preSum * 2 + nums[i]) % mod;\\n    }\\n    return (int) res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520215,
                "title": "greedy-cpp-easy-greedy-solution-with-detailed-explanation-o-n-log-n",
                "content": "# if you like the solution, please give me a up vote.\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nthe power of this group is \\n`max(nums[i0],..,nums[ik])^2 * min(nums[i0],..,nums[ik])`\\nso after we sort the nums from small to large,\\nfor any subsequence `(A0, A1, A2,...An)` score is `An * An * A0`.\\n\\nthe next question is how can we quickly find the subsequence with nums[i].\\n\\n\\nwe can use the example 1 to find the formula.\\n`nums = [2,1,4]`\\n\\nafter we score the nums,\\n`nums = [1, 2, 4]`\\nchoose `nums[0]` as maximum value, the subsequence and score is\\n`[1] => 1 * 1 * 1` \\nthe formula is `nums[0] * nums[0] * nums[0]`\\n\\n\\nchoose `nums[1]` as maximum value, the subsequence and score is\\n`[2] => 2 * 2 * 2`\\n`[1, 2] => 2 * 2 * 1`\\nthe formula is `nums[1] * nums[1] * (nums[1] * nums[0])`\\n\\nchoose `nums[2]` as maximum value,  the subsequence and score is\\n`[4] => 4 * 4 * 4`\\n`[2, 4] => 4 * 4 * 2`\\n`[1, 4] => 4 * 4 * 1`\\n`[1, 2, 4] => 4 * 4 * 1`\\nthe formula is `nums[2] * nums[2] * (nums[2] + nums[1] * (2 * nums[0]))` \\n\\n\\nif we add nums[3]\\nthe formula is `nums[3] * nums[3] * (nums[3] + nums[2] * (2 * nums[1] * (4 * nums[0])))` \\n\\nBy observation, we can derive the following equation.\\n\\n> Define\\n> cur position is `nums[i]`\\n> last is `nums[i-1]`\\n> last2 is `nums[0~i-2]`\\nfor each val in nums, the score is \\n`nums[i] * nums[i] * (nums[i] + last + 2 * last2)`\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    const int mod = 1e9 + 7;\\n    int sumOfPower(vector<int>& nums) {\\n        int n = nums.size();\\n        ll last2 = 0;\\n        ll last = 0;\\n        ll output = 0;\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0 ; i < n; i++) {\\n            ll val = nums[i];\\n            ll v1 = (val * val) % mod;\\n            ll v2 = (last + last2 + val) % mod;\\n            output = (output + ((v1 * v2) % mod)) % mod;\\n        \\n            last2 = (((last2 + last) % mod) * 2) % mod;\\n            last = nums[i];\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    const int mod = 1e9 + 7;\\n    int sumOfPower(vector<int>& nums) {\\n        int n = nums.size();\\n        ll last2 = 0;\\n        ll last = 0;\\n        ll output = 0;\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0 ; i < n; i++) {\\n            ll val = nums[i];\\n            ll v1 = (val * val) % mod;\\n            ll v2 = (last + last2 + val) % mod;\\n            output = (output + ((v1 * v2) % mod)) % mod;\\n        \\n            last2 = (((last2 + last) % mod) * 2) % mod;\\n            last = nums[i];\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531783,
                "title": "python-3-8-lines-w-example-t-m-810-ms-26-5-mb",
                "content": "```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n                                                    #  Ex: nums = [6,1,3]\\n        MOD = 1_000_000_007\\n        ans = sum(pow(num,3,MOD)for num in nums)    #  ans = 1**3 + 3**3 + 6**3 = 244\\n        nums.sort()                                 # nums = [1,3,6]\\n\\n        pref = list(accumulate(nums, lambda x,y:    # pref = [0, 1, 5, 16]\\n                       (2*x+y)%MOD, initial = 0))\\n                                                    #  n    p   ans\\n        for n, p in zip(nums, pref):                # ---  ---  ---\\n            ans+= n*n * p                           #           244\\n            ans%= MOD                               #  1    0   244\\n                                                    #  3    1   253\\n        return ans                                  #  6    5   433 <-- return\\n```\\n\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*log*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n                                                    #  Ex: nums = [6,1,3]\\n        MOD = 1_000_000_007\\n        ans = sum(pow(num,3,MOD)for num in nums)    #  ans = 1**3 + 3**3 + 6**3 = 244\\n        nums.sort()                                 # nums = [1,3,6]\\n\\n        pref = list(accumulate(nums, lambda x,y:    # pref = [0, 1, 5, 16]\\n                       (2*x+y)%MOD, initial = 0))\\n                                                    #  n    p   ans\\n        for n, p in zip(nums, pref):                # ---  ---  ---\\n            ans+= n*n * p                           #           244\\n            ans%= MOD                               #  1    0   244\\n                                                    #  3    1   253\\n        return ans                                  #  6    5   433 <-- return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529909,
                "title": "beats-100-java-c-python-deeply-explained",
                "content": "> \\u26A0\\uFE0F **Disclaimer**: The original solution was crafted in Java. Thus, when we mention \"Beats 100%\" it applies specifically to Java submissions. The performance may vary for other languages.\\n\\n# TL;DR\\n``` java []\\nclass Solution {\\n    public int sumOfPower(int[] nums) {\\n        int prev = 0, sum = 0, mod = (int) 1e9 + 7;\\n        Arrays.sort(nums);\\n        for (int n : nums) {\\n            sum = (int) (((((long) n * n) % mod) * ((prev + n) % mod) + sum) % mod);\\n            prev = ((prev * 2) % mod + n) % mod;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n``` cpp []\\nclass Solution {\\npublic:\\n    int sumOfPower(std::vector<int>& nums) {\\n        int prev = 0, sum = 0, mod = 1e9 + 7;\\n        std::sort(nums.begin(), nums.end());\\n        for (int n : nums) {\\n            sum = (int) (((((long long) n * n) % mod) * ((prev + n) % mod) + sum) % mod);\\n            prev = ((prev * 2) % mod + n) % mod;\\n        }\\n        return sum;\\n    }\\n};\\n```\\n``` python []\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        prev, sum, mod = 0, 0, int(1e9 + 7)\\n        nums.sort()\\n        for n in nums:\\n            sum = (((n * n) % mod) * ((prev + n) % mod) + sum) % mod\\n            prev = ((prev * 2) % mod + n) % mod\\n        return sum\\n\\n```\\n\\n---\\n## \\u26A0\\uFE0F Don\\'t forget to upvote if you like this solution. \\uD83D\\uDE43\\n---\\n\\n# Approach\\n\\nThe key observation here is to understand how the power of groups is calculated, and how we can efficiently compute the total power of all groups. \\n\\nIf we sort the array in ascending order, we can see that for each number `n` in the array, it will be the maximum number in all groups formed by `n` and any combination of numbers before `n` in the array. \\n\\nWe can see from the given examples, for an array `[2, 1, 4]`, the possible groups and their corresponding powers are:\\n```\\n[1]:    1^2 * 1 = 8\\n[2]:    2^2 * 2 = 64\\n[4]:    4^2 * 4 = 4\\n[1,2]:  2^2 * 1 = 16\\n[1,4]:  4^2 * 1 = 32\\n[2, 4]: 4^2 * 2 = 16\\n[1,2,4]:4^2 * 1 = 128\\n\\nTotal power: 8 + 64 + 4 + 16 + 32 + 16 + 128 = 141\\n```\\n\\nBut we also can do it in another way. For each number `n` in the array, let\\'s consider the groups where `n` is the maximum:\\n```\\nn = 1: \\n    groups: [1]\\n    power: 1^2 * 1 = 1\\n\\nn = 2: \\n    groups: [2,1],[2]\\n    power: 2^2 * 1 + 2^2 * 2 = 2^2 * (1 + 2) = 12\\n\\nn = 4: \\n    groups: [4,1],[4,2,1],[4,2],[4]\\n    power: 4^2 * 1 + 4^2 * 1 + 4^2 * 2 + 4^2 * 4 \\n        = 4^2 * (1 + 1 + 2 + 4) = 128.\\n\\nTotal power: 1 + 12 + 128 = 141\\n```\\n\\nLet `prev` be the sum of all minimum numbers from all groups before `n`. Then, the power of the groups with `n` as the maximum element is given by `n^2 * (prev + n)`. This is because when we include `n` in the groups, they become all the previous groups with `n` as the maximum number, plus an additional group with `n` as a single element. Thus, for each `n` we need to multiply each min number from each previous group by `n^2` and add them all up.\\n\\n> If you find it difficult to understand, please let me know, and I\\'ll try to explain it better. However, I encourage you to reread the explanation and perhaps take a piece of paper to work through a few examples as described above. I believe you will start to see the pattern.\\n\\nNow, let\\'s determine how to calculate `prev`. Initially, `prev` is set to `0`, and we will update it for each new `n` using the following idea: `prev = prev + prev + n`, which can be simplified as `prev * 2 + n`. The rationale behind this update is as described earlier: each `n` will be the minimum number once for a group consisting only of `n`, and we also need to account for the sum of all minimum numbers from previous groups before `n`.\\n\\n---\\n\\n# Handling overflow in modulo calculations\\n\\nIn this particular problem, we\\'re working with a modulo of `1e9 + 7` and `1 <= nums[i] <= 1e9`. To ensure our calculations don\\'t cause overflow errors, we need to be cautious and take certain preventative steps. \\n\\nHere is the core code snippet of this task, written in Java:\\n\\n```java\\nsum = (int) (((((long) n * n) % mod) * ((prev + n) % mod) + sum) % mod);\\nprev = ((prev * 2) % mod + n) % mod;\\n```\\n> Note: this code leverages the property of modulo arithmetic that states `(a*b)%c = ((a%c)*b)%c = (a*(b%c))%c = ((a%c)*(b%c))%c`.\\n\\n### Handling Sum Overflow\\nLet\\'s consider the overflow problem with sum:\\n\\n- If `n` equals `1e9`, then `n^2` equals `1e18`, which is larger than `2^31 - 1` (`Integer.MAX_VALUE`). Therefore, we need to cast `n` to long before the multiplication operation. After applying the `% mod` operation, our number will not exceed `1e9 + 7`.\\n\\n- In our scenario, `prev` could be `1e9 + 6` and `n` could be `1e9`. The sum of these two numbers is less than `2^31 - 1`, which means we can safely perform the addition operation, and apply the modulo operation afterwards.\\n\\n- Now, multiplying these two numbers and applying the modulo operation afterwards is also safe. Note that sum is less than `1e9 + 7`, so we can safely add one to another and finally take the modulo operation.\\n\\n### Handling Prev Overflow\\nFor `prev`, potential overflow issue can be handled as follows:\\n\\n- In the worst case scenario, `n` could be `1e9` and `prev` could be `1e9 + 6`, which results in `3 * 1e9 + 12` -- a number greater than `2^31 - 1`. To prevent overflow, we need to apply the modulo operation after `prev * 2`.\\n---\\n# Complexity Analysis\\n\\n- **Time Complexity**: The time complexity of this algorithm is $$O(n \\\\log n)$$, where $$n$$ is the number of elements in `nums`. This is dominated by the sorting operation at the start of the algorithm. Subsequently, we iterate over `nums` once to calculate the sum of the powers, which contributes $$O(n)$$ to the time complexity. However, $$O(n \\\\log n)$$ is the more significant term.\\n\\n- **Space Complexity**: The space complexity of this algorithm is $$O(1)$$. We only use a fixed number of variables (`prev`, `sum`, `mod`) to store the intermediate and final results, and this does not scale with the size of the input `nums`.\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Combinatorics"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int sumOfPower(int[] nums) {\\n        int prev = 0, sum = 0, mod = (int) 1e9 + 7;\\n        Arrays.sort(nums);\\n        for (int n : nums) {\\n            sum = (int) (((((long) n * n) % mod) * ((prev + n) % mod) + sum) % mod);\\n            prev = ((prev * 2) % mod + n) % mod;\\n        }\\n        return sum;\\n    }\\n}\\n```\n``` cpp []\\nclass Solution {\\npublic:\\n    int sumOfPower(std::vector<int>& nums) {\\n        int prev = 0, sum = 0, mod = 1e9 + 7;\\n        std::sort(nums.begin(), nums.end());\\n        for (int n : nums) {\\n            sum = (int) (((((long long) n * n) % mod) * ((prev + n) % mod) + sum) % mod);\\n            prev = ((prev * 2) % mod + n) % mod;\\n        }\\n        return sum;\\n    }\\n};\\n```\n``` python []\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        prev, sum, mod = 0, 0, int(1e9 + 7)\\n        nums.sort()\\n        for n in nums:\\n            sum = (((n * n) % mod) * ((prev + n) % mod) + sum) % mod\\n            prev = ((prev * 2) % mod + n) % mod\\n        return sum\\n\\n```\n```\\n[1]:    1^2 * 1 = 8\\n[2]:    2^2 * 2 = 64\\n[4]:    4^2 * 4 = 4\\n[1,2]:  2^2 * 1 = 16\\n[1,4]:  4^2 * 1 = 32\\n[2, 4]: 4^2 * 2 = 16\\n[1,2,4]:4^2 * 1 = 128\\n\\nTotal power: 8 + 64 + 4 + 16 + 32 + 16 + 128 = 141\\n```\n```\\nn = 1: \\n    groups: [1]\\n    power: 1^2 * 1 = 1\\n\\nn = 2: \\n    groups: [2,1],[2]\\n    power: 2^2 * 1 + 2^2 * 2 = 2^2 * (1 + 2) = 12\\n\\nn = 4: \\n    groups: [4,1],[4,2,1],[4,2],[4]\\n    power: 4^2 * 1 + 4^2 * 1 + 4^2 * 2 + 4^2 * 4 \\n        = 4^2 * (1 + 1 + 2 + 4) = 128.\\n\\nTotal power: 1 + 12 + 128 = 141\\n```\n```java\\nsum = (int) (((((long) n * n) % mod) * ((prev + n) % mod) + sum) % mod);\\nprev = ((prev * 2) % mod + n) % mod;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520863,
                "title": "detailed-explanation-c-100",
                "content": "# Approach\\nFirst of all, we will sort array in non-descending order.\\nNext, we will iterate over the entire array and at each iteration we will calculate the sum for all subarrays,where $$nums[i]$$ is the maximum number in this subarray.\\nSum of all iterations will give us the result.\\n\\nHow we are going to calculate sum on each iteration:\\nimagine that we need to calculate in $$k$$ position\\n\\n$$nums[0]$$ $$nums[1]$$ $$...$$ $$nums[k-1]$$ $$nums[k]$$ $$...$$\\n\\nSince our array is sorted, then $$nums[0]$$ is the minimum number, so if this number is present in our subarray, then the $$power$$ of this subarray is $$nums[k] * nums[k] * nums[0]$$\\nHow many such subarrays do we have? The total number of subarrays is $$2^k$$, obviously half of them contain $$num[0]$$. So the sum of power all subarrays contained $$num[0]$$ equal to $$2^{k-1} * nums[k] * nums[k] * nums[0]$$. In the rest half of subarrays the minimum number will be $$nums[1]$$, and the number of subarrays contained  $$nums[1]$$ is the half of that, which is $$2^{k-2}$$, and the sum of power all subarrays contained $$num[1]$$ as minimum number equal to $$2^{k-2} * nums[k] * nums[k] * nums[1]$$ and so on:\\n\\n$$2^{k-1} * nums[k] * nums[k] * nums[0] + 2^{k-2} * nums[k] * nums[k] * nums[1] + ... + 2^{0} * nums[k] * nums[k] * nums[k - 1]=(2^{k-1} * nums[0] + 2^{k-2} * nums[1] + ... + 2^{0} * nums[k - 1]) * nums[k] * nums[k]$$\\n\\nAnd we also have a subarray consisting of only of a $$nums[k]$$ with the power equal to $$nums[k]^3$$\\n\\nRewrite as a function $$f(k)=2^{k-1} * nums[0] + 2^{k-2} * nums[1] + ... + 2^{0} * nums[k - 1]$$\\nThen it\\'s obvious that $$f(k + 1) = 2 * f(k) + nums[k]$$\\n\\n\\n# Complexity\\n- Time complexity: $$O(n logn)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n\\n# Approach without modulo reduction\\n```\\nclass Solution \\n{\\npublic:\\n    int sumOfPower(vector<int>& nums) \\n    {\\n        std::sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int curSum = 0;\\n        int result = 0;\\n        for (int i = 0; i < n; ++i)\\n        {\\n            result += (curSum + nums[i]) * nums[i] * nums[i];                \\n            curSum = 2 * curSum + nums[i];\\n        }\\n        return result;\\n    }\\n};\\n```\\n# Final approach\\n\\n```\\n#define MOD 1000000007\\n\\n#define MODULE(x) ((x) % MOD)\\n\\nclass Solution \\n{\\npublic:\\n    int sumOfPower(vector<int>& nums) \\n    {\\n        std::sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        long long curSum = 0;\\n        long long result = 0;\\n        for (int i = 0; i < n; ++i)\\n        {\\n            long long curNum = nums[i];\\n            result = MODULE(result + MODULE((curSum + curNum) * MODULE(curNum * curNum)));                \\n            curSum = MODULE(2 * curSum + nums[i]);\\n        }\\n        return result;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int sumOfPower(vector<int>& nums) \\n    {\\n        std::sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int curSum = 0;\\n        int result = 0;\\n        for (int i = 0; i < n; ++i)\\n        {\\n            result += (curSum + nums[i]) * nums[i] * nums[i];                \\n            curSum = 2 * curSum + nums[i];\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\n#define MOD 1000000007\\n\\n#define MODULE(x) ((x) % MOD)\\n\\nclass Solution \\n{\\npublic:\\n    int sumOfPower(vector<int>& nums) \\n    {\\n        std::sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        long long curSum = 0;\\n        long long result = 0;\\n        for (int i = 0; i < n; ++i)\\n        {\\n            long long curNum = nums[i];\\n            result = MODULE(result + MODULE((curSum + curNum) * MODULE(curNum * curNum)));                \\n            curSum = MODULE(2 * curSum + nums[i]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520870,
                "title": "c-observing-pattern",
                "content": "I got this intuition from Discuss section itself (nothing but observation and calculation)\\nAs we understood that sorting the data will not affect the calculation \\nSo initially sorting is carried out\\n![image](https://assets.leetcode.com/users/images/5616101c-8f47-4486-a3e7-fbcc288ac43a_1684000454.333143.jpeg)\\nSo we will write a function for finding out powers easily ...normal pow function cannot be used as we are dealing with long long here.\\n\\nand then for each element we find out the cubes and mutliply the squares with previous.\\nThe previous can be altered in the way as shown in the attached picture\\n![image](https://assets.leetcode.com/users/images/0593ee4c-549e-410a-a9e7-836909f50721_1684000662.759891.jpeg)\\n\\nThe code will look like\\n```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    long long power(long long x,long long y){\\n        long long res=1;\\n        while(y--){\\n            res=(res*x)%mod;\\n        }\\n        return res;\\n    }\\n    int sumOfPower(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        long long prev=0;\\n        long long ans=0;\\n        for(auto x:nums){\\n            ans=(ans+(long long)power(x,3)) %mod;\\n            ans=(ans+((long long)power(x,2)*prev) %mod)%mod;\\n            prev=(prev*2+x)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod=1e9+7;\\n    long long power(long long x,long long y){\\n        long long res=1;\\n        while(y--){\\n            res=(res*x)%mod;\\n        }\\n        return res;\\n    }\\n    int sumOfPower(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        long long prev=0;\\n        long long ans=0;\\n        for(auto x:nums){\\n            ans=(ans+(long long)power(x,3)) %mod;\\n            ans=(ans+((long long)power(x,2)*prev) %mod)%mod;\\n            prev=(prev*2+x)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532044,
                "title": "c-o-nlog-n-prefix-sum-subsequence",
                "content": "# Intuition\\nThe problem can be redefined as a summation of product of minimum and maximum element of each subsequence for the given vector.\\n\\n# Approach\\nAs we are only concerned with maximum and minimum values of each subsequence, we will rely on a special property of subsequence that for occurence of each element to be maximum in a subsequence equal to $$2^i, i\\u2208[0,n)$$. \\nApart from that now we require the \"power of group\" which is nothing but summation of minimum value for each subsequence which shares a trend of double after every iteration starting from 0 val.\\nThe series follow trend of $$[0, minv_{i-1}, 2*minv_{i-1}+maxv_{i+1}, 2*(val_{i-1}+maxv_{i-1}), ...............]$$\\nThus by manipulating the prefix sum array we can get our desired result just from multiplication of square of each value to its prefix count .\\n\\n# Visual Representation/Explanation through Example\\n![LC_2681.jpg](https://assets.leetcode.com/users/images/b191a4ac-ca62-4142-89fb-bbace68ac7d6_1684265138.2748508.jpeg)\\n\\n\\n# Complexity\\n- Time complexity: $$O(Nlog(N))$$\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int sumOfPower(vector<int>& vec) {\\n        long long res=0;\\n        // Typecast the vector from int to long long\\n        vector<long long> nums(begin(vec), end(vec)); \\n        sort(nums.begin(), nums.end());\\n        \\n        int n=nums.size();\\n        vector<int> prefix(n);\\n        prefix[0]=0;\\n        \\n        for(int i=1; i<n; i++)\\n            prefix[i] = ((2*prefix[i-1])+nums[i-1])%mod;\\n        \\n        for(int i=0; i<n; i++)\\n            prefix[i] = (prefix[i]+nums[i])%mod;\\n        \\n        //for(auto it: prefix)\\n        //        cout << it <<\" \";\\n        cout << endl;\\n        for(int i=0; i<n; i++){\\n            res = (res+((long long)((long long)(nums[i]*nums[i])%mod)*prefix[i])%mod)%mod;\\n        }\\n        return res%mod;\\n    }\\n};\\n```\\n\\nI hope you like my approach, do mention your strategies to tackle this question.\\nThank you for being so patient \\uD83D\\uDE0A.",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int sumOfPower(vector<int>& vec) {\\n        long long res=0;\\n        // Typecast the vector from int to long long\\n        vector<long long> nums(begin(vec), end(vec)); \\n        sort(nums.begin(), nums.end());\\n        \\n        int n=nums.size();\\n        vector<int> prefix(n);\\n        prefix[0]=0;\\n        \\n        for(int i=1; i<n; i++)\\n            prefix[i] = ((2*prefix[i-1])+nums[i-1])%mod;\\n        \\n        for(int i=0; i<n; i++)\\n            prefix[i] = (prefix[i]+nums[i])%mod;\\n        \\n        //for(auto it: prefix)\\n        //        cout << it <<\" \";\\n        cout << endl;\\n        for(int i=0; i<n; i++){\\n            res = (res+((long long)((long long)(nums[i]*nums[i])%mod)*prefix[i])%mod)%mod;\\n        }\\n        return res%mod;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3529842,
                "title": "c-detailed-idea-thought-process-and-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA naive solution that enumerates (i.e. brute-force) all the non-empty groups of heroes possible and calculate the power for the groups takes $$O(n \\\\times 2^n)$$, where there are $$2^n$$ possible number of groups and each group takes $$O(n)$$ time to calculate. This time complexity would not pass when n can be as large as $$10^5$$. Therefore, instead of brute-forcing out the non-empty groups, we can try enumerate over the possible minimum and maximum number pairs and calculate their contribution to the final answer. \\n\\nWe want to do this because once we fix the max and min of the subset, as long as the rest of the elements in the subset is greater than min and less than max, the power of this subset would be the same. By sorting the array beforehand, we can easily find out what elements we can take or not take, that are, elements between the minimum index and maximum index.\\n\\n![Before (1).png](https://assets.leetcode.com/users/images/bfe50525-c8c5-4cf4-afd2-14113adcc423_1687098372.6004515.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, we sort all the elements in ascending order. \\n\\n# Naive Implmentation\\nWe can use two loops to enumerate the `min` and `max` element. Once we fix the `min` and `max` element, the elements between would not affect the power of the subset; the power of the subset is still $$max^2 \\\\times min$$ because the elements in between cannot be greater than `max` or less than `min`.\\n\\nLet `b` be the number of elements that are indexed between the min and max elements, the number of ways to form subsets with same `min` and `max` would be $$2^b$$\\n\\nTherefore, let r be the index of the maximum element, and l be the index of the minimum element, the sum of the power contributed by this min max pair can be calculated by the following: \\nif $$ l \\\\neq r$$, then the sum would be $$nums[r]^2 \\\\times nums[l] \\\\,\\\\times 2^{r-l-1} $$\\nif $$ l == r$$, then the sum would be $$num[r] ^ 3$$\\n\\nLet `n` be the number of elements, `i` be the index of the maximum element we enumerate, and `j` be the minimum element we enumerate, we can calculate the total power with the following formula:\\n$$\\\\sum_{i=0}^{n} nums[i]^3 + \\\\sum_{j=0}^{i-1} \\\\, (nums[i]^2 \\\\times nums[j] \\\\times 2^ {i-j-1})$$\\n\\n\\nOr we can take the $$nums[i]^2$$ part out, which becomes:\\n$$\\\\sum_{i=0}^{n}\\\\, nums[i]^3 +(nums[i]^2 \\\\times \\\\sum_{j=0}^{i} \\\\, nums[j] \\\\times 2^ {i-j-1})$$\\n\\nThe final time complexity would be $$O(n^2)$$, but this is still not fast enough to pass the test case as $${(10^5)}^2 = 10^{10}$$.\\n\\n# Faster implementation\\nThe idea is still to enumerate over the maximum element, but now, we try to optimize the process of looping over the minimum element.\\n\\nNote that the second loop, which enumerates over the minimum element, always start from 0 every outer loop. Therefore, we can somehow reuse the already calculated part. \\n\\nWhen the outer loop moves from i to i+1, the inner loop\\'s $$\\\\sum_{j=0}^{i} \\\\, (nums[j] \\\\times 2^ {i-j-1})$$ becomes $$\\\\sum_{j=0}^{i+1} \\\\, (nums[j] \\\\times 2^ {i+1-j-1)})$$, which means an extra $$nums[i] \\\\times 2^0$$ will be added, and everything from `j ~ i`needs to be mulitplied by 2, because $$2^ {i-j-1}$$ becomes $$2^ {i+1-j-1}$$ \\n\\nTherefore, we can use a helper variable `cur` to store the current $$\\\\sum_{j=0}^{i} \\\\, (nums[j] \\\\times 2^ {i-j-1})$$. When we move from i to i+1, we just need to make `cur = cur * 2 + nums[i]`\\n\\nHere is an explanation on the intuition of making `cur = cur * 2 + nums[i]` every outer loop. Every time we move on to the next element, we\\u2019re just adding one possible choice for all the previous minimum values. In other words, each subset gets an extra choice to choose or not to choose an element between the given bound. Therefore, the possible choices are multiplied by 2. \\n\\n![Before.png](https://assets.leetcode.com/users/images/75d42241-fd09-4a4a-a290-5f7c679ddd1f_1684396349.5322797.png)\\n\\nNow, we can loop over the maximum value and use constant extra space to store the information previously required a second loop with a time complexity of $$O(n)$$ to calculate the power. The time compelxity of our algorithm will be sorting\\'s $$O(n \\\\log n)$$. When implementing, remember to add the $$nums[i]^3$$ to the answer and use long long to prevent overflow issues when moding!\\n\\n# Complexity\\n- Time complexity: $$O(n \\\\log n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ if sort is in-place, $$O(n)$$ if sort isn\\'t in-place \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7; \\n    int sumOfPower(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        ll ans = 0, cur = 0; // Use long long to avoid overflow\\n        for(int i = 0;i < nums.size();i++) {\\n            // use a temperary variable to store the contribution of nums[i] as the maximum number\\n            ll now = ((ll)nums[i] * nums[i] % mod * cur % mod + (ll)nums[i] * nums[i] % mod * nums[i]) % mod;\\n            ans = (ans + now) % mod;\\n            cur = (cur * 2 + nums[i]) % mod;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7; \\n    int sumOfPower(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        ll ans = 0, cur = 0; // Use long long to avoid overflow\\n        for(int i = 0;i < nums.size();i++) {\\n            // use a temperary variable to store the contribution of nums[i] as the maximum number\\n            ll now = ((ll)nums[i] * nums[i] % mod * cur % mod + (ll)nums[i] * nums[i] % mod * nums[i]) % mod;\\n            ans = (ans + now) % mod;\\n            cur = (cur * 2 + nums[i]) % mod;\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520685,
                "title": "very-detailed-dp-explanation",
                "content": "**the key insight is to keep track of an artificial score where we pretend that the maximum was always 1 for smaller subarrays.**\\nWhy  this strange idea? Let\\'s explore it together!\\n\\n# DP, ok, but why?\\nThis type of problem screams DP at me. Why? Well, it surely looks like giving the answer to the array `[2,1,4]` right away is gonna be tricky, but the answer to the array `[2,1]` is already a lot simpler and\\u2026 It really looks like there should be a way to infer the result of `[2,1,4]` from that of `[2,1]`.\\n\\n# First step: sorting makes our life easier\\nLet\\u2019s try and show that a bit better. Let\\u2019s say we have the result for `nums[0\\u2026i]`. How do we get the result for `nums[0\\u2026i+1]`?\\nIt seems difficult to say in general, because it all depends on how the maximum and the minimum are updated with the addition of the new element `nums[i+1]`, and since the array is an awful mess, it\\u2019s hard to predict how that goes.\\n\\nWell, we could be a bit more organized. Let\\u2019s sort that array in ascending order. Now everytime we consider a new element, we know it is the new max. For the minimum, even better, it just won\\'t change (because the new element is alway greater). \\nGood! But how do we update out count?\\n\\n# Let\\'s try to understand an example: [1,2,4]\\nWe go step by step, considering one additional element in each step:\\n1. `[1]`: 1, gg ez\\n2. `[1,2]`: Ok, we know `[1]` yields a score of 1 from the previous result (it is obviously also included in that count). There is also the singleton `[2]`, which gives $2^2.2=8$. And finally, there is the `[2,1]` element which gives $2^2.1=4$. In total, $8+4+1=13$\\n3.\\t`[1,2,4]`: There is 13 from the previous result, if we only take numbers from `[2,1]`. There is also the singleton `[4]` which will yield $4^4.4=64$. \\nNow how do we count all the combinations of 4 with the previous elements? Well, those elements are `[1]+[4]=[1,4], [2]+[4]=[2,4] and [1,2]+[4]=[1,2,4]`. \\nThe element `[1]` used to have a max of 1 and yield a score of 1. But `[1,4]` now has a max of 4, so we can take the score that we obtained for `[1]` in the first step and multiply it by $4^2$. `[2]` and `[1,2]` both had a max of 2, and the score associated to these guys is the score that we obtained in the second step minus the score in the first step (because we are counting [1] separately). So the score associated to [2,4] and [1,2,4] is going to be $4^2.(score_2-score_1)/2^2=16(13-1)/4=48$. To account for the maximum changing from 2 to 4, we simply divided by $2^2$ and multiplied by $4^2$. Total: $48+16+64+13=141$\\n\\n\\nWhat\\u2019s the key logic here? **It is to keep track of a number that represents the previous score if the maximum was 1!**\\n\\n# Sorry, what did you just say?\\n\\nLet me explain. At each new step, we get a new maximum, and the hard part is to know how it modifies the result of the previous subsets.\\n\\nFor example, if our previous subarray was `[2]`, we know it has a score of 8. But let\\u2019s instead keep track of its score with an artificial maximum of 1 (artificial score $s$ would be $s=1^2.2=2$), then if we want to know the power of `[2,5]` for example, it is simply $s*5^2$. Keeping track of that artificial score with a maximum of 1 allows us to \\u201Dreplace\\u201D the maximum with the new value at each step!\\nHow to do that properly? At each step, the artificial score is going to increase by an amount that is equal to the increase of the *real score* ($score_i-score_{i-1}$), **divided by the current maximum squared to simulate that artificial maximum of 1**:\\n$$s_i=s_{i-1} + \\\\frac{score_i-score_{i-1} }{nums_i^2}$$\\n\\n# Finally, the full DP logic:\\nTo get the score of `nums[0\\u2026i]` from the score of `nums[0\\u2026i-1]`, we sum three terms: \\n-\\t$score_{i-1}$: it represents the part of the sum coming from all combinations **without** the term `nums[i]`, as calculated in a previous step\\n-\\t$nums[i]^2*nums[i]$: that corresponds to the singleton `[nums[i]]`\\n-\\tThe part where we update the previous results according to the change of max. It corresponds to any combination of the previous numbers with `nums[i+1]` (which is the new max). That is given by $s_i. nums[i]^2$ where $s_i$ is obtained as described above\\nTherefore, the final recursion formula is:\\n$$score_i=score_{i-1}+ nums[i]^2*nums[i]+ s_i. nums[i]^2$$\\nWhere $s_i=s_{i-1} + \\\\frac{score_i-score_{i-1} }{nums_i}$\\n\\nThat\\'s it! Implementing it is not very difficult, I trust you ;)\\nIf that helped you understand the details of the recursive logic, feel free to upvote!\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) for the sorting\\n\\n- Space complexity:\\nO(1). optimizing space, we only need a couple variables to do this DP because we only use the values from last step\\n\\n# Code\\n```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        \\n\\n        nums.sort()\\n        score=nums[0]**2*nums[0]\\n        prevScore,prevMax,correctedSum=0,nums[0],0\\n        for num in nums[1:]:\\n            correctedSum+=(score-prevScore)//(prevMax)**2\\n            prevScore,prevMax=score,num\\n            score+= num**2*num + correctedSum*num**2\\n        \\n        return score%(10**9+7)       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        \\n\\n        nums.sort()\\n        score=nums[0]**2*nums[0]\\n        prevScore,prevMax,correctedSum=0,nums[0],0\\n        for num in nums[1:]:\\n            correctedSum+=(score-prevScore)//(prevMax)**2\\n            prevScore,prevMax=score,num\\n            score+= num**2*num + correctedSum*num**2\\n        \\n        return score%(10**9+7)       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520541,
                "title": "rust-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N * Log N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nimpl Solution {\\n    pub fn sum_of_power(nums: Vec<i32>) -> i32 {\\n        let n = nums.len();\\n        let MOD = 1_000_000_007;\\n        let mut nums = nums;\\n        nums.sort();\\n\\n        let mut data = vec![0; n];\\n        let mut ret = 0;\\n\\n        for i in 0 .. n {\\n            data[i] = nums[i] as i64;\\n            if i > 0 { data[i] = (data[i] + 2 * data[i - 1]) % MOD; }\\n\\n            let mut t = nums[i] as i64;\\n            if i > 0 { t = (t + data[i - 1]) % MOD; }\\n            t = (t * nums[i] as i64) % MOD;\\n            t = (t * nums[i] as i64) % MOD;\\n            ret = (ret + t) % MOD;\\n        }\\n\\n        ret as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn sum_of_power(nums: Vec<i32>) -> i32 {\\n        let n = nums.len();\\n        let MOD = 1_000_000_007;\\n        let mut nums = nums;\\n        nums.sort();\\n\\n        let mut data = vec![0; n];\\n        let mut ret = 0;\\n\\n        for i in 0 .. n {\\n            data[i] = nums[i] as i64;\\n            if i > 0 { data[i] = (data[i] + 2 * data[i - 1]) % MOD; }\\n\\n            let mut t = nums[i] as i64;\\n            if i > 0 { t = (t + data[i - 1]) % MOD; }\\n            t = (t * nums[i] as i64) % MOD;\\n            t = (t * nums[i] as i64) % MOD;\\n            ret = (ret + t) % MOD;\\n        }\\n\\n        ret as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520350,
                "title": "c-100-solution-beginner-friendly",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        vector<long long> d;\\n        for(auto i: nums)d.push_back(i);\\n        \\n        long long mod = 1e9+7;\\n        sort(d.begin(),d.end());\\n        \\n        long long mn=0, res=0;\\n        for(int i=0;i<d.size();i++){\\n            res=(res+((d[i]*d[i])%mod)*d[i]%mod)%mod;\\n            res = (res+((mn * d[i])%mod)*d[i]%mod)%mod;\\n            mn = (mn*2)%mod;\\n            mn = (mn+d[i]) % mod;\\n        }\\n        int ans = res%mod;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        vector<long long> d;\\n        for(auto i: nums)d.push_back(i);\\n        \\n        long long mod = 1e9+7;\\n        sort(d.begin(),d.end());\\n        \\n        long long mn=0, res=0;\\n        for(int i=0;i<d.size();i++){\\n            res=(res+((d[i]*d[i])%mod)*d[i]%mod)%mod;\\n            res = (res+((mn * d[i])%mod)*d[i]%mod)%mod;\\n            mn = (mn*2)%mod;\\n            mn = (mn+d[i]) % mod;\\n        }\\n        int ans = res%mod;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520223,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int sumOfPower(int[] nums) {\\n       ArrayList<Long >arr=new ArrayList<>();\\n            for(int i:nums)      \\n            {\\n                 arr.add((long)i);   \\n            }\\n            \\n            long  mod=1000000007;\\n            Collections.sort(arr);\\n            long mins=0;\\n            long sum=0;\\n            \\n            for(int i=0;i<arr.size();i++)\\n            {\\n                    sum=(sum+((arr.get(i)* arr.get(i))%mod)*arr.get(i)%mod)%mod;\\n                    sum=(sum+((mins*arr.get(i))%mod)*arr.get(i)%mod)%mod;\\n                    mins=(mins*2)%mod;\\n                    mins=(mins+arr.get(i))%mod;\\n            }\\n            int ans=(int)(sum%mod);\\n            return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int sumOfPower(int[] nums) {\\n       ArrayList<Long >arr=new ArrayList<>();\\n            for(int i:nums)      \\n            {\\n                 arr.add((long)i);   \\n            }\\n            \\n            long  mod=1000000007;\\n            Collections.sort(arr);\\n            long mins=0;\\n            long sum=0;\\n            \\n            for(int i=0;i<arr.size();i++)\\n            {\\n                    sum=(sum+((arr.get(i)* arr.get(i))%mod)*arr.get(i)%mod)%mod;\\n                    sum=(sum+((mins*arr.get(i))%mod)*arr.get(i)%mod)%mod;\\n                    mins=(mins*2)%mod;\\n                    mins=(mins+arr.get(i))%mod;\\n            }\\n            int ans=(int)(sum%mod);\\n            return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520203,
                "title": "8-line-easy-to-read-o-nlogn-solution",
                "content": "```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        # We sort the array first\\n        nums.sort()\\n        ans = pre = 0\\n        \\n        # We will consider the power of all the subsets in [nums[0], nums[1], ... , nums[i]]\\n        # When nums[i] is added, it must the the maximum since the array is sorted.\\n        for i, n in enumerate(nums):\\n            # There will be at first a set {nums[i]}, where both the maximum and minimum are nums[i]\\n            ans += n * n * n\\n            \\n            # Since nums[i] is the maximum, the rest of the power will be just nums[i] * nums[i] * (sum of other minimums)\\n            # We realized that this (sum of other minimums) will just grow by a factor of 2.\\n            # This is because when a number is a minimum of a previous set in the previous loop,\\n            # it will be also the minimum in {previous set + nums[i]}\\n            # Finally, there will be a new minimum nums[i-1] in {nums[i-1], nums[i]},\\n            # so we also add the previous element nums[i-1].\\n            if i > 0:\\n                pre = 2 * pre + nums[i-1]\\n                ans += n * n * pre\\n        \\n        return ans % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        # We sort the array first\\n        nums.sort()\\n        ans = pre = 0\\n        \\n        # We will consider the power of all the subsets in [nums[0], nums[1], ... , nums[i]]\\n        # When nums[i] is added, it must the the maximum since the array is sorted.\\n        for i, n in enumerate(nums):\\n            # There will be at first a set {nums[i]}, where both the maximum and minimum are nums[i]\\n            ans += n * n * n\\n            \\n            # Since nums[i] is the maximum, the rest of the power will be just nums[i] * nums[i] * (sum of other minimums)\\n            # We realized that this (sum of other minimums) will just grow by a factor of 2.\\n            # This is because when a number is a minimum of a previous set in the previous loop,\\n            # it will be also the minimum in {previous set + nums[i]}\\n            # Finally, there will be a new minimum nums[i-1] in {nums[i-1], nums[i]},\\n            # so we also add the previous element nums[i-1].\\n            if i > 0:\\n                pre = 2 * pre + nums[i-1]\\n                ans += n * n * pre\\n        \\n        return ans % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699622,
                "title": "and-it-s-maths",
                "content": "```\\nclass Solution {\\n    const int mod = 1e9+7;\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        long long prev = 0;\\n        long long sum = 0;\\n\\n        sort(begin(nums), end(nums));\\n\\n        for (int i=0; i<nums.size(); i++) {\\n            if (i > 0) prev = (1LL*prev*2 + 1LL*nums[i-1]) % mod;\\n            sum = (sum + (1LL*nums[i]*nums[i])%mod * (1LL*nums[i] + prev)%mod) % mod;\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    const int mod = 1e9+7;\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        long long prev = 0;\\n        long long sum = 0;\\n\\n        sort(begin(nums), end(nums));\\n\\n        for (int i=0; i<nums.size(); i++) {\\n            if (i > 0) prev = (1LL*prev*2 + 1LL*nums[i-1]) % mod;\\n            sum = (sum + (1LL*nums[i]*nums[i])%mod * (1LL*nums[i] + prev)%mod) % mod;\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555508,
                "title": "can-anyone-help-why-i-m-getting-wrong-answer-on-2542-test-case",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& a) \\n    {\\n        \\n        sort(a.begin(),a.end()); \\n        \\n        int n=a.size();\\n        vector<long long> sum(n,0);\\n        sum[1]=a[0];\\n        \\n        for(int i=2; i<n; i++)\\n        {\\n            sum[i]=(long)2*sum[i-1]+a[i-1];\\n            sum[i]%=1000000007;\\n        }\\n        long long ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            ans+=((long)pow(a[i],3)%1000000007   + (((long)pow(a[i],2)%1000000007) *sum[i])%1000000007)%1000000007;\\n            ans=ans%1000000007;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n```\\n\\n\\nwhile below solution is accepeted solution :\\ni can\\'t find any difference in concept of my code and this below code\\n```\\n#define MOD 1000000007\\n\\n#define MODULE(x) ((x) % MOD)\\n\\nclass Solution \\n{\\npublic:\\n    int sumOfPower(vector<int>& nums) \\n    {\\n        std::sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        long long curSum = 0;\\n        long long result = 0;\\n        for (int i = 0; i < n; ++i)\\n        {\\n            long long curNum = nums[i];\\n            result = MODULE(result + MODULE((curSum + curNum) * MODULE(curNum * curNum)));                \\n            curSum = MODULE(2 * curSum + nums[i]);\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& a) \\n    {\\n        \\n        sort(a.begin(),a.end()); \\n        \\n        int n=a.size();\\n        vector<long long> sum(n,0);\\n        sum[1]=a[0];\\n        \\n        for(int i=2; i<n; i++)\\n        {\\n            sum[i]=(long)2*sum[i-1]+a[i-1];\\n            sum[i]%=1000000007;\\n        }\\n        long long ans=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            ans+=((long)pow(a[i],3)%1000000007   + (((long)pow(a[i],2)%1000000007) *sum[i])%1000000007)%1000000007;\\n            ans=ans%1000000007;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n```\n```\\n#define MOD 1000000007\\n\\n#define MODULE(x) ((x) % MOD)\\n\\nclass Solution \\n{\\npublic:\\n    int sumOfPower(vector<int>& nums) \\n    {\\n        std::sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        long long curSum = 0;\\n        long long result = 0;\\n        for (int i = 0; i < n; ++i)\\n        {\\n            long long curNum = nums[i];\\n            result = MODULE(result + MODULE((curSum + curNum) * MODULE(curNum * curNum)));                \\n            curSum = MODULE(2 * curSum + nums[i]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544240,
                "title": "one-pass-solution-with-detailed-explanation",
                "content": "Let us start with a $O(n^2)$ solution. We notice that once the array is sorted, we can fix any two *distinct* indices $i, j$ where $0\\\\leq i,j<n$ and $i \\\\neq j$ then all subsequences composed of elements in between $i,j$ will have $A_i$ as the minimum and $A_j$ as the maximum. The number of such subsequences is $2^\\n{j-i-1}$ and so the contribution to answer is $2^{j-i-1} * A_j^2 * A_i$. If we sum this for all pair of indices we get the answer. We will separately handle $i=j$ cases.\\n```\\nint sumOfPower(vector<int>& nums) {\\n    int  n=nums.size(), res=0;\\n    sort(nums.begin(), nums.end());\\n    for (int i=0; i<n; i++)\\n    {\\n        for (int j=i; j<n; j++)\\n        {\\n            int amin=nums[i], amax=nums[j];\\n            int nmid = j-i-1;\\n            if (i==j) res += amax * amax * amin;\\n            else res += (1<<nmid) * amax * amax * amin;\\n        }\\n    }\\n    return res;\\n}\\n```\\n\\nNow, this will pass for small tests. As $n$ starts to increase, it will fail because looking at the constraints in the question, it seems to demand a single-pass solution.\\n\\nConsider an input array which is sorted ie $a \\\\leq b \\\\leq c \\\\leq d \\\\leq e$.\\n```\\nnums = [a,b,c,d,e]\\n```\\nNow let us write the answer at each iteration.\\n$a^3$\\n$b^3 + b^2a$\\n$c^3 + c^2b + 2c^2a$\\n$d^3 + d^2c + 2d^2b + 4c^2a$\\n$e^2 + e^2d + 2e^2c + 4e^b + 8e^2a$\\n\\nFinal answer is the sum of all of these. Notice the pattern that each iteration, we can compute a variable `pre` and then the contribution is `(pre + nums[i]) * nums[i] * nums[i]` and for the next time `pre` becomes `2*pre + nums[i]`.\\nFor example in the abover example, start with $P=0, R=0$ where `P=pre` and `R=res`, shorthand is used for simplicity.\\n$P=0, R=0$\\nAfter $i=0$, $R+=(0+a)*a^2, P=(2*0)+a$\\nAfter $i=1$, $R+=(a+b)*b^2, P=2a+b$\\nAfter $i=2$, $R+=(c+2a+b)*c^2, P=4a+2b+c$\\nAfter $i=3$, $R+=(d+4a+2b+c)*d^2, P=8a+4b+2c+d$\\nAfter $i=4$, $R+=(e+8a*4b+2c+d)*e^2, P=16a+8b+4c+2d+e$\\n\\nHere is the implementation:\\n```\\nint sumOfPower(vector<int>& nums) {\\n    int  n=nums.size();\\n    int res=0, pre=0;\\n    sort(nums.begin(), nums.end());\\n    for (int i=0; i<n; i++)\\n    {\\n        res += (pre + nums[i]) * nums[i] * nums[i]\\n        pre = 2*pre + nums[i];\\n    }\\n    return res;\\n}\\n```\\n\\nWe will need to add modulus operations to deal with big test cases. Also let us use `long long` to avoid edge case integer overflows.\\n```\\nclass Solution {\\n    int mod=1e9+7;\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        int  n=nums.size();\\n        long long res=0, pre=0;\\n        sort(nums.begin(), nums.end());\\n        for (int i=0; i<n; i++)\\n        {\\n            res += (((pre+nums[i])%mod * nums[i])%mod * nums[i])%mod;\\n            pre = (pre<<1)%mod + nums[i];\\n            pre %= mod;\\n            res %= mod;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n$TC: O(n\\\\log(n))$ because there was a sorting step involved. $SC: O(1)$.\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nint sumOfPower(vector<int>& nums) {\\n    int  n=nums.size(), res=0;\\n    sort(nums.begin(), nums.end());\\n    for (int i=0; i<n; i++)\\n    {\\n        for (int j=i; j<n; j++)\\n        {\\n            int amin=nums[i], amax=nums[j];\\n            int nmid = j-i-1;\\n            if (i==j) res += amax * amax * amin;\\n            else res += (1<<nmid) * amax * amax * amin;\\n        }\\n    }\\n    return res;\\n}\\n```\n```\\nnums = [a,b,c,d,e]\\n```\n```\\nint sumOfPower(vector<int>& nums) {\\n    int  n=nums.size();\\n    int res=0, pre=0;\\n    sort(nums.begin(), nums.end());\\n    for (int i=0; i<n; i++)\\n    {\\n        res += (pre + nums[i]) * nums[i] * nums[i]\\n        pre = 2*pre + nums[i];\\n    }\\n    return res;\\n}\\n```\n```\\nclass Solution {\\n    int mod=1e9+7;\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        int  n=nums.size();\\n        long long res=0, pre=0;\\n        sort(nums.begin(), nums.end());\\n        for (int i=0; i<n; i++)\\n        {\\n            res += (((pre+nums[i])%mod * nums[i])%mod * nums[i])%mod;\\n            pre = (pre<<1)%mod + nums[i];\\n            pre %= mod;\\n            res %= mod;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521667,
                "title": "simple-and-short-python-code",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def sumOfPower(self, nums):\\n        res, mod = 0, 1000000007\\n        nums.sort()\\n        sum_val = 0\\n\\n        for num in nums:\\n            res = (res + (sum_val + num) * num % mod * num) % mod\\n            sum_val = (sum_val * 2 + num) % mod\\n        \\n        return res\\n\\n```\\ncan be done in a few lines too: \\n```\\nclass Solution:\\n    def sumOfPower(self, nums, mod = 10**9 + 7):\\n        nums.sort()\\n        res, sum_val = 0, 0\\n        for num in nums: res, sum_val = (res + num*num*(sum_val + num)) % mod, (sum_val*2 + num) % mod\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumOfPower(self, nums):\\n        res, mod = 0, 1000000007\\n        nums.sort()\\n        sum_val = 0\\n\\n        for num in nums:\\n            res = (res + (sum_val + num) * num % mod * num) % mod\\n            sum_val = (sum_val * 2 + num) % mod\\n        \\n        return res\\n\\n```\n```\\nclass Solution:\\n    def sumOfPower(self, nums, mod = 10**9 + 7):\\n        nums.sort()\\n        res, sum_val = 0, 0\\n        for num in nums: res, sum_val = (res + num*num*(sum_val + num)) % mod, (sum_val*2 + num) % mod\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521052,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        ans, t= 0, 0\\n        mod=10**9+7\\n        for num in sorted(nums):\\n            ans = (ans + (t + num) *num* num) % mod\\n            t = (2 * t + num) % mod\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        ans, t= 0, 0\\n        mod=10**9+7\\n        for num in sorted(nums):\\n            ans = (ans + (t + num) *num* num) % mod\\n            t = (2 * t + num) % mod\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521020,
                "title": "python-fast-solution-o-n",
                "content": "For each largest num, prev would be the total of the min of all such subarrays where num is maximum.\\n\\n# Code\\n```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        prev = 0\\n        nums.sort()\\n        ans = 0\\n        mod = 10**9 + 7\\n\\n        for j, num in enumerate(nums):\\n            ans = (ans + (prev*num*num) + num*num*num)%mod\\n            prev = (prev*2 + num) % mod\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        prev = 0\\n        nums.sort()\\n        ans = 0\\n        mod = 10**9 + 7\\n\\n        for j, num in enumerate(nums):\\n            ans = (ans + (prev*num*num) + num*num*num)%mod\\n            prev = (prev*2 + num) % mod\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520530,
                "title": "easy-to-understand-time-o-n-logn-space-o-n",
                "content": "# Intuition\\nA pattern will be formed\\n\\n# Approach\\n\\nLets take array of size 3 : \\nNow sort them in ascending order.\\nLets assume Array will be [a1, a2, a3];\\nnow you will see a pattern like \\n1. when you take a1, it doesn\\'t have any number greater then itself, so the power will be a1xa1x(a1)\\n2. when you take a2 as max element, it makes 2 pairs -> 1 with itself and other with a1, so the power will be a2xa2x(a2+a1)\\n3. when you take a3 as max element, it makes 4 pairs -> 1 with itself and 2nd with a2, 3rd with a1 and 4th with a1 and a2, so the power will be a3xa3x(a3 + a2 + 2*a1) \\n**Here, we see in summation part a3 and a2 are comming only once but a1 is comming twice.**\\nSo the power of hero is sum of all three points.\\n\\nNow Lets take array of size 4 : \\nSort them in ascending order.\\nLets assume Array will be [a1, a2, a3, a4];\\nnow you will see a pattern like \\n1. when you take a1, it doesn\\'t have any number greater then itself, so the power will be **a1xa1x(a1)**\\n2. when you take a2 as max element, it makes 2 pairs -> 1 with itself and other with a1, \\nso the power will be **a2xa2x(a2+a1)**\\n3. when you take a3 as max element, it makes 4 pairs -> 1 with itself and 2nd with a2, 3rd with a1 and 4th with a1 and a2, \\nso the power will be **a3xa3x(a3 + a2 + 2*a1)** \\n4. when you take a4 as max element, it makes 8 pairs -> 1 with itself and 2nd with a3, 3rd with a2, 4th with a1,  5th with a2 and a3, 6th with a1 and a3, 7th with a1 and a2 and 8th with a1, a2 and a3, \\nso the power will be **a4xa4x(a4 + a3 + 2*a2 + 4*a1)** \\n**Here, we see in summation part a4 and a3 are comming only once but a2 is coming 2 times and a1 is comming 4 times.**\\nSo the power of hero is sum of all 4 points.\\n\\nSimilarly, for array of size n :\\n1. sort the array.\\n2. for(i = 0 to n-1) --> sum[i]= 2*(sum[i-1]-nums[i-1])+nums[i]+nums[i-1]\\n3. for(i = 0 to n-1) --> ans+ = nums[i]*nums[i]*sum[i]\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int sumOfPower(int[] nums) {\\n        //O(N) space \\n        //O(N*LOG(N)) time complexity\\n        \\n        Arrays.sort(nums);\\n        int l=nums.length;\\n        int mod = 1000000007;\\n        long ans=0;\\n        int[] sum = new int[l+1];\\n        sum[0]=nums[0];\\n        for(int i=1; i<l;i++){\\n            sum[i]= (((2*(sum[i-1]-nums[i-1])%mod)%mod+nums[i])%mod+nums[i-1])%mod;\\n        }\\n        for(int i=0;i<l;i++){\\n            ans=(ans+( ( ((long)nums[i]*(long)nums[i]) % mod )*(long)sum[i] )%mod )%mod;   \\n        }\\n        return (int)ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int sumOfPower(int[] nums) {\\n        //O(N) space \\n        //O(N*LOG(N)) time complexity\\n        \\n        Arrays.sort(nums);\\n        int l=nums.length;\\n        int mod = 1000000007;\\n        long ans=0;\\n        int[] sum = new int[l+1];\\n        sum[0]=nums[0];\\n        for(int i=1; i<l;i++){\\n            sum[i]= (((2*(sum[i-1]-nums[i-1])%mod)%mod+nums[i])%mod+nums[i-1])%mod;\\n        }\\n        for(int i=0;i<l;i++){\\n            ans=(ans+( ( ((long)nums[i]*(long)nums[i]) % mod )*(long)sum[i] )%mod )%mod;   \\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084014,
                "title": "sort-prefix-sum-combination-trick",
                "content": "# Intuition\\nFind the minimum and maximum for each combination of elements of the array. So sorting first is not a bad idea! Then in an arbitrary sub array, let\\'s say [a1, a2, a3, a4], it is already assumed that a1 <= a2 <= a3 <= a4. We only care about the a1 and a4: a4* a4 * a1\\n\\nOK, we have 2^N - 1 different combinations (minus the null array!). But for sure we cannot proceed to scan those 2^N-1 array. We must find the more effective way. One might think about calculating how many times the term (a_max, a_min) appeared in the sum. Let\\'s take an example:\\n\\nArray of (1, 2, 3, 4) (whatever the original array is, we\\'ve sorted it!):\\nLet\\'s find the elements of all the arrays:\\n* 1 element: \\n    * [1]: max 1, min 1 \\n    * [2]: max 2, min 2\\n    * [3]: max 3, min 3\\n    * [4]: max 4, min 4\\n* 2 elements: \\n    * [1, 2]: max 2, min 1\\n    * [1, 3]: max 3, min 1\\n    * [1, 4]: max 4, min 1\\n    * [2, 3]: max 3, min 2\\n    * [2, 4]: max 4, min 2\\n    * [3, 4]: max 4, min 3\\n* 3 elements:\\n    * [1, 2, 3]: max 3, min 1\\n    * [1, 2, 4]: max 4, min 1\\n    * [1, 3, 4]: max 4, min 1\\n    * [2, 3, 4]: max 4, min 2\\n* 4 elements:\\n    * [1, 2, 3, 4]: max 4, min 1\\n\\nNow have a look, let\\'s count how many times those terms show up in the final sum: \\n- (max 4, min 1): 4 times = 2^(4-1-1)\\n- (max 4, min 2), (max 3, min 1): 2 times = 2^(4-1-2)\\n- all the others: 1 times = 2^(4-1-3)\\n\\nDo the same for 5 elements [1, 2, 3, 4, 5] (Please work on your own!), you can observe that the term (max 5, min 1) will appear 8 times (or 2^(5-1-1)), (max 5, min 2) appear (2^(5-1-2) times), etc etc...\\n\\nSo, now for the general case, one can group the term for [a[1], a[2], ..., a[N]] (sorted), we\\'ll find out that for any sub array containing a[i] as maximum, it has the form:\\n\\n- a[N] * a[N] * (a[1] * 2^(N-1-1) + a[2] * 2^(N-1-2) + ... + a[N-1] * 2^(N-1-N-1))\\n\\n- a[N-1] * a[N-1] * (a[1] * 2^(N-2-1) + a[2] * 2^(N-2-2) + ... + a[N-2] * 2^(N-2-N-2))\\n\\nWe can observe the pattern like this: the sum for a[N] as maximum will be: S[N-1] = (a[1] * 2^(N-1-1) + a[2] * 2^(N-1-2) + ... + a[N-1] * 2^(N-1-N-1)). \\n\\nWorking recursively, we can easily find **S[i] = S[i-1] * 2 + a[i]** --> That\\'s the heart of our calculation!\\n\\nFrom now on, proceed to the last sum is just a piece of cake:\\n\\n1/ Sum of all cubic terms\\n2/ Sum of all (a[i]^2 * S[i-1]) for i from 1 to N-1!\\n\\nOK, we\\'re done with the math. Let\\'s code!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1/ Sort the array, then we don\\'t care any more about min or max.\\n2/ Calculate the prefix sums using our heart of calculation: **S[i] = S[i-1] * 2 + a[i]**\\n3/ Calculating sum, for convenient, break down into two part:\\n- Sum of all cubic terms\\n- sum of a[i] * a[i] * S[i-1]\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\ntypedef unsigned long long ull;\\n\\nclass Solution {\\nprivate:\\n    ull MODULO = 1e9+7;\\npublic:\\n    ull pow(ull x, ull n) {\\n        ull ret = 1;\\n        while (n) {\\n            if (n&1) {\\n                ret = (ret * x) % MODULO;\\n            }\\n            x = (x * x) % MODULO;\\n            n >>= 1;\\n        }\\n\\n        return ret % MODULO;\\n    }\\n\\n    ull inv(ull x) {\\n        return pow(x, MODULO-2);\\n    }\\n\\n    int sumOfPower(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N == 1) {\\n            return pow(nums[0], 3);\\n        }\\n        \\n        // Sort first!\\n        sort(nums.begin(), nums.end());\\n\\n        // Calculate sums here! Mind the trick\\n        vector<ull> fullSum(N-1, 0);\\n        fullSum[0] = nums[0];\\n        for (int i=1; i<N-1; i++) {\\n            fullSum[i] = ((fullSum[i-1] * 2) % MODULO + nums[i]) % MODULO;\\n        }\\n\\n        ull tot = 0;\\n        // Take all cubic elements\\n        for (int i=0; i<N; i++) {\\n            tot = (tot + (pow((ull)nums[i], 3)) % MODULO ) % MODULO;\\n        }\\n\\n        // calculate each elements\\n        for (int i=N-1; i>0; i--) {\\n            ull fact = ((ull)nums[i] * nums[i]) % MODULO;\\n            tot = (tot + (fact * fullSum[i-1]) % MODULO) % MODULO;\\n        }\\n\\n        return tot;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef unsigned long long ull;\\n\\nclass Solution {\\nprivate:\\n    ull MODULO = 1e9+7;\\npublic:\\n    ull pow(ull x, ull n) {\\n        ull ret = 1;\\n        while (n) {\\n            if (n&1) {\\n                ret = (ret * x) % MODULO;\\n            }\\n            x = (x * x) % MODULO;\\n            n >>= 1;\\n        }\\n\\n        return ret % MODULO;\\n    }\\n\\n    ull inv(ull x) {\\n        return pow(x, MODULO-2);\\n    }\\n\\n    int sumOfPower(vector<int>& nums) {\\n        int N = nums.size();\\n        if (N == 1) {\\n            return pow(nums[0], 3);\\n        }\\n        \\n        // Sort first!\\n        sort(nums.begin(), nums.end());\\n\\n        // Calculate sums here! Mind the trick\\n        vector<ull> fullSum(N-1, 0);\\n        fullSum[0] = nums[0];\\n        for (int i=1; i<N-1; i++) {\\n            fullSum[i] = ((fullSum[i-1] * 2) % MODULO + nums[i]) % MODULO;\\n        }\\n\\n        ull tot = 0;\\n        // Take all cubic elements\\n        for (int i=0; i<N; i++) {\\n            tot = (tot + (pow((ull)nums[i], 3)) % MODULO ) % MODULO;\\n        }\\n\\n        // calculate each elements\\n        for (int i=N-1; i>0; i--) {\\n            ull fact = ((ull)nums[i] * nums[i]) % MODULO;\\n            tot = (tot + (fact * fullSum[i-1]) % MODULO) % MODULO;\\n        }\\n\\n        return tot;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988427,
                "title": "intuition",
                "content": "In the problem statement, we only need to track maximum and minimum of sub-sequences i.e., the \"order\" doesn\\'t matter. \\n> Sort the sequence\\n\\nConsider a sorted sub-sequence [1,2,3,4]\\n> Define a maximum number (nums[i] = 4), and define a minimum number (nums[j] = 1)\\n\\nthen, the number of sub-sequences with maximum = 4 and minimum = 2 will be equal to \\n> 2^{i-j-1}\\n\\n\\nUsing this intuition, you can easily come up with an O(N^2) solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        int N = nums.size();\\n        typedef long long ll;\\n        int mod = 1e9 + 7;\\n        \\n        auto mP = [&mod](ll a, ll b) {\\n            return ( (a%mod) * (b%mod) )%mod;\\n        };\\n        \\n        auto mS = [&mod](ll a, ll b) {\\n            return ( (a%mod) + (b%mod) )%mod;\\n        };\\n        \\n        // [1,2,4]\\n        // 1 -> max in \"1\" group ([1]) => (1*1)*( 1 ) = 1\\n        // 2 -> max in \"2\" groups ([1,2], [2]) => (2*2)*( 1 + 2 ) = 12\\n        // 4 -> max in \"4\" groups ([1,2,4], [2,4], [1,4], [4]) => (4*4)*(1+1+2+4) = 128\\n        \\n        sort(begin(nums), end(nums));\\n        \\n        vector<ll> sum(N, 0);\\n        for(int i=0; i<N; ++i) {\\n            sum[i] = mS(nums[i], (i==0 ? 0 : sum[i-1]));\\n        }\\n        \\n        ll m=INT_MAX, ret=0, prev=0;\\n        for(int i=0; i<N; ++i) {\\n            ll num = nums[i];\\n            ll left = mP(num, num);\\n            \\n            ll right = num;\\n            ll pow = 1;\\n            for(int j=i-1; j>=0; --j) {\\n                right = mS(right, mP(nums[j], pow));\\n                pow = mP(pow, 2);\\n            }            \\n            ret = mS(ret, mP(left, right));\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```\\n\\nTo go from `O(N^2)` to `O(N)`, we need to eliminate the inner loop. It follows from the following observation\\n\\nFor the sorted sub-sequence [1,2,3]\\n- If we fix, min=1 and max=3, then there will be two sub-sequences satisfying this constraint => `[1,3], [1,2,3]`\\n- If we fix, min=2 and max=3, then there will be one sub-sequence satisfying this constraint => `[2,3]`\\n\\nFor the sorted sub-sequence [1,2,3,4]\\n- If we fix, min=1 and max=4, then there will be four sub-sequences satisfying this constraint => `[1,4], [1,2,4], [1,3,4],[1,2,3,4]`\\n- If we fix, min=2 and max=4, then there will be two sub-sequences satisfying this constraint => `[2,4], [2,3,4]`\\n\\n> So, everytime we add an element (increment the for-loop index), the contribution of every minimum element doubles\\n\\n```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        int N = nums.size();\\n        int mod = 1e9 + 7;\\n        \\n        auto mP = [&mod](int a, int b) {\\n            return ( int64_t(a%mod) * (b%mod) )%mod;\\n        };\\n        \\n        auto mS = [&mod](int a, int b) {\\n            return ( (a%mod) + (b%mod) )%mod;\\n        };\\n        \\n        sort(begin(nums), end(nums));\\n        \\n        int ret=0, prev=0;\\n        for(int i=0; i<N; ++i) {\\n            prev = mS(mP(prev,2), i==0 ? 0 : nums[i-1]);\\n            ret = mS(ret, mP(mP(nums[i], nums[i]), mS(nums[i], prev)));\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        int N = nums.size();\\n        typedef long long ll;\\n        int mod = 1e9 + 7;\\n        \\n        auto mP = [&mod](ll a, ll b) {\\n            return ( (a%mod) * (b%mod) )%mod;\\n        };\\n        \\n        auto mS = [&mod](ll a, ll b) {\\n            return ( (a%mod) + (b%mod) )%mod;\\n        };\\n        \\n        // [1,2,4]\\n        // 1 -> max in \"1\" group ([1]) => (1*1)*( 1 ) = 1\\n        // 2 -> max in \"2\" groups ([1,2], [2]) => (2*2)*( 1 + 2 ) = 12\\n        // 4 -> max in \"4\" groups ([1,2,4], [2,4], [1,4], [4]) => (4*4)*(1+1+2+4) = 128\\n        \\n        sort(begin(nums), end(nums));\\n        \\n        vector<ll> sum(N, 0);\\n        for(int i=0; i<N; ++i) {\\n            sum[i] = mS(nums[i], (i==0 ? 0 : sum[i-1]));\\n        }\\n        \\n        ll m=INT_MAX, ret=0, prev=0;\\n        for(int i=0; i<N; ++i) {\\n            ll num = nums[i];\\n            ll left = mP(num, num);\\n            \\n            ll right = num;\\n            ll pow = 1;\\n            for(int j=i-1; j>=0; --j) {\\n                right = mS(right, mP(nums[j], pow));\\n                pow = mP(pow, 2);\\n            }            \\n            ret = mS(ret, mP(left, right));\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        int N = nums.size();\\n        int mod = 1e9 + 7;\\n        \\n        auto mP = [&mod](int a, int b) {\\n            return ( int64_t(a%mod) * (b%mod) )%mod;\\n        };\\n        \\n        auto mS = [&mod](int a, int b) {\\n            return ( (a%mod) + (b%mod) )%mod;\\n        };\\n        \\n        sort(begin(nums), end(nums));\\n        \\n        int ret=0, prev=0;\\n        for(int i=0; i<N; ++i) {\\n            prev = mS(mP(prev,2), i==0 ? 0 : nums[i-1]);\\n            ret = mS(ret, mP(mP(nums[i], nums[i]), mS(nums[i], prev)));\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974611,
                "title": "sort-and-accumulate-constant-extra-space-c-solution",
                "content": "After sorting, considering first x elements, if we make subarrays from these x elements, each element will be smallest in following number of subarrays containing xth element:-\\n\\n_(These subarrays will have xth element as largest element)_\\n\\n* xth :- 1 ==> { xth }\\n* x-1th :- 1 ==> { x-1th, xth }\\n* x-2th :- 2 ==> { x-2th, xth } { x-2th, x-1th, xth }\\n* x-2th :- 4 ==> ...\\n* x-3th :- 8 ==> ...\\n* ...\\n\\n```\\nclass Solution {\\n   public:\\n    int sumOfPower(vector<int>& nums)\\n    {\\n        sort(begin(nums), end(nums));\\n        long long ans = 0, cur = 0, MOD = 1e9 + 7;\\n        for (auto& num : nums) {\\n            ans += ((((cur + num) % MOD) * num) % MOD * num) % MOD;\\n            ans %= MOD;\\n            cur = (cur * 2 + num) % MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**If you have any doubts or suggestions, please feel free to comment.\\nIf you find this solution useful, you know where the upvote is :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n   public:\\n    int sumOfPower(vector<int>& nums)\\n    {\\n        sort(begin(nums), end(nums));\\n        long long ans = 0, cur = 0, MOD = 1e9 + 7;\\n        for (auto& num : nums) {\\n            ans += ((((cur + num) % MOD) * num) % MOD * num) % MOD;\\n            ans %= MOD;\\n            cur = (cur * 2 + num) % MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971076,
                "title": "o-n-log-n-solution-in-python-faster-than-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is similar to [Sum of Subsequence Widths](https://leetcode.com/problems/sum-of-subsequence-widths/), but simpler.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n$$ A_i = A_{i-1} + x_i F_i + x_i^3 $$\\n$$ F_i = 2F_{i-1} + x_{i-1}^2$$\\n\\n# Complexity\\n- Time complexity: $$O(N \\\\log N)$$ for sorting\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: in-place with $$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        ans = (nums[0]**3) % 1000000007\\n        f = 0\\n        for u, v in zip(nums, nums[1:]):\\n            f = (f * 2 + u * u) % 1000000007\\n            ans = (ans + v * (f + v * v)) % 1000000007\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        nums.sort(reverse=True)\\n        ans = (nums[0]**3) % 1000000007\\n        f = 0\\n        for u, v in zip(nums, nums[1:]):\\n            f = (f * 2 + u * u) % 1000000007\\n            ans = (ans + v * (f + v * v)) % 1000000007\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824668,
                "title": "scala-foldleft",
                "content": "# Code\\n```\\nobject Solution {\\n  def sumOfPower(nums: Array[Int]): Int =\\n    nums.sorted.foldLeft((0L, 0L)) { case ((acc, sum), n) => (m(acc + m((sum + n) * n) * n), m(sum * 2 + n)) }._1.toInt\\n\\n  private def m(a: Long) = a % 1000000007\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def sumOfPower(nums: Array[Int]): Int =\\n    nums.sorted.foldLeft((0L, 0L)) { case ((acc, sum), n) => (m(acc + m((sum + n) * n) * n), m(sum * 2 + n)) }._1.toInt\\n\\n  private def m(a: Long) = a % 1000000007\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3693088,
                "title": "math-java-solution-clean-code",
                "content": "# Complexity\\n- Time complexity: $O(n \\\\cdot logn)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    int MOD = (int) 1e9 + 7;\\n    long powMod(long base, long exp) {\\n        long ans = 1;\\n        for (; exp != 0;) {\\n            if ((exp & 1) == 1) {\\n                ans *= base;\\n                ans %= MOD;\\n            }\\n            base *= base;\\n            base %= MOD;\\n            exp = exp >> 1;\\n        }\\n        return ans;\\n    }\\n    long mulMod(long a, long b) {\\n        long ans = 0;\\n        for (; b != 0;) {\\n            if ((b & 1) == 1) {\\n                ans += a;\\n                ans %= MOD;\\n            }\\n            a += a;\\n            a %= MOD;\\n            b >>= 1;\\n        }\\n        return ans;\\n    }\\n    public int sumOfPower(int[] nums) {\\n        Arrays.sort(nums);\\n        long ans = 0;\\n        long prev = 0;\\n        long add = 0;\\n        for(var n:nums){\\n            add = mulMod(add,2);\\n            add = (add + prev) % MOD;\\n            ans = (ans + mulMod(add,powMod(n,2))) % MOD;\\n            ans = (ans + powMod(n,3)) % MOD;\\n            prev = n;\\n        }\\n        return (int)(ans % MOD);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```java\\nclass Solution {\\n    int MOD = (int) 1e9 + 7;\\n    long powMod(long base, long exp) {\\n        long ans = 1;\\n        for (; exp != 0;) {\\n            if ((exp & 1) == 1) {\\n                ans *= base;\\n                ans %= MOD;\\n            }\\n            base *= base;\\n            base %= MOD;\\n            exp = exp >> 1;\\n        }\\n        return ans;\\n    }\\n    long mulMod(long a, long b) {\\n        long ans = 0;\\n        for (; b != 0;) {\\n            if ((b & 1) == 1) {\\n                ans += a;\\n                ans %= MOD;\\n            }\\n            a += a;\\n            a %= MOD;\\n            b >>= 1;\\n        }\\n        return ans;\\n    }\\n    public int sumOfPower(int[] nums) {\\n        Arrays.sort(nums);\\n        long ans = 0;\\n        long prev = 0;\\n        long add = 0;\\n        for(var n:nums){\\n            add = mulMod(add,2);\\n            add = (add + prev) % MOD;\\n            ans = (ans + mulMod(add,powMod(n,2))) % MOD;\\n            ans = (ans + powMod(n,3)) % MOD;\\n            prev = n;\\n        }\\n        return (int)(ans % MOD);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674261,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n#define ll long long \\n    int sumOfPower(std::vector<int>& nums) \\n    {\\n        ll sum=0;\\n        ll int mod = 1000000007;\\n        ll n = nums.size();\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        for (int i=0; i<n; i++) \\n        {\\n            ll int cube = (((1ll * nums[i] * nums[i]) %mod) * nums[i]) %mod;\\n            sum = (sum + cube) %mod;\\n        }\\n        ll minsum=0;\\n        for(int j = n-2; j>=0; j--)\\n        {\\n            minsum = (minsum * 2 + nums[j+1]) % mod;\\n            sum = (sum + (((minsum * nums[j]) %mod) * nums[j]) %mod) %mod;\\n        }\\n        return sum;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n#define ll long long \\n    int sumOfPower(std::vector<int>& nums) \\n    {\\n        ll sum=0;\\n        ll int mod = 1000000007;\\n        ll n = nums.size();\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        for (int i=0; i<n; i++) \\n        {\\n            ll int cube = (((1ll * nums[i] * nums[i]) %mod) * nums[i]) %mod;\\n            sum = (sum + cube) %mod;\\n        }\\n        ll minsum=0;\\n        for(int j = n-2; j>=0; j--)\\n        {\\n            minsum = (minsum * 2 + nums[j+1]) % mod;\\n            sum = (sum + (((minsum * nums[j]) %mod) * nums[j]) %mod) %mod;\\n        }\\n        return sum;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560014,
                "title": "sorting-the-array-with-image",
                "content": "# Intuition\\nBasically sorting the array and counting for each element , how many times it will be the minimum of the array.\\n\\n# Approach\\nsorting the array and then for every element , the arrays which it will be part will be subsequence of the elements following it.\\n![leetcode.jpeg](https://assets.leetcode.com/users/images/29739110-ca4a-460f-8978-3455bb1ca80c_1684963926.233752.jpeg)\\n\\n\\n# Complexity\\n- Time complexity:\\nnlogn\\n\\n- Space complexity:\\nn\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        \\n     int i;\\n     int n=nums.size();\\n      long long int  m=1000000007;\\n     long long int  ans=0;\\n      sort(nums.begin(),nums.end());\\n      vector<long long int> sum(n);\\n      long long int e=nums[n-1];\\n      long long int f;\\n      sum[n-1]= (e*e)%m;\\n     long long int  c=sum[n-1];\\n     \\n      for(i=n-2;i>=0;i--){\\n             e=nums[i+1];\\n        c= (2*c-(e*e))%m;\\n        f=nums[i];\\n        c=(c+f*f)%m;\\n          sum[i]=c;\\n        \\n      }\\n      for(i=0;i<n;i++){\\n          f=nums[i];\\n          ans=(ans+(f*sum[i]))%m;\\n      }\\n\\n       ans=ans%m;\\n       int d=ans;\\n       return d;\\n\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        \\n     int i;\\n     int n=nums.size();\\n      long long int  m=1000000007;\\n     long long int  ans=0;\\n      sort(nums.begin(),nums.end());\\n      vector<long long int> sum(n);\\n      long long int e=nums[n-1];\\n      long long int f;\\n      sum[n-1]= (e*e)%m;\\n     long long int  c=sum[n-1];\\n     \\n      for(i=n-2;i>=0;i--){\\n             e=nums[i+1];\\n        c= (2*c-(e*e))%m;\\n        f=nums[i];\\n        c=(c+f*f)%m;\\n          sum[i]=c;\\n        \\n      }\\n      for(i=0;i<n;i++){\\n          f=nums[i];\\n          ans=(ans+(f*sum[i]))%m;\\n      }\\n\\n       ans=ans%m;\\n       int d=ans;\\n       return d;\\n\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550752,
                "title": "c-easy-math",
                "content": "# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    const static ll mod=1e9+7;\\n    int sumOfPower(vector<int>& nums) \\n    {\\n        ll prefix=0;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        ll res=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            prefix<<=1;\\n            if(i-1>=0)prefix+=nums[i-1];\\n            prefix=prefix%mod;\\n            ll cur=(1ll*nums[i]*nums[i])%mod;\\n            res+=cur*prefix;\\n            res+=((1ll*nums[i]*nums[i])%mod)*nums[i];\\n            res=res%mod;\\n        }\\n        return res;\\n    }\\n};\\n\\n// (A^2 * B) + (A^2 * C) = A^2 * (B + C)\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    const static ll mod=1e9+7;\\n    int sumOfPower(vector<int>& nums) \\n    {\\n        ll prefix=0;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        ll res=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            prefix<<=1;\\n            if(i-1>=0)prefix+=nums[i-1];\\n            prefix=prefix%mod;\\n            ll cur=(1ll*nums[i]*nums[i])%mod;\\n            res+=cur*prefix;\\n            res+=((1ll*nums[i]*nums[i])%mod)*nums[i];\\n            res=res%mod;\\n        }\\n        return res;\\n    }\\n};\\n\\n// (A^2 * B) + (A^2 * C) = A^2 * (B + C)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542331,
                "title": "mine",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        ans, t, base = 0, 0, 10**9 + 7\\n        for c in sorted(nums):\\n            ans = (ans + (t + c) * c * c) % base\\n            t = (2 * t + c) % base\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        ans, t, base = 0, 0, 10**9 + 7\\n        for c in sorted(nums):\\n            ans = (ans + (t + c) * c * c) % base\\n            t = (2 * t + c) % base\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540562,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        long long ans = 0;\\n        long long mod = 1e9+7;\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        long long a = nums[0];\\n        for(int i=1;i<n;i++){\\n            ans= (ans + ((((nums[i]%mod)*(nums[i]%mod))%mod)*(a%mod))%mod)%mod;\\n            a=(a*2)%mod;\\n            a=(a+(nums[i]%mod))%mod;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            ans+=(((nums[i]%mod)*(nums[i]%mod)%mod)*(nums[i]%mod))%mod;\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        long long ans = 0;\\n        long long mod = 1e9+7;\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        long long a = nums[0];\\n        for(int i=1;i<n;i++){\\n            ans= (ans + ((((nums[i]%mod)*(nums[i]%mod))%mod)*(a%mod))%mod)%mod;\\n            a=(a*2)%mod;\\n            a=(a+(nums[i]%mod))%mod;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            ans+=(((nums[i]%mod)*(nums[i]%mod)%mod)*(nums[i]%mod))%mod;\\n        }\\n        return ans%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537671,
                "title": "python-in-mathematics-it-is-not-difficult",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, sort the nums.\\n\\nI use [a, b, c, d, e] as example (which is a < b < c < d < e)\\n\\n**Length 1 Array:**\\nPower = a ^ 3 + b ^ 3 + c ^ 3 + d ^ 3 + e ^ 3\\n\\n**Length 2 Array:**\\n[a, b] Power: a * b ^ 2, [a, c] Power: a * c ^ 2\\n[a, d] Power: a * d ^ 2, [a, e] Power: a * e ^ 2\\n[b, c] Power: b * c ^ 2, [b, d] Power: b * d ^ 2\\n[b, e] Power: b * e ^ 2, [c, d] Power: c * d ^ 2\\n[c, e] Power: c * e ^ 2, [d, e] Power: d * e ^ 2\\n\\n**Length 3 Array:**\\n[a, b, c] Power: a * c ^ 2, [a, b, d] Power: a * d ^ 2\\n[a, b, e] Power: a * e ^ 2, [a, c, d] Power: a * d ^ 2\\n[a, c, e] Power: a * e ^ 2, [a, d, e] Power: a * e ^ 2\\n[b, c, d] Power: b * d ^ 2, [b, c, e] Power: b * e ^ 2\\n[b, d, e] Power: b * e ^ 2, [c, d, e] Power: c * e ^ 2\\n\\n**Length 4 Array:**\\n[a, b, c, d] Power: a * d ^ 2, [a, b, c, e] Power: a * e ^ 2\\n[a, b, d, e] Power: a * e ^ 2, [a, c, d, e] Power: a * e ^ 2\\n[b, c, d, e] Power: b * e ^ 2\\n\\n**Length 5 Array:**\\nPower = a * e ^ 2\\n\\n---\\n\\nThen I seperate these in two cases.\\n\\n**Case 1: Length = 1**: Simply loop the number and sum the cube.\\n\\n**Case 2: Length > 1**:\\nI group the result above by number\\'s square:\\n**b ^ 2 * (a) +\\nc ^ 2 * (2a + b) +\\nd ^ 2 * (4a + 2b + c) +\\ne ^ 2 * (8a + 4b + 2c + d)**\\n\\n---\\n\\nJust look at the sum inside brackets. I rewrite it as:\\na = **(0)** * 2 + a\\n2a + b = **(a)** * 2 + b\\n4a + 2b + c = **(2a + b)** * 2 + c\\n8a + 4b + 2c + d = **(4a + 2b + c)** * 2 + d\\n\\n---\\n\\nThe sum inside brackets (Called as \"diff\" in code) is \\n**\"diff\" = The previous \"diff\" * 2 + the new number.**\\n\\nConsider with the number\\'s square. For i in nums, \\n**ith result = nums[i+1] * nums[i+1] * diff, which diff has added nums[i]**\\n\\nreturn **final power % 1000000007**.\\n\\n---\\n\\n# Complexity\\n- Time complexity:  O(nlogn)\\n- Space complexity: O(n)\\n\\n---\\n\\n# Code\\n```\\nclass Solution(object):\\n    def sumOfPower(self, nums):\\n        nums.sort()\\n\\n        output = 0\\n        for n in nums:\\n            output += pow(n, 3)\\n\\n        diff = 0\\n        for i in range(len(nums)-1):\\n            diff += diff + nums[i]\\n            output += nums[i+1] * nums[i+1] * diff\\n\\n        return output % 1000000007\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def sumOfPower(self, nums):\\n        nums.sort()\\n\\n        output = 0\\n        for n in nums:\\n            output += pow(n, 3)\\n\\n        diff = 0\\n        for i in range(len(nums)-1):\\n            diff += diff + nums[i]\\n            output += nums[i+1] * nums[i+1] * diff\\n\\n        return output % 1000000007\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536339,
                "title": "java-easy-to-follow-comments-with-example",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSee comments in code\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSee comments in code\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\n    /**\\n     *     10        20        30        40        50\\n     *                                             50 -> 1\\n     *                                   40 -> 1   =======\\n     *                         30 -> 1   =======   40 -> 1\\n     *               20 -> 1   =======   30 -> 1   30 -> 2\\n     *     10 -> 1   =======   20 -> 1   20 -> 2   20 -> 4\\n     *     =======   10 -> 1   10 -> 2   10 -> 4   10 -> 8\\n     *\\n     *  For all ranges including 50, 50 is the max, for these ranges:\\n     *      There is one range where 50 is min as well => [50]\\n     *      There is one range where 40 is min => [40, 50]\\n     *      There are two ranges where 30 is min => [30, 40, 50], [30, 50]\\n     *      There are four ranges where 20 is min => essentially four sets made from 30 & 40\\n     *      There are eight ranges where 10 is min => essentially eight sets made from 20, 30 & 40\\n     *\\n     *  So we compute the cumulative sums by doubling the previous sum and adding previous number.\\n     *  When calculating power we add self to sum and then multuply by square of self.\\n     *  Overflow makes the code harder to read but below is the crux of the calc:\\n     *      sum = sum * 2 + nums[i - 1]\\n     *      powerSum += (sums[i] + nums[i]) * nums[i]* nums[i]\\n     */\\n    public int sumOfPower(int[] nums) {\\n        int n = nums.length;\\n        int[] sums = new int[n];\\n        int sum = 0, mod = 1000000007;\\n        long powerSum = 0;\\n\\n        Arrays.sort(nums);\\n        sums[0] = 0;\\n        for (int i = 1; i < n; i++) {\\n            sum = (((sum * 2) % mod) + nums[i - 1]) % mod;\\n            sums[i] = sum;\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            powerSum += ( ((sums[i] + nums[i]) % mod) * ((((long)nums[i]) * nums[i]) % mod) ) % mod;\\n            powerSum %= mod;\\n        }\\n        \\n        return (int) powerSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /**\\n     *     10        20        30        40        50\\n     *                                             50 -> 1\\n     *                                   40 -> 1   =======\\n     *                         30 -> 1   =======   40 -> 1\\n     *               20 -> 1   =======   30 -> 1   30 -> 2\\n     *     10 -> 1   =======   20 -> 1   20 -> 2   20 -> 4\\n     *     =======   10 -> 1   10 -> 2   10 -> 4   10 -> 8\\n     *\\n     *  For all ranges including 50, 50 is the max, for these ranges:\\n     *      There is one range where 50 is min as well => [50]\\n     *      There is one range where 40 is min => [40, 50]\\n     *      There are two ranges where 30 is min => [30, 40, 50], [30, 50]\\n     *      There are four ranges where 20 is min => essentially four sets made from 30 & 40\\n     *      There are eight ranges where 10 is min => essentially eight sets made from 20, 30 & 40\\n     *\\n     *  So we compute the cumulative sums by doubling the previous sum and adding previous number.\\n     *  When calculating power we add self to sum and then multuply by square of self.\\n     *  Overflow makes the code harder to read but below is the crux of the calc:\\n     *      sum = sum * 2 + nums[i - 1]\\n     *      powerSum += (sums[i] + nums[i]) * nums[i]* nums[i]\\n     */\\n    public int sumOfPower(int[] nums) {\\n        int n = nums.length;\\n        int[] sums = new int[n];\\n        int sum = 0, mod = 1000000007;\\n        long powerSum = 0;\\n\\n        Arrays.sort(nums);\\n        sums[0] = 0;\\n        for (int i = 1; i < n; i++) {\\n            sum = (((sum * 2) % mod) + nums[i - 1]) % mod;\\n            sums[i] = sum;\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            powerSum += ( ((sums[i] + nums[i]) % mod) * ((((long)nums[i]) * nums[i]) % mod) ) % mod;\\n            powerSum %= mod;\\n        }\\n        \\n        return (int) powerSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535015,
                "title": "o-nlogn-solution-using-memoization",
                "content": "# Intuition\\nIts pretty clear that this is a subset question, so we are somewhere in the realm of ~2^n, since that is the number of subsets. Need to realize that for any subset, I dont care what elements are in it, but rather only the largest and smallest element. If we ordered the numbers, and then picked small and large endpoints, we can calculate the number of elements with (small, large) as \"endpoints\" in O(1) using math. The problem with this idea is that its still expensive (O(n^2)) to find all the endpoint combinations. I thought this was clever enough because we take advantage of sorting, but it\\'s not as good as it can be. \\n\\nSo to make this process cheaper, we turn to memoization. If you write out all the calculations using the current element as the largest, you start to see a pattern: say we have [1, 2, 3, 4]\\n1. 1^2 * (1), assuming we end at high - 1, and then there is one subset that starts at a number <= 1. \\n2. 2^2 * (1 + 2), since there are two sets with numbers that start at a number <= 2. \\n3. 3^2 * (1 + 1 + 2 + 3), since there are two sets that start at 1 and end at 3, one set that starts at two and ends at three, and one set that starts and ends at three. \\n4. 4^2 * (1 + 1 + 1 + 1 + 2 + 2 + 3 + 4), which you can reason out. \\n\\nThe thing to notice is that for steps 3 and 4 (1 + 1 + 2) * 2 = (1 + 1 + 1 + 1 + 2 + 2), and this \"rule\" holds for any two consecutive steps. The reason for this is very simple:\\n\\n1. If I know the number of subsets that start with number N, then the number of subsets doubles in size if we add an extra position / number to be factored into the subsets. (2^(n) * 2) = 2^(n+1) subsets. \\n\\nThis allows us to use the last solution to solve the next one, which is memoization and also can be thought of as dynamic programming. The code shows this idea much more clearly. \\n\\nNote that we must sort, because it provides an ordering allowing us to memoize the previous solution, since all previous numbers at any iteration are strictly <= the current number. \\n\\n# Complexity\\n- Time complexity: O(nlogn) because of sorting domination. \\n\\n- Space complexity: O(1) because we just use pointers. \\n\\n# Code\\n```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        nums.sort()\\n        last = 0\\n        lastNum = 0\\n        total = 0\\n        for num in nums:\\n            total += (num**2) * (last * 2 + lastNum + num)\\n            last *= 2\\n            last += lastNum\\n            lastNum = num\\n        return total % (10**9 + 7)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        nums.sort()\\n        last = 0\\n        lastNum = 0\\n        total = 0\\n        for num in nums:\\n            total += (num**2) * (last * 2 + lastNum + num)\\n            last *= 2\\n            last += lastNum\\n            lastNum = num\\n        return total % (10**9 + 7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532367,
                "title": "python-3-sorting-brute-force-tle-approach",
                "content": "Sorting\\n\\n# Code\\n```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        #O(N LOGN), O(N)\\n        MOD =   pow(10, 9) + 7\\n        nums.sort()\\n        powerSum    =   accProduct  =   0\\n        for i, val in enumerate(nums):\\n            powerSum    =   (powerSum +  pow(val,2,MOD) * (val + accProduct))  %   MOD  \\n            accProduct  =   ((accProduct<<1) + val)  %   MOD       #f(i) = 2*f(i-1) + nums[i]\\n        return powerSum\\n\\n        #TLE:   O(N**2), O(1)\\n        MOD =   pow(10, 9) + 7\\n        nums.sort()\\n        result  =   0\\n        for left in range(len(nums)):\\n            minVal  =   nums[left]\\n            for right in range(left, len(nums)):\\n                maxVal  =   nums[right]\\n                length  =   1<<max(0,right-left-1)                \\n                result  +=  minVal*maxVal*maxVal*length\\n                result  %=  MOD\\n        return result\\n\\n\\n\\n        #TLE:   O(N!), O(1)\\n        MOD =   pow(10,9) + 7\\n        sumPower    =   0\\n\\n        for groupLen in range(1, len(nums) + 1):\\n            for groupIndexes in itertools.combinations(   range(len(nums)), groupLen):\\n                groupMax, groupMin  =   -math.inf, math.inf\\n                #print(groupLen, groups)\\n                for i in groupIndexes:\\n                    groupMax    =   max(    groupMax, nums[i])\\n                    groupMin    =   min(    groupMin, nums[i])\\n                #print(groupLen, groups, groupMax, groupMin)\\n                sumPower    +=  groupMax * groupMax * groupMin\\n                sumPower    %=  MOD\\n\\n        return sumPower\\n```",
                "solutionTags": [
                    "Python3",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        #O(N LOGN), O(N)\\n        MOD =   pow(10, 9) + 7\\n        nums.sort()\\n        powerSum    =   accProduct  =   0\\n        for i, val in enumerate(nums):\\n            powerSum    =   (powerSum +  pow(val,2,MOD) * (val + accProduct))  %   MOD  \\n            accProduct  =   ((accProduct<<1) + val)  %   MOD       #f(i) = 2*f(i-1) + nums[i]\\n        return powerSum\\n\\n        #TLE:   O(N**2), O(1)\\n        MOD =   pow(10, 9) + 7\\n        nums.sort()\\n        result  =   0\\n        for left in range(len(nums)):\\n            minVal  =   nums[left]\\n            for right in range(left, len(nums)):\\n                maxVal  =   nums[right]\\n                length  =   1<<max(0,right-left-1)                \\n                result  +=  minVal*maxVal*maxVal*length\\n                result  %=  MOD\\n        return result\\n\\n\\n\\n        #TLE:   O(N!), O(1)\\n        MOD =   pow(10,9) + 7\\n        sumPower    =   0\\n\\n        for groupLen in range(1, len(nums) + 1):\\n            for groupIndexes in itertools.combinations(   range(len(nums)), groupLen):\\n                groupMax, groupMin  =   -math.inf, math.inf\\n                #print(groupLen, groups)\\n                for i in groupIndexes:\\n                    groupMax    =   max(    groupMax, nums[i])\\n                    groupMin    =   min(    groupMin, nums[i])\\n                #print(groupLen, groups, groupMax, groupMin)\\n                sumPower    +=  groupMax * groupMax * groupMin\\n                sumPower    %=  MOD\\n\\n        return sumPower\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530869,
                "title": "best-explaination-with-intuition-approach-tc-sc",
                "content": "# Intuition\\n        EXAMPLE-1:\\n        nums: 1 2 3 4\\n        \\n        For 4 to be the maximum,\\n        4\\n        1,4\\n        2,4\\n        3,4\\n        1,2,4\\n        1,3,4\\n        2,3,4\\n        1,2,3,4\\n        Ans = (4^2) * [4*(1) + 1*(4) + 2*(2) + 3*(1)]\\n             sq_Max           sum_Mins\\n        \\n        Note: For 3 multiply by 1, for 2 multiply by 2 ,for 1 multiply by 4 => so  multples of 2 in left of 4\\n        ----------------------\\n        EXAMPLE-2:\\n        nums: 1 2 3\\n\\n        For 4 to be the maximum,\\n        3\\n        1,3\\n        2,3\\n        1,2,3\\n\\n        Ans = (3^2)*[3*(1) + 1*(2) + 2*(1)]\\n             sq_Max          sum_Mins\\n        \\n    \\n\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n $$O(1)$$\\n\\n# Code 1: [TLE]\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int sumOfPower(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans = 0;\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=0;i<n;i++){\\n            long long sq_max = (1LL*nums[i]*nums[i])%mod;\\n            long long sum_of_mins = nums[i];        //Own Min\\n            long long count = 1;\\n            for(int j=i-1;j>=0;j--){\\n                sum_of_mins = (sum_of_mins + (count*nums[j])%mod)%mod;\\n                count = (count*2)%mod;\\n            }\\n\\n            ans = (ans + (sq_max*sum_of_mins)%mod)%mod;\\n        }\\n        \\n        return ans;\\n\\n        \\n    }\\n   \\n};\\n```\\n\\n---\\n\\n# Approach 2\\n    EXAMPLE-2:\\n        nums: 1 2 3\\n\\n        For 4 to be the maximum,\\n        3\\n        1,3\\n        2,3\\n        1,2,3\\n\\n        Ans = (3^2)*[3*(1) + 1*(2) + 2*(1)] = 9* [7]  [HERE]\\n             sq_Max          sum_Mins\\n\\n        To Find Mins_Sum: 2*prev_min + nums[i] -nums[i-1]\\n        n=0: m = nums[0]=1  [1]\\n        n=1: m = 2*1 +2 -1 = 3\\n        n=2: m = 2*3 + 4 -3 = 7 [See ABOVE] matches\\n\\n# Intuition\\n    Consider [a,b,c]\\n         Sq_Max  Sum_Mins    2*sum_prev_mins + nums[i] - nums[i-1]\\n    a => (a*a) * (a)\\n    b => (b*b) * (b+a)  => 2*(a) + b - a = a + b \\n    c => (c*c) * (c+b+2a) => 2*(a+b) + c - b = 2*a + b + c\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n $$O(1)$$\\n\\n\\n\\n\\n# Code 2\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int sumOfPower(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans = 0 , sum_prev_mins = 0;\\n        \\n        sort(nums.begin(),nums.end());\\n   \\n        for(int i=0;i<n;i++){\\n            long long sq_max = (1LL*nums[i]*nums[i])%mod;\\n            long long sum_of_mins = i==0? nums[i] : (2*sum_prev_mins + nums[i] - nums[i-1])%mod;  \\n\\n            ans = (ans + (sq_max*sum_of_mins)%mod)%mod;\\n            sum_prev_mins = sum_of_mins; \\n        }\\n        \\n        return ans;\\n\\n        \\n    }\\n   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int sumOfPower(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans = 0;\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=0;i<n;i++){\\n            long long sq_max = (1LL*nums[i]*nums[i])%mod;\\n            long long sum_of_mins = nums[i];        //Own Min\\n            long long count = 1;\\n            for(int j=i-1;j>=0;j--){\\n                sum_of_mins = (sum_of_mins + (count*nums[j])%mod)%mod;\\n                count = (count*2)%mod;\\n            }\\n\\n            ans = (ans + (sq_max*sum_of_mins)%mod)%mod;\\n        }\\n        \\n        return ans;\\n\\n        \\n    }\\n   \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9+7;\\n    int sumOfPower(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans = 0 , sum_prev_mins = 0;\\n        \\n        sort(nums.begin(),nums.end());\\n   \\n        for(int i=0;i<n;i++){\\n            long long sq_max = (1LL*nums[i]*nums[i])%mod;\\n            long long sum_of_mins = i==0? nums[i] : (2*sum_prev_mins + nums[i] - nums[i-1])%mod;  \\n\\n            ans = (ans + (sq_max*sum_of_mins)%mod)%mod;\\n            sum_prev_mins = sum_of_mins; \\n        }\\n        \\n        return ans;\\n\\n        \\n    }\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529728,
                "title": "question-on-possible-follow-up",
                "content": "I read the problem wrong initially and thought the question was asking about subarrays (all the indices are next to each other). So if the problem was asking about subarrays instead. Would it be possible to do this in less than O(n^2) time? I don\\'t think it is.",
                "solutionTags": [],
                "code": "I read the problem wrong initially and thought the question was asking about subarrays (all the indices are next to each other). So if the problem was asking about subarrays instead. Would it be possible to do this in less than O(n^2) time? I don\\'t think it is.",
                "codeTag": "Unknown"
            },
            {
                "id": 3528182,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int mod = 1000000007;\\n    \\n    public int sumOfPower(int[] nums) {\\n        long ans = 0;\\n        long prevSum = 0;\\n\\n        Arrays.sort(nums);\\n\\n        for(long n : nums) {\\n            ans = (ans + ((n*n) % mod * n) % mod + ((n*n) % mod * prevSum) % mod) % mod;\\n            prevSum = (prevSum * 2 + n) % mod;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int mod = 1000000007;\\n    \\n    public int sumOfPower(int[] nums) {\\n        long ans = 0;\\n        long prevSum = 0;\\n\\n        Arrays.sort(nums);\\n\\n        for(long n : nums) {\\n            ans = (ans + ((n*n) % mod * n) % mod + ((n*n) % mod * prevSum) % mod) % mod;\\n            prevSum = (prevSum * 2 + n) % mod;\\n        }\\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528143,
                "title": "c-with-explanation",
                "content": "# Intuition\\nObserve the series\\nObserve all the groups(subsequences) required to compute ans[i] (last row)\\n\\n# Approach\\n![20230515_232436.jpg](https://assets.leetcode.com/users/images/ac710b50-d0c9-4585-b62c-5a591626959d_1684173414.9384253.jpeg)\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int modProd(long long a, long long b) {\\n        a%=mod;\\n        b%=mod;\\n        return (a*b)%mod;\\n    }\\n\\n    int sumOfPower(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n\\n        long long sumOfLastMin=0, sumOfAllMin=0, ans=0;\\n        for(auto it: nums) {\\n            sumOfLastMin= sumOfAllMin + it;\\n            ans += modProd(sumOfLastMin,modProd(it,it));\\n            sumOfAllMin += sumOfLastMin;\\n\\n            sumOfLastMin%=mod;\\n            sumOfAllMin%=mod;\\n            ans%=mod;\\n            \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int modProd(long long a, long long b) {\\n        a%=mod;\\n        b%=mod;\\n        return (a*b)%mod;\\n    }\\n\\n    int sumOfPower(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n\\n        long long sumOfLastMin=0, sumOfAllMin=0, ans=0;\\n        for(auto it: nums) {\\n            sumOfLastMin= sumOfAllMin + it;\\n            ans += modProd(sumOfLastMin,modProd(it,it));\\n            sumOfAllMin += sumOfLastMin;\\n\\n            sumOfLastMin%=mod;\\n            sumOfAllMin%=mod;\\n            ans%=mod;\\n            \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527099,
                "title": "golang-82-ms-8-6-mb",
                "content": "# Complexity\\n- Time complexity: $$O(n*logn)$$\\n- Space complexity: $$O(1)$$\\n# Code\\n```\\nfunc sumOfPower(nums []int) int {\\n\\tmod := 1_000_000_007\\n\\tsort.Ints(nums)\\n\\tvar sum, result int\\n\\tfor _, num := range nums {\\n\\t\\tresult = (result + (num*num%mod)*(num+sum)) % mod\\n\\t\\tsum = (sum<<1 + num) % mod\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc sumOfPower(nums []int) int {\\n\\tmod := 1_000_000_007\\n\\tsort.Ints(nums)\\n\\tvar sum, result int\\n\\tfor _, num := range nums {\\n\\t\\tresult = (result + (num*num%mod)*(num+sum)) % mod\\n\\t\\tsum = (sum<<1 + num) % mod\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3526442,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(NlogN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int sumOfPower(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        \\n        int i,n;\\n        n=nums.size();\\n        \\n        long long ans,mod,pw;\\n        ans=0;\\n        mod=1000000007;\\n        \\n        ans+=(((1LL*nums[0]*nums[0])%mod)*nums[0])%mod;\\n        ans%=mod;\\n        pw=nums[0];\\n\\n        for(i=1;i<n;i++)\\n        {\\n            pw=(2*pw-nums[i-1]+nums[i])%mod;\\n            ans+=(((1LL*nums[i]*nums[i])%mod)*pw)%mod;\\n            ans%=mod;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int sumOfPower(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        \\n        int i,n;\\n        n=nums.size();\\n        \\n        long long ans,mod,pw;\\n        ans=0;\\n        mod=1000000007;\\n        \\n        ans+=(((1LL*nums[0]*nums[0])%mod)*nums[0])%mod;\\n        ans%=mod;\\n        pw=nums[0];\\n\\n        for(i=1;i<n;i++)\\n        {\\n            pw=(2*pw-nums[i-1]+nums[i])%mod;\\n            ans+=(((1LL*nums[i]*nums[i])%mod)*pw)%mod;\\n            ans%=mod;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526418,
                "title": "easy-simple-c-15-lines-code-with-approach",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLets first see the constraints : n = 1e5 . So we have to solve it in less than O(n^2) \\n\\nAs there are 2^n possible subsets , which will give tle . \\nNow think of some monotonic stack technique , where we just take a decision on every element and solve our problem . But here if we find that nums[i] will be maximum for k1(random no ) subsets and nums[i] will be minimum for k2(random no ) subsets. After doing some stuff we will see that it is not usefull and no pattern exists .\\n   \\n`let arr = {2 , 1 , 4 , 3 } we will use 0 based indexing`\\nlets sort the array .  `arr = {1 , 2 , 3 , 4 }`\\nNow think that if **3(index 2)** is the maximum element of subset then how many subsets are there . If you have some basic permutation knowlege then all the elements can occur or not in 2 ways(there or not there ) .\\nIn same ways :\\n1 - 2 ways \\n2 - 2 ways   \\n3 - 1 way as it is maximum it have to be there \\n4 - 0 ways . as 3 is maximum so all elemets greater than 3 cannot occur .\\nNo of ways to form a subset succh that 3 is the maximum number is 2^(number ofelements less than 3 ) . Here in our example are 4 .\\n```\\n{1, 3 } , {1 , 2 , 3  } , {2 , 3 } , {3} \\n```\\n\\nNow after taking every index element as maximum and nums[i] as mimimum ,equation is except the subset of length 1 {1} , {2} , {3} , {4} which we will handle explicitly  :\\n```\\n4 is maximum :  \\n{4 , 3 } = 2^0 * (4* 4 * 3 )\\n{4 , 3 , 2 } =  2^1 * (4* 4 * 2 )\\n{4 , 3 , 2 , 1 } =  2^2 * (4* 4 * 1 )\\n\\n```\\n```\\n3 is maximum :  \\n{ 3 , 2 } =  2^0 * (3*3 * 2 )\\n{ 3 , 2 , 1 } =  2^1 * (3* 3 * 1 )\\n\\n```\\n```\\n2 is maximum :  \\n{ 2 , 1 } =  2^0 * (2*2 * 1 )\\n\\n```\\n\\nNow combining all the terms \\n```\\n2*2*(2^0 x 1) + 3*3*(2^0 * 2 + 2^1 * 1 ) + 4*4(2^0 * 3 + 2^1 * 2 + 2^2 * 1 )\\n```\\nHere if we see inner terms of bracket, they forms a pattern .\\n \\nfinally code steps are : \\nmove from right to left . take current element as maximum . and analyse the pattern for minimum element .\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O( N + NlogN ) \\n    N = traversal \\n    NlogN = sorting the nums array \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1) \\n    only constants are used\\n\\n# Code\\n```\\n#define ll long long \\nconst int mod = 1e9 + 7 ;\\nll mult(ll a , ll b ){\\n    ll res = (a * 1LL * b ) % mod ;\\n    if(res < 0 ) res += mod ; \\n    return res ; \\n}\\nll add(ll a , ll b){\\n    ll res = (a + b ) % mod ;\\n    if(res < 0 ) res += mod ; \\n    return res ;\\n}\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        sort(nums.begin() , nums.end()) ;\\n        int n = nums.size() ;\\n        ll bs = 0 , k = 1 , ans = 0 ;\\n        ll inv2 = (mod - mod/2) % mod ;\\n        for(int i = n-1 ; i>=0 ; --i ){\\n            bs = add( bs , mult( k ,  nums[i] )  ) ;\\n            k = mult(k , 2) ; \\n            ll tp = mult(nums[i] , mult(nums[i] , nums[i])) ; \\n            ans = add( ans , tp ) ;\\n        }\\n        for(int i = n-1 ; i>=0 ; --i ){\\n            bs = add(bs , -nums[i] ) ;\\n            bs = mult(bs , inv2 ) ;\\n            ans = add(ans , mult(bs , mult(nums[i] , nums[i] ) ) );\\n        }\\n        return ans ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Number Theory"
                ],
                "code": "```\\n{1, 3 } , {1 , 2 , 3  } , {2 , 3 } , {3} \\n```\n```\\n4 is maximum :  \\n{4 , 3 } = 2^0 * (4* 4 * 3 )\\n{4 , 3 , 2 } =  2^1 * (4* 4 * 2 )\\n{4 , 3 , 2 , 1 } =  2^2 * (4* 4 * 1 )\\n\\n```\n```\\n3 is maximum :  \\n{ 3 , 2 } =  2^0 * (3*3 * 2 )\\n{ 3 , 2 , 1 } =  2^1 * (3* 3 * 1 )\\n\\n```\n```\\n2 is maximum :  \\n{ 2 , 1 } =  2^0 * (2*2 * 1 )\\n\\n```\n```\\n2*2*(2^0 x 1) + 3*3*(2^0 * 2 + 2^1 * 1 ) + 4*4(2^0 * 3 + 2^1 * 2 + 2^2 * 1 )\\n```\n```\\n#define ll long long \\nconst int mod = 1e9 + 7 ;\\nll mult(ll a , ll b ){\\n    ll res = (a * 1LL * b ) % mod ;\\n    if(res < 0 ) res += mod ; \\n    return res ; \\n}\\nll add(ll a , ll b){\\n    ll res = (a + b ) % mod ;\\n    if(res < 0 ) res += mod ; \\n    return res ;\\n}\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        sort(nums.begin() , nums.end()) ;\\n        int n = nums.size() ;\\n        ll bs = 0 , k = 1 , ans = 0 ;\\n        ll inv2 = (mod - mod/2) % mod ;\\n        for(int i = n-1 ; i>=0 ; --i ){\\n            bs = add( bs , mult( k ,  nums[i] )  ) ;\\n            k = mult(k , 2) ; \\n            ll tp = mult(nums[i] , mult(nums[i] , nums[i])) ; \\n            ans = add( ans , tp ) ;\\n        }\\n        for(int i = n-1 ; i>=0 ; --i ){\\n            bs = add(bs , -nums[i] ) ;\\n            bs = mult(bs , inv2 ) ;\\n            ans = add(ans , mult(bs , mult(nums[i] , nums[i] ) ) );\\n        }\\n        return ans ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526076,
                "title": "easy-solution-observation-from-small-pattern",
                "content": "# Intuition\\n1) Solve for smaller inputs. There is a pattern where the contribution of minimums for each minimum value increases by pow(2, 0)\\n\\nFor eg  [ 1 2 4 6]\\n\\nContribution for  max 1. -> 1\\n\\nContribution for  max 2 ->  2 + 1 * pow(2, 0)\\n\\nContribution for max 4 -> 4 + 2 * pow(2, 0) + 1 * pow(2, 1)\\n\\nContribution for max 6 -> 6 + 4 * pow(2,0) + 2 * pow(2, 1) + 1 * pow(2, 2)\\n\\n\\ncontribution for n -> 2 * (n -1) + nums[i] -  nums[i-1]\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nint mod = 1e9 + 7;\\n\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n\\n        int n = nums.size();\\n        sort( nums.begin(), nums.end());\\n        long long sum = 0;\\n        long long  val = nums[0];\\n        for( int i = 0 ; i < n; i++) {\\n            sum = (sum + ((((long long)nums[i] * (long long)nums[i])% mod) * val) %mod) % mod;\\n            if( i < n-1 ) {\\n                val = (((val * 2)% mod) + (nums[i+1] - nums[i]))% mod;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint mod = 1e9 + 7;\\n\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n\\n        int n = nums.size();\\n        sort( nums.begin(), nums.end());\\n        long long sum = 0;\\n        long long  val = nums[0];\\n        for( int i = 0 ; i < n; i++) {\\n            sum = (sum + ((((long long)nums[i] * (long long)nums[i])% mod) * val) %mod) % mod;\\n            if( i < n-1 ) {\\n                val = (((val * 2)% mod) + (nums[i+1] - nums[i]))% mod;\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524987,
                "title": "track-number-of-subsets-where-index-i-is-the-minimum-element",
                "content": "# Intuition\\nSort the array. At index i, we have $2^i$ subsets with nums[i] as the max element. For every index j < i, there are $2^{i-j-1}$ subsets with nums[j] as the minimum element, and one subset with nums[i] as the minimum element. When we go from index i to index i+1, the amount of times each index < i+1 is the minimum in the subset doubles (except for index i, which remains at 1).\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*lgn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        nums.sort()\\n        total = 0\\n        s = 0\\n        for i in range(len(nums)):\\n            num = nums[i]\\n            if i == 0:\\n                s = num\\n            else:\\n                s -= nums[i-1]\\n                s *= 2\\n                s += nums[i-1] + nums[i]\\n            total += (num**2)*(s)\\n        return total % ((10**9)+7)\\n```",
                "solutionTags": [
                    "Python3",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        nums.sort()\\n        total = 0\\n        s = 0\\n        for i in range(len(nums)):\\n            num = nums[i]\\n            if i == 0:\\n                s = num\\n            else:\\n                s -= nums[i-1]\\n                s *= 2\\n                s += nums[i-1] + nums[i]\\n            total += (num**2)*(s)\\n        return total % ((10**9)+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524444,
                "title": "sort-then-dp-simple-math-formula",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int sumOfPower(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        vector<long long> dp(n);\\n        long long x = nums[0];\\n        long long prev = x * x;\\n        dp[0] = x * x;\\n        for(int i = 1; i < n; i++)\\n        {\\n            long long curr = (long long)nums[i] * (long long)nums[i];\\n            dp[i] = dp[i - 1] * 2 % mod+ (curr - prev) % mod;\\n            if(dp[i] < 0)dp[i] += mod;\\n            prev = curr;\\n\\n        }        \\n        long long res = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            dp[i] %= mod;\\n            res += (dp[i] * nums[i]) % mod;\\n            res %= mod;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod = 1e9 + 7;\\n    int sumOfPower(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        vector<long long> dp(n);\\n        long long x = nums[0];\\n        long long prev = x * x;\\n        dp[0] = x * x;\\n        for(int i = 1; i < n; i++)\\n        {\\n            long long curr = (long long)nums[i] * (long long)nums[i];\\n            dp[i] = dp[i - 1] * 2 % mod+ (curr - prev) % mod;\\n            if(dp[i] < 0)dp[i] += mod;\\n            prev = curr;\\n\\n        }        \\n        long long res = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            dp[i] %= mod;\\n            res += (dp[i] * nums[i]) % mod;\\n            res %= mod;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524152,
                "title": "go-solution",
                "content": "```\\nfunc sumOfPower(a []int) int {\\n    sort.Ints(a)\\n    \\n    mod := int64(1000000007)\\n    res := int64(0)\\n    rightSum := int64(0)\\n    \\n    for i := len(a) - 1; i >= 0; i-- {\\n        x := int64(a[i])\\n        x *= x\\n        x %= mod\\n        \\n        res += int64(a[i]) * x\\n        res %= mod\\n        res += int64(a[i]) * rightSum\\n        res %= mod\\n        \\n        rightSum *= 2\\n        rightSum += x\\n        rightSum %= mod\\n    }   \\n    \\n    return int(res)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc sumOfPower(a []int) int {\\n    sort.Ints(a)\\n    \\n    mod := int64(1000000007)\\n    res := int64(0)\\n    rightSum := int64(0)\\n    \\n    for i := len(a) - 1; i >= 0; i-- {\\n        x := int64(a[i])\\n        x *= x\\n        x %= mod\\n        \\n        res += int64(a[i]) * x\\n        res %= mod\\n        res += int64(a[i]) * rightSum\\n        res %= mod\\n        \\n        rightSum *= 2\\n        rightSum += x\\n        rightSum %= mod\\n    }   \\n    \\n    return int(res)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3523884,
                "title": "python3-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. As we need to find all combination, initial order in array does not matter; Lastly, a sorted array is easier to handle given min and max will just be end points\\n2. Now given we are looking at two end points let say (i,j where i<j) and try to find all arrays given min is fixed to i and max to j\\n    1. For all elements in between i and j we have two choices : Take the element or ignore the element \\n    2. Illustration : min a b c d e f max\\n    3. Choices :        1   2 2 2 2 2 2 1\\n    4. Hence Total Contribution : (max ** 2) * min * (2**(j-i-1))\\n3. Now we can try solving the problem as a Two pointer problem where we can calculate the contribution by a (min,max) pair (i,j) and move forward to calculating contribution of next pairs (i+1,j) or (i,j-1)\\n4. Additionally we can add a visited pair dictionary cache to avoid extra work; FYI this will give you a TLE \\n5. From the above approach it is clear we want to use a DP; We need to find a way to convert our 2D DP to 1D DP\\n6. To understand this solution Mathematically look into the following Explanation : [https://leetcode.com/problems/power-of-heroes/solutions/3520233/c-java-python-sort-and-enumerate-each-maximum-value/](https://leetcode.com/problems/power-of-heroes/solutions/3520233/c-java-python-sort-and-enumerate-each-maximum-value/)\\n7. Adding an Illustration below :\\n    1. Basic Definitions : Let DP[i] be power of Heros if we consider entries in sorted array till i th entry nums[:i+1]\\n    2. Illustration Example : Sorted Array : [1,2,4,5,7,9]\\n        1. If we just consider [1] Power of Heros : 1**2 * (1+0)\\n        2. Now when we add [2] Additional contribution because of 2 : 2**2 * (2 + 1 +0*2)\\n        3. Now when we add [4] Additional contribution because of 4 : 4**2 * (4 + 2 + 1*2)\\n        4. Now when we add [5] Additional contribution because of 5 : 5**2 * (5 + 4 + 2*2 + 1*2*2)\\n        5. Now when we add [7] Additional contribution because of 7 : 7**2 * (7 + 5 + 4*2 + 2*2*2 + 1*2*2*2)  \\n        \\n        Looking at this we see easy way to calculate contribution due to addition of an element : S[i]=nums[i-1]+2*S[i-1]\\n\\n# Code\\n\\n# 2D DP Time Complexity O(n ** 2); Space Complexity O(n ** 2)  TLE\\n\\n```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        \\n        res=[0]\\n        nums.sort()\\n        \\n        cache={}\\n        \\n        def dfs(left,right):\\n            \\n            if left>right:\\n                return\\n            \\n            if (left,right) in cache:\\n                return\\n            #print(\"nums[left],nums[right] : \",nums[left],nums[right])\\n            length=right-left-1\\n            if right==left:\\n                length=0\\n            res[0]+=((nums[right]**2)*(nums[left])*(2**length))%((10**9)+7)\\n            cache[(left,right)]=True\\n            dfs(left+1,right)\\n            dfs(left,right-1)\\n            return \\n        \\n        dfs(0,len(nums)-1)\\n        return res[0]%((10**9)+7)\\n        \\n        \\n        \\n\\n```\\n\\n# 1D DP Time Complexity O(n); Space Complexity O(n) \\n\\n```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n=len(nums)\\n        total = nums[0]**3\\n        S=[0]*n\\n        for i in range(1,n):\\n            total+=nums[i]**3\\n            S[i]=nums[i-1]+2*S[i-1]\\n            total+=(nums[i]**2)*S[i]\\n        return total % (7+10**9)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        \\n        res=[0]\\n        nums.sort()\\n        \\n        cache={}\\n        \\n        def dfs(left,right):\\n            \\n            if left>right:\\n                return\\n            \\n            if (left,right) in cache:\\n                return\\n            #print(\"nums[left],nums[right] : \",nums[left],nums[right])\\n            length=right-left-1\\n            if right==left:\\n                length=0\\n            res[0]+=((nums[right]**2)*(nums[left])*(2**length))%((10**9)+7)\\n            cache[(left,right)]=True\\n            dfs(left+1,right)\\n            dfs(left,right-1)\\n            return \\n        \\n        dfs(0,len(nums)-1)\\n        return res[0]%((10**9)+7)\\n        \\n        \\n        \\n\\n```\n```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n=len(nums)\\n        total = nums[0]**3\\n        S=[0]*n\\n        for i in range(1,n):\\n            total+=nums[i]**3\\n            S[i]=nums[i-1]+2*S[i-1]\\n            total+=(nums[i]**2)*S[i]\\n        return total % (7+10**9)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523808,
                "title": "python-sort-prefix-sum-o-n-log-n",
                "content": "1. Sort `nums` in ascending order.\\n2. We seperate all groups into two kinds:\\n\\t- (part A) groups consisting of only one element.\\n\\t- (part B) groups containing at least two elements.\\n3. For a group in A, say {s_i}, the power is {s_i}^3. \\nFor a group in B, say {s_i, ..., s_j}, there\\'re 2^{j-i-1} elements between s_i and s_j, so the power of the group is s_i * s_j^2 * 2^{j-i-1}.\\n4. Hence the sum of the power of all groups is\\n<img src=\"https://assets.leetcode.com/users/images/b0c6ee7f-5c7a-458f-9d1f-231e008ca2bd_1684066279.753907.png\" width=\"30%\" />\\nthe two summations comes from part A and part B, respectively.\\n5. To speed up, note that part B can be written as following:\\n<img src=\"https://assets.leetcode.com/users/images/52b8317c-3fb4-4c52-814d-790c7e4ebdee_1684067984.7392282.png\" width=\"30%\"  />\\nThe values in parentheses follows\\n<img src=\"https://assets.leetcode.com/users/images/3485aa7a-6033-4444-9b9e-72c5752d36d4_1684068295.1183362.png\" width=\"30%\" />\\nHence we can calculate part B in a more efficient way.\\n```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        mod = 1000000007\\n        nums.sort()\\n        \\n        ans = nums[0]**3 % mod\\n        S = 0\\n        for j, n in enumerate(nums[1:], start=1):\\n            S = (S + S + nums[j-1]) % mod\\n            ans = (ans + n*n*(n+S)) % mod\\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "1. Sort `nums` in ascending order.\\n2. We seperate all groups into two kinds:\\n\\t- (part A) groups consisting of only one element.\\n\\t- (part B) groups containing at least two elements.\\n3. For a group in A, say {s_i}, the power is {s_i}^3. \\nFor a group in B, say {s_i, ..., s_j}, there\\'re 2^{j-i-1} elements between s_i and s_j, so the power of the group is s_i * s_j^2 * 2^{j-i-1}.\\n4. Hence the sum of the power of all groups is\\n<img src=\"https://assets.leetcode.com/users/images/b0c6ee7f-5c7a-458f-9d1f-231e008ca2bd_1684066279.753907.png\" width=\"30%\" />\\nthe two summations comes from part A and part B, respectively.\\n5. To speed up, note that part B can be written as following:\\n<img src=\"https://assets.leetcode.com/users/images/52b8317c-3fb4-4c52-814d-790c7e4ebdee_1684067984.7392282.png\" width=\"30%\"  />\\nThe values in parentheses follows\\n<img src=\"https://assets.leetcode.com/users/images/3485aa7a-6033-4444-9b9e-72c5752d36d4_1684068295.1183362.png\" width=\"30%\" />\\nHence we can calculate part B in a more efficient way.\\n```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        mod = 1000000007\\n        nums.sort()\\n        \\n        ans = nums[0]**3 % mod\\n        S = 0\\n        for j, n in enumerate(nums[1:], start=1):\\n            S = (S + S + nums[j-1]) % mod\\n            ans = (ans + n*n*(n+S)) % mod\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 3523746,
                "title": "c-o-nlogn-7-liners-solution",
                "content": "```\\nint sumOfPower(vector<int>& nums) \\n{\\n\\tlong long result=0,n=nums.size(),s=0,p=0,d=1000000007;\\n\\tsort(nums.begin(),nums.end());\\n\\tfor(int i=0;i<n;i++)\\n\\t{\\n\\t\\ts=(p+nums[i])%d;\\n\\t\\tp=(p+s)%d;\\n\\t\\tresult=(result+(((s*nums[i])%d)*nums[i])%d)%d;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint sumOfPower(vector<int>& nums) \\n{\\n\\tlong long result=0,n=nums.size(),s=0,p=0,d=1000000007;\\n\\tsort(nums.begin(),nums.end());\\n\\tfor(int i=0;i<n;i++)\\n\\t{\\n\\t\\ts=(p+nums[i])%d;\\n\\t\\tp=(p+s)%d;\\n\\t\\tresult=(result+(((s*nums[i])%d)*nums[i])%d)%d;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3523583,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int power(int base, int p) {\\n        int res = 1;\\n        while (p > 0) {\\n            if (p & 1) {\\n                res = ((long long) res * base) % mod;\\n            }\\n            base = ((long long) base * base) % mod;\\n            p /= 2;\\n        }\\n        return res;\\n    }\\n    int square(int num) {\\n        return ((long long) num * num) % mod;\\n    }\\n    int sumOfPower(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<int> suffix(n + 1);\\n        for (int i = n - 1; i >= 0; i--) {\\n            suffix[i] = (suffix[i + 1] + ((long long) square(nums[i]) * power(2, i - 1)) % mod) % mod;\\n        }\\n        int sol = 0;\\n        for (int i = 0; i < n; i++) {\\n            sol = (sol + power(nums[i], 3)) % mod;\\n            if (i + 1 < n) {\\n                int suff = suffix[i + 1];\\n                int deno = power(2, i);\\n                int inv = power(deno, mod - 2);\\n                suff = ((long long) suff * inv) % mod;\\n                sol = (sol + ((long long) nums[i] * suff) % mod) % mod;\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 1e9 + 7;\\n    int power(int base, int p) {\\n        int res = 1;\\n        while (p > 0) {\\n            if (p & 1) {\\n                res = ((long long) res * base) % mod;\\n            }\\n            base = ((long long) base * base) % mod;\\n            p /= 2;\\n        }\\n        return res;\\n    }\\n    int square(int num) {\\n        return ((long long) num * num) % mod;\\n    }\\n    int sumOfPower(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<int> suffix(n + 1);\\n        for (int i = n - 1; i >= 0; i--) {\\n            suffix[i] = (suffix[i + 1] + ((long long) square(nums[i]) * power(2, i - 1)) % mod) % mod;\\n        }\\n        int sol = 0;\\n        for (int i = 0; i < n; i++) {\\n            sol = (sol + power(nums[i], 3)) % mod;\\n            if (i + 1 < n) {\\n                int suff = suffix[i + 1];\\n                int deno = power(2, i);\\n                int inv = power(deno, mod - 2);\\n                suff = ((long long) suff * inv) % mod;\\n                sol = (sol + ((long long) nums[i] * suff) % mod) % mod;\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523441,
                "title": "c-o-n-logn-o-1-memory-short-sln",
                "content": "\\n```\\n    using ll = long long;\\n    int sumOfPower(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        constexpr ll MOD = 1\\'000\\'000\\'007;\\n        ll minSum = 0, ans = 0;\\n        for (const auto v: nums) {\\n            ans = (ans + (ll(v) * v % MOD) * (v + minSum)) % MOD;\\n            minSum = (v + minSum * 2) % MOD;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    using ll = long long;\\n    int sumOfPower(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        constexpr ll MOD = 1\\'000\\'000\\'007;\\n        ll minSum = 0, ans = 0;\\n        for (const auto v: nums) {\\n            ans = (ans + (ll(v) * v % MOD) * (v + minSum)) % MOD;\\n            minSum = (v + minSum * 2) % MOD;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3523123,
                "title": "easy-to-understand-pattern-beats-80-in-memory-usage",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust simple math equation solving\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStart with small array size examples like start from size 1 to 5 and you will notice a pattern coming up and solve that pattern to form a mathematical approach or a equation to that pattern and solve the question keeping in mind to modulo it with 10^9 + 7.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlog(n))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\n#define ll long long int\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        ll sum =0;\\n        ll res = (ll)nums[0]%mod;\\n        ll ans= ((res%mod*res%mod)%mod*res%mod)%mod;\\n        for(int i=1;i<n;i++){\\n            ll p = (ll)nums[i]%mod;\\n            ll q = (ll)nums[i-1]%mod;\\n            ll res = (((p%mod*p%mod)%mod)*(((sum%mod)*2)%mod + p%mod + q%mod)%mod)%mod;\\n            ans += res%mod;\\n            ans %= mod;\\n            sum += (sum%mod + q%mod)%mod;\\n            sum %=mod;\\n        }\\n        return ans%mod; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        ll sum =0;\\n        ll res = (ll)nums[0]%mod;\\n        ll ans= ((res%mod*res%mod)%mod*res%mod)%mod;\\n        for(int i=1;i<n;i++){\\n            ll p = (ll)nums[i]%mod;\\n            ll q = (ll)nums[i-1]%mod;\\n            ll res = (((p%mod*p%mod)%mod)*(((sum%mod)*2)%mod + p%mod + q%mod)%mod)%mod;\\n            ans += res%mod;\\n            ans %= mod;\\n            sum += (sum%mod + q%mod)%mod;\\n            sum %=mod;\\n        }\\n        return ans%mod; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522447,
                "title": "c-sorting-math-easy-to-understand",
                "content": "# Approach\\nIn the first step, we sort the array because sorting doesn\\'t affect the final answer. For example, we have an array with the length 5 = [a1,a2,a3,a4,a5]\\n- In the subarray i to j, the ith element is the minimum and the jth element is the maximum.\\n- When we include both elements in our subset, then how many subsets can we create using these elements? In all subsets, the minimum element is a[i] and the maximum element is a[j]. As a result, we can create 2^(j-i-1) subset using subarray a[i...j]. Based on this, we can find the answer to our question.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        long long ans=0;\\n        sort(nums.begin(),nums.end());\\n        long long mod=1000000007,presum=0;\\n        for(int i=0; i<nums.size(); i++){\\n            long long d= ((long long)nums[i]*(long long)nums[i])%mod;\\n            ans=(ans+(long long)(d*(presum+nums[i]))%mod)%mod;\\n            presum=(2*presum+nums[i])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        long long ans=0;\\n        sort(nums.begin(),nums.end());\\n        long long mod=1000000007,presum=0;\\n        for(int i=0; i<nums.size(); i++){\\n            long long d= ((long long)nums[i]*(long long)nums[i])%mod;\\n            ans=(ans+(long long)(d*(presum+nums[i]))%mod)%mod;\\n            presum=(2*presum+nums[i])%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521829,
                "title": "sort-them-then-try-to-simpilify-the-formula",
                "content": "After sorting, for any possible group between index $i$ and $j$, where $j < i$, $nums[i]$ is the maximum and $nums[j]$ is the minimum element.  \\nFor any element $k$ in-between, such that $j < k < i$, it is irrelevant whether to include $k$ in the group or not, because $nums[i]$ and $nums[j]$ will always be the maximum and the minimum element. Hence there will be $2^{i - j - 1}$ possible groups between index $j$ and $i$. So the sum of them should be\\n\\n$\\\\quad nums[i]^2 \\\\cdot nums[j] \\\\cdot 2^{i - j - 1}$.\\n\\nFor any $i$, the sum of power of any possible $j$, where $j < i$ will be\\n\\n$\\\\quad nums[i]^2 \\\\cdot \\\\Sigma_{j = 0}^{i}(nums[j] \\\\cdot 2^{i - j - 1})$.\\n\\nLet $sub(i) = \\\\Sigma_{j = 0}^{i}(nums[j] \\\\cdot 2^{i - j - 1})$, we see that\\n\\n$\\\\quad sub(i) = 2 \\\\cdot sub(i - 1) + nums[i - 1]$,\\n\\n$\\\\quad sub(0) = 0$.\\n\\nWe also have to consider the case when $j == i$, that is\\n\\n$\\\\quad nums[i]^2 \\\\cdot nums[i]$.\\n\\nWe sum them up to get the final result.\\n\\n$\\\\quad \\\\Sigma_{i = 0}^{n}(nums[i]^2 \\\\cdot \\\\Sigma_{j = 0}^{i}(nums[j] \\\\cdot 2^{i - j - 1}) + nums[i]^2 \\\\cdot nums[i])$.\\n\\n$= \\\\Sigma_{i = 0}^{n}(nums[i]^2 \\\\cdot (sub(i) + nums[i]))$.\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        int n = nums.size();\\n        long long mod = 1e9 + 7;\\n        long long ret = 0;\\n        long long sub = 0;\\n        long long aa = 0;\\n        \\n        sort(begin(nums), end(nums));\\n        \\n        for (int a : nums)\\n        {\\n            aa = ((long long)a * a) % mod;\\n            ret = (ret + ((sub + a) * aa)) % mod;\\n            // from sub(i) to sub(i + 1)\\n            sub = ((sub << 1) + a) % mod;\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        int n = nums.size();\\n        long long mod = 1e9 + 7;\\n        long long ret = 0;\\n        long long sub = 0;\\n        long long aa = 0;\\n        \\n        sort(begin(nums), end(nums));\\n        \\n        for (int a : nums)\\n        {\\n            aa = ((long long)a * a) % mod;\\n            ret = (ret + ((sub + a) * aa)) % mod;\\n            // from sub(i) to sub(i + 1)\\n            sub = ((sub << 1) + a) % mod;\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521712,
                "title": "c",
                "content": "```C []\\nstatic int cmp_int_asc(const int * const p1, const int * const p2){\\n\\treturn *p1 - *p2;\\n}\\n\\n#define MOD 1000000007\\n\\nint sumOfPower(int* nums, int numsSize){\\n\\tint powerSum = 0;\\n\\n\\tqsort(nums, numsSize, sizeof (int), &cmp_int_asc);\\n\\n\\tint prefixSumWithWeight = 0;\\n\\tfor (int i = 0; i < numsSize; i += 1){\\n\\t\\tpowerSum = ( powerSum + ( (int64_t)prefixSumWithWeight + nums[i] ) % MOD * nums[i] % MOD * nums[i] % MOD ) % MOD;\\n\\t\\tprefixSumWithWeight = ( prefixSumWithWeight * 2 % MOD + nums[i] ) % MOD;\\n\\t}\\n\\n\\treturn powerSum;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C []\\nstatic int cmp_int_asc(const int * const p1, const int * const p2){\\n\\treturn *p1 - *p2;\\n}\\n\\n#define MOD 1000000007\\n\\nint sumOfPower(int* nums, int numsSize){\\n\\tint powerSum = 0;\\n\\n\\tqsort(nums, numsSize, sizeof (int), &cmp_int_asc);\\n\\n\\tint prefixSumWithWeight = 0;\\n\\tfor (int i = 0; i < numsSize; i += 1){\\n\\t\\tpowerSum = ( powerSum + ( (int64_t)prefixSumWithWeight + nums[i] ) % MOD * nums[i] % MOD * nums[i] % MOD ) % MOD;\\n\\t\\tprefixSumWithWeight = ( prefixSumWithWeight * 2 % MOD + nums[i] ) % MOD;\\n\\t}\\n\\n\\treturn powerSum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3521666,
                "title": "java-easy-to-understand-o-nlogn",
                "content": "```\\nclass Solution {\\n    int mod = 1000000007;\\n    private long modAdd(long a, long b) { return (a % mod + b % mod) % mod; }\\n    private long modMul(long a, long b) { return ((a % mod) * (b % mod)) % mod; }\\n    public int sumOfPower(int[] nums) {\\n        Arrays.sort(nums);\\n        long sum = 0, res = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            res = modAdd(res, modMul(modMul(nums[i], nums[i]), modAdd(sum, nums[i])));\\n            sum = modAdd(sum * 2, nums[i]);\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1000000007;\\n    private long modAdd(long a, long b) { return (a % mod + b % mod) % mod; }\\n    private long modMul(long a, long b) { return ((a % mod) * (b % mod)) % mod; }\\n    public int sumOfPower(int[] nums) {\\n        Arrays.sort(nums);\\n        long sum = 0, res = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            res = modAdd(res, modMul(modMul(nums[i], nums[i]), modAdd(sum, nums[i])));\\n            sum = modAdd(sum * 2, nums[i]);\\n        }\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521411,
                "title": "clean-and-short-solutions-sort-and-compute-contribution-with-recursive-math-formula-python",
                "content": "\\n**Recursive Math Formula**\\n\\nFirst, `max` and `min` does not change if we do permutations. Therefore, we could sort the list. This enables us to fix the min or max.\\n\\nSecond, compute contribution.\\n\\nAssume `a, b, c, d, e` are in sorted order.\\n\\nThen the contribution of groups with d being max is :\\n\\n`a * 2 ** 2 * d ** 2 + b * 2 ** 1 * d**2 + c * 2 ** 0 * d**2 + d*d**2\\n\\n= d ** 2 * (d + a ** 2 ** 2 + b * 2 ** 1 + c * 2 ** 0)`\\n\\nNote: if `a` is min, `d` is max, each of b and c can be included or not, so `a * 2 ** 2 * d ** 2`.\\n\\nThe contribution of groups with `e := nums[i]` beining max is:\\n\\n`a * 2 ** 3 * e ** 2 + b * 2 ** 2 * e ** 2 + c * 2 ** 1 * e ** 2 + d * 2 ** 0 * e ** 2. + e ** 3\\n\\n= e ** 2 * (e + a ** 2 ** 3 + b * 2 ** 2 + c * 2 ** 1 + d ** 2 ** 0)\\n\\n= e ** 2 * (e + 2 * [a ** 2 ** 2 + b * 2 ** 1 + c * 2 ** 0] + d)\\n\\n= num[i] ** 2 * (nums[i] + S[i])`\\n\\nIf` S[i] = 2 * [a ** 2 ** 2 + b * 2 ** 1 + c * 2 ** 0] + d`\\nand `S[i-1] = a ** 2 ** 2 + b * 2 ** 1 + c * 2 ** 0`,\\nWe see that:\\n\\n`S[i] = 2 * S[i-1] + nums[i-1]`\\n\\n\\nRealizing the above recursive formula, we just need to do linear scan.\\nIn the process of scanning, do not forget to take care of mod operation.\\n\\n\"\"\"\\n```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        nums.sort()\\n        res = 0\\n        M = 10 ** 9 + 7\\n        S = 0\\n        for y in nums:\\n            # below we fist update res, then update s\\n            # i.e., we compute res with the previous step state of s\\n            res = (res + y ** 2 * (y + S)) % M\\n            S = (2 * S + y) % M\\n        return res\\n    \\n    \\n    def sumOfPower(self, nums: List[int]) -> int:\\n        \\n        # step-1 sort\\n        nums.sort()\\n        \\n        # step-2 linear scan\\n        res = 0\\n        S = 0\\n        M = 10 ** 9 + 7\\n        for i, y in enumerate(nums):\\n            # first update S\\n            if i == 0:\\n                S = 0\\n            else:\\n                S = 2 * S + nums[i-1]\\n                S %= M\\n            # then update res\\n            res += y ** 2 * (y + S)\\n            res %= M\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        nums.sort()\\n        res = 0\\n        M = 10 ** 9 + 7\\n        S = 0\\n        for y in nums:\\n            # below we fist update res, then update s\\n            # i.e., we compute res with the previous step state of s\\n            res = (res + y ** 2 * (y + S)) % M\\n            S = (2 * S + y) % M\\n        return res\\n    \\n    \\n    def sumOfPower(self, nums: List[int]) -> int:\\n        \\n        # step-1 sort\\n        nums.sort()\\n        \\n        # step-2 linear scan\\n        res = 0\\n        S = 0\\n        M = 10 ** 9 + 7\\n        for i, y in enumerate(nums):\\n            # first update S\\n            if i == 0:\\n                S = 0\\n            else:\\n                S = 2 * S + nums[i-1]\\n                S %= M\\n            # then update res\\n            res += y ** 2 * (y + S)\\n            res %= M\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521395,
                "title": "swift-explained-approach",
                "content": "# Approach\\n###### Note that only the minimum and maximum elements of each group are important for the power value, any number or combination of intermediate members yields the same result.\\n###### Sort the array in ascending order.\\n###### For each pair of max `i`-th and min `j`-th element, the count of all in-between possible members combinations equals `2^(i-j-1)`. They will all have the power of `nums[j] * nums[i]^2`.\\n###### We can just brute-force through all possible pairs of `(i, j)`, but there\\'s some optimization that can be done here. Suppose we picked the maximal element `i`, and loop through all values of `j` up to it. The values added to the result would be `nums[i]^2 * nums[j] * 2^(i - j - 1)`. Let\\'s take the common multiplier `nums[i]^2`  outside the parentheses and look at the prefix sum $$\\u2211$$`(nums[j] * 2^(i - j - 1))`, `j in 0..<i`.\\n###### For `i`-th element, prefix sum is `nums[i-1] + 2 * nums[i-2] + 4 * nums[i-3] + ... + 2^(i-1) * nums[0]`. For `i-1`-th element, prefix sum is `nums[i-2] + 2 * nums[i-3] + 4 * nums[i-4] + ... + 2^(i-2) * nums[0]`. It can be easily seen that the sum can be computed iteratively, as the sum for the previous value of `i`, multiplied by two, plus the next array number. Single-person groups, where `i` equals `j` are a little out of the pattern, so we just calculate them separately.\\n\\n# Complexity\\n- Time complexity: $$O(n*log(n))$$, for sorting\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution\\n{\\n    func sumOfPower(_ nums: [Int]) -> Int\\n    {\\n        let nums = nums.sorted()\\n        // the value for the all single-hero groups summed up\\n        var answer = nums.reduce(0) { sum, num in sum + num.cubed() } % modulo\\n        var maxSquared = 0, prefixSum = 0\\n        for i in 1..<nums.count\\n        {\\n            maxSquared = (nums[i] * nums[i]) % modulo\\n            prefixSum = (2 * prefixSum + nums[i - 1]) % modulo      \\n            answer += maxSquared * prefixSum\\n            // that\\'s how it would be if we counted each pair manually, without prefix sum\\n            // for j in 0..<i {\\n            //     answer += (nums[j] * maxSquared * 2^(i - j - 1)) % modulo\\n            // }\\n            answer %= modulo\\n        }\\n        return answer\\n    }\\n}\\n\\nlet modulo = 1_000_000_007\\nextension Int\\n{\\n    func cubed() -> Int {\\n        return (((self * self) % modulo) * self) % modulo\\n    } // these damn numbers overflow at the slightest action >_<\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution\\n{\\n    func sumOfPower(_ nums: [Int]) -> Int\\n    {\\n        let nums = nums.sorted()\\n        // the value for the all single-hero groups summed up\\n        var answer = nums.reduce(0) { sum, num in sum + num.cubed() } % modulo\\n        var maxSquared = 0, prefixSum = 0\\n        for i in 1..<nums.count\\n        {\\n            maxSquared = (nums[i] * nums[i]) % modulo\\n            prefixSum = (2 * prefixSum + nums[i - 1]) % modulo      \\n            answer += maxSquared * prefixSum\\n            // that\\'s how it would be if we counted each pair manually, without prefix sum\\n            // for j in 0..<i {\\n            //     answer += (nums[j] * maxSquared * 2^(i - j - 1)) % modulo\\n            // }\\n            answer %= modulo\\n        }\\n        return answer\\n    }\\n}\\n\\nlet modulo = 1_000_000_007\\nextension Int\\n{\\n    func cubed() -> Int {\\n        return (((self * self) % modulo) * self) % modulo\\n    } // these damn numbers overflow at the slightest action >_<\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521292,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int SumOfPower(int[] nums) {        \\n        long res = 0;\\n        long sum = 0;\\n        long mod = 1000000007;\\n        Array.Sort(nums);\\n\\n        foreach (var x in nums)\\n        {\\n            res = (res + (sum + x) * x % mod * x % mod) % mod;\\n            sum = (sum * 2 + x) % mod;\\n        }\\n\\n        return (int)res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int SumOfPower(int[] nums) {        \\n        long res = 0;\\n        long sum = 0;\\n        long mod = 1000000007;\\n        Array.Sort(nums);\\n\\n        foreach (var x in nums)\\n        {\\n            res = (res + (sum + x) * x % mod * x % mod) % mod;\\n            sum = (sum * 2 + x) % mod;\\n        }\\n\\n        return (int)res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521256,
                "title": "c-math-observation",
                "content": "```\\n\\n#define ll long long\\nclass Solution {\\n    const ll mod=1e9+7;\\nll mod_add(ll a, ll b) { return ((a % mod) +0ll+ (b % mod)) % mod; }\\nll mod_sub(ll a, ll b) { return ((a % mod) - 0ll- (b % mod)) % mod; }\\nll mod_mul(ll a, ll b) { return ((a % mod) *1ll* (b % mod)) % mod; }\\nll mod_pow(ll a, ll b) {\\n    ll res = 1;\\n    while (b > 0) {\\n        if (b & 1)\\n            res = mod_mul(a,res);\\n        a = mod_mul(a,a);\\n        b >>= 1;\\n    }\\n    return res;\\n}\\npublic:\\n    ll sumOfPower(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        ll ans=0;\\n        ll sum=0;\\n        ll prev=0;\\n        for(int i=0;i<nums.size();i++){\\n                sum=mod_add(sum,nums[i]);\\n                ans=mod_add(ans,mod_mul(mod_pow(nums[i],2),mod_add(nums[i],prev)));\\n                prev=mod_add(mod_mul(prev,2),nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\n\\n#define ll long long\\nclass Solution {\\n    const ll mod=1e9+7;\\nll mod_add(ll a, ll b) { return ((a % mod) +0ll+ (b % mod)) % mod; }\\nll mod_sub(ll a, ll b) { return ((a % mod) - 0ll- (b % mod)) % mod; }\\nll mod_mul(ll a, ll b) { return ((a % mod) *1ll* (b % mod)) % mod; }\\nll mod_pow(ll a, ll b) {\\n    ll res = 1;\\n    while (b > 0) {\\n        if (b & 1)\\n            res = mod_mul(a,res);\\n        a = mod_mul(a,a);\\n        b >>= 1;\\n    }\\n    return res;\\n}\\npublic:\\n    ll sumOfPower(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        ll ans=0;\\n        ll sum=0;\\n        ll prev=0;\\n        for(int i=0;i<nums.size();i++){\\n                sum=mod_add(sum,nums[i]);\\n                ans=mod_add(ans,mod_mul(mod_pow(nums[i],2),mod_add(nums[i],prev)));\\n                prev=mod_add(mod_mul(prev,2),nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521235,
                "title": "python-solution-with-explanation-o-n-log-n",
                "content": "# Approach\\nSince in calculation of **power** (I will use \"score\" instead) of non-empty group we need to know two values only, namely the minimum and maximum elements in the group, the order of the elements in the group is not important, so we can sort `nums`.\\n\\nFor element a<sub>i</sub> from sorted `nums` we can form number of groups that have a<sub>i</sub> as its minimal element, and some other (larger or equal) element as the maximum one:\\n- a<sub>i</sub> ; a<sub>i</sub> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 combination with score a<sub>i</sub> &times; a<sub>i</sub><sup>2</sup>\\n- a<sub>i</sub>; a<sub>i+1</sub> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 combination with score a<sub>i</sub> &times; a<sub>i+1</sub><sup>2</sup>\\n- a<sub>i</sub>; ... ;a<sub>i+2</sub> &nbsp;&nbsp;&nbsp;&nbsp;2 combinations with score a<sub>i</sub> &times; a<sub>i+2</sub><sup>2</sup>\\n- a<sub>i</sub>; ... ;a<sub>i+3</sub> &nbsp;&nbsp;&nbsp;&nbsp;4 combinations with score a<sub>i</sub> &times; a<sub>i+3</sub><sup>2</sup>\\n- ... &nbsp;&nbsp;&nbsp;&nbsp; ... &nbsp;&nbsp;&nbsp;&nbsp; ... &nbsp;&nbsp;&nbsp;&nbsp; ...\\n- a<sub>i</sub>; ... ;a<sub>n-1</sub> &nbsp;&nbsp;&nbsp;&nbsp;? combinations with score a<sub>i</sub> &times; a<sub>n-1</sub><sup>2</sup>\\n\\nHow many groups can be formed from min/max elements equal to a<sub>i</sub> / a<sub>i+k</sub>. There are k-1 elements between a<sub>i</sub> / a<sub>i+k</sub>, and each of these k-1 elements can be either taken to the group or skipped (i.e., two possible states). This gives us 2<sup>k-1</sup> combinations with score of a<sub>i</sub> &times; a<sub>i+k</sub><sup>2</sup>\\n\\nNow we can write the sum we search\\n\\n![2681a.jpg](https://assets.leetcode.com/users/images/61419f9e-292d-4cd0-bccb-bfa35a8e4dbe_1684008084.5476265.jpeg)\\n\\n\\n# Complexity\\n- Time complexity: `O(n log n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        MOD = 1_000_000_007\\n        nums.sort()\\n        ans = prefix = 0\\n\\n        for num in nums:\\n            ans += num * num * (num + prefix) % MOD\\n            prefix = ((prefix << 1) + num) % MOD\\n        return ans % MOD\\n    # end sumOfPower()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        MOD = 1_000_000_007\\n        nums.sort()\\n        ans = prefix = 0\\n\\n        for num in nums:\\n            ans += num * num * (num + prefix) % MOD\\n            prefix = ((prefix << 1) + num) % MOD\\n        return ans % MOD\\n    # end sumOfPower()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521174,
                "title": "c-one-of-the-best-mathematices-question-for-acc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int mod = 1e9 + 7;\\n    using ll = long long;\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        vector<ll> arr;\\n        for(int i=0;i<nums.size();i++){\\n            arr.push_back(nums[i]);\\n        }\\n        sort(arr.begin(),arr.end());\\n        int n = nums.size();\\n        ll sum = 0;\\n        int p = 0;\\n        for(int i=0;i<n;i++){\\n            sum += ((arr[i]*arr[i])%mod*arr[i])%mod;\\n            sum += ((p*arr[i])%mod*arr[i])%mod;\\n            p = (p*2)%mod;\\n            p = (p + arr[i])%mod;\\n        }\\n        return sum%mod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1e9 + 7;\\n    using ll = long long;\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        vector<ll> arr;\\n        for(int i=0;i<nums.size();i++){\\n            arr.push_back(nums[i]);\\n        }\\n        sort(arr.begin(),arr.end());\\n        int n = nums.size();\\n        ll sum = 0;\\n        int p = 0;\\n        for(int i=0;i<n;i++){\\n            sum += ((arr[i]*arr[i])%mod*arr[i])%mod;\\n            sum += ((p*arr[i])%mod*arr[i])%mod;\\n            p = (p*2)%mod;\\n            p = (p + arr[i])%mod;\\n        }\\n        return sum%mod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521033,
                "title": "c-easy-to-understand-70-time-100-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        long long mod=1e9+7;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long>dp(n);\\n        long long int ans=0;\\n        long long int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            long long t1=long(nums[i]);\\n            long long sq=(t1*t1)%mod;\\n            long long cube=(sq*t1);\\n            long long t3=(sq*sum)%mod;\\n            long long temp=(cube+t3)%mod;\\n            sum=(2*sum+t1)%mod;\\n            ans=(ans%mod+temp)%mod;\\n        }\\n        return int(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        long long mod=1e9+7;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long>dp(n);\\n        long long int ans=0;\\n        long long int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            long long t1=long(nums[i]);\\n            long long sq=(t1*t1)%mod;\\n            long long cube=(sq*t1);\\n            long long t3=(sq*sum)%mod;\\n            long long temp=(cube+t3)%mod;\\n            sum=(2*sum+t1)%mod;\\n            ans=(ans%mod+temp)%mod;\\n        }\\n        return int(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521005,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        MOD = pow(10, 9) + 7\\n        ans, prev = 0, 0\\n        nums.sort()\\n        for start in range(len(nums)):\\n            ans += pow(nums[start], 2, MOD) * (prev + nums[start]) % MOD\\n            ans %= MOD\\n            prev = (prev * 2 + nums[start]) % MOD\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        MOD = pow(10, 9) + 7\\n        ans, prev = 0, 0\\n        nums.sort()\\n        for start in range(len(nums)):\\n            ans += pow(nums[start], 2, MOD) * (prev + nums[start]) % MOD\\n            ans %= MOD\\n            prev = (prev * 2 + nums[start]) % MOD\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521002,
                "title": "sort-sequence-finding",
                "content": "Lets take nums = [5,2,4,6,8].\\nFirst sort the array and the modified nums array will become -> [2,4,5,6,8].\\nNow suppose we consider max element in the subsequence as 6, so the elements that can come in that subsequence as 2,4,5.\\nLets take min ele as 5 then number of subsequence containing min as 5 and max as 6 is 1.\\nSimmilarly subsequence having min 4 and max 6 is 2.\\nSubsequence having min 2 and max 6 is 4.\\nSo the ans that will be dedicated while considering max as 6 is 6 * 6 * (5 * 2^0+4 * 2^1+2 * 2^2)\\nTake curr = 5 * 2^0+4 * 2^1+2 * 2^2\\nSimmilarily when we consider max as 8 ans will be increased by 8 * 8 * (6 * 2^0+5 * 2^1+4 * 2^2+2 * 2^3) = 8 * 8 * (6 * 2^0+2 * curr).\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        long long power = 0;\\n        long long sum = 0;\\n        long long mod = 1000000007;\\n        for(auto num:nums)\\n        {\\n            power = (power+(num * (num+sum) % mod * num))%mod;\\n            sum = (sum*2 + num)%mod;\\n        }\\n        return power;\\n    }\\n};\\n```\\n\\nCredits: @shreyd01 for making my job easy",
                "solutionTags": [
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        long long power = 0;\\n        long long sum = 0;\\n        long long mod = 1000000007;\\n        for(auto num:nums)\\n        {\\n            power = (power+(num * (num+sum) % mod * num))%mod;\\n            sum = (sum*2 + num)%mod;\\n        }\\n        return power;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520988,
                "title": "c-solution",
                "content": "Inspired by https://leetcode.com/problems/power-of-heroes/solutions/3520233/c-java-python-sort-and-enumerate-each-maximum-value/\\n# Code\\n```\\npublic class Solution {\\n    public int SumOfPower(int[] nums) {\\n        long res = 0;\\n        long s = 0;\\n        long @base = 1000000007;\\n        Array.Sort(nums);\\n        foreach (int x in nums) {\\n            res = (res + (s + x) * x % @base * x % @base) % @base;\\n            s = (s * 2 + x) % @base;\\n        }\\n        return (int)res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int SumOfPower(int[] nums) {\\n        long res = 0;\\n        long s = 0;\\n        long @base = 1000000007;\\n        Array.Sort(nums);\\n        foreach (int x in nums) {\\n            res = (res + (s + x) * x % @base * x % @base) % @base;\\n            s = (s * 2 + x) % @base;\\n        }\\n        return (int)res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520904,
                "title": "kotlin",
                "content": "# Code\\n```\\nclass Solution {\\n  val MOD = 1_000_000_007L\\n  fun sumOfPower(nums: IntArray): Int {\\n    nums.sort()\\n    var sum_of_min = 0L\\n    var res = 0L\\n    for (num in nums) {\\n      val max = (num.toLong() * num.toLong()) % MOD\\n      val my_sum_of_min = (sum_of_min + num) % MOD\\n      res = (res + max * my_sum_of_min) % MOD\\n      sum_of_min = (sum_of_min + my_sum_of_min) % MOD\\n    }\\n    return res.toInt()\\n  }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n  val MOD = 1_000_000_007L\\n  fun sumOfPower(nums: IntArray): Int {\\n    nums.sort()\\n    var sum_of_min = 0L\\n    var res = 0L\\n    for (num in nums) {\\n      val max = (num.toLong() * num.toLong()) % MOD\\n      val my_sum_of_min = (sum_of_min + num) % MOD\\n      res = (res + max * my_sum_of_min) % MOD\\n      sum_of_min = (sum_of_min + my_sum_of_min) % MOD\\n    }\\n    return res.toInt()\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520823,
                "title": "my-solution",
                "content": "```\\n/**\\n * sort the vector `nums` firstly.\\n * assume `nums` has five elements, they are `n1` < `n2` < `n3` < `n4` < `n5` respectively.\\n * iterate from `n1` to `n5`, the following calculation will be added to the result,\\n * 1. item1 = n1 * n1 * (n1)\\n *    let s = 0\\n *    then, item1 = n1 * n1 * (n1 + s)\\n * 2. item2 = n2 * n2 * (n2 + (2 ^ 0) * n1)\\n *    let s = n1 + 2 * s = (2 ^ 0) * n1\\n *    item2 = n2 * n2 * (n2 + s)\\n * 3. item3 = n3 * n3 * (n3 + (2 ^ 0) * n2 + (2 ^ 1) * n1)\\n *    let s = n2 + 2 * s = (2 ^ 0) * n2 + (2 ^ 1) * n1\\n *    item3 = n3 * n3 * (n3 + s)\\n * 4. item4 = n4 * n4 * (n4 + (2 ^ 0) * n3 + (2 ^ 1) * n2 + (2 ^ 2) * n1)\\n *    let s = n3 + 2 * s = (2 ^ 0) * n3 + (2 ^ 1) * n2 + (2 ^ 2) * n1\\n *    item4 = n4 * n4 * (n4 + s)\\n * 5. item5 = n5 * n5 * (n5 + (2 ^ 0) * n4 + (2 ^ 1) * n3 + (2 ^ 2) * n2 + (2 ^ 3) * n1)\\n *    let s = n4 + 2 * s = (2 ^ 0) * n4 + (2 ^ 1) * n3 + (2 ^ 2) * n2 + (2 ^ 3) * n1\\n *    item5 = n5 * n5 * (n5 + s)\\n * result = item1 + item2 + item3 + item4 + item5\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  int sumOfPower(vector<int> &nums) {\\n    constexpr int mod = 1000000007;\\n    sort(nums.begin(), nums.end());\\n    int s = 0;\\n    int ret = 0;\\n    for (const int num : nums) {\\n      ret = (ret + static_cast<int>((((static_cast<long long>(num) * num) % mod) * ((num + s) % mod)) % mod)) % mod;\\n      s = (num + (2 * s) % mod) % mod;\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * sort the vector `nums` firstly.\\n * assume `nums` has five elements, they are `n1` < `n2` < `n3` < `n4` < `n5` respectively.\\n * iterate from `n1` to `n5`, the following calculation will be added to the result,\\n * 1. item1 = n1 * n1 * (n1)\\n *    let s = 0\\n *    then, item1 = n1 * n1 * (n1 + s)\\n * 2. item2 = n2 * n2 * (n2 + (2 ^ 0) * n1)\\n *    let s = n1 + 2 * s = (2 ^ 0) * n1\\n *    item2 = n2 * n2 * (n2 + s)\\n * 3. item3 = n3 * n3 * (n3 + (2 ^ 0) * n2 + (2 ^ 1) * n1)\\n *    let s = n2 + 2 * s = (2 ^ 0) * n2 + (2 ^ 1) * n1\\n *    item3 = n3 * n3 * (n3 + s)\\n * 4. item4 = n4 * n4 * (n4 + (2 ^ 0) * n3 + (2 ^ 1) * n2 + (2 ^ 2) * n1)\\n *    let s = n3 + 2 * s = (2 ^ 0) * n3 + (2 ^ 1) * n2 + (2 ^ 2) * n1\\n *    item4 = n4 * n4 * (n4 + s)\\n * 5. item5 = n5 * n5 * (n5 + (2 ^ 0) * n4 + (2 ^ 1) * n3 + (2 ^ 2) * n2 + (2 ^ 3) * n1)\\n *    let s = n4 + 2 * s = (2 ^ 0) * n4 + (2 ^ 1) * n3 + (2 ^ 2) * n2 + (2 ^ 3) * n1\\n *    item5 = n5 * n5 * (n5 + s)\\n * result = item1 + item2 + item3 + item4 + item5\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  int sumOfPower(vector<int> &nums) {\\n    constexpr int mod = 1000000007;\\n    sort(nums.begin(), nums.end());\\n    int s = 0;\\n    int ret = 0;\\n    for (const int num : nums) {\\n      ret = (ret + static_cast<int>((((static_cast<long long>(num) * num) % mod) * ((num + s) % mod)) % mod)) % mod;\\n      s = (num + (2 * s) % mod) % mod;\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520706,
                "title": "easy-c-code-with-o-nlonn-time-o-1-space",
                "content": "# Intuition\\nTry to visulize as we have to only think about max and min element.\\nfirst sort the given array nums and see what is the score if we take max element = nums[n-1] (after sorting) and min element = nums[0] always.\\nscore of this case =\\n ```\\n(nums[n-1]^2)*(nums[0]*pow(2, n-2));\\n```\\nand the take max element = nums[n-1] and min element = nums[1] always.\\nscore of this case = \\n```\\n(nums[n-2]^2)*(nums[1]*pow(2, n-3));\\n```\\nand so on.\\n\\n# Approach\\nCalculate sum see the code for this.\\nIterate nums from right to left and update sum as well sum=(sum-nums[i])/2 and the we can see a formula as answer=answer+(nums[i]*nums[i]*sum).\\nafter this for loop calculate the score if only one element is present in the set.\\n\\n# Complexity\\n- Time complexity:\\n$$O(NlogN)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nconst int M=1e9+7;\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll fastpow(ll x, ll n, ll M){\\n        ll mul = x ;\\n        ll ans = 1 ;\\n        while (n > 0) {\\n            if (n & 1) ans=( ans * mul ) % M ;\\n            mul =( mul * mul ) % M ;\\n            n >>= 1ll ;\\n        }\\n        return ans ;\\n    }\\n    int sumOfPower(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        ll sum=0;\\n        ll mul=1;\\n        ll n=nums.size();\\n        for(int i=n-1; i>=0; i--){\\n            sum=(sum+((nums[i]*1ll*mul)%M))%M;\\n            mul=(mul*1ll*2)%M;\\n        }\\n        ll ans=0;\\n        for(int i=n-1; i>=0; i--){\\n            sum=(sum-nums[i])%M;\\n            sum+=M;\\n            sum%=M;\\n            sum=(sum*1ll*fastpow(2, M-2, M))%M;\\n            ll sq=(nums[i]*1ll*nums[i])%M;\\n            ans=(ans+((sq*sum)%M))%M;\\n        }\\n        for(int i=0; i<n; i++){\\n            ll sq=(nums[i]*1ll*nums[i])%M;\\n            sq=(sq*1ll*nums[i])%M;\\n            ans=(ans+sq)%M;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n(nums[n-1]^2)*(nums[0]*pow(2, n-2));\\n```\n```\\n(nums[n-2]^2)*(nums[1]*pow(2, n-3));\\n```\n```\\nconst int M=1e9+7;\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll fastpow(ll x, ll n, ll M){\\n        ll mul = x ;\\n        ll ans = 1 ;\\n        while (n > 0) {\\n            if (n & 1) ans=( ans * mul ) % M ;\\n            mul =( mul * mul ) % M ;\\n            n >>= 1ll ;\\n        }\\n        return ans ;\\n    }\\n    int sumOfPower(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        ll sum=0;\\n        ll mul=1;\\n        ll n=nums.size();\\n        for(int i=n-1; i>=0; i--){\\n            sum=(sum+((nums[i]*1ll*mul)%M))%M;\\n            mul=(mul*1ll*2)%M;\\n        }\\n        ll ans=0;\\n        for(int i=n-1; i>=0; i--){\\n            sum=(sum-nums[i])%M;\\n            sum+=M;\\n            sum%=M;\\n            sum=(sum*1ll*fastpow(2, M-2, M))%M;\\n            ll sq=(nums[i]*1ll*nums[i])%M;\\n            ans=(ans+((sq*sum)%M))%M;\\n        }\\n        for(int i=0; i<n; i++){\\n            ll sq=(nums[i]*1ll*nums[i])%M;\\n            sq=(sq*1ll*nums[i])%M;\\n            ans=(ans+sq)%M;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520686,
                "title": "c-solution-beat-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        long long res = 0, s = 0, base = 1e9 + 7;\\n        sort(nums.begin(), nums.end());\\n        for (int x: nums) {\\n            res = (res + (s + x) * x % base * x % base) % base;\\n            s = (s * 2 + x) % base;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        long long res = 0, s = 0, base = 1e9 + 7;\\n        sort(nums.begin(), nums.end());\\n        for (int x: nums) {\\n            res = (res + (s + x) * x % base * x % base) % base;\\n            s = (s * 2 + x) % base;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520626,
                "title": "10-line-code-maths-cpp",
                "content": "# Intuition and Approach\\n* hint: power of 2 and prefix sum.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        long long ans=0;\\n        int N=1000000007;\\n        long long sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            long long temp=nums[i];\\n            sum=(sum*2)%N;\\n            if(i>0)sum=(sum+nums[i-1])%N;\\n            long long pro=(temp*temp)%N;\\n            ans=(ans+(((sum+temp)%N)*pro)%N)%N;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        long long ans=0;\\n        int N=1000000007;\\n        long long sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            long long temp=nums[i];\\n            sum=(sum*2)%N;\\n            if(i>0)sum=(sum+nums[i-1])%N;\\n            long long pro=(temp*temp)%N;\\n            ans=(ans+(((sum+temp)%N)*pro)%N)%N;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520567,
                "title": "the-worst-idea-don-t-see-it-or-will-cry",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(k)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define all(v) v.begin(),v.end()\\n#define ll long long\\n\\nconst int MOD=(int)1e9 + 7;\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n     \\n// sort it pls\\n        sort(all(nums));\\n\\n        ll sum=0;\\n        ll ans=0;\\n        for (int i = 0; i < nums.size(); ++i) {\\n// i and i-1 add once then will multiple it by2\\n            if(i>0) {\\n                sum-=nums[i-1];\\n                sum = sum * 2ll;\\n                sum+=nums[i-1];\\n            }\\n// mod\\n            sum%=MOD;\\n            sum+=nums[i];\\n            sum%=MOD;\\n            long long temp=((sum*nums[i])%MOD*nums[i])%MOD;\\n            ans+=temp;\\n            ans%=MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define all(v) v.begin(),v.end()\\n#define ll long long\\n\\nconst int MOD=(int)1e9 + 7;\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n     \\n// sort it pls\\n        sort(all(nums));\\n\\n        ll sum=0;\\n        ll ans=0;\\n        for (int i = 0; i < nums.size(); ++i) {\\n// i and i-1 add once then will multiple it by2\\n            if(i>0) {\\n                sum-=nums[i-1];\\n                sum = sum * 2ll;\\n                sum+=nums[i-1];\\n            }\\n// mod\\n            sum%=MOD;\\n            sum+=nums[i];\\n            sum%=MOD;\\n            long long temp=((sum*nums[i])%MOD*nums[i])%MOD;\\n            ans+=temp;\\n            ans%=MOD;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520529,
                "title": "short-java-solution-sorting-and-prefix-sum-o-nlogn-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAn element is will be the minimum in all the subsets which contains only element greater than or equal to it. We sort the input array so that we can find the number of subsets in which it will be minimum as well as the sum of all the maximums possible.  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need to add cube of each number also to the result because each element has a 1 member subset where it will be both min and max. When we cube a large int it will also overflow as a long because it could go upto 10^27, so we need to take the mod after the square before doing the cube.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN) for sorting\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int sumOfPower(int[] nums) {\\n        Arrays.sort(nums);\\n        long result = 0;\\n        long prev = 0;\\n        for(int i = nums.length-1; i >= 0; i--) {\\n            result += (prev*nums[i] + ((1L * nums[i] * nums[i]) % 1000000007) * nums[i]) % 1000000007;\\n            prev = (2 * prev + 1L*nums[i] * nums[i]) % 1000000007;;\\n        }\\n        return (int)(result % 1000000007);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int sumOfPower(int[] nums) {\\n        Arrays.sort(nums);\\n        long result = 0;\\n        long prev = 0;\\n        for(int i = nums.length-1; i >= 0; i--) {\\n            result += (prev*nums[i] + ((1L * nums[i] * nums[i]) % 1000000007) * nums[i]) % 1000000007;\\n            prev = (2 * prev + 1L*nums[i] * nums[i]) % 1000000007;;\\n        }\\n        return (int)(result % 1000000007);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520500,
                "title": "my-solution",
                "content": "# Intuition\\nThis is mostly an algebra/combinatorics problem. imagine each possible grouping of heroes as a binary string of len(nums) where a 1 in position i means you take the ith hero in the grouping. \\n\\nif you imagine the list as sorted from max to min it is somewhat clear to see that there will be 2 ^ n-1 groups where the hero with max power will be in the group since each group with him in it will correspond to a string with a 1 at the start and any other ordering behind it. \\n\\nEg. if len(nums) == 3, 4 groups\\n100\\n110\\n111\\n101\\n\\nthen notice that in these groups the hero with the least power will be in 2 ^ n-2 of them since that corresponds to having a 1 at the start and at the end\\n\\nand so forth for each next weakest hero, there will be 2^ n-1 - their position from the back of the list groups with them in it.\\n\\nthen if we let $n_i$ denote the hero at the ith position we can write the total sum of powers where *that ith hero is the max power as*\\n \\n$n_i ^3$ + $n_i ^2 * n_(i-1) *2^0$ + $n_i ^2 *n_(i-2) *2^1$ ... \\nthen for the total powers we just need to find this sum for each starting position i. \\n\\nthis leads to an O(n^2) algorithm but there is an optimization you can do where you precompute the part of the sums that appear in each summation by starting with the smallest sum and working forward. which makes the algorithm O(nlogn) since you need to sort the list\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n# Code\\n```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        \\n        nums.sort()\\n        nums = nums[::-1]\\n        out = 0\\n        MOD = (10 **9) + 7\\n        \\n        #precomputing sum list\\n        sum_list = []\\n        curr = 0\\n        for num in nums[::-1] :\\n            curr = curr *2\\n            curr += num\\n            curr = curr % MOD\\n            sum_list.append(curr)\\n\\n        sum_list = sum_list[::-1]\\n        \\n        #finding sum for each ith position\\n        for idx, num in enumerate(nums[:-1]) :\\n            out = out + (num **3) %MOD \\n            num = num **2\\n            num = num %MOD\\n            out = out + (num * sum_list[idx + 1]) % MOD\\n        out = out + (nums[-1] **3) %MOD\\n        out = out%MOD\\n        \\n        return out\\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        \\n        nums.sort()\\n        nums = nums[::-1]\\n        out = 0\\n        MOD = (10 **9) + 7\\n        \\n        #precomputing sum list\\n        sum_list = []\\n        curr = 0\\n        for num in nums[::-1] :\\n            curr = curr *2\\n            curr += num\\n            curr = curr % MOD\\n            sum_list.append(curr)\\n\\n        sum_list = sum_list[::-1]\\n        \\n        #finding sum for each ith position\\n        for idx, num in enumerate(nums[:-1]) :\\n            out = out + (num **3) %MOD \\n            num = num **2\\n            num = num %MOD\\n            out = out + (num * sum_list[idx + 1]) % MOD\\n        out = out + (nums[-1] **3) %MOD\\n        out = out%MOD\\n        \\n        return out\\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520486,
                "title": "simple-solution-using-sorting-and-counting-principle-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        long long mod=1e9+7,n=nums.size(),ans=0,sum=0,a;\\n\\t\\t// sort to ensuer that when iterate over element i th element is the greatest\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n            a=nums[i];\\n\\t\\t\\t// we use formula ans = ans + nums[i]*nums[i] * ( summation of all subset that nums[i] is the greatest element )\\n            ans=(ans+((a*a)%mod)*(a+sum%mod))%mod;\\n            sum=(a+sum*2)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        long long mod=1e9+7,n=nums.size(),ans=0,sum=0,a;\\n\\t\\t// sort to ensuer that when iterate over element i th element is the greatest\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n            a=nums[i];\\n\\t\\t\\t// we use formula ans = ans + nums[i]*nums[i] * ( summation of all subset that nums[i] is the greatest element )\\n            ans=(ans+((a*a)%mod)*(a+sum%mod))%mod;\\n            sum=(a+sum*2)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520483,
                "title": "recursive-tle-accepted-easy-solution",
                "content": "\\n# Code\\n```\\n// recursive TLE\\nclass Solution {\\n    int mod=1000000007;\\n    int ans=0;\\n    public int sumOfPower(int[] nums) {\\n        subset(nums,0,Integer.MIN_VALUE,Integer.MAX_VALUE);\\n        return ans-1;\\n    }\\n    \\n    public void subset(int[] nums,int index,int maximum,int minimum){\\n        if(index==nums.length){\\n            int cal=((int)Math.pow(maximum,2)*minimum)%mod;\\n            ans=ans+cal;\\n            return;\\n        }\\n        subset(nums,index+1,maximum,minimum);\\n        subset(nums,index+1,Math.max(maximum,nums[index]),Math.min(minimum,nums[index]));\\n    }\\n}\\n```\\n```\\n// accepted solution\\nclass Solution {\\n    public int sumOfPower(int[] nums) {\\n    long mod = (long) 1e9 + 7, pre = 0, res = 0;\\n    Arrays.sort(nums);\\n    for (long x : nums) {\\n        res = (res + (x * x % mod) * x % mod + (x * x % mod) * pre % mod) % mod;\\n        pre = (pre * 2 + x) % mod;\\n    }\\n    return (int) res;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// recursive TLE\\nclass Solution {\\n    int mod=1000000007;\\n    int ans=0;\\n    public int sumOfPower(int[] nums) {\\n        subset(nums,0,Integer.MIN_VALUE,Integer.MAX_VALUE);\\n        return ans-1;\\n    }\\n    \\n    public void subset(int[] nums,int index,int maximum,int minimum){\\n        if(index==nums.length){\\n            int cal=((int)Math.pow(maximum,2)*minimum)%mod;\\n            ans=ans+cal;\\n            return;\\n        }\\n        subset(nums,index+1,maximum,minimum);\\n        subset(nums,index+1,Math.max(maximum,nums[index]),Math.min(minimum,nums[index]));\\n    }\\n}\\n```\n```\\n// accepted solution\\nclass Solution {\\n    public int sumOfPower(int[] nums) {\\n    long mod = (long) 1e9 + 7, pre = 0, res = 0;\\n    Arrays.sort(nums);\\n    for (long x : nums) {\\n        res = (res + (x * x % mod) * x % mod + (x * x % mod) * pre % mod) % mod;\\n        pre = (pre * 2 + x) % mod;\\n    }\\n    return (int) res;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520476,
                "title": "easy-c-solution-using-sorting",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        long long int mod = 1e9 + 7 ; \\n        sort(nums.begin() , nums.end());\\n        long long int ans = 0 ;\\n        long long int max_val = 0 ; \\n        for (int i = nums.size()-1 ; i >=0 ;i--){\\n            long long int temp;\\n            long long int v2 = nums[i];\\n            long long int sq = (v2*v2)%mod ; \\n            temp = ((( max_val +sq )%mod) * v2)%mod;\\n            ans = (ans+temp)%mod;\\n            max_val = ((2*max_val)%mod + sq)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        long long int mod = 1e9 + 7 ; \\n        sort(nums.begin() , nums.end());\\n        long long int ans = 0 ;\\n        long long int max_val = 0 ; \\n        for (int i = nums.size()-1 ; i >=0 ;i--){\\n            long long int temp;\\n            long long int v2 = nums[i];\\n            long long int sq = (v2*v2)%mod ; \\n            temp = ((( max_val +sq )%mod) * v2)%mod;\\n            ans = (ans+temp)%mod;\\n            max_val = ((2*max_val)%mod + sq)%mod;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520471,
                "title": "ruby-solution-100-100",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * log(n))$$\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# @param {Integer[]} nums\\n# @return {Integer}\\n\\n@mod = 1000000007\\n\\ndef sum_of_power(nums)\\n    nums.sort!\\n    nums.map! { |num| num % @mod }\\n    sum = 0\\n    sums = [0]\\n    sum_of_sums = [0]\\n    \\n    nums.each do |num|\\n        sum += num + sum_of_sums[-1]\\n        sums << sum % @mod\\n        sum_of_sums << (sum_of_sums[-1] + sums[-2]) % @mod\\n    end\\n    \\n    sums.shift\\n    \\n    total = 0\\n    \\n    (0...nums.length).each do |i|\\n        total = (total + sums[i] * nums[i] ** 2) % @mod\\n    end\\n    \\n    total\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\n\\n@mod = 1000000007\\n\\ndef sum_of_power(nums)\\n    nums.sort!\\n    nums.map! { |num| num % @mod }\\n    sum = 0\\n    sums = [0]\\n    sum_of_sums = [0]\\n    \\n    nums.each do |num|\\n        sum += num + sum_of_sums[-1]\\n        sums << sum % @mod\\n        sum_of_sums << (sum_of_sums[-1] + sums[-2]) % @mod\\n    end\\n    \\n    sums.shift\\n    \\n    total = 0\\n    \\n    (0...nums.length).each do |i|\\n        total = (total + sums[i] * nums[i] ** 2) % @mod\\n    end\\n    \\n    total\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3520459,
                "title": "simple-and-concise-o-nlogn-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n- First, each group is a non-empty subset, and we have 2^N - 1 non-empty subsets. But for each subset we just care about min and max of them.\\n\\n- Sort the array will help us find min and max of each subset easy.\\n\\n- After sort, each number at index i we know nums[i] is alway max for all subset we can find from nums[0] to nums[i]. Figure out the formula based on prefix\\n\\n\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) (for sorting in python)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        MOD = 10**9 + 7\\n        nums.sort()\\n        ans = 0\\n        prefix = 0\\n        for i, val in enumerate(nums):\\n            ans = (ans + (val**2) * (prefix * 2 + (nums[i-1] if i-1 >=0 else 0) + val)) % MOD\\n            prefix = (prefix * 2 + (nums[i-1] if i-1 >=0 else 0)) % MOD\\n                \\n        return ans % MOD\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        MOD = 10**9 + 7\\n        nums.sort()\\n        ans = 0\\n        prefix = 0\\n        for i, val in enumerate(nums):\\n            ans = (ans + (val**2) * (prefix * 2 + (nums[i-1] if i-1 >=0 else 0) + val)) % MOD\\n            prefix = (prefix * 2 + (nums[i-1] if i-1 >=0 else 0)) % MOD\\n                \\n        return ans % MOD\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520441,
                "title": "c-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        const int MOD = 1e9+7;\\n        int n = nums.size();\\n        vector<long long> box(n), base(n), real(n);\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i<n; ++i){\\n            box[i] = nums[i];\\n        }\\n        \\n        \\n        // DP\\n        // real[i] is must picj box[i] and sum of [0-i]\\n        // base[i] is for prefix sum to O(n2) to O(n)\\n        \\n        base[0] = box[0];\\n        real[0] = box[0]*box[0] % MOD;\\n        real[0] = real[0]*box[0] % MOD;\\n        \\n        for(int i = 1; i<n; ++i){\\n            long long cur = box[i] * box[i] % MOD;\\n            real[i] = base[i-1] * cur % MOD;\\n            real[i] += cur * box[i] % MOD;\\n            real[i] %= MOD;\\n            base[i] = base[i-1] + base[i-1] + box[i];\\n            base[i] %= MOD;\\n        }\\n        \\n        \\n        \\n        \\n        \\n        \\n        long long ret = 0;\\n        for(int i = 0; i<n; ++i){\\n            ret += real[i];\\n            ret %= MOD;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        const int MOD = 1e9+7;\\n        int n = nums.size();\\n        vector<long long> box(n), base(n), real(n);\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i<n; ++i){\\n            box[i] = nums[i];\\n        }\\n        \\n        \\n        // DP\\n        // real[i] is must picj box[i] and sum of [0-i]\\n        // base[i] is for prefix sum to O(n2) to O(n)\\n        \\n        base[0] = box[0];\\n        real[0] = box[0]*box[0] % MOD;\\n        real[0] = real[0]*box[0] % MOD;\\n        \\n        for(int i = 1; i<n; ++i){\\n            long long cur = box[i] * box[i] % MOD;\\n            real[i] = base[i-1] * cur % MOD;\\n            real[i] += cur * box[i] % MOD;\\n            real[i] %= MOD;\\n            base[i] = base[i-1] + base[i-1] + box[i];\\n            base[i] %= MOD;\\n        }\\n        \\n        \\n        \\n        \\n        \\n        \\n        long long ret = 0;\\n        for(int i = 0; i<n; ++i){\\n            ret += real[i];\\n            ret %= MOD;\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520429,
                "title": "python-acceptable-solution-with-brief-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe essence here is finding how many times each element multiplied as minimum number in the sub_array. eg, in the [1,2,4], 1 works as min 4 times, 2 works as min 2 times and 4 as min 1 time. If you could find this algorithm, it would guide you to the solution :)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans = 0\\n        mod = 10 ** 9 + 7\\n        n = len(nums)\\n        if n == 1:\\n            return nums[0] ** 3 % mod\\n        k = 0\\n        for i in range(1,n):\\n            ans += (nums[i] ** 3 + nums[i] ** 2 * (k * 2 + nums[i-1])) % mod\\n            k = k * 2 + nums[i-1]\\n        return (ans + nums[0] ** 3) % mod\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans = 0\\n        mod = 10 ** 9 + 7\\n        n = len(nums)\\n        if n == 1:\\n            return nums[0] ** 3 % mod\\n        k = 0\\n        for i in range(1,n):\\n            ans += (nums[i] ** 3 + nums[i] ** 2 * (k * 2 + nums[i-1])) % mod\\n            k = k * 2 + nums[i-1]\\n        return (ans + nums[0] ** 3) % mod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520415,
                "title": "java-o-nlogn-approach",
                "content": "```\\nclass Solution {\\n\\n    public int sumOfPower(int[] nums) {\\n        Arrays.sort(nums);\\n        long[] min = new long[nums.length];\\n        long sum = nums[0];\\n        min[0] = nums[0];\\n        long mod = 1000000007;\\n        long soln = (min[0] % mod * nums[0] % mod * nums[0]) % mod;\\n        for (int i = 1; i < nums.length; i++) {\\n            min[i] = sum + nums[i];\\n            sum += min[i];\\n            sum = sum % mod;\\n            soln = (soln + (min[i] % mod * nums[i] % mod * nums[i]) % mod) % mod;\\n        }\\n        return (int) soln;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public int sumOfPower(int[] nums) {\\n        Arrays.sort(nums);\\n        long[] min = new long[nums.length];\\n        long sum = nums[0];\\n        min[0] = nums[0];\\n        long mod = 1000000007;\\n        long soln = (min[0] % mod * nums[0] % mod * nums[0]) % mod;\\n        for (int i = 1; i < nums.length; i++) {\\n            min[i] = sum + nums[i];\\n            sum += min[i];\\n            sum = sum % mod;\\n            soln = (soln + (min[i] % mod * nums[i] % mod * nums[i]) % mod) % mod;\\n        }\\n        return (int) soln;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520414,
                "title": "sort-and-count-easy-coding",
                "content": "sort array and iterate over left and right indices for each subarray. The start and end points can only be the min,max couple when the other items are in between them So number of subarrays with these left and right points are power set of the distance between. Not the best explanation but code is clean. \\n\\n```\\n\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        \\n        mod = 10**9 + 7\\n        sumPower=0\\n        n=len(nums)\\n        nums.sort()\\n        for i in range(n):\\n            for j in range(i,n):\\n                sumPower+=((nums[i]*nums[j]*nums[j])* (2**max(0,(j-i-1))) % mod )\\n                \\n        return sumPower\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        \\n        mod = 10**9 + 7\\n        sumPower=0\\n        n=len(nums)\\n        nums.sort()\\n        for i in range(n):\\n            for j in range(i,n):\\n                sumPower+=((nums[i]*nums[j]*nums[j])* (2**max(0,(j-i-1))) % mod )\\n                \\n        return sumPower\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520411,
                "title": "c-solution",
                "content": "# Intuition\\nSort the array and likewise try to think the number of times each number appears in all the subsets combined\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef long long int ll;\\nll m = 1e9 + 7LL;\\n\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        \\n        ll n = (int)nums.size();\\n        sort(nums.begin(),nums.end());\\n        \\n        ll toAdd = 0, pref = 0;\\n        ll ans = 0;\\n        \\n        for(ll i = 0; i < n; i++){\\n            toAdd = i >= 1 ? ((pref * 2) % m + nums[i - 1]) % m : 0;\\n            pref = toAdd;\\n            ans = (ans + (((nums[i] % m * nums[i] % m) % m) * (toAdd + nums[i])) % m ) % m;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long int ll;\\nll m = 1e9 + 7LL;\\n\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        \\n        ll n = (int)nums.size();\\n        sort(nums.begin(),nums.end());\\n        \\n        ll toAdd = 0, pref = 0;\\n        ll ans = 0;\\n        \\n        for(ll i = 0; i < n; i++){\\n            toAdd = i >= 1 ? ((pref * 2) % m + nums[i - 1]) % m : 0;\\n            pref = toAdd;\\n            ans = (ans + (((nums[i] % m * nums[i] % m) % m) * (toAdd + nums[i])) % m ) % m;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520400,
                "title": "python-sort-and-count-with-example",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        nums.sort()\\n        mod = 10**9 + 7\\n        ans = 0\\n        pref = 0\\n        for i in range(len(nums)):\\n            ans += nums[i]**2 * (nums[i] + pref)\\n            ans %= mod\\n            pref = pref * 2 + nums[i]\\n            pref %= mod\\n            \\n        return ans\\n            \\n            \\n        \\n        \\n        \\n\"\"\"\\n[2, 1, 5, 4, 3, 7, 1]\\n\\n[1, 1, 2, 3, 4, 5, 7]\\n\\n1**2 (1) = 1\\n\\n1**2 (1 + 2**0 * 1) = 2\\n\\n5**2 (5 + 2**0 * 4 + 2**1 * 3 + 2**2 * 2 + ... + 2**4 * 1)\\n\\n7**2 (7 + 2**0 * 5 + 2**1 * 4 + 2**2 * 4 + ... + 2**5 * 1)\\n\\n\"\"\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        nums.sort()\\n        mod = 10**9 + 7\\n        ans = 0\\n        pref = 0\\n        for i in range(len(nums)):\\n            ans += nums[i]**2 * (nums[i] + pref)\\n            ans %= mod\\n            pref = pref * 2 + nums[i]\\n            pref %= mod\\n            \\n        return ans\\n            \\n            \\n        \\n        \\n        \\n\"\"\"\\n[2, 1, 5, 4, 3, 7, 1]\\n\\n[1, 1, 2, 3, 4, 5, 7]\\n\\n1**2 (1) = 1\\n\\n1**2 (1 + 2**0 * 1) = 2\\n\\n5**2 (5 + 2**0 * 4 + 2**1 * 3 + 2**2 * 2 + ... + 2**4 * 1)\\n\\n7**2 (7 + 2**0 * 5 + 2**1 * 4 + 2**2 * 4 + ... + 2**5 * 1)\\n\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520387,
                "title": "subset-min-max-concept-solved-just-after-1-min-of-contest-feeling-sad",
                "content": "\\n\\n\\n# Complexity\\nO(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int sumOfPower(int[] nums) {\\n        \\n        long mod = 1000000000+7;\\n        Arrays.sort(nums);\\n        \\n        long s = 0;\\n        \\n        long pow2[] = new long[nums.length+5];\\n        pow2[0] = 1;\\n        for(int i = 1; i < nums.length+5; i++)\\n        {\\n            pow2[i] = (pow2[i]*2)%mod;\\n        }    \\n        \\n        \\n        long pre[] = new long[nums.length];\\n        pre[0] = nums[0];\\n        \\n        for(int i = 1;  i < nums.length; i++)\\n        {\\n            pre[i] = (pre[i-1]*2 + nums[i])%mod;\\n        }\\n\\n        for(int i = 0; i < nums.length; i++)\\n        {\\n            long x =  (long)nums[i];\\n            s = (s + (((x*x)%mod)*x)%mod) %mod;\\n        }\\n\\n        \\n        for(int i = 1; i < nums.length; i++)\\n        {\\n            long x = (long)nums[i];\\n            long res = ((x*x)%mod * pre[i-1]) % mod;\\n            s = (s + res) % mod;\\n            \\n            // System.out.println(pre[i]);\\n        }\\n        \\n        return (int)s;\\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int sumOfPower(int[] nums) {\\n        \\n        long mod = 1000000000+7;\\n        Arrays.sort(nums);\\n        \\n        long s = 0;\\n        \\n        long pow2[] = new long[nums.length+5];\\n        pow2[0] = 1;\\n        for(int i = 1; i < nums.length+5; i++)\\n        {\\n            pow2[i] = (pow2[i]*2)%mod;\\n        }    \\n        \\n        \\n        long pre[] = new long[nums.length];\\n        pre[0] = nums[0];\\n        \\n        for(int i = 1;  i < nums.length; i++)\\n        {\\n            pre[i] = (pre[i-1]*2 + nums[i])%mod;\\n        }\\n\\n        for(int i = 0; i < nums.length; i++)\\n        {\\n            long x =  (long)nums[i];\\n            s = (s + (((x*x)%mod)*x)%mod) %mod;\\n        }\\n\\n        \\n        for(int i = 1; i < nums.length; i++)\\n        {\\n            long x = (long)nums[i];\\n            long res = ((x*x)%mod * pre[i-1]) % mod;\\n            s = (s + res) % mod;\\n            \\n            // System.out.println(pre[i]);\\n        }\\n        \\n        return (int)s;\\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520373,
                "title": "c-faster-than-75-sort",
                "content": "# Intuition\\nAt first sort the array.\\n\\n# Approach\\nAt first sort the array. Note, that for each pair indexes (i, j), i < j the minimum value will be nums[i] and the maximum value will be nums[j].\\nThe number of all combinations for these min and max will be (2^(j - i - 1)) - we can include or not inlude the items nums[k], i < k < j.\\nIf we reduce the low index i, then we should multiply sum by 2 and increase the sum by the square of the current item:\\n```\\nsum *= 2;\\nsum %= 1_000_000_007;\\nsum += (nums[i] * (long)nums[i]) % 1_000_000_007;\\nsum %= 1_000_000_007;\\n```\\nOn each step increase the result:\\n```\\nrs += nums[i] * sum;\\nrs %= 1_000_000_007;\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(log(n)*n)$$, where n = len(nums)\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int SumOfPower(int[] nums) {\\n        Array.Sort(nums);\\n        var rs = InitValue(nums);\\n        long sum = (nums[nums.Length - 1] * (long)nums[nums.Length - 1]) % 1_000_000_007;\\n        for (int i = nums.Length - 2; i >= 0; i--)\\n        {\\n            rs += nums[i] * sum;\\n            rs %= 1_000_000_007;\\n            sum *= 2;\\n            sum %= 1_000_000_007;\\n            sum += (nums[i] * (long)nums[i]) % 1_000_000_007;\\n            sum %= 1_000_000_007;\\n        }\\n        return (int)rs;\\n    }\\n    private long InitValue(int[] nums)\\n    {\\n        var rs = 0L;\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            rs += (((nums[i] * (long)nums[i]) % 1_000_000_007) * (long)nums[i]) % 1_000_000_007;\\n            rs %= 1_000_000_007;\\n        }\\n        return rs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nsum *= 2;\\nsum %= 1_000_000_007;\\nsum += (nums[i] * (long)nums[i]) % 1_000_000_007;\\nsum %= 1_000_000_007;\\n```\n```\\nrs += nums[i] * sum;\\nrs %= 1_000_000_007;\\n```\n```\\npublic class Solution {\\n    public int SumOfPower(int[] nums) {\\n        Array.Sort(nums);\\n        var rs = InitValue(nums);\\n        long sum = (nums[nums.Length - 1] * (long)nums[nums.Length - 1]) % 1_000_000_007;\\n        for (int i = nums.Length - 2; i >= 0; i--)\\n        {\\n            rs += nums[i] * sum;\\n            rs %= 1_000_000_007;\\n            sum *= 2;\\n            sum %= 1_000_000_007;\\n            sum += (nums[i] * (long)nums[i]) % 1_000_000_007;\\n            sum %= 1_000_000_007;\\n        }\\n        return (int)rs;\\n    }\\n    private long InitValue(int[] nums)\\n    {\\n        var rs = 0L;\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            rs += (((nums[i] * (long)nums[i]) % 1_000_000_007) * (long)nums[i]) % 1_000_000_007;\\n            rs %= 1_000_000_007;\\n        }\\n        return rs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520341,
                "title": "what-is-this-ez-sol-bruh-best-shit",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sumOfPower(self, nums) -> int:\\n        nums.sort()\\n        mod,n=10**9+7,len(nums)\\n        ans,s,ps=[0]*3\\n        for i in range(n):\\n            ps*=2\\n            ps+=s\\n            ps%=mod\\n            s=nums[i]\\n            ans+=(nums[i]**2)*(ps+s)\\n            ans%=mod\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumOfPower(self, nums) -> int:\\n        nums.sort()\\n        mod,n=10**9+7,len(nums)\\n        ans,s,ps=[0]*3\\n        for i in range(n):\\n            ps*=2\\n            ps+=s\\n            ps%=mod\\n            s=nums[i]\\n            ans+=(nums[i]**2)*(ps+s)\\n            ans%=mod\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520327,
                "title": "c-code-with-maths-and-observing-patterns",
                "content": "# Intuition\\nUsed Computation maths and patterns to find the correct ans.\\n\\n\\n\\n# Approach\\nfirstly we see that the cubes of each elemenet will be added for subsequences of size 1.\\n\\nalso sort the list to easily understand the minimum and maximum\\nin any subsequence rightmost is maximum and leftost minimum\\n\\n\\nafter adding cubes we see that each element on left if multiplied by each element of its right by power of 2(distance) * right elementsqaured\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long mod=1e9+7;\\n    int sumOfPower(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long>cubes;\\n        for(int i=0;i<n;i++)\\n        {\\n            long long c= 1;\\n            c= (c* nums[i])%mod;\\n            c= (c* nums[i])%mod;\\n            c= (c* nums[i])%mod;\\n            cubes.push_back(c);\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans= ans+ cubes[i];\\n            ans%=mod;\\n        }\\n        \\n        \\n        \\n        vector<long long>squares;\\n        for(int i=0;i<n;i++)\\n        {\\n            long long c= 1;\\n            c= (c* nums[i])%mod;\\n            c= (c* nums[i])%mod;\\n            squares.push_back(c);\\n        }\\n        \\n        \\n        vector<long long> pre(n,0);\\n        pre[n-1]=squares[n-1];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            pre[i]= squares[i];\\n            pre[i]%=mod;\\n            pre[i]=pre[i]+pre[i+1];\\n            pre[i]%=mod;\\n        }\\n        \\n        \\n        vector<long long>s=squares;\\n        \\n        \\n        \\n        vector<long long>spec(n+1,0);\\n        \\n        long long total=0;\\n        \\n        spec[n-1]= s[n-1];\\n        total=spec[n-1];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            spec[i]= pre[i]+spec[i];\\n            spec[i]%=mod;\\n            spec[i]=spec[i]+total;\\n            spec[i]%=mod;\\n            total= total+ spec[i];\\n            total%=mod;\\n        }\\n        \\n        \\n        for(auto it:spec)\\n            cout<<it<<\\' \\';\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            long long adder= nums[i]*(spec[i+1]);\\n            adder%=mod;\\n            ans= ans+adder;\\n            ans%=mod;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mod=1e9+7;\\n    int sumOfPower(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<long long>cubes;\\n        for(int i=0;i<n;i++)\\n        {\\n            long long c= 1;\\n            c= (c* nums[i])%mod;\\n            c= (c* nums[i])%mod;\\n            c= (c* nums[i])%mod;\\n            cubes.push_back(c);\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans= ans+ cubes[i];\\n            ans%=mod;\\n        }\\n        \\n        \\n        \\n        vector<long long>squares;\\n        for(int i=0;i<n;i++)\\n        {\\n            long long c= 1;\\n            c= (c* nums[i])%mod;\\n            c= (c* nums[i])%mod;\\n            squares.push_back(c);\\n        }\\n        \\n        \\n        vector<long long> pre(n,0);\\n        pre[n-1]=squares[n-1];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            pre[i]= squares[i];\\n            pre[i]%=mod;\\n            pre[i]=pre[i]+pre[i+1];\\n            pre[i]%=mod;\\n        }\\n        \\n        \\n        vector<long long>s=squares;\\n        \\n        \\n        \\n        vector<long long>spec(n+1,0);\\n        \\n        long long total=0;\\n        \\n        spec[n-1]= s[n-1];\\n        total=spec[n-1];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            spec[i]= pre[i]+spec[i];\\n            spec[i]%=mod;\\n            spec[i]=spec[i]+total;\\n            spec[i]%=mod;\\n            total= total+ spec[i];\\n            total%=mod;\\n        }\\n        \\n        \\n        for(auto it:spec)\\n            cout<<it<<\\' \\';\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            long long adder= nums[i]*(spec[i+1]);\\n            adder%=mod;\\n            ans= ans+adder;\\n            ans%=mod;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3520303,
                "title": "simple-o-n-log-n-python3-solution",
                "content": "# Intuition\\nSorting `nums` stabilizes min and max; 1E5 nums rules out a quadratic solution.\\n\\n# Approach\\nSort `nums` and iterate from low to high. Accumulate the sum of the mins for all groups, remembering to aggressively MOD by 1_000_000_007, since the number of groups roughly doubles in size through each iteration. Accumulate total power in `powerSum`.\\n\\n# Complexity\\n- Time complexity:\\n$$O(N Log N)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:        \\n        nums.sort()\\n        powerSum = 0\\n        minSum = 0\\n        for num1 in nums:\\n            # minSum holds the sum of the mins of all groups that include\\n            # a num to the left of num1. Accumulate the power of each of\\n            # these groups, plus the single-element [num1] group.\\n            powerSum += (minSum + num1) * num1 * num1\\n            powerSum %= 1_000_000_007\\n            \\n            # Update minSum to also contain sets that include num1.\\n            minSum = minSum * 2 + num1\\n            minSum %= 1_000_000_007\\n        return powerSum\\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:        \\n        nums.sort()\\n        powerSum = 0\\n        minSum = 0\\n        for num1 in nums:\\n            # minSum holds the sum of the mins of all groups that include\\n            # a num to the left of num1. Accumulate the power of each of\\n            # these groups, plus the single-element [num1] group.\\n            powerSum += (minSum + num1) * num1 * num1\\n            powerSum %= 1_000_000_007\\n            \\n            # Update minSum to also contain sets that include num1.\\n            minSum = minSum * 2 + num1\\n            minSum %= 1_000_000_007\\n        return powerSum\\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520237,
                "title": "c-sort-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        const int MOD = 1000000007;\\n        sort(nums.begin(),nums.end());\\n        vector<long long> temp;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n\\t\\t\\ttemp.push_back(nums[i]);\\n\\t\\t}\\n        \\n         \\n        long long  min =0,sum=0;\\n        for(int i=0;i<n;i++){\\n            sum = (sum +((temp[i]*temp[i])%MOD )*temp[i]%MOD)%MOD;\\n            sum = (sum +((min*temp[i])%MOD )*temp[i]%MOD)%MOD;\\n            min =(min*2)%MOD;\\n            min = (min + temp[i])%MOD;\\n            \\n        }\\n        return sum%MOD;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        const int MOD = 1000000007;\\n        sort(nums.begin(),nums.end());\\n        vector<long long> temp;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n\\t\\t\\ttemp.push_back(nums[i]);\\n\\t\\t}\\n        \\n         \\n        long long  min =0,sum=0;\\n        for(int i=0;i<n;i++){\\n            sum = (sum +((temp[i]*temp[i])%MOD )*temp[i]%MOD)%MOD;\\n            sum = (sum +((min*temp[i])%MOD )*temp[i]%MOD)%MOD;\\n            min =(min*2)%MOD;\\n            min = (min + temp[i])%MOD;\\n            \\n        }\\n        return sum%MOD;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520236,
                "title": "factoring-based-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe sum we are required to compute can be factored.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf we sort the heroes\\' powers in ascending order, then the answer equals\\n$$\\n\\\\sum_{i<j} nums_i \\\\ (nums_j)^2 \\\\ 2^{j-i-1} + \\\\sum_i (nums_i)^3.\\n$$\\nThe second term takes linear time to compute. The first term can be further factored as\\n$$\\n\\\\sum_i 2^{-i-1} nums_i \\\\sum_{j>i} 2^j nums_j^2.\\n$$\\nFinally, we need to do all computations modulo p. We can replace $2^{-i-1}$ by $(2^{-1})^{i+1}$.\\nIt is easy to see that modulo p $2^{-1}=5 \\\\cdot 10^8 + 4$.\\n\\nNow everything can be computed in linear time.\\n\\n# Complexity\\n- Time complexity: $O(n \\\\log n)$ because we sort the list first.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$ (this can be improved to $O(1)$ on top of the initial data).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        p=10**9+7\\n        inv=5*10**8+4\\n        nums.sort()\\n        sums=[]\\n        s=0\\n        pw=1\\n        for i, n in enumerate(nums):\\n            s=(s+n*n*pw)%p\\n            pw=(pw<<1)%p\\n            sums.append(s)\\n        final_sum=sums[-1]\\n        ans=0\\n        total_inv=inv\\n        for i, n in enumerate(nums):\\n            tmp=n*(final_sum-sums[i])*total_inv%p\\n            total_inv=total_inv*inv%p\\n            ans=(ans+tmp)%p\\n        return (ans+sum(n*n*n%p for n in nums))%p\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        p=10**9+7\\n        inv=5*10**8+4\\n        nums.sort()\\n        sums=[]\\n        s=0\\n        pw=1\\n        for i, n in enumerate(nums):\\n            s=(s+n*n*pw)%p\\n            pw=(pw<<1)%p\\n            sums.append(s)\\n        final_sum=sums[-1]\\n        ans=0\\n        total_inv=inv\\n        for i, n in enumerate(nums):\\n            tmp=n*(final_sum-sums[i])*total_inv%p\\n            total_inv=total_inv*inv%p\\n            ans=(ans+tmp)%p\\n        return (ans+sum(n*n*n%p for n in nums))%p\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520213,
                "title": "sorting-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    using ll = unsigned long long;\\n    ll MOD = 1e9 + 7;\\n    \\n    ll modmul(ll a, ll b) {\\n        return (a*b)%MOD;\\n    }\\n    \\n    ll modadd(ll a, ll b) {\\n        return (a+b)%MOD;\\n    }\\n    \\n    int sumOfPower(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        \\n        vector<ll> dp(nums.size());\\n        \\n        dp[0] = modmul(nums[0],modmul(nums[0],nums[0]));\\n        ll minsum = nums[0];\\n        \\n        for(int i=1; i<nums.size(); i++) {\\n            dp[i] = modadd(modadd(dp[i-1], modmul(minsum,modmul(nums[i],nums[i]))), modmul(nums[i],modmul(nums[i],nums[i])));\\n            minsum = modadd(modmul(minsum,2),nums[i]);\\n        }\\n        \\n        return dp.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = unsigned long long;\\n    ll MOD = 1e9 + 7;\\n    \\n    ll modmul(ll a, ll b) {\\n        return (a*b)%MOD;\\n    }\\n    \\n    ll modadd(ll a, ll b) {\\n        return (a+b)%MOD;\\n    }\\n    \\n    int sumOfPower(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        \\n        vector<ll> dp(nums.size());\\n        \\n        dp[0] = modmul(nums[0],modmul(nums[0],nums[0]));\\n        ll minsum = nums[0];\\n        \\n        for(int i=1; i<nums.size(); i++) {\\n            dp[i] = modadd(modadd(dp[i-1], modmul(minsum,modmul(nums[i],nums[i]))), modmul(nums[i],modmul(nums[i],nums[i])));\\n            minsum = modadd(modmul(minsum,2),nums[i]);\\n        }\\n        \\n        return dp.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520210,
                "title": "python-mod-inverse-o-nlogn",
                "content": "# Code\\n```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        nums.sort()\\n        T = 0\\n        MOD = 10**9 + 7\\n        inverse = pow(2,MOD-2,MOD)\\n        for num in nums:\\n            T = (2*T + num) % MOD\\n        nums.reverse()\\n        res = 0\\n        for num in nums:\\n            T = ((T - num)*inverse)%MOD\\n            res = (res + pow(num,2,MOD)*num + pow(num,2,MOD)*T)%MOD\\n             \\n        return res\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        nums.sort()\\n        T = 0\\n        MOD = 10**9 + 7\\n        inverse = pow(2,MOD-2,MOD)\\n        for num in nums:\\n            T = (2*T + num) % MOD\\n        nums.reverse()\\n        res = 0\\n        for num in nums:\\n            T = ((T - num)*inverse)%MOD\\n            res = (res + pow(num,2,MOD)*num + pow(num,2,MOD)*T)%MOD\\n             \\n        return res\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520206,
                "title": "sort-and-prefix-sum-of-powers-of-2",
                "content": "```\\nclass Solution:\\n    def sumOfPower(self, arr):\\n        n = len(arr)\\n        M = 10 ** 9 + 7\\n        pw = [1] * (n + 1)\\n        for i in range(1, n + 1):\\n            pw[i] = 2 * pw[i - 1]\\n            pw[i] %= M\\n        arr.sort()\\n        res = 0\\n        s = 0\\n        for i in range(n - 1, -1, -1):\\n            res += arr[i] * arr[i] * arr[i]\\n            res += arr[i] * s * pow(pw[i + 1], M - 2, M)\\n            res %= M\\n            s += pw[i] * arr[i] * arr[i]\\n            s %= M\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sumOfPower(self, arr):\\n        n = len(arr)\\n        M = 10 ** 9 + 7\\n        pw = [1] * (n + 1)\\n        for i in range(1, n + 1):\\n            pw[i] = 2 * pw[i - 1]\\n            pw[i] %= M\\n        arr.sort()\\n        res = 0\\n        s = 0\\n        for i in range(n - 1, -1, -1):\\n            res += arr[i] * arr[i] * arr[i]\\n            res += arr[i] * s * pow(pw[i + 1], M - 2, M)\\n            res %= M\\n            s += pw[i] * arr[i] * arr[i]\\n            s %= M\\n        return res\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1892441,
                "content": [
                    {
                        "username": "Msey",
                        "content": "seemed to be easy but in fact it was a trap on contest"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as simple as it appears to be"
                    },
                    {
                        "username": "AntonBelski",
                        "content": "Can you shere with me similar problems here (leetcode) or in codeforces?"
                    },
                    {
                        "username": "ismailhossainraju74",
                        "content": "It could be segment  tree problem."
                    },
                    {
                        "username": "underscore_en",
                        "content": "caution backtracking -> TLE, think about how you can make use of max, min "
                    },
                    {
                        "username": "leana8959",
                        "content": "It is possible to do this below O(N^2) time complexity? (excluding the sorting).\\n\\nI managed to get the right result on my own, the only issue is that with the huge arrays in the end of the test cases are timing out.\\n\\nThanks"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question seems absurd. Theoretically you can only do better than O(n^2) if the array has many duplicate elements. Otherwise, you need to consider every single possible pair of (min, max) which is O(n^2). But with an input size of 10^5, I dont see how that\\'s possible. "
                    },
                    {
                        "username": "Sherif_Tarek",
                        "content": "Could someone please refer me to some tutorial to teach me where should I use the modulo when doing a lot of calculations like in this problem?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "In python, just use it at the end before you return the sum. We can do this because python supports much larger numbers than other languages."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "So some actual helpful hints because the questions hints aren\\'t great. \\n\\nFirst of all, if you are attempting a hard problem, you should already know that a max input size of 10^5 implies that an O(n^2) solution will not work. \\n\\nIt seems impossible, but there is indeed a true O(n) solution assuming nums is sorted. and therefore an O(nlogn) solution for this problem. \\n\\nNotice this is classified as a math problem, so whip out a pen and paper and try an example by hand. I would recomend setting your array to being \\na, b, c, d, e where you know a <= b <= c <= d =< e. (If you try this with an example array of 1, 2, 3, 4, 5 it will be harder to see how to simplify your solution to get an answer. \\n\\n(If you have made it this far, maybe try the advice given first before continuing). \\nIf you are still struggling, write an explicit expression for what number should be returned when your input array is just [a]. Then write an explicit expression for what number should be returned when the input array is [a, b], etc all the way until the array [a, b, c, d, e]. (Unless of course you notice the pattern earlier). \\n\\nGood Luck!"
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "Can anyone please tell me why this logic is failing for larger inputs?\nI tried with the sample and other smaller arrays and it worked fine, but failing for a case with 40 elements.\nIt's sort of a 2 pointer approach to calculate the power within boundaries\n` \nfunc sumOfPower(nums []int) int {\n\n\tsort.Ints(nums)\n\tpower := 0\n\tl := 0\n\tr := 0\n\tfor l < len(nums) {\n\t\tif r == len(nums) {\n\t\t\tl++\n\t\t\tr = l\n\t\t\tcontinue\n\t\t}\n\t\tminPower := nums[l]\n\t\tmaxPower := nums[r]\n\t\tif l == r {\n\t\t\tpower += ((maxPower * maxPower * minPower) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t} else {\n\t\t\tchars := int(math.Pow(float64(2), float64(r-l-1)))\n\t\t\tpower += (((maxPower * maxPower * minPower) * chars) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t}\n\t\tr++\n\t}\n\treturn (power % ((int(math.Pow(float64(10), float64(9)))) + 7))\n}\n\n`"
                    },
                    {
                        "username": "leana8959",
                        "content": "I haven\\'t solved this (my solution is timing out) but here are my two cents:\\n\\nYou\\'re using `float`s in your solution, which might cause imprecision.\\nAlso, maybe consider using a constant for the modulo number (10e9+7), so that it doesn\\'t need to compute that each time."
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "[@isnotavail](/isnotavail)  Ah alright, that would make sense, thank you!\\nIt\\'s Go Lang btw"
                    },
                    {
                        "username": "isnotavail",
                        "content": "I don\\'t know Java but the following line cannot be stored in  64 bits e.g 2^100\\nchars := int(math.Pow(float64(2), float64(r-l-1)))"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Am I the only one to read: \\'the power of this group is max(nums[i0], nums[i1], ... , nums[ik] ** 2 * min(nums[i0], nums[i1], ... ,nums[ik]).\\'\\n\\nI wasted so much time on this..."
                    }
                ]
            },
            {
                "id": 1894796,
                "content": [
                    {
                        "username": "Msey",
                        "content": "seemed to be easy but in fact it was a trap on contest"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as simple as it appears to be"
                    },
                    {
                        "username": "AntonBelski",
                        "content": "Can you shere with me similar problems here (leetcode) or in codeforces?"
                    },
                    {
                        "username": "ismailhossainraju74",
                        "content": "It could be segment  tree problem."
                    },
                    {
                        "username": "underscore_en",
                        "content": "caution backtracking -> TLE, think about how you can make use of max, min "
                    },
                    {
                        "username": "leana8959",
                        "content": "It is possible to do this below O(N^2) time complexity? (excluding the sorting).\\n\\nI managed to get the right result on my own, the only issue is that with the huge arrays in the end of the test cases are timing out.\\n\\nThanks"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question seems absurd. Theoretically you can only do better than O(n^2) if the array has many duplicate elements. Otherwise, you need to consider every single possible pair of (min, max) which is O(n^2). But with an input size of 10^5, I dont see how that\\'s possible. "
                    },
                    {
                        "username": "Sherif_Tarek",
                        "content": "Could someone please refer me to some tutorial to teach me where should I use the modulo when doing a lot of calculations like in this problem?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "In python, just use it at the end before you return the sum. We can do this because python supports much larger numbers than other languages."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "So some actual helpful hints because the questions hints aren\\'t great. \\n\\nFirst of all, if you are attempting a hard problem, you should already know that a max input size of 10^5 implies that an O(n^2) solution will not work. \\n\\nIt seems impossible, but there is indeed a true O(n) solution assuming nums is sorted. and therefore an O(nlogn) solution for this problem. \\n\\nNotice this is classified as a math problem, so whip out a pen and paper and try an example by hand. I would recomend setting your array to being \\na, b, c, d, e where you know a <= b <= c <= d =< e. (If you try this with an example array of 1, 2, 3, 4, 5 it will be harder to see how to simplify your solution to get an answer. \\n\\n(If you have made it this far, maybe try the advice given first before continuing). \\nIf you are still struggling, write an explicit expression for what number should be returned when your input array is just [a]. Then write an explicit expression for what number should be returned when the input array is [a, b], etc all the way until the array [a, b, c, d, e]. (Unless of course you notice the pattern earlier). \\n\\nGood Luck!"
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "Can anyone please tell me why this logic is failing for larger inputs?\nI tried with the sample and other smaller arrays and it worked fine, but failing for a case with 40 elements.\nIt's sort of a 2 pointer approach to calculate the power within boundaries\n` \nfunc sumOfPower(nums []int) int {\n\n\tsort.Ints(nums)\n\tpower := 0\n\tl := 0\n\tr := 0\n\tfor l < len(nums) {\n\t\tif r == len(nums) {\n\t\t\tl++\n\t\t\tr = l\n\t\t\tcontinue\n\t\t}\n\t\tminPower := nums[l]\n\t\tmaxPower := nums[r]\n\t\tif l == r {\n\t\t\tpower += ((maxPower * maxPower * minPower) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t} else {\n\t\t\tchars := int(math.Pow(float64(2), float64(r-l-1)))\n\t\t\tpower += (((maxPower * maxPower * minPower) * chars) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t}\n\t\tr++\n\t}\n\treturn (power % ((int(math.Pow(float64(10), float64(9)))) + 7))\n}\n\n`"
                    },
                    {
                        "username": "leana8959",
                        "content": "I haven\\'t solved this (my solution is timing out) but here are my two cents:\\n\\nYou\\'re using `float`s in your solution, which might cause imprecision.\\nAlso, maybe consider using a constant for the modulo number (10e9+7), so that it doesn\\'t need to compute that each time."
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "[@isnotavail](/isnotavail)  Ah alright, that would make sense, thank you!\\nIt\\'s Go Lang btw"
                    },
                    {
                        "username": "isnotavail",
                        "content": "I don\\'t know Java but the following line cannot be stored in  64 bits e.g 2^100\\nchars := int(math.Pow(float64(2), float64(r-l-1)))"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Am I the only one to read: \\'the power of this group is max(nums[i0], nums[i1], ... , nums[ik] ** 2 * min(nums[i0], nums[i1], ... ,nums[ik]).\\'\\n\\nI wasted so much time on this..."
                    }
                ]
            },
            {
                "id": 1892577,
                "content": [
                    {
                        "username": "Msey",
                        "content": "seemed to be easy but in fact it was a trap on contest"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as simple as it appears to be"
                    },
                    {
                        "username": "AntonBelski",
                        "content": "Can you shere with me similar problems here (leetcode) or in codeforces?"
                    },
                    {
                        "username": "ismailhossainraju74",
                        "content": "It could be segment  tree problem."
                    },
                    {
                        "username": "underscore_en",
                        "content": "caution backtracking -> TLE, think about how you can make use of max, min "
                    },
                    {
                        "username": "leana8959",
                        "content": "It is possible to do this below O(N^2) time complexity? (excluding the sorting).\\n\\nI managed to get the right result on my own, the only issue is that with the huge arrays in the end of the test cases are timing out.\\n\\nThanks"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question seems absurd. Theoretically you can only do better than O(n^2) if the array has many duplicate elements. Otherwise, you need to consider every single possible pair of (min, max) which is O(n^2). But with an input size of 10^5, I dont see how that\\'s possible. "
                    },
                    {
                        "username": "Sherif_Tarek",
                        "content": "Could someone please refer me to some tutorial to teach me where should I use the modulo when doing a lot of calculations like in this problem?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "In python, just use it at the end before you return the sum. We can do this because python supports much larger numbers than other languages."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "So some actual helpful hints because the questions hints aren\\'t great. \\n\\nFirst of all, if you are attempting a hard problem, you should already know that a max input size of 10^5 implies that an O(n^2) solution will not work. \\n\\nIt seems impossible, but there is indeed a true O(n) solution assuming nums is sorted. and therefore an O(nlogn) solution for this problem. \\n\\nNotice this is classified as a math problem, so whip out a pen and paper and try an example by hand. I would recomend setting your array to being \\na, b, c, d, e where you know a <= b <= c <= d =< e. (If you try this with an example array of 1, 2, 3, 4, 5 it will be harder to see how to simplify your solution to get an answer. \\n\\n(If you have made it this far, maybe try the advice given first before continuing). \\nIf you are still struggling, write an explicit expression for what number should be returned when your input array is just [a]. Then write an explicit expression for what number should be returned when the input array is [a, b], etc all the way until the array [a, b, c, d, e]. (Unless of course you notice the pattern earlier). \\n\\nGood Luck!"
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "Can anyone please tell me why this logic is failing for larger inputs?\nI tried with the sample and other smaller arrays and it worked fine, but failing for a case with 40 elements.\nIt's sort of a 2 pointer approach to calculate the power within boundaries\n` \nfunc sumOfPower(nums []int) int {\n\n\tsort.Ints(nums)\n\tpower := 0\n\tl := 0\n\tr := 0\n\tfor l < len(nums) {\n\t\tif r == len(nums) {\n\t\t\tl++\n\t\t\tr = l\n\t\t\tcontinue\n\t\t}\n\t\tminPower := nums[l]\n\t\tmaxPower := nums[r]\n\t\tif l == r {\n\t\t\tpower += ((maxPower * maxPower * minPower) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t} else {\n\t\t\tchars := int(math.Pow(float64(2), float64(r-l-1)))\n\t\t\tpower += (((maxPower * maxPower * minPower) * chars) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t}\n\t\tr++\n\t}\n\treturn (power % ((int(math.Pow(float64(10), float64(9)))) + 7))\n}\n\n`"
                    },
                    {
                        "username": "leana8959",
                        "content": "I haven\\'t solved this (my solution is timing out) but here are my two cents:\\n\\nYou\\'re using `float`s in your solution, which might cause imprecision.\\nAlso, maybe consider using a constant for the modulo number (10e9+7), so that it doesn\\'t need to compute that each time."
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "[@isnotavail](/isnotavail)  Ah alright, that would make sense, thank you!\\nIt\\'s Go Lang btw"
                    },
                    {
                        "username": "isnotavail",
                        "content": "I don\\'t know Java but the following line cannot be stored in  64 bits e.g 2^100\\nchars := int(math.Pow(float64(2), float64(r-l-1)))"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Am I the only one to read: \\'the power of this group is max(nums[i0], nums[i1], ... , nums[ik] ** 2 * min(nums[i0], nums[i1], ... ,nums[ik]).\\'\\n\\nI wasted so much time on this..."
                    }
                ]
            },
            {
                "id": 1892475,
                "content": [
                    {
                        "username": "Msey",
                        "content": "seemed to be easy but in fact it was a trap on contest"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as simple as it appears to be"
                    },
                    {
                        "username": "AntonBelski",
                        "content": "Can you shere with me similar problems here (leetcode) or in codeforces?"
                    },
                    {
                        "username": "ismailhossainraju74",
                        "content": "It could be segment  tree problem."
                    },
                    {
                        "username": "underscore_en",
                        "content": "caution backtracking -> TLE, think about how you can make use of max, min "
                    },
                    {
                        "username": "leana8959",
                        "content": "It is possible to do this below O(N^2) time complexity? (excluding the sorting).\\n\\nI managed to get the right result on my own, the only issue is that with the huge arrays in the end of the test cases are timing out.\\n\\nThanks"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question seems absurd. Theoretically you can only do better than O(n^2) if the array has many duplicate elements. Otherwise, you need to consider every single possible pair of (min, max) which is O(n^2). But with an input size of 10^5, I dont see how that\\'s possible. "
                    },
                    {
                        "username": "Sherif_Tarek",
                        "content": "Could someone please refer me to some tutorial to teach me where should I use the modulo when doing a lot of calculations like in this problem?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "In python, just use it at the end before you return the sum. We can do this because python supports much larger numbers than other languages."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "So some actual helpful hints because the questions hints aren\\'t great. \\n\\nFirst of all, if you are attempting a hard problem, you should already know that a max input size of 10^5 implies that an O(n^2) solution will not work. \\n\\nIt seems impossible, but there is indeed a true O(n) solution assuming nums is sorted. and therefore an O(nlogn) solution for this problem. \\n\\nNotice this is classified as a math problem, so whip out a pen and paper and try an example by hand. I would recomend setting your array to being \\na, b, c, d, e where you know a <= b <= c <= d =< e. (If you try this with an example array of 1, 2, 3, 4, 5 it will be harder to see how to simplify your solution to get an answer. \\n\\n(If you have made it this far, maybe try the advice given first before continuing). \\nIf you are still struggling, write an explicit expression for what number should be returned when your input array is just [a]. Then write an explicit expression for what number should be returned when the input array is [a, b], etc all the way until the array [a, b, c, d, e]. (Unless of course you notice the pattern earlier). \\n\\nGood Luck!"
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "Can anyone please tell me why this logic is failing for larger inputs?\nI tried with the sample and other smaller arrays and it worked fine, but failing for a case with 40 elements.\nIt's sort of a 2 pointer approach to calculate the power within boundaries\n` \nfunc sumOfPower(nums []int) int {\n\n\tsort.Ints(nums)\n\tpower := 0\n\tl := 0\n\tr := 0\n\tfor l < len(nums) {\n\t\tif r == len(nums) {\n\t\t\tl++\n\t\t\tr = l\n\t\t\tcontinue\n\t\t}\n\t\tminPower := nums[l]\n\t\tmaxPower := nums[r]\n\t\tif l == r {\n\t\t\tpower += ((maxPower * maxPower * minPower) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t} else {\n\t\t\tchars := int(math.Pow(float64(2), float64(r-l-1)))\n\t\t\tpower += (((maxPower * maxPower * minPower) * chars) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t}\n\t\tr++\n\t}\n\treturn (power % ((int(math.Pow(float64(10), float64(9)))) + 7))\n}\n\n`"
                    },
                    {
                        "username": "leana8959",
                        "content": "I haven\\'t solved this (my solution is timing out) but here are my two cents:\\n\\nYou\\'re using `float`s in your solution, which might cause imprecision.\\nAlso, maybe consider using a constant for the modulo number (10e9+7), so that it doesn\\'t need to compute that each time."
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "[@isnotavail](/isnotavail)  Ah alright, that would make sense, thank you!\\nIt\\'s Go Lang btw"
                    },
                    {
                        "username": "isnotavail",
                        "content": "I don\\'t know Java but the following line cannot be stored in  64 bits e.g 2^100\\nchars := int(math.Pow(float64(2), float64(r-l-1)))"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Am I the only one to read: \\'the power of this group is max(nums[i0], nums[i1], ... , nums[ik] ** 2 * min(nums[i0], nums[i1], ... ,nums[ik]).\\'\\n\\nI wasted so much time on this..."
                    }
                ]
            },
            {
                "id": 1892433,
                "content": [
                    {
                        "username": "Msey",
                        "content": "seemed to be easy but in fact it was a trap on contest"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as simple as it appears to be"
                    },
                    {
                        "username": "AntonBelski",
                        "content": "Can you shere with me similar problems here (leetcode) or in codeforces?"
                    },
                    {
                        "username": "ismailhossainraju74",
                        "content": "It could be segment  tree problem."
                    },
                    {
                        "username": "underscore_en",
                        "content": "caution backtracking -> TLE, think about how you can make use of max, min "
                    },
                    {
                        "username": "leana8959",
                        "content": "It is possible to do this below O(N^2) time complexity? (excluding the sorting).\\n\\nI managed to get the right result on my own, the only issue is that with the huge arrays in the end of the test cases are timing out.\\n\\nThanks"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question seems absurd. Theoretically you can only do better than O(n^2) if the array has many duplicate elements. Otherwise, you need to consider every single possible pair of (min, max) which is O(n^2). But with an input size of 10^5, I dont see how that\\'s possible. "
                    },
                    {
                        "username": "Sherif_Tarek",
                        "content": "Could someone please refer me to some tutorial to teach me where should I use the modulo when doing a lot of calculations like in this problem?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "In python, just use it at the end before you return the sum. We can do this because python supports much larger numbers than other languages."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "So some actual helpful hints because the questions hints aren\\'t great. \\n\\nFirst of all, if you are attempting a hard problem, you should already know that a max input size of 10^5 implies that an O(n^2) solution will not work. \\n\\nIt seems impossible, but there is indeed a true O(n) solution assuming nums is sorted. and therefore an O(nlogn) solution for this problem. \\n\\nNotice this is classified as a math problem, so whip out a pen and paper and try an example by hand. I would recomend setting your array to being \\na, b, c, d, e where you know a <= b <= c <= d =< e. (If you try this with an example array of 1, 2, 3, 4, 5 it will be harder to see how to simplify your solution to get an answer. \\n\\n(If you have made it this far, maybe try the advice given first before continuing). \\nIf you are still struggling, write an explicit expression for what number should be returned when your input array is just [a]. Then write an explicit expression for what number should be returned when the input array is [a, b], etc all the way until the array [a, b, c, d, e]. (Unless of course you notice the pattern earlier). \\n\\nGood Luck!"
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "Can anyone please tell me why this logic is failing for larger inputs?\nI tried with the sample and other smaller arrays and it worked fine, but failing for a case with 40 elements.\nIt's sort of a 2 pointer approach to calculate the power within boundaries\n` \nfunc sumOfPower(nums []int) int {\n\n\tsort.Ints(nums)\n\tpower := 0\n\tl := 0\n\tr := 0\n\tfor l < len(nums) {\n\t\tif r == len(nums) {\n\t\t\tl++\n\t\t\tr = l\n\t\t\tcontinue\n\t\t}\n\t\tminPower := nums[l]\n\t\tmaxPower := nums[r]\n\t\tif l == r {\n\t\t\tpower += ((maxPower * maxPower * minPower) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t} else {\n\t\t\tchars := int(math.Pow(float64(2), float64(r-l-1)))\n\t\t\tpower += (((maxPower * maxPower * minPower) * chars) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t}\n\t\tr++\n\t}\n\treturn (power % ((int(math.Pow(float64(10), float64(9)))) + 7))\n}\n\n`"
                    },
                    {
                        "username": "leana8959",
                        "content": "I haven\\'t solved this (my solution is timing out) but here are my two cents:\\n\\nYou\\'re using `float`s in your solution, which might cause imprecision.\\nAlso, maybe consider using a constant for the modulo number (10e9+7), so that it doesn\\'t need to compute that each time."
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "[@isnotavail](/isnotavail)  Ah alright, that would make sense, thank you!\\nIt\\'s Go Lang btw"
                    },
                    {
                        "username": "isnotavail",
                        "content": "I don\\'t know Java but the following line cannot be stored in  64 bits e.g 2^100\\nchars := int(math.Pow(float64(2), float64(r-l-1)))"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Am I the only one to read: \\'the power of this group is max(nums[i0], nums[i1], ... , nums[ik] ** 2 * min(nums[i0], nums[i1], ... ,nums[ik]).\\'\\n\\nI wasted so much time on this..."
                    }
                ]
            },
            {
                "id": 1898466,
                "content": [
                    {
                        "username": "Msey",
                        "content": "seemed to be easy but in fact it was a trap on contest"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as simple as it appears to be"
                    },
                    {
                        "username": "AntonBelski",
                        "content": "Can you shere with me similar problems here (leetcode) or in codeforces?"
                    },
                    {
                        "username": "ismailhossainraju74",
                        "content": "It could be segment  tree problem."
                    },
                    {
                        "username": "underscore_en",
                        "content": "caution backtracking -> TLE, think about how you can make use of max, min "
                    },
                    {
                        "username": "leana8959",
                        "content": "It is possible to do this below O(N^2) time complexity? (excluding the sorting).\\n\\nI managed to get the right result on my own, the only issue is that with the huge arrays in the end of the test cases are timing out.\\n\\nThanks"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question seems absurd. Theoretically you can only do better than O(n^2) if the array has many duplicate elements. Otherwise, you need to consider every single possible pair of (min, max) which is O(n^2). But with an input size of 10^5, I dont see how that\\'s possible. "
                    },
                    {
                        "username": "Sherif_Tarek",
                        "content": "Could someone please refer me to some tutorial to teach me where should I use the modulo when doing a lot of calculations like in this problem?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "In python, just use it at the end before you return the sum. We can do this because python supports much larger numbers than other languages."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "So some actual helpful hints because the questions hints aren\\'t great. \\n\\nFirst of all, if you are attempting a hard problem, you should already know that a max input size of 10^5 implies that an O(n^2) solution will not work. \\n\\nIt seems impossible, but there is indeed a true O(n) solution assuming nums is sorted. and therefore an O(nlogn) solution for this problem. \\n\\nNotice this is classified as a math problem, so whip out a pen and paper and try an example by hand. I would recomend setting your array to being \\na, b, c, d, e where you know a <= b <= c <= d =< e. (If you try this with an example array of 1, 2, 3, 4, 5 it will be harder to see how to simplify your solution to get an answer. \\n\\n(If you have made it this far, maybe try the advice given first before continuing). \\nIf you are still struggling, write an explicit expression for what number should be returned when your input array is just [a]. Then write an explicit expression for what number should be returned when the input array is [a, b], etc all the way until the array [a, b, c, d, e]. (Unless of course you notice the pattern earlier). \\n\\nGood Luck!"
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "Can anyone please tell me why this logic is failing for larger inputs?\nI tried with the sample and other smaller arrays and it worked fine, but failing for a case with 40 elements.\nIt's sort of a 2 pointer approach to calculate the power within boundaries\n` \nfunc sumOfPower(nums []int) int {\n\n\tsort.Ints(nums)\n\tpower := 0\n\tl := 0\n\tr := 0\n\tfor l < len(nums) {\n\t\tif r == len(nums) {\n\t\t\tl++\n\t\t\tr = l\n\t\t\tcontinue\n\t\t}\n\t\tminPower := nums[l]\n\t\tmaxPower := nums[r]\n\t\tif l == r {\n\t\t\tpower += ((maxPower * maxPower * minPower) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t} else {\n\t\t\tchars := int(math.Pow(float64(2), float64(r-l-1)))\n\t\t\tpower += (((maxPower * maxPower * minPower) * chars) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t}\n\t\tr++\n\t}\n\treturn (power % ((int(math.Pow(float64(10), float64(9)))) + 7))\n}\n\n`"
                    },
                    {
                        "username": "leana8959",
                        "content": "I haven\\'t solved this (my solution is timing out) but here are my two cents:\\n\\nYou\\'re using `float`s in your solution, which might cause imprecision.\\nAlso, maybe consider using a constant for the modulo number (10e9+7), so that it doesn\\'t need to compute that each time."
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "[@isnotavail](/isnotavail)  Ah alright, that would make sense, thank you!\\nIt\\'s Go Lang btw"
                    },
                    {
                        "username": "isnotavail",
                        "content": "I don\\'t know Java but the following line cannot be stored in  64 bits e.g 2^100\\nchars := int(math.Pow(float64(2), float64(r-l-1)))"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Am I the only one to read: \\'the power of this group is max(nums[i0], nums[i1], ... , nums[ik] ** 2 * min(nums[i0], nums[i1], ... ,nums[ik]).\\'\\n\\nI wasted so much time on this..."
                    }
                ]
            },
            {
                "id": 1892539,
                "content": [
                    {
                        "username": "Msey",
                        "content": "seemed to be easy but in fact it was a trap on contest"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as simple as it appears to be"
                    },
                    {
                        "username": "AntonBelski",
                        "content": "Can you shere with me similar problems here (leetcode) or in codeforces?"
                    },
                    {
                        "username": "ismailhossainraju74",
                        "content": "It could be segment  tree problem."
                    },
                    {
                        "username": "underscore_en",
                        "content": "caution backtracking -> TLE, think about how you can make use of max, min "
                    },
                    {
                        "username": "leana8959",
                        "content": "It is possible to do this below O(N^2) time complexity? (excluding the sorting).\\n\\nI managed to get the right result on my own, the only issue is that with the huge arrays in the end of the test cases are timing out.\\n\\nThanks"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question seems absurd. Theoretically you can only do better than O(n^2) if the array has many duplicate elements. Otherwise, you need to consider every single possible pair of (min, max) which is O(n^2). But with an input size of 10^5, I dont see how that\\'s possible. "
                    },
                    {
                        "username": "Sherif_Tarek",
                        "content": "Could someone please refer me to some tutorial to teach me where should I use the modulo when doing a lot of calculations like in this problem?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "In python, just use it at the end before you return the sum. We can do this because python supports much larger numbers than other languages."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "So some actual helpful hints because the questions hints aren\\'t great. \\n\\nFirst of all, if you are attempting a hard problem, you should already know that a max input size of 10^5 implies that an O(n^2) solution will not work. \\n\\nIt seems impossible, but there is indeed a true O(n) solution assuming nums is sorted. and therefore an O(nlogn) solution for this problem. \\n\\nNotice this is classified as a math problem, so whip out a pen and paper and try an example by hand. I would recomend setting your array to being \\na, b, c, d, e where you know a <= b <= c <= d =< e. (If you try this with an example array of 1, 2, 3, 4, 5 it will be harder to see how to simplify your solution to get an answer. \\n\\n(If you have made it this far, maybe try the advice given first before continuing). \\nIf you are still struggling, write an explicit expression for what number should be returned when your input array is just [a]. Then write an explicit expression for what number should be returned when the input array is [a, b], etc all the way until the array [a, b, c, d, e]. (Unless of course you notice the pattern earlier). \\n\\nGood Luck!"
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "Can anyone please tell me why this logic is failing for larger inputs?\nI tried with the sample and other smaller arrays and it worked fine, but failing for a case with 40 elements.\nIt's sort of a 2 pointer approach to calculate the power within boundaries\n` \nfunc sumOfPower(nums []int) int {\n\n\tsort.Ints(nums)\n\tpower := 0\n\tl := 0\n\tr := 0\n\tfor l < len(nums) {\n\t\tif r == len(nums) {\n\t\t\tl++\n\t\t\tr = l\n\t\t\tcontinue\n\t\t}\n\t\tminPower := nums[l]\n\t\tmaxPower := nums[r]\n\t\tif l == r {\n\t\t\tpower += ((maxPower * maxPower * minPower) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t} else {\n\t\t\tchars := int(math.Pow(float64(2), float64(r-l-1)))\n\t\t\tpower += (((maxPower * maxPower * minPower) * chars) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t}\n\t\tr++\n\t}\n\treturn (power % ((int(math.Pow(float64(10), float64(9)))) + 7))\n}\n\n`"
                    },
                    {
                        "username": "leana8959",
                        "content": "I haven\\'t solved this (my solution is timing out) but here are my two cents:\\n\\nYou\\'re using `float`s in your solution, which might cause imprecision.\\nAlso, maybe consider using a constant for the modulo number (10e9+7), so that it doesn\\'t need to compute that each time."
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "[@isnotavail](/isnotavail)  Ah alright, that would make sense, thank you!\\nIt\\'s Go Lang btw"
                    },
                    {
                        "username": "isnotavail",
                        "content": "I don\\'t know Java but the following line cannot be stored in  64 bits e.g 2^100\\nchars := int(math.Pow(float64(2), float64(r-l-1)))"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Am I the only one to read: \\'the power of this group is max(nums[i0], nums[i1], ... , nums[ik] ** 2 * min(nums[i0], nums[i1], ... ,nums[ik]).\\'\\n\\nI wasted so much time on this..."
                    }
                ]
            },
            {
                "id": 2038366,
                "content": [
                    {
                        "username": "Msey",
                        "content": "seemed to be easy but in fact it was a trap on contest"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as simple as it appears to be"
                    },
                    {
                        "username": "AntonBelski",
                        "content": "Can you shere with me similar problems here (leetcode) or in codeforces?"
                    },
                    {
                        "username": "ismailhossainraju74",
                        "content": "It could be segment  tree problem."
                    },
                    {
                        "username": "underscore_en",
                        "content": "caution backtracking -> TLE, think about how you can make use of max, min "
                    },
                    {
                        "username": "leana8959",
                        "content": "It is possible to do this below O(N^2) time complexity? (excluding the sorting).\\n\\nI managed to get the right result on my own, the only issue is that with the huge arrays in the end of the test cases are timing out.\\n\\nThanks"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question seems absurd. Theoretically you can only do better than O(n^2) if the array has many duplicate elements. Otherwise, you need to consider every single possible pair of (min, max) which is O(n^2). But with an input size of 10^5, I dont see how that\\'s possible. "
                    },
                    {
                        "username": "Sherif_Tarek",
                        "content": "Could someone please refer me to some tutorial to teach me where should I use the modulo when doing a lot of calculations like in this problem?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "In python, just use it at the end before you return the sum. We can do this because python supports much larger numbers than other languages."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "So some actual helpful hints because the questions hints aren\\'t great. \\n\\nFirst of all, if you are attempting a hard problem, you should already know that a max input size of 10^5 implies that an O(n^2) solution will not work. \\n\\nIt seems impossible, but there is indeed a true O(n) solution assuming nums is sorted. and therefore an O(nlogn) solution for this problem. \\n\\nNotice this is classified as a math problem, so whip out a pen and paper and try an example by hand. I would recomend setting your array to being \\na, b, c, d, e where you know a <= b <= c <= d =< e. (If you try this with an example array of 1, 2, 3, 4, 5 it will be harder to see how to simplify your solution to get an answer. \\n\\n(If you have made it this far, maybe try the advice given first before continuing). \\nIf you are still struggling, write an explicit expression for what number should be returned when your input array is just [a]. Then write an explicit expression for what number should be returned when the input array is [a, b], etc all the way until the array [a, b, c, d, e]. (Unless of course you notice the pattern earlier). \\n\\nGood Luck!"
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "Can anyone please tell me why this logic is failing for larger inputs?\nI tried with the sample and other smaller arrays and it worked fine, but failing for a case with 40 elements.\nIt's sort of a 2 pointer approach to calculate the power within boundaries\n` \nfunc sumOfPower(nums []int) int {\n\n\tsort.Ints(nums)\n\tpower := 0\n\tl := 0\n\tr := 0\n\tfor l < len(nums) {\n\t\tif r == len(nums) {\n\t\t\tl++\n\t\t\tr = l\n\t\t\tcontinue\n\t\t}\n\t\tminPower := nums[l]\n\t\tmaxPower := nums[r]\n\t\tif l == r {\n\t\t\tpower += ((maxPower * maxPower * minPower) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t} else {\n\t\t\tchars := int(math.Pow(float64(2), float64(r-l-1)))\n\t\t\tpower += (((maxPower * maxPower * minPower) * chars) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t}\n\t\tr++\n\t}\n\treturn (power % ((int(math.Pow(float64(10), float64(9)))) + 7))\n}\n\n`"
                    },
                    {
                        "username": "leana8959",
                        "content": "I haven\\'t solved this (my solution is timing out) but here are my two cents:\\n\\nYou\\'re using `float`s in your solution, which might cause imprecision.\\nAlso, maybe consider using a constant for the modulo number (10e9+7), so that it doesn\\'t need to compute that each time."
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "[@isnotavail](/isnotavail)  Ah alright, that would make sense, thank you!\\nIt\\'s Go Lang btw"
                    },
                    {
                        "username": "isnotavail",
                        "content": "I don\\'t know Java but the following line cannot be stored in  64 bits e.g 2^100\\nchars := int(math.Pow(float64(2), float64(r-l-1)))"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Am I the only one to read: \\'the power of this group is max(nums[i0], nums[i1], ... , nums[ik] ** 2 * min(nums[i0], nums[i1], ... ,nums[ik]).\\'\\n\\nI wasted so much time on this..."
                    }
                ]
            },
            {
                "id": 1892794,
                "content": [
                    {
                        "username": "Msey",
                        "content": "seemed to be easy but in fact it was a trap on contest"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as simple as it appears to be"
                    },
                    {
                        "username": "AntonBelski",
                        "content": "Can you shere with me similar problems here (leetcode) or in codeforces?"
                    },
                    {
                        "username": "ismailhossainraju74",
                        "content": "It could be segment  tree problem."
                    },
                    {
                        "username": "underscore_en",
                        "content": "caution backtracking -> TLE, think about how you can make use of max, min "
                    },
                    {
                        "username": "leana8959",
                        "content": "It is possible to do this below O(N^2) time complexity? (excluding the sorting).\\n\\nI managed to get the right result on my own, the only issue is that with the huge arrays in the end of the test cases are timing out.\\n\\nThanks"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question seems absurd. Theoretically you can only do better than O(n^2) if the array has many duplicate elements. Otherwise, you need to consider every single possible pair of (min, max) which is O(n^2). But with an input size of 10^5, I dont see how that\\'s possible. "
                    },
                    {
                        "username": "Sherif_Tarek",
                        "content": "Could someone please refer me to some tutorial to teach me where should I use the modulo when doing a lot of calculations like in this problem?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "In python, just use it at the end before you return the sum. We can do this because python supports much larger numbers than other languages."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "So some actual helpful hints because the questions hints aren\\'t great. \\n\\nFirst of all, if you are attempting a hard problem, you should already know that a max input size of 10^5 implies that an O(n^2) solution will not work. \\n\\nIt seems impossible, but there is indeed a true O(n) solution assuming nums is sorted. and therefore an O(nlogn) solution for this problem. \\n\\nNotice this is classified as a math problem, so whip out a pen and paper and try an example by hand. I would recomend setting your array to being \\na, b, c, d, e where you know a <= b <= c <= d =< e. (If you try this with an example array of 1, 2, 3, 4, 5 it will be harder to see how to simplify your solution to get an answer. \\n\\n(If you have made it this far, maybe try the advice given first before continuing). \\nIf you are still struggling, write an explicit expression for what number should be returned when your input array is just [a]. Then write an explicit expression for what number should be returned when the input array is [a, b], etc all the way until the array [a, b, c, d, e]. (Unless of course you notice the pattern earlier). \\n\\nGood Luck!"
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "Can anyone please tell me why this logic is failing for larger inputs?\nI tried with the sample and other smaller arrays and it worked fine, but failing for a case with 40 elements.\nIt's sort of a 2 pointer approach to calculate the power within boundaries\n` \nfunc sumOfPower(nums []int) int {\n\n\tsort.Ints(nums)\n\tpower := 0\n\tl := 0\n\tr := 0\n\tfor l < len(nums) {\n\t\tif r == len(nums) {\n\t\t\tl++\n\t\t\tr = l\n\t\t\tcontinue\n\t\t}\n\t\tminPower := nums[l]\n\t\tmaxPower := nums[r]\n\t\tif l == r {\n\t\t\tpower += ((maxPower * maxPower * minPower) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t} else {\n\t\t\tchars := int(math.Pow(float64(2), float64(r-l-1)))\n\t\t\tpower += (((maxPower * maxPower * minPower) * chars) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t}\n\t\tr++\n\t}\n\treturn (power % ((int(math.Pow(float64(10), float64(9)))) + 7))\n}\n\n`"
                    },
                    {
                        "username": "leana8959",
                        "content": "I haven\\'t solved this (my solution is timing out) but here are my two cents:\\n\\nYou\\'re using `float`s in your solution, which might cause imprecision.\\nAlso, maybe consider using a constant for the modulo number (10e9+7), so that it doesn\\'t need to compute that each time."
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "[@isnotavail](/isnotavail)  Ah alright, that would make sense, thank you!\\nIt\\'s Go Lang btw"
                    },
                    {
                        "username": "isnotavail",
                        "content": "I don\\'t know Java but the following line cannot be stored in  64 bits e.g 2^100\\nchars := int(math.Pow(float64(2), float64(r-l-1)))"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Am I the only one to read: \\'the power of this group is max(nums[i0], nums[i1], ... , nums[ik] ** 2 * min(nums[i0], nums[i1], ... ,nums[ik]).\\'\\n\\nI wasted so much time on this..."
                    }
                ]
            },
            {
                "id": 1892584,
                "content": [
                    {
                        "username": "Msey",
                        "content": "seemed to be easy but in fact it was a trap on contest"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as simple as it appears to be"
                    },
                    {
                        "username": "AntonBelski",
                        "content": "Can you shere with me similar problems here (leetcode) or in codeforces?"
                    },
                    {
                        "username": "ismailhossainraju74",
                        "content": "It could be segment  tree problem."
                    },
                    {
                        "username": "underscore_en",
                        "content": "caution backtracking -> TLE, think about how you can make use of max, min "
                    },
                    {
                        "username": "leana8959",
                        "content": "It is possible to do this below O(N^2) time complexity? (excluding the sorting).\\n\\nI managed to get the right result on my own, the only issue is that with the huge arrays in the end of the test cases are timing out.\\n\\nThanks"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question seems absurd. Theoretically you can only do better than O(n^2) if the array has many duplicate elements. Otherwise, you need to consider every single possible pair of (min, max) which is O(n^2). But with an input size of 10^5, I dont see how that\\'s possible. "
                    },
                    {
                        "username": "Sherif_Tarek",
                        "content": "Could someone please refer me to some tutorial to teach me where should I use the modulo when doing a lot of calculations like in this problem?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "In python, just use it at the end before you return the sum. We can do this because python supports much larger numbers than other languages."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "So some actual helpful hints because the questions hints aren\\'t great. \\n\\nFirst of all, if you are attempting a hard problem, you should already know that a max input size of 10^5 implies that an O(n^2) solution will not work. \\n\\nIt seems impossible, but there is indeed a true O(n) solution assuming nums is sorted. and therefore an O(nlogn) solution for this problem. \\n\\nNotice this is classified as a math problem, so whip out a pen and paper and try an example by hand. I would recomend setting your array to being \\na, b, c, d, e where you know a <= b <= c <= d =< e. (If you try this with an example array of 1, 2, 3, 4, 5 it will be harder to see how to simplify your solution to get an answer. \\n\\n(If you have made it this far, maybe try the advice given first before continuing). \\nIf you are still struggling, write an explicit expression for what number should be returned when your input array is just [a]. Then write an explicit expression for what number should be returned when the input array is [a, b], etc all the way until the array [a, b, c, d, e]. (Unless of course you notice the pattern earlier). \\n\\nGood Luck!"
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "Can anyone please tell me why this logic is failing for larger inputs?\nI tried with the sample and other smaller arrays and it worked fine, but failing for a case with 40 elements.\nIt's sort of a 2 pointer approach to calculate the power within boundaries\n` \nfunc sumOfPower(nums []int) int {\n\n\tsort.Ints(nums)\n\tpower := 0\n\tl := 0\n\tr := 0\n\tfor l < len(nums) {\n\t\tif r == len(nums) {\n\t\t\tl++\n\t\t\tr = l\n\t\t\tcontinue\n\t\t}\n\t\tminPower := nums[l]\n\t\tmaxPower := nums[r]\n\t\tif l == r {\n\t\t\tpower += ((maxPower * maxPower * minPower) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t} else {\n\t\t\tchars := int(math.Pow(float64(2), float64(r-l-1)))\n\t\t\tpower += (((maxPower * maxPower * minPower) * chars) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t}\n\t\tr++\n\t}\n\treturn (power % ((int(math.Pow(float64(10), float64(9)))) + 7))\n}\n\n`"
                    },
                    {
                        "username": "leana8959",
                        "content": "I haven\\'t solved this (my solution is timing out) but here are my two cents:\\n\\nYou\\'re using `float`s in your solution, which might cause imprecision.\\nAlso, maybe consider using a constant for the modulo number (10e9+7), so that it doesn\\'t need to compute that each time."
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "[@isnotavail](/isnotavail)  Ah alright, that would make sense, thank you!\\nIt\\'s Go Lang btw"
                    },
                    {
                        "username": "isnotavail",
                        "content": "I don\\'t know Java but the following line cannot be stored in  64 bits e.g 2^100\\nchars := int(math.Pow(float64(2), float64(r-l-1)))"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Am I the only one to read: \\'the power of this group is max(nums[i0], nums[i1], ... , nums[ik] ** 2 * min(nums[i0], nums[i1], ... ,nums[ik]).\\'\\n\\nI wasted so much time on this..."
                    }
                ]
            },
            {
                "id": 1892441,
                "content": [
                    {
                        "username": "Msey",
                        "content": "seemed to be easy but in fact it was a trap on contest"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as simple as it appears to be"
                    },
                    {
                        "username": "AntonBelski",
                        "content": "Can you shere with me similar problems here (leetcode) or in codeforces?"
                    },
                    {
                        "username": "ismailhossainraju74",
                        "content": "It could be segment  tree problem."
                    },
                    {
                        "username": "underscore_en",
                        "content": "caution backtracking -> TLE, think about how you can make use of max, min "
                    },
                    {
                        "username": "leana8959",
                        "content": "It is possible to do this below O(N^2) time complexity? (excluding the sorting).\\n\\nI managed to get the right result on my own, the only issue is that with the huge arrays in the end of the test cases are timing out.\\n\\nThanks"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question seems absurd. Theoretically you can only do better than O(n^2) if the array has many duplicate elements. Otherwise, you need to consider every single possible pair of (min, max) which is O(n^2). But with an input size of 10^5, I dont see how that\\'s possible. "
                    },
                    {
                        "username": "Sherif_Tarek",
                        "content": "Could someone please refer me to some tutorial to teach me where should I use the modulo when doing a lot of calculations like in this problem?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "In python, just use it at the end before you return the sum. We can do this because python supports much larger numbers than other languages."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "So some actual helpful hints because the questions hints aren\\'t great. \\n\\nFirst of all, if you are attempting a hard problem, you should already know that a max input size of 10^5 implies that an O(n^2) solution will not work. \\n\\nIt seems impossible, but there is indeed a true O(n) solution assuming nums is sorted. and therefore an O(nlogn) solution for this problem. \\n\\nNotice this is classified as a math problem, so whip out a pen and paper and try an example by hand. I would recomend setting your array to being \\na, b, c, d, e where you know a <= b <= c <= d =< e. (If you try this with an example array of 1, 2, 3, 4, 5 it will be harder to see how to simplify your solution to get an answer. \\n\\n(If you have made it this far, maybe try the advice given first before continuing). \\nIf you are still struggling, write an explicit expression for what number should be returned when your input array is just [a]. Then write an explicit expression for what number should be returned when the input array is [a, b], etc all the way until the array [a, b, c, d, e]. (Unless of course you notice the pattern earlier). \\n\\nGood Luck!"
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "Can anyone please tell me why this logic is failing for larger inputs?\nI tried with the sample and other smaller arrays and it worked fine, but failing for a case with 40 elements.\nIt's sort of a 2 pointer approach to calculate the power within boundaries\n` \nfunc sumOfPower(nums []int) int {\n\n\tsort.Ints(nums)\n\tpower := 0\n\tl := 0\n\tr := 0\n\tfor l < len(nums) {\n\t\tif r == len(nums) {\n\t\t\tl++\n\t\t\tr = l\n\t\t\tcontinue\n\t\t}\n\t\tminPower := nums[l]\n\t\tmaxPower := nums[r]\n\t\tif l == r {\n\t\t\tpower += ((maxPower * maxPower * minPower) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t} else {\n\t\t\tchars := int(math.Pow(float64(2), float64(r-l-1)))\n\t\t\tpower += (((maxPower * maxPower * minPower) * chars) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t}\n\t\tr++\n\t}\n\treturn (power % ((int(math.Pow(float64(10), float64(9)))) + 7))\n}\n\n`"
                    },
                    {
                        "username": "leana8959",
                        "content": "I haven\\'t solved this (my solution is timing out) but here are my two cents:\\n\\nYou\\'re using `float`s in your solution, which might cause imprecision.\\nAlso, maybe consider using a constant for the modulo number (10e9+7), so that it doesn\\'t need to compute that each time."
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "[@isnotavail](/isnotavail)  Ah alright, that would make sense, thank you!\\nIt\\'s Go Lang btw"
                    },
                    {
                        "username": "isnotavail",
                        "content": "I don\\'t know Java but the following line cannot be stored in  64 bits e.g 2^100\\nchars := int(math.Pow(float64(2), float64(r-l-1)))"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Am I the only one to read: \\'the power of this group is max(nums[i0], nums[i1], ... , nums[ik] ** 2 * min(nums[i0], nums[i1], ... ,nums[ik]).\\'\\n\\nI wasted so much time on this..."
                    }
                ]
            },
            {
                "id": 1894796,
                "content": [
                    {
                        "username": "Msey",
                        "content": "seemed to be easy but in fact it was a trap on contest"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as simple as it appears to be"
                    },
                    {
                        "username": "AntonBelski",
                        "content": "Can you shere with me similar problems here (leetcode) or in codeforces?"
                    },
                    {
                        "username": "ismailhossainraju74",
                        "content": "It could be segment  tree problem."
                    },
                    {
                        "username": "underscore_en",
                        "content": "caution backtracking -> TLE, think about how you can make use of max, min "
                    },
                    {
                        "username": "leana8959",
                        "content": "It is possible to do this below O(N^2) time complexity? (excluding the sorting).\\n\\nI managed to get the right result on my own, the only issue is that with the huge arrays in the end of the test cases are timing out.\\n\\nThanks"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question seems absurd. Theoretically you can only do better than O(n^2) if the array has many duplicate elements. Otherwise, you need to consider every single possible pair of (min, max) which is O(n^2). But with an input size of 10^5, I dont see how that\\'s possible. "
                    },
                    {
                        "username": "Sherif_Tarek",
                        "content": "Could someone please refer me to some tutorial to teach me where should I use the modulo when doing a lot of calculations like in this problem?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "In python, just use it at the end before you return the sum. We can do this because python supports much larger numbers than other languages."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "So some actual helpful hints because the questions hints aren\\'t great. \\n\\nFirst of all, if you are attempting a hard problem, you should already know that a max input size of 10^5 implies that an O(n^2) solution will not work. \\n\\nIt seems impossible, but there is indeed a true O(n) solution assuming nums is sorted. and therefore an O(nlogn) solution for this problem. \\n\\nNotice this is classified as a math problem, so whip out a pen and paper and try an example by hand. I would recomend setting your array to being \\na, b, c, d, e where you know a <= b <= c <= d =< e. (If you try this with an example array of 1, 2, 3, 4, 5 it will be harder to see how to simplify your solution to get an answer. \\n\\n(If you have made it this far, maybe try the advice given first before continuing). \\nIf you are still struggling, write an explicit expression for what number should be returned when your input array is just [a]. Then write an explicit expression for what number should be returned when the input array is [a, b], etc all the way until the array [a, b, c, d, e]. (Unless of course you notice the pattern earlier). \\n\\nGood Luck!"
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "Can anyone please tell me why this logic is failing for larger inputs?\nI tried with the sample and other smaller arrays and it worked fine, but failing for a case with 40 elements.\nIt's sort of a 2 pointer approach to calculate the power within boundaries\n` \nfunc sumOfPower(nums []int) int {\n\n\tsort.Ints(nums)\n\tpower := 0\n\tl := 0\n\tr := 0\n\tfor l < len(nums) {\n\t\tif r == len(nums) {\n\t\t\tl++\n\t\t\tr = l\n\t\t\tcontinue\n\t\t}\n\t\tminPower := nums[l]\n\t\tmaxPower := nums[r]\n\t\tif l == r {\n\t\t\tpower += ((maxPower * maxPower * minPower) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t} else {\n\t\t\tchars := int(math.Pow(float64(2), float64(r-l-1)))\n\t\t\tpower += (((maxPower * maxPower * minPower) * chars) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t}\n\t\tr++\n\t}\n\treturn (power % ((int(math.Pow(float64(10), float64(9)))) + 7))\n}\n\n`"
                    },
                    {
                        "username": "leana8959",
                        "content": "I haven\\'t solved this (my solution is timing out) but here are my two cents:\\n\\nYou\\'re using `float`s in your solution, which might cause imprecision.\\nAlso, maybe consider using a constant for the modulo number (10e9+7), so that it doesn\\'t need to compute that each time."
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "[@isnotavail](/isnotavail)  Ah alright, that would make sense, thank you!\\nIt\\'s Go Lang btw"
                    },
                    {
                        "username": "isnotavail",
                        "content": "I don\\'t know Java but the following line cannot be stored in  64 bits e.g 2^100\\nchars := int(math.Pow(float64(2), float64(r-l-1)))"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Am I the only one to read: \\'the power of this group is max(nums[i0], nums[i1], ... , nums[ik] ** 2 * min(nums[i0], nums[i1], ... ,nums[ik]).\\'\\n\\nI wasted so much time on this..."
                    }
                ]
            },
            {
                "id": 1892577,
                "content": [
                    {
                        "username": "Msey",
                        "content": "seemed to be easy but in fact it was a trap on contest"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as simple as it appears to be"
                    },
                    {
                        "username": "AntonBelski",
                        "content": "Can you shere with me similar problems here (leetcode) or in codeforces?"
                    },
                    {
                        "username": "ismailhossainraju74",
                        "content": "It could be segment  tree problem."
                    },
                    {
                        "username": "underscore_en",
                        "content": "caution backtracking -> TLE, think about how you can make use of max, min "
                    },
                    {
                        "username": "leana8959",
                        "content": "It is possible to do this below O(N^2) time complexity? (excluding the sorting).\\n\\nI managed to get the right result on my own, the only issue is that with the huge arrays in the end of the test cases are timing out.\\n\\nThanks"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question seems absurd. Theoretically you can only do better than O(n^2) if the array has many duplicate elements. Otherwise, you need to consider every single possible pair of (min, max) which is O(n^2). But with an input size of 10^5, I dont see how that\\'s possible. "
                    },
                    {
                        "username": "Sherif_Tarek",
                        "content": "Could someone please refer me to some tutorial to teach me where should I use the modulo when doing a lot of calculations like in this problem?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "In python, just use it at the end before you return the sum. We can do this because python supports much larger numbers than other languages."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "So some actual helpful hints because the questions hints aren\\'t great. \\n\\nFirst of all, if you are attempting a hard problem, you should already know that a max input size of 10^5 implies that an O(n^2) solution will not work. \\n\\nIt seems impossible, but there is indeed a true O(n) solution assuming nums is sorted. and therefore an O(nlogn) solution for this problem. \\n\\nNotice this is classified as a math problem, so whip out a pen and paper and try an example by hand. I would recomend setting your array to being \\na, b, c, d, e where you know a <= b <= c <= d =< e. (If you try this with an example array of 1, 2, 3, 4, 5 it will be harder to see how to simplify your solution to get an answer. \\n\\n(If you have made it this far, maybe try the advice given first before continuing). \\nIf you are still struggling, write an explicit expression for what number should be returned when your input array is just [a]. Then write an explicit expression for what number should be returned when the input array is [a, b], etc all the way until the array [a, b, c, d, e]. (Unless of course you notice the pattern earlier). \\n\\nGood Luck!"
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "Can anyone please tell me why this logic is failing for larger inputs?\nI tried with the sample and other smaller arrays and it worked fine, but failing for a case with 40 elements.\nIt's sort of a 2 pointer approach to calculate the power within boundaries\n` \nfunc sumOfPower(nums []int) int {\n\n\tsort.Ints(nums)\n\tpower := 0\n\tl := 0\n\tr := 0\n\tfor l < len(nums) {\n\t\tif r == len(nums) {\n\t\t\tl++\n\t\t\tr = l\n\t\t\tcontinue\n\t\t}\n\t\tminPower := nums[l]\n\t\tmaxPower := nums[r]\n\t\tif l == r {\n\t\t\tpower += ((maxPower * maxPower * minPower) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t} else {\n\t\t\tchars := int(math.Pow(float64(2), float64(r-l-1)))\n\t\t\tpower += (((maxPower * maxPower * minPower) * chars) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t}\n\t\tr++\n\t}\n\treturn (power % ((int(math.Pow(float64(10), float64(9)))) + 7))\n}\n\n`"
                    },
                    {
                        "username": "leana8959",
                        "content": "I haven\\'t solved this (my solution is timing out) but here are my two cents:\\n\\nYou\\'re using `float`s in your solution, which might cause imprecision.\\nAlso, maybe consider using a constant for the modulo number (10e9+7), so that it doesn\\'t need to compute that each time."
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "[@isnotavail](/isnotavail)  Ah alright, that would make sense, thank you!\\nIt\\'s Go Lang btw"
                    },
                    {
                        "username": "isnotavail",
                        "content": "I don\\'t know Java but the following line cannot be stored in  64 bits e.g 2^100\\nchars := int(math.Pow(float64(2), float64(r-l-1)))"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Am I the only one to read: \\'the power of this group is max(nums[i0], nums[i1], ... , nums[ik] ** 2 * min(nums[i0], nums[i1], ... ,nums[ik]).\\'\\n\\nI wasted so much time on this..."
                    }
                ]
            },
            {
                "id": 1892475,
                "content": [
                    {
                        "username": "Msey",
                        "content": "seemed to be easy but in fact it was a trap on contest"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as simple as it appears to be"
                    },
                    {
                        "username": "AntonBelski",
                        "content": "Can you shere with me similar problems here (leetcode) or in codeforces?"
                    },
                    {
                        "username": "ismailhossainraju74",
                        "content": "It could be segment  tree problem."
                    },
                    {
                        "username": "underscore_en",
                        "content": "caution backtracking -> TLE, think about how you can make use of max, min "
                    },
                    {
                        "username": "leana8959",
                        "content": "It is possible to do this below O(N^2) time complexity? (excluding the sorting).\\n\\nI managed to get the right result on my own, the only issue is that with the huge arrays in the end of the test cases are timing out.\\n\\nThanks"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question seems absurd. Theoretically you can only do better than O(n^2) if the array has many duplicate elements. Otherwise, you need to consider every single possible pair of (min, max) which is O(n^2). But with an input size of 10^5, I dont see how that\\'s possible. "
                    },
                    {
                        "username": "Sherif_Tarek",
                        "content": "Could someone please refer me to some tutorial to teach me where should I use the modulo when doing a lot of calculations like in this problem?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "In python, just use it at the end before you return the sum. We can do this because python supports much larger numbers than other languages."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "So some actual helpful hints because the questions hints aren\\'t great. \\n\\nFirst of all, if you are attempting a hard problem, you should already know that a max input size of 10^5 implies that an O(n^2) solution will not work. \\n\\nIt seems impossible, but there is indeed a true O(n) solution assuming nums is sorted. and therefore an O(nlogn) solution for this problem. \\n\\nNotice this is classified as a math problem, so whip out a pen and paper and try an example by hand. I would recomend setting your array to being \\na, b, c, d, e where you know a <= b <= c <= d =< e. (If you try this with an example array of 1, 2, 3, 4, 5 it will be harder to see how to simplify your solution to get an answer. \\n\\n(If you have made it this far, maybe try the advice given first before continuing). \\nIf you are still struggling, write an explicit expression for what number should be returned when your input array is just [a]. Then write an explicit expression for what number should be returned when the input array is [a, b], etc all the way until the array [a, b, c, d, e]. (Unless of course you notice the pattern earlier). \\n\\nGood Luck!"
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "Can anyone please tell me why this logic is failing for larger inputs?\nI tried with the sample and other smaller arrays and it worked fine, but failing for a case with 40 elements.\nIt's sort of a 2 pointer approach to calculate the power within boundaries\n` \nfunc sumOfPower(nums []int) int {\n\n\tsort.Ints(nums)\n\tpower := 0\n\tl := 0\n\tr := 0\n\tfor l < len(nums) {\n\t\tif r == len(nums) {\n\t\t\tl++\n\t\t\tr = l\n\t\t\tcontinue\n\t\t}\n\t\tminPower := nums[l]\n\t\tmaxPower := nums[r]\n\t\tif l == r {\n\t\t\tpower += ((maxPower * maxPower * minPower) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t} else {\n\t\t\tchars := int(math.Pow(float64(2), float64(r-l-1)))\n\t\t\tpower += (((maxPower * maxPower * minPower) * chars) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t}\n\t\tr++\n\t}\n\treturn (power % ((int(math.Pow(float64(10), float64(9)))) + 7))\n}\n\n`"
                    },
                    {
                        "username": "leana8959",
                        "content": "I haven\\'t solved this (my solution is timing out) but here are my two cents:\\n\\nYou\\'re using `float`s in your solution, which might cause imprecision.\\nAlso, maybe consider using a constant for the modulo number (10e9+7), so that it doesn\\'t need to compute that each time."
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "[@isnotavail](/isnotavail)  Ah alright, that would make sense, thank you!\\nIt\\'s Go Lang btw"
                    },
                    {
                        "username": "isnotavail",
                        "content": "I don\\'t know Java but the following line cannot be stored in  64 bits e.g 2^100\\nchars := int(math.Pow(float64(2), float64(r-l-1)))"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Am I the only one to read: \\'the power of this group is max(nums[i0], nums[i1], ... , nums[ik] ** 2 * min(nums[i0], nums[i1], ... ,nums[ik]).\\'\\n\\nI wasted so much time on this..."
                    }
                ]
            },
            {
                "id": 1892433,
                "content": [
                    {
                        "username": "Msey",
                        "content": "seemed to be easy but in fact it was a trap on contest"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as simple as it appears to be"
                    },
                    {
                        "username": "AntonBelski",
                        "content": "Can you shere with me similar problems here (leetcode) or in codeforces?"
                    },
                    {
                        "username": "ismailhossainraju74",
                        "content": "It could be segment  tree problem."
                    },
                    {
                        "username": "underscore_en",
                        "content": "caution backtracking -> TLE, think about how you can make use of max, min "
                    },
                    {
                        "username": "leana8959",
                        "content": "It is possible to do this below O(N^2) time complexity? (excluding the sorting).\\n\\nI managed to get the right result on my own, the only issue is that with the huge arrays in the end of the test cases are timing out.\\n\\nThanks"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question seems absurd. Theoretically you can only do better than O(n^2) if the array has many duplicate elements. Otherwise, you need to consider every single possible pair of (min, max) which is O(n^2). But with an input size of 10^5, I dont see how that\\'s possible. "
                    },
                    {
                        "username": "Sherif_Tarek",
                        "content": "Could someone please refer me to some tutorial to teach me where should I use the modulo when doing a lot of calculations like in this problem?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "In python, just use it at the end before you return the sum. We can do this because python supports much larger numbers than other languages."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "So some actual helpful hints because the questions hints aren\\'t great. \\n\\nFirst of all, if you are attempting a hard problem, you should already know that a max input size of 10^5 implies that an O(n^2) solution will not work. \\n\\nIt seems impossible, but there is indeed a true O(n) solution assuming nums is sorted. and therefore an O(nlogn) solution for this problem. \\n\\nNotice this is classified as a math problem, so whip out a pen and paper and try an example by hand. I would recomend setting your array to being \\na, b, c, d, e where you know a <= b <= c <= d =< e. (If you try this with an example array of 1, 2, 3, 4, 5 it will be harder to see how to simplify your solution to get an answer. \\n\\n(If you have made it this far, maybe try the advice given first before continuing). \\nIf you are still struggling, write an explicit expression for what number should be returned when your input array is just [a]. Then write an explicit expression for what number should be returned when the input array is [a, b], etc all the way until the array [a, b, c, d, e]. (Unless of course you notice the pattern earlier). \\n\\nGood Luck!"
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "Can anyone please tell me why this logic is failing for larger inputs?\nI tried with the sample and other smaller arrays and it worked fine, but failing for a case with 40 elements.\nIt's sort of a 2 pointer approach to calculate the power within boundaries\n` \nfunc sumOfPower(nums []int) int {\n\n\tsort.Ints(nums)\n\tpower := 0\n\tl := 0\n\tr := 0\n\tfor l < len(nums) {\n\t\tif r == len(nums) {\n\t\t\tl++\n\t\t\tr = l\n\t\t\tcontinue\n\t\t}\n\t\tminPower := nums[l]\n\t\tmaxPower := nums[r]\n\t\tif l == r {\n\t\t\tpower += ((maxPower * maxPower * minPower) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t} else {\n\t\t\tchars := int(math.Pow(float64(2), float64(r-l-1)))\n\t\t\tpower += (((maxPower * maxPower * minPower) * chars) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t}\n\t\tr++\n\t}\n\treturn (power % ((int(math.Pow(float64(10), float64(9)))) + 7))\n}\n\n`"
                    },
                    {
                        "username": "leana8959",
                        "content": "I haven\\'t solved this (my solution is timing out) but here are my two cents:\\n\\nYou\\'re using `float`s in your solution, which might cause imprecision.\\nAlso, maybe consider using a constant for the modulo number (10e9+7), so that it doesn\\'t need to compute that each time."
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "[@isnotavail](/isnotavail)  Ah alright, that would make sense, thank you!\\nIt\\'s Go Lang btw"
                    },
                    {
                        "username": "isnotavail",
                        "content": "I don\\'t know Java but the following line cannot be stored in  64 bits e.g 2^100\\nchars := int(math.Pow(float64(2), float64(r-l-1)))"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Am I the only one to read: \\'the power of this group is max(nums[i0], nums[i1], ... , nums[ik] ** 2 * min(nums[i0], nums[i1], ... ,nums[ik]).\\'\\n\\nI wasted so much time on this..."
                    }
                ]
            },
            {
                "id": 1898466,
                "content": [
                    {
                        "username": "Msey",
                        "content": "seemed to be easy but in fact it was a trap on contest"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as simple as it appears to be"
                    },
                    {
                        "username": "AntonBelski",
                        "content": "Can you shere with me similar problems here (leetcode) or in codeforces?"
                    },
                    {
                        "username": "ismailhossainraju74",
                        "content": "It could be segment  tree problem."
                    },
                    {
                        "username": "underscore_en",
                        "content": "caution backtracking -> TLE, think about how you can make use of max, min "
                    },
                    {
                        "username": "leana8959",
                        "content": "It is possible to do this below O(N^2) time complexity? (excluding the sorting).\\n\\nI managed to get the right result on my own, the only issue is that with the huge arrays in the end of the test cases are timing out.\\n\\nThanks"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question seems absurd. Theoretically you can only do better than O(n^2) if the array has many duplicate elements. Otherwise, you need to consider every single possible pair of (min, max) which is O(n^2). But with an input size of 10^5, I dont see how that\\'s possible. "
                    },
                    {
                        "username": "Sherif_Tarek",
                        "content": "Could someone please refer me to some tutorial to teach me where should I use the modulo when doing a lot of calculations like in this problem?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "In python, just use it at the end before you return the sum. We can do this because python supports much larger numbers than other languages."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "So some actual helpful hints because the questions hints aren\\'t great. \\n\\nFirst of all, if you are attempting a hard problem, you should already know that a max input size of 10^5 implies that an O(n^2) solution will not work. \\n\\nIt seems impossible, but there is indeed a true O(n) solution assuming nums is sorted. and therefore an O(nlogn) solution for this problem. \\n\\nNotice this is classified as a math problem, so whip out a pen and paper and try an example by hand. I would recomend setting your array to being \\na, b, c, d, e where you know a <= b <= c <= d =< e. (If you try this with an example array of 1, 2, 3, 4, 5 it will be harder to see how to simplify your solution to get an answer. \\n\\n(If you have made it this far, maybe try the advice given first before continuing). \\nIf you are still struggling, write an explicit expression for what number should be returned when your input array is just [a]. Then write an explicit expression for what number should be returned when the input array is [a, b], etc all the way until the array [a, b, c, d, e]. (Unless of course you notice the pattern earlier). \\n\\nGood Luck!"
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "Can anyone please tell me why this logic is failing for larger inputs?\nI tried with the sample and other smaller arrays and it worked fine, but failing for a case with 40 elements.\nIt's sort of a 2 pointer approach to calculate the power within boundaries\n` \nfunc sumOfPower(nums []int) int {\n\n\tsort.Ints(nums)\n\tpower := 0\n\tl := 0\n\tr := 0\n\tfor l < len(nums) {\n\t\tif r == len(nums) {\n\t\t\tl++\n\t\t\tr = l\n\t\t\tcontinue\n\t\t}\n\t\tminPower := nums[l]\n\t\tmaxPower := nums[r]\n\t\tif l == r {\n\t\t\tpower += ((maxPower * maxPower * minPower) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t} else {\n\t\t\tchars := int(math.Pow(float64(2), float64(r-l-1)))\n\t\t\tpower += (((maxPower * maxPower * minPower) * chars) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t}\n\t\tr++\n\t}\n\treturn (power % ((int(math.Pow(float64(10), float64(9)))) + 7))\n}\n\n`"
                    },
                    {
                        "username": "leana8959",
                        "content": "I haven\\'t solved this (my solution is timing out) but here are my two cents:\\n\\nYou\\'re using `float`s in your solution, which might cause imprecision.\\nAlso, maybe consider using a constant for the modulo number (10e9+7), so that it doesn\\'t need to compute that each time."
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "[@isnotavail](/isnotavail)  Ah alright, that would make sense, thank you!\\nIt\\'s Go Lang btw"
                    },
                    {
                        "username": "isnotavail",
                        "content": "I don\\'t know Java but the following line cannot be stored in  64 bits e.g 2^100\\nchars := int(math.Pow(float64(2), float64(r-l-1)))"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Am I the only one to read: \\'the power of this group is max(nums[i0], nums[i1], ... , nums[ik] ** 2 * min(nums[i0], nums[i1], ... ,nums[ik]).\\'\\n\\nI wasted so much time on this..."
                    }
                ]
            },
            {
                "id": 1892539,
                "content": [
                    {
                        "username": "Msey",
                        "content": "seemed to be easy but in fact it was a trap on contest"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as simple as it appears to be"
                    },
                    {
                        "username": "AntonBelski",
                        "content": "Can you shere with me similar problems here (leetcode) or in codeforces?"
                    },
                    {
                        "username": "ismailhossainraju74",
                        "content": "It could be segment  tree problem."
                    },
                    {
                        "username": "underscore_en",
                        "content": "caution backtracking -> TLE, think about how you can make use of max, min "
                    },
                    {
                        "username": "leana8959",
                        "content": "It is possible to do this below O(N^2) time complexity? (excluding the sorting).\\n\\nI managed to get the right result on my own, the only issue is that with the huge arrays in the end of the test cases are timing out.\\n\\nThanks"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question seems absurd. Theoretically you can only do better than O(n^2) if the array has many duplicate elements. Otherwise, you need to consider every single possible pair of (min, max) which is O(n^2). But with an input size of 10^5, I dont see how that\\'s possible. "
                    },
                    {
                        "username": "Sherif_Tarek",
                        "content": "Could someone please refer me to some tutorial to teach me where should I use the modulo when doing a lot of calculations like in this problem?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "In python, just use it at the end before you return the sum. We can do this because python supports much larger numbers than other languages."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "So some actual helpful hints because the questions hints aren\\'t great. \\n\\nFirst of all, if you are attempting a hard problem, you should already know that a max input size of 10^5 implies that an O(n^2) solution will not work. \\n\\nIt seems impossible, but there is indeed a true O(n) solution assuming nums is sorted. and therefore an O(nlogn) solution for this problem. \\n\\nNotice this is classified as a math problem, so whip out a pen and paper and try an example by hand. I would recomend setting your array to being \\na, b, c, d, e where you know a <= b <= c <= d =< e. (If you try this with an example array of 1, 2, 3, 4, 5 it will be harder to see how to simplify your solution to get an answer. \\n\\n(If you have made it this far, maybe try the advice given first before continuing). \\nIf you are still struggling, write an explicit expression for what number should be returned when your input array is just [a]. Then write an explicit expression for what number should be returned when the input array is [a, b], etc all the way until the array [a, b, c, d, e]. (Unless of course you notice the pattern earlier). \\n\\nGood Luck!"
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "Can anyone please tell me why this logic is failing for larger inputs?\nI tried with the sample and other smaller arrays and it worked fine, but failing for a case with 40 elements.\nIt's sort of a 2 pointer approach to calculate the power within boundaries\n` \nfunc sumOfPower(nums []int) int {\n\n\tsort.Ints(nums)\n\tpower := 0\n\tl := 0\n\tr := 0\n\tfor l < len(nums) {\n\t\tif r == len(nums) {\n\t\t\tl++\n\t\t\tr = l\n\t\t\tcontinue\n\t\t}\n\t\tminPower := nums[l]\n\t\tmaxPower := nums[r]\n\t\tif l == r {\n\t\t\tpower += ((maxPower * maxPower * minPower) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t} else {\n\t\t\tchars := int(math.Pow(float64(2), float64(r-l-1)))\n\t\t\tpower += (((maxPower * maxPower * minPower) * chars) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t}\n\t\tr++\n\t}\n\treturn (power % ((int(math.Pow(float64(10), float64(9)))) + 7))\n}\n\n`"
                    },
                    {
                        "username": "leana8959",
                        "content": "I haven\\'t solved this (my solution is timing out) but here are my two cents:\\n\\nYou\\'re using `float`s in your solution, which might cause imprecision.\\nAlso, maybe consider using a constant for the modulo number (10e9+7), so that it doesn\\'t need to compute that each time."
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "[@isnotavail](/isnotavail)  Ah alright, that would make sense, thank you!\\nIt\\'s Go Lang btw"
                    },
                    {
                        "username": "isnotavail",
                        "content": "I don\\'t know Java but the following line cannot be stored in  64 bits e.g 2^100\\nchars := int(math.Pow(float64(2), float64(r-l-1)))"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Am I the only one to read: \\'the power of this group is max(nums[i0], nums[i1], ... , nums[ik] ** 2 * min(nums[i0], nums[i1], ... ,nums[ik]).\\'\\n\\nI wasted so much time on this..."
                    }
                ]
            },
            {
                "id": 2038366,
                "content": [
                    {
                        "username": "Msey",
                        "content": "seemed to be easy but in fact it was a trap on contest"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as simple as it appears to be"
                    },
                    {
                        "username": "AntonBelski",
                        "content": "Can you shere with me similar problems here (leetcode) or in codeforces?"
                    },
                    {
                        "username": "ismailhossainraju74",
                        "content": "It could be segment  tree problem."
                    },
                    {
                        "username": "underscore_en",
                        "content": "caution backtracking -> TLE, think about how you can make use of max, min "
                    },
                    {
                        "username": "leana8959",
                        "content": "It is possible to do this below O(N^2) time complexity? (excluding the sorting).\\n\\nI managed to get the right result on my own, the only issue is that with the huge arrays in the end of the test cases are timing out.\\n\\nThanks"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question seems absurd. Theoretically you can only do better than O(n^2) if the array has many duplicate elements. Otherwise, you need to consider every single possible pair of (min, max) which is O(n^2). But with an input size of 10^5, I dont see how that\\'s possible. "
                    },
                    {
                        "username": "Sherif_Tarek",
                        "content": "Could someone please refer me to some tutorial to teach me where should I use the modulo when doing a lot of calculations like in this problem?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "In python, just use it at the end before you return the sum. We can do this because python supports much larger numbers than other languages."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "So some actual helpful hints because the questions hints aren\\'t great. \\n\\nFirst of all, if you are attempting a hard problem, you should already know that a max input size of 10^5 implies that an O(n^2) solution will not work. \\n\\nIt seems impossible, but there is indeed a true O(n) solution assuming nums is sorted. and therefore an O(nlogn) solution for this problem. \\n\\nNotice this is classified as a math problem, so whip out a pen and paper and try an example by hand. I would recomend setting your array to being \\na, b, c, d, e where you know a <= b <= c <= d =< e. (If you try this with an example array of 1, 2, 3, 4, 5 it will be harder to see how to simplify your solution to get an answer. \\n\\n(If you have made it this far, maybe try the advice given first before continuing). \\nIf you are still struggling, write an explicit expression for what number should be returned when your input array is just [a]. Then write an explicit expression for what number should be returned when the input array is [a, b], etc all the way until the array [a, b, c, d, e]. (Unless of course you notice the pattern earlier). \\n\\nGood Luck!"
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "Can anyone please tell me why this logic is failing for larger inputs?\nI tried with the sample and other smaller arrays and it worked fine, but failing for a case with 40 elements.\nIt's sort of a 2 pointer approach to calculate the power within boundaries\n` \nfunc sumOfPower(nums []int) int {\n\n\tsort.Ints(nums)\n\tpower := 0\n\tl := 0\n\tr := 0\n\tfor l < len(nums) {\n\t\tif r == len(nums) {\n\t\t\tl++\n\t\t\tr = l\n\t\t\tcontinue\n\t\t}\n\t\tminPower := nums[l]\n\t\tmaxPower := nums[r]\n\t\tif l == r {\n\t\t\tpower += ((maxPower * maxPower * minPower) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t} else {\n\t\t\tchars := int(math.Pow(float64(2), float64(r-l-1)))\n\t\t\tpower += (((maxPower * maxPower * minPower) * chars) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t}\n\t\tr++\n\t}\n\treturn (power % ((int(math.Pow(float64(10), float64(9)))) + 7))\n}\n\n`"
                    },
                    {
                        "username": "leana8959",
                        "content": "I haven\\'t solved this (my solution is timing out) but here are my two cents:\\n\\nYou\\'re using `float`s in your solution, which might cause imprecision.\\nAlso, maybe consider using a constant for the modulo number (10e9+7), so that it doesn\\'t need to compute that each time."
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "[@isnotavail](/isnotavail)  Ah alright, that would make sense, thank you!\\nIt\\'s Go Lang btw"
                    },
                    {
                        "username": "isnotavail",
                        "content": "I don\\'t know Java but the following line cannot be stored in  64 bits e.g 2^100\\nchars := int(math.Pow(float64(2), float64(r-l-1)))"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Am I the only one to read: \\'the power of this group is max(nums[i0], nums[i1], ... , nums[ik] ** 2 * min(nums[i0], nums[i1], ... ,nums[ik]).\\'\\n\\nI wasted so much time on this..."
                    }
                ]
            },
            {
                "id": 1892794,
                "content": [
                    {
                        "username": "Msey",
                        "content": "seemed to be easy but in fact it was a trap on contest"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as simple as it appears to be"
                    },
                    {
                        "username": "AntonBelski",
                        "content": "Can you shere with me similar problems here (leetcode) or in codeforces?"
                    },
                    {
                        "username": "ismailhossainraju74",
                        "content": "It could be segment  tree problem."
                    },
                    {
                        "username": "underscore_en",
                        "content": "caution backtracking -> TLE, think about how you can make use of max, min "
                    },
                    {
                        "username": "leana8959",
                        "content": "It is possible to do this below O(N^2) time complexity? (excluding the sorting).\\n\\nI managed to get the right result on my own, the only issue is that with the huge arrays in the end of the test cases are timing out.\\n\\nThanks"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question seems absurd. Theoretically you can only do better than O(n^2) if the array has many duplicate elements. Otherwise, you need to consider every single possible pair of (min, max) which is O(n^2). But with an input size of 10^5, I dont see how that\\'s possible. "
                    },
                    {
                        "username": "Sherif_Tarek",
                        "content": "Could someone please refer me to some tutorial to teach me where should I use the modulo when doing a lot of calculations like in this problem?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "In python, just use it at the end before you return the sum. We can do this because python supports much larger numbers than other languages."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "So some actual helpful hints because the questions hints aren\\'t great. \\n\\nFirst of all, if you are attempting a hard problem, you should already know that a max input size of 10^5 implies that an O(n^2) solution will not work. \\n\\nIt seems impossible, but there is indeed a true O(n) solution assuming nums is sorted. and therefore an O(nlogn) solution for this problem. \\n\\nNotice this is classified as a math problem, so whip out a pen and paper and try an example by hand. I would recomend setting your array to being \\na, b, c, d, e where you know a <= b <= c <= d =< e. (If you try this with an example array of 1, 2, 3, 4, 5 it will be harder to see how to simplify your solution to get an answer. \\n\\n(If you have made it this far, maybe try the advice given first before continuing). \\nIf you are still struggling, write an explicit expression for what number should be returned when your input array is just [a]. Then write an explicit expression for what number should be returned when the input array is [a, b], etc all the way until the array [a, b, c, d, e]. (Unless of course you notice the pattern earlier). \\n\\nGood Luck!"
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "Can anyone please tell me why this logic is failing for larger inputs?\nI tried with the sample and other smaller arrays and it worked fine, but failing for a case with 40 elements.\nIt's sort of a 2 pointer approach to calculate the power within boundaries\n` \nfunc sumOfPower(nums []int) int {\n\n\tsort.Ints(nums)\n\tpower := 0\n\tl := 0\n\tr := 0\n\tfor l < len(nums) {\n\t\tif r == len(nums) {\n\t\t\tl++\n\t\t\tr = l\n\t\t\tcontinue\n\t\t}\n\t\tminPower := nums[l]\n\t\tmaxPower := nums[r]\n\t\tif l == r {\n\t\t\tpower += ((maxPower * maxPower * minPower) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t} else {\n\t\t\tchars := int(math.Pow(float64(2), float64(r-l-1)))\n\t\t\tpower += (((maxPower * maxPower * minPower) * chars) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t}\n\t\tr++\n\t}\n\treturn (power % ((int(math.Pow(float64(10), float64(9)))) + 7))\n}\n\n`"
                    },
                    {
                        "username": "leana8959",
                        "content": "I haven\\'t solved this (my solution is timing out) but here are my two cents:\\n\\nYou\\'re using `float`s in your solution, which might cause imprecision.\\nAlso, maybe consider using a constant for the modulo number (10e9+7), so that it doesn\\'t need to compute that each time."
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "[@isnotavail](/isnotavail)  Ah alright, that would make sense, thank you!\\nIt\\'s Go Lang btw"
                    },
                    {
                        "username": "isnotavail",
                        "content": "I don\\'t know Java but the following line cannot be stored in  64 bits e.g 2^100\\nchars := int(math.Pow(float64(2), float64(r-l-1)))"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Am I the only one to read: \\'the power of this group is max(nums[i0], nums[i1], ... , nums[ik] ** 2 * min(nums[i0], nums[i1], ... ,nums[ik]).\\'\\n\\nI wasted so much time on this..."
                    }
                ]
            },
            {
                "id": 1892584,
                "content": [
                    {
                        "username": "Msey",
                        "content": "seemed to be easy but in fact it was a trap on contest"
                    },
                    {
                        "username": "layyy",
                        "content": "Not as simple as it appears to be"
                    },
                    {
                        "username": "AntonBelski",
                        "content": "Can you shere with me similar problems here (leetcode) or in codeforces?"
                    },
                    {
                        "username": "ismailhossainraju74",
                        "content": "It could be segment  tree problem."
                    },
                    {
                        "username": "underscore_en",
                        "content": "caution backtracking -> TLE, think about how you can make use of max, min "
                    },
                    {
                        "username": "leana8959",
                        "content": "It is possible to do this below O(N^2) time complexity? (excluding the sorting).\\n\\nI managed to get the right result on my own, the only issue is that with the huge arrays in the end of the test cases are timing out.\\n\\nThanks"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "This question seems absurd. Theoretically you can only do better than O(n^2) if the array has many duplicate elements. Otherwise, you need to consider every single possible pair of (min, max) which is O(n^2). But with an input size of 10^5, I dont see how that\\'s possible. "
                    },
                    {
                        "username": "Sherif_Tarek",
                        "content": "Could someone please refer me to some tutorial to teach me where should I use the modulo when doing a lot of calculations like in this problem?"
                    },
                    {
                        "username": "kylestanfield",
                        "content": "In python, just use it at the end before you return the sum. We can do this because python supports much larger numbers than other languages."
                    },
                    {
                        "username": "mshoosterman",
                        "content": "So some actual helpful hints because the questions hints aren\\'t great. \\n\\nFirst of all, if you are attempting a hard problem, you should already know that a max input size of 10^5 implies that an O(n^2) solution will not work. \\n\\nIt seems impossible, but there is indeed a true O(n) solution assuming nums is sorted. and therefore an O(nlogn) solution for this problem. \\n\\nNotice this is classified as a math problem, so whip out a pen and paper and try an example by hand. I would recomend setting your array to being \\na, b, c, d, e where you know a <= b <= c <= d =< e. (If you try this with an example array of 1, 2, 3, 4, 5 it will be harder to see how to simplify your solution to get an answer. \\n\\n(If you have made it this far, maybe try the advice given first before continuing). \\nIf you are still struggling, write an explicit expression for what number should be returned when your input array is just [a]. Then write an explicit expression for what number should be returned when the input array is [a, b], etc all the way until the array [a, b, c, d, e]. (Unless of course you notice the pattern earlier). \\n\\nGood Luck!"
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "Can anyone please tell me why this logic is failing for larger inputs?\nI tried with the sample and other smaller arrays and it worked fine, but failing for a case with 40 elements.\nIt's sort of a 2 pointer approach to calculate the power within boundaries\n` \nfunc sumOfPower(nums []int) int {\n\n\tsort.Ints(nums)\n\tpower := 0\n\tl := 0\n\tr := 0\n\tfor l < len(nums) {\n\t\tif r == len(nums) {\n\t\t\tl++\n\t\t\tr = l\n\t\t\tcontinue\n\t\t}\n\t\tminPower := nums[l]\n\t\tmaxPower := nums[r]\n\t\tif l == r {\n\t\t\tpower += ((maxPower * maxPower * minPower) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t} else {\n\t\t\tchars := int(math.Pow(float64(2), float64(r-l-1)))\n\t\t\tpower += (((maxPower * maxPower * minPower) * chars) % ((int(math.Pow(float64(10), float64(9)))) + 7))\n\t\t}\n\t\tr++\n\t}\n\treturn (power % ((int(math.Pow(float64(10), float64(9)))) + 7))\n}\n\n`"
                    },
                    {
                        "username": "leana8959",
                        "content": "I haven\\'t solved this (my solution is timing out) but here are my two cents:\\n\\nYou\\'re using `float`s in your solution, which might cause imprecision.\\nAlso, maybe consider using a constant for the modulo number (10e9+7), so that it doesn\\'t need to compute that each time."
                    },
                    {
                        "username": "abhishekm2610",
                        "content": "[@isnotavail](/isnotavail)  Ah alright, that would make sense, thank you!\\nIt\\'s Go Lang btw"
                    },
                    {
                        "username": "isnotavail",
                        "content": "I don\\'t know Java but the following line cannot be stored in  64 bits e.g 2^100\\nchars := int(math.Pow(float64(2), float64(r-l-1)))"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Am I the only one to read: \\'the power of this group is max(nums[i0], nums[i1], ... , nums[ik] ** 2 * min(nums[i0], nums[i1], ... ,nums[ik]).\\'\\n\\nI wasted so much time on this..."
                    }
                ]
            }
        ]
    },
    {
        "title": "Find the Punishment Number of an Integer",
        "question_content": "<p>Given a positive integer <code>n</code>, return <em>the <strong>punishment number</strong></em> of <code>n</code>.</p>\n\n<p>The <strong>punishment number</strong> of <code>n</code> is defined as the sum of the squares of all integers <code>i</code> such that:</p>\n\n<ul>\n\t<li><code>1 &lt;= i &lt;= n</code></li>\n\t<li>The decimal representation of <code>i * i</code> can be partitioned into contiguous substrings such that the sum of the integer values of these substrings equals <code>i</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 10\n<strong>Output:</strong> 182\n<strong>Explanation:</strong> There are exactly 3 integers i that satisfy the conditions in the statement:\n- 1 since 1 * 1 = 1\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\nHence, the punishment number of 10 is 1 + 81 + 100 = 182\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 37\n<strong>Output:</strong> 1478\n<strong>Explanation:</strong> There are exactly 4 integers i that satisfy the conditions in the statement:\n- 1 since 1 * 1 = 1. \n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3546812,
                "title": "simple-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canPartition(string s, int target)\\n    {\\n        if (s == \"\" && target == 0) return true;\\n        if (target < 0) return false;\\n        \\n        bool ans = false;\\n        //========================================================================\\n        for (int i = 0; i < s.size(); i++) //try all possible pivot points\\n        {\\n            string left = s.substr(0, i + 1); //keep the left part\\n            string right = s.substr(i + 1); //recurse for right  part\\n            int leftNum = stoi(left);\\n            \\n            bool isPossible = canPartition(right, target - leftNum);\\n            if (isPossible) { ans = true; break; }\\n        }\\n        //=============================================================================\\n        return ans;\\n    }\\n    int punishmentNumber(int n)\\n    {\\n        int sum = 0;\\n        for (int num  = 1; num <= n; num++)\\n        {\\n            int sqr = num * num;\\n            if (canPartition(to_string(sqr), num)) \\n            {\\n                sum += sqr;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```\\n//=======================================================================================================\\n## EFFICIENT APPROACH \\n```\\nclass Solution {\\npublic:\\n    bool canPartition(string& s, int startIdx, int target)\\n    {\\n        if (startIdx == s.size() && target == 0) return true;\\n        if (target < 0) return false;\\n        \\n        bool ans = false;\\n        int leftNum = 0;\\n        //========================================================================\\n        for (int i = startIdx; i < s.size(); i++) //try all possible pivot points\\n        {\\n            leftNum = (leftNum * 10) + (s[i] - \\'0\\'); //keep the left\\n            \\n            bool isPossible = canPartition(s, i + 1, target - leftNum); //recurse for right\\n            if (isPossible) { ans = true; break; }\\n        }\\n        //=============================================================================\\n        return ans;\\n    }\\n    int punishmentNumber(int n)\\n    {\\n        int sum = 0;\\n        for (int num  = 1; num <= n; num++)\\n        {\\n            int sqr = num * num;\\n            string sqrStr = to_string(sqr);\\n            if (canPartition(sqrStr, 0, num)) \\n            {\\n                sum += sqr;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canPartition(string s, int target)\\n    {\\n        if (s == \"\" && target == 0) return true;\\n        if (target < 0) return false;\\n        \\n        bool ans = false;\\n        //========================================================================\\n        for (int i = 0; i < s.size(); i++) //try all possible pivot points\\n        {\\n            string left = s.substr(0, i + 1); //keep the left part\\n            string right = s.substr(i + 1); //recurse for right  part\\n            int leftNum = stoi(left);\\n            \\n            bool isPossible = canPartition(right, target - leftNum);\\n            if (isPossible) { ans = true; break; }\\n        }\\n        //=============================================================================\\n        return ans;\\n    }\\n    int punishmentNumber(int n)\\n    {\\n        int sum = 0;\\n        for (int num  = 1; num <= n; num++)\\n        {\\n            int sqr = num * num;\\n            if (canPartition(to_string(sqr), num)) \\n            {\\n                sum += sqr;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canPartition(string& s, int startIdx, int target)\\n    {\\n        if (startIdx == s.size() && target == 0) return true;\\n        if (target < 0) return false;\\n        \\n        bool ans = false;\\n        int leftNum = 0;\\n        //========================================================================\\n        for (int i = startIdx; i < s.size(); i++) //try all possible pivot points\\n        {\\n            leftNum = (leftNum * 10) + (s[i] - \\'0\\'); //keep the left\\n            \\n            bool isPossible = canPartition(s, i + 1, target - leftNum); //recurse for right\\n            if (isPossible) { ans = true; break; }\\n        }\\n        //=============================================================================\\n        return ans;\\n    }\\n    int punishmentNumber(int n)\\n    {\\n        int sum = 0;\\n        for (int num  = 1; num <= n; num++)\\n        {\\n            int sqr = num * num;\\n            string sqrStr = to_string(sqr);\\n            if (canPartition(sqrStr, 0, num)) \\n            {\\n                sum += sqr;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547280,
                "title": "0ms-tc-o-n-5-3-sc-o-log-n-most-efficient-solution-simplest-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can check whether each number in $$[1, n]$$ is a good number and sum them up.\\n\\nNotice that we have $$n \\\\le 1000$$, that means $$n^2 \\\\le 1000000$$, so we are basically dealing with 6 digits numbers. This makes brutal force ($$O(3 * 2^6)$$ ops) much faster than any attempt to uses DP ($$O(1000 * 6^2)$$ ops).\\n\\n> For the discussion of DP method, see the [Appendix](#appendix-dp-method)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe simply use a recursive call to check if `num` can be split to sum up to `target`. This takes only at most $$2^6$$ recursions assuming `num` has 6 digits.\\n\\n**A key technique** we used here is to start the split from the *right side* (least significant digit) rather than the *left side* (most significant digit).\\n\\nFor example: *Can we split $65536$ to sum up to $256$?* There are 3 choices:\\n  * Split $6553$ to make $256 - 6 = 250$\\n  * Split $655$ to make $256 - 36 = 220$\\n  * Split $65$ to make $256 - 536 < 0$ impossible.\\n  \\nThis allows us to use divide and remainder operator directly on the number, rather than having to convert the number into digits (or even worse, strings).\\n\\n# Complexity\\n- Time complexity: $$\\\\Theta(N 2^{\\\\log_{10} N^2})$$\\nOr roughtly $$\\\\Theta(N^{1.602})$$\\nThe $$\\\\Theta(2^{\\\\log_{10} N^2})$$ part is all the possible ways to split a $$\\\\log_{10} N^2$$ digits number.\\n\\n- Space complexity: $$\\\\Theta(\\\\log_{10} N^2)$$\\nOr simply $$\\\\Theta(\\\\log N)$$\\nSpace is only used for the stack of recursive calls and it\\'s only 6 for $$N < 1000$$.\\n\\n# Code\\n```\\nbool CanMake(int num, int target) {\\n  if (target < 0 || num < target) {\\n    return false;\\n  }\\n  if (num == target) {\\n    return true;\\n  }\\n  return CanMake(num / 10, target - num % 10) || CanMake(num / 100, target - num % 100) ||\\n      CanMake(num / 1000, target - num % 1000);\\n}\\n\\nclass Solution {\\npublic:\\n  int punishmentNumber(int n) {\\n    int answer = 0;\\n    for (int i = 1; i <= n; ++i) {\\n      int num = i * i;\\n      if (CanMake(num, i)) {\\n        answer += num;\\n      }\\n    }\\n    return answer;\\n  }\\n};\\n```\\n\\n# Appendix: DP method\\n> Inefficient for this problem\\n\\nTo solve the problem of *can we split a number such that the parts sum up to target*, we could use DP:\\n```\\n// Returns the number of ways to split num into parts such that\\n// these parts sum up to target.\\nint64_t WaysToMake(int num, int target) {\\n  vector<int> digits = GetDigits(num);  // Easy to implement.\\n  const int L = digits.size();\\n  // counts[i][t] := the number of ways to split [0: i) of\\n  // digits and sum up to t.\\n  vector<vector<int64_t>> counts(L + 1, vector<int64_t>(target + 1));\\n  counts[0][0] = 1;\\n  for (int i = 1; i <= L; ++i) {\\n    int value = 0;\\n    int factor = 1;\\n    for (int j = i - 1; j >= 0; --j) {\\n      value += factor * digits[j];\\n      if (value > target) {\\n        break;\\n      }\\n      factor *= 10;\\n      for (int t = target - value; t >= 0; --t) {\\n        counts[i][t + value] += counts[j][t];\\n      }\\n    }\\n  }\\n  return counts[L][target];\\n}\\n```\\nAs you can see there are 3 levels of loop. The time complexity would be: $$\\\\Theta(T * \\\\log(N)\\\\log(T))$$ where $$N$$ is the `num` to split and $$T$$ is the `target` to sum up to.\\n\\nThis is, however, a good method if we have very small target and huge number (like when `num` is not a `int` but a `BigInteger` that has hundreds of digits).",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nbool CanMake(int num, int target) {\\n  if (target < 0 || num < target) {\\n    return false;\\n  }\\n  if (num == target) {\\n    return true;\\n  }\\n  return CanMake(num / 10, target - num % 10) || CanMake(num / 100, target - num % 100) ||\\n      CanMake(num / 1000, target - num % 1000);\\n}\\n\\nclass Solution {\\npublic:\\n  int punishmentNumber(int n) {\\n    int answer = 0;\\n    for (int i = 1; i <= n; ++i) {\\n      int num = i * i;\\n      if (CanMake(num, i)) {\\n        answer += num;\\n      }\\n    }\\n    return answer;\\n  }\\n};\\n```\n```\\n// Returns the number of ways to split num into parts such that\\n// these parts sum up to target.\\nint64_t WaysToMake(int num, int target) {\\n  vector<int> digits = GetDigits(num);  // Easy to implement.\\n  const int L = digits.size();\\n  // counts[i][t] := the number of ways to split [0: i) of\\n  // digits and sum up to t.\\n  vector<vector<int64_t>> counts(L + 1, vector<int64_t>(target + 1));\\n  counts[0][0] = 1;\\n  for (int i = 1; i <= L; ++i) {\\n    int value = 0;\\n    int factor = 1;\\n    for (int j = i - 1; j >= 0; --j) {\\n      value += factor * digits[j];\\n      if (value > target) {\\n        break;\\n      }\\n      factor *= 10;\\n      for (int t = target - value; t >= 0; --t) {\\n        counts[i][t + value] += counts[j][t];\\n      }\\n    }\\n  }\\n  return counts[L][target];\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546767,
                "title": "explained-recursion-very-simple-and-easy-to-understand-solution",
                "content": "<b> Up vote if this solution helps </b>\\n# Approach \\nWe can use dp to check recursively all tha possible component and check if its equel to the reference number (i) \\n\\nAlso we use a map to store the number which were tested before.\\n\\nNow to compute the dp recursion we will remove the first j digit and pass the remaining vlaues to recursive funtion.\\nHere to remove the first j digit we have simply taken one iterator in our recursive argument i which is updated on each call to the function.\\n\\nAlso we update the ref value as per the digit/integer removed from the actual number.\\n\\nCheck this to understand more the recursion :\\nwe want to test for 36 * 36 = 1296, if 36 is to be added or not\\nso we pass s = \"1296\" & ref = 36 & i = 0\\n=> on first iteration we remove 1 from 1296 \\n   so we pas s = \"1296\" with i = 1, which is equivalent to passing 296\\n   and we update the ref = ref - 1\\n  similarly the recursion grow for all possible cases:\\n\\n (1296, 36)\\n  \\n (296, 35= 36 -1)  (96, 24 = 36 -12 ) ( 6, -93 = 36-129) ( \"\", -1260 = 36- 1296)\\n\\nexpanding only first case here :\\n (96, 33 = 35 - 2) ( 6, 6 = 35 - 29) (\"\", -261 = 35- 296)\\n\\n on above the second case return true and recursively we return true from here onwards.\\n\\n\\n\\n\\n\\n```\\nunordered_map<int, int> mp;\\nclass Solution {\\npublic:\\n    bool check(string &s, int ref, int i){\\n        string str = s.substr(i);\\n        int t = stoi(str);\\n        if(ref > t || ref < 0 || s.size() == i) return false;\\n        if(t == ref) return true;\\n        for(int j = 1; i+j < s.size(); ++j){\\n            str = s.substr(i, j);\\n            if(check(s, ref - stoi(str), i+j)) return true;\\n        }\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        for(int i = 1; i <= n; ++i){\\n            string sqr = to_string(i*i);           \\n            if(mp.find(i*i) == mp.end() ) mp[i*i] = check(sqr, i, 0); \\n            ans += i*i * mp[i*i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n<b> Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nunordered_map<int, int> mp;\\nclass Solution {\\npublic:\\n    bool check(string &s, int ref, int i){\\n        string str = s.substr(i);\\n        int t = stoi(str);\\n        if(ref > t || ref < 0 || s.size() == i) return false;\\n        if(t == ref) return true;\\n        for(int j = 1; i+j < s.size(); ++j){\\n            str = s.substr(i, j);\\n            if(check(s, ref - stoi(str), i+j)) return true;\\n        }\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        for(int i = 1; i <= n; ++i){\\n            string sqr = to_string(i*i);           \\n            if(mp.find(i*i) == mp.end() ) mp[i*i] = check(sqr, i, 0); \\n            ans += i*i * mp[i*i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553435,
                "title": "c-precompute-the-answer-do-the-work-at-compile-time-o-1-tc-fast-0ms-100",
                "content": "# Approach 1: precompute the answer\\nSince the result ony depends on the single input number and the range is quite limited we can compute all of that at compile time. To be fair I am cheating a bit here as not all the work is done at compile time. It would take a bit more time to make this fully \"compile time\", see approach 2 below.\\n\\nThe following code was used to decide of a number matches the criteria:\\n\\n```cpp\\n// There is no std::stoi for std::string_view, so let\\'s work around it.\\nint stoi(string_view s) {\\n    int ans = 0;\\n    auto [ptr, ec] = std::from_chars(s.data(), s.data() + s.size(), ans);\\n    assert(ec == std::errc());\\n    return ans;\\n}\\n\\nbool isPN(string_view s, int x) {\\n    if (empty(s)) return x == 0;\\n    if (x < 0) return false;\\n\\n    if (size(s) == 1) return (s[0] & 0xf) == x;\\n\\n    if (stoi(s) == x) return true;\\n\\n    for (int i = 1; i < size(s); ++i) {\\n        const int left = stoi(s.substr(0, i));\\n        string_view right = s.substr(i);\\n        if (isPN(right, x - left)) return true;\\n    }\\n    return false;\\n}\\n\\nbool isPN(int x) {\\n    return isPN(to_string(x * x), x);\\n}    \\n```\\n\\nThere are only 29 numbers up to 1000 that match the criteria and with that we can built a constant time solution:\\n\\n```cpp\\nconstexpr auto gen_pn() {\\n    // The list was generated with:\\n    //   for (int i = 1; i <= 1000; ++i)\\n    //       if (isPN(i)) cout << i << \", \" << endl;\\n    array<int, 29> pns = {\\n        1, 9, 10, 36, 45, 55, 82, 91, 99, 100, 235, 297, 369, 370, 379,\\n        414, 657, 675, 703, 756, 792, 909, 918, 945, 964, 990, 991, 999, 1000};\\n    \\n    array<int, 1001> ans = {};\\n    int sum = 0;\\n    for (int i = 0, p = 0; i < size(ans); ++i) {\\n        if (i == pns[p]) {\\n            sum += i * i;\\n            ++p;\\n        }\\n        ans[i] = sum;\\n    }\\n    return ans;\\n}\\n\\nconstexpr auto pns = gen_pn();\\n}  // namespace\\n\\nclass Solution {\\npublic:\\n    static int punishmentNumber(int n) {\\n        return pns[n];\\n    }\\n};\\n```\\n\\n**Complexity Analysis**\\n\\n* Time complexity is $$O(1)$$ and the\\n \\n* Space complexity is $$O(1)$$.\\n\\n# Approach 2: do all the work at compile time\\nTaking inspiration by a [post](https://leetcode.com/problems/find-the-punishment-number-of-an-integer/discuss/3546736/O(1)) from @0xFFFFFFFF we can do all the work at compile time:\\n\\n```cpp\\nnamespace {\\nconstexpr bool isPN(array<char, 8>& v, int n, int idx, int rem) {\\n    if (idx == n) return rem == 0;\\n    int val = 0;\\n    for (int i = idx; i < n; ++i) {\\n        val *= 10;\\n        val += v[i];\\n        if (val <= rem && isPN(v, n, i + 1, rem - val)) return true;\\n    }\\n    return false;\\n }\\n\\n// need to work around a couple of limitations of constexpr\\nconstexpr bool isPN(int i) {\\n    int s = i * i;\\n    int n = 0;\\n    // hand-roll std::stoi and don\\'t use vector or string as we dont\\' seem to be able to use them\\n    // in a constexpr context.\\n    // no std::string or std::vector in constexpr\\t\\n    array<char, 8> v = {};\\n    // no std::to_string or std::to_char in constexpr\\n    while (s) {\\n        v[n++] = s % 10;\\n        s /= 10;\\n    }\\n    // no std::reverse in constexpr\\n    for (int l = 0, r = n - 1; l < r; ++l, --r) {\\n        // no std::swap in constexpr\\n        int t = v[r];\\n        v[r] = v[l];\\n        v[l] = t;\\n    }\\n    return isPN(v, n, 0, i);\\n}\\n\\nconstexpr auto gen_pn() {\\n    array<int, 1001> ans = {0};\\n    int sum = 0;\\n    for (int i = 1, p = 0; i < size(ans); ++i) {\\n        if (isPN(i)) sum += i * i;\\n        ans[i] = sum;\\n    }\\n    return ans;\\n}\\n\\nconstexpr auto pns = gen_pn();\\n}  // namespace\\n\\nclass Solution {\\npublic:\\n    static int punishmentNumber(int n) {\\n        return pns[n];\\n    }\\n};\\n```\\n\\n**Complexity Analysis**\\n\\nSame as approach 1.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n// There is no std::stoi for std::string_view, so let\\'s work around it.\\nint stoi(string_view s) {\\n    int ans = 0;\\n    auto [ptr, ec] = std::from_chars(s.data(), s.data() + s.size(), ans);\\n    assert(ec == std::errc());\\n    return ans;\\n}\\n\\nbool isPN(string_view s, int x) {\\n    if (empty(s)) return x == 0;\\n    if (x < 0) return false;\\n\\n    if (size(s) == 1) return (s[0] & 0xf) == x;\\n\\n    if (stoi(s) == x) return true;\\n\\n    for (int i = 1; i < size(s); ++i) {\\n        const int left = stoi(s.substr(0, i));\\n        string_view right = s.substr(i);\\n        if (isPN(right, x - left)) return true;\\n    }\\n    return false;\\n}\\n\\nbool isPN(int x) {\\n    return isPN(to_string(x * x), x);\\n}    \\n```\n```cpp\\nconstexpr auto gen_pn() {\\n    // The list was generated with:\\n    //   for (int i = 1; i <= 1000; ++i)\\n    //       if (isPN(i)) cout << i << \", \" << endl;\\n    array<int, 29> pns = {\\n        1, 9, 10, 36, 45, 55, 82, 91, 99, 100, 235, 297, 369, 370, 379,\\n        414, 657, 675, 703, 756, 792, 909, 918, 945, 964, 990, 991, 999, 1000};\\n    \\n    array<int, 1001> ans = {};\\n    int sum = 0;\\n    for (int i = 0, p = 0; i < size(ans); ++i) {\\n        if (i == pns[p]) {\\n            sum += i * i;\\n            ++p;\\n        }\\n        ans[i] = sum;\\n    }\\n    return ans;\\n}\\n\\nconstexpr auto pns = gen_pn();\\n}  // namespace\\n\\nclass Solution {\\npublic:\\n    static int punishmentNumber(int n) {\\n        return pns[n];\\n    }\\n};\\n```\n```cpp\\nnamespace {\\nconstexpr bool isPN(array<char, 8>& v, int n, int idx, int rem) {\\n    if (idx == n) return rem == 0;\\n    int val = 0;\\n    for (int i = idx; i < n; ++i) {\\n        val *= 10;\\n        val += v[i];\\n        if (val <= rem && isPN(v, n, i + 1, rem - val)) return true;\\n    }\\n    return false;\\n }\\n\\n// need to work around a couple of limitations of constexpr\\nconstexpr bool isPN(int i) {\\n    int s = i * i;\\n    int n = 0;\\n    // hand-roll std::stoi and don\\'t use vector or string as we dont\\' seem to be able to use them\\n    // in a constexpr context.\\n    // no std::string or std::vector in constexpr\\t\\n    array<char, 8> v = {};\\n    // no std::to_string or std::to_char in constexpr\\n    while (s) {\\n        v[n++] = s % 10;\\n        s /= 10;\\n    }\\n    // no std::reverse in constexpr\\n    for (int l = 0, r = n - 1; l < r; ++l, --r) {\\n        // no std::swap in constexpr\\n        int t = v[r];\\n        v[r] = v[l];\\n        v[l] = t;\\n    }\\n    return isPN(v, n, 0, i);\\n}\\n\\nconstexpr auto gen_pn() {\\n    array<int, 1001> ans = {0};\\n    int sum = 0;\\n    for (int i = 1, p = 0; i < size(ans); ++i) {\\n        if (isPN(i)) sum += i * i;\\n        ans[i] = sum;\\n    }\\n    return ans;\\n}\\n\\nconstexpr auto pns = gen_pn();\\n}  // namespace\\n\\nclass Solution {\\npublic:\\n    static int punishmentNumber(int n) {\\n        return pns[n];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3547660,
                "title": "image-explination-with-recurssive-tree-recurssion-0-1-knapsack-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool ans = false;\\n\\n\\t\\tvoid solve(string prev, string s, int n,int sum) {\\n\\t\\t\\tif (s.length() == 0) {\\n\\t\\t\\t\\tif(prev.size()>0){sum+=stoi(prev);}\\n\\t\\t\\t\\tif (sum==n) {\\n\\t\\t\\t\\t\\tans = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif (sum > n) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tprev += s[0];\\n\\t\\t\\ts = s.substr(1);\\n\\n\\t\\t\\tint k = stoi(prev);        \\n\\t\\t\\tsolve(\"\", s, n,sum+k);\\n\\t\\t\\tsolve(prev, s, n,sum);\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tint punishmentNumber(int n) {\\n\\t\\t\\t\\tint sum = 0;\\n\\n\\t\\t\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\t\\t\\tstring s = to_string(i*i);            \\n\\t\\t\\t\\t\\tans = false;\\n\\t\\t\\t\\t\\tsolve(\"\", s, i,0);\\n\\t\\t\\t\\t\\tif (ans) {\\n\\t\\t\\t\\t\\t\\tsum += i*i;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn sum;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\t\\t\\t\\t\\n![image](https://assets.leetcode.com/users/images/3cdc262f-47e5-4ad9-bc90-87592da18d0c_1684652934.5675123.jpeg)\\njust keep one thing sure if in the end of tree when string length is 0 then just cheeck whether the prev length is 0 or not if not then add stoi vale of string to sum so that prev cant left after the end of tree",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool ans = false;\\n\\n\\t\\tvoid solve(string prev, string s, int n,int sum) {\\n\\t\\t\\tif (s.length() == 0) {\\n\\t\\t\\t\\tif(prev.size()>0){sum+=stoi(prev);}",
                "codeTag": "Java"
            },
            {
                "id": 3547015,
                "title": "o-n-easy-solution-recursion-c-java-python",
                "content": "# Intuition\\nSince the Constraints are less n <= 1000 ```Try for each number i where 1 <= i <= n```\\n\\n# Approach\\nFor each number i where 1 <= i <= n \\nTry whether the decimal representation of i * i can be partitioned into contiguous substrings such that the sum of the integer values of these substrings equals i.\\n\\n``` For example if i = 36 then 36 * 36 can be partitioned in such way that it sums up to 36```\\n``` 36 * 36 = 1296 &&  1 + 29 + 6 = 36 ```\\n\\nIt can be easily check using recursion.\\n\\n# Code - C++\\n```\\nclass Solution {\\npublic:\\n    bool check(int idx, string &p, int target)\\n    {\\n        if (idx == p.size())\\n        {\\n            if (target == 0)\\n                return true;\\n            else\\n                return false;\\n        }\\n        if (target < 0)\\n            return false;\\n        for (int i = idx; i < p.size(); ++i)\\n        {\\n            string x = p.substr(idx, i + 1 - idx);\\n            int y = stoi(x);\\n            if (check(i + 1, p, target - y))\\n                return true;\\n        }\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        long long ans = 0;\\n        for (long long i = 1; i <= n; ++i)\\n        {\\n            long long x = i * i;\\n            string p = to_string(x);\\n            if (check(0, p, i))\\n                ans += (i * i);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Code - Java\\n```\\npublic class Solution {\\n    public static boolean check(int idx, String p, int target) {\\n        if (idx == p.length()) {\\n            return target == 0;\\n        }\\n        if (target < 0) {\\n            return false;\\n        }\\n        for (int i = idx; i < p.length(); ++i) {\\n            String x = p.substring(idx, i + 1);\\n            int y = Integer.parseInt(x);\\n            if (check(i + 1, p, target - y)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public static int punishmentNumber(int n) {\\n        long ans = 0;\\n        for (long i = 1; i <= n; ++i) {\\n            long x = i * i;\\n            String p = Long.toString(x);\\n            if (check(0, p, (int) i)) {\\n                ans += (i * i);\\n            }\\n        }\\n        return (int) ans;\\n    }\\n    \\n    public static void main(String[] args) {\\n        int result = punishmentNumber(10);\\n        System.out.println(result);\\n    }\\n}\\n```\\n# Code - Python\\n```\\nclass Solution:\\n    def check(self, idx, p, target):\\n        if idx == len(p):\\n            return target == 0\\n        if target < 0:\\n            return False\\n        for i in range(idx, len(p)):\\n            x = p[idx:i + 1]\\n            y = int(x)\\n            if self.check(i + 1, p, target - y):\\n                return True\\n        return False\\n\\n    def punishmentNumber(self, n):\\n        ans = 0\\n        for i in range(1, n + 1):\\n            x = i * i\\n            p = str(x)\\n            if self.check(0, p, i):\\n                ans += (i * i)\\n        return ans\\n\\n\\nsolution = Solution()\\nresult = solution.punishmentNumber(10)\\nprint(result)\\n```\\n``` Please Upvote if it was helpful ```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```Try for each number i where 1 <= i <= n```\n``` For example if i = 36 then 36 * 36 can be partitioned in such way that it sums up to 36```\n``` 36 * 36 = 1296 &&  1 + 29 + 6 = 36 ```\n```\\nclass Solution {\\npublic:\\n    bool check(int idx, string &p, int target)\\n    {\\n        if (idx == p.size())\\n        {\\n            if (target == 0)\\n                return true;\\n            else\\n                return false;\\n        }\\n        if (target < 0)\\n            return false;\\n        for (int i = idx; i < p.size(); ++i)\\n        {\\n            string x = p.substr(idx, i + 1 - idx);\\n            int y = stoi(x);\\n            if (check(i + 1, p, target - y))\\n                return true;\\n        }\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        long long ans = 0;\\n        for (long long i = 1; i <= n; ++i)\\n        {\\n            long long x = i * i;\\n            string p = to_string(x);\\n            if (check(0, p, i))\\n                ans += (i * i);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public static boolean check(int idx, String p, int target) {\\n        if (idx == p.length()) {\\n            return target == 0;\\n        }\\n        if (target < 0) {\\n            return false;\\n        }\\n        for (int i = idx; i < p.length(); ++i) {\\n            String x = p.substring(idx, i + 1);\\n            int y = Integer.parseInt(x);\\n            if (check(i + 1, p, target - y)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public static int punishmentNumber(int n) {\\n        long ans = 0;\\n        for (long i = 1; i <= n; ++i) {\\n            long x = i * i;\\n            String p = Long.toString(x);\\n            if (check(0, p, (int) i)) {\\n                ans += (i * i);\\n            }\\n        }\\n        return (int) ans;\\n    }\\n    \\n    public static void main(String[] args) {\\n        int result = punishmentNumber(10);\\n        System.out.println(result);\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def check(self, idx, p, target):\\n        if idx == len(p):\\n            return target == 0\\n        if target < 0:\\n            return False\\n        for i in range(idx, len(p)):\\n            x = p[idx:i + 1]\\n            y = int(x)\\n            if self.check(i + 1, p, target - y):\\n                return True\\n        return False\\n\\n    def punishmentNumber(self, n):\\n        ans = 0\\n        for i in range(1, n + 1):\\n            x = i * i\\n            p = str(x)\\n            if self.check(0, p, i):\\n                ans += (i * i)\\n        return ans\\n\\n\\nsolution = Solution()\\nresult = solution.punishmentNumber(10)\\nprint(result)\\n```\n``` Please Upvote if it was helpful ```",
                "codeTag": "Java"
            },
            {
                "id": 3546726,
                "title": "c-recursion-brute-force",
                "content": "```\\nclass Solution {\\n    bool canPartitionSubstring(string& input, int k, int index, int currentSum) {\\n        if (index >= input.length()) {\\n            return currentSum == k;\\n        }\\n    \\n        int num = 0;\\n        \\n        for (int i = index; i < input.length(); i++) {\\n            num = num * 10 + (input[i] - \\'0\\');\\n            \\n            if (canPartitionSubstring(input, k, i + 1, currentSum + num)) {\\n                return true;\\n            }\\n        }\\n    \\n        return false;\\n}\\npublic:\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        \\n        for(int i = 1; i <= n; i++) {\\n            string v = to_string(i*i);\\n            bool k = canPartitionSubstring(v,i,0,0);\\n            \\n            if(k) {\\n                ans += i*i;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    bool canPartitionSubstring(string& input, int k, int index, int currentSum) {\\n        if (index >= input.length()) {\\n            return currentSum == k;\\n        }\\n    \\n        int num = 0;\\n        \\n        for (int i = index; i < input.length(); i++) {\\n            num = num * 10 + (input[i] - \\'0\\');\\n            \\n            if (canPartitionSubstring(input, k, i + 1, currentSum + num)) {\\n                return true;\\n            }\\n        }\\n    \\n        return false;\\n}\\npublic:\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        \\n        for(int i = 1; i <= n; i++) {\\n            string v = to_string(i*i);\\n            bool k = canPartitionSubstring(v,i,0,0);\\n            \\n            if(k) {\\n                ans += i*i;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546903,
                "title": "too-lazy-to-explain-but-still-tried",
                "content": "# Intuition\\nSince the constraints are small , we can check for each numbers square if it follows the second condition. (sum of substrings == n )\\n\\n# Approach\\nRecursion is the key here \\nThink like you want to check if a given String  suppose \"12345\" , \\nwill give u a specific sum, by adding its substrings. \\n\\n# Complexity\\n- Time complexity:\\nToo Lazy\\n\\n- Space complexity:\\nToo Lazy\\n\\n# Code\\n```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int sum = 0; \\n        \\n        for(int i = 1; i <= n ; i++ ){\\n            \\n            if( check(i,Integer.toString(i*i),0)) sum += i*i; \\n        }\\n        \\n        return sum;\\n        \\n    }\\n    \\n    public boolean check(int n,String square ,int sum ){\\n        \\n        if( square.isEmpty() || square == null ){\\n            if( sum == n ) return true; \\n            else return false; \\n        }\\n        \\n        for(int i =0; i < square.length(); i++ ){\\n            \\n            if( check(n,square.substring(i+1),sum+Integer.valueOf(square.substring(0,i+1))) ) return true;\\n            \\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int sum = 0; \\n        \\n        for(int i = 1; i <= n ; i++ ){\\n            \\n            if( check(i,Integer.toString(i*i),0)) sum += i*i; \\n        }\\n        \\n        return sum;\\n        \\n    }\\n    \\n    public boolean check(int n,String square ,int sum ){\\n        \\n        if( square.isEmpty() || square == null ){\\n            if( sum == n ) return true; \\n            else return false; \\n        }\\n        \\n        for(int i =0; i < square.length(); i++ ){\\n            \\n            if( check(n,square.substring(i+1),sum+Integer.valueOf(square.substring(0,i+1))) ) return true;\\n            \\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546897,
                "title": "java-easy-solution",
                "content": "\\n```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n       \\n        int count=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(check(0,i,0,Integer.toString(i*i))) count=count+(i*i);\\n        }\\n        return count;\\n    }\\n      public boolean check(int idx,int n,int s,String s1)\\n    {\\n        if(idx==s1.length())\\n        {\\n            if(s==n) return true;\\n            else return false;\\n        }\\n        for(int j=idx;j<s1.length();j++)\\n        {\\n            if(check(j+1,n,s+Integer.valueOf(s1.substring(idx,j+1)),s1))\\n                return true;\\n        }\\n         return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n       \\n        int count=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(check(0,i,0,Integer.toString(i*i))) count=count+(i*i);\\n        }\\n        return count;\\n    }\\n      public boolean check(int idx,int n,int s,String s1)\\n    {\\n        if(idx==s1.length())\\n        {\\n            if(s==n) return true;\\n            else return false;\\n        }\\n        for(int j=idx;j<s1.length();j++)\\n        {\\n            if(check(j+1,n,s+Integer.valueOf(s1.substring(idx,j+1)),s1))\\n                return true;\\n        }\\n         return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546766,
                "title": "simple-backtracking-solution",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def punishmentNumber(self, n):\\n        def check(i, sum_, s):\\n            if i == len(s):\\n                return sum_ == num\\n            ans = False\\n            for j in range(i, len(s)):\\n                ans = check(j + 1, sum_ + int(s[i: j + 1]), s) or ans\\n            return ans\\n            \\n        res = 0\\n        for num in range(1, n + 1):\\n            sNum = num * num\\n            if check(0, 0, str(sNum)):\\n                res += sNum\\n        return res\\n```\\nUpVote, if you like it **:)**",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution(object):\\n    def punishmentNumber(self, n):\\n        def check(i, sum_, s):\\n            if i == len(s):\\n                return sum_ == num\\n            ans = False\\n            for j in range(i, len(s)):\\n                ans = check(j + 1, sum_ + int(s[i: j + 1]), s) or ans\\n            return ans\\n            \\n        res = 0\\n        for num in range(1, n + 1):\\n            sNum = num * num\\n            if check(0, 0, str(sNum)):\\n                res += sNum\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552961,
                "title": "python-3-16-lines-w-optimization-tip-t-m-99-95",
                "content": "Optimization Tip:\\n\\nA necessary condition for an integer num to satisfy the partition criterion is:\\n```\\n            num %9 ==  0 or  num %9 ==  1.\\n```            \\nThis necessary condition greatly reduces the number of candidates to check the partition criterion.\\n\\nFor example, if n = 20, then the candidates 1 <= i <= 20 can be pruned to i = 9, 10, 18, or 19.\\n\\nThe reason for this necessary condition is based on the *casting out nines* principle. An integer`num`satisfies the *partition* criterion only if:\\n```\\n                  (num%9)**2 == num %9, \\n```           \\nwhich implies this necessary condition. The details are left to the reader.           \\n```\\ndef isValid(num: int) -> bool:                          # <-- checks whether num satisfies the \\n                                                        #     partition criterion\\n    l = len(sq := str(sqr(num))) -1\\n\\n    for i in range(1 << l):                             # <-- builds and checks partitions \\n\\n        par = [str()]                          \\n        for j, ch in enumerate(sq):\\n            par[-1] += ch\\n            if i & (1 << j): par.append(str())\\n\\n        if sum(map(int, par)) == num: return True\\n\\n    return False\\n\\nsqr = lambda x: x*x\\nf = lambda x: x%9 < 2 and isValid(x)                    # <-- Here\\'s that necessary condition\\n\\nnums = tuple(filter(f,tuple(range(1,1001))))            # <-- builds the list of integers that \\n                                                        #     satisfy the partition criterion\\npref = tuple(accumulate(map(sqr,nums), initial = 0))    # <-- builds prefix sum\\n\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n\\n        return pref[bisect_right(nums, n)]              # <-- determines punishment number\\n```\\n[https://leetcode.com/problems/find-the-punishment-number-of-an-integer/submissions/954947169//](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*log*N*) and space complexity is *O*(*N*log*N*), both in which *N* ~`len(nums)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n            num %9 ==  0 or  num %9 ==  1.\\n```\n```\\n                  (num%9)**2 == num %9, \\n```\n```\\ndef isValid(num: int) -> bool:                          # <-- checks whether num satisfies the \\n                                                        #     partition criterion\\n    l = len(sq := str(sqr(num))) -1\\n\\n    for i in range(1 << l):                             # <-- builds and checks partitions \\n\\n        par = [str()]                          \\n        for j, ch in enumerate(sq):\\n            par[-1] += ch\\n            if i & (1 << j): par.append(str())\\n\\n        if sum(map(int, par)) == num: return True\\n\\n    return False\\n\\nsqr = lambda x: x*x\\nf = lambda x: x%9 < 2 and isValid(x)                    # <-- Here\\'s that necessary condition\\n\\nnums = tuple(filter(f,tuple(range(1,1001))))            # <-- builds the list of integers that \\n                                                        #     satisfy the partition criterion\\npref = tuple(accumulate(map(sqr,nums), initial = 0))    # <-- builds prefix sum\\n\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n\\n        return pref[bisect_right(nums, n)]              # <-- determines punishment number\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547194,
                "title": "c-dp-recursion-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmake a dp array to store the punishment numbers from 1 to n.\\nmake a recursive check function to check if a given number follows the property no.2\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool check(int n1,int sum, int sqre,int n)\\n    {\\n        if(n1+sum==n)\\n        {\\n            return true;\\n        }\\n        int tens=10;\\n        while(n1/tens!=0)\\n        {\\n            int nsum= sum + (n1%tens);\\n            \\n            int nn1= (n1/tens);\\n            bool ans=check(nn1,nsum, sqre,n);\\n            \\n            if(ans==true)\\n            {\\n                return true;\\n            }\\n                \\n            tens=tens*10;\\n        }\\n        return false;\\n    }\\n    \\n    int punishmentNumber(int n) {\\n        vector<int>dp(n+1,0);\\n        int ans=0;\\n        for(int i=1; i<=n;i++)\\n        {\\n            int curr=0;\\n            if(check(i*i,0,i*i,i))\\n            {\\n                curr=i*i;\\n            }    \\n            // dp[i]=dp[i-1]+curr;\\n            ans+=curr;\\n        }\\n    \\n        // return dp[n];\\n        return ans;\\n    \\n    }\\n};\\n```\\n# Complexity \\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\ntime taken by check function: x^x (x=number of digits in i*i)\\nmaximium value of i * i=10^8\\nmax value of x=8 \\nwe run this check function n times\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nn sized dp array can be reduced to a single variable\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(int n1,int sum, int sqre,int n)\\n    {\\n        if(n1+sum==n)\\n        {\\n            return true;\\n        }\\n        int tens=10;\\n        while(n1/tens!=0)\\n        {\\n            int nsum= sum + (n1%tens);\\n            \\n            int nn1= (n1/tens);\\n            bool ans=check(nn1,nsum, sqre,n);\\n            \\n            if(ans==true)\\n            {\\n                return true;\\n            }\\n                \\n            tens=tens*10;\\n        }\\n        return false;\\n    }\\n    \\n    int punishmentNumber(int n) {\\n        vector<int>dp(n+1,0);\\n        int ans=0;\\n        for(int i=1; i<=n;i++)\\n        {\\n            int curr=0;\\n            if(check(i*i,0,i*i,i))\\n            {\\n                curr=i*i;\\n            }    \\n            // dp[i]=dp[i-1]+curr;\\n            ans+=curr;\\n        }\\n    \\n        // return dp[n];\\n        return ans;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547064,
                "title": "brute-force-but-easy-to-understand-c",
                "content": "check individually for easy no.\\n# Code\\n```\\n// <!-- UPVOTE IF THIS CODE IS HELP FULL FOR YOU\\n// IF ANY SUGGETION YOU CAN COMMENT HERE. -->\\nclass Solution {\\npublic:\\n    bool check(string &str,int &k,int sum,int s){\\n        if(sum>k)return false;\\n        if(s==str.length()){\\n            if(k==sum)return true;\\n            return false;\\n        }\\n        bool ans = false;\\n        int x = 0;\\n        for(int i = s; i < str.length(); i++){\\n            x = x*10+(str[i]-\\'0\\');\\n            ans |= check(str,k,sum+x,i+1);\\n        }\\n        return ans;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        string str;\\n        for(int i = 1; i <= n; i++){\\n            str = to_string(i*i);\\n            if(check(str,i,0,0)){\\n                ans += (i*i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// <!-- UPVOTE IF THIS CODE IS HELP FULL FOR YOU\\n// IF ANY SUGGETION YOU CAN COMMENT HERE. -->\\nclass Solution {\\npublic:\\n    bool check(string &str,int &k,int sum,int s){\\n        if(sum>k)return false;\\n        if(s==str.length()){\\n            if(k==sum)return true;\\n            return false;\\n        }\\n        bool ans = false;\\n        int x = 0;\\n        for(int i = s; i < str.length(); i++){\\n            x = x*10+(str[i]-\\'0\\');\\n            ans |= check(str,k,sum+x,i+1);\\n        }\\n        return ans;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        string str;\\n        for(int i = 1; i <= n; i++){\\n            str = to_string(i*i);\\n            if(check(str,i,0,0)){\\n                ans += (i*i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546985,
                "title": "simple-python-solution-clearly-explained-partable-function",
                "content": "# Intuition\\nlooking at this problem we can basically do a iteration i over numbers from 1 to n+1.... but the real problem lies in checking if the square of i..... we utilize a funtion partable to check if it can be partitioned to satisfy the given conditions\\n# Approach\\n![WhatsApp Image 2023-05-21 at 9.35.57 AM.jpeg](https://assets.leetcode.com/users/images/82dd5fed-d8dd-45f8-851e-b7b4ddff95f2_1684642191.6161456.jpeg)\\n\\nto consider a better example for this lets consider 36(square 1296)\\n\\n![img2.jpeg](https://assets.leetcode.com/users/images/9c9d1bec-f3e7-4416-9636-a387cb083cc9_1684642227.168015.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        \\n        # to check if we the square number can be arranged to satisfy the given conditions\\n        def partable(n,li,i):\\n            if(len(n)<=i):\\n                return sum(li)==math.sqrt(int(n))\\n            if(partable(n,li[:-1]+[int(str(li[-1])+n[i])],i+1) or partable(n,li+[int(n[i])],i+1)):return True\\n            return False\\n        \\n        #iterating over the every number from 1 to n\\n        res=0\\n        for i in range(1,n+1):\\n            if(partable(str(i*i),[int(str(i*i)[0])],1)):res+=i*i\\n        return res\\n```\\n\\n\\n![upvote.jpeg](https://assets.leetcode.com/users/images/6e7a15fa-62d6-49ac-bd37-03c186f09a39_1684642701.7989.jpeg)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        \\n        # to check if we the square number can be arranged to satisfy the given conditions\\n        def partable(n,li,i):\\n            if(len(n)<=i):\\n                return sum(li)==math.sqrt(int(n))\\n            if(partable(n,li[:-1]+[int(str(li[-1])+n[i])],i+1) or partable(n,li+[int(n[i])],i+1)):return True\\n            return False\\n        \\n        #iterating over the every number from 1 to n\\n        res=0\\n        for i in range(1,n+1):\\n            if(partable(str(i*i),[int(str(i*i)[0])],1)):res+=i*i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546837,
                "title": "easy-to-understand-python-solution-with-clear-steps-and-explanation",
                "content": "# Code\\n```\\n\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        #This is a method to check if s is possible to make s with su and cache_sum\\n        def possible(sum_added,cache_sum, n, target):\\n            # We have two choices, either to use the first character of n or combine it with the sum that we have\\n            if not n:\\n                return target == sum_added+cache_sum\\n            num = int(n[0])\\n            cas = cache_sum\\n            #This is case when we add the first number to already present sum: possible(sum_added,cas*10+num, n[1:], target)\\n            # Case when we add this as a digit, so we add cache_sum to already present sum: possible(sum_added+cas,num, n[1:], target)\\n            return possible(sum_added,cas*10+num, n[1:], target) or possible(sum_added+cas,num, n[1:], target)\\n        # print(possible(0,0 ,str(81), 9))\\n        ans = 0\\n        for i in range(1, n+1):\\n            # We see how many are possible\\n            if possible(0,0,str(i*i), i):\\n                ans += i*i\\n        return ans\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        #This is a method to check if s is possible to make s with su and cache_sum\\n        def possible(sum_added,cache_sum, n, target):\\n            # We have two choices, either to use the first character of n or combine it with the sum that we have\\n            if not n:\\n                return target == sum_added+cache_sum\\n            num = int(n[0])\\n            cas = cache_sum\\n            #This is case when we add the first number to already present sum: possible(sum_added,cas*10+num, n[1:], target)\\n            # Case when we add this as a digit, so we add cache_sum to already present sum: possible(sum_added+cas,num, n[1:], target)\\n            return possible(sum_added,cas*10+num, n[1:], target) or possible(sum_added+cas,num, n[1:], target)\\n        # print(possible(0,0 ,str(81), 9))\\n        ans = 0\\n        for i in range(1, n+1):\\n            # We see how many are possible\\n            if possible(0,0,str(i*i), i):\\n                ans += i*i\\n        return ans\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552322,
                "title": "punishment-number-solve-by-recursion-in-java",
                "content": "\\n\\n```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int sum = 0;\\n        for(int i = 1; i <= n ; i++)\\n        {\\n            int sqr = i*i;\\n            if(isPart(sqr,i))\\n            sum += sqr;\\n        }\\n        return sum;\\n    }\\n        boolean isPart(int num, int tar)\\n        {\\n            if(tar < 0 || num < tar)\\n            {\\n                return false;\\n            }\\n            if(num == tar)\\n            return true;\\n            return isPart(num/10,tar-num%10)||isPart(num/100,tar-num%100)||isPart(num/1000,tar-num%1000);\\n        }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int sum = 0;\\n        for(int i = 1; i <= n ; i++)\\n        {\\n            int sqr = i*i;\\n            if(isPart(sqr,i))\\n            sum += sqr;\\n        }\\n        return sum;\\n    }\\n        boolean isPart(int num, int tar)\\n        {\\n            if(tar < 0 || num < tar)\\n            {\\n                return false;\\n            }\\n            if(num == tar)\\n            return true;\\n            return isPart(num/10,tar-num%10)||isPart(num/100,tar-num%100)||isPart(num/1000,tar-num%1000);\\n        }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548818,
                "title": "c-backtracking-approach-explained",
                "content": "# Intuition\\nThe main idea of this problem is to generate all non empty partitions of a string using Backtracking.\\n\\nFor example let\\'s  say i = 36, it\\'s square = 36*36 = 1296\\nTo check if some partition of 1296 satisfy given statement, we make all partitions e.g\\n[1,2,9,6], [1,29,6], [1,296], [12,9,6] , [12,96], [129,6]\\n\\nAmong these only [1,29,6] satisfies the constraint.\\n\\nWe only need one of these set to satisfy the statement, hence we break immediately if we find any valid set.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n* Generate all possible squares and check if they satisfy the given statement\\n* To check if a square satisfies the given constraint or not generate all possible partitions using backtracking.\\n* If any single partition satisfy the statement then this square will be added to solution\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity :  O(n*(2^6)), here 6 is the maxm square length that is len(1000*1000) = 6\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool valid(int n, string s,int sum){\\n        // empty string indicates we have completed one partition\\n        if(s==\"\") if(sum==n) return true;\\n\\n        // We use backtracking to check for all partitions if it is possible to generate required sum \\n        // and if we find sum we immediately return true immediately\\n        for(int i=1;i<=s.size();i++){\\n            int x  = stoi(s.substr(0,i));\\n            if(valid(n, s.substr(i), sum+x)) return true;\\n        }\\n        \\n        //If no partition could add up to required sum n\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n\\n        //generate all possible squares and check them if they satisfy the given statement\\n        for(int i=1;i<=n;i++){\\n            int sq = i*i;\\n            string x = to_string(sq);\\n            if(valid(i,x,0)) ans += i*i;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool valid(int n, string s,int sum){\\n        // empty string indicates we have completed one partition\\n        if(s==\"\") if(sum==n) return true;\\n\\n        // We use backtracking to check for all partitions if it is possible to generate required sum \\n        // and if we find sum we immediately return true immediately\\n        for(int i=1;i<=s.size();i++){\\n            int x  = stoi(s.substr(0,i));\\n            if(valid(n, s.substr(i), sum+x)) return true;\\n        }\\n        \\n        //If no partition could add up to required sum n\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n\\n        //generate all possible squares and check them if they satisfy the given statement\\n        for(int i=1;i<=n;i++){\\n            int sq = i*i;\\n            string x = to_string(sq);\\n            if(valid(i,x,0)) ans += i*i;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546746,
                "title": "recursion-c",
                "content": "**Brute-Force Recursion**\\n# Complexity\\n- Time complexity: Exponential (I think)\\n# C++\\n```\\nclass Solution {\\npublic:\\n    bool isPunished(int n, int ogNum, int curNum, int mod) {\\n        if (curNum == ogNum and n == 0)\\n            return 1;\\n        if (curNum > ogNum || n == 0 || n * 10 < mod)\\n            return 0;\\n        if (isPunished(n / mod, ogNum, curNum + (n % mod), 10))\\n            return 1;\\n        if (isPunished(n, ogNum, curNum, mod * 10))\\n            return 1;\\n        return 0;\\n    }\\n    int punishmentNumber(int n) {\\n        int res = 0;\\n        for (int num = 1; num <= n; ++num) {\\n            int sq = num * num * 1LL;\\n            if (isPunished(sq, num, 0, 10))\\n                res += sq;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPunished(int n, int ogNum, int curNum, int mod) {\\n        if (curNum == ogNum and n == 0)\\n            return 1;\\n        if (curNum > ogNum || n == 0 || n * 10 < mod)\\n            return 0;\\n        if (isPunished(n / mod, ogNum, curNum + (n % mod), 10))\\n            return 1;\\n        if (isPunished(n, ogNum, curNum, mod * 10))\\n            return 1;\\n        return 0;\\n    }\\n    int punishmentNumber(int n) {\\n        int res = 0;\\n        for (int num = 1; num <= n; ++num) {\\n            int sq = num * num * 1LL;\\n            if (isPunished(sq, num, 0, 10))\\n                res += sq;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692827,
                "title": "recursion-group-ungroup",
                "content": "```\\nclass Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        int res = 0;\\n\\n        for (int i=1; i<=n; i++) {\\n            int pro = i*i;\\n            if (helper(i, pro)) res += pro;\\n            // cout << \"------------------\\\\n\";\\n        }\\n\\n        return res;\\n    }\\n\\n    bool helper(int target, int n, int prev=0, int sum = 0, int mul = 1) {\\n        if (n==0) {\\n            // cout << target << \\' \\' << n << \\' \\' << prev << \\' \\' << sum << \\' \\' << mul << endl;\\n            if (sum==target) return true;\\n            return false;\\n        }\\n        if (prev > target) return false;\\n        if (sum > target) return false;\\n\\n        int curr = n%10;\\n        int newprev = prev + curr*mul; // value after grouping with previous number\\n\\n        // cout << target << \\' \\' << n << \\' \\' << prev << \\' \\' << sum << \\' \\' << mul << endl;\\n\\n        bool res = helper(target, n/10, newprev, sum - prev + newprev, mul*10); // join previous group\\n        res |= helper(target, n/10, curr, sum + curr, 10); // form new group\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        int res = 0;\\n\\n        for (int i=1; i<=n; i++) {\\n            int pro = i*i;\\n            if (helper(i, pro)) res += pro;\\n            // cout << \"------------------\\\\n\";\\n        }\\n\\n        return res;\\n    }\\n\\n    bool helper(int target, int n, int prev=0, int sum = 0, int mul = 1) {\\n        if (n==0) {\\n            // cout << target << \\' \\' << n << \\' \\' << prev << \\' \\' << sum << \\' \\' << mul << endl;\\n            if (sum==target) return true;\\n            return false;\\n        }\\n        if (prev > target) return false;\\n        if (sum > target) return false;\\n\\n        int curr = n%10;\\n        int newprev = prev + curr*mul; // value after grouping with previous number\\n\\n        // cout << target << \\' \\' << n << \\' \\' << prev << \\' \\' << sum << \\' \\' << mul << endl;\\n\\n        bool res = helper(target, n/10, newprev, sum - prev + newprev, mul*10); // join previous group\\n        res |= helper(target, n/10, curr, sum + curr, 10); // form new group\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3559930,
                "title": "amortized-o-1",
                "content": "We use a recursive function (`canPartition`) to check each number `<= n`.\\n\\nThen, we maintain a prefix sum to lookup a punishment number for `n`.\\n\\n> Note that `psum` is reused between test cases, so the complexity is amortized O(1).\\n\\n**C++**\\n```cpp\\nint psum[1001] = {}, ln = 1;\\nclass Solution {\\npublic:\\n    bool canPartition(const string &s, int i, int n) {\\n        if (n < 0 || i == s.size())\\n            return n == 0;\\n        for (int j = i, num = 0; j < s.size() && num <= n; ++j) {\\n            num = (num * 10) + (s[j] - \\'0\\');\\n            if (canPartition(s, j + 1, n - num))\\n                return true;\\n        }\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        for(; ln <= n; ++ln)\\n            psum[ln] = psum[ln - 1] + (canPartition(to_string(ln * ln), 0, ln) ? ln * ln : 0);\\n        return psum[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint psum[1001] = {}, ln = 1;\\nclass Solution {\\npublic:\\n    bool canPartition(const string &s, int i, int n) {\\n        if (n < 0 || i == s.size())\\n            return n == 0;\\n        for (int j = i, num = 0; j < s.size() && num <= n; ++j) {\\n            num = (num * 10) + (s[j] - \\'0\\');\\n            if (canPartition(s, j + 1, n - num))\\n                return true;\\n        }\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        for(; ln <= n; ++ln)\\n            psum[ln] = psum[ln - 1] + (canPartition(to_string(ln * ln), 0, ln) ? ln * ln : 0);\\n        return psum[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548746,
                "title": "easy-to-understand-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int ans = 0;\\n        for (int i = 1; i <= n; i++) {\\n            int sqr = i * i;\\n            if (solve(\"\"+sqr, 0, i)) {\\n                ans += sqr;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    boolean solve(String s, int sum, int target) {\\n        if (s.length() == 0) return sum == target;\\n        for (int i = 0; i < s.length(); i++) {\\n            int val = Integer.parseInt(s.substring(0, i+1));\\n            if (solve(s.substring(i+1), sum + val, target)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int ans = 0;\\n        for (int i = 1; i <= n; i++) {\\n            int sqr = i * i;\\n            if (solve(\"\"+sqr, 0, i)) {\\n                ans += sqr;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    boolean solve(String s, int sum, int target) {\\n        if (s.length() == 0) return sum == target;\\n        for (int i = 0; i < s.length(); i++) {\\n            int val = Integer.parseInt(s.substring(0, i+1));\\n            if (solve(s.substring(i+1), sum + val, target)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548557,
                "title": "very-easy-solution",
                "content": "```\\nclass Solution {\\n    ArrayList<String>list=new ArrayList<>();\\n    boolean b=false;\\n    public int punishmentNumber(int n) {\\n        int ans=0;\\n        \\n        for(int i=1;i<=n;i++){\\n            int k=i*i;\\n            String p=k+\"\";\\n            find(p,i);\\n            if(b){\\n                // System.out.println(i);\\n                ans+=i*i;\\n            }\\n            b=false;\\n            list.clear();\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public void find(String s,int check){\\n        if(s.equals(\"\")){\\n            int ans=0;\\n            \\n            for(String j:list){\\n                ans+=Integer.parseInt(j);\\n            }\\n            \\n            if(ans==check){\\n                b=true;\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0;i<s.length();i++){\\n            String current=s.substring(0,i+1);\\n            list.add(current);\\n            find(s.substring(i+1),check);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    ArrayList<String>list=new ArrayList<>();\\n    boolean b=false;\\n    public int punishmentNumber(int n) {\\n        int ans=0;\\n        \\n        for(int i=1;i<=n;i++){\\n            int k=i*i;\\n            String p=k+\"\";\\n            find(p,i);\\n            if(b){\\n                // System.out.println(i);\\n                ans+=i*i;\\n            }\\n            b=false;\\n            list.clear();\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public void find(String s,int check){\\n        if(s.equals(\"\")){\\n            int ans=0;\\n            \\n            for(String j:list){\\n                ans+=Integer.parseInt(j);\\n            }\\n            \\n            if(ans==check){\\n                b=true;\\n            }\\n            return;\\n        }\\n        \\n        for(int i=0;i<s.length();i++){\\n            String current=s.substring(0,i+1);\\n            list.add(current);\\n            find(s.substring(i+1),check);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548453,
                "title": "c-recursion-simple-valid-function-partitioning",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this question we have to find sum of square of all the integer from 1 to n and condition is The decimal representation of i * i can be partitioned into contiguous substrings such that the sum of the integer values of these substrings equals i. \\n\\nso to find this we run a loop from 1 to n and check i is satisfy the condition or not if it satisfy then we add square of the i into our answer.\\n\\nNow the main concern is how we check so we can use the idea like partioning the string using recursion. I make function isvalid where pass three value starting index which is zero second is string which we convert from number and third is the digit sum which we want to make.\\n\\nI write the code similar to palindrome partitioning.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*2^(length of string which is atmost 7))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(int i, string s,int total)\\n    {\\n        if(i==s.length())\\n        {\\n            if(total==0)\\n                return true;\\n            return false;\\n        }\\n        for(int j=i;j<s.length();j++)\\n        {\\n            if(isvalid(j+1,s,total-stoi(s.substr(i,j-i+1))))\\n            return true;\\n        }\\n        return false; \\n    }\\n    int punishmentNumber(int n) {\\n        int ans=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(isvalid(0,to_string(i*i),i)){\\n                ans+=i*i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n![upwote.jpeg](https://assets.leetcode.com/users/images/afb0ccc2-1ced-4bcc-a260-1f941cca6a3e_1684668097.810613.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int i, string s,int total)\\n    {\\n        if(i==s.length())\\n        {\\n            if(total==0)\\n                return true;\\n            return false;\\n        }\\n        for(int j=i;j<s.length();j++)\\n        {\\n            if(isvalid(j+1,s,total-stoi(s.substr(i,j-i+1))))\\n            return true;\\n        }\\n        return false; \\n    }\\n    int punishmentNumber(int n) {\\n        int ans=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(isvalid(0,to_string(i*i),i)){\\n                ans+=i*i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547234,
                "title": "image-explanation-of-the-recursion-c-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/a80175c1-b3ae-4d64-b123-9ad742276e7b_1684646207.9781668.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool canPartition(string& s, int startIdx, int target) {\\n        if(startIdx == s.size() && target == 0) return true;\\n        if(target < 0) return false;\\n\\n        int leftNum = 0;\\n        for(int i = startIdx; i < s.size(); i++) {\\n            leftNum = (leftNum * 10) + (s[i] - \\'0\\');\\n            if(canPartition(s, i + 1, target - leftNum)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    int punishmentNumber(int n) {\\n        int sum = 0;\\n        for(int num = 1; num <= n; num++) {\\n            int sq = num * num;\\n            string sqrStr = to_string(sq);\\n            if(canPartition(sqrStr, 0, num)) sum += sq;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool canPartition(string& s, int startIdx, int target) {\\n        if(startIdx == s.size() && target == 0) return true;\\n        if(target < 0) return false;\\n\\n        int leftNum = 0;\\n        for(int i = startIdx; i < s.size(); i++) {\\n            leftNum = (leftNum * 10) + (s[i] - \\'0\\');\\n            if(canPartition(s, i + 1, target - leftNum)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    int punishmentNumber(int n) {\\n        int sum = 0;\\n        for(int num = 1; num <= n; num++) {\\n            int sq = num * num;\\n            string sqrStr = to_string(sq);\\n            if(canPartition(sqrStr, 0, num)) sum += sq;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547042,
                "title": "recursion-solution-cpp-easy-soltuion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    \\n      bool solve(string s,string temp,int ans,int&target){\\n            if( s == \"\"){\\n                if(ans == target) return true;\\n                return false;\\n            }\\n             int len = s.size();\\n             bool res = true;\\n\\n            for(int i = 1 ; i<= s.size();i++){\\n                    int abc = stoi(s.substr(0,i));\\n                    res = solve(s.substr(i,len-1),(temp+s.substr(0,i)),abc+ans,target);\\n                    if(res == true) return true;\\n            }\\n            return res;\\n       }\\n    int punishmentNumber(int n) {\\n        int ans = 1;\\n        for(int i = 2 ;i<= n;i++) \\n           if(solve(to_string(i*i),\"\",0,i) ) ans +=(i*i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n      bool solve(string s,string temp,int ans,int&target){\\n            if( s == \"\"){\\n                if(ans == target) return true;\\n                return false;\\n            }\\n             int len = s.size();\\n             bool res = true;\\n\\n            for(int i = 1 ; i<= s.size();i++){\\n                    int abc = stoi(s.substr(0,i));\\n                    res = solve(s.substr(i,len-1),(temp+s.substr(0,i)),abc+ans,target);\\n                    if(res == true) return true;\\n            }\\n            return res;\\n       }\\n    int punishmentNumber(int n) {\\n        int ans = 1;\\n        for(int i = 2 ;i<= n;i++) \\n           if(solve(to_string(i*i),\"\",0,i) ) ans +=(i*i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546898,
                "title": "very-simple-and-easy-to-understand-solution",
                "content": "Method 1\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    void solve(string s,bool &f,int idx,int sum,int no)\\n    {\\n        if(0==s.size() && sum==no)\\n        {\\n            // cout<<sum<<\" \";\\n            f=true;\\n            return;\\n        }\\n        if(0==s.size()) return;\\n        for(int i=1;i<=s.size();i++)\\n        {\\n            string a=s.substr(0,i);\\n          // cout<<a<<\" \";\\n            solve(s.substr(i),f,idx,sum+stoi(a),no);\\n        }\\n    }\\n    int punishmentNumber(int n) {\\n        ll ans=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            ll x=i*i;\\n            bool f=false;\\n            string s=to_string(x);\\n            solve(s,f,0,0,i);\\n            if(f)\\n            {\\n                ans+=x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nMethod 2\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    bool solve(string s,int i,int sum,int no)\\n    {\\n        if(i==s.size() )\\n        {\\n           if( sum==no)\\n            return true;\\n            \\n            return false;\\n        }\\n         for(int j=i;j<s.size();j++)\\n        {\\n            string a=s.substr(i,j+1-i);\\n          \\n            if(solve(s,j+1,sum+stoi(a),no)) return true;\\n        }\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        ll ans=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            int x=i*i;\\n            \\n            string s=to_string(x);\\n          \\n            if(solve(s,0,0,i))\\n            {\\n                ans+=x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    void solve(string s,bool &f,int idx,int sum,int no)\\n    {\\n        if(0==s.size() && sum==no)\\n        {\\n            // cout<<sum<<\" \";\\n            f=true;\\n            return;\\n        }\\n        if(0==s.size()) return;\\n        for(int i=1;i<=s.size();i++)\\n        {\\n            string a=s.substr(0,i);\\n          // cout<<a<<\" \";\\n            solve(s.substr(i),f,idx,sum+stoi(a),no);\\n        }\\n    }\\n    int punishmentNumber(int n) {\\n        ll ans=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            ll x=i*i;\\n            bool f=false;\\n            string s=to_string(x);\\n            solve(s,f,0,0,i);\\n            if(f)\\n            {\\n                ans+=x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    bool solve(string s,int i,int sum,int no)\\n    {\\n        if(i==s.size() )\\n        {\\n           if( sum==no)\\n            return true;\\n            \\n            return false;\\n        }\\n         for(int j=i;j<s.size();j++)\\n        {\\n            string a=s.substr(i,j+1-i);\\n          \\n            if(solve(s,j+1,sum+stoi(a),no)) return true;\\n        }\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        ll ans=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            int x=i*i;\\n            \\n            string s=to_string(x);\\n          \\n            if(solve(s,0,0,i))\\n            {\\n                ans+=x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3546819,
                "title": "best-solution-easy-code-c-recursion",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\nO(n)*2^6 in worst case\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) for recursion stack space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int n,string s,int len,int size,int total,int pre){\\n        if(len+pre==size){\\n            int c=0;\\n            c=stoi(s.substr(pre,len));\\n            total+=c;\\n            if(total == n)\\n                return 1;\\n            else \\n                return 0;\\n               \\n        }\\n        \\n        int c=stoi(s.substr(pre,len));\\n        return solve(n,s,1,size,total+c,pre+len)||solve(n,s,len+1,size,total,pre);\\n    }\\n    int punishmentNumber(int n) {\\n        int ans=0;\\n        string s=\"\";\\n        for(int i=1;i<=n;i++){\\n            int sq=i*i;\\n            s=to_string(sq);\\n            if(solve(i,s,1,s.length(),0,0)==1){\\n               \\n                ans+=(i*i);\\n            }\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n,string s,int len,int size,int total,int pre){\\n        if(len+pre==size){\\n            int c=0;\\n            c=stoi(s.substr(pre,len));\\n            total+=c;\\n            if(total == n)\\n                return 1;\\n            else \\n                return 0;\\n               \\n        }\\n        \\n        int c=stoi(s.substr(pre,len));\\n        return solve(n,s,1,size,total+c,pre+len)||solve(n,s,len+1,size,total,pre);\\n    }\\n    int punishmentNumber(int n) {\\n        int ans=0;\\n        string s=\"\";\\n        for(int i=1;i<=n;i++){\\n            int sq=i*i;\\n            s=to_string(sq);\\n            if(solve(i,s,1,s.length(),0,0)==1){\\n               \\n                ans+=(i*i);\\n            }\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546810,
                "title": "brute-force-backtrack-c",
                "content": "```\\nclass Solution {\\n    bool dfs(int i, int n, vector<int> &v, int &val, int sum) {\\n        if(i == n) return sum == val;\\n        int cnt = 0;\\n        for(int j=i; j<n; j++) {\\n            cnt = cnt * 10 + v[j];\\n            if(dfs(j + 1, n, v, val, sum + cnt)) return true;\\n        }\\n        return false;\\n    }\\n    bool good(int n) {\\n        int a = n * n;\\n        vector<int> v;\\n       \\n        while(a) {\\n            v.push_back(a % 10);\\n            a /= 10;\\n        }\\n        reverse(v.begin(), v.end());\\n        return dfs(0, v.size(), v, n, 0);\\n    }\\npublic:\\n    int punishmentNumber(int n) {\\n        long ans = 0;\\n        for(int i=1; i<=n; i++) {\\n            if(good(i)) ans += i * i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    bool dfs(int i, int n, vector<int> &v, int &val, int sum) {\\n        if(i == n) return sum == val;\\n        int cnt = 0;\\n        for(int j=i; j<n; j++) {\\n            cnt = cnt * 10 + v[j];\\n            if(dfs(j + 1, n, v, val, sum + cnt)) return true;\\n        }\\n        return false;\\n    }\\n    bool good(int n) {\\n        int a = n * n;\\n        vector<int> v;\\n       \\n        while(a) {\\n            v.push_back(a % 10);\\n            a /= 10;\\n        }\\n        reverse(v.begin(), v.end());\\n        return dfs(0, v.size(), v, n, 0);\\n    }\\npublic:\\n    int punishmentNumber(int n) {\\n        long ans = 0;\\n        for(int i=1; i<=n; i++) {\\n            if(good(i)) ans += i * i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546774,
                "title": "java-backtracking-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*log<sub>10</sub>n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*log<sub>10</sub>n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  private Set<Integer> helper(int num, String s, int i) {\\n    var n = s.length();\\n    var ret = new HashSet<Integer>();\\n    \\n    if (i == n) {\\n      ret.add(0);\\n      return ret;\\n    }\\n    \\n    for (var j=i; j<n && Integer.parseInt(s.substring(i, j+1)) <= num; j++) {\\n      var x = Integer.parseInt(s.substring(i, j+1));\\n      var set = helper(num, s, j+1);\\n      \\n      for (var a : set) ret.add(x + a);\\n    }\\n    return ret;\\n  }\\n  \\n  public int punishmentNumber(int n) {\\n    var ans = 0;\\n    \\n    for (var i=1; i<=n; i++) \\n      if (helper(i, String.valueOf(i*i), 0).contains(i))\\n        ans += i*i;\\n    \\n    return ans;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n  private Set<Integer> helper(int num, String s, int i) {\\n    var n = s.length();\\n    var ret = new HashSet<Integer>();\\n    \\n    if (i == n) {\\n      ret.add(0);\\n      return ret;\\n    }\\n    \\n    for (var j=i; j<n && Integer.parseInt(s.substring(i, j+1)) <= num; j++) {\\n      var x = Integer.parseInt(s.substring(i, j+1));\\n      var set = helper(num, s, j+1);\\n      \\n      for (var a : set) ret.add(x + a);\\n    }\\n    return ret;\\n  }\\n  \\n  public int punishmentNumber(int n) {\\n    var ans = 0;\\n    \\n    for (var i=1; i<=n; i++) \\n      if (helper(i, String.valueOf(i*i), 0).contains(i))\\n        ans += i*i;\\n    \\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546736,
                "title": "o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int punishmentNumber(int n) {\\n    static vector<int> v{\\n      1,   9,   10,  36,  45,  55,  82,  91,  99,  100, 235, 297, 369, 370,  379,\\n      414, 657, 675, 703, 756, 792, 909, 918, 945, 964, 990, 991, 999, 1000,\\n    };\\n    int res = 0;\\n    for (int i : v) {\\n      if (i > n) {\\n        break;\\n      }\\n      res += i * i;\\n    }\\n    return res;\\n  }\\n};\\n\\n// pre calculate\\n/*\\nbool isP(int i) {\\n  int s = i * i;\\n  string sv = to_string(s);\\n  int n = sv.size();\\n  // cout << \">>> \" << sv << endl;\\n  function<bool(int, int)> f = [&](int index, int rest) {\\n    if (index == n) {\\n      return rest == 0;\\n    }\\n    int value = 0;\\n    for (int i = index; i < n; ++i) {\\n      value *= 10;\\n      value += sv[i] - \\'0\\';\\n      if (value <= rest && f(i + 1, rest - value)) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  };\\n  return f(0, i);\\n}\\n\\nint main(int, char*[]) {\\n  for (int i = 1; i <= 1000; ++i) {\\n    if (isP(i)) {\\n      cout << i << \",\";\\n    }\\n  }\\n  cout << endl;\\n\\n  return 0;\\n}\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int punishmentNumber(int n) {\\n    static vector<int> v{\\n      1,   9,   10,  36,  45,  55,  82,  91,  99,  100, 235, 297, 369, 370,  379,\\n      414, 657, 675, 703, 756, 792, 909, 918, 945, 964, 990, 991, 999, 1000,\\n    };\\n    int res = 0;\\n    for (int i : v) {\\n      if (i > n) {\\n        break;\\n      }\\n      res += i * i;\\n    }\\n    return res;\\n  }\\n};\\n\\n// pre calculate\\n/*\\nbool isP(int i) {\\n  int s = i * i;\\n  string sv = to_string(s);\\n  int n = sv.size();\\n  // cout << \">>> \" << sv << endl;\\n  function<bool(int, int)> f = [&](int index, int rest) {\\n    if (index == n) {\\n      return rest == 0;\\n    }\\n    int value = 0;\\n    for (int i = index; i < n; ++i) {\\n      value *= 10;\\n      value += sv[i] - \\'0\\';\\n      if (value <= rest && f(i + 1, rest - value)) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  };\\n  return f(0, i);\\n}\\n\\nint main(int, char*[]) {\\n  for (int i = 1; i <= 1000; ++i) {\\n    if (isP(i)) {\\n      cout << i << \",\";\\n    }\\n  }\\n  cout << endl;\\n\\n  return 0;\\n}\\n*/\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4059553,
                "title": "c-simple-recursion-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool is_valid(int i, string s, int t) {\\n        if(i == s.size() && t == 0) return true;\\n        else if(i == s.size()) return false;\\n\\n        string temp = \"\";\\n        bool ans = false;\\n        for(int ind = i; ind < s.size(); ind++) {\\n            temp += s[ind];\\n            ans = ans || is_valid(ind+1, s, t - stoi(temp));\\n        }\\n\\n        return ans;\\n    }\\n\\npublic:\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        for(int i=1;i<=n;i++) {\\n            if(is_valid(0, to_string(i*i), i)) {\\n                ans += i*i;\\n                cout<<i*i<<endl;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool is_valid(int i, string s, int t) {\\n        if(i == s.size() && t == 0) return true;\\n        else if(i == s.size()) return false;\\n\\n        string temp = \"\";\\n        bool ans = false;\\n        for(int ind = i; ind < s.size(); ind++) {\\n            temp += s[ind];\\n            ans = ans || is_valid(ind+1, s, t - stoi(temp));\\n        }\\n\\n        return ans;\\n    }\\n\\npublic:\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        for(int i=1;i<=n;i++) {\\n            if(is_valid(0, to_string(i*i), i)) {\\n                ans += i*i;\\n                cout<<i*i<<endl;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3643630,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s, int target)\\n    {\\n        if (s == \"\" && target == 0) return true;\\n        if (target < 0) return false;\\n        \\n        bool ans = false;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            string left = s.substr(0, i + 1);\\n            string right = s.substr(i + 1);\\n            int leftNum = stoi(left);\\n            \\n            bool isPossible = isValid(right, target - leftNum);\\n            if (isPossible) { ans = true; break; }\\n        }\\n        return ans;\\n    }\\n    int punishmentNumber(int n)\\n    {\\n        int sum = 0;\\n        for (int num  = 1; num <= n; num++)\\n        {\\n            int sqr = num * num;\\n            if (isValid(to_string(sqr), num)) \\n            {\\n                sum += sqr;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s, int target)\\n    {\\n        if (s == \"\" && target == 0) return true;\\n        if (target < 0) return false;\\n        \\n        bool ans = false;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            string left = s.substr(0, i + 1);\\n            string right = s.substr(i + 1);\\n            int leftNum = stoi(left);\\n            \\n            bool isPossible = isValid(right, target - leftNum);\\n            if (isPossible) { ans = true; break; }\\n        }\\n        return ans;\\n    }\\n    int punishmentNumber(int n)\\n    {\\n        int sum = 0;\\n        for (int num  = 1; num <= n; num++)\\n        {\\n            int sqr = num * num;\\n            if (isValid(to_string(sqr), num)) \\n            {\\n                sum += sqr;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560918,
                "title": "brute-force-partition-string-recursion-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    void partition(string str,int index,vector<string> &temp,pair<int,bool> &n,int &ans){\\n        if(index>=str.length()){\\n            int tempSum = 0;\\n            for(auto i:temp){\\n                tempSum+=stoi(i);\\n            }\\n            if(tempSum == n.first && n.second == false){\\n                ans+=(int)pow(n.first,2);\\n                n.second = true;\\n            }\\n            \\n            return;\\n        }\\n\\n        for(int i=index;i<str.length();i++){\\n            int len = i-index+1;\\n            string te = str.substr(index,len);\\n            temp.push_back(te);\\n            partition(str,i+1,temp,n,ans);\\n            temp.pop_back();\\n        }\\n    }\\n\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        for(int i=1;i<=n;i++){\\n            string sq = to_string((int)pow(i,2));\\n            vector<string> temp;\\n            pair<int,bool> pp;\\n            pp.first = i;\\n            pp.second  = false;\\n          partition(sq,0,temp,pp,ans);\\n           \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void partition(string str,int index,vector<string> &temp,pair<int,bool> &n,int &ans){\\n        if(index>=str.length()){\\n            int tempSum = 0;\\n            for(auto i:temp){\\n                tempSum+=stoi(i);\\n            }\\n            if(tempSum == n.first && n.second == false){\\n                ans+=(int)pow(n.first,2);\\n                n.second = true;\\n            }\\n            \\n            return;\\n        }\\n\\n        for(int i=index;i<str.length();i++){\\n            int len = i-index+1;\\n            string te = str.substr(index,len);\\n            temp.push_back(te);\\n            partition(str,i+1,temp,n,ans);\\n            temp.pop_back();\\n        }\\n    }\\n\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        for(int i=1;i<=n;i++){\\n            string sq = to_string((int)pow(i,2));\\n            vector<string> temp;\\n            pair<int,bool> pp;\\n            pp.first = i;\\n            pp.second  = false;\\n          partition(sq,0,temp,pp,ans);\\n           \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550227,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        def possible(sum_added,cache_sum, n, target):\\n            \\n            if not n:\\n                return target == sum_added+cache_sum\\n            num = int(n[0])\\n            cas = cache_sum\\n\\n            return possible(sum_added,cas*10+num, n[1:], target) or possible(sum_added+cas,num, n[1:], target)\\n\\n        ans = 0\\n        for i in range(1, n+1):\\n           \\n            if possible(0,0,str(i*i), i):\\n                ans += i*i\\n        return ans\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        def possible(sum_added,cache_sum, n, target):\\n            \\n            if not n:\\n                return target == sum_added+cache_sum\\n            num = int(n[0])\\n            cas = cache_sum\\n\\n            return possible(sum_added,cas*10+num, n[1:], target) or possible(sum_added+cas,num, n[1:], target)\\n\\n        ans = 0\\n        for i in range(1, n+1):\\n           \\n            if possible(0,0,str(i*i), i):\\n                ans += i*i\\n        return ans\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550121,
                "title": "python-punishment-number-of-an-integer",
                "content": "```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        res = 0\\n        for i in range(n + 1):\\n            sqr = i * i\\n            a = str(sqr)\\n            if self.check(a, i):\\n                res += sqr\\n        return res\\n    \\n    def check(self, s, t):\\n        if len(s) == 0 and t == 0:\\n            return True\\n        if t < 0:\\n            return False\\n        for i in range(len(s)):\\n            l = s[:i+1]\\n            r = s[i+1:]\\n            res = self.check(r, t - int(l))\\n            if res:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        res = 0\\n        for i in range(n + 1):\\n            sqr = i * i\\n            a = str(sqr)\\n            if self.check(a, i):\\n                res += sqr\\n        return res\\n    \\n    def check(self, s, t):\\n        if len(s) == 0 and t == 0:\\n            return True\\n        if t < 0:\\n            return False\\n        for i in range(len(s)):\\n            l = s[:i+1]\\n            r = s[i+1:]\\n            res = self.check(r, t - int(l))\\n            if res:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549841,
                "title": "python-100-fast-solution",
                "content": "# Approach\\nhttps://oeis.org/A038206 - jist visit this link to read about punishment numbers)\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n\\n- Space complexity: $$O(N)$$\\n\\n# Code\\n```\\n\"\"\"\\nhttps://oeis.org/A038206\\n\"\"\"\\n\\n\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        nums = [1, 9, 10, 36, 45, 55, \\n        82, 91, 99, 100, 235, 297, \\n        369, 370, 379, 414, 657, \\n        675, 703, 756, 792, 909, \\n        918, 945, 964, 990, 991, \\n        999, 1000]\\n        ans = 0\\n        for num in nums:\\n            if n >= num:\\n                ans += num**2\\n            else:\\n                break\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```\\n\"\"\"\\nhttps://oeis.org/A038206\\n\"\"\"\\n\\n\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        nums = [1, 9, 10, 36, 45, 55, \\n        82, 91, 99, 100, 235, 297, \\n        369, 370, 379, 414, 657, \\n        675, 703, 756, 792, 909, \\n        918, 945, 964, 990, 991, \\n        999, 1000]\\n        ans = 0\\n        for num in nums:\\n            if n >= num:\\n                ans += num**2\\n            else:\\n                break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549821,
                "title": "prefix-sum-or-recursion",
                "content": "# Observation\\nCan we express a(n) with the digits of a(n)^2 in order, only adding plus signs ?\\nNotice that every term is either 0 or 1 modulo 9.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        vector<int> s{1, 9, 10, 36, 45, 55, 82, 91, 99, 100, 235, 297, 369, 370, 379, 414, 657, 675, 703, 756, 792, 909, 918, 945, 964, 990, 991, 999, 1000}; \\n        vector<int> pre(size(s));\\n        for(int i=0; i<size(s); ++i)\\n            pre[i] = (i?pre[i-1]: 0) + (s[i] * s[i]);\\n        return pre[upper_bound(begin(s),end(s),n)-begin(s)-1];\\n    }\\n};\\n```\\n# Recursion Approach\\n```\\nclass Solution {\\nprivate:\\n    bool fn(string&s,int n,int k,int idx){\\n        if(idx >= n) return k == 0;\\n        for(int i=1; i<=n; ++i){\\n            int e = stoi(s.substr(idx,i));\\n            if(k - e >= 0){\\n                if(fn(s,n,k-e,i+idx)) return true;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        for(int i=1; i<=n; ++i){\\n            string e = to_string(i*i);\\n            if(fn(e,size(e),i,0)){\\n                ans += i*i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        vector<int> s{1, 9, 10, 36, 45, 55, 82, 91, 99, 100, 235, 297, 369, 370, 379, 414, 657, 675, 703, 756, 792, 909, 918, 945, 964, 990, 991, 999, 1000}; \\n        vector<int> pre(size(s));\\n        for(int i=0; i<size(s); ++i)\\n            pre[i] = (i?pre[i-1]: 0) + (s[i] * s[i]);\\n        return pre[upper_bound(begin(s),end(s),n)-begin(s)-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    bool fn(string&s,int n,int k,int idx){\\n        if(idx >= n) return k == 0;\\n        for(int i=1; i<=n; ++i){\\n            int e = stoi(s.substr(idx,i));\\n            if(k - e >= 0){\\n                if(fn(s,n,k-e,i+idx)) return true;\\n            }\\n        }\\n        return false;\\n    }\\npublic:\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        for(int i=1; i<=n; ++i){\\n            string e = to_string(i*i);\\n            if(fn(e,size(e),i,0)){\\n                ans += i*i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549757,
                "title": "fastest-code-of-this-question-possible",
                "content": "# Intuition\\nPre Caluculate all the number as constraints are small.\\n# Approach\\nMake a vector of the pre calculated numbers and traverse over it and take the sum of numbers less than n.\\n\\n# Complexity\\n- Time complexity: Bit Slower than O(1).\\n\\n- Space complexity: O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n     vector<int> numbers = {1, 9, 10, 36, 45, 55, 82, 91, 99, 100, 235, 297, 369, 370, 379, 414, 657, 675, 703, 756, 792, 909, 918, 945, 964, 990, 991, 999, 1000};\\n\\n        int i = 0 , res = 0;\\n        while( i < numbers.size() && n >= numbers[i])\\n        {\\n            res += numbers[i]*numbers[i];\\n            i++;\\n        }\\n     return res;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n     vector<int> numbers = {1, 9, 10, 36, 45, 55, 82, 91, 99, 100, 235, 297, 369, 370, 379, 414, 657, 675, 703, 756, 792, 909, 918, 945, 964, 990, 991, 999, 1000};\\n\\n        int i = 0 , res = 0;\\n        while( i < numbers.size() && n >= numbers[i])\\n        {\\n            res += numbers[i]*numbers[i];\\n            i++;\\n        }\\n     return res;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548126,
                "title": "c-easy-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool helper(string sqr, int n , int sum , int i){\\n        if(sum == n && i == sqr.length()){\\n            // cout << sum << endl;\\n            return true;\\n        }\\n        \\n        \\n        for(int j=1;j<=sqr.length() - i;j++){\\n            string t = sqr.substr(i,j);\\n            // cout << t << endl;\\n            int temp = stoi(t);\\n            // cout<< t << \" \" << sum << endl;\\n            \\n            bool flag = helper(sqr, n , sum+temp,i+j );\\n            if(flag){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        for(int i=1;i<=n;i++){\\n            int s = i*i;\\n            // cout << s << \" \" << i<< endl;\\n            string sqr = to_string(s);\\n            bool flag = helper(sqr, i,0,0);\\n            if(flag){\\n                ans+=s;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool helper(string sqr, int n , int sum , int i){\\n        if(sum == n && i == sqr.length()){\\n            // cout << sum << endl;\\n            return true;\\n        }\\n        \\n        \\n        for(int j=1;j<=sqr.length() - i;j++){\\n            string t = sqr.substr(i,j);\\n            // cout << t << endl;\\n            int temp = stoi(t);\\n            // cout<< t << \" \" << sum << endl;\\n            \\n            bool flag = helper(sqr, n , sum+temp,i+j );\\n            if(flag){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        for(int i=1;i<=n;i++){\\n            int s = i*i;\\n            // cout << s << \" \" << i<< endl;\\n            string sqr = to_string(s);\\n            bool flag = helper(sqr, i,0,0);\\n            if(flag){\\n                ans+=s;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3547997,
                "title": "simple-and-clean-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool helper(string s, int i, int sum, int target){\\n        if(i == s.size()){\\n            if(sum == target) return true;\\n            else return false;\\n        }\\n        int k = 0 ;\\n        while(i < s.size()){\\n            k *= 10 ;\\n            k += s[i]-\\'0\\';\\n            i++;\\n            if(sum + k <= target && helper(s,i,sum+k,target)) return true;\\n        }\\n        return false;\\n    }\\n\\n    int punishmentNumber(int n) {\\n        int ans = 1 ;\\n        for(int i = 2 ; i <= n ; i++){\\n            int sqnum = i*i ;\\n            string s = to_string(sqnum);\\n            if(helper(s,0,0,i))ans += sqnum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool helper(string s, int i, int sum, int target){\\n        if(i == s.size()){\\n            if(sum == target) return true;\\n            else return false;\\n        }\\n        int k = 0 ;\\n        while(i < s.size()){\\n            k *= 10 ;\\n            k += s[i]-\\'0\\';\\n            i++;\\n            if(sum + k <= target && helper(s,i,sum+k,target)) return true;\\n        }\\n        return false;\\n    }\\n\\n    int punishmentNumber(int n) {\\n        int ans = 1 ;\\n        for(int i = 2 ; i <= n ; i++){\\n            int sqnum = i*i ;\\n            string s = to_string(sqnum);\\n            if(helper(s,0,0,i))ans += sqnum;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547553,
                "title": "javascript-2698-find-the-punishment-number-of-an-integer",
                "content": "---\\n\\nWeekly Contest 346 solutions:\\n- Q1 - https://leetcode.com/problems/minimum-string-length-after-removing-substrings/solutions/3547566/javascript-2696-minimum-string-length-after-removing-substrings/\\n- Q2 - https://leetcode.com/problems/lexicographically-smallest-palindrome/solutions/3547563/javascript-2697-lexicographically-smallest-palindrome/\\n- Q3 - https://leetcode.com/problems/find-the-punishment-number-of-an-integer/solutions/3547553/javascript-2698-find-the-punishment-number-of-an-integer/\\n\\n---\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ndfs\\ncalc for all numbers till 1000 only once ( for all tests cases )\\n1st submission pass\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nlet set\\n\\nconst punishmentNumber = function (n) {\\n\\n  function generateNumSeq () {\\n\\n    function isNum (s, i) {\\n      let yes = 0\\n      function dfs (start, sum) {\\n        if (yes) return\\n        if (start === s.length) {\\n          if (sum === +i) yes = 1\\n          return\\n        }\\n        for (let i = start + 1; i <= s.length; i++) {\\n          dfs(i, sum + +s.slice(start, i))\\n        }\\n      }\\n      dfs(0, 0)\\n      return yes\\n    }\\n\\n    set = new Set()\\n    for (let i = 1; i <= 1000; i++) {\\n      if (isNum(\\'\\' + i * i, i)) {\\n        set.add(i)\\n      }\\n    }\\n  }\\n\\n  if (!set) {\\n    generateNumSeq()\\n  }\\n\\n  let s = 0\\n  for (let i = 1; i <= n; i++) {\\n    if (set.has(i)) {\\n      s += i * i\\n    }\\n  }\\n  return s\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet set\\n\\nconst punishmentNumber = function (n) {\\n\\n  function generateNumSeq () {\\n\\n    function isNum (s, i) {\\n      let yes = 0\\n      function dfs (start, sum) {\\n        if (yes) return\\n        if (start === s.length) {\\n          if (sum === +i) yes = 1\\n          return\\n        }\\n        for (let i = start + 1; i <= s.length; i++) {\\n          dfs(i, sum + +s.slice(start, i))\\n        }\\n      }\\n      dfs(0, 0)\\n      return yes\\n    }\\n\\n    set = new Set()\\n    for (let i = 1; i <= 1000; i++) {\\n      if (isNum(\\'\\' + i * i, i)) {\\n        set.add(i)\\n      }\\n    }\\n  }\\n\\n  if (!set) {\\n    generateNumSeq()\\n  }\\n\\n  let s = 0\\n  for (let i = 1; i <= n; i++) {\\n    if (set.has(i)) {\\n      s += i * i\\n    }\\n  }\\n  return s\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3547510,
                "title": "simple-java-using-bit-to-find-all-possible-combination-of-number",
                "content": "# Intuition\\nFind all the possible substring and add them\\n\\n# Approach\\nUsed bitwise to find the substring or partitions. let l = length of number\\nthen for any set bit partition the number for that position e.g 36 * 36 = 1296\\n000 -> 1296\\n001 -> 129 | 6\\n010 -> 12 | 96\\n011 -> 12 | 9 | 6\\n100 -> 1 | 296\\n101 -> 1 | 29 | 6\\n110 -> 1 | 2 | 96\\n111 -> 1 | 2 | 9 | 6\\n \\n\\n# Complexity\\n- Time complexity:\\nO(n * 2^n-1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int sum = 1;\\n        for(int i=2;i<=n;i++) {\\n            if(checkNumber(i)) {\\n                sum += (i*i);\\n            }\\n        }\\n        return sum;\\n    }\\n    \\n    private boolean checkNumber(int n) {\\n        int n1 = n*n;\\n        String ns = Integer.toString(n1);\\n        int l = ns.length();\\n        int bitLe = (int)Math.pow(2, l-1);\\n        for(int i=0;i<bitLe;i++) {\\n            List<Integer> k = new ArrayList<>();\\n            for (int j = 0; j < l; j++) {\\n                if ((i & (1 << j)) > 0) {\\n                    k.add(j);\\n                }\\n            }\\n            int sum = 0;\\n            int prev = 0;\\n            if(!k.isEmpty()) {\\n                for(int sub: k) {\\n                    sum += Integer.parseInt(ns.substring(prev, sub+1));\\n                    prev = sub+1;\\n                }\\n                sum += Integer.parseInt(ns.substring(prev, l));\\n            }\\n            if(sum == n) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int sum = 1;\\n        for(int i=2;i<=n;i++) {\\n            if(checkNumber(i)) {\\n                sum += (i*i);\\n            }\\n        }\\n        return sum;\\n    }\\n    \\n    private boolean checkNumber(int n) {\\n        int n1 = n*n;\\n        String ns = Integer.toString(n1);\\n        int l = ns.length();\\n        int bitLe = (int)Math.pow(2, l-1);\\n        for(int i=0;i<bitLe;i++) {\\n            List<Integer> k = new ArrayList<>();\\n            for (int j = 0; j < l; j++) {\\n                if ((i & (1 << j)) > 0) {\\n                    k.add(j);\\n                }\\n            }\\n            int sum = 0;\\n            int prev = 0;\\n            if(!k.isEmpty()) {\\n                for(int sub: k) {\\n                    sum += Integer.parseInt(ns.substring(prev, sub+1));\\n                    prev = sub+1;\\n                }\\n                sum += Integer.parseInt(ns.substring(prev, l));\\n            }\\n            if(sum == n) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547392,
                "title": "c-simple-recursion-without-strings-beats-100-time-complexity-derivation-in-comment",
                "content": "Pretty much same as the other solutions. But instead of using str.substr() , division and modulus operation are used.\\nString is split into left and right portions. Then it is checked recursively by subtracting right from number and exploring if left is a valid number.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool valid(int num,int target){\\n        if(target<=0) return false;\\n        if(num==target) return true;\\n        int b10 = 10;\\n        int left = num/b10;\\n        int right = num%b10;\\n        while(left>0){\\n            if(valid(left,target-right)) return true;\\n            b10*=10;\\n            left = num/b10;\\n            right = num%b10;\\n        }\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int sum = 0;\\n        for(int i=1;i<=n;i++){\\n            if(valid(i*i,i)) sum+=(i*i);\\n        }\\n        return sum;\\n    }\\n};\\n```\\n# Complexity\\n- Time Complexity : O(N ^ 1.602)\\nFor valid function ->\\nvalid(num) = valid(num/10) + valid(num/100) + valid(num/1000)\\nThis will go only 3 levels because largest number that can be passed is 10^6\\nSolving this will give:\\nvalid(num) = O(num^0.277)\\n[See the comment for more detailed explaination]\\nvalid(i*i) = O(i^0.554)\\nThis is done n times give us the total complexity as :\\nO(N^1.554).\\n\\n    However we can obtain a general solution even for larger number.\\n    valid(num) = valid(num/10)+valid(num/100)+valid(num/1000)+valid(num/10000)+....\\n    Solving this will give :\\n    valid(num) =  O(num^(Log10(2))) = O(num^0.301)\\n    valid(i*i) = O(i^0.602)\\n    This is done n times to give time complexity as :\\nO(N^1.602) approximately O(N^1.6)\\n- Space complexity : O(Log N)\\n    Recursive stack calls. For N^2, there will be Log10(N^2) calls",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(int num,int target){\\n        if(target<=0) return false;\\n        if(num==target) return true;\\n        int b10 = 10;\\n        int left = num/b10;\\n        int right = num%b10;\\n        while(left>0){\\n            if(valid(left,target-right)) return true;\\n            b10*=10;\\n            left = num/b10;\\n            right = num%b10;\\n        }\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int sum = 0;\\n        for(int i=1;i<=n;i++){\\n            if(valid(i*i,i)) sum+=(i*i);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547291,
                "title": "burst-balloons-alike-algorithm-o-n-mcm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. An alternative problem statement :- Given 2 numbers N and K. Is it possible to partition K such that the sum of all the partitions equals K ?\\n2. Example, N = 36, K = 1296. \\n>     Partition => 1 | 29 | 6 => 1 + 29 + 6 = 36\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. There are many ways to partition N. \\n2. Many ways = Dynamic Programming. Partitioning logic is very similar to the problems like Balloon bursting or merge stones.\\n3. There\\'s a fancy term for such algorithm known as MCM (Matrix Chain Multiplication). \\n\\n---\\n\\n\\n**Understanding MCM**\\nGiven N and K, we can create an array of digits of K. Let\\'s call if arr. (Example, for N = 36, K = 1296, arr = [1,2,9,6]).\\n```\\narr[i,j] = subarray of array that starts with i and ends at j.\\n```\\n1. We will define dp[i][j] = maximum sum by partitioning arr[i,j] such that it is less than N.\\n2. Example := dp[0][2] = 30. Because, arr[0,2] = {1,2,9} can be partitioned into {1} and {2,9} whose sum = 1 + 29 = 30 which is less than 36.\\n3. Example := dp[1][3] = 35. Because, arr[1,3] = {2,9,6} can be partitioned into {2,9} and {6} whose sum = 29 + 6 = 35 which is less than 36.\\n4. Special Case := If arr[i,j] <= N, we don\\'t need to partition. Example, dp[1][2] = 29 which is less than 36.\\n5. Now, taking into account the entire array, if dp[0][arr.length-1] = N, then we can say that we can partition the array (and hence the number k) such that the sum of partitions equals N.\\n6. In our case, we will iterate over all numbers from 1 to 1000 and check whether k = square of each number, can be partitioned such that the sum of all partitions equals N. We can then store all eligible numbers into a list and calculate punishment number of any number.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n1. Complexity of MCM => O(N^2), where N is size of the array. In our case, the array\\'s maximum size will be 10^6. \\n2. Complexity for actual question => Linear. Since, we have already found all eligible numbers, we just have to calculate punishment number which can be done in O(N).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1. For MCM, SC = O(N ^2).\\n2. For actual algorithm, SC = O(N). \\n\\n# Code\\n```\\nclass Solution {\\n    public int punishmentNumber(int b) {\\n/* Note that I\\'ve found these numbers by invoking part-A of this code */\\n        int[] arr = {1, 9, 10, 36, 45, 55, 82, 91, 99, 100, 235, 297, 369, 370, 379, 414, 657, 675, 703, 756, 792, 909, 918, 945, 964, 990, 991, 999, 1000};\\n        \\n        int ans = 0;\\n        int i = 0;\\n        while(i<arr.length && arr[i] <= b){\\n            ans += (int) Math.pow(arr[i] , 2);\\n            i++;\\n        }\\n        \\n        return ans;\\n\\n/* Part - A */\\n        // int n = 1;\\n        // ArrayList<Integer> getIt = new ArrayList<>();\\n        // while(n <= 1000){\\n        //     int[] digits = div((int) Math.pow(n,2));\\n        //     if(func(digits, n)){\\n        //         getIt.add(n);\\n        //     }\\n        //     n++;\\n        // }\\n    }\\n    \\n    public int[] div(int n){\\n        ArrayList<Integer> lis = new ArrayList<>();\\n        while(n>0){\\n            lis.add(n % 10);\\n            n /= 10;\\n        }\\n        Collections.reverse(lis);\\n        int[] ans = new int[lis.size()];\\n        for(int i=0; i<lis.size();i++){\\n            ans[i] = lis.get(i);\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean func(int[] arr, int n){\\n        int[][] dp = new int[n+1][n+1];\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i] <= n){\\n                dp[i][i] = arr[i];\\n            }\\n        }\\n\\n        for(int i=0;i<arr.length-1;i++){\\n            if((arr[i]*10 + arr[i+1]) <= n){\\n                dp[i][i+1] = arr[i]*10 + arr[i+1];\\n                continue;\\n            }\\n            if(arr[i] + arr[i+1] <= n){\\n                dp[i][i+1] = arr[i] + arr[i+1];\\n            }\\n        }\\n        \\n        int l = 3, mx = arr.length;\\n        while(l<=mx){\\n            int x = 0;\\n            while((x + l - 1) < mx){\\n                int y = x + l - 1;\\n                int dd = 0, mul = 10;\\n                for(int g=x;g<=y;g++){\\n                    dd = (dd * mul) + arr[g];\\n                }\\n                if(dd <= n){\\n                    dp[x][y] = dd;\\n                    x++; y++;\\n                    continue;\\n                }\\n                int k = x + 1;\\n                while(k<=y){\\n                    int sum = dp[x][k-1] + dp[k][y];\\n                    if(sum <= n)\\n                        dp[x][y] = Math.max(dp[x][y], sum);\\n                    k++;\\n                }\\n\\n                x++;\\n                y++;\\n            }\\n            l++;\\n        }\\n        \\n        return dp[0][mx-1] == n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\narr[i,j] = subarray of array that starts with i and ends at j.\\n```\n```\\nclass Solution {\\n    public int punishmentNumber(int b) {\\n/* Note that I\\'ve found these numbers by invoking part-A of this code */\\n        int[] arr = {1, 9, 10, 36, 45, 55, 82, 91, 99, 100, 235, 297, 369, 370, 379, 414, 657, 675, 703, 756, 792, 909, 918, 945, 964, 990, 991, 999, 1000};\\n        \\n        int ans = 0;\\n        int i = 0;\\n        while(i<arr.length && arr[i] <= b){\\n            ans += (int) Math.pow(arr[i] , 2);\\n            i++;\\n        }\\n        \\n        return ans;\\n\\n/* Part - A */\\n        // int n = 1;\\n        // ArrayList<Integer> getIt = new ArrayList<>();\\n        // while(n <= 1000){\\n        //     int[] digits = div((int) Math.pow(n,2));\\n        //     if(func(digits, n)){\\n        //         getIt.add(n);\\n        //     }\\n        //     n++;\\n        // }\\n    }\\n    \\n    public int[] div(int n){\\n        ArrayList<Integer> lis = new ArrayList<>();\\n        while(n>0){\\n            lis.add(n % 10);\\n            n /= 10;\\n        }\\n        Collections.reverse(lis);\\n        int[] ans = new int[lis.size()];\\n        for(int i=0; i<lis.size();i++){\\n            ans[i] = lis.get(i);\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean func(int[] arr, int n){\\n        int[][] dp = new int[n+1][n+1];\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i] <= n){\\n                dp[i][i] = arr[i];\\n            }\\n        }\\n\\n        for(int i=0;i<arr.length-1;i++){\\n            if((arr[i]*10 + arr[i+1]) <= n){\\n                dp[i][i+1] = arr[i]*10 + arr[i+1];\\n                continue;\\n            }\\n            if(arr[i] + arr[i+1] <= n){\\n                dp[i][i+1] = arr[i] + arr[i+1];\\n            }\\n        }\\n        \\n        int l = 3, mx = arr.length;\\n        while(l<=mx){\\n            int x = 0;\\n            while((x + l - 1) < mx){\\n                int y = x + l - 1;\\n                int dd = 0, mul = 10;\\n                for(int g=x;g<=y;g++){\\n                    dd = (dd * mul) + arr[g];\\n                }\\n                if(dd <= n){\\n                    dp[x][y] = dd;\\n                    x++; y++;\\n                    continue;\\n                }\\n                int k = x + 1;\\n                while(k<=y){\\n                    int sum = dp[x][k-1] + dp[k][y];\\n                    if(sum <= n)\\n                        dp[x][y] = Math.max(dp[x][y], sum);\\n                    k++;\\n                }\\n\\n                x++;\\n                y++;\\n            }\\n            l++;\\n        }\\n        \\n        return dp[0][mx-1] == n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547081,
                "title": "very-simple-and-easy-to-understand-solution-python",
                "content": "For each number between 1 to n ,check recursively if it can be partitioned or not ; if it can be partitioned the Add the square of that number to the sum ......\\n\\n# Code\\n```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n\\n        def can_partition(s,target) -> bool :\\n\\n            if len(s) == 0 and target == 0 :return True\\n            if target < 0 :return False\\n            ans = False \\n            for i in range(len(s)) :\\n                left_part = s[0:i+1]\\n                right_part = s[i+1:]\\n                if can_partition(right_part , target - int(left_part)):\\n                    ans = True\\n                    return ans\\n            return ans\\n            \\n        \\n        sum = 0\\n        for i in range(1,n+1) :\\n            square_n = i**2\\n            if can_partition(str(square_n),i):\\n                sum += square_n\\n        return sum\\n        \\n       \\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n\\n        def can_partition(s,target) -> bool :\\n\\n            if len(s) == 0 and target == 0 :return True\\n            if target < 0 :return False\\n            ans = False \\n            for i in range(len(s)) :\\n                left_part = s[0:i+1]\\n                right_part = s[i+1:]\\n                if can_partition(right_part , target - int(left_part)):\\n                    ans = True\\n                    return ans\\n            return ans\\n            \\n        \\n        sum = 0\\n        for i in range(1,n+1) :\\n            square_n = i**2\\n            if can_partition(str(square_n),i):\\n                sum += square_n\\n        return sum\\n        \\n       \\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546999,
                "title": "dp-is-slower-than-recursion-dp-state-reversal-working-leetcode",
                "content": "\\nThis works but \\n```\\nclass Solution {\\npublic:\\n    bool dp(int val1,string &s,int in){\\n        if(s.size()==in){return val1==0;}\\n        int cur=0;\\n        for(int i=in;i<s.size();i++){\\n            cur*=10;cur+=(s[i]-\\'0\\');\\n            if(val1-cur<0){return false;}\\n            if(dp(val1-cur,s,i+1)){return 1;}\\n        }\\n        return 0;\\n    }\\n\\n    int punishmentNumber(int n) {\\n        int c=0;\\n        for(int i=1;i<=n;i++){\\n            string sq=to_string(i*i);\\n            if(dp(i,sq,0)){c+=i*i;}\\n        }\\n        return c;\\n    }\\n};\\n```\\nThis does\\'nt!!!!\\n```\\nclass Solution {\\npublic:\\n    \\n    int dp(int val,string &s,int in,vector<vector<int>> &vec){\\n        if(s.size()==in){\\n            if(val==0){return 1;}\\n            return 0;}\\n        if(vec[val][in]!=-1){return vec[val][in];}\\n        string temp;\\n        for(int i=in;i<s.size();i++){\\n            temp.push_back(s[i]);\\n            int x=val-stoi(temp);\\n            if(x<0){continue;}\\n            if(dp(x,s,i+1,vec)){return vec[val][in]=1;}\\n        }\\n        return vec[val][in]=0;\\n    }\\n    int punishmentNumber(int n) {\\n        int c=0;\\n        for(int i=1;i<=n;i++){\\n            \\n            string sq=to_string(i*i);\\n            vector<vector<int>> vec(i+1,vector<int>(sq.size(),-1));\\n            if(dp(i,sq,0,vec)){\\n                c+=i*i;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```\\nIn the first solution where i used dynamic programming , if i simply reverse the states of memoization the solution unexpectedly works, i have no idea how this works and what logic is underneath it.\\n```\\n\\nclass Solution {\\n\\n    int dp(int val,string &s,int in,vector<vector<int>> &vec){\\n        if(s.size()==in){return val==0;}\\n        if(vec[in][val]!=-1){return vec[in][val];}\\n        int cur=0;\\n        for(int i=in;i<s.size();i++){\\n            cur*=10;cur+=(s[i]-\\'0\\');\\n            if(val-cur<0){return false;}\\n            if(dp(val-cur,s,i+1,vec)){return vec[in][val]=1;}\\n        }\\n        return vec[in][val]=0;\\n    }\\n\\n    int punishmentNumber(int n) {\\n        int c=0;\\n        for(int i=1;i<=n;i++){\\n            string sq=to_string(i*i);\\n            vector<vector<int>> vec(sq.size(),vector<int>(i+1,-1));\\n            if(dp(i,sq,0,vec)){c+=i*i;}\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dp(int val1,string &s,int in){\\n        if(s.size()==in){return val1==0;}\\n        int cur=0;\\n        for(int i=in;i<s.size();i++){\\n            cur*=10;cur+=(s[i]-\\'0\\');\\n            if(val1-cur<0){return false;}\\n            if(dp(val1-cur,s,i+1)){return 1;}\\n        }\\n        return 0;\\n    }\\n\\n    int punishmentNumber(int n) {\\n        int c=0;\\n        for(int i=1;i<=n;i++){\\n            string sq=to_string(i*i);\\n            if(dp(i,sq,0)){c+=i*i;}\\n        }\\n        return c;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int dp(int val,string &s,int in,vector<vector<int>> &vec){\\n        if(s.size()==in){\\n            if(val==0){return 1;}\\n            return 0;}\\n        if(vec[val][in]!=-1){return vec[val][in];}\\n        string temp;\\n        for(int i=in;i<s.size();i++){\\n            temp.push_back(s[i]);\\n            int x=val-stoi(temp);\\n            if(x<0){continue;}\\n            if(dp(x,s,i+1,vec)){return vec[val][in]=1;}\\n        }\\n        return vec[val][in]=0;\\n    }\\n    int punishmentNumber(int n) {\\n        int c=0;\\n        for(int i=1;i<=n;i++){\\n            \\n            string sq=to_string(i*i);\\n            vector<vector<int>> vec(i+1,vector<int>(sq.size(),-1));\\n            if(dp(i,sq,0,vec)){\\n                c+=i*i;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\n\\n    int dp(int val,string &s,int in,vector<vector<int>> &vec){\\n        if(s.size()==in){return val==0;}\\n        if(vec[in][val]!=-1){return vec[in][val];}\\n        int cur=0;\\n        for(int i=in;i<s.size();i++){\\n            cur*=10;cur+=(s[i]-\\'0\\');\\n            if(val-cur<0){return false;}\\n            if(dp(val-cur,s,i+1,vec)){return vec[in][val]=1;}\\n        }\\n        return vec[in][val]=0;\\n    }\\n\\n    int punishmentNumber(int n) {\\n        int c=0;\\n        for(int i=1;i<=n;i++){\\n            string sq=to_string(i*i);\\n            vector<vector<int>> vec(sq.size(),vector<int>(i+1,-1));\\n            if(dp(i,sq,0,vec)){c+=i*i;}\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546956,
                "title": "ez-c-solution-using-recursion-explained",
                "content": "**APPROACH :**\\n* This is the most naive approach .\\n* We are calcualting from 1 to N which number will satisfy the given condition.\\n* Generating all valid partition of current number^2.\\n* If any of the partition sum is equal to the current_number we add it to our final answer.\\n\\n**Time Complexity : O(N *  (2^M + M ) )\\nSpace Complexity : O(M * M )**\\nHere M being size of string . Since M can be max of 6 this solution is Accepted. Someone please verify if time complexity is correct.\\n\\n```\\nclass Solution {\\npublic:   \\n    void calc(int start,  string& s, vector<string>& tmp, vector<vector<string>>& ans){\\n          if (start == s.size()) {\\n            ans.push_back(tmp);\\n            return;\\n          }\\n          for (int i = 1; start + i <= s.size(); ++i) {\\n            tmp.push_back(s.substr(start, i));\\n            calc(start + i, s, tmp, ans);\\n            tmp.pop_back();\\n          }\\n    }\\n    bool check(int n){\\n        long square=n*n;\\n        string x=to_string(square);       \\n          vector<vector<string>> res;\\n         vector<string> tmp;\\n        calc(0, x, tmp, res);\\n        for(auto i:res){\\n            int s=0;\\n            for(auto j:i)\\n                s+=stoi(j);\\n            if(s==n) return true;\\n        }\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n       int res=0;       \\n        for(int i=1;i<=n;i++)\\n            if(check(i))\\n                res+=pow(i,2);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:   \\n    void calc(int start,  string& s, vector<string>& tmp, vector<vector<string>>& ans){\\n          if (start == s.size()) {\\n            ans.push_back(tmp);\\n            return;\\n          }\\n          for (int i = 1; start + i <= s.size(); ++i) {\\n            tmp.push_back(s.substr(start, i));\\n            calc(start + i, s, tmp, ans);\\n            tmp.pop_back();\\n          }\\n    }\\n    bool check(int n){\\n        long square=n*n;\\n        string x=to_string(square);       \\n          vector<vector<string>> res;\\n         vector<string> tmp;\\n        calc(0, x, tmp, res);\\n        for(auto i:res){\\n            int s=0;\\n            for(auto j:i)\\n                s+=stoi(j);\\n            if(s==n) return true;\\n        }\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n       int res=0;       \\n        for(int i=1;i<=n;i++)\\n            if(check(i))\\n                res+=pow(i,2);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546955,
                "title": "javascript-bfs",
                "content": "# Approach\\nFor example: 1296 -> 1 + 29 + 6\\nFor each additional digit, there are two options. We can find all possible partitions by BFS or DFS.\\n![11.png](https://assets.leetcode.com/users/images/3b7b51ab-1369-4330-8111-b8031d0d3501_1684642193.3786297.png)\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar punishmentNumber = function(n) {\\n    let res = 0;\\n    \\n    const isValid = function(arr, target) {\\n        let current = [{val: Number(arr[0]), last: Number(arr[0])}];\\n        for (let i = 1; i < arr.length; i++) {\\n            let next = [];\\n            for (let j = 0; j < current.length; j++) {\\n                let last1 = current[j].last * 10 + Number(arr[i]);\\n                let val1 = current[j].val + last1 - current[j].last;\\n                \\n                let last2 = Number(arr[i]);\\n                let val2 = current[j].val + last2;\\n                \\n                if (val1 <= target) next.push({val: val1, last: last1});\\n                if (val2 <= target) next.push({val: val2, last: last2});\\n            }\\n            current = next;\\n        }\\n        \\n        for (let item of current) {\\n            if (item.val === target) return true;\\n        }\\n        return false;\\n    };\\n    \\n    for (let i = 1; i <= n; i++) {\\n        const square = i * i;\\n        const arr = (square + \\'\\').split(\\'\\');\\n        if (isValid(arr, i)) res += square;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar punishmentNumber = function(n) {\\n    let res = 0;\\n    \\n    const isValid = function(arr, target) {\\n        let current = [{val: Number(arr[0]), last: Number(arr[0])}];\\n        for (let i = 1; i < arr.length; i++) {\\n            let next = [];\\n            for (let j = 0; j < current.length; j++) {\\n                let last1 = current[j].last * 10 + Number(arr[i]);\\n                let val1 = current[j].val + last1 - current[j].last;\\n                \\n                let last2 = Number(arr[i]);\\n                let val2 = current[j].val + last2;\\n                \\n                if (val1 <= target) next.push({val: val1, last: last1});\\n                if (val2 <= target) next.push({val: val2, last: last2});\\n            }\\n            current = next;\\n        }\\n        \\n        for (let item of current) {\\n            if (item.val === target) return true;\\n        }\\n        return false;\\n    };\\n    \\n    for (let i = 1; i <= n; i++) {\\n        const square = i * i;\\n        const arr = (square + \\'\\').split(\\'\\');\\n        if (isValid(arr, i)) res += square;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3546920,
                "title": "video-explanation-brute-force-with-proof",
                "content": "# Explanation \\n\\nhttps://youtu.be/ZzaHqP-ZXuQ\\n\\n[Click here if the preview above doesn\\'t works](https://youtu.be/ZzaHqP-ZXuQ)\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    int ToInteger (int l, int r, const string& s) {\\n        int result = 0;\\n        for (int j = l; j <= r; j ++) {\\n            result = (result * 10) + (s[j] - \\'0\\');\\n        }\\n        return result;\\n    }\\n    \\n    bool CanPartitionWithSum (int current_sum, int i, const string& s, const int target_sum) {\\n        int n = s.length();\\n        if (i == n) return (current_sum == target_sum);\\n        \\n        for (int till = i; till < n; till ++) {\\n            int val = ToInteger (i, till, s);\\n            \\n            if (CanPartitionWithSum(current_sum+val, till+1, s, target_sum))\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool IsValid (int n) {\\n        int squared = n*n;\\n        string s = to_string(squared);\\n\\n        return CanPartitionWithSum (0, 0, s, n);\\n    }\\n    \\npublic:\\n    int punishmentNumber(int n) {\\n        int result = 0;\\n        for (int j = 1; j <= n; j ++) \\n            if (IsValid (j)) result += j*j;\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int ToInteger (int l, int r, const string& s) {\\n        int result = 0;\\n        for (int j = l; j <= r; j ++) {\\n            result = (result * 10) + (s[j] - \\'0\\');\\n        }\\n        return result;\\n    }\\n    \\n    bool CanPartitionWithSum (int current_sum, int i, const string& s, const int target_sum) {\\n        int n = s.length();\\n        if (i == n) return (current_sum == target_sum);\\n        \\n        for (int till = i; till < n; till ++) {\\n            int val = ToInteger (i, till, s);\\n            \\n            if (CanPartitionWithSum(current_sum+val, till+1, s, target_sum))\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool IsValid (int n) {\\n        int squared = n*n;\\n        string s = to_string(squared);\\n\\n        return CanPartitionWithSum (0, 0, s, n);\\n    }\\n    \\npublic:\\n    int punishmentNumber(int n) {\\n        int result = 0;\\n        for (int j = 1; j <= n; j ++) \\n            if (IsValid (j)) result += j*j;\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546907,
                "title": "bute-force-recursion",
                "content": "Just try to think of recurion in this question it is almost brute force...feel free to comment and ask your doubt\\n```\\nclass Solution {\\npublic:\\n    // this function is for extracting digits from n for recurison\\n    // you can use string too (noob me didnt think in contest and save time)\\n    void punish(int n, vector<int> &nums){\\n        n*=n;\\n        while(n){\\n            nums.push_back(n%10);\\n            n/=10;\\n        }\\n        \\n        reverse(nums.begin(),nums.end());\\n    }\\n    \\n    bool solve(int ind,int num, int target, vector<int> &nums){\\n        // base case ha apna ue\\n        if(ind >= nums.size()){\\n            // if we found the partion then return true, else false;\\n            if(num == target){\\n                return true;\\n            }\\n            \\n            return false;\\n        }\\n        \\n        int nummm = 0;\\n        // partion them in various partion\\n        for(int i = ind; i<nums.size(); i++){\\n            // this is the number forming at each partion\\n            // like 1296 is there then first it will break in\\n            // 1, 12, 129 like this\\n            // and in rest if we took partion 1 then from 2, 29 this is what recursion is doing\\n            nummm = nummm*10 + nums[i];\\n            \\n            // this is done to minmize unnecessary calls\\n            // otherwise may give TLE\\n            if(solve(i+1,num+nummm,target,nums)){\\n                return true;\\n            }\\n        }\\n        \\n        // if not found return false\\n        return false;\\n    }\\n    \\n    int punishmentNumber(int n) {\\n        int ans= 0; \\n        for(int i = 1; i<=n; i++){\\n            vector<int> nums;\\n            // to extract digts and use in recurison\\n            punish(i,nums);\\n            \\n            // add it in ans\\n            if(solve(0,0,i,nums))\\n                ans += i*i;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // this function is for extracting digits from n for recurison\\n    // you can use string too (noob me didnt think in contest and save time)\\n    void punish(int n, vector<int> &nums){\\n        n*=n;\\n        while(n){\\n            nums.push_back(n%10);\\n            n/=10;\\n        }\\n        \\n        reverse(nums.begin(),nums.end());\\n    }\\n    \\n    bool solve(int ind,int num, int target, vector<int> &nums){\\n        // base case ha apna ue\\n        if(ind >= nums.size()){\\n            // if we found the partion then return true, else false;\\n            if(num == target){\\n                return true;\\n            }\\n            \\n            return false;\\n        }\\n        \\n        int nummm = 0;\\n        // partion them in various partion\\n        for(int i = ind; i<nums.size(); i++){\\n            // this is the number forming at each partion\\n            // like 1296 is there then first it will break in\\n            // 1, 12, 129 like this\\n            // and in rest if we took partion 1 then from 2, 29 this is what recursion is doing\\n            nummm = nummm*10 + nums[i];\\n            \\n            // this is done to minmize unnecessary calls\\n            // otherwise may give TLE\\n            if(solve(i+1,num+nummm,target,nums)){\\n                return true;\\n            }\\n        }\\n        \\n        // if not found return false\\n        return false;\\n    }\\n    \\n    int punishmentNumber(int n) {\\n        int ans= 0; \\n        for(int i = 1; i<=n; i++){\\n            vector<int> nums;\\n            // to extract digts and use in recurison\\n            punish(i,nums);\\n            \\n            // add it in ans\\n            if(solve(0,0,i,nums))\\n                ans += i*i;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546875,
                "title": "easy-recursion-using-java-100-beats",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int res=0;\\n        for(int i=2;i<=n;i++){\\n            if(isPos(i,i*i,0,10)){\\n                res +=(i*i);\\n            }\\n            \\n        }\\n        return ++res;\\n    }\\n    \\n    public boolean isPos(int i, int val,int temp,int div){\\n        if((val+temp)==i)return true;\\n        if(val==0) return false;\\n        while(div<val){\\n            if(isPos(i,val/div,temp+(val%div),10)) return true;\\n            div *=10;\\n        }\\n        return false;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int res=0;\\n        for(int i=2;i<=n;i++){\\n            if(isPos(i,i*i,0,10)){\\n                res +=(i*i);\\n            }\\n            \\n        }\\n        return ++res;\\n    }\\n    \\n    public boolean isPos(int i, int val,int temp,int div){\\n        if((val+temp)==i)return true;\\n        if(val==0) return false;\\n        while(div<val){\\n            if(isPos(i,val/div,temp+(val%div),10)) return true;\\n            div *=10;\\n        }\\n        return false;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546797,
                "title": "recursion-cpp",
                "content": "<!-- Describe your first thoughts on how to solve this problem. -->\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(string str,int i,int tar){\\n        if(tar==0 and i==str.size())return true;\\n        \\n        for(int ind=i;ind<str.size();ind++){\\n            string s=str.substr(i,ind-i+1);\\n            int num=stoi(s);\\n            if(num<=tar){\\n                if(solve(str,ind+1,tar-num))return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            string str=to_string(i*i);\\n            if(solve(str,0,i)){\\n                cout<<i<<\" \";\\n                ans+=i*i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(string str,int i,int tar){\\n        if(tar==0 and i==str.size())return true;\\n        \\n        for(int ind=i;ind<str.size();ind++){\\n            string s=str.substr(i,ind-i+1);\\n            int num=stoi(s);\\n            if(num<=tar){\\n                if(solve(str,ind+1,tar-num))return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            string str=to_string(i*i);\\n            if(solve(str,0,i)){\\n                cout<<i<<\" \";\\n                ans+=i*i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3546793,
                "title": "c-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNaively check all numbers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate from 1 to the given n.\\nFor each number, check it can be partitioned then summed to itself.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nNoted that $$n <= 1000$$, the length of the corresponding string is at most 7, therefore the time complexity of recursion on it is $$O(1)$$.\\n\\nSince we iterate all numbers smaller or equal to $$n$$, total complexity is $$O(n)$$.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNo extra space used, $$O(1)$$.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        int ret = 0;\\n        for(int i = 1; i <= n; ++i){\\n            if(check(i)) ret += (i * i);\\n        }\\n        return ret;\\n    }\\n    \\n    bool check(int i){\\n        int target = i * i;\\n        string str = to_string(target);\\n        return dfs(str, 0, i);\\n    }\\n    \\n    bool dfs(const string& str, int start, int val){\\n        // whether the given str[start:] can be partitioned and sum to val?\\n        if(start == str.length()) return val == 0;\\n        \\n        for(int l = 1; start + l <= str.length(); ++l){\\n            int num = stoi(str.substr(start, l));\\n            if(num > val) break;\\n            if(dfs(str, start + l, val - num)) return true;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        int ret = 0;\\n        for(int i = 1; i <= n; ++i){\\n            if(check(i)) ret += (i * i);\\n        }\\n        return ret;\\n    }\\n    \\n    bool check(int i){\\n        int target = i * i;\\n        string str = to_string(target);\\n        return dfs(str, 0, i);\\n    }\\n    \\n    bool dfs(const string& str, int start, int val){\\n        // whether the given str[start:] can be partitioned and sum to val?\\n        if(start == str.length()) return val == 0;\\n        \\n        for(int l = 1; start + l <= str.length(); ++l){\\n            int num = stoi(str.substr(start, l));\\n            if(num > val) break;\\n            if(dfs(str, start + l, val - num)) return true;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546769,
                "title": "simple-python-solution",
                "content": "\\n```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        def partition_string(s):\\n            if len(s) == 0:\\n                return [[]]\\n            partitions = []\\n            for i in range(1, len(s) + 1):\\n                prefix, suffix = s[:i], s[i:]\\n                suffix_partitions = partition_string(suffix)\\n                for p in suffix_partitions:\\n                    partitions.append([prefix] + p)\\n\\n            return partitions\\n    \\n        valid = []\\n        for i in range(1, n+1):\\n            x = i * i\\n            ps = partition_string(str(x))\\n            for p in ps:\\n                if sum(int(s) for s in p) == i:\\n                    valid.append(i)\\n                    break\\n        return sum(x**2 for x in valid)             \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        def partition_string(s):\\n            if len(s) == 0:\\n                return [[]]\\n            partitions = []\\n            for i in range(1, len(s) + 1):\\n                prefix, suffix = s[:i], s[i:]\\n                suffix_partitions = partition_string(suffix)\\n                for p in suffix_partitions:\\n                    partitions.append([prefix] + p)\\n\\n            return partitions\\n    \\n        valid = []\\n        for i in range(1, n+1):\\n            x = i * i\\n            ps = partition_string(str(x))\\n            for p in ps:\\n                if sum(int(s) for s in p) == i:\\n                    valid.append(i)\\n                    break\\n        return sum(x**2 for x in valid)             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4099752,
                "title": "try-all-easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int punishmentNumber(int n) \\n    {\\n         //looping over the all number less equal to n\\n         int sum = 0;\\n         for(int i = 1 ; i <= n ; i++)\\n         {\\n             int idx = 0;\\n             long long int val = (i * i);\\n             string str = to_string(val);\\n             if(fun(i,idx,str) == true)\\n             {\\n                 sum = sum + (i*i);\\n                 \\n             }\\n         }    \\n         return sum;\\n    }\\n    bool fun(int val,int idx , string &str)\\n    {\\n        if(val == 0 and idx >= str.length()) return true;\\n\\n        if(val < 0)  return false;\\n        if(idx >= str.length()) return false;\\n        int num = 0;\\n\\n        while(idx < str.length())\\n        {\\n            num = (num * 10) + (str[idx] - \\'0\\');\\n            if(fun(val - num,idx+1,str) == true) return true;\\n            idx++;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int punishmentNumber(int n) \\n    {\\n         //looping over the all number less equal to n\\n         int sum = 0;\\n         for(int i = 1 ; i <= n ; i++)\\n         {\\n             int idx = 0;\\n             long long int val = (i * i);\\n             string str = to_string(val);\\n             if(fun(i,idx,str) == true)\\n             {\\n                 sum = sum + (i*i);\\n                 \\n             }\\n         }    \\n         return sum;\\n    }\\n    bool fun(int val,int idx , string &str)\\n    {\\n        if(val == 0 and idx >= str.length()) return true;\\n\\n        if(val < 0)  return false;\\n        if(idx >= str.length()) return false;\\n        int num = 0;\\n\\n        while(idx < str.length())\\n        {\\n            num = (num * 10) + (str[idx] - \\'0\\');\\n            if(fun(val - num,idx+1,str) == true) return true;\\n            idx++;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098646,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int punishmentNumber(int n) {\\n\\n    bool backtrack(String candidate, int target, int idx, List<int> cur) {\\n        if (idx == candidate.length) {\\n            final sum = cur.fold<int>(0, (a, b) => a + b);\\n            if (sum == target) {\\n                return true;\\n            }\\n            return false;\\n        }\\n\\n        for (int i = idx; i < candidate.length; i++) {\\n            final current = int.parse(candidate.substring(idx, i + 1));\\n            cur.add(current);\\n            if (backtrack(candidate, target, i + 1, cur)) {\\n                return true;\\n            }\\n            cur.removeLast();\\n        }\\n\\n        return false;\\n    }\\n\\n    var total = 0;\\n    var squared = 1;\\n    for (int i = 1; i <= n; i++) {\\n        squared = i * i;\\n        if (backtrack(squared.toString(), i, 0, [])) {\\n            total += squared;\\n        }\\n    }\\n\\n    return total;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int punishmentNumber(int n) {\\n\\n    bool backtrack(String candidate, int target, int idx, List<int> cur) {\\n        if (idx == candidate.length) {\\n            final sum = cur.fold<int>(0, (a, b) => a + b);\\n            if (sum == target) {\\n                return true;\\n            }\\n            return false;\\n        }\\n\\n        for (int i = idx; i < candidate.length; i++) {\\n            final current = int.parse(candidate.substring(idx, i + 1));\\n            cur.add(current);\\n            if (backtrack(candidate, target, i + 1, cur)) {\\n                return true;\\n            }\\n            cur.removeLast();\\n        }\\n\\n        return false;\\n    }\\n\\n    var total = 0;\\n    var squared = 1;\\n    for (int i = 1; i <= n; i++) {\\n        squared = i * i;\\n        if (backtrack(squared.toString(), i, 0, [])) {\\n            total += squared;\\n        }\\n    }\\n\\n    return total;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091970,
                "title": "code-explained-with-help-of-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Recursive function to find a combination of squares that adds up to \\'n\\'\\n    bool solve(int ind, string &sqr, int n, vector<vector<int>>& dp) {\\n        // Base case: If we\\'ve reached the end of the string, check if \\'n\\' is 0\\n        if (ind == sqr.size())\\n            return n == 0;\\n        \\n        // Check if this subproblem has already been solved\\n        if (dp[ind][n] != -1)\\n            return dp[ind][n];\\n        \\n        // Iterate through substrings starting from \\'ind\\'\\n        for (int i = ind; i < sqr.size(); i++) {\\n            string curr = string(sqr.begin() + ind, sqr.begin() + i + 1);\\n            int currno = stoi(curr);\\n            \\n            // If the current number is less than or equal to \\'n\\', try using it\\n            if (currno <= n) {\\n                if (solve(i + 1, sqr, n - currno, dp))\\n                    return dp[ind][n] = true;\\n            } else {\\n                // If the current number is greater than \\'n\\', break the loop\\n                break;\\n            }\\n        }\\n        \\n        // If no valid combination is found, set dp[ind][n] to false\\n        return dp[ind][n] = false;\\n    }\\n    \\n    // Function to set up memoization and call \\'solve\\'\\n    int memo(int temp, int n) {\\n        string sqr = to_string(temp);\\n        vector<vector<int>> dp(sqr.size(), vector<int>(n + 1, -1));\\n        return solve(0, sqr, n, dp);\\n    }\\n    \\n    // Main function to calculate the sum of squares with valid combinations\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        // Iterate through integers from 1 to \\'n\\'\\n        for (int i = 1; i <= n; i++) {\\n            int temp = i * i; // Calculate the square of \\'i\\'\\n            \\n            // Check if there exists a valid combination for \\'i\\' using \\'memo\\' function\\n            if (memo(temp, i)) {\\n                ans += temp; // Add the square to the result\\n            }\\n        }\\n        return ans; // Return the total sum of valid squares\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Recursive function to find a combination of squares that adds up to \\'n\\'\\n    bool solve(int ind, string &sqr, int n, vector<vector<int>>& dp) {\\n        // Base case: If we\\'ve reached the end of the string, check if \\'n\\' is 0\\n        if (ind == sqr.size())\\n            return n == 0;\\n        \\n        // Check if this subproblem has already been solved\\n        if (dp[ind][n] != -1)\\n            return dp[ind][n];\\n        \\n        // Iterate through substrings starting from \\'ind\\'\\n        for (int i = ind; i < sqr.size(); i++) {\\n            string curr = string(sqr.begin() + ind, sqr.begin() + i + 1);\\n            int currno = stoi(curr);\\n            \\n            // If the current number is less than or equal to \\'n\\', try using it\\n            if (currno <= n) {\\n                if (solve(i + 1, sqr, n - currno, dp))\\n                    return dp[ind][n] = true;\\n            } else {\\n                // If the current number is greater than \\'n\\', break the loop\\n                break;\\n            }\\n        }\\n        \\n        // If no valid combination is found, set dp[ind][n] to false\\n        return dp[ind][n] = false;\\n    }\\n    \\n    // Function to set up memoization and call \\'solve\\'\\n    int memo(int temp, int n) {\\n        string sqr = to_string(temp);\\n        vector<vector<int>> dp(sqr.size(), vector<int>(n + 1, -1));\\n        return solve(0, sqr, n, dp);\\n    }\\n    \\n    // Main function to calculate the sum of squares with valid combinations\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        // Iterate through integers from 1 to \\'n\\'\\n        for (int i = 1; i <= n; i++) {\\n            int temp = i * i; // Calculate the square of \\'i\\'\\n            \\n            // Check if there exists a valid combination for \\'i\\' using \\'memo\\' function\\n            if (memo(temp, i)) {\\n                ans += temp; // Add the square to the result\\n            }\\n        }\\n        return ans; // Return the total sum of valid squares\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084030,
                "title": "simple-recursion-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int sum=0;\\n        for(int i=1;i<=n;i++){\\n            if(check(i*i,i,1)){\\n                sum+=i*i;\\n            }\\n        }\\n        return sum;\\n    }\\n    private boolean check(int x,int sum,int i){\\n        if(sum<0) return false;\\n        if(sum==0&&x==0) return true;\\n        if(x==0) return false;\\n        \\n        return check(x/10,sum-((x%10)*i),1)||check(x/10,sum-x%10,1)||check(x/10,sum-((x%10)*i),i*10);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java []\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int sum=0;\\n        for(int i=1;i<=n;i++){\\n            if(check(i*i,i,1)){\\n                sum+=i*i;\\n            }\\n        }\\n        return sum;\\n    }\\n    private boolean check(int x,int sum,int i){\\n        if(sum<0) return false;\\n        if(sum==0&&x==0) return true;\\n        if(x==0) return false;\\n        \\n        return check(x/10,sum-((x%10)*i),1)||check(x/10,sum-x%10,1)||check(x/10,sum-((x%10)*i),i*10);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080639,
                "title": "easy-solution-with-c-find-the-punishment-number-of-an-integer",
                "content": "```\\n\\nint divNumber(int n)\\n{\\n     int div = 1;\\n    while (div <= n) div *= 10;\\n    return div / 10;\\n}\\n\\n\\n\\nint solve(int i, int n, int sum , int div)\\n{\\n    if (sum == n && i == 0)\\n        return 1;\\n    while(div)\\n    {\\n        int tmp = i / div;\\n        sum += tmp;\\n        i -= tmp * div;\\n        if (solve(i ,n , sum, div /10))\\n        {\\n            return 1;\\n        }\\n        i += tmp *div;\\n        sum -= tmp;\\n        div /= 10;\\n    }\\n    return 0;\\n}\\nint punishmentNumber(int n){\\n    int start = 1;\\n    int result = 0;\\n\\n    while (start <= n)\\n    {\\n        int sum  = 0; \\n        int j = start * start;\\n        int div  = divNumber(j);\\n        \\n        if ((solve(j, start, sum,div) == 1))\\n        {\\n            result += j;\\n        }\\n        start++;\\n    }\\n    return result  ;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nint divNumber(int n)\\n{\\n     int div = 1;\\n    while (div <= n) div *= 10;\\n    return div / 10;\\n}\\n\\n\\n\\nint solve(int i, int n, int sum , int div)\\n{\\n    if (sum == n && i == 0)\\n        return 1;\\n    while(div)\\n    {\\n        int tmp = i / div;\\n        sum += tmp;\\n        i -= tmp * div;\\n        if (solve(i ,n , sum, div /10))\\n        {\\n            return 1;\\n        }\\n        i += tmp *div;\\n        sum -= tmp;\\n        div /= 10;\\n    }\\n    return 0;\\n}\\nint punishmentNumber(int n){\\n    int start = 1;\\n    int result = 0;\\n\\n    while (start <= n)\\n    {\\n        int sum  = 0; \\n        int j = start * start;\\n        int div  = divNumber(j);\\n        \\n        if ((solve(j, start, sum,div) == 1))\\n        {\\n            result += j;\\n        }\\n        start++;\\n    }\\n    return result  ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4060632,
                "title": "python-solution-think-it-is-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        def can_partition_sum_to_target(s: str, target: int) -> bool:\\n            if not s and not target:\\n                return True\\n            for i in range(len(s)):\\n                subtrahend = int(s[:i + 1])\\n                if subtrahend > target:\\n                    return False\\n                if can_partition_sum_to_target(s[i + 1:], target - subtrahend):\\n                    return True\\n            return False\\n        return sum(i * i for i in range(1, n + 1) if can_partition_sum_to_target(str(i * i), i))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        def can_partition_sum_to_target(s: str, target: int) -> bool:\\n            if not s and not target:\\n                return True\\n            for i in range(len(s)):\\n                subtrahend = int(s[:i + 1])\\n                if subtrahend > target:\\n                    return False\\n                if can_partition_sum_to_target(s[i + 1:], target - subtrahend):\\n                    return True\\n            return False\\n        return sum(i * i for i in range(1, n + 1) if can_partition_sum_to_target(str(i * i), i))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014299,
                "title": "recursion-c-r",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int flag=0;\\n    void f(int i, string &s, int sum, int x)\\n    {\\n        if(i==s.size())\\n        {\\n            if(sum==x) flag=1;\\n            return;\\n        }\\n        for(int j=i; j<s.size(); j++)\\n        {\\n            string str=s.substr(i,j-i+1);\\n            f(j+1,s,sum+stoi(str),x);\\n        }\\n    }\\n    int punishmentNumber(int n) \\n    {\\n        int ans=0;\\n        for(int x=1; x<=n; x++)\\n        {\\n            flag=0;\\n            string sq=to_string(x*x);\\n            f(0,sq,0,x);\\n            if(flag) ans+=x*x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int flag=0;\\n    void f(int i, string &s, int sum, int x)\\n    {\\n        if(i==s.size())\\n        {\\n            if(sum==x) flag=1;\\n            return;\\n        }\\n        for(int j=i; j<s.size(); j++)\\n        {\\n            string str=s.substr(i,j-i+1);\\n            f(j+1,s,sum+stoi(str),x);\\n        }\\n    }\\n    int punishmentNumber(int n) \\n    {\\n        int ans=0;\\n        for(int x=1; x<=n; x++)\\n        {\\n            flag=0;\\n            string sq=to_string(x*x);\\n            f(0,sq,0,x);\\n            if(flag) ans+=x*x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976982,
                "title": "easy-steps-punishment-number-by-given-conditions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    boolean punishN(int ind, int n, int x, String s){\\n        if(ind == s.length()){\\n            if(x==n){\\n                return true;\\n            }\\n        }\\n        for(int j=ind; j<s.length(); j++){\\n            if(punishN(j+1, n, x+Integer.valueOf(s.substring(ind,j+1)), s)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public int punishmentNumber(int n) {\\n        int count=0;\\n        for(int i=1; i<=n; i++){\\n            if(punishN(0,i,0,Integer.toString(i*i))){\\n                count+=i*i;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    boolean punishN(int ind, int n, int x, String s){\\n        if(ind == s.length()){\\n            if(x==n){\\n                return true;\\n            }\\n        }\\n        for(int j=ind; j<s.length(); j++){\\n            if(punishN(j+1, n, x+Integer.valueOf(s.substring(ind,j+1)), s)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public int punishmentNumber(int n) {\\n        int count=0;\\n        for(int i=1; i<=n; i++){\\n            if(punishN(0,i,0,Integer.toString(i*i))){\\n                count+=i*i;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975869,
                "title": "rust-solution-using-dfs",
                "content": "\\n# Code\\n```\\nstruct Helper {\\n  result: bool,\\n  target: i32\\n}\\nimpl Helper {\\n  fn dfs(&mut self, arr:&Vec<i32>, ci:usize, now:i32) {\\n    let len = arr.len();\\n    if len == ci {\\n      if self.target == now {\\n        self.result = true;\\n      }\\n      return\\n    }\\n\\n    let mut temp = 0;\\n    for i in ci..len {\\n      temp *= 10;\\n      temp += arr[i];\\n      self.dfs(arr, i+1, now + temp);\\n    }\\n  }\\n}\\n\\nimpl Solution {\\n  pub fn punishment_number(n: i32) -> i32 {\\n    let mut result = 0;\\n    for i in 1..=n {\\n      let mut helper = Helper { result:false, target:i };\\n      let sv = i * i;\\n      let arr = sv.to_string().chars().map(|v| v.to_digit(10).unwrap() as i32).collect::<Vec<i32>>();\\n      helper.dfs(&arr, 0, 0);\\n      if helper.result {\\n        result += sv;\\n      }\\n    }\\n    result\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nstruct Helper {\\n  result: bool,\\n  target: i32\\n}\\nimpl Helper {\\n  fn dfs(&mut self, arr:&Vec<i32>, ci:usize, now:i32) {\\n    let len = arr.len();\\n    if len == ci {\\n      if self.target == now {\\n        self.result = true;\\n      }\\n      return\\n    }\\n\\n    let mut temp = 0;\\n    for i in ci..len {\\n      temp *= 10;\\n      temp += arr[i];\\n      self.dfs(arr, i+1, now + temp);\\n    }\\n  }\\n}\\n\\nimpl Solution {\\n  pub fn punishment_number(n: i32) -> i32 {\\n    let mut result = 0;\\n    for i in 1..=n {\\n      let mut helper = Helper { result:false, target:i };\\n      let sv = i * i;\\n      let arr = sv.to_string().chars().map(|v| v.to_digit(10).unwrap() as i32).collect::<Vec<i32>>();\\n      helper.dfs(&arr, 0, 0);\\n      if helper.result {\\n        result += sv;\\n      }\\n    }\\n    result\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3915936,
                "title": "java-100",
                "content": "# Approach\\nThere are are only a few numbers that satisfy the property. Store them in an array and sum their squares if they are less than or equal to n.\\n\\n# Complexity\\n- Time complexity: O(1)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public int punishmentNumber(int n)\\n    {\\n        int [] x = {1, 9, 10, 36, 45, 55, 82, 91, 99, 100, 235, 297,\\n                    369, 370, 379, 414, 657, 675, 703, 756, 792, 909,\\n                    918, 945, 964, 990, 991, 999, 1000};\\n\\n        int s = 0;\\n\\n        for(int i=0; i<x.length && x[i]<=n; i++)\\n            s += x[i]*x[i];\\n\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int punishmentNumber(int n)\\n    {\\n        int [] x = {1, 9, 10, 36, 45, 55, 82, 91, 99, 100, 235, 297,\\n                    369, 370, 379, 414, 657, 675, 703, 756, 792, 909,\\n                    918, 945, 964, 990, 991, 999, 1000};\\n\\n        int s = 0;\\n\\n        for(int i=0; i<x.length && x[i]<=n; i++)\\n            s += x[i]*x[i];\\n\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902098,
                "title": "easy-and-intuitive",
                "content": "# Code\\n```\\nclass Solution {\\n    private int partition(int digits, String no, int n){\\n        if(digits==1||Integer.valueOf(no)==n)return Integer.valueOf(no);\\n        for(int j=1; j<digits; j++)if(Integer.valueOf(no.substring(0,j))+partition(digits-j,no.substring(j),n-Integer.valueOf(no.substring(0,j)))==n)return n;\\n        return 0;\\n    }\\n    private boolean isPartitionPossible(int n){\\n        if(n==1||n==9) return true;\\n        if(n<9) return false;\\n        int sq=n*n, i=sq, digits=0;\\n        String no=Integer.toString(sq);\\n        while(i>0){i/=10;digits++;} //Count Digits\\n        if(partition(digits,no,n)==n)return true;\\n        return false;\\n    }\\n    public int punishmentNumber(int n) {\\n        if(n==0) return 0;\\n        if(isPartitionPossible(n)) return n*n+punishmentNumber(n-1);\\n        else return punishmentNumber(n-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    private int partition(int digits, String no, int n){\\n        if(digits==1||Integer.valueOf(no)==n)return Integer.valueOf(no);\\n        for(int j=1; j<digits; j++)if(Integer.valueOf(no.substring(0,j))+partition(digits-j,no.substring(j),n-Integer.valueOf(no.substring(0,j)))==n)return n;\\n        return 0;\\n    }\\n    private boolean isPartitionPossible(int n){\\n        if(n==1||n==9) return true;\\n        if(n<9) return false;\\n        int sq=n*n, i=sq, digits=0;\\n        String no=Integer.toString(sq);\\n        while(i>0){i/=10;digits++;} //Count Digits\\n        if(partition(digits,no,n)==n)return true;\\n        return false;\\n    }\\n    public int punishmentNumber(int n) {\\n        if(n==0) return 0;\\n        if(isPartitionPossible(n)) return n*n+punishmentNumber(n-1);\\n        else return punishmentNumber(n-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866794,
                "title": "easy-memoized-version",
                "content": "# Note\\nwe can use \\n```\\n  const solved = \\n  {\\n    \"till\": 35,\\n    \"list\": [[1, 1], [9, 82], [10, 182]]\\n  }\\n```\\nto start with but in just one run we can get the complete dictionary. if we utilize that the runtime is rduced massively.\\nAnd the complete also is printed as well.\\n\\n# Code\\n```\\n  const solved = \\n  // {\\n  //   \"till\": 35,\\n  //   \"list\": [[1, 1], [9, 82], [10, 182]]\\n  // }\\n  // in just one run we can find the complete list and paste it here to utilize (and why not!)\\n  {\\n  till: 1000,\\n  list: [\\n    [ 1, 1 ],           [ 9, 82 ],\\n    [ 10, 182 ],        [ 36, 1478 ],\\n    [ 45, 3503 ],       [ 55, 6528 ],\\n    [ 82, 13252 ],      [ 91, 21533 ],\\n    [ 99, 31334 ],      [ 100, 41334 ],\\n    [ 235, 96559 ],     [ 297, 184768 ],\\n    [ 369, 320929 ],    [ 370, 457829 ],\\n    [ 379, 601470 ],    [ 414, 772866 ],\\n    [ 657, 1204515 ],   [ 675, 1660140 ],\\n    [ 703, 2154349 ],   [ 756, 2725885 ],\\n    [ 792, 3353149 ],   [ 909, 4179430 ],\\n    [ 918, 5022154 ],   [ 945, 5915179 ],\\n    [ 964, 6844475 ],   [ 990, 7824575 ],\\n    [ 991, 8806656 ],   [ 999, 9804657 ],\\n    [ 1000, 10804657 ]\\n  ]\\n}\\nfunction punishmentNumber(n: number): number {\\n\\n  if (n <= solved[\"till\"]) {\\n    let i = (solved[\"list\"].length) - 1\\n    for (; i > -1; i--) {\\n      if (n >= solved[\"list\"][i][0]) break;\\n    }\\n    return solved[\"list\"][i][1]\\n  }\\n  for (let i = solved[\"till\"] + 1; i <= n; i++) {\\n      solved[\"till\"] = i;\\n    if (check(i)) {\\n      solved[\"list\"].push([i, solved[\"list\"][(solved[\"list\"].length) - 1][1] + (i * i)])\\n    }\\n  }\\n  return solved[\"list\"][(solved[\"list\"].length) - 1][1];\\n\\n  function check(init) {\\n    let found = false\\n    checkSum(init * init, []);\\n    function checkSum(num, nums) {\\n      if (found) return;\\n      if (num === 0 && nums.reduce((a, b) => a + b, 0) === init) {\\n        found = true;\\n        return;\\n      }\\n      let rem = num;\\n      let divisor = 10;\\n      while (rem > 0) {\\n        rem = num;\\n        let temp = rem % divisor;\\n        rem = (rem - temp) / divisor\\n        nums.push(temp)\\n        checkSum(rem, nums)\\n        nums.pop()\\n        divisor *= 10\\n      }\\n    }\\n    return found;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Math",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\n  const solved = \\n  {\\n    \"till\": 35,\\n    \"list\": [[1, 1], [9, 82], [10, 182]]\\n  }\\n```\n```\\n  const solved = \\n  // {\\n  //   \"till\": 35,\\n  //   \"list\": [[1, 1], [9, 82], [10, 182]]\\n  // }\\n  // in just one run we can find the complete list and paste it here to utilize (and why not!)\\n  {\\n  till: 1000,\\n  list: [\\n    [ 1, 1 ],           [ 9, 82 ],\\n    [ 10, 182 ],        [ 36, 1478 ],\\n    [ 45, 3503 ],       [ 55, 6528 ],\\n    [ 82, 13252 ],      [ 91, 21533 ],\\n    [ 99, 31334 ],      [ 100, 41334 ],\\n    [ 235, 96559 ],     [ 297, 184768 ],\\n    [ 369, 320929 ],    [ 370, 457829 ],\\n    [ 379, 601470 ],    [ 414, 772866 ],\\n    [ 657, 1204515 ],   [ 675, 1660140 ],\\n    [ 703, 2154349 ],   [ 756, 2725885 ],\\n    [ 792, 3353149 ],   [ 909, 4179430 ],\\n    [ 918, 5022154 ],   [ 945, 5915179 ],\\n    [ 964, 6844475 ],   [ 990, 7824575 ],\\n    [ 991, 8806656 ],   [ 999, 9804657 ],\\n    [ 1000, 10804657 ]\\n  ]\\n}\\nfunction punishmentNumber(n: number): number {\\n\\n  if (n <= solved[\"till\"]) {\\n    let i = (solved[\"list\"].length) - 1\\n    for (; i > -1; i--) {\\n      if (n >= solved[\"list\"][i][0]) break;\\n    }\\n    return solved[\"list\"][i][1]\\n  }\\n  for (let i = solved[\"till\"] + 1; i <= n; i++) {\\n      solved[\"till\"] = i;\\n    if (check(i)) {\\n      solved[\"list\"].push([i, solved[\"list\"][(solved[\"list\"].length) - 1][1] + (i * i)])\\n    }\\n  }\\n  return solved[\"list\"][(solved[\"list\"].length) - 1][1];\\n\\n  function check(init) {\\n    let found = false\\n    checkSum(init * init, []);\\n    function checkSum(num, nums) {\\n      if (found) return;\\n      if (num === 0 && nums.reduce((a, b) => a + b, 0) === init) {\\n        found = true;\\n        return;\\n      }\\n      let rem = num;\\n      let divisor = 10;\\n      while (rem > 0) {\\n        rem = num;\\n        let temp = rem % divisor;\\n        rem = (rem - temp) / divisor\\n        nums.push(temp)\\n        checkSum(rem, nums)\\n        nums.pop()\\n        divisor *= 10\\n      }\\n    }\\n    return found;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3850441,
                "title": "backtracking",
                "content": "```\\nclass Solution \\n{\\n    bool f(int i, int n)\\n    {\\n        if(!i and !n) return true;\\n        if(!i or n<=0) return false;\\n        for(int s{}, p{1}; i; p*=10)\\n        {\\n            s += p*(i%10);\\n            i/=10;\\n            if(f(i, n-s)) return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    int punishmentNumber(int n)\\n    {\\n        int out{};\\n        for(int i{1}; i<=n; ++i)\\n            if(f(i*i, i)) out += i*i;\\n        return out;\\n    }\\n};\\n```\\n||\\n```\\nint punishmentNumber(int n)\\n{\\n\\tint d[]{1,81,100,1296,2025,3025,6724,8281,9801,10000,55225,88209,136161,136900,143641,171396,431649,455625,494209,\\n\\t        571536,627264,826281,842724,893025,929296,980100,982081,998001,1000000};\\n\\treturn accumulate(begin(d), upper_bound(begin(d), end(d), n*n), 0);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    bool f(int i, int n)\\n    {\\n        if(!i and !n) return true;\\n        if(!i or n<=0) return false;\\n        for(int s{}, p{1}; i; p*=10)\\n        {\\n            s += p*(i%10);\\n            i/=10;\\n            if(f(i, n-s)) return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    int punishmentNumber(int n)\\n    {\\n        int out{};\\n        for(int i{1}; i<=n; ++i)\\n            if(f(i*i, i)) out += i*i;\\n        return out;\\n    }\\n};\\n```\n```\\nint punishmentNumber(int n)\\n{\\n\\tint d[]{1,81,100,1296,2025,3025,6724,8281,9801,10000,55225,88209,136161,136900,143641,171396,431649,455625,494209,\\n\\t        571536,627264,826281,842724,893025,929296,980100,982081,998001,1000000};\\n\\treturn accumulate(begin(d), upper_bound(begin(d), end(d), n*n), 0);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847532,
                "title": "easy-to-get-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int cnt=0;\\n        for(int i=1;i<=n;i++){\\n           if(check(i,0,Integer.toString(i*i))){\\n                cnt+=i*i;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n\\n    public boolean check(int num,int sum,String s){\\n       if(s.length()==0)return num==sum;\\n       \\n       for(int k=0;k<s.length();k++){\\n         int ans=Integer.parseInt(s.substring(0,k+1));\\n        if(check(num,ans+sum,s.substring(k+1)))return true;\\n       }\\n       return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int cnt=0;\\n        for(int i=1;i<=n;i++){\\n           if(check(i,0,Integer.toString(i*i))){\\n                cnt+=i*i;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n\\n    public boolean check(int num,int sum,String s){\\n       if(s.length()==0)return num==sum;\\n       \\n       for(int k=0;k<s.length();k++){\\n         int ans=Integer.parseInt(s.substring(0,k+1));\\n        if(check(num,ans+sum,s.substring(k+1)))return true;\\n       }\\n       return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830949,
                "title": "short-python-solution",
                "content": "# Approach\\nThe main part is disecting string and adding up.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        ans=0\\n\\n        def validate(s,ind,sm,n):\\n            if sm==n and len(s)==ind: return True\\n            elif ind==len(s): return False\\n            if sm>n: return False\\n            for i in range(ind+1,len(s)+1):\\n                if validate(s,i,sm+int(s[ind:i]),n): return True\\n            return False\\n\\n        for i in range(1,n+1):\\n            if validate(str(i*i), 0, 0, i): ans+=i*i\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        ans=0\\n\\n        def validate(s,ind,sm,n):\\n            if sm==n and len(s)==ind: return True\\n            elif ind==len(s): return False\\n            if sm>n: return False\\n            for i in range(ind+1,len(s)+1):\\n                if validate(s,i,sm+int(s[ind:i]),n): return True\\n            return False\\n\\n        for i in range(1,n+1):\\n            if validate(str(i*i), 0, 0, i): ans+=i*i\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797373,
                "title": "ek-number-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public static boolean isSum(String s , int num){\\n    if(s.length()==0 && num ==0){\\n      return true;\\n    }\\n    if(s.length()==0){\\n      return false;\\n    }\\n    if(s.length()==1 && Integer.parseInt(s)!=num){\\n      return false;\\n    }\\n    if(Integer.parseInt(s)==num){\\n      return true;\\n    }\\n    int lambai = s.length();\\n    boolean kattapa = false;\\n    for(int i =0;i<lambai-1;i++){\\n      kattapa =  isSum(s.substring(i+1), num - Integer.parseInt(s.substring(0,i+1)));\\n      if(kattapa){\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  public static int punishmentNumber(int n) {\\n    int sum =0;\\n    for(int i =1;i<=n;i++){\\n      if(isSum(String.valueOf(i*i),i)){\\n        sum+=i*i;\\n      }\\n    }\\n    return sum;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public static boolean isSum(String s , int num){\\n    if(s.length()==0 && num ==0){\\n      return true;\\n    }\\n    if(s.length()==0){\\n      return false;\\n    }\\n    if(s.length()==1 && Integer.parseInt(s)!=num){\\n      return false;\\n    }\\n    if(Integer.parseInt(s)==num){\\n      return true;\\n    }\\n    int lambai = s.length();\\n    boolean kattapa = false;\\n    for(int i =0;i<lambai-1;i++){\\n      kattapa =  isSum(s.substring(i+1), num - Integer.parseInt(s.substring(0,i+1)));\\n      if(kattapa){\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  public static int punishmentNumber(int n) {\\n    int sum =0;\\n    for(int i =1;i<=n;i++){\\n      if(isSum(String.valueOf(i*i),i)){\\n        sum+=i*i;\\n      }\\n    }\\n    return sum;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795360,
                "title": "easy-to-understand-c-basic-approach",
                "content": "# Approach\\nPartition Approach of Dynamic Programming\\n\\n# Complexity\\n- Time complexity:O(N*N)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int sum,int start,string str)\\n    {\\n            if(sum==0)\\n            {\\n                if(start>=str.length())\\n                {\\n                 return true;\\n                }\\n            }\\n            if(start>=str.length())\\n            {\\n                return false;\\n            }\\n            long long x=0;\\n            for(int i=start;i<str.length();i++)\\n            {\\n                x=x*10+(str[i]-\\'0\\');\\n                if(sum>=x)\\n                {\\n                    if(check(sum-x,i+1,str)==true)\\n                    {\\n                        return true;\\n                    }\\n                }\\n            }\\n            return false;\\n    }\\n    int punishmentNumber(int n)\\n    {\\n       long long sum=0;\\n       \\n       for(int i=1;i<=n;i++)\\n       {\\n           long long val=i*i;\\n           if(check(i,0,to_string(val))==true)\\n           {\\n               sum+=val;\\n           }\\n       }    \\n       return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int sum,int start,string str)\\n    {\\n            if(sum==0)\\n            {\\n                if(start>=str.length())\\n                {\\n                 return true;\\n                }\\n            }\\n            if(start>=str.length())\\n            {\\n                return false;\\n            }\\n            long long x=0;\\n            for(int i=start;i<str.length();i++)\\n            {\\n                x=x*10+(str[i]-\\'0\\');\\n                if(sum>=x)\\n                {\\n                    if(check(sum-x,i+1,str)==true)\\n                    {\\n                        return true;\\n                    }\\n                }\\n            }\\n            return false;\\n    }\\n    int punishmentNumber(int n)\\n    {\\n       long long sum=0;\\n       \\n       for(int i=1;i<=n;i++)\\n       {\\n           long long val=i*i;\\n           if(check(i,0,to_string(val))==true)\\n           {\\n               sum+=val;\\n           }\\n       }    \\n       return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781419,
                "title": "c-recursive-approach",
                "content": "# Code\\n```\\nbool check(int i,string str,int k)\\n{\\n    if(k < 0)\\n        return false;\\n    if(i == str.length())\\n    {\\n        if(k == 0)\\n            return true;\\n        return false;\\n    }\\n    for(int j=i;j<str.length();j++)\\n    {\\n        int a = stoi(str.substr(i,j-i+1));\\n        if(check(j+1,str,k-a))\\n            return true;\\n    }\\n    return false;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        int res = 0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            int temp = i * i;\\n            string str = to_string(temp);\\n            if(check(0,str,i))\\n                res += temp;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool check(int i,string str,int k)\\n{\\n    if(k < 0)\\n        return false;\\n    if(i == str.length())\\n    {\\n        if(k == 0)\\n            return true;\\n        return false;\\n    }\\n    for(int j=i;j<str.length();j++)\\n    {\\n        int a = stoi(str.substr(i,j-i+1));\\n        if(check(j+1,str,k-a))\\n            return true;\\n    }\\n    return false;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        int res = 0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            int temp = i * i;\\n            string str = to_string(temp);\\n            if(check(0,str,i))\\n                res += temp;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726577,
                "title": "c-solution-recursion",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(string &number,int i,int k,int sum){\\n        if(i==number.size()) return sum==k;\\n        \\n        int num = 0;\\n        for(int ind=i;ind<number.size();ind++){\\n            num = num*10+number[ind]-\\'0\\';\\n            if(isPossible(number,ind+1,k,sum+num)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n         int ans = 0;\\n         for(int i=1;i<=n;i++){\\n             string number = to_string(i*i);\\n             if(isPossible(number,0,i,0)){\\n                 ans += i*i;\\n             }\\n         }\\n         return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(string &number,int i,int k,int sum){\\n        if(i==number.size()) return sum==k;\\n        \\n        int num = 0;\\n        for(int ind=i;ind<number.size();ind++){\\n            num = num*10+number[ind]-\\'0\\';\\n            if(isPossible(number,ind+1,k,sum+num)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n         int ans = 0;\\n         for(int i=1;i<=n;i++){\\n             string number = to_string(i*i);\\n             if(isPossible(number,0,i,0)){\\n                 ans += i*i;\\n             }\\n         }\\n         return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712678,
                "title": "c-recursion-code",
                "content": "```\\nclass Solution {\\npublic:\\n   int dp[1001];\\n    bool canPartitionSubstring(string& input, int k, int index, int currentSum) {\\n        if (index >= input.length()) {\\n            return currentSum == k;\\n        }\\n    \\n        int num = 0;\\n        \\n        for (int i = index; i < input.length(); i++) {\\n            num = num * 10 + (input[i] - \\'0\\');\\n            \\n            if (canPartitionSubstring(input, k, i + 1, currentSum + num)) {\\n                return true;\\n            }\\n        }\\n    \\n        return false;\\n    }\\n\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        memset(dp,-1,sizeof(dp));\\n        for (int i = 1; i <= n; i++) {\\n            int sq = i * i;\\n            string v = to_string(sq);\\n            bool k = canPartitionSubstring(v, i, 0, 0);\\n            if(dp[i]!=-1)ans+=sq;\\n            else\\n            if (k) {\\n                ans += sq;\\n                dp[i]=0;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int dp[1001];\\n    bool canPartitionSubstring(string& input, int k, int index, int currentSum) {\\n        if (index >= input.length()) {\\n            return currentSum == k;\\n        }\\n    \\n        int num = 0;\\n        \\n        for (int i = index; i < input.length(); i++) {\\n            num = num * 10 + (input[i] - \\'0\\');\\n            \\n            if (canPartitionSubstring(input, k, i + 1, currentSum + num)) {\\n                return true;\\n            }\\n        }\\n    \\n        return false;\\n    }\\n\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        memset(dp,-1,sizeof(dp));\\n        for (int i = 1; i <= n; i++) {\\n            int sq = i * i;\\n            string v = to_string(sq);\\n            bool k = canPartitionSubstring(v, i, 0, 0);\\n            if(dp[i]!=-1)ans+=sq;\\n            else\\n            if (k) {\\n                ans += sq;\\n                dp[i]=0;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711079,
                "title": "c-simple-clean-and-short-code-backtracking",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    \\npublic:\\n    \\n    bool backtrack(string& s, int target, int currsum, int ind)\\n    {\\n        if(ind==s.size())\\n            return currsum==target;\\n        if(currsum>target)return false;\\n        for(int i=ind;i<s.size();i++)\\n        {\\n            int num = stoll(s.substr(ind,i-ind+1));\\n            if(backtrack(s,target,currsum+num,i+1))\\n                return true;\\n        }\\n        return false;\\n        \\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        for(int i = 1; i <= n; i++) \\n        {\\n            string v = to_string(i*i);\\n            if(backtrack(v,i,0,0))\\n                ans += i*i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    \\n    bool backtrack(string& s, int target, int currsum, int ind)\\n    {\\n        if(ind==s.size())\\n            return currsum==target;\\n        if(currsum>target)return false;\\n        for(int i=ind;i<s.size();i++)\\n        {\\n            int num = stoll(s.substr(ind,i-ind+1));\\n            if(backtrack(s,target,currsum+num,i+1))\\n                return true;\\n        }\\n        return false;\\n        \\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        for(int i = 1; i <= n; i++) \\n        {\\n            string v = to_string(i*i);\\n            if(backtrack(v,i,0,0))\\n                ans += i*i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710075,
                "title": "fastest-ever-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        // int arr[] = {1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000};\\n        int sum = 0;\\n        // int ans = n*n;\\n        // for(int i:arr)\\n        for(int i:{1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000}){\\n            if(i <= n) sum += i*i;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        // int arr[] = {1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000};\\n        int sum = 0;\\n        // int ans = n*n;\\n        // for(int i:arr)\\n        for(int i:{1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000}){\\n            if(i <= n) sum += i*i;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688874,
                "title": "simple-recursion",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool dfs(int idx, string s, int sum){   \\n        \\n        if(sum==0){\\n            if(idx==s.length())return true;\\n            else{\\n                string k = s.substr(idx);\\n                int n = stoi(k);\\n                if(n==0)return true;\\n                else return false;\\n            }\\n\\n        }\\n        if(idx>=s.length())return false;\\n        \\n\\n        for(int i=idx; i<s.length(); i++){\\n            string sub = s.substr(idx, i-idx+1);\\n            int num = stoi(sub);\\n            if(dfs(i+1, s, sum-num)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    int punishmentNumber(int n) {\\n        int ans =0;\\n        for(int i=1; i<=n; i++){\\n            int sq = i*i;\\n            string s = to_string(sq);\\n            if(dfs(0, s, i))ans+= sq;\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool dfs(int idx, string s, int sum){   \\n        \\n        if(sum==0){\\n            if(idx==s.length())return true;\\n            else{\\n                string k = s.substr(idx);\\n                int n = stoi(k);\\n                if(n==0)return true;\\n                else return false;\\n            }\\n\\n        }\\n        if(idx>=s.length())return false;\\n        \\n\\n        for(int i=idx; i<s.length(); i++){\\n            string sub = s.substr(idx, i-idx+1);\\n            int num = stoi(sub);\\n            if(dfs(i+1, s, sum-num)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    int punishmentNumber(int n) {\\n        int ans =0;\\n        for(int i=1; i<=n; i++){\\n            int sq = i*i;\\n            string s = to_string(sq);\\n            if(dfs(0, s, i))ans+= sq;\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682373,
                "title": "c-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  bool check(string s,int k,int sum,int p){\\n      if(sum> k) return 0;\\n      if(s.size()==p){\\n          if(k==sum){\\n              return true;\\n          } return false;\\n      }\\n      bool ans=false;\\n      int x=0;\\n      for(int i=p;i<s.size();i++){\\n          x=x*10+(s[i]-\\'0\\');\\n      ans=ans or check(s,k,sum+x,i+1);\\n      }\\n      return ans;\\n  }\\n    int punishmentNumber(int n) {\\n      int punishment = 0;\\n\\n    for (int i = 1; i <= n; i++) {\\n         if (check(to_string(i*i),i,0,0)) {\\n                punishment += (i*i);\\n            }\\n       }\\n    return punishment;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool check(string s,int k,int sum,int p){\\n      if(sum> k) return 0;\\n      if(s.size()==p){\\n          if(k==sum){\\n              return true;\\n          } return false;\\n      }\\n      bool ans=false;\\n      int x=0;\\n      for(int i=p;i<s.size();i++){\\n          x=x*10+(s[i]-\\'0\\');\\n      ans=ans or check(s,k,sum+x,i+1);\\n      }\\n      return ans;\\n  }\\n    int punishmentNumber(int n) {\\n      int punishment = 0;\\n\\n    for (int i = 1; i <= n; i++) {\\n         if (check(to_string(i*i),i,0,0)) {\\n                punishment += (i*i);\\n            }\\n       }\\n    return punishment;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667702,
                "title": "c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(string &x,int ind,int t){\\n        if(t<0) return false;\\n        if(ind==size(x)) return t==0;\\n        for(int i=ind;i<size(x);++i){\\n            string nx=x.substr(ind,i-ind+1);\\n            int v=stoi(nx);\\n            if(check(x,i+1,t-v))return true;\\n        }\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans=0;\\n        for(int i=1;i<=n;++i){\\n            int x=i*i;\\n            string s=to_string(x);\\n            if(check(s,0,i)) ans+=x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string &x,int ind,int t){\\n        if(t<0) return false;\\n        if(ind==size(x)) return t==0;\\n        for(int i=ind;i<size(x);++i){\\n            string nx=x.substr(ind,i-ind+1);\\n            int v=stoi(nx);\\n            if(check(x,i+1,t-v))return true;\\n        }\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans=0;\\n        for(int i=1;i<=n;++i){\\n            int x=i*i;\\n            string s=to_string(x);\\n            if(check(s,0,i)) ans+=x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661797,
                "title": "dp-memoization-approach-java-solution-clean-code",
                "content": "# Complexity\\nLet $max = 10^3$\\n- Time complexity: $O(max^2)$ for preprocessing then $O(1)$ for each $n$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(max)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    static int dp[][];\\n    static int ans[];\\n    static boolean helper(String num,int target,int idx){\\n        if(idx >= num.length()) return target == 0;\\n        if(target < 0) return false;\\n        if(dp[idx][target] != -1) return dp[idx][target] == 1 ? true : false; \\n        int sum = 0;\\n        for(int i = idx;i < num.length();i++){\\n            sum = sum * 10 + (num.charAt(i) - \\'0\\');\\n            if(helper(num,target - sum,i + 1)){\\n                dp[idx][target] = 1;\\n                return true;\\n            }\\n        }\\n        dp[idx][target] = 0;\\n        return false;\\n    }\\n    static{\\n        int N = (int)1e3;\\n        dp = new int[7][N + 1];\\n        ans = new int[N + 1];\\n        for(int i = 1;i <= N;i++){\\n            for(var a:dp) Arrays.fill(a,-1);\\n            boolean flag = helper(String.valueOf(i * i),i,0);\\n            ans[i] = ans[i - 1] + (flag ? i * i : 0);\\n        }\\n    }\\n    public int punishmentNumber(int n) {\\n        return ans[n];\\n    }\\n}\\n```\\n\\n# Upvote if you found it useful \\uD83D\\uDC4D\\uD83D\\uDC4D",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```java\\nclass Solution {\\n    static int dp[][];\\n    static int ans[];\\n    static boolean helper(String num,int target,int idx){\\n        if(idx >= num.length()) return target == 0;\\n        if(target < 0) return false;\\n        if(dp[idx][target] != -1) return dp[idx][target] == 1 ? true : false; \\n        int sum = 0;\\n        for(int i = idx;i < num.length();i++){\\n            sum = sum * 10 + (num.charAt(i) - \\'0\\');\\n            if(helper(num,target - sum,i + 1)){\\n                dp[idx][target] = 1;\\n                return true;\\n            }\\n        }\\n        dp[idx][target] = 0;\\n        return false;\\n    }\\n    static{\\n        int N = (int)1e3;\\n        dp = new int[7][N + 1];\\n        ans = new int[N + 1];\\n        for(int i = 1;i <= N;i++){\\n            for(var a:dp) Arrays.fill(a,-1);\\n            boolean flag = helper(String.valueOf(i * i),i,0);\\n            ans[i] = ans[i - 1] + (flag ? i * i : 0);\\n        }\\n    }\\n    public int punishmentNumber(int n) {\\n        return ans[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661564,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// class Solution {\\n//     private:\\n//     bool check(int index,string s,int square){\\n//          if(square==0 && index==s.size())return true;\\n\\n//          bool result=false;\\n\\n//          for(int j=index;j<s.size();j++){\\n//              int next=stoi(s.substr(index,j-index+1));\\n//              if(next>square)break;\\n//              result=check(j+1,s,square-next);\\n//              if(result) return true;\\n\\n//          }\\n//          return false;\\n//     }\\n// public:\\n//     int punishmentNumber(int n) {\\n//      int ans=0;\\n//      for(int i=1;i<=n;i++){\\n//          int square=i*i;\\n//          string s=to_string(square);\\n//          int index=0;\\n//          if(check(index,s,square))\\n//          ans+=square;\\n\\n//      }\\n//      return ans;\\n//     }\\n// };\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool canPartition(string s, int target)\\n    {\\n        if (s == \"\" && target == 0) return true;\\n        if (target < 0) return false;\\n        \\n        bool ans = false;\\n        //========================================================================\\n        for (int i = 0; i < s.size(); i++) //try all possible pivot points\\n        {\\n            string left = s.substr(0, i + 1); //keep the left part\\n            string right = s.substr(i + 1); //recurse for right  part\\n            int leftNum = stoi(left);\\n            \\n            bool isPossible = canPartition(right, target - leftNum);\\n            if (isPossible) { ans = true; break; }\\n        }\\n        //=============================================================================\\n        return ans;\\n    }\\n    int punishmentNumber(int n)\\n    {\\n        int sum = 0;\\n        for (int num  = 1; num <= n; num++)\\n        {\\n            int sqr = num * num;\\n            if (canPartition(to_string(sqr), num)) \\n            {\\n                sum += sqr;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// class Solution {\\n//     private:\\n//     bool check(int index,string s,int square){\\n//          if(square==0 && index==s.size())return true;\\n\\n//          bool result=false;\\n\\n//          for(int j=index;j<s.size();j++){\\n//              int next=stoi(s.substr(index,j-index+1));\\n//              if(next>square)break;\\n//              result=check(j+1,s,square-next);\\n//              if(result) return true;\\n\\n//          }\\n//          return false;\\n//     }\\n// public:\\n//     int punishmentNumber(int n) {\\n//      int ans=0;\\n//      for(int i=1;i<=n;i++){\\n//          int square=i*i;\\n//          string s=to_string(square);\\n//          int index=0;\\n//          if(check(index,s,square))\\n//          ans+=square;\\n\\n//      }\\n//      return ans;\\n//     }\\n// };\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool canPartition(string s, int target)\\n    {\\n        if (s == \"\" && target == 0) return true;\\n        if (target < 0) return false;\\n        \\n        bool ans = false;\\n        //========================================================================\\n        for (int i = 0; i < s.size(); i++) //try all possible pivot points\\n        {\\n            string left = s.substr(0, i + 1); //keep the left part\\n            string right = s.substr(i + 1); //recurse for right  part\\n            int leftNum = stoi(left);\\n            \\n            bool isPossible = canPartition(right, target - leftNum);\\n            if (isPossible) { ans = true; break; }\\n        }\\n        //=============================================================================\\n        return ans;\\n    }\\n    int punishmentNumber(int n)\\n    {\\n        int sum = 0;\\n        for (int num  = 1; num <= n; num++)\\n        {\\n            int sqr = num * num;\\n            if (canPartition(to_string(sqr), num)) \\n            {\\n                sum += sqr;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635336,
                "title": "python-backtracking",
                "content": "```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        def can_partition(nums, start, target):\\n            if start == len(nums) or target < 0:\\n                return target == 0\\n            for end in range(start + 1, len(nums) + 1):\\n                if can_partition(nums, end, target - int(nums[start:end])):\\n                    return True\\n            return False\\n        return sum(i * i for i in range(n + 1) if can_partition(str(i * i), 0, i))\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        def can_partition(nums, start, target):\\n            if start == len(nums) or target < 0:\\n                return target == 0\\n            for end in range(start + 1, len(nums) + 1):\\n                if can_partition(nums, end, target - int(nums[start:end])):\\n                    return True\\n            return False\\n        return sum(i * i for i in range(n + 1) if can_partition(str(i * i), 0, i))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632714,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(string str,int i,int tar){\\n        if(tar==0 and i==str.size())return true;\\n        \\n        for(int ind=i;ind<str.size();ind++){\\n            string s=str.substr(i,ind-i+1);\\n            int num=stoi(s);\\n            if(num<=tar){\\n                if(solve(str,ind+1,tar-num))return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            string str=to_string(i*i);\\n            if(solve(str,0,i)){\\n                cout<<i<<\" \";\\n                ans+=i*i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    bool solve(string str,int i,int tar){\\n        if(tar==0 and i==str.size())return true;\\n        \\n        for(int ind=i;ind<str.size();ind++){\\n            string s=str.substr(i,ind-i+1);\\n            int num=stoi(s);\\n            if(num<=tar){\\n                if(solve(str,ind+1,tar-num))return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3624205,
                "title": "simple-recursion-using-partition-of-numbers",
                "content": "# Intuition\\n// fx(1296) --> fx(129) + 6, fx(12) + 96 , fx(1) + 296, fx(0) + 1296;\\n// fx(129)--> fx(12) + 9, fx(1) + 29, fx(0) + 129;\\n// fx(12) --> fx(1) + 2, fx(0) + 12;\\n// fx(1) --> fx(0) + 1;\\n// fx(0)  --> 0;\\n\\n\\n# Approach\\nrecursion\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the given code can be analyzed as follows:\\n\\n1. The `punishmentNumber` function iterates from 1 to `n` in the `for` loop. This results in a time complexity of O(n).\\n\\n2. For each iteration of the `for` loop, the `fx` function is called recursively. The `fx` function has a while loop that runs until `p/i` becomes 0, and in each iteration, it divides `i` by 10. This while loop has a time complexity of O(log(p)).\\n\\n3. Since the `for` loop iterates from 1 to `n`, the total number of times the `fx` function is called is approximately equal to the sum of logarithms of numbers from 1 to `n`, which can be approximated as O(nlog(n)).\\n\\n4. Within each iteration of the `fx` function, the recursive call to `fx` is made, and the loop within it runs until `p/i` becomes 0. This inner loop has a time complexity of O(log(p/i)). The overall number of iterations of this inner loop can be approximated as O(log(p/i)), which is equal to O(log(n)).\\n\\nCombining the above points, the overall time complexity of the code is approximately O(n * log(n) * log(n)).\\n\\nRegarding space complexity, the code does not use any additional data structures that grow with the input size. It only uses a few integer variables, which have constant space requirements. Therefore, the space complexity of the code is O(1), constant space complexity.\\n\\nNote: The above analysis assumes that arithmetic operations such as division and addition take constant time, which is typically the case for integers in most programming languages.\\n\\n- Space complexity:\\nTherefore, the space complexity of the code is O(n) due to the recursive calls and the stack frames created for each call.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool fx(int p,int n,int ans){\\n\\n        if(p==0){\\n            if(ans==n){\\n                return true;\\n            }\\n            return false;\\n        }\\n\\n        int i = 10;\\n        while(1){\\n            int curr = p%i;\\n            bool a = fx(p/i,n,ans+curr);\\n            if(a){\\n                return true;\\n            }\\n            if(p/i==0){\\n                break;\\n            }\\n            i *= 10;\\n        }\\n\\n        return false;\\n\\n    }\\n\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        int cnt = 0;\\n        for(int i=1;i<=n;i++){\\n            if(fx(i*i,i,ans)){\\n                cnt += (i*i);\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool fx(int p,int n,int ans){\\n\\n        if(p==0){\\n            if(ans==n){\\n                return true;\\n            }\\n            return false;\\n        }\\n\\n        int i = 10;\\n        while(1){\\n            int curr = p%i;\\n            bool a = fx(p/i,n,ans+curr);\\n            if(a){\\n                return true;\\n            }\\n            if(p/i==0){\\n                break;\\n            }\\n            i *= 10;\\n        }\\n\\n        return false;\\n\\n    }\\n\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        int cnt = 0;\\n        for(int i=1;i<=n;i++){\\n            if(fx(i*i,i,ans)){\\n                cnt += (i*i);\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617276,
                "title": "simple-recursive-way-with-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int s=0;\\n        for(int i=1; i<=n; i++){\\n            if(possible(i*i, i))s+=i*i;\\n        }\\n        return s;\\n    }\\n    private boolean possible(int a, int b){\\n        if(a==b)return true;\\n        else if(b<0 || a<b)return false;\\n\\n        for(int x=10; x<=a; x*=10){\\n            if(possible(a/x, b-a%x))return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int s=0;\\n        for(int i=1; i<=n; i++){\\n            if(possible(i*i, i))s+=i*i;\\n        }\\n        return s;\\n    }\\n    private boolean possible(int a, int b){\\n        if(a==b)return true;\\n        else if(b<0 || a<b)return false;\\n\\n        for(int x=10; x<=a; x*=10){\\n            if(possible(a/x, b-a%x))return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613728,
                "title": "god-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tbool ans = false;\\n\\n\\tvoid solve(string prev, string s, int n,int sum) {\\n\\t\\tif (s.length() == 0) {\\n\\t\\t\\tif(prev.size()>0){sum+=stoi(prev);}\\n\\t\\t\\tif (sum==n) {\\n\\t\\t\\t\\tans = true;\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif (sum > n) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tprev += s[0];\\n\\t\\ts = s.substr(1);\\n\\n\\t\\tint k = stoi(prev);        \\n\\t\\tsolve(\"\", s, n,sum+k);\\n\\t\\tsolve(prev, s, n,sum);\\n\\n\\t\\t}\\n\\n\\t\\tint punishmentNumber(int n) {\\n\\t\\t\\tint sum = 0;\\n\\n\\t\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\t\\tstring s = to_string(i*i);            \\n\\t\\t\\t\\tans = false;\\n\\t\\t\\t\\tsolve(\"\", s, i,0);\\n\\t\\t\\t\\tif (ans) {\\n\\t\\t\\t\\t\\tsum += i*i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\t};\\n\\t\\t\\t\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tbool ans = false;\\n\\n\\tvoid solve(string prev, string s, int n,int sum) {\\n\\t\\tif (s.length() == 0) {\\n\\t\\t\\tif(prev.size()>0){sum+=stoi(prev);}\\n\\t\\t\\tif (sum==n) {\\n\\t\\t\\t\\tans = true;\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif (sum > n) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tprev += s[0];\\n\\t\\ts = s.substr(1);\\n\\n\\t\\tint k = stoi(prev);        \\n\\t\\tsolve(\"\", s, n,sum+k);\\n\\t\\tsolve(prev, s, n,sum);\\n\\n\\t\\t}\\n\\n\\t\\tint punishmentNumber(int n) {\\n\\t\\t\\tint sum = 0;\\n\\n\\t\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\t\\tstring s = to_string(i*i);            \\n\\t\\t\\t\\tans = false;\\n\\t\\t\\t\\tsolve(\"\", s, i,0);\\n\\t\\t\\t\\tif (ans) {\\n\\t\\t\\t\\t\\tsum += i*i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\t};\\n\\t\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605309,
                "title": "use-the-wrong-answer-to-add-your-next-condition",
                "content": "Use the Wrong Answer to add your next condition!\\n\\nclass Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        if (n<9) return 1;\\n        if (n==9) return 82; \\n        if (n<36) return 182;\\n        if (n<45) return 1478;\\n        if (n<55) return 3503;\\n        if (n<82) return 6528;\\n        if (n<91) return 13252;\\n        if (n<99) return 21533;\\n        if (n<100) return 31334; \\n        if (n<235) return 41334; \\n        if (n<297) return 96559; \\n        if (n<369) return 184768;\\n        if (n<370) return 320929;\\n        if (n<379) return 457829;\\n        if (n<414) return 601470;\\n        if (n<657) return 772866;\\n        if (n<675) return 1204515;\\n        if (n<703) return 1660140;\\n        if (n<756) return 2154349;\\n        if (n<792) return 2725885;\\n        if (n<909) return 3353149;\\n        if (n<918) return 4179430;\\n        if (n<945) return 5022154;\\n        if (n<964) return 5915179;\\n        if (n<990) return 6844475;\\n        if (n<991) return 7824575;\\n        if (n<999) return 8806656;\\n        if (n<1000) return 9804657;\\n        return 10804657;         \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        if (n<9) return 1;\\n        if (n==9) return 82; \\n        if (n<36) return 182;\\n        if (n<45) return 1478;\\n        if (n<55) return 3503;\\n        if (n<82) return 6528;\\n        if (n<91) return 13252;\\n        if (n<99) return 21533;\\n        if (n<100) return 31334; \\n        if (n<235) return 41334; \\n        if (n<297) return 96559; \\n        if (n<369) return 184768;\\n        if (n<370) return 320929;\\n        if (n<379) return 457829;\\n        if (n<414) return 601470;\\n        if (n<657) return 772866;\\n        if (n<675) return 1204515;\\n        if (n<703) return 1660140;\\n        if (n<756) return 2154349;\\n        if (n<792) return 2725885;\\n        if (n<909) return 3353149;\\n        if (n<918) return 4179430;\\n        if (n<945) return 5022154;\\n        if (n<964) return 5915179;\\n        if (n<990) return 6844475;\\n        if (n<991) return 7824575;\\n        if (n<999) return 8806656;\\n        if (n<1000) return 9804657;\\n        return 10804657;         \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3590301,
                "title": "simple-recursive-solution-easy-to-understand",
                "content": "\\n\\n# Approach\\nIn every turn we can take the current digit alone or with the already taken previous digits (e.g for 12 if the current number of which square is considered is 14 then we can take 1 or 12) if the number obtained is not greater than the required number of square is considered, otherwise we must take the digit alone(e.g for 12 if the current number of which square is considered is 10 we can consider only 1 not 12). \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int n,vector<int>&vec,int sum,int i,int no){\\n        if(i==vec.size()){\\n            if(sum==n)\\n                return true;\\n            return false;\\n        }\\n        bool res= false;\\n        int p= no*10+vec[i];\\n        if(p > n){\\n            res= res | check(n,vec,sum+vec[i],i+1,vec[i]);\\n        }\\n        else{\\n            res= res | (check(n,vec,sum-no+p,i+1,p) | check(n,vec,sum+vec[i],i+1,vec[i]));\\n        }\\n        return res;\\n    }\\n    int punishmentNumber(int n) {\\n        int sum=0;\\n        for(int i=1;i<=n;i++){\\n            int k= i*i;\\n            vector<int>vec;\\n            while(k!=0){\\n                vec.push_back(k%10);\\n                k/=10;\\n            }\\n            reverse(vec.begin(),vec.end());\\n            if(check(i,vec,0,0,0)){\\n                //cout<<i<<endl;\\n                sum+= i*i;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int n,vector<int>&vec,int sum,int i,int no){\\n        if(i==vec.size()){\\n            if(sum==n)\\n                return true;\\n            return false;\\n        }\\n        bool res= false;\\n        int p= no*10+vec[i];\\n        if(p > n){\\n            res= res | check(n,vec,sum+vec[i],i+1,vec[i]);\\n        }\\n        else{\\n            res= res | (check(n,vec,sum-no+p,i+1,p) | check(n,vec,sum+vec[i],i+1,vec[i]));\\n        }\\n        return res;\\n    }\\n    int punishmentNumber(int n) {\\n        int sum=0;\\n        for(int i=1;i<=n;i++){\\n            int k= i*i;\\n            vector<int>vec;\\n            while(k!=0){\\n                vec.push_back(k%10);\\n                k/=10;\\n            }\\n            reverse(vec.begin(),vec.end());\\n            if(check(i,vec,0,0,0)){\\n                //cout<<i<<endl;\\n                sum+= i*i;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3585431,
                "title": "c-punishment-number",
                "content": "https://leetcode.com/problems/find-the-punishment-number-of-an-integer/submissions/954375930/\\n\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3582034,
                "title": "try-all-partitions-without-use-of-string-library-recursion",
                "content": "# Intuition\\nWe need to check if it is possible to string-partition some square of a number to obtain the root. First thought is to try all possible partitions. But how? \\n\\n# Approach\\n$$i$$-th partition from the left will have some $$x_i$$ number of digits of initial number. My first submit was simply six for-loops for each $$x_i$$. But that is a terrible way to try all possible string-partitions. Recursion - is the best way. Suppose we have numbers 2500 and 50. We can try all possible suffixes (or prefixes): 0, 00, 500, 2500. And recursively dive to a subproblem. For prefix \\'0\\' subproblem is to string-partition \\'250\\' to obtain \\'50-0\\'.\\n\\n# Complexity\\n- Time complexity: O(number of string-partitions of a number)\\n\\n- Space complexity: O(log(n)) - depth of the recursion tree\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    /* can n be string-partition to obtain o? */\\n    bool is_good(int n, int o){ \\n        if(n==o)\\n            return true;\\n        for(int x{}, p{1}; n; p*=10){\\n            x += n%10*p;\\n            n /= 10;\\n            if(is_good(n, o-x))\\n                return true;\\n        }\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int s{};\\n        for(int i{1}, sq; i<=n; ++i){\\n            sq = i*i;\\n            s += is_good(sq, i)*sq;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /* can n be string-partition to obtain o? */\\n    bool is_good(int n, int o){ \\n        if(n==o)\\n            return true;\\n        for(int x{}, p{1}; n; p*=10){\\n            x += n%10*p;\\n            n /= 10;\\n            if(is_good(n, o-x))\\n                return true;\\n        }\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int s{};\\n        for(int i{1}, sq; i<=n; ++i){\\n            sq = i*i;\\n            s += is_good(sq, i)*sq;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578818,
                "title": "c-simple-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        int punishment = 0;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            bool flag=false;\\n            int square = i * i;\\n            string str = to_string(square);\\n            checkConditions(0,i,0,0,str,flag);\\n            if (flag) {\\n                punishment += square;\\n            }\\n        }\\n        \\n        return punishment;\\n    }\\n    void checkConditions(int index,int& val,int sum,int total, string &str, bool& flag){\\n        \\n        if(index==str.size() && (sum+total==val)){\\n             flag = true;\\n             return;\\n        }\\n        if(index>=str.size() || flag) return;\\n        int curr = int(str[index])-48;\\n        int temp = sum*10+curr;\\n        checkConditions(index+1,val,temp,total,str,flag);\\n        total+=sum;\\n        sum = curr;\\n        checkConditions(index+1,val,sum,total,str,flag);\\n    }\\n    \\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        int punishment = 0;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            bool flag=false;\\n            int square = i * i;\\n            string str = to_string(square);\\n            checkConditions(0,i,0,0,str,flag);\\n            if (flag) {\\n                punishment += square;\\n            }\\n        }\\n        \\n        return punishment;\\n    }\\n    void checkConditions(int index,int& val,int sum,int total, string &str, bool& flag){\\n        \\n        if(index==str.size() && (sum+total==val)){\\n             flag = true;\\n             return;\\n        }\\n        if(index>=str.size() || flag) return;\\n        int curr = int(str[index])-48;\\n        int temp = sum*10+curr;\\n        checkConditions(index+1,val,temp,total,str,flag);\\n        total+=sum;\\n        sum = curr;\\n        checkConditions(index+1,val,sum,total,str,flag);\\n    }\\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577409,
                "title": "q3-solution-with-notes-c",
                "content": "![3.jpeg](https://assets.leetcode.com/users/images/1a5310bd-d70a-4469-96dd-39faa0a84bb5_1685422090.812319.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "![3.jpeg](https://assets.leetcode.com/users/images/1a5310bd-d70a-4469-96dd-39faa0a84bb5_1685422090.812319.jpeg)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3575166,
                "title": "brute-force-recursive-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool send(string number , int rn)\\n    {\\n        \\n        if(rn==0 and number.length()==0) return true;\\n        else if(rn < 0) return false;\\n        string check = number;\\n        bool ans = false;\\n        for(int i = 0 ; i < check.length() ; i++)\\n        {\\n            int fa = 0;\\n            fa+=stoi(check.substr(0,i+1));\\n            if(send(check.substr(i+1) , rn-fa)) return true;\\n        }\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        for(int i = 1 ; i <= n ; i++)\\n        {\\n            if(send(to_string(i*i),i)) \\n            {\\n                cout<<i*i<<endl;\\n                ans+=i*i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool send(string number , int rn)\\n    {\\n        \\n        if(rn==0 and number.length()==0) return true;\\n        else if(rn < 0) return false;\\n        string check = number;\\n        bool ans = false;\\n        for(int i = 0 ; i < check.length() ; i++)\\n        {\\n            int fa = 0;\\n            fa+=stoi(check.substr(0,i+1));\\n            if(send(check.substr(i+1) , rn-fa)) return true;\\n        }\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        for(int i = 1 ; i <= n ; i++)\\n        {\\n            if(send(to_string(i*i),i)) \\n            {\\n                cout<<i*i<<endl;\\n                ans+=i*i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3570147,
                "title": "dp-c-o-6-6-1000-1000",
                "content": "class Solution {\\npublic:\\n\\n    int find(int i, int j, string sum, vector<vector<int> > &dp) {\\n        if (i == sum.length() && j == 0) {\\n            return 1;\\n        }\\n        if (i == sum.length()) {\\n            return 0;\\n        }\\n        if (j < 0) {\\n            return 0;\\n        }\\n        if (dp[i][j] != -1) {\\n            return dp[i][j];\\n        }\\n        dp[i][j] =  0;\\n        int curSum = 0;\\n        for (int itr = i; itr < sum.length(); itr++) {\\n            curSum = curSum * 10 + sum[itr]-\\'0\\';\\n            dp[i][j] = dp[i][j] || find(itr+1, j-curSum, sum, dp);\\n        }\\n        return dp[i][j];\\n    }\\n\\n\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        for (int i = 1; i <= n; i++) {\\n            int sumReq = i * i;\\n            vector<vector<int> > dp(7, vector<int> (1001, -1));\\n            string sum = to_string(sumReq);\\n            if (find(0, i, sum, dp) == 1) {\\n                ans = ans + i * i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int find(int i, int j, string sum, vector<vector<int> > &dp) {\\n        if (i == sum.length() && j == 0) {\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3569886,
                "title": "ez-recursion-rust-o-n-logn-logn",
                "content": "# Intuition\\nThe core of the problem is how to partition a number so to answer if it can form a sum that equals the square root of it. The apply it to every number from 1 to N and calculate the result.\\n\\n# Approach\\nHere I used recursion to search a sum of different partitions of a number until the list is exhausted or sum equals original number is found.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * log(n)^{log(n)})$$\\nThe first loop iterates over all N and for every number it executes the recursion with branching number equals length of the number and base case also equals length of the number. It is also possible to prove that in this specific case it will be $$O(n * 2^{log(n)})$$\\n\\n- Space complexity:\\n$$O(n)$$ because it requires the number to be dissected into digits.\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn punishment_number(n: i32) -> i32 {\\n        let range = 1..=n;\\n        range.into_iter().filter(Self::valid).map(|a| a * a).sum()\\n    }\\n\\n    fn valid(s: &i32) -> bool {\\n        let mut temp = s * s;\\n        let mut digits = vec![];\\n        while temp > 0 {\\n            digits.push(temp % 10);\\n            temp = temp / 10;\\n        }\\n        digits.reverse();\\n\\n        return Self::helper(&digits, 0, 0, s)\\n    }\\n\\n    fn helper(d: &Vec<i32>, i: usize, sum: i32, target: &i32) -> bool {\\n        if i == d.len() {\\n            return sum == *target;\\n        }\\n\\n        // the number representing a new partition\\n        let mut partition = 0;\\n        let mut j = i;\\n        loop {\\n            if j == d.len() {\\n                return false\\n            }\\n            partition = partition*10 + d[j];\\n            if Self::helper(d, j + 1, sum + partition, target) {\\n                // found a partition that works, so the whole number is valid, return immediately\\n                return true\\n            }\\n            j += 1\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn punishment_number(n: i32) -> i32 {\\n        let range = 1..=n;\\n        range.into_iter().filter(Self::valid).map(|a| a * a).sum()\\n    }\\n\\n    fn valid(s: &i32) -> bool {\\n        let mut temp = s * s;\\n        let mut digits = vec![];\\n        while temp > 0 {\\n            digits.push(temp % 10);\\n            temp = temp / 10;\\n        }\\n        digits.reverse();\\n\\n        return Self::helper(&digits, 0, 0, s)\\n    }\\n\\n    fn helper(d: &Vec<i32>, i: usize, sum: i32, target: &i32) -> bool {\\n        if i == d.len() {\\n            return sum == *target;\\n        }\\n\\n        // the number representing a new partition\\n        let mut partition = 0;\\n        let mut j = i;\\n        loop {\\n            if j == d.len() {\\n                return false\\n            }\\n            partition = partition*10 + d[j];\\n            if Self::helper(d, j + 1, sum + partition, target) {\\n                // found a partition that works, so the whole number is valid, return immediately\\n                return true\\n            }\\n            j += 1\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3568423,
                "title": "java-solution-easy-to-understand-recursion",
                "content": "```\\nclass Solution {\\n    public boolean isPart2(String str,int num){\\n        if(num<0)return false;\\n        if(str.length()==0){\\n            return num==0;\\n        }\\n        for(int i=0;i<str.length();i++){\\n            int num1=Integer.parseInt(str.substring(0,i+1));\\n            if(isPart2(str.substring(i+1),num-num1))return true;\\n        }\\n        return false;\\n    }\\n    public boolean isPart(int num){\\n        int sqr=num*num;\\n        return isPart2(sqr+\"\",num);\\n    }\\n    public int punishmentNumber(int n) {\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            if(isPart(i))ans+=(i*i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPart2(String str,int num){\\n        if(num<0)return false;\\n        if(str.length()==0){\\n            return num==0;\\n        }\\n        for(int i=0;i<str.length();i++){\\n            int num1=Integer.parseInt(str.substring(0,i+1));\\n            if(isPart2(str.substring(i+1),num-num1))return true;\\n        }\\n        return false;\\n    }\\n    public boolean isPart(int num){\\n        int sqr=num*num;\\n        return isPart2(sqr+\"\",num);\\n    }\\n    public int punishmentNumber(int n) {\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            if(isPart(i))ans+=(i*i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567698,
                "title": "c-recursion-easy-solution",
                "content": "# Please UpVote if it helps you\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(string&s,int i,int x,int tot){\\n        if(i>=s.length()){\\n            return x == tot;\\n        }\\n        bool ans = 0;\\n        int q=0;\\n        for(int j=i;j<s.length();++j){\\n            q = 10*q + int(s[j])-48;\\n            ans |= solve(s,j+1,x+q,tot);\\n            if(ans)return 1;\\n        }\\n        return ans;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        for(int i=1;i<=n;++i){\\n            string s = to_string(i*i);\\n            if(solve(s,0,0,i)){ans += i*i;}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(string&s,int i,int x,int tot){\\n        if(i>=s.length()){\\n            return x == tot;\\n        }\\n        bool ans = 0;\\n        int q=0;\\n        for(int j=i;j<s.length();++j){\\n            q = 10*q + int(s[j])-48;\\n            ans |= solve(s,j+1,x+q,tot);\\n            if(ans)return 1;\\n        }\\n        return ans;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        for(int i=1;i<=n;++i){\\n            string s = to_string(i*i);\\n            if(solve(s,0,0,i)){ans += i*i;}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567280,
                "title": "easy-understanding-java-solution-fastest-simple-recursion",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int sum=0;\\n        for(int i=1; i<=n; i++){\\n            int sqr=i*i;\\n            if(isPart(sqr,i))\\n            sum+=sqr;\\n        }\\n\\n        return sum;\\n    }\\n    boolean isPart(int num,int tar){\\n        if(tar<0 || num<tar){\\n            return false;\\n        }\\n        if(num==tar) return true;\\n        return isPart(num/10,tar-num%10)|| isPart(num/100,tar-num%100)|| isPart(num/1000,tar-num%1000);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int sum=0;\\n        for(int i=1; i<=n; i++){\\n            int sqr=i*i;\\n            if(isPart(sqr,i))\\n            sum+=sqr;\\n        }\\n\\n        return sum;\\n    }\\n    boolean isPart(int num,int tar){\\n        if(tar<0 || num<tar){\\n            return false;\\n        }\\n        if(num==tar) return true;\\n        return isPart(num/10,tar-num%10)|| isPart(num/100,tar-num%100)|| isPart(num/1000,tar-num%1000);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566946,
                "title": "simplest-basic-recursion-java-easy",
                "content": "# Intuition\\nBasically we have to partition each and every string to find the solution.\\n\\n# Approach\\nPartitioning of string means recursion.\\n\\n# Code\\n```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int sum=0;\\n        for(int i=1;i<=n;i++){\\n            if(rec(i,Integer.toString(i*i),0)) sum+=i*i ;\\n            else sum+=0;\\n        }\\n        return sum;\\n    }\\n    static boolean rec(int sum,String num,int start){\\n        if(sum<0){\\n            return false;\\n        }\\n        if(start==num.length() && sum==0){\\n            return true;\\n        }\\n        for(int i=start;i<num.length();i++){\\n            int left = Integer.parseInt(num.substring(start,i+1));\\n            boolean right = rec(sum-left,num,i+1);\\n            if(right){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int sum=0;\\n        for(int i=1;i<=n;i++){\\n            if(rec(i,Integer.toString(i*i),0)) sum+=i*i ;\\n            else sum+=0;\\n        }\\n        return sum;\\n    }\\n    static boolean rec(int sum,String num,int start){\\n        if(sum<0){\\n            return false;\\n        }\\n        if(start==num.length() && sum==0){\\n            return true;\\n        }\\n        for(int i=start;i<num.length();i++){\\n            int left = Integer.parseInt(num.substring(start,i+1));\\n            boolean right = rec(sum-left,num,i+1);\\n            if(right){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565788,
                "title": "recursion-o-n-time-precomputation-explained-and-evaluated",
                "content": "[TOC]\\n# Recursive Brute-force Approach\\nWe progress through all values of $$i$$ from $$1$$ to $$N$$, checking whether they fit the \"punisher\" condition.\\nFor each number $$i^2$$ we use brute-force search to go through all possible ways of separating one or more digits from its right side as a substring, whose value will participate in the sum to be calculated. By detaching a part of the number in this way, we reduce it, and for this reduced number we recursively call the same check function. We continue like this until we run out of digits. If at least one option of all combinations yields the required sum $$i$$, then the number $$i$$ is suitable for punishment.\\n\\n## Complexity\\n- Time complexity: $O(N^{1.6})$\\n- Space complexity: $O(logN)$\\n\\n*Where did that bizarre fractional power come from?*\\n<details>\\n<summary>Math goes here</summary>\\n<br/>\\nLet\\'s recap some basics first.\\n\\n$log_{a}b$ means the power to which $a$ must be raised to get $b$, i.e. $a^{log_{a}b} = b$.\\n${log_{a}b} + {log_{a}c} = {log_{a}bc}$\\u2007\\u2007\\u2007\\u2007${log_{a}b} = {log_{a}c} \\\\times {log_{c}b}$\\u2007\\u2007\\u2007\\u2007${log_{a}b^{n}} = n{log_{a}b}$\\n\\n---\\n\\nLet $X$ be some integer. The number of digits in its decimal representation is $log_{10}X$, rounded up. Omit the thing with rounding, it does not matter in terms of an approximate complexity estimation.\\nSince it\\'s known that $i\\\\le N$ and we pass values $i^2$ to the checking function, we\\'ll estimate them from above as $N^2$ each. The digits count for them will be $log_{10}N^{2} = 2log_{10}N = 2log_{10}2\\\\times log_{2}N \\\\approx 0.602\\\\times log_{2}N \\\\approx  log_{2}N^{0.6}$.\\nThe number of all the possible ways to split an $x$-digit integer is $2^{x-1}$, so, in our case it is $2^{log_{2}N^{0.6}} - 1 = N^{0.6} - 1$. This maximum possible number of variants to deal with in the checking function gives an upper estimate of its time complexity as $O(N^{0.6})$. The function itself is used exactly $N$ times, which results in total time complexity $O(N^{1.6})$.\\nAs for space consumption, the only place where it is greater than $O(1)$ is the recursion stack for the said function. Note that the depth of recursion cannot be greater than the number of digits in the number, estimated above as $log_{2}N^{0.6} = 0.6log_{2}N$, which means $O(logN)$ space complexity.\\n\\n---\\n\\nThanks to [@hero080](https://leetcode.com/hero080/) for the concept, check out his solution [here](https://leetcode.com/problems/find-the-punishment-number-of-an-integer/solutions/3547280/0ms-tc-on53-sc-olog-n-most-efficient-solution-simplest-code/). This is where this analysis derives from.\\n</details>\\n\\n## Code\\n```\\nclass Solution\\n{\\n    func punishmentNumber(_ n: Int) -> Int\\n    {\\n        var sum = 0\\n        for i in 1...n\\n        {\\n            let squared = i * i\\n            if isPunisher(i, squared) {\\n                sum += squared\\n            }\\n        }\\n        return sum\\n    }\\n                     //rep is decimalRepresentation           \\n    func isPunisher(_ num: Int, _ rep: Int) -> Bool \\n    {\\n        if num == rep { return true }\\n        if rep < 10 { return false }\\n        var exp = 10, suffixNum: Int\\n        while exp < rep\\n        {\\n            suffixNum = rep % exp\\n            if suffixNum >= num { return false }\\n            if isPunisher(num - suffixNum, rep / exp) { return true }\\n            exp *= 10\\n        }\\n        return false\\n    }\\n}\\n```\\n# Precomputation and caching as a way to increase performance\\nIt is easy to see that all suitable values $$i$$ are the same each time, the only difference is to which limit $$n$$ we compute them. So we can calculate in advance some quantity of initial $$i$$ numbers and, for that matter, the required sum of their squares.\\nIf a given value of $$n$$ is within the range, we can immediately return a ready answer. If not, we fallback on the previous method and continue calculations starting from the maximal known number and up to $$n$$, adding along the way the newly obtained values to our storage, thus expanding it.\\n\\n*But isn\\'t that cheating?*\\n\\nWell, first of all, the problem conditions in no way mention or forbid this rather obvious approach. Second, we don\\'t slack off on the solution by use of code. All the code for the actual calculations of needed numbers is right there and in working order - in fact, all these values were obtained with it. Basically, as soon as a larger $$n$$ number arrives, everything will come in motion - both calculations and adding to the cache for the next queries. Nothing forbids even emptying prepared arrays by removing all elements from them. Even so, this approach will give an improved performance, taking advantage of the fact that static variables are preserved between test cases. The entire value cache will be recalculated and populated no more than once during the whole tests run, thus avoiding unnecessary computations of the same things.\\nFinally, take a broader view of things. We are given a problem, in the general sense of the word, we need to handle it in the best way possible \\u2013 and that\\'s exactly what we do. In a real work task we wouldn\\'t hesitate of using the most efficient way to get the job done, right?\\n\\n## Complexity\\nOh, this is going to be an unusual one.\\n\\n- Time complexity: $O(max(0, N-P)*N^{0.6} + T*log(max(P, N)))$\\n- Space complexity: $O(max(P,N))$\\n\\nDenote by $P$ the number of the precomputed values of $i$ paired with the respective squared sum, and by $T$ the count of tests performed. Assume that we cache all the obtained results with no limitations.\\n\\nTo estimate the memory consumption, it would be helpful to know how the number of found $i$ grows with the growth of $N$. Sample observations suggest that it decreases at about a logarithmic rate, but without a mathematical proof of this we have to settle for a linear estimate of $O(N)$ \\u2013 at least, the amount of found $i$ in $N$ numbers obviously cannot be greater than $N$. Also, the use of memory by any measure will not be less than the number of pre-calculated values stored. Combined that means overall space complexity of $O(max(P,N))$. The puny value $O(logN)$ for checking function dissolves in it like a drop in the ocean.\\n\\nSince for all numbers from $1$ to $N$ we check each of them only once during the whole run, then use the saved values, and initially we have P of them stored, a total of up to $max(0, N-P)$ function calls will be performed. Each check\\'s time complexity was estimated before as $O(N^{0.6})$. That yields $O(max(0, N-P) * N^{0.6})$ time for checking part.\\nIn cases where all numbers $i$ in the requested interval $1...n$ have already been found and stored in an array, we use a binary search to find the last $i \\\\le n$ among them. The size of the array is the count of stored values, which was just estimated as $max(P, N)$ and the binary search is as fast as logarithm of this, i.e. $log(max(P, N))$. In the worst case, we we\\'ll follow the binary search path for each test, hence we multiply this value by $T$ : $O(T*log(max(P, N)))$.\\nTogether with the previous one, it gives the total time complexity $O(max(0, N-P)*N^{0.6} + T*log(max(P, N)))$.\\n\\n\\n## Code\\n\\n```\\nvar punishers = [1, 9, 10, 36, 45, 55, 82, 91, 99, 100, 235, 297, 369, 370, 379, 414,\\n                657, 675, 703, 756, 792, 909, 918, 945, 964, 990, 991, 999, 1000]\\nvar pNumbers = [1, 82, 182, 1478, 3503, 6528, 13252, 21533, 31334, 41334, 96559, 184768,\\n                320929, 457829, 601470, 772866, 1204515, 1660140, 2154349, 2725885, 3353149,\\n                4179430, 5022154, 5915179, 6844475, 7824575, 8806656, 9804657, 10804657]\\nvar pMaxChecked = 1200\\n//the first one after 1000 will be 1296\\n\\nclass Solution {\\n    func punishmentNumber(_ n: Int) -> Int\\n    {\\n        if n <= pMaxChecked // use precomputed value\\n        {   // binary search for the last index where holds punishers[index] <= n\\n            var low = 0, high = punishers.count - 1, mid: Int\\n            while low < high\\n            {                \\n                mid = low + (high - low + 1) / 2\\n                if punishers[mid] <= n { low = mid }\\n                else { high = mid - 1 }\\n            }\\n            return pNumbers[high]\\n        }\\n        else // caclculate and add new values\\n        {   \\n            var sum = pNumbers.last ?? 0, squared: Int\\n            for i in (pMaxChecked + 1)...n\\n            {\\n                squared = i * i\\n                if isPunisher(i, squared)\\n                {\\n                    sum += squared\\n                    punishers.append(i)\\n                    pNumbers.append(sum)\\n                    // print(punishers.last!, pNumbers.last!)\\n                }\\n                pMaxChecked += 1\\n            }\\n            return sum\\n        }\\n    }\\n                     //rep is decimalRepresentation           \\n    func isPunisher(_ num: Int, _ rep: Int) -> Bool \\n    {\\n        if num == rep { return true }\\n        if rep < num { return false }\\n        var exp = 10, suffixNum: Int\\n        while exp < rep\\n        {\\n            suffixNum = rep % exp\\n            if suffixNum >= num { return false }\\n            if isPunisher(num - suffixNum, rep / exp) { return true }\\n            exp *= 10\\n        }\\n        return false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Math",
                    "Binary Search",
                    "Recursion",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution\\n{\\n    func punishmentNumber(_ n: Int) -> Int\\n    {\\n        var sum = 0\\n        for i in 1...n\\n        {\\n            let squared = i * i\\n            if isPunisher(i, squared) {\\n                sum += squared\\n            }\\n        }\\n        return sum\\n    }\\n                     //rep is decimalRepresentation           \\n    func isPunisher(_ num: Int, _ rep: Int) -> Bool \\n    {\\n        if num == rep { return true }\\n        if rep < 10 { return false }\\n        var exp = 10, suffixNum: Int\\n        while exp < rep\\n        {\\n            suffixNum = rep % exp\\n            if suffixNum >= num { return false }\\n            if isPunisher(num - suffixNum, rep / exp) { return true }\\n            exp *= 10\\n        }\\n        return false\\n    }\\n}\\n```\n```\\nvar punishers = [1, 9, 10, 36, 45, 55, 82, 91, 99, 100, 235, 297, 369, 370, 379, 414,\\n                657, 675, 703, 756, 792, 909, 918, 945, 964, 990, 991, 999, 1000]\\nvar pNumbers = [1, 82, 182, 1478, 3503, 6528, 13252, 21533, 31334, 41334, 96559, 184768,\\n                320929, 457829, 601470, 772866, 1204515, 1660140, 2154349, 2725885, 3353149,\\n                4179430, 5022154, 5915179, 6844475, 7824575, 8806656, 9804657, 10804657]\\nvar pMaxChecked = 1200\\n//the first one after 1000 will be 1296\\n\\nclass Solution {\\n    func punishmentNumber(_ n: Int) -> Int\\n    {\\n        if n <= pMaxChecked // use precomputed value\\n        {   // binary search for the last index where holds punishers[index] <= n\\n            var low = 0, high = punishers.count - 1, mid: Int\\n            while low < high\\n            {                \\n                mid = low + (high - low + 1) / 2\\n                if punishers[mid] <= n { low = mid }\\n                else { high = mid - 1 }\\n            }\\n            return pNumbers[high]\\n        }\\n        else // caclculate and add new values\\n        {   \\n            var sum = pNumbers.last ?? 0, squared: Int\\n            for i in (pMaxChecked + 1)...n\\n            {\\n                squared = i * i\\n                if isPunisher(i, squared)\\n                {\\n                    sum += squared\\n                    punishers.append(i)\\n                    pNumbers.append(sum)\\n                    // print(punishers.last!, pNumbers.last!)\\n                }\\n                pMaxChecked += 1\\n            }\\n            return sum\\n        }\\n    }\\n                     //rep is decimalRepresentation           \\n    func isPunisher(_ num: Int, _ rep: Int) -> Bool \\n    {\\n        if num == rep { return true }\\n        if rep < num { return false }\\n        var exp = 10, suffixNum: Int\\n        while exp < rep\\n        {\\n            suffixNum = rep % exp\\n            if suffixNum >= num { return false }\\n            if isPunisher(num - suffixNum, rep / exp) { return true }\\n            exp *= 10\\n        }\\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565667,
                "title": "simple-java-recursive-solution-using-strings",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal is to try the possible partitions of the current square to determine if they sum to the initial value (the target). \\n\\nEx, i = 36, i*i = 1296, 1 + 29 + 6 = 36. \\nWe do this for every 2 <= i <= 1000.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConvert the current square, i * i, to a string. Then recursively try every possible partition of the square to determine if any combination sums to the target. If the string is empty, we have reached the end of the current combination. If our index is greater than the current string OR our sum is already larger than the target, return false.\\n\\nOtherwise, check both the current substring from (0, idx+1) OR increase the index of the substring to be checked by 1. If either return true, we have a solution.\\n\\nThis can likely be optimized to use modulo and divison instead of parsing strings and integers.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int res = 1;\\n        for (int i = 2; i <= n; i++){\\n            if (valid(i, 0, String.valueOf(i*i),0)){\\n                res = res + (i*i);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public boolean valid(int tar, int sum, String num, int idx){\\n        \\n        if (num == null || num.length() == 0){\\n            return tar == sum;\\n        }\\n        if (idx >= num.length() || sum > tar) {\\n            return false;\\n        }\\n        return valid(tar, sum + Integer.parseInt(num.substring(0, idx+1)), num.substring(idx+1), 0) \\n            || valid(tar, sum, num, idx+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int res = 1;\\n        for (int i = 2; i <= n; i++){\\n            if (valid(i, 0, String.valueOf(i*i),0)){\\n                res = res + (i*i);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public boolean valid(int tar, int sum, String num, int idx){\\n        \\n        if (num == null || num.length() == 0){\\n            return tar == sum;\\n        }\\n        if (idx >= num.length() || sum > tar) {\\n            return false;\\n        }\\n        return valid(tar, sum + Integer.parseInt(num.substring(0, idx+1)), num.substring(idx+1), 0) \\n            || valid(tar, sum, num, idx+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565606,
                "title": "easy-best-c-code-recursion",
                "content": "### LinkedIn : https://www.linkedin.com/in/aditya-jhunjhunwala-51b586195/\\n# Code\\n## Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    bool recursion(int ind,string s,int no,int sum,int temp){\\n        if(ind == s.size()-1){\\n            temp += s[ind] - \\'0\\';\\n            if(sum + temp == no)\\n                return true;\\n            return false;\\n        }\\n        temp += s[ind] - \\'0\\';\\n        return recursion(ind+1,s,no,sum + temp,0) || recursion(ind+1,s,no,sum,temp*10);\\n    }\\n    bool isPossible(int i){\\n        string s = to_string(i*i);\\n        if(recursion(0,s,i,0,0))\\n            return true;\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int sum = 0;\\n        for(int i = 9 ; i <= n ; i++)\\n            if(isPossible(i))\\n                sum += (i * i);\\n        return sum + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool recursion(int ind,string s,int no,int sum,int temp){\\n        if(ind == s.size()-1){\\n            temp += s[ind] - \\'0\\';\\n            if(sum + temp == no)\\n                return true;\\n            return false;\\n        }\\n        temp += s[ind] - \\'0\\';\\n        return recursion(ind+1,s,no,sum + temp,0) || recursion(ind+1,s,no,sum,temp*10);\\n    }\\n    bool isPossible(int i){\\n        string s = to_string(i*i);\\n        if(recursion(0,s,i,0,0))\\n            return true;\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int sum = 0;\\n        for(int i = 9 ; i <= n ; i++)\\n            if(isPossible(i))\\n                sum += (i * i);\\n        return sum + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564681,
                "title": "simple-recursion-best-explanation-optimal-c-python",
                "content": "- Algorithm :\\n\\n1. The code defines a class `Solution` with a few helper methods and a main method `punishmentNumber()`.\\n\\n2. The code uses a cache dictionary (`cache`) to store precomputed values for efficient lookup.\\n\\n3. The `isValid()` method checks if a given string `s` can be partitioned in a way that the sum of the partitions equals the `remSum` (remaining sum).\\n\\n4. The `isValid()` method uses recursion to consider all possible substrings of `s` and recursively checks if the remaining substring and remaining sum can be validly partitioned.\\n\\n5. The `preCompute()` method is responsible for precomputing all possible values from 1 to `n` and storing them in the cache dictionary (`cache`). It uses the `isValid()` method to determine if a number `i` squared can be partitioned into `i` parts that sum up to `i`.\\n\\n6. The `punishmentNumber()` method calls `preCompute()` to precompute values and then iterates from 1 to `n`. If a number `i` is present in the cache, it adds the square of `i` to the answer (`ans`).\\n\\n7. Finally, the `punishmentNumber()` method returns the value of `ans`, which represents the sum of the squares of numbers that can be partitioned into `i` parts, where `i` ranges from 1 to `n`.\\n\\nIn summary, the code uses recursion and precomputation to find numbers that can be partitioned into specific sums. It then computes the sum of the squares of those numbers and returns the result.\\n# Code\\n```Python []\\nclass Solution(object):\\n    cache = {}\\n\\n    #Function to check valid partition of num\\n    def isValid(self,s,remSum):\\n        #Base Case 1: if remaining sum goes negative\\n        if remSum < 0:\\n            return False\\n        #Base Case 2: if sum=0 and string becomes empty\\n        if not s and remSum==0:\\n            return True\\n        #Consider all sub string and go recursively\\n        valid = False\\n        for i in range(0,len(s)):\\n            curr = s[:i+1] #slicing/substr(0,i+1)\\n            curVal = int(curr) #Current Value\\n            next = s[i+1:] #Remaining str passed recursively\\n            valid = self.isValid(next,remSum-curVal)\\n            if valid:#Optimization\\n                break\\n        return valid\\n\\n    #Function to preCompute all possible value from [1,n]\\n    def preCompute(self,n):\\n        for i in range(1,n+1):\\n            if self.isValid(str(i*i),i):\\n                self.cache[i] = True\\n    def punishmentNumber(self, n):\\n        self.preCompute(n)\\n        ans=0\\n        for i in range(1,n+1):\\n            if i in self.cache:\\n                ans += i*i\\n        return ans\\n```\\n```C++ []\\nclass Solution {\\nprivate:\\n    unordered_map<int, bool> cache;\\n\\n    // Function to check valid partition of num\\n    bool isValid(string s, int remSum) {\\n        // Base Case 1: if remaining sum goes negative\\n        if (remSum < 0)\\n            return false;\\n        // Base Case 2: if sum = 0 and string becomes empty\\n        if (s.empty() && remSum == 0)\\n            return true;\\n        // Consider all substrings and go recursively\\n        bool valid = false;\\n        for (int i = 0; i < s.length(); i++) {\\n            string curr = s.substr(0, i + 1); // slicing/substr(0, i+1)\\n            int curVal = stoi(curr); // Current Value\\n            string next = s.substr(i + 1); // Remaining str passed recursively\\n            valid = isValid(next, remSum - curVal);\\n            if (valid) // Optimization\\n                break;\\n        }\\n        return valid;\\n    }\\n\\n    // Function to preCompute all possible values from [1, n]\\n    void preCompute(int n) {\\n        for (int i = 1; i <= n; i++) {\\n            if (isValid(to_string(i * i), i))\\n                cache[i] = true;\\n        }\\n    }\\n\\npublic:\\n    int punishmentNumber(int n) {\\n        preCompute(n);\\n        int ans = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if (cache.find(i) != cache.end())\\n                ans += i * i;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```Python []\\nclass Solution(object):\\n    cache = {}\\n\\n    #Function to check valid partition of num\\n    def isValid(self,s,remSum):\\n        #Base Case 1: if remaining sum goes negative\\n        if remSum < 0:\\n            return False\\n        #Base Case 2: if sum=0 and string becomes empty\\n        if not s and remSum==0:\\n            return True\\n        #Consider all sub string and go recursively\\n        valid = False\\n        for i in range(0,len(s)):\\n            curr = s[:i+1] #slicing/substr(0,i+1)\\n            curVal = int(curr) #Current Value\\n            next = s[i+1:] #Remaining str passed recursively\\n            valid = self.isValid(next,remSum-curVal)\\n            if valid:#Optimization\\n                break\\n        return valid\\n\\n    #Function to preCompute all possible value from [1,n]\\n    def preCompute(self,n):\\n        for i in range(1,n+1):\\n            if self.isValid(str(i*i),i):\\n                self.cache[i] = True\\n    def punishmentNumber(self, n):\\n        self.preCompute(n)\\n        ans=0\\n        for i in range(1,n+1):\\n            if i in self.cache:\\n                ans += i*i\\n        return ans\\n```\n```C++ []\\nclass Solution {\\nprivate:\\n    unordered_map<int, bool> cache;\\n\\n    // Function to check valid partition of num\\n    bool isValid(string s, int remSum) {\\n        // Base Case 1: if remaining sum goes negative\\n        if (remSum < 0)\\n            return false;\\n        // Base Case 2: if sum = 0 and string becomes empty\\n        if (s.empty() && remSum == 0)\\n            return true;\\n        // Consider all substrings and go recursively\\n        bool valid = false;\\n        for (int i = 0; i < s.length(); i++) {\\n            string curr = s.substr(0, i + 1); // slicing/substr(0, i+1)\\n            int curVal = stoi(curr); // Current Value\\n            string next = s.substr(i + 1); // Remaining str passed recursively\\n            valid = isValid(next, remSum - curVal);\\n            if (valid) // Optimization\\n                break;\\n        }\\n        return valid;\\n    }\\n\\n    // Function to preCompute all possible values from [1, n]\\n    void preCompute(int n) {\\n        for (int i = 1; i <= n; i++) {\\n            if (isValid(to_string(i * i), i))\\n                cache[i] = true;\\n        }\\n    }\\n\\npublic:\\n    int punishmentNumber(int n) {\\n        preCompute(n);\\n        int ans = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if (cache.find(i) != cache.end())\\n                ans += i * i;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563031,
                "title": "simple-recursion-solution",
                "content": "# Intuition\\nSimple recursion\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution:\\n    candidate_list = {}\\n    def polpulate_candidate_list(self, m: int):\\n        for i in range(m+1):\\n            self.candidate_list[i+1] = 0\\n        t=1\\n        while(t<=m):\\n            square = t * t\\n            if_cand = self.segment(square, t)\\n            if if_cand == 1:\\n                self.candidate_list[t] = 1\\n            t=t+1\\n\\n    def segment(self, square, m):\\n        #print(f\"value of m is {m}\")\\n        if m<0:\\n            return 0\\n        if len(str(square)) == 1 and square != m:\\n            return 0\\n        elif len(str(square)) == 1 and square == m:\\n            return 1\\n        else:\\n            for i in range(len(str(square))):\\n                first_part, second_part = self.get_split(square, i)\\n                #print (f\"first_part is {first_part} and second_part is {second_part} and required sum was {m}\")\\n                if first_part + second_part == m:\\n                    return 1\\n                else:\\n                    a = self.segment(second_part, m-first_part)\\n                    if a == 1:\\n                        return a\\n\\n    def get_split(self, square, i):\\n        j = i\\n        res = [int(x) for x in str(square)]\\n        first_part  = 0\\n        second_part = 0\\n        counter = 0\\n        while(i>=0):\\n            first_part = first_part + res[counter] * pow(10,i)\\n            counter = counter + 1\\n            i = i - 1\\n        i = len(str(square)) - j - 2\\n       # counter = counter - 1\\n        while(i>=0):\\n            second_part = second_part + res[counter] * pow(10,i)\\n            counter = counter + 1\\n            i = i - 1\\n        return first_part, second_part\\n            \\n    def punishmentNumber(self, n: int) -> int:\\n        self.polpulate_candidate_list(n)\\n        result = 0 \\n        while (n>0):\\n            if self.candidate_list[n] == 1:\\n                result = result + n * n\\n            n = n - 1\\n        #print(self.candidate_list)\\n        #print(result)\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    candidate_list = {}\\n    def polpulate_candidate_list(self, m: int):\\n        for i in range(m+1):\\n            self.candidate_list[i+1] = 0\\n        t=1\\n        while(t<=m):\\n            square = t * t\\n            if_cand = self.segment(square, t)\\n            if if_cand == 1:\\n                self.candidate_list[t] = 1\\n            t=t+1\\n\\n    def segment(self, square, m):\\n        #print(f\"value of m is {m}\")\\n        if m<0:\\n            return 0\\n        if len(str(square)) == 1 and square != m:\\n            return 0\\n        elif len(str(square)) == 1 and square == m:\\n            return 1\\n        else:\\n            for i in range(len(str(square))):\\n                first_part, second_part = self.get_split(square, i)\\n                #print (f\"first_part is {first_part} and second_part is {second_part} and required sum was {m}\")\\n                if first_part + second_part == m:\\n                    return 1\\n                else:\\n                    a = self.segment(second_part, m-first_part)\\n                    if a == 1:\\n                        return a\\n\\n    def get_split(self, square, i):\\n        j = i\\n        res = [int(x) for x in str(square)]\\n        first_part  = 0\\n        second_part = 0\\n        counter = 0\\n        while(i>=0):\\n            first_part = first_part + res[counter] * pow(10,i)\\n            counter = counter + 1\\n            i = i - 1\\n        i = len(str(square)) - j - 2\\n       # counter = counter - 1\\n        while(i>=0):\\n            second_part = second_part + res[counter] * pow(10,i)\\n            counter = counter + 1\\n            i = i - 1\\n        return first_part, second_part\\n            \\n    def punishmentNumber(self, n: int) -> int:\\n        self.polpulate_candidate_list(n)\\n        result = 0 \\n        while (n>0):\\n            if self.candidate_list[n] == 1:\\n                result = result + n * n\\n            n = n - 1\\n        #print(self.candidate_list)\\n        #print(result)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562112,
                "title": "scala-short",
                "content": "# Code\\n```\\nobject Solution {\\n  def iter(s: String, sum: Int): Boolean = \\n    if(s.isEmpty) sum == 0\\n    else (s.inits.toList zip s.tails.toList.reverse).init.exists { \\n      case (a, b) => iter(b, sum - a.toInt) \\n    }\\n\\n  def punishmentNumber(n: Int): Int = {\\n    (1 to n).filter { i => iter((i * i).toString ,i) }.map(i => i * i).sum\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def iter(s: String, sum: Int): Boolean = \\n    if(s.isEmpty) sum == 0\\n    else (s.inits.toList zip s.tails.toList.reverse).init.exists { \\n      case (a, b) => iter(b, sum - a.toInt) \\n    }\\n\\n  def punishmentNumber(n: Int): Int = {\\n    (1 to n).filter { i => iter((i * i).toString ,i) }.map(i => i * i).sum\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3561901,
                "title": "c-recursion-partition",
                "content": "```\\nclass Solution {\\npublic:\\n    bool f(int i, string &s, int num, int n) {\\n        if(num == 0 && i == n) return 1;\\n        if(i >= n) return 0;\\n        string str = \"\";\\n        bool ans = 0;\\n        for(int j = i; j < n; j++) {\\n            str.push_back(s[j]);\\n            int x = stoi(str);\\n            if(x <= num) ans |= f(j + 1, s, num - x, n);\\n        }\\n        return ans;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        for(int i = 1; i <= n; i++) {\\n            int prod = i * i;\\n            string s = to_string(prod); int sz = s.size();\\n            if(f(0, s, i, sz)) ans += prod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(int i, string &s, int num, int n) {\\n        if(num == 0 && i == n) return 1;\\n        if(i >= n) return 0;\\n        string str = \"\";\\n        bool ans = 0;\\n        for(int j = i; j < n; j++) {\\n            str.push_back(s[j]);\\n            int x = stoi(str);\\n            if(x <= num) ans |= f(j + 1, s, num - x, n);\\n        }\\n        return ans;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        for(int i = 1; i <= n; i++) {\\n            int prod = i * i;\\n            string s = to_string(prod); int sz = s.size();\\n            if(f(0, s, i, sz)) ans += prod;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561794,
                "title": "scala-recursion",
                "content": "# Code\\n```\\nobject Solution {\\n    \\n  import scala.collection.immutable.Queue\\n\\n  def punishmentNumber(n: Int): Int =\\n    (1 to n).filter(checkSquare).map(i => i * i).sum\\n\\n  private def checkSquare(i: Int): Boolean = {\\n    def go(chars: List[Char], curr: Queue[Char], acc: Int): Boolean =\\n      chars match {\\n        case c :: tail =>\\n          val nCurr = curr :+ c\\n          val break = go(tail, Queue.empty, acc + nCurr.mkString.toInt)\\n          go(tail, nCurr, acc) || break\\n        case Nil => curr.isEmpty && acc == i\\n      }\\n\\n    go((i * i).toString().toList, Queue.empty, 0)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    \\n  import scala.collection.immutable.Queue\\n\\n  def punishmentNumber(n: Int): Int =\\n    (1 to n).filter(checkSquare).map(i => i * i).sum\\n\\n  private def checkSquare(i: Int): Boolean = {\\n    def go(chars: List[Char], curr: Queue[Char], acc: Int): Boolean =\\n      chars match {\\n        case c :: tail =>\\n          val nCurr = curr :+ c\\n          val break = go(tail, Queue.empty, acc + nCurr.mkString.toInt)\\n          go(tail, nCurr, acc) || break\\n        case Nil => curr.isEmpty && acc == i\\n      }\\n\\n    go((i * i).toString().toList, Queue.empty, 0)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3561390,
                "title": "java-recursion-step-by-step-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are given a number n we want to find the punisment number between 1 to n , we are also given the condition in which a number is called punishment number that is \\n- The decimal representation of i * i can be partitioned into contiguous substrings such that the sum of the integer values of these substrings equals i . \\n-  that is we can represent number 81 as 8+1 =9 and 9 is square root 81 then we can say 9 is a punishment number \\n\\nThings to note \\n-\\n<hr>\\n\\nThe thing we need here is recursion because we want to check if it is possible  i * i can be partitioned into contiguous substrings such that the sum of the integer values of these substrings equals i.\\n \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe question can be done in following steps\\n- Initialize a variable sum to keep track of the cumulative sum of squares of integers that satisfy the condition.\\n\\n- Iterate through integers from 1 to \\'n\\' using a loop.\\n\\n- For each iteration, calculate the square of the current integer and store it in the variable sqr.\\n\\n- Call the helper method isPart to check if the current square sqr satisfies the partitioning condition.\\n\\n- If the condition is satisfied, add the square value sqr to the sum.\\n\\n- After iterating through all integers from 1 to \\'n\\', return the final value of sum as the punishment number.\\n\\n- Define the helper method isPart that takes two integers num and tar as input and returns a boolean indicating if num can be partitioned into substrings with a sum equal to tar.\\n\\n- In the isPart method, handle the base cases first:\\n\\n     - If the target value tar is negative or the number num is smaller than tar, return false.\\n     - If num is equal to tar, return true since it satisfies the condition.\\n- Recursively call the isPart method with updated values to check for partitioning:\\n\\n     - Remove the last digit from num by performing integer division by 10: num/10.\\n     - Subtract the last digit of num from the target value tar using the modulus operator %: tar - num%10.\\n     - Repeat the process with different division factors (10, 100, 1000) to check for partitioning possibilities.\\n     -      return isPart(num/10,tar-num%10)||isPart(num/100,tar-num%100)||isPart(num/1000,tar-num%1000);\\n- If any of the recursive calls to isPart return true, indicating successful partitioning, return true.\\n- Otherwise, if none of the recursive calls return true, return false to indicate unsuccessful partitioning.\\n\\n# Complexity\\n Time complexity:O(n)\\n-\\n<hr>\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution mainly depends on the number \\'n\\' given as input. The brute force approach iterates through integers from 1 to \\'n\\' and performs calculations for each integer. Hence, the time complexity can be considered as O(n), where \\'n\\' is the given positive integer\\n\\n Space complexity:O(log n)\\n-\\n<hr>\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is determined by the recursive calls made in the isPart method. Since the recursion depth is limited by the number of digits in the given input, the space complexity can be considered as O(log n), where \\'n\\' is the given positive integer.\\n\\n# Code\\n```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int sum = 0;\\n        for(int i = 1; i <= n ; i++)\\n        {\\n            int sqr = i*i;\\n            if(isPart(sqr,i))\\n            sum += sqr;\\n        }\\n        return sum;\\n    }\\n        boolean isPart(int num, int tar)\\n        {\\n            if(tar < 0 || num < tar)\\n            {\\n                return false;\\n            }\\n            if(num == tar)\\n            return true;\\n            return isPart(num/10,tar-num%10)||isPart(num/100,tar-num%100)||isPart(num/1000,tar-num%1000);\\n        }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int sum = 0;\\n        for(int i = 1; i <= n ; i++)\\n        {\\n            int sqr = i*i;\\n            if(isPart(sqr,i))\\n            sum += sqr;\\n        }\\n        return sum;\\n    }\\n        boolean isPart(int num, int tar)\\n        {\\n            if(tar < 0 || num < tar)\\n            {\\n                return false;\\n            }\\n            if(num == tar)\\n            return true;\\n            return isPart(num/10,tar-num%10)||isPart(num/100,tar-num%100)||isPart(num/1000,tar-num%1000);\\n        }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561379,
                "title": "o-1-time-complexity-o-1-space-complexity-solution",
                "content": "class Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        vector<int> arr={1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000};\\n        int ans=0;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]<=n){\\n                ans+=(arr[i]*arr[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        vector<int> arr={1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000}",
                "codeTag": "Java"
            },
            {
                "id": 3560598,
                "title": "beats-95-java-static-method-usage-and-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\npre compute all the values and store them in an array.\\nmain logic would be to find all the substrings of an Integer and check if any of them equals the sum\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nuse java static method to precompute so that it becomes a 1 time job.\\nfor find recursive solution start with i = 0,j = 1, find the substring from 0 till j and pass the rest of the substring to the same method again. repeat the process.  \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n1001*7*7 --> as we precompute for every number till 1k and for each number max length can be of 7  \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1001 for array we store and for each substring we cal it just stores in memory so it would be 1000000 -> almost constant\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    static int[] val = new int[1001];\\n\\n  static {\\n    for (int i = 1; i <= 1000; i++) {\\n      if (isPossible(Integer.toString(i*i), 0, i)) {\\n        val[i] = val[i - 1] + i * i;\\n      } else {\\n        val[i] = val[i - 1];\\n      }\\n    }\\n  }\\n\\n  public static int punishmentNumber(int n) {\\n    return val[n];\\n  }\\n\\n  static boolean isPossible(String s, int i, int val) {\\n    if(val < 0 ) return false;\\n    if (val == 0 && i == s.length() ) return true;\\n    for (int j = 1; i+j <= s.length(); j++) {\\n      int k = Integer.parseInt(s.substring( i, i+j));\\n      if (isPossible(s, i + j, val - k)) return true;\\n    }\\n    return false;\\n  }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    static int[] val = new int[1001];\\n\\n  static {\\n    for (int i = 1; i <= 1000; i++) {\\n      if (isPossible(Integer.toString(i*i), 0, i)) {\\n        val[i] = val[i - 1] + i * i;\\n      } else {\\n        val[i] = val[i - 1];\\n      }\\n    }\\n  }\\n\\n  public static int punishmentNumber(int n) {\\n    return val[n];\\n  }\\n\\n  static boolean isPossible(String s, int i, int val) {\\n    if(val < 0 ) return false;\\n    if (val == 0 && i == s.length() ) return true;\\n    for (int j = 1; i+j <= s.length(); j++) {\\n      int k = Integer.parseInt(s.substring( i, i+j));\\n      if (isPossible(s, i + j, val - k)) return true;\\n    }\\n    return false;\\n  }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559969,
                "title": "python-dfs-find-the-number-is-punishment-explained",
                "content": "We can check every number in the range of [1, n] and get the results.\\n\\nThe key if how to check if a number is punishment number. We can use DFS to try all the substring cases to check if there is a possible partition that meet the requirement.\\n\\nSee the code blow:\\n\\n```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        p = 1\\n        \\n        for ti in range(2, n + 1):\\n            if self.isPunish(str(ti * ti), 0, ti):\\n                p += ti * ti\\n        return p\\n    \\n    \\n    def isPunish(self, str_i, s, target):\\n        if int(str_i[s:]) == target:\\n            return True\\n        \\n        for nidx in range(s + 1, len(str_i)):\\n            ntarget = target - int(str_i[s: nidx])\\n            if ntarget >= 0:\\n                if self.isPunish(str_i, nidx, ntarget):\\n                    return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        p = 1\\n        \\n        for ti in range(2, n + 1):\\n            if self.isPunish(str(ti * ti), 0, ti):\\n                p += ti * ti\\n        return p\\n    \\n    \\n    def isPunish(self, str_i, s, target):\\n        if int(str_i[s:]) == target:\\n            return True\\n        \\n        for nidx in range(s + 1, len(str_i)):\\n            ntarget = target - int(str_i[s: nidx])\\n            if ntarget >= 0:\\n                if self.isPunish(str_i, nidx, ntarget):\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559555,
                "title": "c-easy-to-understand-implement",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n```\\nO(n^2)\\n```\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nO(1)\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f;\\n    void func(int i,string& s,int sum,int& exp){\\n        int n=s.length();\\n        if(i==n){\\n            if(sum==exp){\\n                f=1;\\n                return;\\n            }\\n        }\\n        for(int j=i;j<n;j++){\\n            int len=(j-i+1);\\n            string ns= s.substr(i,len);\\n            int nst= stoi(ns);\\n            func(j+1,s,sum+nst,exp);\\n        }\\n    }\\n    int punishmentNumber(int n) {\\n        int res=0;\\n        for(int i=1;i<=n;i++){\\n            int val=(i*i);\\n            string s= to_string(val);\\n            f=0;\\n            func(0,s,0,i);\\n            if(f==1){\\n                res += val;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nO(n^2)\\n```\n```\\nO(1)\\n```\n```\\nclass Solution {\\npublic:\\n    int f;\\n    void func(int i,string& s,int sum,int& exp){\\n        int n=s.length();\\n        if(i==n){\\n            if(sum==exp){\\n                f=1;\\n                return;\\n            }\\n        }\\n        for(int j=i;j<n;j++){\\n            int len=(j-i+1);\\n            string ns= s.substr(i,len);\\n            int nst= stoi(ns);\\n            func(j+1,s,sum+nst,exp);\\n        }\\n    }\\n    int punishmentNumber(int n) {\\n        int res=0;\\n        for(int i=1;i<=n;i++){\\n            int val=(i*i);\\n            string s= to_string(val);\\n            f=0;\\n            func(0,s,0,i);\\n            if(f==1){\\n                res += val;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559212,
                "title": "c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canPartition(string &str, int startIndex, int target)\\n    {\\n        if (startIndex == str.size() && target == 0)\\n            return true;\\n        if (target < 0)\\n            return false;\\n        \\n        bool ans = false;\\n        int leftNum = 0;\\n\\n        for (int i = startIndex; i < str.size(); i++)\\n        {\\n            leftNum = (leftNum * 10) + (str[i] - \\'0\\');\\n\\n            bool isPossible = canPartition(str, i + 1, target - leftNum);\\n            if (isPossible)\\n            {\\n                ans = true;\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    int punishmentNumber(int n) {\\n        int sum = 0;\\n        for (int num = 1; num <= n; num++)\\n        {\\n            int sqr = num * num;\\n            string sqrStr = to_string(sqr);\\n            if (canPartition(sqrStr, 0, num))\\n                sum += sqr;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canPartition(string &str, int startIndex, int target)\\n    {\\n        if (startIndex == str.size() && target == 0)\\n            return true;\\n        if (target < 0)\\n            return false;\\n        \\n        bool ans = false;\\n        int leftNum = 0;\\n\\n        for (int i = startIndex; i < str.size(); i++)\\n        {\\n            leftNum = (leftNum * 10) + (str[i] - \\'0\\');\\n\\n            bool isPossible = canPartition(str, i + 1, target - leftNum);\\n            if (isPossible)\\n            {\\n                ans = true;\\n                break;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    int punishmentNumber(int n) {\\n        int sum = 0;\\n        for (int num = 1; num <= n; num++)\\n        {\\n            int sqr = num * num;\\n            string sqrStr = to_string(sqr);\\n            if (canPartition(sqrStr, 0, num))\\n                sum += sqr;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559206,
                "title": "python-3-lines-with-no-pre-calculation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we create a function `e` that recursively calculate a string `s` can be equal to an integer `t` when it partitioned in some way. \\n\\nThen we use this function to calculate sum of the numbers `i` from `1` to `n` which their squares can be partitioned as sum of the partitiones equals to `i` in some way. \\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        def e(s,t): \\n            return int(s)==t or any(e(s[:i],t-int(s[i:])) for i in range(1,len(s)))\\n        return sum(i*i*e(str(i*i),i) for i in range(1,n+1))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        def e(s,t): \\n            return int(s)==t or any(e(s[:i],t-int(s[i:])) for i in range(1,len(s)))\\n        return sum(i*i*e(str(i*i),i) for i in range(1,n+1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558588,
                "title": "clean-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each pair of remainder $a$ and quotient $b$, recursively check if $a$ can be splitted and added up to $n-b$.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    bool check(int n, int sq){\\n        int d=1;\\n        while(sq>=d){\\n            int a=sq%d,b=sq/d;\\n            if(a+b==n or check(n-b,a)) return true;\\n            d*=10;\\n        }\\n        return false;\\n    }\\npublic:\\n    int punishmentNumber(int n) {\\n        int result=0;\\n        for(int i=1;i<=n;i++){\\n            int sq=i*i;\\n            if(!check(i,sq)) continue;\\n            result+=sq;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool check(int n, int sq){\\n        int d=1;\\n        while(sq>=d){\\n            int a=sq%d,b=sq/d;\\n            if(a+b==n or check(n-b,a)) return true;\\n            d*=10;\\n        }\\n        return false;\\n    }\\npublic:\\n    int punishmentNumber(int n) {\\n        int result=0;\\n        for(int i=1;i<=n;i++){\\n            int sq=i*i;\\n            if(!check(i,sq)) continue;\\n            result+=sq;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557746,
                "title": "a-simple-backtracking-java-solution",
                "content": "this solution is very similar to backtracking palindrome partitioning \\n\\n```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int total=0;\\n        for(int i=1;i<=n;i++){\\n            if(isRequired((\"\"+i*i),0,0,i))\\n                total+=i*i;\\n            \\n        }\\n        \\n        return total;\\n    }\\n    \\n    \\n    boolean isRequired(String s,int start,int sum,int val){\\n        \\n       \\n        if(start>=s.length())\\n             if(sum==val)\\n           { \\n                 \\n            return true;}\\n        for(int i=start;i<s.length();i++){\\n            \\n            int summ=Integer.parseInt(s.substring(start,i+1));\\n           boolean a= isRequired(s,i+1,sum+summ,val);\\n            if(a)\\n                return a;\\n        }\\n        \\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int total=0;\\n        for(int i=1;i<=n;i++){\\n            if(isRequired((\"\"+i*i),0,0,i))\\n                total+=i*i;\\n            \\n        }\\n        \\n        return total;\\n    }\\n    \\n    \\n    boolean isRequired(String s,int start,int sum,int val){\\n        \\n       \\n        if(start>=s.length())\\n             if(sum==val)\\n           { \\n                 \\n            return true;}\\n        for(int i=start;i<s.length();i++){\\n            \\n            int summ=Integer.parseInt(s.substring(start,i+1));\\n           boolean a= isRequired(s,i+1,sum+summ,val);\\n            if(a)\\n                return a;\\n        }\\n        \\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557129,
                "title": "string-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        def helper(s, target):\\n            if int(s) == target: return True\\n            for i in reversed(range(1, len(s))):\\n                if int(s[i:]) > target:\\n                    break\\n                if helper(s[:i], target-int(s[i:])):\\n                    return True\\n            return False\\n                \\n        ret = 0\\n        for i in range(1, n+1):\\n            if helper(str(i*i), i):\\n                ret += i*i\\n        return ret\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        def helper(s, target):\\n            if int(s) == target: return True\\n            for i in reversed(range(1, len(s))):\\n                if int(s[i:]) > target:\\n                    break\\n                if helper(s[:i], target-int(s[i:])):\\n                    return True\\n            return False\\n                \\n        ret = 0\\n        for i in range(1, n+1):\\n            if helper(str(i*i), i):\\n                ret += i*i\\n        return ret\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556432,
                "title": "easy-to-understand-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def rec(self, i:int, array: list, partition_sum: int, total: int, number: int) -> bool:\\n        if total + partition_sum > number:\\n            return False\\n        if i == len(array):\\n            return total + partition_sum == number\\n        \\n        #include in previous partition\\n        if(self.rec(i+1, array, 10 * partition_sum + array[i], total, number)):\\n            return True\\n        \\n        #create new partition\\n        if(self.rec(i+1, array, array[i], total + partition_sum, number)):\\n            return True\\n        \\n        return False\\n        \\n    def punishmentNumber(self, n: int) -> int:\\n        punishment_number = 0\\n        \\n        for num in range(1, n+1):\\n            array = [int(digit) for digit in str(num * num)]\\n            \\n            if self.rec(0, array, 0, 0, num):\\n                print(num)\\n                punishment_number += num * num                \\n                \\n        return punishment_number\\n    \\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rec(self, i:int, array: list, partition_sum: int, total: int, number: int) -> bool:\\n        if total + partition_sum > number:\\n            return False\\n        if i == len(array):\\n            return total + partition_sum == number\\n        \\n        #include in previous partition\\n        if(self.rec(i+1, array, 10 * partition_sum + array[i], total, number)):\\n            return True\\n        \\n        #create new partition\\n        if(self.rec(i+1, array, array[i], total + partition_sum, number)):\\n            return True\\n        \\n        return False\\n        \\n    def punishmentNumber(self, n: int) -> int:\\n        punishment_number = 0\\n        \\n        for num in range(1, n+1):\\n            array = [int(digit) for digit in str(num * num)]\\n            \\n            if self.rec(0, array, 0, 0, num):\\n                print(num)\\n                punishment_number += num * num                \\n                \\n        return punishment_number\\n    \\n\\n        \\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3556324,
                "title": "c-recursion",
                "content": "```\\nclass Solution {\\n    bool isValid(const int i,const string strI,const int sz,int index, int rs){\\n        if (index == sz){\\n            return rs==i;\\n        }\\n        int cLen=0;\\n        int n = 0;\\n        while (rs+n<=i && index+cLen<sz){\\n            cLen++;\\n            n = stoi(strI.substr(index,cLen));\\n            if(isValid(i,strI,sz,index+cLen,rs+n)){\\n                return true;\\n            }\\n        }\\n        return false;\\n        \\n    }\\npublic:\\n    int punishmentNumber(int n) {\\n        int pn=0;\\n        for (int i=1;i<=n;i++){\\n            string s = to_string(i*i);\\n            if (isValid(i,s,s.size(),0,0)){\\n                pn += (i*i);\\n            }\\n        }\\n        return pn;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool isValid(const int i,const string strI,const int sz,int index, int rs){\\n        if (index == sz){\\n            return rs==i;\\n        }\\n        int cLen=0;\\n        int n = 0;\\n        while (rs+n<=i && index+cLen<sz){\\n            cLen++;\\n            n = stoi(strI.substr(index,cLen));\\n            if(isValid(i,strI,sz,index+cLen,rs+n)){\\n                return true;\\n            }\\n        }\\n        return false;\\n        \\n    }\\npublic:\\n    int punishmentNumber(int n) {\\n        int pn=0;\\n        for (int i=1;i<=n;i++){\\n            string s = to_string(i*i);\\n            if (isValid(i,s,s.size(),0,0)){\\n                pn += (i*i);\\n            }\\n        }\\n        return pn;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554905,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n\\n    private static var cache: [[[Int]]?] = Array(repeating: nil, count: 1000001)\\n\\n    private static func parts(_ n: Int) -> [[Int]] {\\n        \\n        if let c = cache[n] { return c }\\n\\n        var d = 10\\n        var res = [[n]]\\n\\n        while d < n {\\n            let l = parts(n / d)\\n            let r = parts(n % d)\\n\\n            res += l.flatMap { l in r.map { l + $0 }}\\n            d *= 10\\n        }\\n\\n        cache[n] = res\\n        return res\\n    }\\n\\n    private static let ii = (1...1000).filter { i in\\n        parts(i * i).map({ $0.reduce(0, +) }).contains(i)\\n    }\\n\\n    func punishmentNumber(_ n: Int) -> Int {\\n\\n        var res = 0\\n        var i = 0\\n\\n        while i < Self.ii.count, Self.ii[i] <= n {\\n            res += Self.ii[i] * Self.ii[i]\\n            i += 1\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\n    private static var cache: [[[Int]]?] = Array(repeating: nil, count: 1000001)\\n\\n    private static func parts(_ n: Int) -> [[Int]] {\\n        \\n        if let c = cache[n] { return c }\\n\\n        var d = 10\\n        var res = [[n]]\\n\\n        while d < n {\\n            let l = parts(n / d)\\n            let r = parts(n % d)\\n\\n            res += l.flatMap { l in r.map { l + $0 }}\\n            d *= 10\\n        }\\n\\n        cache[n] = res\\n        return res\\n    }\\n\\n    private static let ii = (1...1000).filter { i in\\n        parts(i * i).map({ $0.reduce(0, +) }).contains(i)\\n    }\\n\\n    func punishmentNumber(_ n: Int) -> Int {\\n\\n        var res = 0\\n        var i = 0\\n\\n        while i < Self.ii.count, Self.ii[i] <= n {\\n            res += Self.ii[i] * Self.ii[i]\\n            i += 1\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554245,
                "title": "easy-commented-explaination-in-c-string",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(2^log n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool canPartitioning(string s , int no){\\n if(s==\"\"&& no==0)return true;\\n  if(no<0)return false;\\n    for(int i = 0 ; i<s.size(); i++){\\n\\n        if(canPartitioning(s.substr(i+1), no-stoi(s.substr(0,i+1)))){ // if s = 1296 nd no is 36 have to make 36 by partioning so 1st (296, 35)-> solve by resn \\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n    int punishmentNumber(int n) {\\n      int sum = 0 ;\\n      for(int i = 1; i<=n; i++){\\n          int square = i*i;\\n          string substrg = to_string(square);\\n          if(canPartitioning(substrg , i)){\\n              sum += square; //adding square of it \\n          }\\n          \\n      } \\n      return sum; \\n    }\\n};\\n//what que expecting is tht if no is 2 then it square 2*2 ->4 now convet 4 to substring and check if we partitioning the square ito back the original no 2 thn we add thth no in answer add thth no saqure \\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool canPartitioning(string s , int no){\\n if(s==\"\"&& no==0)return true;\\n  if(no<0)return false;\\n    for(int i = 0 ; i<s.size(); i++){\\n\\n        if(canPartitioning(s.substr(i+1), no-stoi(s.substr(0,i+1)))){ // if s = 1296 nd no is 36 have to make 36 by partioning so 1st (296, 35)-> solve by resn \\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n    int punishmentNumber(int n) {\\n      int sum = 0 ;\\n      for(int i = 1; i<=n; i++){\\n          int square = i*i;\\n          string substrg = to_string(square);\\n          if(canPartitioning(substrg , i)){\\n              sum += square; //adding square of it \\n          }\\n          \\n      } \\n      return sum; \\n    }\\n};\\n//what que expecting is tht if no is 2 then it square 2*2 ->4 now convet 4 to substring and check if we partitioning the square ito back the original no 2 thn we add thth no in answer add thth no saqure \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554204,
                "title": "simple-recursion-cakewalk-beginner-s-friendly",
                "content": "```\\nbool isPossible(int i,string &s,int current,int num){\\n    // 1296;\\n    if(i>=s.size()){\\n        return (current==num);\\n    }\\n    int temp=0;\\n    for(int j=i;j<s.size();j++){\\n        temp=(temp*10)+(s[j]-\\'0\\');\\n        bool b= isPossible(j+1,s,current+temp,num);\\n        if(b) return true;\\n    }\\n    \\n    return false;\\n}\\n\\nbool isPunishmentNumber(int num){\\n    string s = to_string(num*num);\\n    return isPossible(0,s,0,num);\\n}\\n\\nclass Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n       int ans=1;\\n        for(int i=2;i<=n;i++){\\n            if(isPunishmentNumber(i))\\n                ans+=i*i;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n// 1296\\n// 1 + 29 + 6 -> 36,,, RETURN TRUE; // THIS IS TRUE RECURSION;\\n```",
                "solutionTags": [],
                "code": "```\\nbool isPossible(int i,string &s,int current,int num){\\n    // 1296;\\n    if(i>=s.size()){\\n        return (current==num);\\n    }\\n    int temp=0;\\n    for(int j=i;j<s.size();j++){\\n        temp=(temp*10)+(s[j]-\\'0\\');\\n        bool b= isPossible(j+1,s,current+temp,num);\\n        if(b) return true;\\n    }\\n    \\n    return false;\\n}\\n\\nbool isPunishmentNumber(int num){\\n    string s = to_string(num*num);\\n    return isPossible(0,s,0,num);\\n}\\n\\nclass Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n       int ans=1;\\n        for(int i=2;i<=n;i++){\\n            if(isPunishmentNumber(i))\\n                ans+=i*i;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n// 1296\\n// 1 + 29 + 6 -> 36,,, RETURN TRUE; // THIS IS TRUE RECURSION;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553508,
                "title": "python-backtracking",
                "content": "# Code\\n```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        def backtrack(i, target):\\n            # Given a string s and int target, return True if s can be partitioned into contiguous substrings s.t. sum of the integer\\n            # values of the substrings equals target.\\n            # Backtrack pruning: don\\'t need to consider splitting if splitting results in some number > target\\n            \\n            if i == len(s):\\n                if target == 0:\\n                    self.valid = True\\n                return\\n            \\n            for j in range(i + 1, len(s) + 1):\\n                # try to partition s[:j] and s[j:]\\n                left, right = s[i:j], s[i + j:]\\n                if int(left) <= target:\\n                    backtrack(j, target - int(left))\\n        \\n        res = 0\\n        for i in range(1, n + 1):\\n            self.valid = False\\n            s = str(i * i)\\n            backtrack(0, i)\\n            if self.valid:\\n                res += i * i\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        def backtrack(i, target):\\n            # Given a string s and int target, return True if s can be partitioned into contiguous substrings s.t. sum of the integer\\n            # values of the substrings equals target.\\n            # Backtrack pruning: don\\'t need to consider splitting if splitting results in some number > target\\n            \\n            if i == len(s):\\n                if target == 0:\\n                    self.valid = True\\n                return\\n            \\n            for j in range(i + 1, len(s) + 1):\\n                # try to partition s[:j] and s[j:]\\n                left, right = s[i:j], s[i + j:]\\n                if int(left) <= target:\\n                    backtrack(j, target - int(left))\\n        \\n        res = 0\\n        for i in range(1, n + 1):\\n            self.valid = False\\n            s = str(i * i)\\n            backtrack(0, i)\\n            if self.valid:\\n                res += i * i\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553170,
                "title": "recursive-approach-o-n-time-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(string num,int target){\\n        int n = num.length();\\n        if(target == 0 && num == \"\")\\n            return true;\\n        if(target < 0)\\n            return false;\\n        for(int i = 1;i <= n;i++){\\n            string a = num.substr(0,i);\\n            string b = num.substr(i);\\n            int x = stoi(a);\\n            if(check(b,target-x)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        for(int i = 1;i <= n;i++){\\n            if(check(to_string(i*i),i)){\\n                ans += i*i;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string num,int target){\\n        int n = num.length();\\n        if(target == 0 && num == \"\")\\n            return true;\\n        if(target < 0)\\n            return false;\\n        for(int i = 1;i <= n;i++){\\n            string a = num.substr(0,i);\\n            string b = num.substr(i);\\n            int x = stoi(a);\\n            if(check(b,target-x)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        for(int i = 1;i <= n;i++){\\n            if(check(to_string(i*i),i)){\\n                ans += i*i;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553117,
                "title": "2698-find-the-punishment-number-of-an-integer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nlet set\\nvar punishmentNumber = function (n) {\\n  function generateNumSeq() {\\n\\n    function isNum(s, i) {\\n      let yes = 0\\n      function dfs(start, sum) {\\n        if (yes) return\\n        if (start === s.length) {\\n          if (sum === +i) yes = 1\\n          return\\n        }\\n        for (let i = start + 1; i <= s.length; i++) {\\n          dfs(i, sum + +s.slice(start, i))\\n        }\\n      }\\n      dfs(0, 0)\\n      return yes\\n    }\\n\\n    set = new Set()\\n    for (let i = 1; i <= 1000; i++) {\\n      if (isNum(\\'\\' + i * i, i)) {\\n        set.add(i)\\n      }\\n    }\\n  }\\n\\n  if (!set) {\\n    generateNumSeq()\\n  }\\n\\n  let s = 0\\n  for (let i = 1; i <= n; i++) {\\n    if (set.has(i)) {\\n      s += i * i\\n    }\\n  }\\n  return s\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nlet set\\nvar punishmentNumber = function (n) {\\n  function generateNumSeq() {\\n\\n    function isNum(s, i) {\\n      let yes = 0\\n      function dfs(start, sum) {\\n        if (yes) return\\n        if (start === s.length) {\\n          if (sum === +i) yes = 1\\n          return\\n        }\\n        for (let i = start + 1; i <= s.length; i++) {\\n          dfs(i, sum + +s.slice(start, i))\\n        }\\n      }\\n      dfs(0, 0)\\n      return yes\\n    }\\n\\n    set = new Set()\\n    for (let i = 1; i <= 1000; i++) {\\n      if (isNum(\\'\\' + i * i, i)) {\\n        set.add(i)\\n      }\\n    }\\n  }\\n\\n  if (!set) {\\n    generateNumSeq()\\n  }\\n\\n  let s = 0\\n  for (let i = 1; i <= n; i++) {\\n    if (set.has(i)) {\\n      s += i * i\\n    }\\n  }\\n  return s\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3553007,
                "title": "c-easy-solution-recursion-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool find(int i,int j,int sum,string& t,vector<vector<int>>& v,int& no){\\n        if(j==t.size()){\\n            if(sum==no){\\n                return true;\\n            }\\n            return false;\\n        }\\n        bool par=0,not_par=0;\\n        par=find(j+1,j+1,sum+v[i][j],t,v,no);\\n        if(j!=t.size()-1){\\n            not_par=find(i,j+1,sum,t,v,no);\\n        }\\n         return par|not_par;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            int no=i*i,temp=i*i;\\n            string t=to_string(no);\\n           \\n            vector<vector<int>> v(t.size(),vector<int>(t.size()));\\n            for(int k=0;k<t.size();k++){\\n                int sum=0;\\n                for(int j=k;j<t.size();j++){\\n                    sum=sum*10+(t[j]-\\'0\\');\\n                    v[k][j]=sum;\\n                }\\n            }\\n            bool flag=find(0,0,0,t,v,i);\\n            if(flag){\\n                ans+=temp;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find(int i,int j,int sum,string& t,vector<vector<int>>& v,int& no){\\n        if(j==t.size()){\\n            if(sum==no){\\n                return true;\\n            }\\n            return false;\\n        }\\n        bool par=0,not_par=0;\\n        par=find(j+1,j+1,sum+v[i][j],t,v,no);\\n        if(j!=t.size()-1){\\n            not_par=find(i,j+1,sum,t,v,no);\\n        }\\n         return par|not_par;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            int no=i*i,temp=i*i;\\n            string t=to_string(no);\\n           \\n            vector<vector<int>> v(t.size(),vector<int>(t.size()));\\n            for(int k=0;k<t.size();k++){\\n                int sum=0;\\n                for(int j=k;j<t.size();j++){\\n                    sum=sum*10+(t[j]-\\'0\\');\\n                    v[k][j]=sum;\\n                }\\n            }\\n            bool flag=find(0,0,0,t,v,i);\\n            if(flag){\\n                ans+=temp;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552784,
                "title": "c-recursion",
                "content": "# Code\\n```\\nclass Solution {\\n    void compute(string toForm, int &match, int temp, bool &satisfy) {\\n        if(toForm == \"\") {\\n            if(temp == match) {\\n                satisfy = true;\\n                return;\\n            }\\n        }\\n        for(int i = 1; i <= toForm.length(); i++) {\\n            compute(toForm.substr(i), match, temp + stoi(toForm.substr(0, i)), satisfy);\\n        }\\n    }\\npublic:\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        for(int i = 1; i <= n; i++) {\\n            bool satisfy = false;\\n            compute(to_string(i * i), i, 0, satisfy); \\n            if(satisfy)\\n                ans += i * i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    void compute(string toForm, int &match, int temp, bool &satisfy) {\\n        if(toForm == \"\") {\\n            if(temp == match) {\\n                satisfy = true;\\n                return;\\n            }\\n        }\\n        for(int i = 1; i <= toForm.length(); i++) {\\n            compute(toForm.substr(i), match, temp + stoi(toForm.substr(0, i)), satisfy);\\n        }\\n    }\\npublic:\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        for(int i = 1; i <= n; i++) {\\n            bool satisfy = false;\\n            compute(to_string(i * i), i, 0, satisfy); \\n            if(satisfy)\\n                ans += i * i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552447,
                "title": "java-backtracking-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int res = 0;\\n        for(int i = 1; i <= n; i++)\\n            if(f(0, String.valueOf(i*i), i, 0))\\n                res += i * i;\\n        return res;\\n    }\\n    \\n    boolean f(int i, String s, int ori, int temp){\\n        if(i == s.length()) \\n            if(ori == temp)\\n                return true;\\n        int n = s.length(); \\n        for(int j = i; j < n; j++){\\n             if(j + 1 <= n){\\n                String t = s.substring(i, j + 1);\\n                int x = Integer.valueOf(t);\\n                if(temp + x <= ori && f(j + 1, s, ori, temp + x))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int res = 0;\\n        for(int i = 1; i <= n; i++)\\n            if(f(0, String.valueOf(i*i), i, 0))\\n                res += i * i;\\n        return res;\\n    }\\n    \\n    boolean f(int i, String s, int ori, int temp){\\n        if(i == s.length()) \\n            if(ori == temp)\\n                return true;\\n        int n = s.length(); \\n        for(int j = i; j < n; j++){\\n             if(j + 1 <= n){\\n                String t = s.substring(i, j + 1);\\n                int x = Integer.valueOf(t);\\n                if(temp + x <= ori && f(j + 1, s, ori, temp + x))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552400,
                "title": "a-few-solutions",
                "content": "Peform DFS to consider all possibilities for each `i`<sup>th</sup> candidate from `i = 1..N` inclusive, ie. given the string `s` representation of `i * i` we consider all substrings of length `k` as integer candidates, attempting to recursively `go` create total `t` sum to reach each `i`<sup>th</sup> `target`.  If we can recursively `go` reach an `i`<sup>th</sup> `target`, then we add `i * i` onto the accumulated answer to be returned.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun punishmentNumber(N: Int): Int {\\n        fun go(s: String, target: Int, i: Int = 0, t: Int = 0): Boolean {\\n            if (i == s.length)\\n                return t == target\\n            for (k in 1..s.length)\\n                if (i + k <= s.length && go(s, target, i + k, t + s.substring(i, i + k).toInt()))\\n                    return true\\n            return false\\n        }\\n        return (1..N).map{ if (go(\"${it * it}\", it)) it * it else 0 }.sum()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet punishmentNumber = N => {\\n    let go = (s, target, i = 0, t = 0) => {\\n        if (i == s.length)\\n            return t == target;\\n        for (let k = 1; k <= s.length; ++k)\\n            if (i + k <= s.length && go(s, target, i + k, t + Number(s.slice(i, i + k))))\\n                return true;\\n        return false;\\n    };\\n    return _.sum([...Array(N).keys()].map(i => i + 1).map(i => go(`${i * i}`, i) ? i * i : 0));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def punishmentNumber(self, N: int) -> int:\\n        def go(s, target, i = 0, t = 0):\\n            if i == len(s):\\n                return t == target\\n            for k in range(1, len(s) + 1):\\n                if i + k <= len(s) and go(s, target, i + k, t + int(s[i:i + k])):\\n                    return True\\n            return False\\n        return sum(i * i for i in range(1, N + 1) if go(str(i * i), i))\\n```\\n\\n*Rust*\\n```\\nimpl Solution {\\n    pub fn punishment_number(N: i32) -> i32 {\\n        fn go(s: &String, target: i32, i: usize, t: i32) -> bool {\\n            if i == s.len() {\\n                return t == target;\\n            }\\n            for k in 1..=s.len() {\\n                if i + k <= s.len() && go(s, target, i + k, t + s[i..i + k].parse::<i32>().unwrap()) {\\n                    return true;\\n                }\\n            }\\n            false\\n        }\\n        (1..=N).map(|i| if go(&(i * i).to_string(), i, 0, 0) { i * i } else { 0 }).sum::<i32>()\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using fun = function<bool(string&&, int, int, int)>;\\n    int punishmentNumber(int N, int t = 0) {\\n        fun go = [&](auto&& s, auto target, auto i, auto t) {\\n            if (i == s.size()) {\\n                return t == target;\\n            }\\n            for (auto k{ 1 }; k <= s.size(); ++k)\\n                if (i + k <= s.size() && go(move(s), target, i + k, t + stoi(s.substr(i, k))))\\n                    return true;\\n            return false;\\n        };\\n        for (auto i{ 1 }; i <= N; ++i)\\n            if (go(to_string(i * i), i, 0, 0))\\n                t += i * i;\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun punishmentNumber(N: Int): Int {\\n        fun go(s: String, target: Int, i: Int = 0, t: Int = 0): Boolean {\\n            if (i == s.length)\\n                return t == target\\n            for (k in 1..s.length)\\n                if (i + k <= s.length && go(s, target, i + k, t + s.substring(i, i + k).toInt()))\\n                    return true\\n            return false\\n        }\\n        return (1..N).map{ if (go(\"${it * it}\", it)) it * it else 0 }.sum()\\n    }\\n}\\n```\n```\\nlet punishmentNumber = N => {\\n    let go = (s, target, i = 0, t = 0) => {\\n        if (i == s.length)\\n            return t == target;\\n        for (let k = 1; k <= s.length; ++k)\\n            if (i + k <= s.length && go(s, target, i + k, t + Number(s.slice(i, i + k))))\\n                return true;\\n        return false;\\n    };\\n    return _.sum([...Array(N).keys()].map(i => i + 1).map(i => go(`${i * i}`, i) ? i * i : 0));\\n};\\n```\n```\\nclass Solution:\\n    def punishmentNumber(self, N: int) -> int:\\n        def go(s, target, i = 0, t = 0):\\n            if i == len(s):\\n                return t == target\\n            for k in range(1, len(s) + 1):\\n                if i + k <= len(s) and go(s, target, i + k, t + int(s[i:i + k])):\\n                    return True\\n            return False\\n        return sum(i * i for i in range(1, N + 1) if go(str(i * i), i))\\n```\n```\\nimpl Solution {\\n    pub fn punishment_number(N: i32) -> i32 {\\n        fn go(s: &String, target: i32, i: usize, t: i32) -> bool {\\n            if i == s.len() {\\n                return t == target;\\n            }\\n            for k in 1..=s.len() {\\n                if i + k <= s.len() && go(s, target, i + k, t + s[i..i + k].parse::<i32>().unwrap()) {\\n                    return true;\\n                }\\n            }\\n            false\\n        }\\n        (1..=N).map(|i| if go(&(i * i).to_string(), i, 0, 0) { i * i } else { 0 }).sum::<i32>()\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<bool(string&&, int, int, int)>;\\n    int punishmentNumber(int N, int t = 0) {\\n        fun go = [&](auto&& s, auto target, auto i, auto t) {\\n            if (i == s.size()) {\\n                return t == target;\\n            }\\n            for (auto k{ 1 }; k <= s.size(); ++k)\\n                if (i + k <= s.size() && go(move(s), target, i + k, t + stoi(s.substr(i, k))))\\n                    return true;\\n            return false;\\n        };\\n        for (auto i{ 1 }; i <= N; ++i)\\n            if (go(to_string(i * i), i, 0, 0))\\n                t += i * i;\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551843,
                "title": "c-simple-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int i, int sum, int pre, string str, int target){\\n        if(i == str.size()) return pre + sum == target;\\n\\n        bool used = check(i + 1, sum, pre * 10 + (str[i] - \\'0\\'), str, target);\\n        bool not_used = check(i + 1, sum + pre, str[i] - \\'0\\', str, target);\\n        return used || not_used;\\n\\n    }\\n\\n    int punishmentNumber(int n) {\\n        int res = 1;\\n        for(int i = 2; i <= n; i++){\\n            string s_tmp = to_string(i * i);\\n            bool flag = check(1, 0, s_tmp[0] - \\'0\\', s_tmp, i);\\n            if(flag) res += i * i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int i, int sum, int pre, string str, int target){\\n        if(i == str.size()) return pre + sum == target;\\n\\n        bool used = check(i + 1, sum, pre * 10 + (str[i] - \\'0\\'), str, target);\\n        bool not_used = check(i + 1, sum + pre, str[i] - \\'0\\', str, target);\\n        return used || not_used;\\n\\n    }\\n\\n    int punishmentNumber(int n) {\\n        int res = 1;\\n        for(int i = 2; i <= n; i++){\\n            string s_tmp = to_string(i * i);\\n            bool flag = check(1, 0, s_tmp[0] - \\'0\\', s_tmp, i);\\n            if(flag) res += i * i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551640,
                "title": "kotlin-most-optimal-solution-with-explanation",
                "content": "# Approach\\nWe loop `i` in `1` to `n`, check for each `i` if `i^2` (call it `x`) can sum up to target `i`. We check this statement by recursive calls, until we found basecase of where `x` equals remainder of target `target`, which by then we should have succesfully summed up to original target (`i`) with this last `x` in our recursive calls.\\n\\nWe also have to in our recursive calls continuosly check if we reached over target sum with `target < 0` or if we reached a x which it is impossible to sum up to target `x < target`\\n\\nTime complexity is $O(n*log(n))$ and space complexity is $log(n)$, but we have to consider since $1 <= n^2 <= 10^6$ that gives us $max(log_{10}(n)) = log_{10}10^6 = 6$ so that means that we might even consider this as having a time complexity of $O(n)$ and space complexity of $O(1)$ (max $log(n)$ calls). I would love to hear your opinion on the time complexity.\\n\\n# Code\\n```\\nclass Solution {\\n    fun punishmentNumber(n: Int): Int {\\n        \\n        fun partition(x: Int, target: Int): Boolean {\\n            if (x == target)\\n                return true\\n            if (target < 0 || x < target )\\n                return false\\n\\n            return partition(x / 10, target - (x % 10)) ||\\n                partition(x / 100, target - (x % 100)) ||\\n                partition(x / 1000, target - (x % 1000))\\n        }\\n        \\n        var res = 0\\n        for (i in 1..n) {\\n            val iSq = i * i\\n            if (partition(iSq, i))\\n                res += iSq\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun punishmentNumber(n: Int): Int {\\n        \\n        fun partition(x: Int, target: Int): Boolean {\\n            if (x == target)\\n                return true\\n            if (target < 0 || x < target )\\n                return false\\n\\n            return partition(x / 10, target - (x % 10)) ||\\n                partition(x / 100, target - (x % 100)) ||\\n                partition(x / 1000, target - (x % 1000))\\n        }\\n        \\n        var res = 0\\n        for (i in 1..n) {\\n            val iSq = i * i\\n            if (partition(iSq, i))\\n                res += iSq\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551632,
                "title": "c-dp-solution-easy-to-understand-clean-code",
                "content": "# Approach\\nGenerate all possible partitions of the square of that number and try to make sum of partition numbers equal to the original number.\\n\\n# Complexity\\n- Time complexity:\\nO(n * length(n*n) * n);\\n\\n- Space complexity:\\nO(length(n*n) * n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool func(int it, string & no, int totsum, vector<vector<int>>&dp){\\n        if(it == no.size()){\\n            return totsum == 0;\\n        }\\n\\n        if(dp[it][totsum]!=-1)return dp[it][totsum];\\n\\n        for(int j= it; j<no.size(); j++){\\n            string curr = string(no.begin()+it, no.begin()+j+1);\\n            int currno = stoi(curr);\\n            if(currno<=totsum){\\n                if(func(j+1,no,totsum-currno,dp)){\\n                    return dp[it][totsum] = true;\\n                }\\n            }\\n\\n            else{\\n                break;\\n            }\\n        }\\n\\n        return dp[it][totsum] = false;\\n    }\\n\\n    int func(int&currno, int i){\\n        string no = to_string(currno);\\n        vector<vector<int>>dp(no.size(),vector<int>(i+1,-1));\\n        return func(0,no,i,dp);\\n    }\\n\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        for(int i = 1; i<=n; i++){\\n            int currno = i*i;\\n            if(func(currno,i)){\\n                ans+=currno;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool func(int it, string & no, int totsum, vector<vector<int>>&dp){\\n        if(it == no.size()){\\n            return totsum == 0;\\n        }\\n\\n        if(dp[it][totsum]!=-1)return dp[it][totsum];\\n\\n        for(int j= it; j<no.size(); j++){\\n            string curr = string(no.begin()+it, no.begin()+j+1);\\n            int currno = stoi(curr);\\n            if(currno<=totsum){\\n                if(func(j+1,no,totsum-currno,dp)){\\n                    return dp[it][totsum] = true;\\n                }\\n            }\\n\\n            else{\\n                break;\\n            }\\n        }\\n\\n        return dp[it][totsum] = false;\\n    }\\n\\n    int func(int&currno, int i){\\n        string no = to_string(currno);\\n        vector<vector<int>>dp(no.size(),vector<int>(i+1,-1));\\n        return func(0,no,i,dp);\\n    }\\n\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        for(int i = 1; i<=n; i++){\\n            int currno = i*i;\\n            if(func(currno,i)){\\n                ans+=currno;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551382,
                "title": "easy-recursion-partition-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Explore the all possible way , eg . do all possible partition is any of the partition matches the required conditoin return 1 \\n- and if `f` return 1 mean we need to include the sq of the nunber in answer .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- (N*2^log10(N)) ==> 1|0|0|0|0|0|0  | places to do seperation .\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     // Algorithm:\\n    // For each number from 1 to n, square it and multiply by the result of function f\\n    // f recursively checks if the given number n can be formed by a subset of digits from the square of i\\n    // It does this by generating all possible partitions of the digits in the square of i\\n    // If any subset is equal to n, return 1 to indicate that n can be formed\\n    // If no subset is equal to n, return 0 to indicate that n cannot be formed.\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        \\n        for (int i = 1; i < n + 1; i++) {\\n            ans += f(i * i, i) * (i * i);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int f(int sq, int n) {\\n        // Base cases:\\n        // If n becomes negative, it means the subset of digits taken so far exceeds n, so it\\'s not possible to form n\\n        // If n becomes equal to sq, it means exactly n can be formed using the digits in sq, so return 1\\n        if (n < 0) {\\n            return 0;\\n        }\\n        \\n        if (n == sq) {\\n            return 1;\\n        }\\n        \\n        int nt = sq;\\n        int temp1 = 0;\\n        int tp = 10;\\n        \\n        while (nt != 0) {\\n            temp1 = sq % tp;\\n            nt /= 10;\\n            tp *= 10;\\n            int alpha = f(nt, n - temp1);\\n            \\n            // If the recursive call to f returns 1, it means n can be formed from a subset of digits,\\n            // so return 1 to indicate that n can be formed\\n            if (alpha == 1) {\\n                return 1;\\n            }\\n        }\\n        \\n        // If none of the subsets of digits can form n, return 0\\n        return 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     // Algorithm:\\n    // For each number from 1 to n, square it and multiply by the result of function f\\n    // f recursively checks if the given number n can be formed by a subset of digits from the square of i\\n    // It does this by generating all possible partitions of the digits in the square of i\\n    // If any subset is equal to n, return 1 to indicate that n can be formed\\n    // If no subset is equal to n, return 0 to indicate that n cannot be formed.\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n        \\n        for (int i = 1; i < n + 1; i++) {\\n            ans += f(i * i, i) * (i * i);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int f(int sq, int n) {\\n        // Base cases:\\n        // If n becomes negative, it means the subset of digits taken so far exceeds n, so it\\'s not possible to form n\\n        // If n becomes equal to sq, it means exactly n can be formed using the digits in sq, so return 1\\n        if (n < 0) {\\n            return 0;\\n        }\\n        \\n        if (n == sq) {\\n            return 1;\\n        }\\n        \\n        int nt = sq;\\n        int temp1 = 0;\\n        int tp = 10;\\n        \\n        while (nt != 0) {\\n            temp1 = sq % tp;\\n            nt /= 10;\\n            tp *= 10;\\n            int alpha = f(nt, n - temp1);\\n            \\n            // If the recursive call to f returns 1, it means n can be formed from a subset of digits,\\n            // so return 1 to indicate that n can be formed\\n            if (alpha == 1) {\\n                return 1;\\n            }\\n        }\\n        \\n        // If none of the subsets of digits can form n, return 0\\n        return 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551126,
                "title": "dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBuild a DFS with current number and the target.\\n\\n# Complexity\\n- Time complexity: O(n+m) for the DFS. Technically lesser since we are pruning the trees.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nI\\'m not very sure. Still thinking about it. Sorry.\\n\\n# Code\\n```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        result = 0\\n\\n        def checkTarget(num, target):\\n            # When the DFS solution is found\\n            if num == target:\\n                return True\\n\\n            # When DFS reached a leaf node\\n            if num == 0:\\n                return False\\n\\n            # Array of Digits\\n            arr = [int(d) for d in str(num)]\\n            \\n            cur = 0\\n            for i in range(len(arr)):\\n                # Building current left sub-number\\n                cur = arr[i] + cur * 10\\n\\n                temp = 0\\n                # Building the right sub-number\\n                for j in range(i + 1, len(arr)):\\n                    temp = arr[j] + temp * 10\\n                \\n                # Pruning the tree in case of -ve targets\\n                if target - cur < 0:\\n                    break\\n\\n                # Recursive call\\n                if checkTarget(temp, target - cur):\\n                    return True\\n\\n            # When soln. wasn\\'t found in the current subtree.\\n            return False\\n\\n        for i in range(1, n + 1):\\n            print(i)\\n            if checkTarget(i * i, i):\\n                # print(i*i)\\n                result += i * i\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        result = 0\\n\\n        def checkTarget(num, target):\\n            # When the DFS solution is found\\n            if num == target:\\n                return True\\n\\n            # When DFS reached a leaf node\\n            if num == 0:\\n                return False\\n\\n            # Array of Digits\\n            arr = [int(d) for d in str(num)]\\n            \\n            cur = 0\\n            for i in range(len(arr)):\\n                # Building current left sub-number\\n                cur = arr[i] + cur * 10\\n\\n                temp = 0\\n                # Building the right sub-number\\n                for j in range(i + 1, len(arr)):\\n                    temp = arr[j] + temp * 10\\n                \\n                # Pruning the tree in case of -ve targets\\n                if target - cur < 0:\\n                    break\\n\\n                # Recursive call\\n                if checkTarget(temp, target - cur):\\n                    return True\\n\\n            # When soln. wasn\\'t found in the current subtree.\\n            return False\\n\\n        for i in range(1, n + 1):\\n            print(i)\\n            if checkTarget(i * i, i):\\n                # print(i*i)\\n                result += i * i\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551067,
                "title": "back-tracking-with-memoization-and-binary-search-for-optimization",
                "content": "# Intuition\\nNote: This approach is not thread-safe.\\n\\n# Approach\\nBasic Approach is to iterate from 1 to n and check each square using backtracking.\\n\\nMemoization with binary search is added to optimize for repeated calls.\\n\\n# Complexity\\n- Time complexity:\\n$O(n)$ once for largest n, $O(log(n))$ otherwise.\\n\\n- Space complexity:\\n$O(n)$ for the memoization;\\n\\n# Code\\n```\\npublic class Solution {\\n    private MemoPunishment memo;\\n    \\n    public int PunishmentNumber(int n) {\\n        if (memo == null) {\\n            memo = new MemoPunishment();\\n        }\\n        return memo.punishSum(n);\\n    }\\n\\n    private class MemoPunishment {\\n        private int alreadyCalculated;\\n        private List<(int i, int sum)> prefixMemo;\\n\\n        public MemoPunishment() {\\n            this.alreadyCalculated = 0;\\n            this.prefixMemo = new List<(int, int)>();\\n            this.prefixMemo.Add((0, 0));\\n        }\\n\\n        public int punishSum(int n) {\\n            CalculateMore(n);\\n            int target = BinarySearch(n);\\n            return prefixMemo[target].sum;\\n        }\\n\\n        private void CalculateMore(int n) {\\n            int square;\\n            for (int i = this.alreadyCalculated + 1; i <= n; ++i) {\\n                square = i * i;\\n                if (BackTracking(square, i)) {\\n                    this.prefixMemo.Add((i, square + this.prefixMemo[this.prefixMemo.Count - 1].sum));\\n                }\\n            }\\n            this.alreadyCalculated = n;\\n        }\\n\\n        private bool BackTracking(int num, int target) {\\n            if (num == target) {\\n                return true;\\n            } else if (num < 10 || target < 0) {\\n                return false;\\n            }\\n            int mod = 10;\\n            while (mod < num) {\\n                if (BackTracking(num % mod, target - num / mod)) {\\n                    return true;\\n                }\\n                mod *= 10;\\n            }\\n            return false;\\n        }\\n\\n        private int BinarySearch(int n) {\\n            int low, mid, high;\\n            low = 0; high = this.prefixMemo.Count - 1;\\n            while (low < high) {\\n                mid = low + (high - low) / 2 + 1;\\n                if (this.prefixMemo[mid].i <= n) {\\n                    low = mid;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n            return low;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    private MemoPunishment memo;\\n    \\n    public int PunishmentNumber(int n) {\\n        if (memo == null) {\\n            memo = new MemoPunishment();\\n        }\\n        return memo.punishSum(n);\\n    }\\n\\n    private class MemoPunishment {\\n        private int alreadyCalculated;\\n        private List<(int i, int sum)> prefixMemo;\\n\\n        public MemoPunishment() {\\n            this.alreadyCalculated = 0;\\n            this.prefixMemo = new List<(int, int)>();\\n            this.prefixMemo.Add((0, 0));\\n        }\\n\\n        public int punishSum(int n) {\\n            CalculateMore(n);\\n            int target = BinarySearch(n);\\n            return prefixMemo[target].sum;\\n        }\\n\\n        private void CalculateMore(int n) {\\n            int square;\\n            for (int i = this.alreadyCalculated + 1; i <= n; ++i) {\\n                square = i * i;\\n                if (BackTracking(square, i)) {\\n                    this.prefixMemo.Add((i, square + this.prefixMemo[this.prefixMemo.Count - 1].sum));\\n                }\\n            }\\n            this.alreadyCalculated = n;\\n        }\\n\\n        private bool BackTracking(int num, int target) {\\n            if (num == target) {\\n                return true;\\n            } else if (num < 10 || target < 0) {\\n                return false;\\n            }\\n            int mod = 10;\\n            while (mod < num) {\\n                if (BackTracking(num % mod, target - num / mod)) {\\n                    return true;\\n                }\\n                mod *= 10;\\n            }\\n            return false;\\n        }\\n\\n        private int BinarySearch(int n) {\\n            int low, mid, high;\\n            low = 0; high = this.prefixMemo.Count - 1;\\n            while (low < high) {\\n                mid = low + (high - low) / 2 + 1;\\n                if (this.prefixMemo[mid].i <= n) {\\n                    low = mid;\\n                } else {\\n                    high = mid - 1;\\n                }\\n            }\\n            return low;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550921,
                "title": "static-dp-recursion-solution-explained-java-solution-beats-100",
                "content": "Calculate all substrings of the given number and keep track of their sum using recursion and return true if the desired sum is found.\\nUse \\'prev\\' variable to keep track of the range for which punishment integers have already been calculated and use \\'check\\' to keep track of them.Start calculations from the new prev value.\\n\\n```\\n static int prev=1;\\n static int[] check=new int[1001];\\n    \\n    static boolean find(StringBuilder sb,int curr,int sum,int n)\\n    {\\n        if(curr==sb.length())\\n        {\\n            if(sum==n) return true;\\n            return false;\\n        }\\n        \\n        for(int i=curr;i<=sb.length()-1;i++)\\n        {\\n            boolean ans= find(sb,i+1, sum+Integer.parseInt(sb.substring(curr,i+1)),n );\\n            if(ans) return true;\\n        }\\n        return false;\\n    }\\n    public int punishmentNumber(int n) {\\n        \\n        while(prev<=n)\\n        {\\n            if(find(new StringBuilder(prev*prev+\"\"),0,0,prev))\\n                check[prev]++;\\n            prev++;\\n        }\\n        \\n        int ans=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(check[i]==1)\\n            ans+=i*i;\\n        }\\n        return ans;\\n    }\\n```\\nDo let me know if further modifications can be made.",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n static int prev=1;\\n static int[] check=new int[1001];\\n    \\n    static boolean find(StringBuilder sb,int curr,int sum,int n)\\n    {\\n        if(curr==sb.length())\\n        {\\n            if(sum==n) return true;\\n            return false;\\n        }\\n        \\n        for(int i=curr;i<=sb.length()-1;i++)\\n        {\\n            boolean ans= find(sb,i+1, sum+Integer.parseInt(sb.substring(curr,i+1)),n );\\n            if(ans) return true;\\n        }\\n        return false;\\n    }\\n    public int punishmentNumber(int n) {\\n        \\n        while(prev<=n)\\n        {\\n            if(find(new StringBuilder(prev*prev+\"\"),0,0,prev))\\n                check[prev]++;\\n            prev++;\\n        }\\n        \\n        int ans=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(check[i]==1)\\n            ans+=i*i;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3550849,
                "title": "oeis-sequence-number-a038206-for-fun",
                "content": "# Intuition\\nReminded me of a sequence I saw in the online encyclopedia of integer sequences.\\n\\n# Approach\\nThe recursive approach has been discussed in length by the other solutions - this one is for fun.\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$ - the sequnce is constant\\n\\n- Space complexity:\\n$$O(1)$$ - the sequnce is constant\\n\\n# Code\\n```\\nclass Solution {\\n    static int[] seq = {1, 9, 10, 36, 45, \\n                        55, 82, 91, 99, 100, \\n                        235, 297, 369, 370, \\n                        379, 414, 657, 675, \\n                        703, 756, 792, 909, \\n                        918, 945, 964, 990, \\n                        991, 999, 1000};\\n    \\n    public int punishmentNumber(int n) {\\n        int sum = 0, i = 0;\\n        while(i < seq.length && seq[i] <= n) {\\n            sum += seq[i] * seq[i];\\n            ++i;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int[] seq = {1, 9, 10, 36, 45, \\n                        55, 82, 91, 99, 100, \\n                        235, 297, 369, 370, \\n                        379, 414, 657, 675, \\n                        703, 756, 792, 909, \\n                        918, 945, 964, 990, \\n                        991, 999, 1000};\\n    \\n    public int punishmentNumber(int n) {\\n        int sum = 0, i = 0;\\n        while(i < seq.length && seq[i] <= n) {\\n            sum += seq[i] * seq[i];\\n            ++i;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550255,
                "title": "python-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        res = 0\\n        def isDecimalRepresentation(i, square, s):\\n            if i == len(square) and s == num:\\n                return True\\n            for j in range(i, len(square)):\\n                if isDecimalRepresentation(j + 1, square, s + int(square[i:j + 1])):\\n                    return True\\n        for num in range(1, n + 1):\\n            if isDecimalRepresentation(0, str(num * num), 0):\\n                res += num * num\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        res = 0\\n        def isDecimalRepresentation(i, square, s):\\n            if i == len(square) and s == num:\\n                return True\\n            for j in range(i, len(square)):\\n                if isDecimalRepresentation(j + 1, square, s + int(square[i:j + 1])):\\n                    return True\\n        for num in range(1, n + 1):\\n            if isDecimalRepresentation(0, str(num * num), 0):\\n                res += num * num\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550110,
                "title": "using-recursion-to-solve",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        result = 0\\n        for i in range(1, n + 1):\\n            num_str = str(i * i)\\n            if self.is_valid_partition(num_str, i):\\n                result += i * i\\n        return result\\n\\n\\n    def is_valid_partition(self, num_str, target): # (100, 10)\\n        if target == 0:\\n            return len(num_str) == 0 or int(num_str) == 0\\n        for i in range(1, len(num_str) + 1): # i=1, 2, 3\\n            if self.is_valid_partition(num_str[i:], target - int(num_str[:i])): # \\n                return True\\n        return False\\n\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        result = 0\\n        for i in range(1, n + 1):\\n            num_str = str(i * i)\\n            if self.is_valid_partition(num_str, i):\\n                result += i * i\\n        return result\\n\\n\\n    def is_valid_partition(self, num_str, target): # (100, 10)\\n        if target == 0:\\n            return len(num_str) == 0 or int(num_str) == 0\\n        for i in range(1, len(num_str) + 1): # i=1, 2, 3\\n            if self.is_valid_partition(num_str[i:], target - int(num_str[:i])): # \\n                return True\\n        return False\\n\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550054,
                "title": "rust-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N * N * Log N * Log N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N * Log N)\\n# Code\\n```\\nimpl Solution {\\n    pub fn punishment_number(n: i32) -> i32 {\\n        let mut ret = 0;\\n        for a in 1 ..= n {\\n            if Self::valid(a) { ret += a * a; } \\n        }\\n        ret\\n    }\\n\\n    fn valid(a: i32) -> bool {\\n        let n = a as usize + 1;\\n        let mut temp = a * a;\\n        let mut d = vec![];\\n\\n        while temp > 0 {\\n            d.push(temp % 10);\\n            temp /= 10;\\n        }\\n        d.reverse();\\n\\n        let m = d.len(); \\n        let mut dp = vec![vec![-1; n]; m];\\n\\n        Self::cal(&mut dp, &d, m - 1, n - 1) == 1\\n    } \\n\\n    fn cal(dp: &mut Vec<Vec<i32>>, d: &Vec<i32>, i: usize, j: usize) -> i32 {\\n        if dp[i][j] != -1 { return dp[i][j] }\\n\\n        let (mut base, mut a) = (1, 0);\\n        for k in (0 ..= i).rev() {\\n            a += base * d[k];\\n            base *= 10;\\n            if k == 0 {\\n                if a as usize == j { dp[i][j] = 1; }\\n                break\\n            }\\n            if a as usize >= j { break }\\n            if Self::cal(dp, d, k - 1, j - a as usize) == 1 { dp[i][j] = 1 }\\n        }\\n        if dp[i][j] != 1 { dp[i][j] = 0; }\\n        dp[i][j]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn punishment_number(n: i32) -> i32 {\\n        let mut ret = 0;\\n        for a in 1 ..= n {\\n            if Self::valid(a) { ret += a * a; } \\n        }\\n        ret\\n    }\\n\\n    fn valid(a: i32) -> bool {\\n        let n = a as usize + 1;\\n        let mut temp = a * a;\\n        let mut d = vec![];\\n\\n        while temp > 0 {\\n            d.push(temp % 10);\\n            temp /= 10;\\n        }\\n        d.reverse();\\n\\n        let m = d.len(); \\n        let mut dp = vec![vec![-1; n]; m];\\n\\n        Self::cal(&mut dp, &d, m - 1, n - 1) == 1\\n    } \\n\\n    fn cal(dp: &mut Vec<Vec<i32>>, d: &Vec<i32>, i: usize, j: usize) -> i32 {\\n        if dp[i][j] != -1 { return dp[i][j] }\\n\\n        let (mut base, mut a) = (1, 0);\\n        for k in (0 ..= i).rev() {\\n            a += base * d[k];\\n            base *= 10;\\n            if k == 0 {\\n                if a as usize == j { dp[i][j] = 1; }\\n                break\\n            }\\n            if a as usize >= j { break }\\n            if Self::cal(dp, d, k - 1, j - a as usize) == 1 { dp[i][j] = 1 }\\n        }\\n        if dp[i][j] != 1 { dp[i][j] = 0; }\\n        dp[i][j]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3550026,
                "title": "python-recursion",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTry all partitions recursively and check if total can be reached which is equal to the square root of the original number.\\n\\n# Code\\n```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        count = 0\\n        for j in range(1, n + 1):\\n            s = str(j * j)\\n            total = 0\\n            @cache\\n            def rec(s, total):\\n                if s == \"\" and total == j:\\n                    return True\\n                \\n                for i in range(len(s)):\\n                    val = int(s[:i + 1])\\n                    if rec(s[i + 1:], total + val):\\n                        return True\\n                return False                \\n            if rec(s, total):\\n                count += int(s)\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def punishmentNumber(self, n: int) -> int:\\n        count = 0\\n        for j in range(1, n + 1):\\n            s = str(j * j)\\n            total = 0\\n            @cache\\n            def rec(s, total):\\n                if s == \"\" and total == j:\\n                    return True\\n                \\n                for i in range(len(s)):\\n                    val = int(s[:i + 1])\\n                    if rec(s[i + 1:], total + val):\\n                        return True\\n                return False                \\n            if rec(s, total):\\n                count += int(s)\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550002,
                "title": "java-easy-to-follow-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSome sort of DP need to be used. May not be able to save any state depending on index since each attempt is separate.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse DP and add them to a list. Finally use the list to compute result.\\nOne thing is that -- you cannot use any sort of map or array to store the result. Since each combination i.e., for 1296 if you are trying 1 + 2 + 9 + 6, 1 + 20 + 6 = 36. The result of one path does not carry over to the next path. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n n * O(2^len) where len is the length of the number of digits in square of the number. The n-times is because we have to check it for each number up until n. \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nStack space to keep track of the recursion. O(2^n) at worst.\\n# Code\\n```\\nclass Solution {\\n    List<Integer> spc;\\n    public int punishmentNumber(int n) {\\n        spc = new ArrayList<>();\\n        \\n        for(int i = 1; i <= n; i++){\\n            if (isSpecial(i))\\n                spc.add(i);\\n        }\\n        \\n        int rslt = 0;\\n        for(int i = 0; i < spc.size(); i++){\\n            rslt += spc.get(i) * spc.get(i);\\n        }\\n        return rslt;\\n    }\\n    private boolean isSpecial(int u){\\n        if (u == 1 || u == 10){\\n            return true;\\n        }\\n        int cand = u * u;\\n        String rep = String.valueOf(cand);\\n        int len = rep.length();\\n        \\n      \\n        if (dfs(u, rep, 0, 0))\\n            return true;\\n        return false;\\n    }\\n    private boolean dfs(int u, String rep, int sta, int sumsofar){\\n        //System.out.println(\"TOP rep = \" + rep + \" u = \" + u + \"sta = \" + sta + \" sumsofar = \" + sumsofar);\\n        if (sta == rep.length() && u == sumsofar){\\n            //System.out.println(\"GOT TRUE \" + \"TOPX rep = \" + rep + \" u = \" + u + \"sta = \" + sta + \" sumsofar = \" + sumsofar);\\n            return true;\\n        }\\n\\n        if (sta >= rep.length())\\n            return false;\\n        if (sumsofar > u){\\n            return false;\\n        }\\n        boolean rtn = false;\\n        for(int i = sta+1; i <= rep.length(); i++){\\n            int val = Integer.parseInt(rep.substring(sta, i));\\n            //System.out.println(\"val is \" + val);\\n            sumsofar += val;\\n            //System.out.println(\"val is \" + val);\\n            if (dfs(u, rep, i, sumsofar)){\\n                return true;\\n            }\\n            sumsofar -= val;\\n        }\\n \\n        return false;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> spc;\\n    public int punishmentNumber(int n) {\\n        spc = new ArrayList<>();\\n        \\n        for(int i = 1; i <= n; i++){\\n            if (isSpecial(i))\\n                spc.add(i);\\n        }\\n        \\n        int rslt = 0;\\n        for(int i = 0; i < spc.size(); i++){\\n            rslt += spc.get(i) * spc.get(i);\\n        }\\n        return rslt;\\n    }\\n    private boolean isSpecial(int u){\\n        if (u == 1 || u == 10){\\n            return true;\\n        }\\n        int cand = u * u;\\n        String rep = String.valueOf(cand);\\n        int len = rep.length();\\n        \\n      \\n        if (dfs(u, rep, 0, 0))\\n            return true;\\n        return false;\\n    }\\n    private boolean dfs(int u, String rep, int sta, int sumsofar){\\n        //System.out.println(\"TOP rep = \" + rep + \" u = \" + u + \"sta = \" + sta + \" sumsofar = \" + sumsofar);\\n        if (sta == rep.length() && u == sumsofar){\\n            //System.out.println(\"GOT TRUE \" + \"TOPX rep = \" + rep + \" u = \" + u + \"sta = \" + sta + \" sumsofar = \" + sumsofar);\\n            return true;\\n        }\\n\\n        if (sta >= rep.length())\\n            return false;\\n        if (sumsofar > u){\\n            return false;\\n        }\\n        boolean rtn = false;\\n        for(int i = sta+1; i <= rep.length(); i++){\\n            int val = Integer.parseInt(rep.substring(sta, i));\\n            //System.out.println(\"val is \" + val);\\n            sumsofar += val;\\n            //System.out.println(\"val is \" + val);\\n            if (dfs(u, rep, i, sumsofar)){\\n                return true;\\n            }\\n            sumsofar -= val;\\n        }\\n \\n        return false;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549921,
                "title": "c",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int PunishmentNumber(int n) {\\n        var res = 0;\\n        for (var i = 1; i <= n; i++){\\n            if (IsPN((i*i).ToString(), i, 0, 0)) \\n                res += (i * i);\\n        }\\n        return res;\\n    }\\n    private bool IsPN(string s, int num, int sum, int index)\\n    {\\n        if(index == s. Length)\\n            return sum == num;\\n        var cur = 0;\\n        for(var i = index; i < s.Length; i++){\\n            cur = cur * 10 + (s[i] - \\'0\\');\\n            if(sum + cur > num)\\n                break;\\n            if(IsPN(s, num, sum + cur, i + 1))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int PunishmentNumber(int n) {\\n        var res = 0;\\n        for (var i = 1; i <= n; i++){\\n            if (IsPN((i*i).ToString(), i, 0, 0)) \\n                res += (i * i);\\n        }\\n        return res;\\n    }\\n    private bool IsPN(string s, int num, int sum, int index)\\n    {\\n        if(index == s. Length)\\n            return sum == num;\\n        var cur = 0;\\n        for(var i = index; i < s.Length; i++){\\n            cur = cur * 10 + (s[i] - \\'0\\');\\n            if(sum + cur > num)\\n                break;\\n            if(IsPN(s, num, sum + cur, i + 1))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549920,
                "title": "recursion-using-just-integers",
                "content": "We can take advantage of the fact that the target $n$ is in the range $1 \\\\leq n \\\\leq 1000$. This means that at any point, there are only three valid ways to split the candidate number from the right: single-digit suffix, two-digit suffix and three-digit suffix.\\n\\n```\\nclass Solution {\\npublic:\\n    bool util(int candidate, int target) //candidate=i*i, target=i, ex: (1296,36)\\n    {\\n        if (target<0) return false;\\n        if (candidate==0) return false;\\n        bool a =  (candidate==target);\\n        bool b = util(candidate/10, target-candidate%10);\\n        bool c = util(candidate/100, target-candidate%100);\\n        bool d = util(candidate/1000, target-candidate%1000);\\n        return (a|b|c|d);\\n    }\\n    int punishmentNumber(int n) \\n    {\\n        int res=0;\\n        for(int i=1; i<=n; i++) if(util(i*i, i)) res+= i*i;\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool util(int candidate, int target) //candidate=i*i, target=i, ex: (1296,36)\\n    {\\n        if (target<0) return false;\\n        if (candidate==0) return false;\\n        bool a =  (candidate==target);\\n        bool b = util(candidate/10, target-candidate%10);\\n        bool c = util(candidate/100, target-candidate%100);\\n        bool d = util(candidate/1000, target-candidate%1000);\\n        return (a|b|c|d);\\n    }\\n    int punishmentNumber(int n) \\n    {\\n        int res=0;\\n        for(int i=1; i<=n; i++) if(util(i*i, i)) res+= i*i;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549913,
                "title": "confuse-watch-it-easy-simple-clean-expalined",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nokk , let thing first what is the main element/ problem of this question .\\n--> we need to iterate for each element and check punishment condition if yes then add it to our answer.\\n--> we all know get idea about the rest of code then find punishment (if not so see in my code)\\n\\n# FIND PUNISHMENT NUMBER\\n--> it is non other divide a number in all possible chunks and if any one from all that partition possibility  will have sum equal to the num( their square root ). sucess! this is a  punishment number and add it to answer .\\n-> If not any possibility will satisfy it then  it is not a punishment no.\\n\\nwe are using division algo for that :- \\ntarget(divident) --> which we have to do partation .( intially square of num)\\nstore --> store detach part of target( detach during partition )\\nquo(quotient) --> left side of partition of currrent target after partition\\nrem(remainder)--> right side of partition of current side after partition \\ndivi(divisor) --> do partition \\n\\n\\nchecking points :-\\n1) quo ==0 \\n--> it is happen when the partition wall( divisor) go beyond /left side to our target . it happen when divi > target \\n- rem + store == num  \\na) yes --> true\\nb) no --> false \\n[note included quo  because =0, target because it dissolved( break) into rem , quo ]\\n\\n2) quo + rem + store == num \\n- this check point for check if we get sucess before quo==0\\n\\n3) recurrsive call :-\\nwe do a recurssive call for the current partition (if upper conditions not satisfy)  that by considering the existing partition and store value is any possibiity to partition  quo ( become target in recurrsive call) to get our sucess .\\n-we only considered true return from it , because we only check from all possiblity is any one of them who will give sucess .\\n\\nuse for loop to divide the target from all possible from position ( tense->10, hund --> 100)\\n after quo == 0 is last point of our loop because after that no futhure number is remain for partition .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// my work --> your upvote++  :)\\nclass Solution {\\npublic:\\n    \\n      bool check( int target  , int num ,int store )\\n      {\\n         for( int divi  = 10 ; ; divi*=10)\\n         { \\n             int quo = target/divi ;\\n             int rem = target %divi ; \\n\\n             if( quo == 0 )\\n             { \\n                 if(rem + store == num)\\n                 { \\n                     return true ;\\n                 }\\n              \\n              else{\\n                   return false ; }\\n                 }\\n\\n           else if(quo+ rem +store == num )\\n           {\\n                return true ;\\n           }\\n           else{\\n                 \\n               if(check(quo, num , store +rem ))\\n                 { return true;  }\\n           }\\n             \\n        }\\n\\n          return false ;\\n      }\\n    \\n    int punishmentNumber(int n) {\\n        \\n        \\n        int sum = 1 ; \\n        for( int i = 2 ; i<= n ;i++)\\n        {\\n            int val = pow( i,2);\\n         \\n            if(check(val ,i,0) )\\n            { \\n                cout<<val<<\" \";\\n                 sum =sum+val;\\n            }\\n            \\n        }\\n        \\n        return sum ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// my work --> your upvote++  :)\\nclass Solution {\\npublic:\\n    \\n      bool check( int target  , int num ,int store )\\n      {\\n         for( int divi  = 10 ; ; divi*=10)\\n         { \\n             int quo = target/divi ;\\n             int rem = target %divi ; \\n\\n             if( quo == 0 )\\n             { \\n                 if(rem + store == num)\\n                 { \\n                     return true ;\\n                 }\\n              \\n              else{\\n                   return false ; }\\n                 }\\n\\n           else if(quo+ rem +store == num )\\n           {\\n                return true ;\\n           }\\n           else{\\n                 \\n               if(check(quo, num , store +rem ))\\n                 { return true;  }\\n           }\\n             \\n        }\\n\\n          return false ;\\n      }\\n    \\n    int punishmentNumber(int n) {\\n        \\n        \\n        int sum = 1 ; \\n        for( int i = 2 ; i<= n ;i++)\\n        {\\n            int val = pow( i,2);\\n         \\n            if(check(val ,i,0) )\\n            { \\n                cout<<val<<\" \";\\n                 sum =sum+val;\\n            }\\n            \\n        }\\n        \\n        return sum ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3549758,
                "title": "0-ms-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int res = 0;\\n        int[] temp = {1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000};\\n        for(int i=0; i<temp.length; i++){\\n            if(temp[i]<=n)res += temp[i]*temp[i];\\n            else return res;\\n        }\\n        return res;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int res = 0;\\n        int[] temp = {1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000};\\n        for(int i=0; i<temp.length; i++){\\n            if(temp[i]<=n)res += temp[i]*temp[i];\\n            else return res;\\n        }\\n        return res;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549687,
                "title": "c-and-java-optimized-recursive-solution-100-tc-and-sc-without-string-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsimple recursion will do our job since 1000 is not so big number so its square 1000000 and the possible partitions in it on the basis of no of digits ie; 7(worst case) will be 2^6 in general n digits ways of partitining 2^(n-1).this would not go so high.TC will be 64 * 1000 + some stack overhead time\\ninstead of strings as used by many of others and stoi which is again taking time and space use % and / operators to get left and right partitions of a number\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^(x-1) x n) no of digits in n->x\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nstack space no of digits\\n\\n**PLS UPVOTE IF IT HELPED**\\n![image.png](https://assets.leetcode.com/users/images/f78d36ba-0ab5-4028-a5ab-d4374c02ea95_1684695252.7884612.png)\\n\\n\\n# c++\\n```\\nclass Solution {\\npublic:\\nbool f(int num,int target){\\n    if(num<10) return num==target;\\n    int p_10=10;\\n    if(num==target) return true;\\n    int x=num/p_10;\\n    while(x){\\n        if(f(x,target-num%p_10)) return true;\\n        p_10*=10;\\n        x=num/p_10;\\n    }\\n    return false;\\n}\\n    int punishmentNumber(int n) {\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            if(f(i*i,i)) ans+=i*i;\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```\\n# Java\\n```\\nclass Solution {\\n    public boolean f(int num,int target){\\n        if(num<10) return num==target;\\n        int p_10=10;\\n        if(num==target) return true;\\n        int x=num/p_10;\\n        while(x>0){\\n            if(f(x,target-num%p_10)) return true;\\n            p_10*=10;\\n            x=num/p_10;\\n        }\\n        return false;\\n    }\\n    public int punishmentNumber(int n) {\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            if(f(i*i,i)) ans+=i*i;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool f(int num,int target){\\n    if(num<10) return num==target;\\n    int p_10=10;\\n    if(num==target) return true;\\n    int x=num/p_10;\\n    while(x){\\n        if(f(x,target-num%p_10)) return true;\\n        p_10*=10;\\n        x=num/p_10;\\n    }\\n    return false;\\n}\\n    int punishmentNumber(int n) {\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            if(f(i*i,i)) ans+=i*i;\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\n    public boolean f(int num,int target){\\n        if(num<10) return num==target;\\n        int p_10=10;\\n        if(num==target) return true;\\n        int x=num/p_10;\\n        while(x>0){\\n            if(f(x,target-num%p_10)) return true;\\n            p_10*=10;\\n            x=num/p_10;\\n        }\\n        return false;\\n    }\\n    public int punishmentNumber(int n) {\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            if(f(i*i,i)) ans+=i*i;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549641,
                "title": "intuitive-recursive-solution-in-c",
                "content": "# Intuition\\nWe can apply kind of a partition based approach by dividing squares of the numbers by 10, 100, 1000 ... to check for all contiguous substrings.\\n\\nTRY DRAWING A RECURSIVE TREE FOR THE APPROACH !\\n\\n# Approach\\n- Divide the square of the number by 10, 100, 1000 ... uptil the quotient we get becomes zero, to check for all partitions.\\n\\nFor number = 36, square = 1296\\n1296 / 10 => quo = 129, rem = 6 --> 6 / 10 => quo  = 0, rem = 6 (stop for quo = 0)\\n...\\n1296 / 10000 => quo = 0, rem = 1296 \\nSimilarly, recursive calls are made.\\n- If when (quo == 0) and the sum of contiguous substrings equals to the number then return true else return false.\\n- Do check for all numbers from 1 to n and add their squares to the answer if contiguous substring forms the number.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        \\n    bool solve(int num, int divident, int sum){\\n        \\n        for (int divisor = 10; ; divisor *= 10){\\n            \\n            int quo = divident / divisor; \\n            int rem = divident % divisor;\\n            \\n            if (quo == 0){\\n                if (sum + rem == num){\\n                    return true;\\n                }\\n                else {\\n                    return false;\\n                }\\n            }\\n            else {\\n                if (solve(num, rem, sum + quo) == true){\\n                    return true;\\n                }\\n            }\\n        }\\n    }\\n    \\n    int punishmentNumber(int n) {\\n        \\n        int ans = 0;\\n        \\n        for (int num=1; num<=n; num++){\\n            if (solve(num,  num*num, 0)){\\n                ans += num*num;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        \\n    bool solve(int num, int divident, int sum){\\n        \\n        for (int divisor = 10; ; divisor *= 10){\\n            \\n            int quo = divident / divisor; \\n            int rem = divident % divisor;\\n            \\n            if (quo == 0){\\n                if (sum + rem == num){\\n                    return true;\\n                }\\n                else {\\n                    return false;\\n                }\\n            }\\n            else {\\n                if (solve(num, rem, sum + quo) == true){\\n                    return true;\\n                }\\n            }\\n        }\\n    }\\n    \\n    int punishmentNumber(int n) {\\n        \\n        int ans = 0;\\n        \\n        for (int num=1; num<=n; num++){\\n            if (solve(num,  num*num, 0)){\\n                ans += num*num;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549545,
                "title": "oeis-sequence-without-recursion",
                "content": "You can refer oeis.org for this sequence.\\n```\\nclass Solution {\\npublic:\\n    int punishmentNumber(int n)\\n    {\\n        vector<int>v = {1, 9, 10, 36, 45, 55, 82, 91, 99, 100, 235, 297, 369, 370, 379, 414, 657, 675, 703, 756, 792, 909, 918, 945, 964, 990, 991, 999, 1000, 1296};\\n        int ans = 0;\\n        int i = 0;\\n        while(n>=v[i])\\n        {\\n            ans += v[i]*v[i];\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int punishmentNumber(int n)\\n    {\\n        vector<int>v = {1, 9, 10, 36, 45, 55, 82, 91, 99, 100, 235, 297, 369, 370, 379, 414, 657, 675, 703, 756, 792, 909, 918, 945, 964, 990, 991, 999, 1000, 1296};\\n        int ans = 0;\\n        int i = 0;\\n        while(n>=v[i])\\n        {\\n            ans += v[i]*v[i];\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549487,
                "title": "java-solution-using-recursionrecur",
                "content": "\\n```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int sum =0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            int sqr = i*i;\\n            if(canPartion(Integer.toString(sqr), i))\\n            {\\n                sum += sqr;\\n            }\\n        }\\n        return sum;\\n    }\\n\\n    boolean canPartion(String s, int t)\\n    {\\n        if(s==\"\" && t ==0) return true;\\n        if(t < 0)  return false;\\n        boolean ans = false;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(canPartion(s.substring(i+1), t- Integer.valueOf(s.substring(0,i+1))))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int punishmentNumber(int n) {\\n        int sum =0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            int sqr = i*i;\\n            if(canPartion(Integer.toString(sqr), i))\\n            {\\n                sum += sqr;\\n            }\\n        }\\n        return sum;\\n    }\\n\\n    boolean canPartion(String s, int t)\\n    {\\n        if(s==\"\" && t ==0) return true;\\n        if(t < 0)  return false;\\n        boolean ans = false;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(canPartion(s.substring(i+1), t- Integer.valueOf(s.substring(0,i+1))))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1902280,
                "content": [
                    {
                        "username": "padmavathidevi71625",
                        "content": "After 10+ wrong submissions\\nI came up with this\\n1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000\\n:)"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@to_string](/to_string) probably the outputs looool"
                    },
                    {
                        "username": "to_string",
                        "content": "Brother :) what is this \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Optimization Tip:\n\nA necessary condition for an integer `num` to satisfy the *partition* criterion  is: \n```\n            num %9 ==  0 or  num %9 ==  1.\n```\nThis necessary condition greatly reduces  the number of candidates to check the *partition* criterion. For example, if `n = 20`, then the candidates `1 <= i <= 20` can be pruned to  i = 9, 10, 18, or 19.\n\nThe reason for this necessary condition is based on *casting out nines* . principle. An integer `num` satisfies the *partition* criterion  only if:\n```\n           (num%9)**2 == num %9, \n```\nwhich implies this necessary condition. The details are left to the reader.\n\n"
                    },
                    {
                        "username": "arthur3366",
                        "content": "class Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        if (n<9) return 1;\\n        if (n==9) return 82; \\n        if (n<36) return 182;\\n        if (n<45) return 1478;\\n        if (n<55) return 3503;\\n        if (n<82) return 6528;\\n        if (n<91) return 13252;\\n        if (n<99) return 21533;\\n        if (n<100) return 31334; \\n        if (n<235) return 41334; \\n        if (n<297) return 96559; \\n        if (n<369) return 184768;\\n        if (n<370) return 320929;\\n        if (n<379) return 457829;\\n        if (n<414) return 601470;\\n        if (n<657) return 772866;\\n        if (n<675) return 1204515;\\n        if (n<703) return 1660140;\\n        if (n<756) return 2154349;\\n        if (n<792) return 2725885;\\n        if (n<909) return 3353149;\\n        if (n<918) return 4179430;\\n        if (n<945) return 5022154;\\n        if (n<964) return 5915179;\\n        if (n<990) return 6844475;\\n        if (n<991) return 7824575;\\n        if (n<999) return 8806656;\\n        if (n<1000) return 9804657;\\n        return 10804657;\\n         \\n    }\\n};"
                    },
                    {
                        "username": "Anisha2123",
                        "content": "Genius\\uD83D\\uDCAB"
                    },
                    {
                        "username": "hero080",
                        "content": "If you are trying DP and get TLE, or if you passed it with brutal force and don\\'t know why, here is the full explanation:\\nhttps://leetcode.com/problems/find-the-punishment-number-of-an-integer/solutions/3547280/0ms-tc-on-log-n-sc-olog-n-most-efficient-solution-simplest-code/"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How else tried implementing dp, but it passed without dp! "
                    },
                    {
                        "username": "ghouse_07",
                        "content": "It will pass as it has only one test cases,for multiple test cases dp is required."
                    },
                    {
                        "username": "danielmascena",
                        "content": "solved with a dp approach. The tip here I think is not to overthink about it"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "how can find punish number"
                    },
                    {
                        "username": "jaiswaldevansh27",
                        "content": "I dont understand the question, how  do we obtain \\'i\\' here? (refer the above example)\\nInput: n = 10\\nOutput: 182\\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1\\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\\nHence, the punishment number of 10 is 1 + 81 + 100 = 182\\n\\n\\nInput: n = 37\\nOutput: 1478\\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1. \\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \\n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig... \\'i\\' is any number in between 1<= i <= n such that below condition given in question should satisfy and punishment of n is  sum of i\\'s"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A tip:\nEven if you feel the precomputed results to be unfair, consider caching the values calculated at runtime in some static variable. This way the data would persist during the whole bunch of tests, and you won't be recomputing the same things over and over again."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "i think we have to invlove partition algo ..Am in right direction ??\\n"
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "Yes, you are right. Try making partitions by divding the numbers by 10, 100, 1000 ..."
                    }
                ]
            },
            {
                "id": 1901901,
                "content": [
                    {
                        "username": "padmavathidevi71625",
                        "content": "After 10+ wrong submissions\\nI came up with this\\n1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000\\n:)"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@to_string](/to_string) probably the outputs looool"
                    },
                    {
                        "username": "to_string",
                        "content": "Brother :) what is this \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Optimization Tip:\n\nA necessary condition for an integer `num` to satisfy the *partition* criterion  is: \n```\n            num %9 ==  0 or  num %9 ==  1.\n```\nThis necessary condition greatly reduces  the number of candidates to check the *partition* criterion. For example, if `n = 20`, then the candidates `1 <= i <= 20` can be pruned to  i = 9, 10, 18, or 19.\n\nThe reason for this necessary condition is based on *casting out nines* . principle. An integer `num` satisfies the *partition* criterion  only if:\n```\n           (num%9)**2 == num %9, \n```\nwhich implies this necessary condition. The details are left to the reader.\n\n"
                    },
                    {
                        "username": "arthur3366",
                        "content": "class Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        if (n<9) return 1;\\n        if (n==9) return 82; \\n        if (n<36) return 182;\\n        if (n<45) return 1478;\\n        if (n<55) return 3503;\\n        if (n<82) return 6528;\\n        if (n<91) return 13252;\\n        if (n<99) return 21533;\\n        if (n<100) return 31334; \\n        if (n<235) return 41334; \\n        if (n<297) return 96559; \\n        if (n<369) return 184768;\\n        if (n<370) return 320929;\\n        if (n<379) return 457829;\\n        if (n<414) return 601470;\\n        if (n<657) return 772866;\\n        if (n<675) return 1204515;\\n        if (n<703) return 1660140;\\n        if (n<756) return 2154349;\\n        if (n<792) return 2725885;\\n        if (n<909) return 3353149;\\n        if (n<918) return 4179430;\\n        if (n<945) return 5022154;\\n        if (n<964) return 5915179;\\n        if (n<990) return 6844475;\\n        if (n<991) return 7824575;\\n        if (n<999) return 8806656;\\n        if (n<1000) return 9804657;\\n        return 10804657;\\n         \\n    }\\n};"
                    },
                    {
                        "username": "Anisha2123",
                        "content": "Genius\\uD83D\\uDCAB"
                    },
                    {
                        "username": "hero080",
                        "content": "If you are trying DP and get TLE, or if you passed it with brutal force and don\\'t know why, here is the full explanation:\\nhttps://leetcode.com/problems/find-the-punishment-number-of-an-integer/solutions/3547280/0ms-tc-on-log-n-sc-olog-n-most-efficient-solution-simplest-code/"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How else tried implementing dp, but it passed without dp! "
                    },
                    {
                        "username": "ghouse_07",
                        "content": "It will pass as it has only one test cases,for multiple test cases dp is required."
                    },
                    {
                        "username": "danielmascena",
                        "content": "solved with a dp approach. The tip here I think is not to overthink about it"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "how can find punish number"
                    },
                    {
                        "username": "jaiswaldevansh27",
                        "content": "I dont understand the question, how  do we obtain \\'i\\' here? (refer the above example)\\nInput: n = 10\\nOutput: 182\\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1\\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\\nHence, the punishment number of 10 is 1 + 81 + 100 = 182\\n\\n\\nInput: n = 37\\nOutput: 1478\\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1. \\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \\n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig... \\'i\\' is any number in between 1<= i <= n such that below condition given in question should satisfy and punishment of n is  sum of i\\'s"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A tip:\nEven if you feel the precomputed results to be unfair, consider caching the values calculated at runtime in some static variable. This way the data would persist during the whole bunch of tests, and you won't be recomputing the same things over and over again."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "i think we have to invlove partition algo ..Am in right direction ??\\n"
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "Yes, you are right. Try making partitions by divding the numbers by 10, 100, 1000 ..."
                    }
                ]
            },
            {
                "id": 1918988,
                "content": [
                    {
                        "username": "padmavathidevi71625",
                        "content": "After 10+ wrong submissions\\nI came up with this\\n1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000\\n:)"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@to_string](/to_string) probably the outputs looool"
                    },
                    {
                        "username": "to_string",
                        "content": "Brother :) what is this \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Optimization Tip:\n\nA necessary condition for an integer `num` to satisfy the *partition* criterion  is: \n```\n            num %9 ==  0 or  num %9 ==  1.\n```\nThis necessary condition greatly reduces  the number of candidates to check the *partition* criterion. For example, if `n = 20`, then the candidates `1 <= i <= 20` can be pruned to  i = 9, 10, 18, or 19.\n\nThe reason for this necessary condition is based on *casting out nines* . principle. An integer `num` satisfies the *partition* criterion  only if:\n```\n           (num%9)**2 == num %9, \n```\nwhich implies this necessary condition. The details are left to the reader.\n\n"
                    },
                    {
                        "username": "arthur3366",
                        "content": "class Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        if (n<9) return 1;\\n        if (n==9) return 82; \\n        if (n<36) return 182;\\n        if (n<45) return 1478;\\n        if (n<55) return 3503;\\n        if (n<82) return 6528;\\n        if (n<91) return 13252;\\n        if (n<99) return 21533;\\n        if (n<100) return 31334; \\n        if (n<235) return 41334; \\n        if (n<297) return 96559; \\n        if (n<369) return 184768;\\n        if (n<370) return 320929;\\n        if (n<379) return 457829;\\n        if (n<414) return 601470;\\n        if (n<657) return 772866;\\n        if (n<675) return 1204515;\\n        if (n<703) return 1660140;\\n        if (n<756) return 2154349;\\n        if (n<792) return 2725885;\\n        if (n<909) return 3353149;\\n        if (n<918) return 4179430;\\n        if (n<945) return 5022154;\\n        if (n<964) return 5915179;\\n        if (n<990) return 6844475;\\n        if (n<991) return 7824575;\\n        if (n<999) return 8806656;\\n        if (n<1000) return 9804657;\\n        return 10804657;\\n         \\n    }\\n};"
                    },
                    {
                        "username": "Anisha2123",
                        "content": "Genius\\uD83D\\uDCAB"
                    },
                    {
                        "username": "hero080",
                        "content": "If you are trying DP and get TLE, or if you passed it with brutal force and don\\'t know why, here is the full explanation:\\nhttps://leetcode.com/problems/find-the-punishment-number-of-an-integer/solutions/3547280/0ms-tc-on-log-n-sc-olog-n-most-efficient-solution-simplest-code/"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How else tried implementing dp, but it passed without dp! "
                    },
                    {
                        "username": "ghouse_07",
                        "content": "It will pass as it has only one test cases,for multiple test cases dp is required."
                    },
                    {
                        "username": "danielmascena",
                        "content": "solved with a dp approach. The tip here I think is not to overthink about it"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "how can find punish number"
                    },
                    {
                        "username": "jaiswaldevansh27",
                        "content": "I dont understand the question, how  do we obtain \\'i\\' here? (refer the above example)\\nInput: n = 10\\nOutput: 182\\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1\\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\\nHence, the punishment number of 10 is 1 + 81 + 100 = 182\\n\\n\\nInput: n = 37\\nOutput: 1478\\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1. \\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \\n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig... \\'i\\' is any number in between 1<= i <= n such that below condition given in question should satisfy and punishment of n is  sum of i\\'s"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A tip:\nEven if you feel the precomputed results to be unfair, consider caching the values calculated at runtime in some static variable. This way the data would persist during the whole bunch of tests, and you won't be recomputing the same things over and over again."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "i think we have to invlove partition algo ..Am in right direction ??\\n"
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "Yes, you are right. Try making partitions by divding the numbers by 10, 100, 1000 ..."
                    }
                ]
            },
            {
                "id": 1901340,
                "content": [
                    {
                        "username": "padmavathidevi71625",
                        "content": "After 10+ wrong submissions\\nI came up with this\\n1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000\\n:)"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@to_string](/to_string) probably the outputs looool"
                    },
                    {
                        "username": "to_string",
                        "content": "Brother :) what is this \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Optimization Tip:\n\nA necessary condition for an integer `num` to satisfy the *partition* criterion  is: \n```\n            num %9 ==  0 or  num %9 ==  1.\n```\nThis necessary condition greatly reduces  the number of candidates to check the *partition* criterion. For example, if `n = 20`, then the candidates `1 <= i <= 20` can be pruned to  i = 9, 10, 18, or 19.\n\nThe reason for this necessary condition is based on *casting out nines* . principle. An integer `num` satisfies the *partition* criterion  only if:\n```\n           (num%9)**2 == num %9, \n```\nwhich implies this necessary condition. The details are left to the reader.\n\n"
                    },
                    {
                        "username": "arthur3366",
                        "content": "class Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        if (n<9) return 1;\\n        if (n==9) return 82; \\n        if (n<36) return 182;\\n        if (n<45) return 1478;\\n        if (n<55) return 3503;\\n        if (n<82) return 6528;\\n        if (n<91) return 13252;\\n        if (n<99) return 21533;\\n        if (n<100) return 31334; \\n        if (n<235) return 41334; \\n        if (n<297) return 96559; \\n        if (n<369) return 184768;\\n        if (n<370) return 320929;\\n        if (n<379) return 457829;\\n        if (n<414) return 601470;\\n        if (n<657) return 772866;\\n        if (n<675) return 1204515;\\n        if (n<703) return 1660140;\\n        if (n<756) return 2154349;\\n        if (n<792) return 2725885;\\n        if (n<909) return 3353149;\\n        if (n<918) return 4179430;\\n        if (n<945) return 5022154;\\n        if (n<964) return 5915179;\\n        if (n<990) return 6844475;\\n        if (n<991) return 7824575;\\n        if (n<999) return 8806656;\\n        if (n<1000) return 9804657;\\n        return 10804657;\\n         \\n    }\\n};"
                    },
                    {
                        "username": "Anisha2123",
                        "content": "Genius\\uD83D\\uDCAB"
                    },
                    {
                        "username": "hero080",
                        "content": "If you are trying DP and get TLE, or if you passed it with brutal force and don\\'t know why, here is the full explanation:\\nhttps://leetcode.com/problems/find-the-punishment-number-of-an-integer/solutions/3547280/0ms-tc-on-log-n-sc-olog-n-most-efficient-solution-simplest-code/"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How else tried implementing dp, but it passed without dp! "
                    },
                    {
                        "username": "ghouse_07",
                        "content": "It will pass as it has only one test cases,for multiple test cases dp is required."
                    },
                    {
                        "username": "danielmascena",
                        "content": "solved with a dp approach. The tip here I think is not to overthink about it"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "how can find punish number"
                    },
                    {
                        "username": "jaiswaldevansh27",
                        "content": "I dont understand the question, how  do we obtain \\'i\\' here? (refer the above example)\\nInput: n = 10\\nOutput: 182\\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1\\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\\nHence, the punishment number of 10 is 1 + 81 + 100 = 182\\n\\n\\nInput: n = 37\\nOutput: 1478\\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1. \\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \\n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig... \\'i\\' is any number in between 1<= i <= n such that below condition given in question should satisfy and punishment of n is  sum of i\\'s"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A tip:\nEven if you feel the precomputed results to be unfair, consider caching the values calculated at runtime in some static variable. This way the data would persist during the whole bunch of tests, and you won't be recomputing the same things over and over again."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "i think we have to invlove partition algo ..Am in right direction ??\\n"
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "Yes, you are right. Try making partitions by divding the numbers by 10, 100, 1000 ..."
                    }
                ]
            },
            {
                "id": 1900733,
                "content": [
                    {
                        "username": "padmavathidevi71625",
                        "content": "After 10+ wrong submissions\\nI came up with this\\n1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000\\n:)"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@to_string](/to_string) probably the outputs looool"
                    },
                    {
                        "username": "to_string",
                        "content": "Brother :) what is this \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Optimization Tip:\n\nA necessary condition for an integer `num` to satisfy the *partition* criterion  is: \n```\n            num %9 ==  0 or  num %9 ==  1.\n```\nThis necessary condition greatly reduces  the number of candidates to check the *partition* criterion. For example, if `n = 20`, then the candidates `1 <= i <= 20` can be pruned to  i = 9, 10, 18, or 19.\n\nThe reason for this necessary condition is based on *casting out nines* . principle. An integer `num` satisfies the *partition* criterion  only if:\n```\n           (num%9)**2 == num %9, \n```\nwhich implies this necessary condition. The details are left to the reader.\n\n"
                    },
                    {
                        "username": "arthur3366",
                        "content": "class Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        if (n<9) return 1;\\n        if (n==9) return 82; \\n        if (n<36) return 182;\\n        if (n<45) return 1478;\\n        if (n<55) return 3503;\\n        if (n<82) return 6528;\\n        if (n<91) return 13252;\\n        if (n<99) return 21533;\\n        if (n<100) return 31334; \\n        if (n<235) return 41334; \\n        if (n<297) return 96559; \\n        if (n<369) return 184768;\\n        if (n<370) return 320929;\\n        if (n<379) return 457829;\\n        if (n<414) return 601470;\\n        if (n<657) return 772866;\\n        if (n<675) return 1204515;\\n        if (n<703) return 1660140;\\n        if (n<756) return 2154349;\\n        if (n<792) return 2725885;\\n        if (n<909) return 3353149;\\n        if (n<918) return 4179430;\\n        if (n<945) return 5022154;\\n        if (n<964) return 5915179;\\n        if (n<990) return 6844475;\\n        if (n<991) return 7824575;\\n        if (n<999) return 8806656;\\n        if (n<1000) return 9804657;\\n        return 10804657;\\n         \\n    }\\n};"
                    },
                    {
                        "username": "Anisha2123",
                        "content": "Genius\\uD83D\\uDCAB"
                    },
                    {
                        "username": "hero080",
                        "content": "If you are trying DP and get TLE, or if you passed it with brutal force and don\\'t know why, here is the full explanation:\\nhttps://leetcode.com/problems/find-the-punishment-number-of-an-integer/solutions/3547280/0ms-tc-on-log-n-sc-olog-n-most-efficient-solution-simplest-code/"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How else tried implementing dp, but it passed without dp! "
                    },
                    {
                        "username": "ghouse_07",
                        "content": "It will pass as it has only one test cases,for multiple test cases dp is required."
                    },
                    {
                        "username": "danielmascena",
                        "content": "solved with a dp approach. The tip here I think is not to overthink about it"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "how can find punish number"
                    },
                    {
                        "username": "jaiswaldevansh27",
                        "content": "I dont understand the question, how  do we obtain \\'i\\' here? (refer the above example)\\nInput: n = 10\\nOutput: 182\\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1\\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\\nHence, the punishment number of 10 is 1 + 81 + 100 = 182\\n\\n\\nInput: n = 37\\nOutput: 1478\\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1. \\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \\n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig... \\'i\\' is any number in between 1<= i <= n such that below condition given in question should satisfy and punishment of n is  sum of i\\'s"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A tip:\nEven if you feel the precomputed results to be unfair, consider caching the values calculated at runtime in some static variable. This way the data would persist during the whole bunch of tests, and you won't be recomputing the same things over and over again."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "i think we have to invlove partition algo ..Am in right direction ??\\n"
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "Yes, you are right. Try making partitions by divding the numbers by 10, 100, 1000 ..."
                    }
                ]
            },
            {
                "id": 2076250,
                "content": [
                    {
                        "username": "padmavathidevi71625",
                        "content": "After 10+ wrong submissions\\nI came up with this\\n1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000\\n:)"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@to_string](/to_string) probably the outputs looool"
                    },
                    {
                        "username": "to_string",
                        "content": "Brother :) what is this \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Optimization Tip:\n\nA necessary condition for an integer `num` to satisfy the *partition* criterion  is: \n```\n            num %9 ==  0 or  num %9 ==  1.\n```\nThis necessary condition greatly reduces  the number of candidates to check the *partition* criterion. For example, if `n = 20`, then the candidates `1 <= i <= 20` can be pruned to  i = 9, 10, 18, or 19.\n\nThe reason for this necessary condition is based on *casting out nines* . principle. An integer `num` satisfies the *partition* criterion  only if:\n```\n           (num%9)**2 == num %9, \n```\nwhich implies this necessary condition. The details are left to the reader.\n\n"
                    },
                    {
                        "username": "arthur3366",
                        "content": "class Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        if (n<9) return 1;\\n        if (n==9) return 82; \\n        if (n<36) return 182;\\n        if (n<45) return 1478;\\n        if (n<55) return 3503;\\n        if (n<82) return 6528;\\n        if (n<91) return 13252;\\n        if (n<99) return 21533;\\n        if (n<100) return 31334; \\n        if (n<235) return 41334; \\n        if (n<297) return 96559; \\n        if (n<369) return 184768;\\n        if (n<370) return 320929;\\n        if (n<379) return 457829;\\n        if (n<414) return 601470;\\n        if (n<657) return 772866;\\n        if (n<675) return 1204515;\\n        if (n<703) return 1660140;\\n        if (n<756) return 2154349;\\n        if (n<792) return 2725885;\\n        if (n<909) return 3353149;\\n        if (n<918) return 4179430;\\n        if (n<945) return 5022154;\\n        if (n<964) return 5915179;\\n        if (n<990) return 6844475;\\n        if (n<991) return 7824575;\\n        if (n<999) return 8806656;\\n        if (n<1000) return 9804657;\\n        return 10804657;\\n         \\n    }\\n};"
                    },
                    {
                        "username": "Anisha2123",
                        "content": "Genius\\uD83D\\uDCAB"
                    },
                    {
                        "username": "hero080",
                        "content": "If you are trying DP and get TLE, or if you passed it with brutal force and don\\'t know why, here is the full explanation:\\nhttps://leetcode.com/problems/find-the-punishment-number-of-an-integer/solutions/3547280/0ms-tc-on-log-n-sc-olog-n-most-efficient-solution-simplest-code/"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How else tried implementing dp, but it passed without dp! "
                    },
                    {
                        "username": "ghouse_07",
                        "content": "It will pass as it has only one test cases,for multiple test cases dp is required."
                    },
                    {
                        "username": "danielmascena",
                        "content": "solved with a dp approach. The tip here I think is not to overthink about it"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "how can find punish number"
                    },
                    {
                        "username": "jaiswaldevansh27",
                        "content": "I dont understand the question, how  do we obtain \\'i\\' here? (refer the above example)\\nInput: n = 10\\nOutput: 182\\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1\\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\\nHence, the punishment number of 10 is 1 + 81 + 100 = 182\\n\\n\\nInput: n = 37\\nOutput: 1478\\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1. \\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \\n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig... \\'i\\' is any number in between 1<= i <= n such that below condition given in question should satisfy and punishment of n is  sum of i\\'s"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A tip:\nEven if you feel the precomputed results to be unfair, consider caching the values calculated at runtime in some static variable. This way the data would persist during the whole bunch of tests, and you won't be recomputing the same things over and over again."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "i think we have to invlove partition algo ..Am in right direction ??\\n"
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "Yes, you are right. Try making partitions by divding the numbers by 10, 100, 1000 ..."
                    }
                ]
            },
            {
                "id": 1962630,
                "content": [
                    {
                        "username": "padmavathidevi71625",
                        "content": "After 10+ wrong submissions\\nI came up with this\\n1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000\\n:)"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@to_string](/to_string) probably the outputs looool"
                    },
                    {
                        "username": "to_string",
                        "content": "Brother :) what is this \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Optimization Tip:\n\nA necessary condition for an integer `num` to satisfy the *partition* criterion  is: \n```\n            num %9 ==  0 or  num %9 ==  1.\n```\nThis necessary condition greatly reduces  the number of candidates to check the *partition* criterion. For example, if `n = 20`, then the candidates `1 <= i <= 20` can be pruned to  i = 9, 10, 18, or 19.\n\nThe reason for this necessary condition is based on *casting out nines* . principle. An integer `num` satisfies the *partition* criterion  only if:\n```\n           (num%9)**2 == num %9, \n```\nwhich implies this necessary condition. The details are left to the reader.\n\n"
                    },
                    {
                        "username": "arthur3366",
                        "content": "class Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        if (n<9) return 1;\\n        if (n==9) return 82; \\n        if (n<36) return 182;\\n        if (n<45) return 1478;\\n        if (n<55) return 3503;\\n        if (n<82) return 6528;\\n        if (n<91) return 13252;\\n        if (n<99) return 21533;\\n        if (n<100) return 31334; \\n        if (n<235) return 41334; \\n        if (n<297) return 96559; \\n        if (n<369) return 184768;\\n        if (n<370) return 320929;\\n        if (n<379) return 457829;\\n        if (n<414) return 601470;\\n        if (n<657) return 772866;\\n        if (n<675) return 1204515;\\n        if (n<703) return 1660140;\\n        if (n<756) return 2154349;\\n        if (n<792) return 2725885;\\n        if (n<909) return 3353149;\\n        if (n<918) return 4179430;\\n        if (n<945) return 5022154;\\n        if (n<964) return 5915179;\\n        if (n<990) return 6844475;\\n        if (n<991) return 7824575;\\n        if (n<999) return 8806656;\\n        if (n<1000) return 9804657;\\n        return 10804657;\\n         \\n    }\\n};"
                    },
                    {
                        "username": "Anisha2123",
                        "content": "Genius\\uD83D\\uDCAB"
                    },
                    {
                        "username": "hero080",
                        "content": "If you are trying DP and get TLE, or if you passed it with brutal force and don\\'t know why, here is the full explanation:\\nhttps://leetcode.com/problems/find-the-punishment-number-of-an-integer/solutions/3547280/0ms-tc-on-log-n-sc-olog-n-most-efficient-solution-simplest-code/"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How else tried implementing dp, but it passed without dp! "
                    },
                    {
                        "username": "ghouse_07",
                        "content": "It will pass as it has only one test cases,for multiple test cases dp is required."
                    },
                    {
                        "username": "danielmascena",
                        "content": "solved with a dp approach. The tip here I think is not to overthink about it"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "how can find punish number"
                    },
                    {
                        "username": "jaiswaldevansh27",
                        "content": "I dont understand the question, how  do we obtain \\'i\\' here? (refer the above example)\\nInput: n = 10\\nOutput: 182\\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1\\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\\nHence, the punishment number of 10 is 1 + 81 + 100 = 182\\n\\n\\nInput: n = 37\\nOutput: 1478\\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1. \\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \\n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig... \\'i\\' is any number in between 1<= i <= n such that below condition given in question should satisfy and punishment of n is  sum of i\\'s"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A tip:\nEven if you feel the precomputed results to be unfair, consider caching the values calculated at runtime in some static variable. This way the data would persist during the whole bunch of tests, and you won't be recomputing the same things over and over again."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "i think we have to invlove partition algo ..Am in right direction ??\\n"
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "Yes, you are right. Try making partitions by divding the numbers by 10, 100, 1000 ..."
                    }
                ]
            },
            {
                "id": 1933829,
                "content": [
                    {
                        "username": "padmavathidevi71625",
                        "content": "After 10+ wrong submissions\\nI came up with this\\n1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000\\n:)"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@to_string](/to_string) probably the outputs looool"
                    },
                    {
                        "username": "to_string",
                        "content": "Brother :) what is this \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Optimization Tip:\n\nA necessary condition for an integer `num` to satisfy the *partition* criterion  is: \n```\n            num %9 ==  0 or  num %9 ==  1.\n```\nThis necessary condition greatly reduces  the number of candidates to check the *partition* criterion. For example, if `n = 20`, then the candidates `1 <= i <= 20` can be pruned to  i = 9, 10, 18, or 19.\n\nThe reason for this necessary condition is based on *casting out nines* . principle. An integer `num` satisfies the *partition* criterion  only if:\n```\n           (num%9)**2 == num %9, \n```\nwhich implies this necessary condition. The details are left to the reader.\n\n"
                    },
                    {
                        "username": "arthur3366",
                        "content": "class Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        if (n<9) return 1;\\n        if (n==9) return 82; \\n        if (n<36) return 182;\\n        if (n<45) return 1478;\\n        if (n<55) return 3503;\\n        if (n<82) return 6528;\\n        if (n<91) return 13252;\\n        if (n<99) return 21533;\\n        if (n<100) return 31334; \\n        if (n<235) return 41334; \\n        if (n<297) return 96559; \\n        if (n<369) return 184768;\\n        if (n<370) return 320929;\\n        if (n<379) return 457829;\\n        if (n<414) return 601470;\\n        if (n<657) return 772866;\\n        if (n<675) return 1204515;\\n        if (n<703) return 1660140;\\n        if (n<756) return 2154349;\\n        if (n<792) return 2725885;\\n        if (n<909) return 3353149;\\n        if (n<918) return 4179430;\\n        if (n<945) return 5022154;\\n        if (n<964) return 5915179;\\n        if (n<990) return 6844475;\\n        if (n<991) return 7824575;\\n        if (n<999) return 8806656;\\n        if (n<1000) return 9804657;\\n        return 10804657;\\n         \\n    }\\n};"
                    },
                    {
                        "username": "Anisha2123",
                        "content": "Genius\\uD83D\\uDCAB"
                    },
                    {
                        "username": "hero080",
                        "content": "If you are trying DP and get TLE, or if you passed it with brutal force and don\\'t know why, here is the full explanation:\\nhttps://leetcode.com/problems/find-the-punishment-number-of-an-integer/solutions/3547280/0ms-tc-on-log-n-sc-olog-n-most-efficient-solution-simplest-code/"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How else tried implementing dp, but it passed without dp! "
                    },
                    {
                        "username": "ghouse_07",
                        "content": "It will pass as it has only one test cases,for multiple test cases dp is required."
                    },
                    {
                        "username": "danielmascena",
                        "content": "solved with a dp approach. The tip here I think is not to overthink about it"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "how can find punish number"
                    },
                    {
                        "username": "jaiswaldevansh27",
                        "content": "I dont understand the question, how  do we obtain \\'i\\' here? (refer the above example)\\nInput: n = 10\\nOutput: 182\\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1\\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\\nHence, the punishment number of 10 is 1 + 81 + 100 = 182\\n\\n\\nInput: n = 37\\nOutput: 1478\\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1. \\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \\n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig... \\'i\\' is any number in between 1<= i <= n such that below condition given in question should satisfy and punishment of n is  sum of i\\'s"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A tip:\nEven if you feel the precomputed results to be unfair, consider caching the values calculated at runtime in some static variable. This way the data would persist during the whole bunch of tests, and you won't be recomputing the same things over and over again."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "i think we have to invlove partition algo ..Am in right direction ??\\n"
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "Yes, you are right. Try making partitions by divding the numbers by 10, 100, 1000 ..."
                    }
                ]
            },
            {
                "id": 1906823,
                "content": [
                    {
                        "username": "padmavathidevi71625",
                        "content": "After 10+ wrong submissions\\nI came up with this\\n1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000\\n:)"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@to_string](/to_string) probably the outputs looool"
                    },
                    {
                        "username": "to_string",
                        "content": "Brother :) what is this \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Optimization Tip:\n\nA necessary condition for an integer `num` to satisfy the *partition* criterion  is: \n```\n            num %9 ==  0 or  num %9 ==  1.\n```\nThis necessary condition greatly reduces  the number of candidates to check the *partition* criterion. For example, if `n = 20`, then the candidates `1 <= i <= 20` can be pruned to  i = 9, 10, 18, or 19.\n\nThe reason for this necessary condition is based on *casting out nines* . principle. An integer `num` satisfies the *partition* criterion  only if:\n```\n           (num%9)**2 == num %9, \n```\nwhich implies this necessary condition. The details are left to the reader.\n\n"
                    },
                    {
                        "username": "arthur3366",
                        "content": "class Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        if (n<9) return 1;\\n        if (n==9) return 82; \\n        if (n<36) return 182;\\n        if (n<45) return 1478;\\n        if (n<55) return 3503;\\n        if (n<82) return 6528;\\n        if (n<91) return 13252;\\n        if (n<99) return 21533;\\n        if (n<100) return 31334; \\n        if (n<235) return 41334; \\n        if (n<297) return 96559; \\n        if (n<369) return 184768;\\n        if (n<370) return 320929;\\n        if (n<379) return 457829;\\n        if (n<414) return 601470;\\n        if (n<657) return 772866;\\n        if (n<675) return 1204515;\\n        if (n<703) return 1660140;\\n        if (n<756) return 2154349;\\n        if (n<792) return 2725885;\\n        if (n<909) return 3353149;\\n        if (n<918) return 4179430;\\n        if (n<945) return 5022154;\\n        if (n<964) return 5915179;\\n        if (n<990) return 6844475;\\n        if (n<991) return 7824575;\\n        if (n<999) return 8806656;\\n        if (n<1000) return 9804657;\\n        return 10804657;\\n         \\n    }\\n};"
                    },
                    {
                        "username": "Anisha2123",
                        "content": "Genius\\uD83D\\uDCAB"
                    },
                    {
                        "username": "hero080",
                        "content": "If you are trying DP and get TLE, or if you passed it with brutal force and don\\'t know why, here is the full explanation:\\nhttps://leetcode.com/problems/find-the-punishment-number-of-an-integer/solutions/3547280/0ms-tc-on-log-n-sc-olog-n-most-efficient-solution-simplest-code/"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How else tried implementing dp, but it passed without dp! "
                    },
                    {
                        "username": "ghouse_07",
                        "content": "It will pass as it has only one test cases,for multiple test cases dp is required."
                    },
                    {
                        "username": "danielmascena",
                        "content": "solved with a dp approach. The tip here I think is not to overthink about it"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "how can find punish number"
                    },
                    {
                        "username": "jaiswaldevansh27",
                        "content": "I dont understand the question, how  do we obtain \\'i\\' here? (refer the above example)\\nInput: n = 10\\nOutput: 182\\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1\\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\\nHence, the punishment number of 10 is 1 + 81 + 100 = 182\\n\\n\\nInput: n = 37\\nOutput: 1478\\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1. \\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \\n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig... \\'i\\' is any number in between 1<= i <= n such that below condition given in question should satisfy and punishment of n is  sum of i\\'s"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A tip:\nEven if you feel the precomputed results to be unfair, consider caching the values calculated at runtime in some static variable. This way the data would persist during the whole bunch of tests, and you won't be recomputing the same things over and over again."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "i think we have to invlove partition algo ..Am in right direction ??\\n"
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "Yes, you are right. Try making partitions by divding the numbers by 10, 100, 1000 ..."
                    }
                ]
            },
            {
                "id": 1901097,
                "content": [
                    {
                        "username": "padmavathidevi71625",
                        "content": "After 10+ wrong submissions\\nI came up with this\\n1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000\\n:)"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@to_string](/to_string) probably the outputs looool"
                    },
                    {
                        "username": "to_string",
                        "content": "Brother :) what is this \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Optimization Tip:\n\nA necessary condition for an integer `num` to satisfy the *partition* criterion  is: \n```\n            num %9 ==  0 or  num %9 ==  1.\n```\nThis necessary condition greatly reduces  the number of candidates to check the *partition* criterion. For example, if `n = 20`, then the candidates `1 <= i <= 20` can be pruned to  i = 9, 10, 18, or 19.\n\nThe reason for this necessary condition is based on *casting out nines* . principle. An integer `num` satisfies the *partition* criterion  only if:\n```\n           (num%9)**2 == num %9, \n```\nwhich implies this necessary condition. The details are left to the reader.\n\n"
                    },
                    {
                        "username": "arthur3366",
                        "content": "class Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        if (n<9) return 1;\\n        if (n==9) return 82; \\n        if (n<36) return 182;\\n        if (n<45) return 1478;\\n        if (n<55) return 3503;\\n        if (n<82) return 6528;\\n        if (n<91) return 13252;\\n        if (n<99) return 21533;\\n        if (n<100) return 31334; \\n        if (n<235) return 41334; \\n        if (n<297) return 96559; \\n        if (n<369) return 184768;\\n        if (n<370) return 320929;\\n        if (n<379) return 457829;\\n        if (n<414) return 601470;\\n        if (n<657) return 772866;\\n        if (n<675) return 1204515;\\n        if (n<703) return 1660140;\\n        if (n<756) return 2154349;\\n        if (n<792) return 2725885;\\n        if (n<909) return 3353149;\\n        if (n<918) return 4179430;\\n        if (n<945) return 5022154;\\n        if (n<964) return 5915179;\\n        if (n<990) return 6844475;\\n        if (n<991) return 7824575;\\n        if (n<999) return 8806656;\\n        if (n<1000) return 9804657;\\n        return 10804657;\\n         \\n    }\\n};"
                    },
                    {
                        "username": "Anisha2123",
                        "content": "Genius\\uD83D\\uDCAB"
                    },
                    {
                        "username": "hero080",
                        "content": "If you are trying DP and get TLE, or if you passed it with brutal force and don\\'t know why, here is the full explanation:\\nhttps://leetcode.com/problems/find-the-punishment-number-of-an-integer/solutions/3547280/0ms-tc-on-log-n-sc-olog-n-most-efficient-solution-simplest-code/"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How else tried implementing dp, but it passed without dp! "
                    },
                    {
                        "username": "ghouse_07",
                        "content": "It will pass as it has only one test cases,for multiple test cases dp is required."
                    },
                    {
                        "username": "danielmascena",
                        "content": "solved with a dp approach. The tip here I think is not to overthink about it"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "how can find punish number"
                    },
                    {
                        "username": "jaiswaldevansh27",
                        "content": "I dont understand the question, how  do we obtain \\'i\\' here? (refer the above example)\\nInput: n = 10\\nOutput: 182\\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1\\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\\nHence, the punishment number of 10 is 1 + 81 + 100 = 182\\n\\n\\nInput: n = 37\\nOutput: 1478\\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1. \\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \\n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig... \\'i\\' is any number in between 1<= i <= n such that below condition given in question should satisfy and punishment of n is  sum of i\\'s"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A tip:\nEven if you feel the precomputed results to be unfair, consider caching the values calculated at runtime in some static variable. This way the data would persist during the whole bunch of tests, and you won't be recomputing the same things over and over again."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "i think we have to invlove partition algo ..Am in right direction ??\\n"
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "Yes, you are right. Try making partitions by divding the numbers by 10, 100, 1000 ..."
                    }
                ]
            },
            {
                "id": 1902280,
                "content": [
                    {
                        "username": "padmavathidevi71625",
                        "content": "After 10+ wrong submissions\\nI came up with this\\n1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000\\n:)"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@to_string](/to_string) probably the outputs looool"
                    },
                    {
                        "username": "to_string",
                        "content": "Brother :) what is this \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Optimization Tip:\n\nA necessary condition for an integer `num` to satisfy the *partition* criterion  is: \n```\n            num %9 ==  0 or  num %9 ==  1.\n```\nThis necessary condition greatly reduces  the number of candidates to check the *partition* criterion. For example, if `n = 20`, then the candidates `1 <= i <= 20` can be pruned to  i = 9, 10, 18, or 19.\n\nThe reason for this necessary condition is based on *casting out nines* . principle. An integer `num` satisfies the *partition* criterion  only if:\n```\n           (num%9)**2 == num %9, \n```\nwhich implies this necessary condition. The details are left to the reader.\n\n"
                    },
                    {
                        "username": "arthur3366",
                        "content": "class Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        if (n<9) return 1;\\n        if (n==9) return 82; \\n        if (n<36) return 182;\\n        if (n<45) return 1478;\\n        if (n<55) return 3503;\\n        if (n<82) return 6528;\\n        if (n<91) return 13252;\\n        if (n<99) return 21533;\\n        if (n<100) return 31334; \\n        if (n<235) return 41334; \\n        if (n<297) return 96559; \\n        if (n<369) return 184768;\\n        if (n<370) return 320929;\\n        if (n<379) return 457829;\\n        if (n<414) return 601470;\\n        if (n<657) return 772866;\\n        if (n<675) return 1204515;\\n        if (n<703) return 1660140;\\n        if (n<756) return 2154349;\\n        if (n<792) return 2725885;\\n        if (n<909) return 3353149;\\n        if (n<918) return 4179430;\\n        if (n<945) return 5022154;\\n        if (n<964) return 5915179;\\n        if (n<990) return 6844475;\\n        if (n<991) return 7824575;\\n        if (n<999) return 8806656;\\n        if (n<1000) return 9804657;\\n        return 10804657;\\n         \\n    }\\n};"
                    },
                    {
                        "username": "Anisha2123",
                        "content": "Genius\\uD83D\\uDCAB"
                    },
                    {
                        "username": "hero080",
                        "content": "If you are trying DP and get TLE, or if you passed it with brutal force and don\\'t know why, here is the full explanation:\\nhttps://leetcode.com/problems/find-the-punishment-number-of-an-integer/solutions/3547280/0ms-tc-on-log-n-sc-olog-n-most-efficient-solution-simplest-code/"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How else tried implementing dp, but it passed without dp! "
                    },
                    {
                        "username": "ghouse_07",
                        "content": "It will pass as it has only one test cases,for multiple test cases dp is required."
                    },
                    {
                        "username": "danielmascena",
                        "content": "solved with a dp approach. The tip here I think is not to overthink about it"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "how can find punish number"
                    },
                    {
                        "username": "jaiswaldevansh27",
                        "content": "I dont understand the question, how  do we obtain \\'i\\' here? (refer the above example)\\nInput: n = 10\\nOutput: 182\\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1\\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\\nHence, the punishment number of 10 is 1 + 81 + 100 = 182\\n\\n\\nInput: n = 37\\nOutput: 1478\\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1. \\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \\n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig... \\'i\\' is any number in between 1<= i <= n such that below condition given in question should satisfy and punishment of n is  sum of i\\'s"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A tip:\nEven if you feel the precomputed results to be unfair, consider caching the values calculated at runtime in some static variable. This way the data would persist during the whole bunch of tests, and you won't be recomputing the same things over and over again."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "i think we have to invlove partition algo ..Am in right direction ??\\n"
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "Yes, you are right. Try making partitions by divding the numbers by 10, 100, 1000 ..."
                    }
                ]
            },
            {
                "id": 1901901,
                "content": [
                    {
                        "username": "padmavathidevi71625",
                        "content": "After 10+ wrong submissions\\nI came up with this\\n1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000\\n:)"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@to_string](/to_string) probably the outputs looool"
                    },
                    {
                        "username": "to_string",
                        "content": "Brother :) what is this \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Optimization Tip:\n\nA necessary condition for an integer `num` to satisfy the *partition* criterion  is: \n```\n            num %9 ==  0 or  num %9 ==  1.\n```\nThis necessary condition greatly reduces  the number of candidates to check the *partition* criterion. For example, if `n = 20`, then the candidates `1 <= i <= 20` can be pruned to  i = 9, 10, 18, or 19.\n\nThe reason for this necessary condition is based on *casting out nines* . principle. An integer `num` satisfies the *partition* criterion  only if:\n```\n           (num%9)**2 == num %9, \n```\nwhich implies this necessary condition. The details are left to the reader.\n\n"
                    },
                    {
                        "username": "arthur3366",
                        "content": "class Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        if (n<9) return 1;\\n        if (n==9) return 82; \\n        if (n<36) return 182;\\n        if (n<45) return 1478;\\n        if (n<55) return 3503;\\n        if (n<82) return 6528;\\n        if (n<91) return 13252;\\n        if (n<99) return 21533;\\n        if (n<100) return 31334; \\n        if (n<235) return 41334; \\n        if (n<297) return 96559; \\n        if (n<369) return 184768;\\n        if (n<370) return 320929;\\n        if (n<379) return 457829;\\n        if (n<414) return 601470;\\n        if (n<657) return 772866;\\n        if (n<675) return 1204515;\\n        if (n<703) return 1660140;\\n        if (n<756) return 2154349;\\n        if (n<792) return 2725885;\\n        if (n<909) return 3353149;\\n        if (n<918) return 4179430;\\n        if (n<945) return 5022154;\\n        if (n<964) return 5915179;\\n        if (n<990) return 6844475;\\n        if (n<991) return 7824575;\\n        if (n<999) return 8806656;\\n        if (n<1000) return 9804657;\\n        return 10804657;\\n         \\n    }\\n};"
                    },
                    {
                        "username": "Anisha2123",
                        "content": "Genius\\uD83D\\uDCAB"
                    },
                    {
                        "username": "hero080",
                        "content": "If you are trying DP and get TLE, or if you passed it with brutal force and don\\'t know why, here is the full explanation:\\nhttps://leetcode.com/problems/find-the-punishment-number-of-an-integer/solutions/3547280/0ms-tc-on-log-n-sc-olog-n-most-efficient-solution-simplest-code/"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How else tried implementing dp, but it passed without dp! "
                    },
                    {
                        "username": "ghouse_07",
                        "content": "It will pass as it has only one test cases,for multiple test cases dp is required."
                    },
                    {
                        "username": "danielmascena",
                        "content": "solved with a dp approach. The tip here I think is not to overthink about it"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "how can find punish number"
                    },
                    {
                        "username": "jaiswaldevansh27",
                        "content": "I dont understand the question, how  do we obtain \\'i\\' here? (refer the above example)\\nInput: n = 10\\nOutput: 182\\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1\\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\\nHence, the punishment number of 10 is 1 + 81 + 100 = 182\\n\\n\\nInput: n = 37\\nOutput: 1478\\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1. \\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \\n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig... \\'i\\' is any number in between 1<= i <= n such that below condition given in question should satisfy and punishment of n is  sum of i\\'s"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A tip:\nEven if you feel the precomputed results to be unfair, consider caching the values calculated at runtime in some static variable. This way the data would persist during the whole bunch of tests, and you won't be recomputing the same things over and over again."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "i think we have to invlove partition algo ..Am in right direction ??\\n"
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "Yes, you are right. Try making partitions by divding the numbers by 10, 100, 1000 ..."
                    }
                ]
            },
            {
                "id": 1918988,
                "content": [
                    {
                        "username": "padmavathidevi71625",
                        "content": "After 10+ wrong submissions\\nI came up with this\\n1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000\\n:)"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@to_string](/to_string) probably the outputs looool"
                    },
                    {
                        "username": "to_string",
                        "content": "Brother :) what is this \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Optimization Tip:\n\nA necessary condition for an integer `num` to satisfy the *partition* criterion  is: \n```\n            num %9 ==  0 or  num %9 ==  1.\n```\nThis necessary condition greatly reduces  the number of candidates to check the *partition* criterion. For example, if `n = 20`, then the candidates `1 <= i <= 20` can be pruned to  i = 9, 10, 18, or 19.\n\nThe reason for this necessary condition is based on *casting out nines* . principle. An integer `num` satisfies the *partition* criterion  only if:\n```\n           (num%9)**2 == num %9, \n```\nwhich implies this necessary condition. The details are left to the reader.\n\n"
                    },
                    {
                        "username": "arthur3366",
                        "content": "class Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        if (n<9) return 1;\\n        if (n==9) return 82; \\n        if (n<36) return 182;\\n        if (n<45) return 1478;\\n        if (n<55) return 3503;\\n        if (n<82) return 6528;\\n        if (n<91) return 13252;\\n        if (n<99) return 21533;\\n        if (n<100) return 31334; \\n        if (n<235) return 41334; \\n        if (n<297) return 96559; \\n        if (n<369) return 184768;\\n        if (n<370) return 320929;\\n        if (n<379) return 457829;\\n        if (n<414) return 601470;\\n        if (n<657) return 772866;\\n        if (n<675) return 1204515;\\n        if (n<703) return 1660140;\\n        if (n<756) return 2154349;\\n        if (n<792) return 2725885;\\n        if (n<909) return 3353149;\\n        if (n<918) return 4179430;\\n        if (n<945) return 5022154;\\n        if (n<964) return 5915179;\\n        if (n<990) return 6844475;\\n        if (n<991) return 7824575;\\n        if (n<999) return 8806656;\\n        if (n<1000) return 9804657;\\n        return 10804657;\\n         \\n    }\\n};"
                    },
                    {
                        "username": "Anisha2123",
                        "content": "Genius\\uD83D\\uDCAB"
                    },
                    {
                        "username": "hero080",
                        "content": "If you are trying DP and get TLE, or if you passed it with brutal force and don\\'t know why, here is the full explanation:\\nhttps://leetcode.com/problems/find-the-punishment-number-of-an-integer/solutions/3547280/0ms-tc-on-log-n-sc-olog-n-most-efficient-solution-simplest-code/"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How else tried implementing dp, but it passed without dp! "
                    },
                    {
                        "username": "ghouse_07",
                        "content": "It will pass as it has only one test cases,for multiple test cases dp is required."
                    },
                    {
                        "username": "danielmascena",
                        "content": "solved with a dp approach. The tip here I think is not to overthink about it"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "how can find punish number"
                    },
                    {
                        "username": "jaiswaldevansh27",
                        "content": "I dont understand the question, how  do we obtain \\'i\\' here? (refer the above example)\\nInput: n = 10\\nOutput: 182\\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1\\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\\nHence, the punishment number of 10 is 1 + 81 + 100 = 182\\n\\n\\nInput: n = 37\\nOutput: 1478\\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1. \\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \\n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig... \\'i\\' is any number in between 1<= i <= n such that below condition given in question should satisfy and punishment of n is  sum of i\\'s"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A tip:\nEven if you feel the precomputed results to be unfair, consider caching the values calculated at runtime in some static variable. This way the data would persist during the whole bunch of tests, and you won't be recomputing the same things over and over again."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "i think we have to invlove partition algo ..Am in right direction ??\\n"
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "Yes, you are right. Try making partitions by divding the numbers by 10, 100, 1000 ..."
                    }
                ]
            },
            {
                "id": 1901340,
                "content": [
                    {
                        "username": "padmavathidevi71625",
                        "content": "After 10+ wrong submissions\\nI came up with this\\n1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000\\n:)"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@to_string](/to_string) probably the outputs looool"
                    },
                    {
                        "username": "to_string",
                        "content": "Brother :) what is this \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Optimization Tip:\n\nA necessary condition for an integer `num` to satisfy the *partition* criterion  is: \n```\n            num %9 ==  0 or  num %9 ==  1.\n```\nThis necessary condition greatly reduces  the number of candidates to check the *partition* criterion. For example, if `n = 20`, then the candidates `1 <= i <= 20` can be pruned to  i = 9, 10, 18, or 19.\n\nThe reason for this necessary condition is based on *casting out nines* . principle. An integer `num` satisfies the *partition* criterion  only if:\n```\n           (num%9)**2 == num %9, \n```\nwhich implies this necessary condition. The details are left to the reader.\n\n"
                    },
                    {
                        "username": "arthur3366",
                        "content": "class Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        if (n<9) return 1;\\n        if (n==9) return 82; \\n        if (n<36) return 182;\\n        if (n<45) return 1478;\\n        if (n<55) return 3503;\\n        if (n<82) return 6528;\\n        if (n<91) return 13252;\\n        if (n<99) return 21533;\\n        if (n<100) return 31334; \\n        if (n<235) return 41334; \\n        if (n<297) return 96559; \\n        if (n<369) return 184768;\\n        if (n<370) return 320929;\\n        if (n<379) return 457829;\\n        if (n<414) return 601470;\\n        if (n<657) return 772866;\\n        if (n<675) return 1204515;\\n        if (n<703) return 1660140;\\n        if (n<756) return 2154349;\\n        if (n<792) return 2725885;\\n        if (n<909) return 3353149;\\n        if (n<918) return 4179430;\\n        if (n<945) return 5022154;\\n        if (n<964) return 5915179;\\n        if (n<990) return 6844475;\\n        if (n<991) return 7824575;\\n        if (n<999) return 8806656;\\n        if (n<1000) return 9804657;\\n        return 10804657;\\n         \\n    }\\n};"
                    },
                    {
                        "username": "Anisha2123",
                        "content": "Genius\\uD83D\\uDCAB"
                    },
                    {
                        "username": "hero080",
                        "content": "If you are trying DP and get TLE, or if you passed it with brutal force and don\\'t know why, here is the full explanation:\\nhttps://leetcode.com/problems/find-the-punishment-number-of-an-integer/solutions/3547280/0ms-tc-on-log-n-sc-olog-n-most-efficient-solution-simplest-code/"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How else tried implementing dp, but it passed without dp! "
                    },
                    {
                        "username": "ghouse_07",
                        "content": "It will pass as it has only one test cases,for multiple test cases dp is required."
                    },
                    {
                        "username": "danielmascena",
                        "content": "solved with a dp approach. The tip here I think is not to overthink about it"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "how can find punish number"
                    },
                    {
                        "username": "jaiswaldevansh27",
                        "content": "I dont understand the question, how  do we obtain \\'i\\' here? (refer the above example)\\nInput: n = 10\\nOutput: 182\\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1\\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\\nHence, the punishment number of 10 is 1 + 81 + 100 = 182\\n\\n\\nInput: n = 37\\nOutput: 1478\\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1. \\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \\n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig... \\'i\\' is any number in between 1<= i <= n such that below condition given in question should satisfy and punishment of n is  sum of i\\'s"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A tip:\nEven if you feel the precomputed results to be unfair, consider caching the values calculated at runtime in some static variable. This way the data would persist during the whole bunch of tests, and you won't be recomputing the same things over and over again."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "i think we have to invlove partition algo ..Am in right direction ??\\n"
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "Yes, you are right. Try making partitions by divding the numbers by 10, 100, 1000 ..."
                    }
                ]
            },
            {
                "id": 1900733,
                "content": [
                    {
                        "username": "padmavathidevi71625",
                        "content": "After 10+ wrong submissions\\nI came up with this\\n1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000\\n:)"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@to_string](/to_string) probably the outputs looool"
                    },
                    {
                        "username": "to_string",
                        "content": "Brother :) what is this \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Optimization Tip:\n\nA necessary condition for an integer `num` to satisfy the *partition* criterion  is: \n```\n            num %9 ==  0 or  num %9 ==  1.\n```\nThis necessary condition greatly reduces  the number of candidates to check the *partition* criterion. For example, if `n = 20`, then the candidates `1 <= i <= 20` can be pruned to  i = 9, 10, 18, or 19.\n\nThe reason for this necessary condition is based on *casting out nines* . principle. An integer `num` satisfies the *partition* criterion  only if:\n```\n           (num%9)**2 == num %9, \n```\nwhich implies this necessary condition. The details are left to the reader.\n\n"
                    },
                    {
                        "username": "arthur3366",
                        "content": "class Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        if (n<9) return 1;\\n        if (n==9) return 82; \\n        if (n<36) return 182;\\n        if (n<45) return 1478;\\n        if (n<55) return 3503;\\n        if (n<82) return 6528;\\n        if (n<91) return 13252;\\n        if (n<99) return 21533;\\n        if (n<100) return 31334; \\n        if (n<235) return 41334; \\n        if (n<297) return 96559; \\n        if (n<369) return 184768;\\n        if (n<370) return 320929;\\n        if (n<379) return 457829;\\n        if (n<414) return 601470;\\n        if (n<657) return 772866;\\n        if (n<675) return 1204515;\\n        if (n<703) return 1660140;\\n        if (n<756) return 2154349;\\n        if (n<792) return 2725885;\\n        if (n<909) return 3353149;\\n        if (n<918) return 4179430;\\n        if (n<945) return 5022154;\\n        if (n<964) return 5915179;\\n        if (n<990) return 6844475;\\n        if (n<991) return 7824575;\\n        if (n<999) return 8806656;\\n        if (n<1000) return 9804657;\\n        return 10804657;\\n         \\n    }\\n};"
                    },
                    {
                        "username": "Anisha2123",
                        "content": "Genius\\uD83D\\uDCAB"
                    },
                    {
                        "username": "hero080",
                        "content": "If you are trying DP and get TLE, or if you passed it with brutal force and don\\'t know why, here is the full explanation:\\nhttps://leetcode.com/problems/find-the-punishment-number-of-an-integer/solutions/3547280/0ms-tc-on-log-n-sc-olog-n-most-efficient-solution-simplest-code/"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How else tried implementing dp, but it passed without dp! "
                    },
                    {
                        "username": "ghouse_07",
                        "content": "It will pass as it has only one test cases,for multiple test cases dp is required."
                    },
                    {
                        "username": "danielmascena",
                        "content": "solved with a dp approach. The tip here I think is not to overthink about it"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "how can find punish number"
                    },
                    {
                        "username": "jaiswaldevansh27",
                        "content": "I dont understand the question, how  do we obtain \\'i\\' here? (refer the above example)\\nInput: n = 10\\nOutput: 182\\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1\\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\\nHence, the punishment number of 10 is 1 + 81 + 100 = 182\\n\\n\\nInput: n = 37\\nOutput: 1478\\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1. \\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \\n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig... \\'i\\' is any number in between 1<= i <= n such that below condition given in question should satisfy and punishment of n is  sum of i\\'s"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A tip:\nEven if you feel the precomputed results to be unfair, consider caching the values calculated at runtime in some static variable. This way the data would persist during the whole bunch of tests, and you won't be recomputing the same things over and over again."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "i think we have to invlove partition algo ..Am in right direction ??\\n"
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "Yes, you are right. Try making partitions by divding the numbers by 10, 100, 1000 ..."
                    }
                ]
            },
            {
                "id": 2076250,
                "content": [
                    {
                        "username": "padmavathidevi71625",
                        "content": "After 10+ wrong submissions\\nI came up with this\\n1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000\\n:)"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@to_string](/to_string) probably the outputs looool"
                    },
                    {
                        "username": "to_string",
                        "content": "Brother :) what is this \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Optimization Tip:\n\nA necessary condition for an integer `num` to satisfy the *partition* criterion  is: \n```\n            num %9 ==  0 or  num %9 ==  1.\n```\nThis necessary condition greatly reduces  the number of candidates to check the *partition* criterion. For example, if `n = 20`, then the candidates `1 <= i <= 20` can be pruned to  i = 9, 10, 18, or 19.\n\nThe reason for this necessary condition is based on *casting out nines* . principle. An integer `num` satisfies the *partition* criterion  only if:\n```\n           (num%9)**2 == num %9, \n```\nwhich implies this necessary condition. The details are left to the reader.\n\n"
                    },
                    {
                        "username": "arthur3366",
                        "content": "class Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        if (n<9) return 1;\\n        if (n==9) return 82; \\n        if (n<36) return 182;\\n        if (n<45) return 1478;\\n        if (n<55) return 3503;\\n        if (n<82) return 6528;\\n        if (n<91) return 13252;\\n        if (n<99) return 21533;\\n        if (n<100) return 31334; \\n        if (n<235) return 41334; \\n        if (n<297) return 96559; \\n        if (n<369) return 184768;\\n        if (n<370) return 320929;\\n        if (n<379) return 457829;\\n        if (n<414) return 601470;\\n        if (n<657) return 772866;\\n        if (n<675) return 1204515;\\n        if (n<703) return 1660140;\\n        if (n<756) return 2154349;\\n        if (n<792) return 2725885;\\n        if (n<909) return 3353149;\\n        if (n<918) return 4179430;\\n        if (n<945) return 5022154;\\n        if (n<964) return 5915179;\\n        if (n<990) return 6844475;\\n        if (n<991) return 7824575;\\n        if (n<999) return 8806656;\\n        if (n<1000) return 9804657;\\n        return 10804657;\\n         \\n    }\\n};"
                    },
                    {
                        "username": "Anisha2123",
                        "content": "Genius\\uD83D\\uDCAB"
                    },
                    {
                        "username": "hero080",
                        "content": "If you are trying DP and get TLE, or if you passed it with brutal force and don\\'t know why, here is the full explanation:\\nhttps://leetcode.com/problems/find-the-punishment-number-of-an-integer/solutions/3547280/0ms-tc-on-log-n-sc-olog-n-most-efficient-solution-simplest-code/"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How else tried implementing dp, but it passed without dp! "
                    },
                    {
                        "username": "ghouse_07",
                        "content": "It will pass as it has only one test cases,for multiple test cases dp is required."
                    },
                    {
                        "username": "danielmascena",
                        "content": "solved with a dp approach. The tip here I think is not to overthink about it"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "how can find punish number"
                    },
                    {
                        "username": "jaiswaldevansh27",
                        "content": "I dont understand the question, how  do we obtain \\'i\\' here? (refer the above example)\\nInput: n = 10\\nOutput: 182\\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1\\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\\nHence, the punishment number of 10 is 1 + 81 + 100 = 182\\n\\n\\nInput: n = 37\\nOutput: 1478\\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1. \\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \\n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig... \\'i\\' is any number in between 1<= i <= n such that below condition given in question should satisfy and punishment of n is  sum of i\\'s"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A tip:\nEven if you feel the precomputed results to be unfair, consider caching the values calculated at runtime in some static variable. This way the data would persist during the whole bunch of tests, and you won't be recomputing the same things over and over again."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "i think we have to invlove partition algo ..Am in right direction ??\\n"
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "Yes, you are right. Try making partitions by divding the numbers by 10, 100, 1000 ..."
                    }
                ]
            },
            {
                "id": 1962630,
                "content": [
                    {
                        "username": "padmavathidevi71625",
                        "content": "After 10+ wrong submissions\\nI came up with this\\n1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000\\n:)"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@to_string](/to_string) probably the outputs looool"
                    },
                    {
                        "username": "to_string",
                        "content": "Brother :) what is this \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Optimization Tip:\n\nA necessary condition for an integer `num` to satisfy the *partition* criterion  is: \n```\n            num %9 ==  0 or  num %9 ==  1.\n```\nThis necessary condition greatly reduces  the number of candidates to check the *partition* criterion. For example, if `n = 20`, then the candidates `1 <= i <= 20` can be pruned to  i = 9, 10, 18, or 19.\n\nThe reason for this necessary condition is based on *casting out nines* . principle. An integer `num` satisfies the *partition* criterion  only if:\n```\n           (num%9)**2 == num %9, \n```\nwhich implies this necessary condition. The details are left to the reader.\n\n"
                    },
                    {
                        "username": "arthur3366",
                        "content": "class Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        if (n<9) return 1;\\n        if (n==9) return 82; \\n        if (n<36) return 182;\\n        if (n<45) return 1478;\\n        if (n<55) return 3503;\\n        if (n<82) return 6528;\\n        if (n<91) return 13252;\\n        if (n<99) return 21533;\\n        if (n<100) return 31334; \\n        if (n<235) return 41334; \\n        if (n<297) return 96559; \\n        if (n<369) return 184768;\\n        if (n<370) return 320929;\\n        if (n<379) return 457829;\\n        if (n<414) return 601470;\\n        if (n<657) return 772866;\\n        if (n<675) return 1204515;\\n        if (n<703) return 1660140;\\n        if (n<756) return 2154349;\\n        if (n<792) return 2725885;\\n        if (n<909) return 3353149;\\n        if (n<918) return 4179430;\\n        if (n<945) return 5022154;\\n        if (n<964) return 5915179;\\n        if (n<990) return 6844475;\\n        if (n<991) return 7824575;\\n        if (n<999) return 8806656;\\n        if (n<1000) return 9804657;\\n        return 10804657;\\n         \\n    }\\n};"
                    },
                    {
                        "username": "Anisha2123",
                        "content": "Genius\\uD83D\\uDCAB"
                    },
                    {
                        "username": "hero080",
                        "content": "If you are trying DP and get TLE, or if you passed it with brutal force and don\\'t know why, here is the full explanation:\\nhttps://leetcode.com/problems/find-the-punishment-number-of-an-integer/solutions/3547280/0ms-tc-on-log-n-sc-olog-n-most-efficient-solution-simplest-code/"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How else tried implementing dp, but it passed without dp! "
                    },
                    {
                        "username": "ghouse_07",
                        "content": "It will pass as it has only one test cases,for multiple test cases dp is required."
                    },
                    {
                        "username": "danielmascena",
                        "content": "solved with a dp approach. The tip here I think is not to overthink about it"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "how can find punish number"
                    },
                    {
                        "username": "jaiswaldevansh27",
                        "content": "I dont understand the question, how  do we obtain \\'i\\' here? (refer the above example)\\nInput: n = 10\\nOutput: 182\\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1\\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\\nHence, the punishment number of 10 is 1 + 81 + 100 = 182\\n\\n\\nInput: n = 37\\nOutput: 1478\\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1. \\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \\n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig... \\'i\\' is any number in between 1<= i <= n such that below condition given in question should satisfy and punishment of n is  sum of i\\'s"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A tip:\nEven if you feel the precomputed results to be unfair, consider caching the values calculated at runtime in some static variable. This way the data would persist during the whole bunch of tests, and you won't be recomputing the same things over and over again."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "i think we have to invlove partition algo ..Am in right direction ??\\n"
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "Yes, you are right. Try making partitions by divding the numbers by 10, 100, 1000 ..."
                    }
                ]
            },
            {
                "id": 1933829,
                "content": [
                    {
                        "username": "padmavathidevi71625",
                        "content": "After 10+ wrong submissions\\nI came up with this\\n1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000\\n:)"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@to_string](/to_string) probably the outputs looool"
                    },
                    {
                        "username": "to_string",
                        "content": "Brother :) what is this \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Optimization Tip:\n\nA necessary condition for an integer `num` to satisfy the *partition* criterion  is: \n```\n            num %9 ==  0 or  num %9 ==  1.\n```\nThis necessary condition greatly reduces  the number of candidates to check the *partition* criterion. For example, if `n = 20`, then the candidates `1 <= i <= 20` can be pruned to  i = 9, 10, 18, or 19.\n\nThe reason for this necessary condition is based on *casting out nines* . principle. An integer `num` satisfies the *partition* criterion  only if:\n```\n           (num%9)**2 == num %9, \n```\nwhich implies this necessary condition. The details are left to the reader.\n\n"
                    },
                    {
                        "username": "arthur3366",
                        "content": "class Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        if (n<9) return 1;\\n        if (n==9) return 82; \\n        if (n<36) return 182;\\n        if (n<45) return 1478;\\n        if (n<55) return 3503;\\n        if (n<82) return 6528;\\n        if (n<91) return 13252;\\n        if (n<99) return 21533;\\n        if (n<100) return 31334; \\n        if (n<235) return 41334; \\n        if (n<297) return 96559; \\n        if (n<369) return 184768;\\n        if (n<370) return 320929;\\n        if (n<379) return 457829;\\n        if (n<414) return 601470;\\n        if (n<657) return 772866;\\n        if (n<675) return 1204515;\\n        if (n<703) return 1660140;\\n        if (n<756) return 2154349;\\n        if (n<792) return 2725885;\\n        if (n<909) return 3353149;\\n        if (n<918) return 4179430;\\n        if (n<945) return 5022154;\\n        if (n<964) return 5915179;\\n        if (n<990) return 6844475;\\n        if (n<991) return 7824575;\\n        if (n<999) return 8806656;\\n        if (n<1000) return 9804657;\\n        return 10804657;\\n         \\n    }\\n};"
                    },
                    {
                        "username": "Anisha2123",
                        "content": "Genius\\uD83D\\uDCAB"
                    },
                    {
                        "username": "hero080",
                        "content": "If you are trying DP and get TLE, or if you passed it with brutal force and don\\'t know why, here is the full explanation:\\nhttps://leetcode.com/problems/find-the-punishment-number-of-an-integer/solutions/3547280/0ms-tc-on-log-n-sc-olog-n-most-efficient-solution-simplest-code/"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How else tried implementing dp, but it passed without dp! "
                    },
                    {
                        "username": "ghouse_07",
                        "content": "It will pass as it has only one test cases,for multiple test cases dp is required."
                    },
                    {
                        "username": "danielmascena",
                        "content": "solved with a dp approach. The tip here I think is not to overthink about it"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "how can find punish number"
                    },
                    {
                        "username": "jaiswaldevansh27",
                        "content": "I dont understand the question, how  do we obtain \\'i\\' here? (refer the above example)\\nInput: n = 10\\nOutput: 182\\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1\\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\\nHence, the punishment number of 10 is 1 + 81 + 100 = 182\\n\\n\\nInput: n = 37\\nOutput: 1478\\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1. \\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \\n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig... \\'i\\' is any number in between 1<= i <= n such that below condition given in question should satisfy and punishment of n is  sum of i\\'s"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A tip:\nEven if you feel the precomputed results to be unfair, consider caching the values calculated at runtime in some static variable. This way the data would persist during the whole bunch of tests, and you won't be recomputing the same things over and over again."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "i think we have to invlove partition algo ..Am in right direction ??\\n"
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "Yes, you are right. Try making partitions by divding the numbers by 10, 100, 1000 ..."
                    }
                ]
            },
            {
                "id": 1906823,
                "content": [
                    {
                        "username": "padmavathidevi71625",
                        "content": "After 10+ wrong submissions\\nI came up with this\\n1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000\\n:)"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@to_string](/to_string) probably the outputs looool"
                    },
                    {
                        "username": "to_string",
                        "content": "Brother :) what is this \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Optimization Tip:\n\nA necessary condition for an integer `num` to satisfy the *partition* criterion  is: \n```\n            num %9 ==  0 or  num %9 ==  1.\n```\nThis necessary condition greatly reduces  the number of candidates to check the *partition* criterion. For example, if `n = 20`, then the candidates `1 <= i <= 20` can be pruned to  i = 9, 10, 18, or 19.\n\nThe reason for this necessary condition is based on *casting out nines* . principle. An integer `num` satisfies the *partition* criterion  only if:\n```\n           (num%9)**2 == num %9, \n```\nwhich implies this necessary condition. The details are left to the reader.\n\n"
                    },
                    {
                        "username": "arthur3366",
                        "content": "class Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        if (n<9) return 1;\\n        if (n==9) return 82; \\n        if (n<36) return 182;\\n        if (n<45) return 1478;\\n        if (n<55) return 3503;\\n        if (n<82) return 6528;\\n        if (n<91) return 13252;\\n        if (n<99) return 21533;\\n        if (n<100) return 31334; \\n        if (n<235) return 41334; \\n        if (n<297) return 96559; \\n        if (n<369) return 184768;\\n        if (n<370) return 320929;\\n        if (n<379) return 457829;\\n        if (n<414) return 601470;\\n        if (n<657) return 772866;\\n        if (n<675) return 1204515;\\n        if (n<703) return 1660140;\\n        if (n<756) return 2154349;\\n        if (n<792) return 2725885;\\n        if (n<909) return 3353149;\\n        if (n<918) return 4179430;\\n        if (n<945) return 5022154;\\n        if (n<964) return 5915179;\\n        if (n<990) return 6844475;\\n        if (n<991) return 7824575;\\n        if (n<999) return 8806656;\\n        if (n<1000) return 9804657;\\n        return 10804657;\\n         \\n    }\\n};"
                    },
                    {
                        "username": "Anisha2123",
                        "content": "Genius\\uD83D\\uDCAB"
                    },
                    {
                        "username": "hero080",
                        "content": "If you are trying DP and get TLE, or if you passed it with brutal force and don\\'t know why, here is the full explanation:\\nhttps://leetcode.com/problems/find-the-punishment-number-of-an-integer/solutions/3547280/0ms-tc-on-log-n-sc-olog-n-most-efficient-solution-simplest-code/"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How else tried implementing dp, but it passed without dp! "
                    },
                    {
                        "username": "ghouse_07",
                        "content": "It will pass as it has only one test cases,for multiple test cases dp is required."
                    },
                    {
                        "username": "danielmascena",
                        "content": "solved with a dp approach. The tip here I think is not to overthink about it"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "how can find punish number"
                    },
                    {
                        "username": "jaiswaldevansh27",
                        "content": "I dont understand the question, how  do we obtain \\'i\\' here? (refer the above example)\\nInput: n = 10\\nOutput: 182\\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1\\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\\nHence, the punishment number of 10 is 1 + 81 + 100 = 182\\n\\n\\nInput: n = 37\\nOutput: 1478\\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1. \\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \\n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig... \\'i\\' is any number in between 1<= i <= n such that below condition given in question should satisfy and punishment of n is  sum of i\\'s"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A tip:\nEven if you feel the precomputed results to be unfair, consider caching the values calculated at runtime in some static variable. This way the data would persist during the whole bunch of tests, and you won't be recomputing the same things over and over again."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "i think we have to invlove partition algo ..Am in right direction ??\\n"
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "Yes, you are right. Try making partitions by divding the numbers by 10, 100, 1000 ..."
                    }
                ]
            },
            {
                "id": 1901097,
                "content": [
                    {
                        "username": "padmavathidevi71625",
                        "content": "After 10+ wrong submissions\\nI came up with this\\n1,9,10,36,45,55,82,91,99,100,235,297,369,370,379,414,657,675,703,756,792,909,918,945,964,990,991,999,1000\\n:)"
                    },
                    {
                        "username": "Kromydas",
                        "content": "[@to_string](/to_string) probably the outputs looool"
                    },
                    {
                        "username": "to_string",
                        "content": "Brother :) what is this \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "Spaulding_",
                        "content": "Optimization Tip:\n\nA necessary condition for an integer `num` to satisfy the *partition* criterion  is: \n```\n            num %9 ==  0 or  num %9 ==  1.\n```\nThis necessary condition greatly reduces  the number of candidates to check the *partition* criterion. For example, if `n = 20`, then the candidates `1 <= i <= 20` can be pruned to  i = 9, 10, 18, or 19.\n\nThe reason for this necessary condition is based on *casting out nines* . principle. An integer `num` satisfies the *partition* criterion  only if:\n```\n           (num%9)**2 == num %9, \n```\nwhich implies this necessary condition. The details are left to the reader.\n\n"
                    },
                    {
                        "username": "arthur3366",
                        "content": "class Solution {\\npublic:\\n    int punishmentNumber(int n) {\\n        if (n<9) return 1;\\n        if (n==9) return 82; \\n        if (n<36) return 182;\\n        if (n<45) return 1478;\\n        if (n<55) return 3503;\\n        if (n<82) return 6528;\\n        if (n<91) return 13252;\\n        if (n<99) return 21533;\\n        if (n<100) return 31334; \\n        if (n<235) return 41334; \\n        if (n<297) return 96559; \\n        if (n<369) return 184768;\\n        if (n<370) return 320929;\\n        if (n<379) return 457829;\\n        if (n<414) return 601470;\\n        if (n<657) return 772866;\\n        if (n<675) return 1204515;\\n        if (n<703) return 1660140;\\n        if (n<756) return 2154349;\\n        if (n<792) return 2725885;\\n        if (n<909) return 3353149;\\n        if (n<918) return 4179430;\\n        if (n<945) return 5022154;\\n        if (n<964) return 5915179;\\n        if (n<990) return 6844475;\\n        if (n<991) return 7824575;\\n        if (n<999) return 8806656;\\n        if (n<1000) return 9804657;\\n        return 10804657;\\n         \\n    }\\n};"
                    },
                    {
                        "username": "Anisha2123",
                        "content": "Genius\\uD83D\\uDCAB"
                    },
                    {
                        "username": "hero080",
                        "content": "If you are trying DP and get TLE, or if you passed it with brutal force and don\\'t know why, here is the full explanation:\\nhttps://leetcode.com/problems/find-the-punishment-number-of-an-integer/solutions/3547280/0ms-tc-on-log-n-sc-olog-n-most-efficient-solution-simplest-code/"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "How else tried implementing dp, but it passed without dp! "
                    },
                    {
                        "username": "ghouse_07",
                        "content": "It will pass as it has only one test cases,for multiple test cases dp is required."
                    },
                    {
                        "username": "danielmascena",
                        "content": "solved with a dp approach. The tip here I think is not to overthink about it"
                    },
                    {
                        "username": "raviprajapatikandari",
                        "content": "how can find punish number"
                    },
                    {
                        "username": "jaiswaldevansh27",
                        "content": "I dont understand the question, how  do we obtain \\'i\\' here? (refer the above example)\\nInput: n = 10\\nOutput: 182\\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1\\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\\nHence, the punishment number of 10 is 1 + 81 + 100 = 182\\n\\n\\nInput: n = 37\\nOutput: 1478\\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\\n- 1 since 1 * 1 = 1. \\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \\n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "ig... \\'i\\' is any number in between 1<= i <= n such that below condition given in question should satisfy and punishment of n is  sum of i\\'s"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A tip:\nEven if you feel the precomputed results to be unfair, consider caching the values calculated at runtime in some static variable. This way the data would persist during the whole bunch of tests, and you won't be recomputing the same things over and over again."
                    },
                    {
                        "username": "purushattom1999",
                        "content": "i think we have to invlove partition algo ..Am in right direction ??\\n"
                    },
                    {
                        "username": "Aditya_Prajapati",
                        "content": "Yes, you are right. Try making partitions by divding the numbers by 10, 100, 1000 ..."
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Strength of a Group",
        "question_content": "<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> representing the score of students in an exam. The teacher would like to form one <strong>non-empty</strong> group of students with maximal <strong>strength</strong>, where the strength of a group of students of indices <code>i<sub>0</sub></code>, <code>i<sub>1</sub></code>, <code>i<sub>2</sub></code>, ... , <code>i<sub>k</sub></code> is defined as <code>nums[i<sub>0</sub>] * nums[i<sub>1</sub>] * nums[i<sub>2</sub>] * ... * nums[i<sub>k</sub>]</code>.</p>\n\n<p>Return <em>the maximum strength of a group the teacher can create</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,-1,-5,2,5,-9]\n<strong>Output:</strong> 1350\n<strong>Explanation:</strong> One way to form a group of maximal strength is to group the students at indices [0,2,3,4,5]. Their strength is 3 * (-5) * 2 * 5 * (-9) = 1350, which we can show is optimal.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-4,-5,-4]\n<strong>Output:</strong> 20\n<strong>Explanation:</strong> Group the students at indices [0, 1] . Then, we&rsquo;ll have a resulting strength of 20. We cannot achieve greater strength.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 13</code></li>\n\t<li><code>-9 &lt;= nums[i] &lt;= 9</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3568549,
                "title": "explained-product-of-all-non-zero-o-n-very-simple-easy-to-understand-solution",
                "content": "<b>Up vote if you like the solution </b>\\n\\n# Approach\\n2. 1. We just need to take product of all numbers & also keep tracking the largest negative number.\\n2. Check if the product is negative then devide it by the largest negative number. ( Basically we want to remove the largest negative number or you can say smallest abs valued negative number)\\n3. Above is the case when there is no 0 or the case when only one negative number. So to handle the edge cases :\\n    i) check the largest number is equal to zero and no of negative count is less than 2 then return 0.\\n    ii) check if the largest number is negative and if the negative number count is less than 2 then return the largest negative number.\\n If we have case non of the above then two then go with first two steps conditions.\\n\\n# Code\\n```\\nlong long maxStrength(vector<int>& nums) {\\n    long long prod = 1;\\n    int largestNegative = INT_MIN, largest = INT_MIN, negCount = 0;\\n    for(auto n: nums){\\n        if(n) prod *= n;\\n        if(n < 0 ) { largestNegative = max(largestNegative, n); negCount++; }\\n        largest = max(largest, n);\\n    }\\n    if(largest == 0 && negCount < 2) return 0;\\n    if(largest < 0 && negCount == 1) return largestNegative;\\n    if(prod > 0 ) return prod;\\n    return prod/largestNegative;\\n}\\n```\\n\\n<b> Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nlong long maxStrength(vector<int>& nums) {\\n    long long prod = 1;\\n    int largestNegative = INT_MIN, largest = INT_MIN, negCount = 0;\\n    for(auto n: nums){\\n        if(n) prod *= n;\\n        if(n < 0 ) { largestNegative = max(largestNegative, n); negCount++; }\\n        largest = max(largest, n);\\n    }\\n    if(largest == 0 && negCount < 2) return 0;\\n    if(largest < 0 && negCount == 1) return largestNegative;\\n    if(prod > 0 ) return prod;\\n    return prod/largestNegative;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3568596,
                "title": "sort",
                "content": "Greedy works - take all positive scores, and all pairs of negative scores.\\n\\nWe skip an odd negative score with the smallest absolute value.\\n    \\nIt\\'s easier to sort the numbers to do so (`n` is small anyways).\\n    \\n> Beware of the edge case when we did not pick any score. In that case, we return the largest score.\\n    \\n**C++**\\n```cpp\\nlong long maxStrength(vector<int>& nums) {\\n    sort(begin(nums), end(nums));\\n    long long res = 1, sz = nums.size(), cnt = 0;\\n    for (int i = 0; i < sz; ++i)\\n        if (res * nums[i] > 0 || (i + 1 < sz && nums[i + 1] < 0)) {\\n            res *= nums[i];\\n            ++cnt;\\n        }\\n    return cnt ? res : nums.back();\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nlong long maxStrength(vector<int>& nums) {\\n    sort(begin(nums), end(nums));\\n    long long res = 1, sz = nums.size(), cnt = 0;\\n    for (int i = 0; i < sz; ++i)\\n        if (res * nums[i] > 0 || (i + 1 < sz && nums[i + 1] < 0)) {\\n            res *= nums[i];\\n            ++cnt;\\n        }\\n    return cnt ? res : nums.back();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3568709,
                "title": "simple-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    long long ans = INT_MIN;\\n    void solve(vector<int>&nums, int index, long long product, int size)\\n    {\\n        if (index == nums.size()) \\n        { \\n            //we need a non empty group\\n            if (size != 0) ans = max(ans, product);  \\n            return; \\n        }\\n        solve(nums, index + 1, product * nums[index], size + 1); //pick\\n        solve(nums, index + 1, product, size); //not pick\\n    }\\n    long long maxStrength(vector<int>& nums) \\n    {\\n        solve(nums, 0, 1, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long ans = INT_MIN;\\n    void solve(vector<int>&nums, int index, long long product, int size)\\n    {\\n        if (index == nums.size()) \\n        { \\n            //we need a non empty group\\n            if (size != 0) ans = max(ans, product);  \\n            return; \\n        }\\n        solve(nums, index + 1, product * nums[index], size + 1); //pick\\n        solve(nums, index + 1, product, size); //not pick\\n    }\\n    long long maxStrength(vector<int>& nums) \\n    {\\n        solve(nums, 0, 1, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568541,
                "title": "python-elegant-short-remove-maximum-from-negative-commented-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        contains_zero = False\\n        positive = []\\n        negative = []\\n\\n        for num in nums:\\n            if num > 0:\\n                positive.append(num)\\n            elif num < 0:\\n                negative.append(num)\\n            else:\\n                contains_zero = True\\n\\n        # If the product of negative numbers is negative\\n        if len(negative) & 1:\\n            # If there is more than one negative number,\\n            # then their product can be positive.\\n            if len(negative) > 1:\\n                negative.remove(max(negative))\\n            # If not, then the product of positive numbers is sufficient\\n            elif positive:\\n                return prod(positive)\\n            # If not again, then zero is greater than negative numbers.\\n            elif contains_zero:\\n                return 0\\n            # If again not, then return the maximum among the negative\\n            else:\\n                return max(negative)\\n\\n        # Consists of zeros only\\n        if not (negative or positive):\\n            return 0\\n\\n        return prod(negative) * prod(positive)\\n```\\n\\n# Important\\nIf you like this solution remember to **upvote it** to let me know.\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        contains_zero = False\\n        positive = []\\n        negative = []\\n\\n        for num in nums:\\n            if num > 0:\\n                positive.append(num)\\n            elif num < 0:\\n                negative.append(num)\\n            else:\\n                contains_zero = True\\n\\n        # If the product of negative numbers is negative\\n        if len(negative) & 1:\\n            # If there is more than one negative number,\\n            # then their product can be positive.\\n            if len(negative) > 1:\\n                negative.remove(max(negative))\\n            # If not, then the product of positive numbers is sufficient\\n            elif positive:\\n                return prod(positive)\\n            # If not again, then zero is greater than negative numbers.\\n            elif contains_zero:\\n                return 0\\n            # If again not, then return the maximum among the negative\\n            else:\\n                return max(negative)\\n\\n        # Consists of zeros only\\n        if not (negative or positive):\\n            return 0\\n\\n        return prod(negative) * prod(positive)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602454,
                "title": "explained-simple-and-clear-python3-code",
                "content": "# Intuition\\nThe goal of this problem is to form a group of students with maximal strength, where the strength of a group is defined as the product of the scores of the students in that group. We can approach this problem by separating the positive and negative numbers in the given array. By doing this, we can maximize the strength by considering the product of positive numbers and an even number of negative numbers (or excluding one negative number if there is an odd number of negatives).\\n\\n\\n# Approach\\nTo maximize the strength of a group of students based on their scores, we can follow these steps:\\n1.\\tInitialize two empty lists, \\'pos\\' and \\'neg\\', to store the positive and negative numbers from the given \\'nums\\' array.\\n2.\\tIf the length of the \\'nums\\' array is 1, return that single element as it represents the maximum strength in this case.\\n3.\\tIterate through each element \\'x\\' in the \\'nums\\' array:\\n\\u2022\\tIf \\'x\\' is greater than 0, add it to the \\'pos\\' list.\\n\\u2022\\tIf \\'x\\' is less than 0, add its absolute value (-x) to the \\'neg\\' list.\\n4.\\tSort the \\'neg\\' list in reverse order, placing the largest negative numbers at the front.\\n5.\\tIf the length of the \\'neg\\' list is odd, remove the last element to ensure an even number of negative numbers.\\n6.\\tCheck if both the \\'neg\\' and \\'pos\\' lists are empty. If they are, return 0 as there are no elements to form a group.\\n7.\\tOtherwise, initialize a variable \\'res\\' to 1, which will store the maximum strength.\\n8.\\tMultiply \\'res\\' by each element \\'x\\' in the \\'neg\\' list using a loop.\\n9.\\tMultiply \\'res\\' by each element \\'x\\' in the \\'pos\\' list using another loop.\\n10.\\tFinally, return \\'res\\' as the maximum strength of the group.\\nBy separating the positive and negative numbers and considering the product of positive numbers and an even number of negative numbers, we ensure that the group\\'s strength is maximized.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this approach is dominated by the sorting operation on the \\'neg\\' list, which takes O(n log n) time. The loops to multiply the elements contribute O(n) time complexity. Therefore, the overall time complexity is O(n log n).\\n- Space complexity:\\nThe space complexity is determined by the additional space used to store the \\'pos\\' and \\'neg\\' lists, which can have a maximum size of \\'n\\', where \\'n\\' is the length of the \\'nums\\' array. Hence, the space complexity is O(n).\\n# Code\\n```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        pos,neg=[],[]\\n\\n        if len(nums)==1:\\n            return nums[0]\\n\\n        for x in nums:\\n            if x>0:\\n                pos.append(x)\\n            elif x<0:\\n                neg.append(-x)\\n\\n        neg.sort(reverse=True)\\n        \\n        if len(neg)%2==1:\\n            neg.pop()\\n\\n        if len(neg)==0 and len(pos)==0:\\n            return 0\\n        else:\\n            res=1\\n            for x in neg: res*=x\\n            for x in pos: res*=x\\n            return res\\n       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        pos,neg=[],[]\\n\\n        if len(nums)==1:\\n            return nums[0]\\n\\n        for x in nums:\\n            if x>0:\\n                pos.append(x)\\n            elif x<0:\\n                neg.append(-x)\\n\\n        neg.sort(reverse=True)\\n        \\n        if len(neg)%2==1:\\n            neg.pop()\\n\\n        if len(neg)==0 and len(pos)==0:\\n            return 0\\n        else:\\n            res=1\\n            for x in neg: res*=x\\n            for x in pos: res*=x\\n            return res\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568577,
                "title": "java-greedy-solution-sorting",
                "content": "```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        //sorting the array\\n        Arrays.sort(nums);\\n        //initializing with the bigger number\\n        long prdt=nums[nums.length-1];\\n        int p1=0;\\n        //counting neg numbers\\n        for(int x:nums){\\n            if(x<0)p1++;\\n        }\\n     \\n        int flag=0;\\n        //if count of neg numbers are odd then making it even\\n        if(p1%2==1)p1--;\\n        //mul the neg numbers\\n        for(int x:nums){\\n            if(p1==0)break;\\n            if(flag==0){\\n                prdt=1l;\\n                flag++;\\n            }\\n            prdt*=1l*x;\\n            p1--;\\n            \\n        }\\n       // mul the pos numbers\\n        int n=nums.length;\\n        for(int i=n-1;i>=0;i--){\\n            \\n            if(nums[i]<=0)break;\\n            if(flag==0){\\n                prdt=1l;\\n                flag++;\\n            }\\n            prdt*=1l*nums[i];\\n        }\\n        return prdt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        //sorting the array\\n        Arrays.sort(nums);\\n        //initializing with the bigger number\\n        long prdt=nums[nums.length-1];\\n        int p1=0;\\n        //counting neg numbers\\n        for(int x:nums){\\n            if(x<0)p1++;\\n        }\\n     \\n        int flag=0;\\n        //if count of neg numbers are odd then making it even\\n        if(p1%2==1)p1--;\\n        //mul the neg numbers\\n        for(int x:nums){\\n            if(p1==0)break;\\n            if(flag==0){\\n                prdt=1l;\\n                flag++;\\n            }\\n            prdt*=1l*x;\\n            p1--;\\n            \\n        }\\n       // mul the pos numbers\\n        int n=nums.length;\\n        for(int i=n-1;i>=0;i--){\\n            \\n            if(nums[i]<=0)break;\\n            if(flag==0){\\n                prdt=1l;\\n                flag++;\\n            }\\n            prdt*=1l*nums[i];\\n        }\\n        return prdt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568557,
                "title": "c-solution-pick-or-not-pick-recursive-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n                 return getMaxStrength(nums, 0, 1, false);\\n    }\\n\\nprivate:\\n    long long getMaxStrength(vector<int>& nums, int start, long long product, bool nonZeroFlag) {\\n        if (start == nums.size()) {\\n            if (!nonZeroFlag) {\\n                long long maxNegative = INT64_MIN;\\n                for (int num : nums) {\\n                    if (num < 0 && num > maxNegative) {\\n                        maxNegative = num;\\n                    }\\n                }\\n                return maxNegative;\\n            }\\n            return product;\\n        }\\n\\n        // Check if product becomes zero\\n        if (product == 0) {\\n            return 0;\\n        }\\n\\n        // Pick the current element and recursively calculate the strength\\n        long long pick = getMaxStrength(nums, start + 1, product * nums[start], true);\\n\\n        // Not pick the current element and recursively calculate the strength\\n        long long notPick = getMaxStrength(nums, start + 1, product, nonZeroFlag);\\n\\n        // Return the maximum strength between the two choices\\n        return max(pick, notPick);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n                 return getMaxStrength(nums, 0, 1, false);\\n    }\\n\\nprivate:\\n    long long getMaxStrength(vector<int>& nums, int start, long long product, bool nonZeroFlag) {\\n        if (start == nums.size()) {\\n            if (!nonZeroFlag) {\\n                long long maxNegative = INT64_MIN;\\n                for (int num : nums) {\\n                    if (num < 0 && num > maxNegative) {\\n                        maxNegative = num;\\n                    }\\n                }\\n                return maxNegative;\\n            }\\n            return product;\\n        }\\n\\n        // Check if product becomes zero\\n        if (product == 0) {\\n            return 0;\\n        }\\n\\n        // Pick the current element and recursively calculate the strength\\n        long long pick = getMaxStrength(nums, start + 1, product * nums[start], true);\\n\\n        // Not pick the current element and recursively calculate the strength\\n        long long notPick = getMaxStrength(nums, start + 1, product, nonZeroFlag);\\n\\n        // Return the maximum strength between the two choices\\n        return max(pick, notPick);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568799,
                "title": "o-1-solution-sorting-c-java-python",
                "content": "# Intuition\\n**``` Try to maximize the product by picking all positives elements and even number of negative elements```**\\n# Approach\\n**``` Have Seperate arrays for positives and negatives. In order to maximize the product take even numbers of negative elements which would give the max value```**\\n\\n# Complexity\\n- Time complexity:\\n**```O(NLOGN) but since the constraints are very minimum it can be considered as O(1) \\uD83D\\uDE43```**\\n\\n- Space complexity:\\n**```O(N)```**\\n\\n\\n**``` Please Upvote if it was helpful  \\uD83D\\uDE07 \\uD83D\\uDE07```**\\n# Code (C++)\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        long long n = nums.size();\\n        vector<long long> negs, pos;\\n        for (auto it : nums)\\n        {\\n            if (it < 0)\\n                negs.push_back(it);\\n            if (it > 0)\\n                pos.push_back(it);\\n        }\\n        long long prod = 1, x = count(nums.begin(), nums.end(), 0);\\n        sort(negs.begin(), negs.end());\\n        if (negs.size() <= 1 && pos.size() == 0)\\n        {\\n            return *max_element(nums.begin(), nums.end());\\n        }\\n        if (negs.size() % 2 == 0)\\n        {\\n            for (auto it : negs)\\n                prod = prod * it;\\n            for (auto it : pos)\\n                prod = prod * it;\\n            return prod;\\n        }  \\n        else\\n        {\\n            for (int i = 0; i < negs.size() - 1; ++i)\\n                prod = prod * negs[i];\\n            for (auto it : pos)\\n                prod = prod * it;\\n            return prod;\\n        }\\n        return prod;\\n    }\\n};\\n```\\n# Code (Java)\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        int n = nums.length;\\n        List<Long> negs = new ArrayList<>();\\n        List<Long> pos = new ArrayList<>();\\n        for (int num : nums) {\\n            if (num < 0)\\n                negs.add((long) num);\\n            if (num > 0)\\n                pos.add((long) num);\\n        }\\n        long prod = 1;\\n        long x = Collections.frequency(Arrays.asList(nums), 0);\\n        Collections.sort(negs);\\n        if (negs.size() <= 1 && pos.size() == 0)\\n            return Arrays.stream(nums).max().getAsInt();\\n        if (negs.size() % 2 == 0) {\\n            for (long num : negs)\\n                prod = prod * num;\\n            for (long num : pos)\\n                prod = prod * num;\\n            return prod;\\n        } else {\\n            for (int i = 0; i < negs.size() - 1; ++i)\\n                prod = prod * negs.get(i);\\n            for (long num : pos)\\n                prod = prod * num;\\n            return prod;\\n        }\\n    }\\n}\\n```\\n# Code (Python)\\n```\\nimport math\\n\\nclass Solution:\\n    def maxStrength(self, nums):\\n        negs = []\\n        pos = []\\n        \\n        for num in nums:\\n            if num < 0:\\n                negs.append(num)\\n            elif num > 0:\\n                pos.append(num)\\n        \\n        prod = 1\\n        x = nums.count(0)\\n        negs.sort()\\n        \\n        if len(negs) <= 1 and len(pos) == 0:\\n            return max(nums)\\n        \\n        if len(negs) % 2 == 0:\\n            for num in negs:\\n                prod *= num\\n            for num in pos:\\n                prod *= num\\n            return prod\\n        else:\\n            for i in range(len(negs) - 1):\\n                prod *= negs[i]\\n            for num in pos:\\n                prod *= num\\n            return prod\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "``` Try to maximize the product by picking all positives elements and even number of negative elements```\n``` Have Seperate arrays for positives and negatives. In order to maximize the product take even numbers of negative elements which would give the max value```\n```O(NLOGN) but since the constraints are very minimum it can be considered as O(1) \\uD83D\\uDE43```\n```O(N)```\n``` Please Upvote if it was helpful  \\uD83D\\uDE07 \\uD83D\\uDE07```\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        long long n = nums.size();\\n        vector<long long> negs, pos;\\n        for (auto it : nums)\\n        {\\n            if (it < 0)\\n                negs.push_back(it);\\n            if (it > 0)\\n                pos.push_back(it);\\n        }\\n        long long prod = 1, x = count(nums.begin(), nums.end(), 0);\\n        sort(negs.begin(), negs.end());\\n        if (negs.size() <= 1 && pos.size() == 0)\\n        {\\n            return *max_element(nums.begin(), nums.end());\\n        }\\n        if (negs.size() % 2 == 0)\\n        {\\n            for (auto it : negs)\\n                prod = prod * it;\\n            for (auto it : pos)\\n                prod = prod * it;\\n            return prod;\\n        }  \\n        else\\n        {\\n            for (int i = 0; i < negs.size() - 1; ++i)\\n                prod = prod * negs[i];\\n            for (auto it : pos)\\n                prod = prod * it;\\n            return prod;\\n        }\\n        return prod;\\n    }\\n};\\n```\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        int n = nums.length;\\n        List<Long> negs = new ArrayList<>();\\n        List<Long> pos = new ArrayList<>();\\n        for (int num : nums) {\\n            if (num < 0)\\n                negs.add((long) num);\\n            if (num > 0)\\n                pos.add((long) num);\\n        }\\n        long prod = 1;\\n        long x = Collections.frequency(Arrays.asList(nums), 0);\\n        Collections.sort(negs);\\n        if (negs.size() <= 1 && pos.size() == 0)\\n            return Arrays.stream(nums).max().getAsInt();\\n        if (negs.size() % 2 == 0) {\\n            for (long num : negs)\\n                prod = prod * num;\\n            for (long num : pos)\\n                prod = prod * num;\\n            return prod;\\n        } else {\\n            for (int i = 0; i < negs.size() - 1; ++i)\\n                prod = prod * negs.get(i);\\n            for (long num : pos)\\n                prod = prod * num;\\n            return prod;\\n        }\\n    }\\n}\\n```\n```\\nimport math\\n\\nclass Solution:\\n    def maxStrength(self, nums):\\n        negs = []\\n        pos = []\\n        \\n        for num in nums:\\n            if num < 0:\\n                negs.append(num)\\n            elif num > 0:\\n                pos.append(num)\\n        \\n        prod = 1\\n        x = nums.count(0)\\n        negs.sort()\\n        \\n        if len(negs) <= 1 and len(pos) == 0:\\n            return max(nums)\\n        \\n        if len(negs) % 2 == 0:\\n            for num in negs:\\n                prod *= num\\n            for num in pos:\\n                prod *= num\\n            return prod\\n        else:\\n            for i in range(len(negs) - 1):\\n                prod *= negs[i]\\n            for num in pos:\\n                prod *= num\\n            return prod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568699,
                "title": "clean-simple-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    long max = 0;\\n    public long maxStrength(int[] nums) {\\n        if (nums.length == 1)   return nums[0];\\n        int pos = 0, neg = 0, z = 0;\\n        for(int num : nums){\\n            if(num > 0)    pos++;\\n            else if(num < 0)   neg++;\\n            else z++;\\n        }\\n        if (pos == 0 && neg == 1 && nums.length > 1)    return 0;\\n        if(z == nums.length)  return 0;\\n        group(nums, 0, 1);\\n        return max;\\n    }\\n    void group(int[] nums, int i, long grp) {\\n        if(i >= nums.length){\\n            max = Math.max(max, grp);\\n            return;\\n        }\\n        group(nums, i + 1, grp * nums[i]);\\n        group(nums, i + 1, grp);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    long max = 0;\\n    public long maxStrength(int[] nums) {\\n        if (nums.length == 1)   return nums[0];\\n        int pos = 0, neg = 0, z = 0;\\n        for(int num : nums){\\n            if(num > 0)    pos++;\\n            else if(num < 0)   neg++;\\n            else z++;\\n        }\\n        if (pos == 0 && neg == 1 && nums.length > 1)    return 0;\\n        if(z == nums.length)  return 0;\\n        group(nums, 0, 1);\\n        return max;\\n    }\\n    void group(int[] nums, int i, long grp) {\\n        if(i >= nums.length){\\n            max = Math.max(max, grp);\\n            return;\\n        }\\n        group(nums, i + 1, grp * nums[i]);\\n        group(nums, i + 1, grp);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568672,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->To find the maximal strength, we need to consider all possible subsets of indices. For each subset, we calculate the strength by multiplying the corresponding elements from the input array. The maximal strength is the maximum strength encountered among all subsets.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a variable maxStrength to a minimum value, which will store the maximum strength encountered.\\n2. Iterate through all possible subsets of indices using bitmasking.\\n- Start from 1 and iterate until the bitmask is less than the maximum subset size.\\n- Calculate the maximum subset size as 2 to the power of n, where n is the size of the input array.\\n3. For each subset represented by the bitmask:\\n- Initialize a variable strength to 1, which will store the strength of the current subset.\\n- Iterate through the indices of the input array.\\n4. If the corresponding bit in the bitmask is set (i.e., the bitwise AND operation between the bitmask and (1 << i) is non-zero), include the element at that index in the strength calculation by multiplying it with strength.\\n- If the calculated strength is greater than the current maxStrength, update maxStrength with the new value.\\n5. After iterating through all possible subsets, maxStrength will contain the maximum strength encountered.\\n6. Return maxStrength as the result.\\n\\nBy following this approach, we consider all possible subsets of indices and calculate the strength for each subset. The maximum strength encountered is stored and returned as the result, representing the maximal strength of a group formed by selecting any subset of indices.\\n\\nI hope this provides a clear understanding of the intuition and approach used to solve the problem. Let me know if you have any further questions!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) \\n    {\\n         int n = nums.size();\\n        if (n == 0) {\\n            // Handle the case when the input vector is empty\\n            return 0;\\n        }\\n\\n        int maxSubsetSize = pow(2, n);\\n        long long maxStrength = INT_MIN;\\n\\n        for (int mask = 1; mask < maxSubsetSize; mask++) {\\n            long long strength = 1;\\n\\n            for (int i = 0; i < n; i++) {\\n                if (mask & (1 << i)) {\\n                    strength *= nums[i];\\n                }\\n            }\\n\\n            maxStrength = max(maxStrength, strength);\\n        }\\n\\n        return maxStrength;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) \\n    {\\n         int n = nums.size();\\n        if (n == 0) {\\n            // Handle the case when the input vector is empty\\n            return 0;\\n        }\\n\\n        int maxSubsetSize = pow(2, n);\\n        long long maxStrength = INT_MIN;\\n\\n        for (int mask = 1; mask < maxSubsetSize; mask++) {\\n            long long strength = 1;\\n\\n            for (int i = 0; i < n; i++) {\\n                if (mask & (1 << i)) {\\n                    strength *= nums[i];\\n                }\\n            }\\n\\n            maxStrength = max(maxStrength, strength);\\n        }\\n\\n        return maxStrength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569327,
                "title": "very-simple-brute-force-knapsack-x-no-greedy-x-python-and-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLooking at the constraints we can realize that solution can have complexity upto `2^n`.\\nSimple Knapsack solution can be applied.\\n\\nEither we can consider an element at ith position or not consider it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n`Helper(nums, ind, prod, took)`In this function\\n- `ind` indicates that we have to decide whether to take element at position ith or not take it.\\n- `prod` is the product after reaching the `ind` index.\\n- `took` is a variable to consider the fact that the subsequence that we choose has at least 1 element.\\n- If we take the element at `ind` we call `helper(nums, ind + 1, prod, took);` Taking the elements makes took = true cause now we can say that the subsequence must have atleast 1 element. \\n- If we donot take the element at `ind` we call `helper(nums, ind + 1, prod, took);`. We pass on the took value if we previously took an elment it will be true else false.\\n- **BASE CASE** : \\n    ```\\n    if(nums.size() == ind){\\n        // Considering the answer only if the at\\n        // least one element is taken.\\n        if(took)\\n            ans = max(ans, prod);\\n        return;\\n    }\\n    ```\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:`2^n`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `2^n Stack space`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` Python []\\nclass Solution:\\n    ans = -1e18\\n    def helper(self, nums, ind, prod, took):\\n        if ind == len(nums):\\n            global ans\\n            if took:\\n                self.ans = max(self.ans, prod)\\n            return\\n        self.helper(nums, ind + 1, prod * nums[ind], True)\\n        self.helper(nums, ind + 1, prod, took)\\n    def maxStrength(self, nums: List[int]) -> int:\\n        self.helper(nums, 0, 1, False)\\n        return int(self.ans)\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    long long ans = -1e18;\\n    void helper(vector<int> &nums, int ind, long long prod, bool took){\\n        if(nums.size() == ind){\\n            if(took)\\n            ans = max(ans, prod);\\n            return;\\n        }\\n        helper(nums, ind + 1, prod, took);\\n        helper(nums, ind + 1, nums[ind] * prod, true);\\n    }\\n    long long maxStrength(vector<int>& nums) {\\n        helper(nums, 0, 1, false);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n    if(nums.size() == ind){\\n        // Considering the answer only if the at\\n        // least one element is taken.\\n        if(took)\\n            ans = max(ans, prod);\\n        return;\\n    }\\n    ```\n``` Python []\\nclass Solution:\\n    ans = -1e18\\n    def helper(self, nums, ind, prod, took):\\n        if ind == len(nums):\\n            global ans\\n            if took:\\n                self.ans = max(self.ans, prod)\\n            return\\n        self.helper(nums, ind + 1, prod * nums[ind], True)\\n        self.helper(nums, ind + 1, prod, took)\\n    def maxStrength(self, nums: List[int]) -> int:\\n        self.helper(nums, 0, 1, False)\\n        return int(self.ans)\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    long long ans = -1e18;\\n    void helper(vector<int> &nums, int ind, long long prod, bool took){\\n        if(nums.size() == ind){\\n            if(took)\\n            ans = max(ans, prod);\\n            return;\\n        }\\n        helper(nums, ind + 1, prod, took);\\n        helper(nums, ind + 1, nums[ind] * prod, true);\\n    }\\n    long long maxStrength(vector<int>& nums) {\\n        helper(nums, 0, 1, false);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568783,
                "title": "no-recursion-simple-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Beats 100%\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Loops and condition only\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    o(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    3 variables only\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n    long pod=1;\\n    int largestNeg=Integer.MIN_VALUE;\\n    int largest=Integer.MIN_VALUE;\\n    int neg=0;\\n\\n    for(int num: nums){\\n        if(num!=0){\\n            pod*=num;\\n        } \\n        if(num<0){\\n            largestNeg=Math.max(largestNeg,num);\\n            neg++;\\n        }\\n        largest =Math.max(largest,num);\\n    }\\n    if(largest ==0 && neg<2) return 0;\\n    if(largest<0 && neg==1) return largestNeg;\\n    if(pod>0) return pod;\\n    return pod/largestNeg;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n    long pod=1;\\n    int largestNeg=Integer.MIN_VALUE;\\n    int largest=Integer.MIN_VALUE;\\n    int neg=0;\\n\\n    for(int num: nums){\\n        if(num!=0){\\n            pod*=num;\\n        } \\n        if(num<0){\\n            largestNeg=Math.max(largestNeg,num);\\n            neg++;\\n        }\\n        largest =Math.max(largest,num);\\n    }\\n    if(largest ==0 && neg<2) return 0;\\n    if(largest<0 && neg==1) return largestNeg;\\n    if(pod>0) return pod;\\n    return pod/largestNeg;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568547,
                "title": "c-very-simple-and-easy-to-understand-backtracking",
                "content": "# Intuition\\nAfter observing the constraints first approach came to my mind is to make all subsets using backtracking and find product of each set to find maximum value.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: O(2^13)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long ans = INT_MIN;\\n    void solve(vector<int>& nums, int i, long long prod){\\n        if(i>=nums.size()){\\n            ans = max(ans,prod);\\n            return;\\n        }\\n        solve(nums,i+1,prod*nums[i]), solve(nums,i+1,prod);\\n        \\n    }\\n    long long maxStrength(vector<int>& nums) {\\n        solve(nums,0,1);\\n        //If ans is 1 it might be a negative number , a 1 or 0\\n        // Therefore we check all cases here.\\n        if(ans==1){\\n            int maxm = INT_MIN;\\n            for(int i=0;i<nums.size();i++){\\n                maxm = max(maxm,nums[i]);\\n                if(nums[i]==1) return 1;\\n            }\\n            \\n            return maxm;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long ans = INT_MIN;\\n    void solve(vector<int>& nums, int i, long long prod){\\n        if(i>=nums.size()){\\n            ans = max(ans,prod);\\n            return;\\n        }\\n        solve(nums,i+1,prod*nums[i]), solve(nums,i+1,prod);\\n        \\n    }\\n    long long maxStrength(vector<int>& nums) {\\n        solve(nums,0,1);\\n        //If ans is 1 it might be a negative number , a 1 or 0\\n        // Therefore we check all cases here.\\n        if(ans==1){\\n            int maxm = INT_MIN;\\n            for(int i=0;i<nums.size();i++){\\n                maxm = max(maxm,nums[i]);\\n                if(nums[i]==1) return 1;\\n            }\\n            \\n            return maxm;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568910,
                "title": "c-simple-maths",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        long long int ans = 1;\\n        int mx = INT_MIN;\\n        bool a = false, b = false;\\n        int c = 0;\\n        for(auto &i: nums){\\n            if(i>0)a = true;\\n            if(i==0)b = true;\\n            if(i<0)c++;\\n            if(i)\\n            ans *= i;\\n            if(i<0)mx = max(mx,i);\\n        }\\n        // cout<<ans<<\" \"<<a<<\" \"<<b<<\" \"<<c<<\" \"<<mx;\\n        if(c==0){\\n            if(a)return ans;\\n            return 0;\\n        }else if(c==1){\\n            if(a)return ans/mx;\\n            return 0;\\n        }\\n        if((c||a) && ans>0){\\n            return ans;\\n        }\\n        ans /= mx;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        long long int ans = 1;\\n        int mx = INT_MIN;\\n        bool a = false, b = false;\\n        int c = 0;\\n        for(auto &i: nums){\\n            if(i>0)a = true;\\n            if(i==0)b = true;\\n            if(i<0)c++;\\n            if(i)\\n            ans *= i;\\n            if(i<0)mx = max(mx,i);\\n        }\\n        // cout<<ans<<\" \"<<a<<\" \"<<b<<\" \"<<c<<\" \"<<mx;\\n        if(c==0){\\n            if(a)return ans;\\n            return 0;\\n        }else if(c==1){\\n            if(a)return ans/mx;\\n            return 0;\\n        }\\n        if((c||a) && ans>0){\\n            return ans;\\n        }\\n        ans /= mx;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3568786,
                "title": "js-o-n-log-n-tc-on-sc",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst maxStrength = function(nums) {\\n    nums.sort((a, b) => a - b)\\n    \\n    const negatives = nums.filter(num => num < 0)\\n    const positives = nums.filter(num => num > 0)\\n    \\n    const negCount = negatives.length\\n    const posCount = positives.length\\n\\n    if (posCount === 0 && negCount === 0) return 0\\n    if (posCount === 0 && negCount === 1) return nums[nums.length - 1]\\n    \\n    let res = 1\\n    \\n    if (negCount % 2 === 0) {\\n        for (const num of negatives) {\\n            res *= num\\n        }\\n        \\n        for (const num of positives) {\\n            res *= num\\n        }\\n    } else {\\n        for (let i = 0; i < negCount - 1; i++) {\\n            const num = negatives[i]\\n            res *= num\\n        }\\n        \\n        for (const num of positives) {\\n            res *= num\\n        }\\n        \\n    }\\n    \\n    return  res\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst maxStrength = function(nums) {\\n    nums.sort((a, b) => a - b)\\n    \\n    const negatives = nums.filter(num => num < 0)\\n    const positives = nums.filter(num => num > 0)\\n    \\n    const negCount = negatives.length\\n    const posCount = positives.length\\n\\n    if (posCount === 0 && negCount === 0) return 0\\n    if (posCount === 0 && negCount === 1) return nums[nums.length - 1]\\n    \\n    let res = 1\\n    \\n    if (negCount % 2 === 0) {\\n        for (const num of negatives) {\\n            res *= num\\n        }\\n        \\n        for (const num of positives) {\\n            res *= num\\n        }\\n    } else {\\n        for (let i = 0; i < negCount - 1; i++) {\\n            const num = negatives[i]\\n            res *= num\\n        }\\n        \\n        for (const num of positives) {\\n            res *= num\\n        }\\n        \\n    }\\n    \\n    return  res\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3568739,
                "title": "o-n-7-lines-of-code-c-simple-and-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nQuestion is some kind of similar to 152. Maximum Product Subarray [https://leetcode.com/problems/maximum-product-subarray/description/](), in that que. we have subarray in this we have subsequence. So we will follow same code except two extra variable mite and mate which stores min/max value till index in array.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$ O(1) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& a) {\\n        long long ma=a[0],mi=a[0];\\n        for(int i=1;i<a.size();i++){\\n            long long mite=mi,mate=ma;\\n            if(a[i]<0)\\n                swap(ma,mi);\\n            ma=max({mate,ma*a[i],(long long)a[i]});\\n            mi=min({mite,mi*a[i],(long long)a[i]});\\n        }\\n        return ma;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& a) {\\n        long long ma=a[0],mi=a[0];\\n        for(int i=1;i<a.size();i++){\\n            long long mite=mi,mate=ma;\\n            if(a[i]<0)\\n                swap(ma,mi);\\n            ma=max({mate,ma*a[i],(long long)a[i]});\\n            mi=min({mite,mi*a[i],(long long)a[i]});\\n        }\\n        return ma;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568686,
                "title": "easy-cpp-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n       return dfs(nums, 0, 1, 0); \\n    } \\n   long long  dfs(vector<int>& nums,  int pos , long long  product, int count) {\\n        if( pos >= nums.size() ) {\\n            if (count == 0 ){\\n                return INT_MIN;\\n            }\\n            return product ;\\n        }\\n        long long include = dfs(nums, pos + 1, product * nums[pos], count + 1);\\n        long long exclude = dfs( nums, pos + 1, product, count);\\n        return  max( include, exclude);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n       return dfs(nums, 0, 1, 0); \\n    } \\n   long long  dfs(vector<int>& nums,  int pos , long long  product, int count) {\\n        if( pos >= nums.size() ) {\\n            if (count == 0 ){\\n                return INT_MIN;\\n            }\\n            return product ;\\n        }\\n        long long include = dfs(nums, pos + 1, product * nums[pos], count + 1);\\n        long long exclude = dfs( nums, pos + 1, product, count);\\n        return  max( include, exclude);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568554,
                "title": "easy-explaination-maths-sorting-implementation-upsolve",
                "content": "# Intuition\\n**Please Note we have to take care of negative number as well as Zeroes.**\\n\\n\\n\\n# Approach\\nHere just take care of some corner cases what would be when we have single element or element with all negative but some zeroes.\\n\\nJust See the constraints and you can sort the negative elements in order.\\nWe must select those negative numbers who later cancel the sign in short take even negative numbers and if a single negative exist only take it when you have a single element\\n\\n# Complexity\\n- Time complexity:\\nTraversing the array once : 0(n)\\n\\n- Space complexity:\\nstoring the negative elements : worst 0(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        if(nums.size() == 1)\\n        {\\n            return nums[0];\\n        }\\n        vector<int> neg;\\n        long long ans = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                if(ans == 0) ans = nums[i];\\n                else\\n                ans *= nums[i];\\n            }\\n            else if(nums[i]<0) neg.push_back(nums[i]);\\n            else continue;\\n        }\\n        sort(neg.begin(),neg.end());\\n        int n= neg.size();\\n        if(n%2==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans == 0) ans = neg[i];\\n                else\\n                ans *= neg[i];\\n            }\\n        }\\n        if(n%2==1)\\n        {\\n            for(int i=0;i<n-1;i++)\\n            {\\n                if(ans == 0) ans = neg[i];\\n                else \\n                ans *= neg[i];\\n            }\\n        }\\n        if(ans == 0 && n == 1) return 0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        if(nums.size() == 1)\\n        {\\n            return nums[0];\\n        }\\n        vector<int> neg;\\n        long long ans = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                if(ans == 0) ans = nums[i];\\n                else\\n                ans *= nums[i];\\n            }\\n            else if(nums[i]<0) neg.push_back(nums[i]);\\n            else continue;\\n        }\\n        sort(neg.begin(),neg.end());\\n        int n= neg.size();\\n        if(n%2==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans == 0) ans = neg[i];\\n                else\\n                ans *= neg[i];\\n            }\\n        }\\n        if(n%2==1)\\n        {\\n            for(int i=0;i<n-1;i++)\\n            {\\n                if(ans == 0) ans = neg[i];\\n                else \\n                ans *= neg[i];\\n            }\\n        }\\n        if(ans == 0 && n == 1) return 0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570058,
                "title": "simple-brute-force-easy-generate-all-subsets-solution-use-of-given-constraints",
                "content": "# Approach \\nSince array\\'s atmost size can be 13, so we can generate all subsets of it and check which subsets give maximum strength.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        vector<int> temp;\\n        vector<vector<int>> dp;\\n        f(0,nums,temp,dp);\\n\\n        long long ans = INT_MIN;\\n        for(int i=0 ; i<dp.size() ; i++){\\n            if(dp[i].size() == 0) continue;\\n            long long curr = dp[i][0];\\n            for(int j=0 ; j<dp[i].size() ; j++) {\\n                if(j == 0) continue;\\n                curr *= 1ll*dp[i][j]; \\n            }\\n            ans = max(ans,curr);\\n        }\\n        return ans;\\n    }\\n    \\n    // generate all subsets\\n    void f(int idx, vector<int> &nums, vector<int> &subset, vector<vector<int>> &res) {\\n        res.push_back(subset);\\n        for(int i = idx; i < nums.size(); i++) {\\n            subset.push_back(nums[i]);\\n            f(i+1,nums,subset,res);\\n            subset.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        vector<int> temp;\\n        vector<vector<int>> dp;\\n        f(0,nums,temp,dp);\\n\\n        long long ans = INT_MIN;\\n        for(int i=0 ; i<dp.size() ; i++){\\n            if(dp[i].size() == 0) continue;\\n            long long curr = dp[i][0];\\n            for(int j=0 ; j<dp[i].size() ; j++) {\\n                if(j == 0) continue;\\n                curr *= 1ll*dp[i][j]; \\n            }\\n            ans = max(ans,curr);\\n        }\\n        return ans;\\n    }\\n    \\n    // generate all subsets\\n    void f(int idx, vector<int> &nums, vector<int> &subset, vector<vector<int>> &res) {\\n        res.push_back(subset);\\n        for(int i = idx; i < nums.size(); i++) {\\n            subset.push_back(nums[i]);\\n            f(i+1,nums,subset,res);\\n            subset.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569592,
                "title": "greedy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        vector<int> neg;\\n        long long ans = 1, cntp = 0, cntn = 0, cntz = 0;\\n        for(int i : nums) {\\n            if(i < 0) {\\n                cntn++;\\n                neg.push_back(i);\\n            }\\n            else if(i > 0) cntp++, ans *= i;\\n            else cntz++;\\n        }\\n\\n        sort(neg.begin(), neg.end());\\n        \\n        if(cntn % 2) cntn--;\\n        if(!cntn && !cntp) {\\n            return cntz ? 0 : neg[0];\\n        }\\n\\n        for(int i=0; i<cntn; i++) ans *= neg[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        vector<int> neg;\\n        long long ans = 1, cntp = 0, cntn = 0, cntz = 0;\\n        for(int i : nums) {\\n            if(i < 0) {\\n                cntn++;\\n                neg.push_back(i);\\n            }\\n            else if(i > 0) cntp++, ans *= i;\\n            else cntz++;\\n        }\\n\\n        sort(neg.begin(), neg.end());\\n        \\n        if(cntn % 2) cntn--;\\n        if(!cntn && !cntp) {\\n            return cntz ? 0 : neg[0];\\n        }\\n\\n        for(int i=0; i<cntn; i++) ans *= neg[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569257,
                "title": "easy-and-simple-solution-in-o-n-complexity-and-o-1-space",
                "content": "# approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n-It is easy and simple solution \\n-The variables we have to find are\\n1.total number of negatives\\n2.The maximum negative number\\n3.The maximum number \\n4.product of the elements\\nfrom the array\\nthere are total 4 possibilities in any combination of the array\\n1.array exist zero and the negative count will be zero or one \\nex:[0,0,-1]\\nin this case we return zero as the max will be zero\\n2.Array exist only with the negative value and the count is one ex:[-1]\\nthen here we directly return the negative max.\\n3.If the product value is negative then it is necessary to remove one element from the array \\nex:[3,-1,-5,2,5,-9]\\nhere we will return 1350 as the answer\\n4.if none case has executed then directly return the product\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) \\n    {\\n        long long prod=1;\\n        int negcount=0,negmax=INT_MIN,maxi=INT_MIN;\\n        for(auto l:nums)\\n        {\\n            if(l)\\n            prod*=l;\\n            if(l<0)\\n            {\\n                negmax=max(negmax,l);\\n                negcount++;\\n            }\\n            maxi=max(maxi,l);\\n        }\\n        if(maxi==0 && negcount<2)return 0;\\n        if(maxi<0 && negcount==1)return negmax;\\n        if(prod<0)return prod/negmax;\\n        return prod;\\n    }\\n};\\n```\\n# upvote me if you like my solution comment if any doubts\\n![uvote.jpeg](https://assets.leetcode.com/users/images/ec8e6029-97df-467d-888e-04bc00b78604_1685210775.049858.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) \\n    {\\n        long long prod=1;\\n        int negcount=0,negmax=INT_MIN,maxi=INT_MIN;\\n        for(auto l:nums)\\n        {\\n            if(l)\\n            prod*=l;\\n            if(l<0)\\n            {\\n                negmax=max(negmax,l);\\n                negcount++;\\n            }\\n            maxi=max(maxi,l);\\n        }\\n        if(maxi==0 && negcount<2)return 0;\\n        if(maxi<0 && negcount==1)return negmax;\\n        if(prod<0)return prod/negmax;\\n        return prod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569207,
                "title": "2708-java-simple-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        if(nums.length == 1) return  nums[0];\\n        int totalMinus = 0 , smallMinus = -9;\\n        for(int i : nums){\\n            if(i < 0){\\n                totalMinus++;\\n                if(smallMinus < i) smallMinus = i;\\n            }\\n        }\\n        long l = 1;\\n        boolean b = true , b1 = false;\\n        if(totalMinus % 2 == 0) b = false;\\n        for(int j : nums){\\n            if(b && j == smallMinus) b = false;\\n            else if(j != 0) {\\n                l = l * j;\\n                b1 = true;\\n            }\\n        }\\n        return b1? l : 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        if(nums.length == 1) return  nums[0];\\n        int totalMinus = 0 , smallMinus = -9;\\n        for(int i : nums){\\n            if(i < 0){\\n                totalMinus++;\\n                if(smallMinus < i) smallMinus = i;\\n            }\\n        }\\n        long l = 1;\\n        boolean b = true , b1 = false;\\n        if(totalMinus % 2 == 0) b = false;\\n        for(int j : nums){\\n            if(b && j == smallMinus) b = false;\\n            else if(j != 0) {\\n                l = l * j;\\n                b1 = true;\\n            }\\n        }\\n        return b1? l : 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569102,
                "title": "brute-force-approach-recursive-approach",
                "content": "# Code\\n\\n```\\n\\n// Recursive solution\\nclass Solution {\\npublic:\\n    void helper(int i, long long maxi, vector<int> &nums, long long &ans) {\\n        if(i == nums.size()){\\n            if(ans < maxi) ans = maxi;\\n        }else{\\n            if(maxi == INT_MIN) helper(i+1, nums[i], nums, ans);\\n            else helper(i+1, maxi * nums[i], nums, ans);\\n            helper(i+1, maxi, nums, ans);\\n        }\\n    }\\n\\n    long long maxStrength(vector<int>& nums) {\\n        if(nums.size() == 1) return nums[0];\\n        long long ans = 0;\\n        helper(0, INT_MIN, nums , ans);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    void helper(int i, long long maxi, vector<int> &nums, long long &ans) {\\n        if(i == nums.size()){\\n            if(ans < maxi) ans = maxi;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3569085,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        max_strength,min_strength=nums[0],nums[0]\\n        for num in nums[1:]:\\n            max_strength,min_strength=max(max_strength,num,num*max_strength,num*min_strength),min(min_strength,num,num*min_strength,num*max_strength)\\n\\n        return max_strength    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        max_strength,min_strength=nums[0],nums[0]\\n        for num in nums[1:]:\\n            max_strength,min_strength=max(max_strength,num,num*max_strength,num*min_strength),min(min_strength,num,num*min_strength,num*max_strength)\\n\\n        return max_strength    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568819,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStrength(self, nums):\\n        if len(nums) == 1:\\n            return nums[0]\\n\\n        nums.sort()\\n\\n        neg = [i for i in nums if i < 0]\\n        pos = [i for i in nums if i > 0]\\n\\n        if not neg and not pos:\\n            return 0\\n\\n        if len(neg)%2 == 1:\\n            p = prod(neg[:-1]) if neg[:-1] else 0\\n        else:\\n            p = prod(neg)\\n\\n        q = prod(pos) if pos else 0\\n\\n        return max(p*q,q,p)\\n\\n\\n\\n    \\n    \\n    \\n    \\n    \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStrength(self, nums):\\n        if len(nums) == 1:\\n            return nums[0]\\n\\n        nums.sort()\\n\\n        neg = [i for i in nums if i < 0]\\n        pos = [i for i in nums if i > 0]\\n\\n        if not neg and not pos:\\n            return 0\\n\\n        if len(neg)%2 == 1:\\n            p = prod(neg[:-1]) if neg[:-1] else 0\\n        else:\\n            p = prod(neg)\\n\\n        q = prod(pos) if pos else 0\\n\\n        return max(p*q,q,p)\\n\\n\\n\\n    \\n    \\n    \\n    \\n    \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568801,
                "title": "python-4-lines-easy-to-understand",
                "content": "# Approach\\nKeep track of minimum and maximum combinations.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        max_memo, min_memo = nums[0], nums[0]\\n        for num in nums[1:]:\\n            max_memo, min_memo = max(max_memo, num, num*max_memo, num*min_memo), min(min_memo, num, num*min_memo, num*max_memo)\\n        return max_memo\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        max_memo, min_memo = nums[0], nums[0]\\n        for num in nums[1:]:\\n            max_memo, min_memo = max(max_memo, num, num*max_memo, num*min_memo), min(min_memo, num, num*min_memo, num*max_memo)\\n        return max_memo\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568790,
                "title": "c-solutions-explained-line-by-line-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem aims to find the maximum strength of a subarray based on the given input array a. The strength of a subarray is defined as the product of all its elements. The task is to determine the maximum possible strength by considering different subarrays.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the code is a dynamic programming approach that iterates over the input array a to calculate the maximum and minimum strengths encountered so far. It maintains two variables, maxStrength and minStrength, to track the maximum and minimum strengths, respectively.\\n\\nThe algorithm iterates over the array a starting from index 1. For each element at index i, it stores the previous maximum and minimum strengths in variables prevMax and prevMin, respectively.\\n\\nIf the current element a[i] is negative, the algorithm swaps the values of maxStrength and minStrength. This is done to handle negative numbers since multiplying a negative number with the minimum strength can result in the maximum strength.\\nNext, the algorithm calculates the new maximum and minimum strengths using the current element and the previous strengths. It computes the maximum strength as the maximum among the previous maximum strength (prevMax), the product of the current element and the previous maximum strength (maxStrength * a[i]), and the current element itself (a[i]). Similarly, it computes the minimum strength as the minimum among the previous minimum strength (prevMin), the product of the current element and the previous minimum strength (minStrength * a[i]), and the current element itself (a[i]).\\n\\nAfter iterating over all elements, the maximum strength (maxStrength) represents the maximum possible strength of a subarray in the given array a. It is returned as the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe algorithm iterates over the input array a once, resulting in a linear time complexity of O(n), where n is the size of the array a.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe algorithm uses a constant amount of additional space to store the variables for maximum and minimum strengths. Hence, the space complexity is O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& a) {\\n        // Initialize variables to track the maximum and minimum strength\\n        long long maxStrength = a[0]; // Maximum strength\\n        long long minStrength = a[0]; // Minimum strength\\n        \\n        // Iterate over the array from index 1\\n        for (int i = 1; i < a.size(); i++) {\\n            // Store the previous maximum and minimum strengths\\n            long long prevMax = maxStrength;\\n            long long prevMin = minStrength;\\n            \\n            // Check if the current element is negative\\n            if (a[i] < 0)\\n                swap(maxStrength, minStrength); // Swap maximum and minimum strengths\\n            \\n            // Calculate the new maximum and minimum strengths using the current element\\n            maxStrength = max({prevMax, maxStrength * a[i], static_cast<long long>(a[i])});\\n            minStrength = min({prevMin, minStrength * a[i], static_cast<long long>(a[i])});\\n        }\\n        \\n        return maxStrength; // Return the maximum strength\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& a) {\\n        // Initialize variables to track the maximum and minimum strength\\n        long long maxStrength = a[0]; // Maximum strength\\n        long long minStrength = a[0]; // Minimum strength\\n        \\n        // Iterate over the array from index 1\\n        for (int i = 1; i < a.size(); i++) {\\n            // Store the previous maximum and minimum strengths\\n            long long prevMax = maxStrength;\\n            long long prevMin = minStrength;\\n            \\n            // Check if the current element is negative\\n            if (a[i] < 0)\\n                swap(maxStrength, minStrength); // Swap maximum and minimum strengths\\n            \\n            // Calculate the new maximum and minimum strengths using the current element\\n            maxStrength = max({prevMax, maxStrength * a[i], static_cast<long long>(a[i])});\\n            minStrength = min({prevMin, minStrength * a[i], static_cast<long long>(a[i])});\\n        }\\n        \\n        return maxStrength; // Return the maximum strength\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568682,
                "title": "use-backtracking-to-generate-subsets-find-the-maximum-prod-subset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nedge case empty subset, tackle it\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<int>>&ans,int i,vector<int>&v,vector<int>&nums){\\n        if(i>=nums.size()){\\n            ans.push_back(v);\\n            return;\\n        }\\n        \\n        v.push_back(nums[i]);\\n        solve(ans,i+1,v,nums);\\n        v.pop_back();\\n        solve(ans,i+1,v,nums);\\n    }\\n    long long maxStrength(vector<int>& nums) {\\n         vector<vector<int>>subsets; int n=nums.size(); long long ans=INT_MIN;\\n     \\n        vector<int>v;\\n        solve(subsets,0,v,nums);\\n      for(int i=0;i<subsets.size();i++)\\n      {    if(subsets[i].size()==0)continue;\\n          long long prod=subsets[i][0];\\n     \\n          for(int j=1;j<subsets[i].size();j++)\\n          {\\n              prod*=subsets[i][j];\\n          }\\n          ans=max(ans,prod);\\n      }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<int>>&ans,int i,vector<int>&v,vector<int>&nums){\\n        if(i>=nums.size()){\\n            ans.push_back(v);\\n            return;\\n        }\\n        \\n        v.push_back(nums[i]);\\n        solve(ans,i+1,v,nums);\\n        v.pop_back();\\n        solve(ans,i+1,v,nums);\\n    }\\n    long long maxStrength(vector<int>& nums) {\\n         vector<vector<int>>subsets; int n=nums.size(); long long ans=INT_MIN;\\n     \\n        vector<int>v;\\n        solve(subsets,0,v,nums);\\n      for(int i=0;i<subsets.size();i++)\\n      {    if(subsets[i].size()==0)continue;\\n          long long prod=subsets[i][0];\\n     \\n          for(int j=1;j<subsets[i].size();j++)\\n          {\\n              prod*=subsets[i][j];\\n          }\\n          ans=max(ans,prod);\\n      }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568663,
                "title": "c-sorting",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        long long ans = 1;\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        if(n == 1){\\n            return nums[0];\\n        }\\n        int count1 = 0, count = 0;\\n        for (int i = n - 1; i >= 0; i--){\\n            if(nums[i] != 0){\\n                ans *= nums[i];\\n            }\\n            if(nums[i] < 0){\\n                count++;\\n            }\\n            if(nums[i] == 0){\\n                count1++;\\n            }\\n        }\\n        if(count == 1 && count1 == n - 1){\\n            return 0;\\n        }\\n        if(count1 == n){\\n            return 0;\\n        }\\n        if(ans < 0){\\n            for (int i = n - 1; i >= 0; i--){\\n                if(nums[i] < 0){\\n                    ans /= nums[i];\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        long long ans = 1;\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        if(n == 1){\\n            return nums[0];\\n        }\\n        int count1 = 0, count = 0;\\n        for (int i = n - 1; i >= 0; i--){\\n            if(nums[i] != 0){\\n                ans *= nums[i];\\n            }\\n            if(nums[i] < 0){\\n                count++;\\n            }\\n            if(nums[i] == 0){\\n                count1++;\\n            }\\n        }\\n        if(count == 1 && count1 == n - 1){\\n            return 0;\\n        }\\n        if(count1 == n){\\n            return 0;\\n        }\\n        if(ans < 0){\\n            for (int i = n - 1; i >= 0; i--){\\n                if(nums[i] < 0){\\n                    ans /= nums[i];\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568571,
                "title": "simple-solution-via-bit-masking",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n       int n=nums.size();\\n       long long subsetcnt=1<<n;//finding all possible subsets\\n       long long maxans=INT_MIN;\\n       \\n      for(int mask=0;mask<subsetcnt;mask++){//iterating over all possible subsets\\n          long long ans=INT_MIN;\\n          bool f=true;\\n          for(int i=0;i<n;i++){\\n              if((mask & (1<<i))!=0){//if(it is 1 then it means we have chosen that number else not)\\n                  if(f){\\n                      ans=nums[i];\\n                      f=false;\\n                  }\\n                  else ans=ans*nums[i];\\n              }\\n          }\\n          maxans=max(maxans,ans);\\n      }\\n        return maxans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n       int n=nums.size();\\n       long long subsetcnt=1<<n;//finding all possible subsets\\n       long long maxans=INT_MIN;\\n       \\n      for(int mask=0;mask<subsetcnt;mask++){//iterating over all possible subsets\\n          long long ans=INT_MIN;\\n          bool f=true;\\n          for(int i=0;i<n;i++){\\n              if((mask & (1<<i))!=0){//if(it is 1 then it means we have chosen that number else not)\\n                  if(f){\\n                      ans=nums[i];\\n                      f=false;\\n                  }\\n                  else ans=ans*nums[i];\\n              }\\n          }\\n          maxans=max(maxans,ans);\\n      }\\n        return maxans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060278,
                "title": "c-linear-time-complexity-greedy-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return nums[0];\\n        long long ans = 1;\\n        int cntneg = 0;\\n        int cntzero = 0;\\n        int cntpos = 0;\\n        for(int i=0;i<n;i++) {\\n            if(nums[i] > 0) ans = ans * nums[i]*1ll;\\n            if(nums[i] < 0) cntneg++;\\n            if(nums[i] == 0) cntzero++;\\n            if(nums[i] > 0) cntpos++;\\n        }\\n        if(cntzero == n) return 0;\\n        if(cntpos == 0 && cntneg == 1 && cntzero >= 1) {\\n            return 0;\\n        }\\n\\n        sort(nums.begin(), nums.end());\\n\\n        if(cntneg%2 == 0) {\\n            for(int i=0;i<n;i++) {\\n                if(nums[i] < 0) ans = ans * nums[i]*1ll;\\n            }\\n        }\\n        else {\\n            for(int i=0;i<cntneg-1;i++) {\\n                ans = ans * nums[i]*1ll;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return nums[0];\\n        long long ans = 1;\\n        int cntneg = 0;\\n        int cntzero = 0;\\n        int cntpos = 0;\\n        for(int i=0;i<n;i++) {\\n            if(nums[i] > 0) ans = ans * nums[i]*1ll;\\n            if(nums[i] < 0) cntneg++;\\n            if(nums[i] == 0) cntzero++;\\n            if(nums[i] > 0) cntpos++;\\n        }\\n        if(cntzero == n) return 0;\\n        if(cntpos == 0 && cntneg == 1 && cntzero >= 1) {\\n            return 0;\\n        }\\n\\n        sort(nums.begin(), nums.end());\\n\\n        if(cntneg%2 == 0) {\\n            for(int i=0;i<n;i++) {\\n                if(nums[i] < 0) ans = ans * nums[i]*1ll;\\n            }\\n        }\\n        else {\\n            for(int i=0;i<cntneg-1;i++) {\\n                ans = ans * nums[i]*1ll;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585386,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n//TC: nlog(n)\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        ArrayList<Integer> pos = new ArrayList<>();\\n        ArrayList<Integer> neg = new ArrayList<>();\\n        long ans = 1;\\n        int n_neg = 0;\\n        int zero=0;\\n        int take=0;\\n\\n        //count all positive,negative,zero\\n        for(int num:nums)\\n        {\\n            if(num>0) \\n            {\\n                pos.add(num);\\n                ans = ans*num;\\n            }\\n            else if(num<0) \\n            {\\n                neg.add(num);\\n                n_neg++;\\n            }\\n            else\\n            {\\n                zero++;\\n            }\\n        }\\n        //edge case\\n        if(n_neg==1 && nums.length==1) return nums[0];\\n        if(n_neg==1 && nums.length>1 && zero==nums.length-1 || zero==nums.length) return 0;\\n\\n        //if n_neg is odd consider only highest even neg numbers to prod\\n        if(n_neg%2==0) take=n_neg;\\n        else \\n        {\\n            take=n_neg-1;\\n            \\n        }\\n        \\n        //sort the neg arraylist\\n        Collections.sort(neg);//nlogn\\n        System.out.print(ans);\\n      \\n        int k=0;\\n        //while the neg >0 mul to prod\\n        while(take>0)\\n        {\\n            ans = ans*Math.abs(neg.get(k));\\n            k++;\\n            take--;\\n        }\\n        return ans;\\n\\n\\n        \\n\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//TC: nlog(n)\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        ArrayList<Integer> pos = new ArrayList<>();\\n        ArrayList<Integer> neg = new ArrayList<>();\\n        long ans = 1;\\n        int n_neg = 0;\\n        int zero=0;\\n        int take=0;\\n\\n        //count all positive,negative,zero\\n        for(int num:nums)\\n        {\\n            if(num>0) \\n            {\\n                pos.add(num);\\n                ans = ans*num;\\n            }\\n            else if(num<0) \\n            {\\n                neg.add(num);\\n                n_neg++;\\n            }\\n            else\\n            {\\n                zero++;\\n            }\\n        }\\n        //edge case\\n        if(n_neg==1 && nums.length==1) return nums[0];\\n        if(n_neg==1 && nums.length>1 && zero==nums.length-1 || zero==nums.length) return 0;\\n\\n        //if n_neg is odd consider only highest even neg numbers to prod\\n        if(n_neg%2==0) take=n_neg;\\n        else \\n        {\\n            take=n_neg-1;\\n            \\n        }\\n        \\n        //sort the neg arraylist\\n        Collections.sort(neg);//nlogn\\n        System.out.print(ans);\\n      \\n        int k=0;\\n        //while the neg >0 mul to prod\\n        while(take>0)\\n        {\\n            ans = ans*Math.abs(neg.get(k));\\n            k++;\\n            take--;\\n        }\\n        return ans;\\n\\n\\n        \\n\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579438,
                "title": "very-basic-approach-no-complex-data-structure-beginner-friendly",
                "content": "# Intuition\\nTake all positive values. If there are even number (not equal to zero) of negetive values take all of them else take one less of them (which should be the least values as their absolute values will contribute to maximum score). If there is no positive or negative values except zero or only zero and one negative value then return zero else return the answer.\\n\\nJust think greedily \\uD83D\\uDE01\\n\\n\\n# Complexity\\n- Time complexity: $O(n log n)$ (though there is maximum 13 elements only \\uD83D\\uDE05\\uD83D\\uDE05 so it\\'s close to O(constant) solution technically.. \\uD83D\\uDE01\\uD83D\\uDE01)\\n\\n- Space complexity: $O(1)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        if (nums.size() == 1) {\\n            return nums[0] * 1LL;\\n        }\\n        long long ans = 1;\\n        bool flag1 = false, flag2 = false; //flag is to denote if there is positive or negative numbers which have taken part or not. If not then answer is 0.\\n        int numOfneg = 0;\\n        for (int val : nums) {\\n            if (val > 0) {\\n                ans *= (val * 1LL);\\n                flag1 = true;\\n            } else if (val < 0) {\\n                numOfneg++;\\n            }\\n        }\\n        if (numOfneg == 0) {\\n            if (!flag1) {\\n                return 0;\\n            }\\n            return ans;\\n        }\\n        if (numOfneg % 2 == 0) {\\n            for (int val : nums) {\\n                if (val < 0) {\\n                    ans *= (val * 1LL);\\n                    flag2 = true;\\n                }\\n            }\\n        } else {\\n            sort(nums.begin(), nums.end());\\n            for (int i = 0; i < numOfneg-1; i++) {\\n                ans *= (nums[i] * 1LL);\\n                flag2 = true;\\n            }\\n        }\\n        return (!flag1 && !flag2) ? 0 : ans;\\n    }\\n};\\n```\\n\\nPlease upvote if you like the solution. \\uD83D\\uDE04\\u2764",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        if (nums.size() == 1) {\\n            return nums[0] * 1LL;\\n        }\\n        long long ans = 1;\\n        bool flag1 = false, flag2 = false; //flag is to denote if there is positive or negative numbers which have taken part or not. If not then answer is 0.\\n        int numOfneg = 0;\\n        for (int val : nums) {\\n            if (val > 0) {\\n                ans *= (val * 1LL);\\n                flag1 = true;\\n            } else if (val < 0) {\\n                numOfneg++;\\n            }\\n        }\\n        if (numOfneg == 0) {\\n            if (!flag1) {\\n                return 0;\\n            }\\n            return ans;\\n        }\\n        if (numOfneg % 2 == 0) {\\n            for (int val : nums) {\\n                if (val < 0) {\\n                    ans *= (val * 1LL);\\n                    flag2 = true;\\n                }\\n            }\\n        } else {\\n            sort(nums.begin(), nums.end());\\n            for (int i = 0; i < numOfneg-1; i++) {\\n                ans *= (nums[i] * 1LL);\\n                flag2 = true;\\n            }\\n        }\\n        return (!flag1 && !flag2) ? 0 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578725,
                "title": "single-pass-keep-track-of-min-and-max-product",
                "content": "# Intuition\\nKeeping track of the minimum product is useful, since we can multiply it by another negative number and potentially get a new max product.\\n\\nThe key to dealing with edge cases is to never initialize the product with constants like $$0$$ or $$1$$, but only array members.\\n\\n\\n# Top-down DP (recursion)\\n```\\nfunction maxStrength(nums: number[]): number {\\n    const n = nums.length;\\n\\n    function dp(i: number): [number, number] {\\n        if (i === n-1) return [nums[n-1], nums[n-1]];\\n\\n        const [nextMin, nextMax] = dp(i+1);\\n        return [\\n            Math.min(nextMin, nums[i] * nextMax, nums[i] * nextMin, nums[i]),\\n            Math.max(nextMax, nums[i] * nextMax, nums[i] * nextMin, nums[i])\\n        ];\\n    }\\n\\n    return dp(0)[1];\\n};\\n```\\n- Time complexity: $$O(n)$$ - linear, since there is only a single (i+1) call\\n- Space complexity: $$O(n)$$ - max height of the function call stack\\n\\n# Bottom-up DP (reduced space)\\n```\\nfunction maxStrength(nums: number[]): number {\\n    let minProd = nums[0], maxProd = nums[0];\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        const x = nums[i];\\n        [minProd, maxProd] = [\\n            Math.min(minProd, x, x * minProd, x * maxProd),\\n            Math.max(maxProd, x, x * minProd, x * maxProd)\\n        ];\\n    }\\n\\n    return maxProd;\\n};\\n```\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$",
                "solutionTags": [
                    "TypeScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunction maxStrength(nums: number[]): number {\\n    const n = nums.length;\\n\\n    function dp(i: number): [number, number] {\\n        if (i === n-1) return [nums[n-1], nums[n-1]];\\n\\n        const [nextMin, nextMax] = dp(i+1);\\n        return [\\n            Math.min(nextMin, nums[i] * nextMax, nums[i] * nextMin, nums[i]),\\n            Math.max(nextMax, nums[i] * nextMax, nums[i] * nextMin, nums[i])\\n        ];\\n    }\\n\\n    return dp(0)[1];\\n};\\n```\n```\\nfunction maxStrength(nums: number[]): number {\\n    let minProd = nums[0], maxProd = nums[0];\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        const x = nums[i];\\n        [minProd, maxProd] = [\\n            Math.min(minProd, x, x * minProd, x * maxProd),\\n            Math.max(maxProd, x, x * minProd, x * maxProd)\\n        ];\\n    }\\n\\n    return maxProd;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3575918,
                "title": "c-single-pass-constant-space-12ms-46-5mb",
                "content": "This what an odd third problem for a contest, feeling much easier than the second, but okay: the very low limit of `13` elements also made me think that probably the core idea was to offer contestant another combinatorics problem.\\n\\nBut we really don\\'t need it, since we can play smart and figure out a few things:\\n* if we have positive numbers, we will ALWAYS add them to the product;\\n* if we have zeroes, we will always ignore them, unless there is only another negative element in the mix (and thus a `0` would still be a better option);\\n* if we have negative numbers, we will only consider them in pairs, favouring the ones with the higher absolute values first.\\n\\nNow, to code this all, let\\'s start with ruling out the edge case of a single element provided (in which case we just `return` it) and declaring otherwise our usual support variables:\\n* `len` will store the length of the input;\\n* `w` is the writing pointer to store our negative values;\\n* `pluses` and `zeroes` will store, as the name implies, the amount of positive integers and zeroes we will find, both initially set to be `0`;\\n* `res` is our result variable, initialised to be `1`;\\n* `negs` is an array of `len` cells that will store every negative value we find.\\n\\nWe will then parse every element in `nums` with the pointer `i` and:\\n* store the current element `nums[i]` in `n`;\\n* if `n` is negative, we will:\\n    * store `n` in `negs[w]`;\\n    * increase `w` by `1`;\\n* if `n` is positive, we will:\\n    * increase `pluses` by `1`;\\n    * multiply `res` by `n`;\\n* otherwise, we will increase `zeroes` by `1`.\\n\\nIf by now we found that `nums` was made only of `0`s (ie: `zeroes == len`), we can just `return` `0`.\\n\\nNext, if we found at least two negative numbers (ie; `w > 1`) we will:\\n* sort the first `w` elements in `negs`;\\n* loop with `i` starting from `1` up to `w` (excluded) for each pair of indexes and multiply `res` by `negs[i]` and `negs[i - 1]`;\\n* `return` `res`.\\n\\nIn all the other cases, we will `return`:\\n* `res` if we have encountered at least a positive number (ie: `pluses != 0`);\\n* `0` if we did not encounter any positive number, but at least a `0` (ie: `zeroes != 0`);\\n* `negs[0]` otherwise.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        // edge case: single value\\n        if (nums.size() == 1) return nums[0];\\n        // support variables\\n        int len = nums.size(), w = 0, pluses = 0, zeroes = 0;\\n        long long res = 1, negs[len];\\n        // parsing nums\\n        for (int i = 0, n; i < len; i++) {\\n            n = nums[i];\\n            // negative\\n            if (n < 0) negs[w++] = n;\\n            // positive\\n            else if (n > 0) pluses++, res *= n;\\n            // zero\\n            else zeroes++;\\n        }\\n        // edge case: all zeroes\\n        if (zeroes == len) return 0;\\n        // dealing with negative pairs first\\n        if (w > 1) {\\n            sort(negs, negs + w, less<int>());\\n            for (int i = 1; i < w; i += 2) res *= negs[i] * negs[i - 1];\\n            return res;\\n        }\\n        return pluses ? res : zeroes ? 0 : negs[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        // edge case: single value\\n        if (nums.size() == 1) return nums[0];\\n        // support variables\\n        int len = nums.size(), w = 0, pluses = 0, zeroes = 0;\\n        long long res = 1, negs[len];\\n        // parsing nums\\n        for (int i = 0, n; i < len; i++) {\\n            n = nums[i];\\n            // negative\\n            if (n < 0) negs[w++] = n;\\n            // positive\\n            else if (n > 0) pluses++, res *= n;\\n            // zero\\n            else zeroes++;\\n        }\\n        // edge case: all zeroes\\n        if (zeroes == len) return 0;\\n        // dealing with negative pairs first\\n        if (w > 1) {\\n            sort(negs, negs + w, less<int>());\\n            for (int i = 1; i < w; i += 2) res *= negs[i] * negs[i - 1];\\n            return res;\\n        }\\n        return pluses ? res : zeroes ? 0 : negs[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570431,
                "title": "easy-iterative-exploring-all-possibilities-to-avoid-any-corner-case",
                "content": "# Intuition\\nAs the problem had a constraint of 1=<n<=13, it was easy to conclude that we can generate all the possibilities of 2^N. This problem can also be done by greedy logic but that comes up with the cost of thinking about corner cases. So for a contest perspective I choose exploring all posibilities.\\n\\n# Approach\\nItteratively explore all 2^n possibilities.\\n\\ntotalPossibilities = (1<<n) // 2^N\\nnow for each possibility let\\'s calculate the answer, so for every i from 0 to 2^N - 1 it will represent a subset of selection in their binary representation.\\nEx say N = 3 then totalPossibilities = 8, so each number from 0 to 7 represent following subsets:\\n0 = 000 => no elements in subset\\n1 = 001 => 0th element in subset\\n2 = 010 => 1th element in subset\\n3 = 011 => 0th and 1st element in subset\\n4 = 100 => 2nd element in subset\\n5 = 101 => 2nd and 0th element in subset\\n6 = 110 => 2nd and 1st element in subset\\n7 = 111 => 2nd, 1st and 0th element in subset\\n\\n\\n# Complexity\\n- Time complexity:\\nO((2^N)*N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        long long n = nums.size();\\n        long long totalPos = 1<<n;\\n        long long ans = nums[0];\\n        for(long long i=1;i<totalPos;i++)\\n        {\\n            long long curAns = 1;\\n            for(long long j=0;j<n;j++)\\n            {\\n                if((i>>j)&1)\\n                {\\n                    curAns*=nums[j];\\n                }\\n            }\\n            ans = max(ans,curAns);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        long long n = nums.size();\\n        long long totalPos = 1<<n;\\n        long long ans = nums[0];\\n        for(long long i=1;i<totalPos;i++)\\n        {\\n            long long curAns = 1;\\n            for(long long j=0;j<n;j++)\\n            {\\n                if((i>>j)&1)\\n                {\\n                    curAns*=nums[j];\\n                }\\n            }\\n            ans = max(ans,curAns);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569736,
                "title": "simple-java-o-nlogn-solution-using-sorting",
                "content": "# Code\\n```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        if(nums.length == 1)\\n            return (long) nums[0];\\n        \\n        Arrays.sort(nums);\\n        \\n        int index = nums.length-1;\\n        long prod = 0;\\n        while(index >= 0) {\\n            if(nums[index] > 0) {\\n                if(prod == 0) {\\n                    prod = (long) nums[index];\\n                } else {\\n                    prod *= (long) nums[index];\\n                }\\n            } else {\\n                break;\\n            }\\n            index--;\\n        }\\n        \\n        while(index >= 0 && nums[index] == 0)\\n            index--;\\n        \\n        int numNeg = index + 1;\\n        if(numNeg > 1) {\\n            int temp = 0;\\n            int cutOff = index;\\n            if(numNeg % 2 == 0)\\n                cutOff++;\\n            \\n            while(temp < cutOff) {\\n                if(prod == 0)\\n                    prod = nums[temp];\\n                else\\n                    prod *= nums[temp];\\n                temp++;\\n            }\\n        }\\n        \\n        return prod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        if(nums.length == 1)\\n            return (long) nums[0];\\n        \\n        Arrays.sort(nums);\\n        \\n        int index = nums.length-1;\\n        long prod = 0;\\n        while(index >= 0) {\\n            if(nums[index] > 0) {\\n                if(prod == 0) {\\n                    prod = (long) nums[index];\\n                } else {\\n                    prod *= (long) nums[index];\\n                }\\n            } else {\\n                break;\\n            }\\n            index--;\\n        }\\n        \\n        while(index >= 0 && nums[index] == 0)\\n            index--;\\n        \\n        int numNeg = index + 1;\\n        if(numNeg > 1) {\\n            int temp = 0;\\n            int cutOff = index;\\n            if(numNeg % 2 == 0)\\n                cutOff++;\\n            \\n            while(temp < cutOff) {\\n                if(prod == 0)\\n                    prod = nums[temp];\\n                else\\n                    prod *= nums[temp];\\n                temp++;\\n            }\\n        }\\n        \\n        return prod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569405,
                "title": "python-brute-force-1-liner",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        return max(prod(combo) for size in range(1, len(nums) + 1) for combo in combinations(nums, size))\\n```",
                "solutionTags": [
                    "Python3",
                    "Simulation",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        return max(prod(combo) for size in range(1, len(nums) + 1) for combo in combinations(nums, size))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569189,
                "title": "java-2-approaches-recursive-linear-easy",
                "content": "Appraoch 1: Recursive\\n\\n```\\nclass Solution {\\n    List<List<Integer>> ans = new ArrayList();\\n    \\n    public void solve(int[] nums, int ind, List<Integer> temp){\\n        int n = nums.length;\\n        if(ind>= n){\\n            ans.add(new ArrayList(temp));\\n            return;\\n        }\\n            \\n//         discard current element\\n        solve(nums, ind+1, temp);\\n//          include current index\\n        temp.add(nums[ind]);\\n        solve(nums, ind+1, temp);\\n        temp.remove(temp.indexOf(nums[ind]));\\n    }\\n    \\n    public long maxStrength(int[] nums) {\\n        long res = Integer.MIN_VALUE;\\n        solve(nums, 0, new ArrayList());\\n        for(List<Integer> list : ans){\\n            if(list.size() == 0)\\n                continue;\\n            long sum = list.get(0);\\n            for(int i = 1 ; i < list.size(); i++)\\n                sum*=list.get(i);\\n            res = Math.max(res,sum);\\n        }\\n        return res;\\n    }\\n}\\n\\n```\\n\\nApproach 2 : Linear\\n```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        long res = 1;\\n        int largest = Integer.MIN_VALUE,neg = 0, largestNegative = Integer.MIN_VALUE;\\n        for(int num :  nums){\\n            if(num!=0)res*=num;\\n            if(num < 0){\\n                neg++;\\n                largestNegative = Math.max(largestNegative, num);\\n            }\\n            largest = Math.max(largest, num);\\n        }\\n        if(largest == 0 && neg < 2)  return 0;\\n        if(largest < 0 && neg == 1 ) return (largestNegative);\\n        if(res > 0) return res;\\n        return res/largestNegative;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> ans = new ArrayList();\\n    \\n    public void solve(int[] nums, int ind, List<Integer> temp){\\n        int n = nums.length;\\n        if(ind>= n){\\n            ans.add(new ArrayList(temp));\\n            return;\\n        }\\n            \\n//         discard current element\\n        solve(nums, ind+1, temp);\\n//          include current index\\n        temp.add(nums[ind]);\\n        solve(nums, ind+1, temp);\\n        temp.remove(temp.indexOf(nums[ind]));\\n    }\\n    \\n    public long maxStrength(int[] nums) {\\n        long res = Integer.MIN_VALUE;\\n        solve(nums, 0, new ArrayList());\\n        for(List<Integer> list : ans){\\n            if(list.size() == 0)\\n                continue;\\n            long sum = list.get(0);\\n            for(int i = 1 ; i < list.size(); i++)\\n                sum*=list.get(i);\\n            res = Math.max(res,sum);\\n        }\\n        return res;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        long res = 1;\\n        int largest = Integer.MIN_VALUE,neg = 0, largestNegative = Integer.MIN_VALUE;\\n        for(int num :  nums){\\n            if(num!=0)res*=num;\\n            if(num < 0){\\n                neg++;\\n                largestNegative = Math.max(largestNegative, num);\\n            }\\n            largest = Math.max(largest, num);\\n        }\\n        if(largest == 0 && neg < 2)  return 0;\\n        if(largest < 0 && neg == 1 ) return (largestNegative);\\n        if(res > 0) return res;\\n        return res/largestNegative;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569072,
                "title": "simple-and-easy-sort-greedy-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        long long ans=1;\\n        int p= nums.size();\\n        for(int i=0; i<p; i++) {\\n            if(nums[i]>0) ans*= nums[i];\\n        }\\n        vector<int>ntv;\\n        for(int i=0; i<p; i++) {\\n            if(nums[i]<0 ) ntv.push_back(nums[i]);\\n        }\\n        int s=ntv.size();\\n        if(s%2==0) {\\n        for(int i=0; i<s; i++) ans*= ntv[i];\\n        }\\n        else {\\n            for(int i=0; i<s-1; i++) ans*= ntv[i];\\n        }\\n        if(ans==1) return nums[p-1];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        long long ans=1;\\n        int p= nums.size();\\n        for(int i=0; i<p; i++) {\\n            if(nums[i]>0) ans*= nums[i];\\n        }\\n        vector<int>ntv;\\n        for(int i=0; i<p; i++) {\\n            if(nums[i]<0 ) ntv.push_back(nums[i]);\\n        }\\n        int s=ntv.size();\\n        if(s%2==0) {\\n        for(int i=0; i<s; i++) ans*= ntv[i];\\n        }\\n        else {\\n            for(int i=0; i<s-1; i++) ans*= ntv[i];\\n        }\\n        if(ans==1) return nums[p-1];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568806,
                "title": "easy-commented-code-intuitive-solution",
                "content": "### Do Upvote if it helps !!\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(nlogn)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        //store negative integers \\n        vector<int> neg;\\n        \\n        //countp - number positive integers\\n        //countn - number of negative integers\\n        // countz - number of zeroes\\n        int countp=0,countn=0,z=0;\\n        \\n        for(auto e : nums){\\n            if(e<0){\\n                neg.push_back(e);\\n                countn++;\\n            }\\n            else if(e>0){\\n                countp++;\\n            }\\n            else{\\n                z++;\\n            }\\n        }\\n        \\n        //special case : eg [0,-1]\\n        if(countn<2 && countp==0){\\n            if(z>0){\\n                return 0;\\n            }\\n            else{\\n                return nums[0];\\n            }\\n        }\\n        \\n        //considering all positive values\\n        long long ans=1;\\n        for(auto e : nums){\\n            if(e>0){\\n                ans=ans*(long long)e;\\n            }\\n        }\\n        \\n        //sorting negative values\\n        sort(neg.begin(),neg.end());\\n        \\n        //taking even number of negative values i.e if size is even taking all other rejecting last value with minimum magnitude\\n        for(int i=0 ; i<((int)neg.size()&1 ? neg.size()-1 : neg.size()) ; i++){\\n            ans=ans*(long long)neg[i];\\n            cout<<ans<<endl;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        //store negative integers \\n        vector<int> neg;\\n        \\n        //countp - number positive integers\\n        //countn - number of negative integers\\n        // countz - number of zeroes\\n        int countp=0,countn=0,z=0;\\n        \\n        for(auto e : nums){\\n            if(e<0){\\n                neg.push_back(e);\\n                countn++;\\n            }\\n            else if(e>0){\\n                countp++;\\n            }\\n            else{\\n                z++;\\n            }\\n        }\\n        \\n        //special case : eg [0,-1]\\n        if(countn<2 && countp==0){\\n            if(z>0){\\n                return 0;\\n            }\\n            else{\\n                return nums[0];\\n            }\\n        }\\n        \\n        //considering all positive values\\n        long long ans=1;\\n        for(auto e : nums){\\n            if(e>0){\\n                ans=ans*(long long)e;\\n            }\\n        }\\n        \\n        //sorting negative values\\n        sort(neg.begin(),neg.end());\\n        \\n        //taking even number of negative values i.e if size is even taking all other rejecting last value with minimum magnitude\\n        for(int i=0 ; i<((int)neg.size()&1 ? neg.size()-1 : neg.size()) ; i++){\\n            ans=ans*(long long)neg[i];\\n            cout<<ans<<endl;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3568724,
                "title": "bit-manipulation-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return nums[0];\\n        long long ans= LLONG_MIN;\\n        for(int i=1;i<(1<<n);i++){\\n            long long pro=1;\\n            for(int bit=0;bit<n;bit++){\\n                if(i&(1<<bit)) pro*=nums[bit];\\n            }\\n            ans=max(ans,pro);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return nums[0];\\n        long long ans= LLONG_MIN;\\n        for(int i=1;i<(1<<n);i++){\\n            long long pro=1;\\n            for(int bit=0;bit<n;bit++){\\n                if(i&(1<<bit)) pro*=nums[bit];\\n            }\\n            ans=max(ans,pro);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568680,
                "title": "c-not-so-good-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public long MaxStrength(int[] nums) \\n    {\\n        int negativeCount = 0;\\n        int zeroCount = 0;\\n        \\n        if(nums.Length == 1)\\n        {\\n            return nums[0];\\n        }\\n        \\n        long op=1;\\n        int small = Int32.MaxValue;\\n        for(int i=0;i<nums.Length;i++)\\n        {\\n            if(Math.Abs(nums[i]) <= Math.Abs(small) && nums[i] < 0)\\n            {\\n                small = nums[i];               \\n            }\\n            if(nums[i] != 0)\\n            {\\n                op = op * nums[i];  \\n            }\\n            if(nums[i]<0)\\n            {\\n                negativeCount++;\\n            }\\n            if(nums[i]==0)\\n            {\\n                zeroCount++;\\n            }\\n     \\n        }\\n\\n        if(op<0)\\n        {\\n            op = op /small; \\n        }\\n        \\n        if((negativeCount == 1 && negativeCount+zeroCount == nums.Length) || zeroCount == nums.Length)\\n        {\\n            return 0;\\n        }\\n\\n        \\n        return op;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long MaxStrength(int[] nums) \\n    {\\n        int negativeCount = 0;\\n        int zeroCount = 0;\\n        \\n        if(nums.Length == 1)\\n        {\\n            return nums[0];\\n        }\\n        \\n        long op=1;\\n        int small = Int32.MaxValue;\\n        for(int i=0;i<nums.Length;i++)\\n        {\\n            if(Math.Abs(nums[i]) <= Math.Abs(small) && nums[i] < 0)\\n            {\\n                small = nums[i];               \\n            }\\n            if(nums[i] != 0)\\n            {\\n                op = op * nums[i];  \\n            }\\n            if(nums[i]<0)\\n            {\\n                negativeCount++;\\n            }\\n            if(nums[i]==0)\\n            {\\n                zeroCount++;\\n            }\\n     \\n        }\\n\\n        if(op<0)\\n        {\\n            op = op /small; \\n        }\\n        \\n        if((negativeCount == 1 && negativeCount+zeroCount == nums.Length) || zeroCount == nums.Length)\\n        {\\n            return 0;\\n        }\\n\\n        \\n        return op;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568637,
                "title": "take-or-not-take-recursive",
                "content": "```\\nclass Solution {\\npublic:\\n    long long ans;\\n    void solve(int i,long long pro,vector<int>&nums)\\n    {\\n        if(pro!=1) ans=max(ans,pro);\\n        if(i>=nums.size()) return;\\n        solve(i+1,pro,nums);\\n        solve(i+1,pro*nums[i],nums);\\n    }\\n    \\n    long long maxStrength(vector<int>& nums) {\\n        ans=*max_element(nums.begin(),nums.end());\\n        solve(0,1,nums);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long ans;\\n    void solve(int i,long long pro,vector<int>&nums)\\n    {\\n        if(pro!=1) ans=max(ans,pro);\\n        if(i>=nums.size()) return;\\n        solve(i+1,pro,nums);\\n        solve(i+1,pro*nums[i],nums);\\n    }\\n    \\n    long long maxStrength(vector<int>& nums) {\\n        ans=*max_element(nums.begin(),nums.end());\\n        solve(0,1,nums);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568585,
                "title": "c-java-one-pass-greedy-solution",
                "content": "## Explanation\\nTo maximise the product , its intuitive that we should multiply all positive numbers and even number of negative numbers so that the resultant product is positive and maximum.\\n\\nIf there are odd number of negative numbers, exclude the negative number with minimum absolute value. Beware of the edge cases, where the array might be filled with zeros and 0 or 1 negative number.\\n\\n## Code\\n```C++ []\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n    long long maxStrength(vector<int>& nums) {\\n        ll n = size(nums), pos = 0, neg = 0, prod = 1, minNeg = -10;\\n        if(n == 1) return nums[0];\\n        for(int val : nums){\\n            if(val > 0) pos++;\\n            else if(val < 0) {\\n                neg++;\\n                minNeg = max(minNeg, (ll)val);\\n            }\\n            if(val) prod = prod * abs(val);\\n        }\\n        if(pos == 0 and neg < 2) return 0;\\n        if(neg % 2) prod = prod / abs(minNeg);\\n        return prod;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        long n = nums.length, pos = 0, neg = 0, prod = 1, minNeg = -10;\\n        if(n == 1) return nums[0];\\n        for(int val : nums){\\n            if(val > 0) pos++;\\n            else if(val < 0) {\\n                neg++;\\n                minNeg = Math.max(minNeg, (long)val);\\n            }\\n            if(val != 0) prod = prod * Math.abs(val);\\n        }\\n        if(pos == 0 && neg < 2) return 0;\\n        if(neg % 2 == 1) prod = prod / Math.abs(minNeg);\\n        return prod;\\n    }\\n}\\n```\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n    long long maxStrength(vector<int>& nums) {\\n        ll n = size(nums), pos = 0, neg = 0, prod = 1, minNeg = -10;\\n        if(n == 1) return nums[0];\\n        for(int val : nums){\\n            if(val > 0) pos++;\\n            else if(val < 0) {\\n                neg++;\\n                minNeg = max(minNeg, (ll)val);\\n            }\\n            if(val) prod = prod * abs(val);\\n        }\\n        if(pos == 0 and neg < 2) return 0;\\n        if(neg % 2) prod = prod / abs(minNeg);\\n        return prod;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        long n = nums.length, pos = 0, neg = 0, prod = 1, minNeg = -10;\\n        if(n == 1) return nums[0];\\n        for(int val : nums){\\n            if(val > 0) pos++;\\n            else if(val < 0) {\\n                neg++;\\n                minNeg = Math.max(minNeg, (long)val);\\n            }\\n            if(val != 0) prod = prod * Math.abs(val);\\n        }\\n        if(pos == 0 && neg < 2) return 0;\\n        if(neg % 2 == 1) prod = prod / Math.abs(minNeg);\\n        return prod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568581,
                "title": "java-recursion",
                "content": "# Code\\n```\\nclass Solution {\\n    private long maxStrength;\\n\\n    public long maxStrength(int[] nums) {\\n        maxStrength = Integer.MIN_VALUE;\\n        helper(nums, 0, 1, 0);\\n        return maxStrength;\\n    }\\n\\n    private void helper(int[] nums, int index, long product, int size) {\\n        if (index >= nums.length) {\\n            if(size != 0) maxStrength = Math.max(maxStrength, product);\\n            return;\\n        }\\n\\n        helper(nums, index + 1, product * nums[index], size + 1);\\n        helper(nums, index + 1, product, size);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private long maxStrength;\\n\\n    public long maxStrength(int[] nums) {\\n        maxStrength = Integer.MIN_VALUE;\\n        helper(nums, 0, 1, 0);\\n        return maxStrength;\\n    }\\n\\n    private void helper(int[] nums, int index, long product, int size) {\\n        if (index >= nums.length) {\\n            if(size != 0) maxStrength = Math.max(maxStrength, product);\\n            return;\\n        }\\n\\n        helper(nums, index + 1, product * nums[index], size + 1);\\n        helper(nums, index + 1, product, size);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095988,
                "title": "rust-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(2^n)$$\\n\\n- Space complexity:\\n$$O(1)$$O\\n\\n# Code\\n```\\nimpl Solution {\\n  pub fn max_strength(nums: Vec<i32>) -> i64 {\\n    let n = nums.len();\\n    let limit = 1i64 << n;\\n    let mut result = -10i64.pow(13);\\n    for i in 1..limit {\\n      let mut temp = 1;\\n      for j in 0..n {\\n        if i >> j & 1 == 1 {\\n          temp *= nums[j] as i64;\\n        }\\n      }\\n      result = result.max(temp);\\n    }\\n\\n    result\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn max_strength(nums: Vec<i32>) -> i64 {\\n    let n = nums.len();\\n    let limit = 1i64 << n;\\n    let mut result = -10i64.pow(13);\\n    for i in 1..limit {\\n      let mut temp = 1;\\n      for j in 0..n {\\n        if i >> j & 1 == 1 {\\n          temp *= nums[j] as i64;\\n        }\\n      }\\n      result = result.max(temp);\\n    }\\n\\n    result\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4091812,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        n=[]\\n        pos=[]\\n        if len(nums)==1:\\n            return nums[0]\\n        for i in nums:\\n            if 0>i:\\n                n.append(-i)\\n            elif i>0:\\n                pos.append(i)\\n        n.sort()\\n        if len(n)%2==1:\\n            n.pop(0)\\n        if len(n)==0 and len(pos)==0:\\n            return 0\\n        else:\\n            return prod(n)*prod(pos)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        n=[]\\n        pos=[]\\n        if len(nums)==1:\\n            return nums[0]\\n        for i in nums:\\n            if 0>i:\\n                n.append(-i)\\n            elif i>0:\\n                pos.append(i)\\n        n.sort()\\n        if len(n)%2==1:\\n            n.pop(0)\\n        if len(n)==0 and len(pos)==0:\\n            return 0\\n        else:\\n            return prod(n)*prod(pos)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086404,
                "title": "ruby-4-liner",
                "content": "```ruby\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef max_strength(nums)\\n  nums.drop(1).each_with_object(Array.new(2, nums[0])) { |num, acc|\\n    (res, cur_min) = acc\\n    acc[0], acc[1] = [res, num, num*res, num*cur_min].max, [cur_min, num, num*cur_min, num*res].min\\n  }[0]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef max_strength(nums)\\n  nums.drop(1).each_with_object(Array.new(2, nums[0])) { |num, acc|\\n    (res, cur_min) = acc\\n    acc[0], acc[1] = [res, num, num*res, num*cur_min].max, [cur_min, num, num*cur_min, num*res].min\\n  }[0]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4078316,
                "title": "easy-greedy-python-c-javascript-beats-96-simple-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want to simply first choose the elements which contribute to the maximum product.\\n\\nWe can filter the un-needed from the total product !! \\uD83D\\uDE2E\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGet a non-zero product of the list. Iterate through the ```nums``` list and remove elements which do not increase product greedily (check code). \\n\\nFew conditions are put to handle edge cases. An edge case, for this question, is any test case with 0. To avoid the product from 0, only non-zero elements are checked. \\n\\nFinally, we compare the total product and the product obtained Greedily.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```gp``` = Greedy Product\\n```python []\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        prod,c,n,gp=1,0,len(nums),0\\n        if n==1:\\n            return nums[0]\\n        for j in nums:\\n            if j:\\n                prod*=j\\n            else:\\n                c+=1\\n        if n-c<=1:\\n            return max(nums)\\n        for j in nums:\\n            if j and prod/j>gp:\\n                gp=prod/j\\n        return int(max(gp,prod))\\n```\\n```cpp []\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        long long prod = 1, c = 0, n = nums.size(), gp = 0;\\n        if (n == 1) {\\n            return nums[0];\\n        }\\n        for (int j : nums) {\\n            if (j) {\\n                prod *= j;\\n            } else {\\n                c += 1;\\n            }\\n        }\\n        if (n - c <= 1) {\\n            return *std::max_element(nums.begin(), nums.end());\\n        }\\n        for (int j : nums) {\\n            if (j && prod / j > gp) {\\n                gp = prod / j;\\n            }\\n        }\\n        return std::max(gp, prod);\\n    }\\n};\\n```\\n```javascript []\\nvar maxStrength = function(nums) {\\n     let prod = 1;\\n        let c = 0;\\n        let n = nums.length;\\n        let gp = 0;\\n        if (n === 1) {\\n            return nums[0];\\n        }\\n        for (let j of nums) {\\n            if (j) {\\n                prod *= j;\\n            } else {\\n                c += 1;\\n            }\\n        }\\n        if (n - c <= 1) {\\n            return Math.max(...nums);\\n        }\\n        for (let j of nums) {\\n            if (j && prod / j > gp) {\\n                gp = prod / j;\\n            }\\n        }\\n        return Math.max(gp, prod);\\n};\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```nums```\n```gp```\n```python []\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        prod,c,n,gp=1,0,len(nums),0\\n        if n==1:\\n            return nums[0]\\n        for j in nums:\\n            if j:\\n                prod*=j\\n            else:\\n                c+=1\\n        if n-c<=1:\\n            return max(nums)\\n        for j in nums:\\n            if j and prod/j>gp:\\n                gp=prod/j\\n        return int(max(gp,prod))\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        long long prod = 1, c = 0, n = nums.size(), gp = 0;\\n        if (n == 1) {\\n            return nums[0];\\n        }\\n        for (int j : nums) {\\n            if (j) {\\n                prod *= j;\\n            } else {\\n                c += 1;\\n            }\\n        }\\n        if (n - c <= 1) {\\n            return *std::max_element(nums.begin(), nums.end());\\n        }\\n        for (int j : nums) {\\n            if (j && prod / j > gp) {\\n                gp = prod / j;\\n            }\\n        }\\n        return std::max(gp, prod);\\n    }\\n};\\n```\n```javascript []\\nvar maxStrength = function(nums) {\\n     let prod = 1;\\n        let c = 0;\\n        let n = nums.length;\\n        let gp = 0;\\n        if (n === 1) {\\n            return nums[0];\\n        }\\n        for (let j of nums) {\\n            if (j) {\\n                prod *= j;\\n            } else {\\n                c += 1;\\n            }\\n        }\\n        if (n - c <= 1) {\\n            return Math.max(...nums);\\n        }\\n        for (let j of nums) {\\n            if (j && prod / j > gp) {\\n                gp = prod / j;\\n            }\\n        }\\n        return Math.max(gp, prod);\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077798,
                "title": "beats-92-c-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n       if(nums.size()==1)\\n       return nums[0];\\n       int cn=0,cp=0,zero=0;\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           if(nums[i]<0)\\n           cn++;\\n           else if(nums[i]>0)\\n           cp++;\\n           else\\n           zero++;\\n       } \\n       if(cn%2)\\n       cn-=1;\\n       if(zero&&!cp&&cn<=1)\\n       return 0;\\n       long long p=1;\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           if(nums[i]<0&&cn)\\n           {\\n           p*=nums[i];\\n           cn--;\\n         \\n           }\\n           else if(nums[i]>0)\\n           p*=nums[i];\\n       }\\n       return p;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n       if(nums.size()==1)\\n       return nums[0];\\n       int cn=0,cp=0,zero=0;\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           if(nums[i]<0)\\n           cn++;\\n           else if(nums[i]>0)\\n           cp++;\\n           else\\n           zero++;\\n       } \\n       if(cn%2)\\n       cn-=1;\\n       if(zero&&!cp&&cn<=1)\\n       return 0;\\n       long long p=1;\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           if(nums[i]<0&&cn)\\n           {\\n           p*=nums[i];\\n           cn--;\\n         \\n           }\\n           else if(nums[i]>0)\\n           p*=nums[i];\\n       }\\n       return p;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056426,
                "title": "here-my-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst maxStrength = nums => {\\n  let positives = 1, negatives = 1, minNegative = -9\\n  let positiveCount = 0, negativeCount = 0\\n  if(nums.length === 1) {\\n    return nums[0]\\n  }\\n  for(let i = 0; i < nums.length; i++) {\\n    const item = nums[i]\\n    if(item > 0) {\\n      positives *= item\\n      positiveCount++\\n    } else if(item < 0) {\\n      negatives *= item\\n      minNegative = Math.max(minNegative, item)\\n      negativeCount++\\n    }   \\n  }\\n  if(!positiveCount && nums.includes(0) && negativeCount === 1) {\\n    return 0\\n  }\\n  if(!positiveCount && !negativeCount) {\\n    return 0\\n  }\\n  if(negatives > 0) {\\n    return positives * negatives\\n  } else {\\n    return positives * (negatives/minNegative)\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst maxStrength = nums => {\\n  let positives = 1, negatives = 1, minNegative = -9\\n  let positiveCount = 0, negativeCount = 0\\n  if(nums.length === 1) {\\n    return nums[0]\\n  }\\n  for(let i = 0; i < nums.length; i++) {\\n    const item = nums[i]\\n    if(item > 0) {\\n      positives *= item\\n      positiveCount++\\n    } else if(item < 0) {\\n      negatives *= item\\n      minNegative = Math.max(minNegative, item)\\n      negativeCount++\\n    }   \\n  }\\n  if(!positiveCount && nums.includes(0) && negativeCount === 1) {\\n    return 0\\n  }\\n  if(!positiveCount && !negativeCount) {\\n    return 0\\n  }\\n  if(negatives > 0) {\\n    return positives * negatives\\n  } else {\\n    return positives * (negatives/minNegative)\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4051854,
                "title": "easy-java-solution-beats-100-in-time",
                "content": "\\n\\n# Complexity \\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        \\n        long ans=1;\\n        long min=Integer.MIN_VALUE,max=min;\\n        int count=0;\\n        if(nums.length==1)\\n        {\\n            return nums[0];\\n        }\\n    \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            max=Math.max(max,nums[i]);\\n            if(nums[i]==0)\\n            {\\n                continue;\\n            }\\n            if(nums[i]<0)\\n            {\\n                count++;\\n                min=Math.max(min,nums[i]);\\n            }\\n            \\n            ans=ans*nums[i];\\n        }\\n        \\n        if(max==0 && (count==1||count==0))\\n        {\\n            return 0;\\n        }\\n        if(count%2==0)\\n        {\\n            return ans;\\n        }\\n        if(count%2!=0 )\\n        {\\n            return (long)ans/min;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        \\n        long ans=1;\\n        long min=Integer.MIN_VALUE,max=min;\\n        int count=0;\\n        if(nums.length==1)\\n        {\\n            return nums[0];\\n        }\\n    \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            max=Math.max(max,nums[i]);\\n            if(nums[i]==0)\\n            {\\n                continue;\\n            }\\n            if(nums[i]<0)\\n            {\\n                count++;\\n                min=Math.max(min,nums[i]);\\n            }\\n            \\n            ans=ans*nums[i];\\n        }\\n        \\n        if(max==0 && (count==1||count==0))\\n        {\\n            return 0;\\n        }\\n        if(count%2==0)\\n        {\\n            return ans;\\n        }\\n        if(count%2!=0 )\\n        {\\n            return (long)ans/min;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051467,
                "title": "c-by-counting-zero-ve-and-ve-numbers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nJust if and else and observing different test cases\\nTry to handle these test cases and will get the answer\\n[-1], [-1,0,0,0], [0,0,0], [-1,-1,0], [3,4,5,-1,-1,-3]\\n\\n# Complexity\\n- Time complexity: \\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        long long res = 1;\\n        int minNeg = 10;\\n        int negCount = 0;\\n        int zeroCount = false;\\n\\n        for(auto &v: nums) {\\n            if(v == 0) zeroCount++;\\n            else if(v > 0) res*=v;\\n            else {\\n                negCount++;\\n                res*=abs(v);\\n                minNeg = min(minNeg, abs(v));\\n            }\\n        }\\n\\n        if((nums.size() == 1) && (negCount == 1)) return -res;\\n        if(nums.size() == zeroCount) return 0;\\n        if((nums.size() == zeroCount + 1) && (negCount == 1)) return 0;\\n        if(negCount%2) res/=minNeg;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        long long res = 1;\\n        int minNeg = 10;\\n        int negCount = 0;\\n        int zeroCount = false;\\n\\n        for(auto &v: nums) {\\n            if(v == 0) zeroCount++;\\n            else if(v > 0) res*=v;\\n            else {\\n                negCount++;\\n                res*=abs(v);\\n                minNeg = min(minNeg, abs(v));\\n            }\\n        }\\n\\n        if((nums.size() == 1) && (negCount == 1)) return -res;\\n        if(nums.size() == zeroCount) return 0;\\n        if((nums.size() == zeroCount + 1) && (negCount == 1)) return 0;\\n        if(negCount%2) res/=minNeg;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045220,
                "title": "c-o-n-time-and-o-1-space",
                "content": "# Intuition\\nMultiply all non-zero, divide by largest negative if the result is negative.\\n\\nThe task is quite easy, but corner cases are tricky. For example, if you have [0, -9], the strongest group is 0, but if you have just [-9], the strongest group is -9. Because of that, we also need to count how many non-zero numbers we have. Thanks to this counter, we can initialize `res` to 1 and avoid having an extra if clause.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int largest_neg = INT_MIN;\\n        long long res = 1;\\n        int nonzero_count = 0;\\n\\n        for (int n : nums) {\\n            if (n != 0) {\\n                nonzero_count++;\\n                res *= n;\\n                if (n < 0) {\\n                    largest_neg = max(largest_neg, n);\\n                }\\n            }\\n        }\\n\\n        if (res < 0 && nums.size() > 1) {\\n            res /= largest_neg;\\n            nonzero_count--;\\n        }\\n\\n        return nonzero_count ? res : 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int largest_neg = INT_MIN;\\n        long long res = 1;\\n        int nonzero_count = 0;\\n\\n        for (int n : nums) {\\n            if (n != 0) {\\n                nonzero_count++;\\n                res *= n;\\n                if (n < 0) {\\n                    largest_neg = max(largest_neg, n);\\n                }\\n            }\\n        }\\n\\n        if (res < 0 && nums.size() > 1) {\\n            res /= largest_neg;\\n            nonzero_count--;\\n        }\\n\\n        return nonzero_count ? res : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042972,
                "title": "0-and-1",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return nums[0];\\n        int one=0,c=0,zero=0;\\n        bool chk=0;\\n        long long ans=1;\\n        int mn=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==1) one++;\\n            if(nums[i]==0) zero++;\\n            if(nums[i]<0)\\n            {\\n                c++;\\n                mn=max(mn,nums[i]);\\n            }\\n            if(nums[i])\\n            {\\n                chk=1;\\n                ans*=nums[i];\\n            }\\n        }\\n        if(c&1 and mn) ans/=mn;\\n        if(zero)\\n        {\\n            if(zero==n or (c and zero==n-1) or (chk and ans<0)) return 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1) return nums[0];\\n        int one=0,c=0,zero=0;\\n        bool chk=0;\\n        long long ans=1;\\n        int mn=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==1) one++;\\n            if(nums[i]==0) zero++;\\n            if(nums[i]<0)\\n            {\\n                c++;\\n                mn=max(mn,nums[i]);\\n            }\\n            if(nums[i])\\n            {\\n                chk=1;\\n                ans*=nums[i];\\n            }\\n        }\\n        if(c&1 and mn) ans/=mn;\\n        if(zero)\\n        {\\n            if(zero==n or (c and zero==n-1) or (chk and ans<0)) return 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033797,
                "title": "greedily-sort-then-max-prefix-product",
                "content": "```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        nums.sort(key = lambda x: (2 if x == 0 else int(x < 0), -abs(x)))\\n        res = float(\\'-inf\\')\\n        p = 1\\n        for el in nums:\\n            p *= el\\n            res = max(res, p)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        nums.sort(key = lambda x: (2 if x == 0 else int(x < 0), -abs(x)))\\n        res = float(\\'-inf\\')\\n        p = 1\\n        for el in nums:\\n            p *= el\\n            res = max(res, p)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007308,
                "title": "c-code-recursive-backtracking",
                "content": "The given C++ code finds the maximum product that can be obtained by multiplying a subsequence of integers from a vector nums. Here\\'s a simple explanation of the algorithm:\\n\\n1. Initialize a variable pro to store the maximum product and set it to a very small value (INT_MIN).\\n1. Get the size of the input vector nums and store it in the variable n.\\n1. Define a recursive function backTrack that takes two parameters: cur (current index) and product (current product). This function is a lambda function, which means it\\'s a small, self-contained function defined within the main function.\\n1. Inside the backTrack function:\\na. Check if cur has reached the end of the vector (cur == n). If so, update the pro variable with the maximum of the current pro and product and return from the function.\\nb. Recursively call backTrack twice:\\n\\t1. First, multiply the current element at index cur with the product if product is not INT_MIN, otherwise, use 1*nums[cur]. This represents including the current element in the subsequence.\\n\\t1. Second, call backTrack without multiplying the current element by product. This represents excluding the current element from the subsequence.\\n1. Call the backTrack function initially with cur as 0 and product as INT_MIN.\\n1. Return the final value of pro as the maximum product.\\nIn simple terms, the code explores all possible subsequences of nums to find the one with the highest product, considering both including and excluding elements at each step. It uses recursion to explore all possibilities and keeps track of the maximum product found so far in the pro variable.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        \\n        long long pro=INT_MIN;\\n        int n=nums.size();\\n        function <void(int,long long)>backTrack=[&](int cur,long long product)\\n        {\\n            if(cur==n)\\n            {\\n                pro=max(pro,product);\\n                return;\\n            }            \\n                backTrack(cur+1,product==INT_MIN ? 1*nums[cur]: product*nums[cur]);\\n                backTrack(cur+1,product);\\n        };\\n        \\n        backTrack(0,INT_MIN);\\n        return pro;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        \\n        long long pro=INT_MIN;\\n        int n=nums.size();\\n        function <void(int,long long)>backTrack=[&](int cur,long long product)\\n        {\\n            if(cur==n)\\n            {\\n                pro=max(pro,product);\\n                return;\\n            }            \\n                backTrack(cur+1,product==INT_MIN ? 1*nums[cur]: product*nums[cur]);\\n                backTrack(cur+1,product);\\n        };\\n        \\n        backTrack(0,INT_MIN);\\n        return pro;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006251,
                "title": "simple-solution-using-backtracking",
                "content": "\\n\\n# Code\\n```\\nimport math\\nclass Solution(object):\\n    def maxStrength(self, nums):\\n        pro=[]\\n        def back(pro,nums,i,new):\\n            if len(new)!=0:\\n                pro.append(math.prod(new))\\n            for j in range(i,len(nums)):\\n                back(pro,nums,j+1,new+[nums[j]])\\n        back(pro,nums,0,[])\\n        pro.sort()\\n        return pro[-1]\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution(object):\\n    def maxStrength(self, nums):\\n        pro=[]\\n        def back(pro,nums,i,new):\\n            if len(new)!=0:\\n                pro.append(math.prod(new))\\n            for j in range(i,len(nums)):\\n                back(pro,nums,j+1,new+[nums[j]])\\n        back(pro,nums,0,[])\\n        pro.sort()\\n        return pro[-1]\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006175,
                "title": "simple-solution-beats-80-memory",
                "content": "\\n\\n# Code\\n```\\nimport math\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        neg=[]\\n        pos=[]\\n        z=float(-inf)\\n        for i in nums:\\n            if i<0:\\n                neg.append(i)\\n            if i>0:\\n                pos.append(i)\\n            if i==0:\\n                z=0\\n        neg.sort()\\n        pos.sort()\\n        a=float(-inf)\\n        b=float(-inf)\\n        if len(neg+pos)==0:\\n                a=float(-inf)\\n        else:\\n\\n            if len(neg)%2==0:\\n                b=math.prod(neg+pos)\\n                    \\n            else:\\n                i\\n                if len(neg[:len(neg)-1]+pos)==0 and len(neg)!=0:\\n                    a=neg[0]\\n                \\n                else:\\n                    a=math.prod(neg[:len(neg)-1]+pos)\\n        return max(a,b,z)\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        neg=[]\\n        pos=[]\\n        z=float(-inf)\\n        for i in nums:\\n            if i<0:\\n                neg.append(i)\\n            if i>0:\\n                pos.append(i)\\n            if i==0:\\n                z=0\\n        neg.sort()\\n        pos.sort()\\n        a=float(-inf)\\n        b=float(-inf)\\n        if len(neg+pos)==0:\\n                a=float(-inf)\\n        else:\\n\\n            if len(neg)%2==0:\\n                b=math.prod(neg+pos)\\n                    \\n            else:\\n                i\\n                if len(neg[:len(neg)-1]+pos)==0 and len(neg)!=0:\\n                    a=neg[0]\\n                \\n                else:\\n                    a=math.prod(neg[:len(neg)-1]+pos)\\n        return max(a,b,z)\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003365,
                "title": "python-3",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        import math\\n        l = len(nums)\\n        m = math.prod(nums)\\n\\n        if l == 1:\\n            return m\\n\\n        if m == 0:\\n            if nums.count(0) == l:\\n                return 0\\n            elif nums.count(0)>=1:\\n                for i in range(nums.count(0)):\\n                    nums.remove(0)\\n            m = math.prod(nums)\\n        if m < 0:\\n            pos = [x for x in nums if x>0]\\n            neg = [x for x in nums if x<0]\\n            neg.sort()\\n            neg.pop()\\n            if len(neg+pos) == 0:\\n                return 0\\n            return math.prod(pos) * math.prod(neg)\\n        \\n        return m\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        import math\\n        l = len(nums)\\n        m = math.prod(nums)\\n\\n        if l == 1:\\n            return m\\n\\n        if m == 0:\\n            if nums.count(0) == l:\\n                return 0\\n            elif nums.count(0)>=1:\\n                for i in range(nums.count(0)):\\n                    nums.remove(0)\\n            m = math.prod(nums)\\n        if m < 0:\\n            pos = [x for x in nums if x>0]\\n            neg = [x for x in nums if x<0]\\n            neg.sort()\\n            neg.pop()\\n            if len(neg+pos) == 0:\\n                return 0\\n            return math.prod(pos) * math.prod(neg)\\n        \\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000984,
                "title": "very-simple-o-n-solution",
                "content": "# Intuition\\nWe can simple multiply all the elements(skipping 0s) and if the product is negative, we can divide it with the highest negative element that is part of the array. that sould give us the maximum.\\n# Approach\\nThere are few special cases to be handled here:\\n1- If array has only 1 element, the product will be that only.\\n2- If the product is negative and equals to the  the highest negative   element, that means the array contains that element and any number of 1\\'s and/or 0\\'s. We can keep a track of that and if 1 occusrs even once , we can return 1, else if zero occurs even once return 0;\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n- Space complexity:\\n  O(n)  \\n# Code\\n```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n\\n        int minRem=-99999;\\n        long product=0;\\n        boolean one=false;\\n        boolean zero=false;\\n\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=0){\\n               if(product==0){\\n                   product=1;\\n               }\\n                product=product*nums[i];\\n              \\n            }\\n            if(nums[i]<0 && nums[i]>minRem){\\n                minRem=nums[i];\\n            }\\n\\n            if(nums[i]==1){\\n                one=true;\\n            }\\n            if(nums[i]==0){\\n                zero=true;\\n            }\\n        }\\n\\n\\n        if(product<0){\\n           \\n            if(product==minRem){\\n                if(one)\\n                    return 1;\\n                if(zero)\\n                    return 0;    \\n            }\\n             product=product/minRem;\\n        }\\n\\n\\n    \\n        \\n        \\n        return product;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n\\n        int minRem=-99999;\\n        long product=0;\\n        boolean one=false;\\n        boolean zero=false;\\n\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=0){\\n               if(product==0){\\n                   product=1;\\n               }\\n                product=product*nums[i];\\n              \\n            }\\n            if(nums[i]<0 && nums[i]>minRem){\\n                minRem=nums[i];\\n            }\\n\\n            if(nums[i]==1){\\n                one=true;\\n            }\\n            if(nums[i]==0){\\n                zero=true;\\n            }\\n        }\\n\\n\\n        if(product<0){\\n           \\n            if(product==minRem){\\n                if(one)\\n                    return 1;\\n                if(zero)\\n                    return 0;    \\n            }\\n             product=product/minRem;\\n        }\\n\\n\\n    \\n        \\n        \\n        return product;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990726,
                "title": "simple-sorting-based-approach",
                "content": "\\n# Approach\\nIf we sort the array, all numbers which are positive(>0) will be part of the solution. \\nWhen 0 is there, then there are conditions:\\n  1. If 0 is not the largest element, then ignore it.\\n  2. If it\\'s the largest number, then consider the negative numbers:\\n    a. If count of negative number is even, then ignore 0 and consider product of negative numbers which will turn out to be positive since count of negative numbers are even.\\n    b. If count of negative number is odd, then check if count is 1(only 1 negative number), then ignore it. Else proceed to #3 point.\\n  3. If negative number is encountered, keep track of firstnegative number. This number at firstnegative index will be ignored if count of negative number is odd. Because it\\'s the smallest negative number. \\n\\n# Complexity\\n- Time complexity:\\nnlogn(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public long maxStrength(int[] nums) {\\n      \\n        Arrays.sort(nums);\\n       \\n        long ans=nums[nums.length-1];\\n        int firstNegativeIndex=-1;\\n        if(ans<0){\\n            firstNegativeIndex=nums.length-1;\\n            ans=1;\\n        } else{\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(nums[i]>=0){\\n                ans=Math.max(ans*nums[i],ans);\\n              \\n            }\\n            else if(nums[i]<0){\\n                firstNegativeIndex=i;\\n                break;\\n\\n            }\\n        }\\n        }\\n        \\n        if(firstNegativeIndex!=-1){\\n          \\n            if((firstNegativeIndex+1)%2==0){\\n                int index=firstNegativeIndex;\\n                if(ans==0){\\n                    ans=1;\\n                }\\n                while (index>=0){\\n                    ans=ans*nums[index];\\n                    index--;\\n                }\\n            }else {\\n                int index=firstNegativeIndex-1;\\n                 if(index<0){\\n                     if(firstNegativeIndex!=(nums.length-1)){\\n                         return nums[nums.length-1]==0?0:ans;\\n                     }\\n                    index=0;\\n                }else{\\n                   if(ans==0){\\n                    ans=1;\\n                }  \\n                }\\n                while (index>=0){\\n                    ans=ans*nums[index];\\n                    index--;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n\\n    public long maxStrength(int[] nums) {\\n      \\n        Arrays.sort(nums);\\n       \\n        long ans=nums[nums.length-1];\\n        int firstNegativeIndex=-1;\\n        if(ans<0){\\n            firstNegativeIndex=nums.length-1;\\n            ans=1;\\n        } else{\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(nums[i]>=0){\\n                ans=Math.max(ans*nums[i],ans);\\n              \\n            }\\n            else if(nums[i]<0){\\n                firstNegativeIndex=i;\\n                break;\\n\\n            }\\n        }\\n        }\\n        \\n        if(firstNegativeIndex!=-1){\\n          \\n            if((firstNegativeIndex+1)%2==0){\\n                int index=firstNegativeIndex;\\n                if(ans==0){\\n                    ans=1;\\n                }\\n                while (index>=0){\\n                    ans=ans*nums[index];\\n                    index--;\\n                }\\n            }else {\\n                int index=firstNegativeIndex-1;\\n                 if(index<0){\\n                     if(firstNegativeIndex!=(nums.length-1)){\\n                         return nums[nums.length-1]==0?0:ans;\\n                     }\\n                    index=0;\\n                }else{\\n                   if(ans==0){\\n                    ans=1;\\n                }  \\n                }\\n                while (index>=0){\\n                    ans=ans*nums[index];\\n                    index--;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987359,
                "title": "o-n-tc-sc-o-1-single-loop-100-faster-simple-and-easy-to-understand-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThree types of values are possible for every element:\\npositive, negative & zero , based on that their contribution in the max product will be deicded.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEvery positive element will contribute to the max product and 0 will be the ans when there are only zero elements in the array or one negative and all zeros but for negative elements,there are again three possible cases:\\n(i) only one negative element:\\nIn this case, the single negative element won\\'t contribute to the max product unless it\\'s the only element in the array.\\n(ii) odd number of negative element (>=3)\\nIn this scenario, we have to drop one negative element to make the count of negative elements even so that their product is positive. Now the question is which negative element to drop. The max element among those negative elements will be dropped since without it the product will be maximum. \\nfor eg in case of -4, -5, -3 so if we drop max element i.e. -3 we get max prod i.e. 20 as the ans which is correct.\\n(iii) even number of negative elements:\\nEvery negative element will contribute to the max product when there are even number of negative elements.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        long posProd = 1;\\n        long negProd = 1;\\n        int maxNeg = Integer.MIN_VALUE;\\n        int negCount = 0;\\n        boolean hasPos = false;\\n        boolean hasZero = false;\\n\\n        for (final int num : nums)\\n            if (num > 0) {\\n                posProd *= num;\\n                hasPos = true;\\n            } else if (num < 0) {\\n                negProd *= num;\\n                maxNeg = Math.max(maxNeg, num);\\n                ++negCount;\\n            } else { // num == 0\\n                hasZero = true;\\n            }\\n\\n        if (negCount == 0 && !hasPos) return 0;\\n        if (negCount % 2 == 0) return negProd*posProd;\\n        if (negCount >= 3)return negProd/maxNeg*posProd;\\n        if (hasPos)return posProd;\\n        if (hasZero)return 0;\\n        return maxNeg;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        long posProd = 1;\\n        long negProd = 1;\\n        int maxNeg = Integer.MIN_VALUE;\\n        int negCount = 0;\\n        boolean hasPos = false;\\n        boolean hasZero = false;\\n\\n        for (final int num : nums)\\n            if (num > 0) {\\n                posProd *= num;\\n                hasPos = true;\\n            } else if (num < 0) {\\n                negProd *= num;\\n                maxNeg = Math.max(maxNeg, num);\\n                ++negCount;\\n            } else { // num == 0\\n                hasZero = true;\\n            }\\n\\n        if (negCount == 0 && !hasPos) return 0;\\n        if (negCount % 2 == 0) return negProd*posProd;\\n        if (negCount >= 3)return negProd/maxNeg*posProd;\\n        if (hasPos)return posProd;\\n        if (hasZero)return 0;\\n        return maxNeg;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968916,
                "title": "beginner-s-code-controlled-by-conditions",
                "content": "# Intuition\\nPossibly one of the actual manipulation of numbers and conditions was present in this question.\\n\\n# Approach\\n I have approached the problem by taking ample of conditions and laying them down on a paper then actually coding the solution keeping in mind all the edge cases.\\nI thought this was one of the best problems when it comes to analysis of numbers and thinking of edge cases!!\\nKindly upvote the solution if you found it clean and precise.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) \\n    {\\n        if(nums.size()==1)\\n        return nums[0];\\n        long long p=1,n=1;\\n        int m=-10;\\n        int l=nums.size();\\n        int c=0,d=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(nums[i]==0)\\n                continue;\\n            if(nums[i]>0){\\n                p*=nums[i];\\n                c++;\\n            }\\n            else\\n            {\\n                m=max(m,nums[i]);\\n                n*=nums[i];\\n                d++;\\n            }\\n            \\n        }\\n        if(c>0 && d==0)\\n        return n*p;\\n        else if(d==0 && c==0)\\n        return 0;\\n        else if(d==1 && c>0)\\n        return n*p/m;\\n        else if(d==1 && c==0)\\n        return 0;\\n        else if((c>0 || d>0)&& n*p>0)\\n        return n*p;\\n        return (n*p)/m;\\n            \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) \\n    {\\n        if(nums.size()==1)\\n        return nums[0];\\n        long long p=1,n=1;\\n        int m=-10;\\n        int l=nums.size();\\n        int c=0,d=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(nums[i]==0)\\n                continue;\\n            if(nums[i]>0){\\n                p*=nums[i];\\n                c++;\\n            }\\n            else\\n            {\\n                m=max(m,nums[i]);\\n                n*=nums[i];\\n                d++;\\n            }\\n            \\n        }\\n        if(c>0 && d==0)\\n        return n*p;\\n        else if(d==0 && c==0)\\n        return 0;\\n        else if(d==1 && c>0)\\n        return n*p/m;\\n        else if(d==1 && c==0)\\n        return 0;\\n        else if((c>0 || d>0)&& n*p>0)\\n        return n*p;\\n        return (n*p)/m;\\n            \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967334,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        if(nums.size()==1){\\n            return nums[0];\\n        }\\n        long long product = 1;\\n        int test_1=0,test_0=0;\\n        int count=0;\\n        int mini = INT_MAX;\\n        for(int i:nums){\\n            if(i>0)\\n                test_1=1;\\n            if(i==0){\\n                test_0=1;\\n                continue;\\n            }\\n            product*=abs(i);\\n            if(i<0){\\n                count++;\\n                mini = min(mini,abs(i));\\n            }\\n        }\\n        if(!test_1&&test_0){\\n            if(count==1||count==0)\\n                return 0;\\n        }\\n        if(count%2==0){\\n            return product;\\n        }\\n        return product/mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        if(nums.size()==1){\\n            return nums[0];\\n        }\\n        long long product = 1;\\n        int test_1=0,test_0=0;\\n        int count=0;\\n        int mini = INT_MAX;\\n        for(int i:nums){\\n            if(i>0)\\n                test_1=1;\\n            if(i==0){\\n                test_0=1;\\n                continue;\\n            }\\n            product*=abs(i);\\n            if(i<0){\\n                count++;\\n                mini = min(mini,abs(i));\\n            }\\n        }\\n        if(!test_1&&test_0){\\n            if(count==1||count==0)\\n                return 0;\\n        }\\n        if(count%2==0){\\n            return product;\\n        }\\n        return product/mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966164,
                "title": "recursion-python3",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        ans = max(nums)\\n        def dfs(idx, curr, check):\\n            if idx == len(nums):\\n                if not check:\\n                    return\\n                nonlocal ans\\n                ans = max(ans, curr)\\n                return\\n            \\n            dfs(idx+1, curr, False)\\n            dfs(idx+1, curr * nums[idx], True)\\n            if check:\\n                dfs(idx+1, curr, True)\\n        dfs(0,1,False)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        ans = max(nums)\\n        def dfs(idx, curr, check):\\n            if idx == len(nums):\\n                if not check:\\n                    return\\n                nonlocal ans\\n                ans = max(ans, curr)\\n                return\\n            \\n            dfs(idx+1, curr, False)\\n            dfs(idx+1, curr * nums[idx], True)\\n            if check:\\n                dfs(idx+1, curr, True)\\n        dfs(0,1,False)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959892,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        int n = nums.length;\\n        if(n == 1){\\n            return nums[0];\\n        }\\n        Arrays.sort(nums);\\n        long sum = 1;\\n        boolean c = false;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i] > 0){\\n                sum *= nums[i];\\n                c = true;\\n            }\\n            else if(nums[i] < 0 && nums[i+1] < 0){\\n                sum *= nums[i];\\n                sum *= nums[i+1];\\n                i++;\\n                c = true;\\n            }\\n        }\\n        if(nums[n-1] > 0){\\n            sum *= nums[n-1];\\n            c = true;\\n        }\\n        return c == true?sum:0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        int n = nums.length;\\n        if(n == 1){\\n            return nums[0];\\n        }\\n        Arrays.sort(nums);\\n        long sum = 1;\\n        boolean c = false;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i] > 0){\\n                sum *= nums[i];\\n                c = true;\\n            }\\n            else if(nums[i] < 0 && nums[i+1] < 0){\\n                sum *= nums[i];\\n                sum *= nums[i+1];\\n                i++;\\n                c = true;\\n            }\\n        }\\n        if(nums[n-1] > 0){\\n            sum *= nums[n-1];\\n            c = true;\\n        }\\n        return c == true?sum:0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946624,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic: \\n\\n    \\n\\n    long long maxStrength(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)return nums[0];\\n        long long ans=1;\\n        sort(nums.begin(),nums.end());\\n        int last=-1,count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<0)last=i;\\n\\n            if(nums[i]!=0){\\n            ans*=nums[i];\\n            count++;\\n            }\\n        }\\n        if(ans<0)\\n        {\\n            ans/=nums[last];\\n            count--;\\n        }\\n        \\n        if(count==0)return 0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n\\n    \\n\\n    long long maxStrength(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)return nums[0];\\n        long long ans=1;\\n        sort(nums.begin(),nums.end());\\n        int last=-1,count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<0)last=i;\\n\\n            if(nums[i]!=0){\\n            ans*=nums[i];\\n            count++;\\n            }\\n        }\\n        if(ans<0)\\n        {\\n            ans/=nums[last];\\n            count--;\\n        }\\n        \\n        if(count==0)return 0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940299,
                "title": "simple-backtracking-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        def f(index, nums, product,count):\\n            if index==len(nums):\\n                if count==0:\\n                    return float(\\'-inf\\')\\n                return product\\n            take=f(index+1, nums, product*nums[index],count+1)\\n            not_take=f(index+1,nums, product,count)\\n            return max(take,not_take)\\n        return f(0,nums,1,0)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        def f(index, nums, product,count):\\n            if index==len(nums):\\n                if count==0:\\n                    return float(\\'-inf\\')\\n                return product\\n            take=f(index+1, nums, product*nums[index],count+1)\\n            not_take=f(index+1,nums, product,count)\\n            return max(take,not_take)\\n        return f(0,nums,1,0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936966,
                "title": "golang-solution-with-comment",
                "content": "# Code\\n```go\\nfunc maxStrength(nums []int) int64 {\\n\\tstrength, nonZero, maxNegative := 1, 0, math.MinInt64\\n\\tfor _, v := range nums {\\n\\t\\tif v == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tstrength *= v\\n\\t\\tnonZero++\\n\\t\\tif v < 0 && v > maxNegative {\\n\\t\\t\\tmaxNegative = v\\n\\t\\t}\\n\\t}\\n\\tif nonZero == 0 {\\n\\t\\t// all 0\\n\\t\\treturn 0\\n\\t}\\n\\tif strength > 0 {\\n\\t\\t// positive\\n\\t\\treturn int64(strength)\\n\\t}\\n\\tif nonZero == 1 {\\n\\t\\tif len(nums) == 1 {\\n\\t\\t\\t// only one negative student\\n\\t\\t\\treturn int64(strength)\\n\\t\\t}\\n\\t\\t// has 0 student\\n\\t\\treturn 0\\n\\t}\\n\\t// remove max negative student\\n\\treturn int64(strength/maxNegative)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc maxStrength(nums []int) int64 {\\n\\tstrength, nonZero, maxNegative := 1, 0, math.MinInt64\\n\\tfor _, v := range nums {\\n\\t\\tif v == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tstrength *= v\\n\\t\\tnonZero++\\n\\t\\tif v < 0 && v > maxNegative {\\n\\t\\t\\tmaxNegative = v\\n\\t\\t}\\n\\t}\\n\\tif nonZero == 0 {\\n\\t\\t// all 0\\n\\t\\treturn 0\\n\\t}\\n\\tif strength > 0 {\\n\\t\\t// positive\\n\\t\\treturn int64(strength)\\n\\t}\\n\\tif nonZero == 1 {\\n\\t\\tif len(nums) == 1 {\\n\\t\\t\\t// only one negative student\\n\\t\\t\\treturn int64(strength)\\n\\t\\t}\\n\\t\\t// has 0 student\\n\\t\\treturn 0\\n\\t}\\n\\t// remove max negative student\\n\\treturn int64(strength/maxNegative)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3933515,
                "title": "backtracking-naive-approach-greedy-approach-beats-86",
                "content": "```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        \"\"\"\\n        naive approach: we can use backtracking to exhaust all the combinations\\n        at every point, we have a choice of whether to include the \\n        current element in the answer or not\\n        \"\"\"\\n        self.max_ans = nums[0]\\n        def fun(index, cur_prod, count):\\n            if index >= len(nums):\\n                if count == 0:\\n                    return float(\\'-inf\\')\\n                return cur_prod\\n\\n            # include the current index as part of answer\\n            x = fun(index+1, cur_prod*nums[index], count+1)\\n            # exclude the current index as part of answer\\n            y = fun(index+1, cur_prod, count)\\n            return max(x, y)\\n        return fun(0, 1, 0)\\n            \\n            \\n```\\nApproach 2: Greedy\\n```\\ndef maxStrength(self, nums: List[int]) -> int:\\n        \"\"\"\\n        greedy approach\\n        sort\\n        \"\"\"\\n        nums.sort()\\n        # count number of positive integers, negative integers\\n        # all positive integers will always be used in answer\\n        # if negative integers are even, all will be used\\n        # if negative integers are odd, highest one will not be used\\n        if len(nums) == 1:\\n            return nums[0]\\n        neg_index, pos_index, pos_index_set, zero_present = -1, -1, False, False\\n        for i in range(len(nums)):\\n            if nums[i] == 0:\\n                zero_present = True\\n            if nums[i] < 0:\\n                neg_index = i\\n            elif not pos_index_set and nums[i] > 0:\\n                pos_index = i\\n                pos_index_set = True\\n        \\n        if pos_index_set:\\n            result = 1\\n            for i in range(pos_index, len(nums)):\\n                result*=nums[i]\\n            if neg_index % 2:\\n                # there are even negative elements all can be used\\n                for i in range(neg_index+1):\\n                    result*=nums[i]\\n            else:\\n                # largest negative value should not be used\\n                for i in range(neg_index):\\n                    result*=nums[i]\\n            return result\\n\\n        if neg_index > -1:\\n            # there is no positive element in nums but negative elements are present\\n            result = nums[0]\\n            if neg_index % 2:\\n                for i in range(1, neg_index+1):\\n                    result*=nums[i]\\n            else:\\n                for i in range(1, neg_index):\\n                    result*=nums[i]\\n            return max(result, 0) if zero_present else result\\n\\n        return 0\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        \"\"\"\\n        naive approach: we can use backtracking to exhaust all the combinations\\n        at every point, we have a choice of whether to include the \\n        current element in the answer or not\\n        \"\"\"\\n        self.max_ans = nums[0]\\n        def fun(index, cur_prod, count):\\n            if index >= len(nums):\\n                if count == 0:\\n                    return float(\\'-inf\\')\\n                return cur_prod\\n\\n            # include the current index as part of answer\\n            x = fun(index+1, cur_prod*nums[index], count+1)\\n            # exclude the current index as part of answer\\n            y = fun(index+1, cur_prod, count)\\n            return max(x, y)\\n        return fun(0, 1, 0)\\n            \\n            \\n```\n```\\ndef maxStrength(self, nums: List[int]) -> int:\\n        \"\"\"\\n        greedy approach\\n        sort\\n        \"\"\"\\n        nums.sort()\\n        # count number of positive integers, negative integers\\n        # all positive integers will always be used in answer\\n        # if negative integers are even, all will be used\\n        # if negative integers are odd, highest one will not be used\\n        if len(nums) == 1:\\n            return nums[0]\\n        neg_index, pos_index, pos_index_set, zero_present = -1, -1, False, False\\n        for i in range(len(nums)):\\n            if nums[i] == 0:\\n                zero_present = True\\n            if nums[i] < 0:\\n                neg_index = i\\n            elif not pos_index_set and nums[i] > 0:\\n                pos_index = i\\n                pos_index_set = True\\n        \\n        if pos_index_set:\\n            result = 1\\n            for i in range(pos_index, len(nums)):\\n                result*=nums[i]\\n            if neg_index % 2:\\n                # there are even negative elements all can be used\\n                for i in range(neg_index+1):\\n                    result*=nums[i]\\n            else:\\n                # largest negative value should not be used\\n                for i in range(neg_index):\\n                    result*=nums[i]\\n            return result\\n\\n        if neg_index > -1:\\n            # there is no positive element in nums but negative elements are present\\n            result = nums[0]\\n            if neg_index % 2:\\n                for i in range(1, neg_index+1):\\n                    result*=nums[i]\\n            else:\\n                for i in range(1, neg_index):\\n                    result*=nums[i]\\n            return max(result, 0) if zero_present else result\\n\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915009,
                "title": "o-n-cpp-simple-for-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        \\n        int neg = 0;\\n        long long ans = 1;\\n        int zero= 0;\\n\\n        if(nums.size() == 1) { return nums[0];}\\n\\n        for(auto x : nums){if(x<0)neg++; if(x == 0){zero++;continue;}ans=ans*x;}\\n\\n        if(zero == nums.size()) return 0;\\n        if(neg == 0) return ans;\\n        if(neg%2 == 0) return ans;\\n\\n        int minneg = INT_MIN;\\n\\n        for(auto x  : nums)\\n        {\\n            if(x < 0){minneg = max(minneg,x);}\\n        }\\n\\n        if(zero == nums.size()-1) return  (ans > 0)?ans:0;\\n         \\n        cout << ans;\\n        return ans/minneg;\\n\\n\\n\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        \\n        int neg = 0;\\n        long long ans = 1;\\n        int zero= 0;\\n\\n        if(nums.size() == 1) { return nums[0];}\\n\\n        for(auto x : nums){if(x<0)neg++; if(x == 0){zero++;continue;}ans=ans*x;}\\n\\n        if(zero == nums.size()) return 0;\\n        if(neg == 0) return ans;\\n        if(neg%2 == 0) return ans;\\n\\n        int minneg = INT_MIN;\\n\\n        for(auto x  : nums)\\n        {\\n            if(x < 0){minneg = max(minneg,x);}\\n        }\\n\\n        if(zero == nums.size()-1) return  (ans > 0)?ans:0;\\n         \\n        cout << ans;\\n        return ans/minneg;\\n\\n\\n\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3913006,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int neg = 0;\\n        \\n        for(auto i : nums){\\n            if(i<0){\\n                neg++;\\n            }\\n        }\\n        int ineg = neg;\\n        long long int res = 1;\\n        for(int i = 0; i<nums.size(); ++i){\\n            if(nums[i]<0){\\n                if(neg>=2){\\n                    cout<<\"entered in 1\"<<endl;\\n                    cout<<\"neg \"<<neg<<endl;\\n                    res = res*nums[i];\\n                    cout<<\"res\"<<res<<endl;\\n                    i++;\\n                    res = res*nums[i];\\n                    cout<<\"res\"<<res<<endl;\\n                    neg-=2;\\n                    cout<<\"neg\"<<neg<<endl;\\n                }\\n            }\\n            else if(nums[i] == 0){\\n                cout<<\"entered in 2\";\\n                continue;\\n            }\\n            else{\\n                cout<<\"entered in 3\";\\n                res=res*nums[i];\\n            }\\n        }\\n        if(res == 1 and ineg<2){\\n            return nums[nums.size()-1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int neg = 0;\\n        \\n        for(auto i : nums){\\n            if(i<0){\\n                neg++;\\n            }\\n        }\\n        int ineg = neg;\\n        long long int res = 1;\\n        for(int i = 0; i<nums.size(); ++i){\\n            if(nums[i]<0){\\n                if(neg>=2){\\n                    cout<<\"entered in 1\"<<endl;\\n                    cout<<\"neg \"<<neg<<endl;\\n                    res = res*nums[i];\\n                    cout<<\"res\"<<res<<endl;\\n                    i++;\\n                    res = res*nums[i];\\n                    cout<<\"res\"<<res<<endl;\\n                    neg-=2;\\n                    cout<<\"neg\"<<neg<<endl;\\n                }\\n            }\\n            else if(nums[i] == 0){\\n                cout<<\"entered in 2\";\\n                continue;\\n            }\\n            else{\\n                cout<<\"entered in 3\";\\n                res=res*nums[i];\\n            }\\n        }\\n        if(res == 1 and ineg<2){\\n            return nums[nums.size()-1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3905907,
                "title": "python-heap-solution-beats-87",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        if len(nums) == 1: return nums[0]\\n\\n        minHeap, maxHeap, non_zero_count, product = [], [], 0, 0\\n\\n        for number in nums:\\n            if number > 0: heapq.heappush(minHeap, number)\\n            else:\\n                if number != 0: \\n                    heapq.heappush(maxHeap, number)\\n                    non_zero_count += 1\\n                    product = 1 if non_zero_count >= 2 else 0\\n\\n        if len(maxHeap)%2 == 0:\\n            while maxHeap: product *= heapq.heappop(maxHeap)\\n        else:\\n            while len(maxHeap) != 1: product *= heapq.heappop(maxHeap)\\n\\n        if product == 0:\\n            if len(minHeap) > 0: \\n                product = 1 \\n            else:\\n                return 0\\n\\n        while minHeap: product *= heapq.heappop(minHeap)\\n        \\n        return abs(product)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        if len(nums) == 1: return nums[0]\\n\\n        minHeap, maxHeap, non_zero_count, product = [], [], 0, 0\\n\\n        for number in nums:\\n            if number > 0: heapq.heappush(minHeap, number)\\n            else:\\n                if number != 0: \\n                    heapq.heappush(maxHeap, number)\\n                    non_zero_count += 1\\n                    product = 1 if non_zero_count >= 2 else 0\\n\\n        if len(maxHeap)%2 == 0:\\n            while maxHeap: product *= heapq.heappop(maxHeap)\\n        else:\\n            while len(maxHeap) != 1: product *= heapq.heappop(maxHeap)\\n\\n        if product == 0:\\n            if len(minHeap) > 0: \\n                product = 1 \\n            else:\\n                return 0\\n\\n        while minHeap: product *= heapq.heappop(minHeap)\\n        \\n        return abs(product)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900360,
                "title": "java-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        if(nums.length==1) return nums[0];\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long prod = 1;\\n        boolean used = false;\\n        for(int i=nums.length-1;i>=0;i--){\\n            if (nums[i]<=0) break;\\n            used = true;\\n            prod*=nums[i];\\n            }\\n        if(!used) prod = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>=0) break;\\n            if(prod==0){\\n                if(i+1<n && nums[i+1]<0){\\n                    prod = nums[i]*nums[i+1];\\n                    i++;\\n                } \\n            }\\n            else{\\n\\n                if(i+1<n && nums[i+1]<0) {\\n                    int mul = nums[i]*nums[i+1];\\n                    prod*=mul;\\n                    i++;\\n                }\\n                \\n            }\\n        }\\n        return prod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        if(nums.length==1) return nums[0];\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        long prod = 1;\\n        boolean used = false;\\n        for(int i=nums.length-1;i>=0;i--){\\n            if (nums[i]<=0) break;\\n            used = true;\\n            prod*=nums[i];\\n            }\\n        if(!used) prod = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>=0) break;\\n            if(prod==0){\\n                if(i+1<n && nums[i+1]<0){\\n                    prod = nums[i]*nums[i+1];\\n                    i++;\\n                } \\n            }\\n            else{\\n\\n                if(i+1<n && nums[i+1]<0) {\\n                    int mul = nums[i]*nums[i+1];\\n                    prod*=mul;\\n                    i++;\\n                }\\n                \\n            }\\n        }\\n        return prod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895600,
                "title": "c-very-simple-and-easy-to-understand-pick-not-pick",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    long long solve(int indx, long long mult,int flag, vector<int>&nums, int n){\\n        \\n        \\n        if(indx>=n){\\n            if(flag==0){\\n                return mult=-1e9;\\n            }\\n            \\n            return mult;\\n        }\\n        \\n        long long m=solve(indx+1,mult,flag,nums,n);\\n        mult=mult*nums[indx];\\n        long long k=solve(indx+1,mult,flag+1,nums,n);\\n        \\n        return max(m,k);\\n       \\n    }\\n    long long maxStrength(vector<int>& nums) {\\n        \\n        long long mult=1;\\n        return solve(0,mult,0,nums,nums.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long solve(int indx, long long mult,int flag, vector<int>&nums, int n){\\n        \\n        \\n        if(indx>=n){\\n            if(flag==0){\\n                return mult=-1e9;\\n            }\\n            \\n            return mult;\\n        }\\n        \\n        long long m=solve(indx+1,mult,flag,nums,n);\\n        mult=mult*nums[indx];\\n        long long k=solve(indx+1,mult,flag+1,nums,n);\\n        \\n        return max(m,k);\\n       \\n    }\\n    long long maxStrength(vector<int>& nums) {\\n        \\n        long long mult=1;\\n        return solve(0,mult,0,nums,nums.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891038,
                "title": "maximum-strength-of-a-group",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        pn=[]\\n        nn=[]\\n        z=[]\\n        for u in nums:\\n            if u>0:\\n                pn.append(u)\\n            elif u<0:\\n                nn.append(u)\\n            else:\\n                z.append(u)\\n        if len(pn)==0 and len(z)>0 and len(nn)==1:\\n            return 0\\n        elif len(pn)==0 and len(z)==0 and len(nn)==1:\\n            return nn[0]\\n        elif len(pn)==0 and len(z)>0 and len(nn)==0:\\n            return 0\\n        f=1\\n        for i in pn:\\n            f=f*i\\n        print(f)\\n        nn.sort()\\n        print(nn)\\n        if len(nn)%2==0:\\n            for i in nn:\\n                f=f*i\\n        \\n        else:\\n            for i in range(len(nn)-1):\\n                f=f*nn[i]\\n        return f\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        pn=[]\\n        nn=[]\\n        z=[]\\n        for u in nums:\\n            if u>0:\\n                pn.append(u)\\n            elif u<0:\\n                nn.append(u)\\n            else:\\n                z.append(u)\\n        if len(pn)==0 and len(z)>0 and len(nn)==1:\\n            return 0\\n        elif len(pn)==0 and len(z)==0 and len(nn)==1:\\n            return nn[0]\\n        elif len(pn)==0 and len(z)>0 and len(nn)==0:\\n            return 0\\n        f=1\\n        for i in pn:\\n            f=f*i\\n        print(f)\\n        nn.sort()\\n        print(nn)\\n        if len(nn)%2==0:\\n            for i in nn:\\n                f=f*i\\n        \\n        else:\\n            for i in range(len(nn)-1):\\n                f=f*nn[i]\\n        return f\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887236,
                "title": "python-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        cur_max=float(\\'-inf\\')\\n        def backt(i,cur):\\n            nonlocal cur_max\\n            #Base case\\n            if i == len(nums):\\n                if cur> cur_max:\\n                    cur_max=cur\\n                return\\n\\n            #Handling edge cases\\n            if len(nums) == 1:\\n                cur_max=nums[0]\\n                return\\n\\n            #Handling edge cases\\n            #Eg [0,0]\\n            if nums.count(0) == len(nums):\\n                cur_max=0\\n                return\\n            #Handling edge cases\\n            #eg [0,-3,0]\\n            if nums.count(0)==len(nums)-1 and sum(nums) < 0:\\n                cur_max=0\\n                return\\n\\n            backt(i+1,cur*nums[i])\\n            #Backtracking\\n            backt(i+1,cur)\\n\\n  \\n        backt(0,1)\\n        \\n        return cur_max",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        cur_max=float(\\'-inf\\')\\n        def backt(i,cur):\\n            nonlocal cur_max\\n            #Base case\\n            if i == len(nums):\\n                if cur> cur_max:\\n                    cur_max=cur\\n                return\\n\\n            #Handling edge cases\\n            if len(nums) == 1:\\n                cur_max=nums[0]\\n                return\\n\\n            #Handling edge cases\\n            #Eg [0,0]\\n            if nums.count(0) == len(nums):\\n                cur_max=0\\n                return\\n            #Handling edge cases\\n            #eg [0,-3,0]\\n            if nums.count(0)==len(nums)-1 and sum(nums) < 0:\\n                cur_max=0\\n                return\\n\\n            backt(i+1,cur*nums[i])\\n            #Backtracking\\n            backt(i+1,cur)\\n\\n  \\n        backt(0,1)\\n        \\n        return cur_max",
                "codeTag": "Java"
            },
            {
                "id": 3885525,
                "title": "90-40",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        long long ans=1;\\n        vector<int>neg;\\n        int z=0;\\n        int check=0;\\n        for(auto k:nums)\\n        {\\n            if(k>0){ans*=(long long)k;check++;}\\n            else if(k<0)neg.push_back(k);\\n            else z=1;\\n        }\\n       \\n        sort(neg.begin(),neg.end());\\n        int n=neg.size();\\n        if(check==0)\\n        {\\n            if(n<=1&&z==1)return 0;\\n        }\\n        \\n        \\n       if(n%2)\\n       {\\n           for(int i=0;i<n-1;i++)\\n           {\\n               ans*=(long long)neg[i];\\n           }\\n       }\\n       else\\n       {\\n           for(auto k:neg)\\n           {\\n               ans*=(long long)k;\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        long long ans=1;\\n        vector<int>neg;\\n        int z=0;\\n        int check=0;\\n        for(auto k:nums)\\n        {\\n            if(k>0){ans*=(long long)k;check++;}\\n            else if(k<0)neg.push_back(k);\\n            else z=1;\\n        }\\n       \\n        sort(neg.begin(),neg.end());\\n        int n=neg.size();\\n        if(check==0)\\n        {\\n            if(n<=1&&z==1)return 0;\\n        }\\n        \\n        \\n       if(n%2)\\n       {\\n           for(int i=0;i<n-1;i++)\\n           {\\n               ans*=(long long)neg[i];\\n           }\\n       }\\n       else\\n       {\\n           for(auto k:neg)\\n           {\\n               ans*=(long long)k;\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869508,
                "title": "c-solution-using-a-multiset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, find numbers less than zero and avoid numbers equal to zero when calculating the product. Calculate the total and the number of zeros. If the number of zeros is equal to the number of \\'nums\\' return zero. If a zero found return maximum between the largest number and the total else return just the total. Before that make sure to divide by the largest negative number.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        if(nums.size() == 1) return nums[0];\\n        if(nums.size() == 2) return max(max(nums[0],nums[1]), nums[0]*nums[1]);\\n        multiset<int> ltzero;\\n        long long total = 1;\\n        int zeros = 0;\\n        int mx = INT_MIN;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            mx = max(mx, nums[i]);\\n            if(nums[i] != 0)\\n                total*= nums[i];\\n            else\\n                zeros++;\\n            if(nums[i] < 0)\\n            {\\n                ltzero.insert(-nums[i]);\\n            }\\n        }\\n        if( ltzero.size()%2==1 \\n            && total != -*ltzero.begin()\\n        ){\\n            total/= -*ltzero.begin();\\n        }\\n        if(zeros == nums.size()) return 0;\\n        return zeros > 0? max(total,(long long)mx) : total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        if(nums.size() == 1) return nums[0];\\n        if(nums.size() == 2) return max(max(nums[0],nums[1]), nums[0]*nums[1]);\\n        multiset<int> ltzero;\\n        long long total = 1;\\n        int zeros = 0;\\n        int mx = INT_MIN;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            mx = max(mx, nums[i]);\\n            if(nums[i] != 0)\\n                total*= nums[i];\\n            else\\n                zeros++;\\n            if(nums[i] < 0)\\n            {\\n                ltzero.insert(-nums[i]);\\n            }\\n        }\\n        if( ltzero.size()%2==1 \\n            && total != -*ltzero.begin()\\n        ){\\n            total/= -*ltzero.begin();\\n        }\\n        if(zeros == nums.size()) return 0;\\n        return zeros > 0? max(total,(long long)mx) : total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858002,
                "title": "java-simple-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        if(nums.length == 1) return nums[0];\\n        Arrays.sort(nums);\\n        long res = 0;\\n        boolean lamp = false;\\n        for(int i = 0; i < nums.length && nums[i] < 0; i++){\\n            if(lamp) res = (res == 0 ? 1 : res) * (nums[i] * nums[i - 1]);\\n            lamp = !lamp;\\n        }\\n        for(int i = nums.length - 1; i >= 0 && nums[i] > 0; i--){\\n            if(res == 0) res = 1;\\n            res *= nums[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        if(nums.length == 1) return nums[0];\\n        Arrays.sort(nums);\\n        long res = 0;\\n        boolean lamp = false;\\n        for(int i = 0; i < nums.length && nums[i] < 0; i++){\\n            if(lamp) res = (res == 0 ? 1 : res) * (nums[i] * nums[i - 1]);\\n            lamp = !lamp;\\n        }\\n        for(int i = nums.length - 1; i >= 0 && nums[i] > 0; i--){\\n            if(res == 0) res = 1;\\n            res *= nums[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835083,
                "title": "c-0ms-beats-100-o-n",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        if(nums.size() == 1) return nums[0];\\n        int n = nums.size(), maxx =INT_MIN, minn = INT_MIN, count =0;\\n        long long pro = 1;\\n        for(int i =0; i<n; i++){\\n            if(nums[i]) pro *= nums[i]; // if nums[i] is not zero, then use it for product\\n            maxx = max(maxx, nums[i]);\\n            if(nums[i]<0){\\n                minn = max(minn, nums[i]); // max in negative numbers\\n                count++; // counting number of negatives in order to make product positive \\n            }\\n        }\\n        if(maxx == 0 && count <=1) return 0; // corner case\\n        if(count &1) return (pro/minn); // if negative element, then return it by dividing by maximum negative number\\n        return pro;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        if(nums.size() == 1) return nums[0];\\n        int n = nums.size(), maxx =INT_MIN, minn = INT_MIN, count =0;\\n        long long pro = 1;\\n        for(int i =0; i<n; i++){\\n            if(nums[i]) pro *= nums[i]; // if nums[i] is not zero, then use it for product\\n            maxx = max(maxx, nums[i]);\\n            if(nums[i]<0){\\n                minn = max(minn, nums[i]); // max in negative numbers\\n                count++; // counting number of negatives in order to make product positive \\n            }\\n        }\\n        if(maxx == 0 && count <=1) return 0; // corner case\\n        if(count &1) return (pro/minn); // if negative element, then return it by dividing by maximum negative number\\n        return pro;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827818,
                "title": "golang-o-n-0ms-rule-based",
                "content": "```\\nfunc maxStrength(nums []int) int64 {\\n    neg := int64(0)\\n    pos := int64(0)\\n    zc := 0\\n    nc := 0\\n    maxNeg := -1000000\\n    for _, n := range nums {\\n        if n < 0 {\\n            if n > maxNeg {\\n                maxNeg = n\\n            }\\n            if neg == 0{\\n                neg = 1\\n            }\\n            nc++\\n            neg *= int64(n)\\n            continue\\n        }\\n        if n > 0 {\\n            if pos == 0{\\n                pos = 1\\n            }\\n            pos *= int64(n)\\n            continue\\n        }\\n        zc++\\n    }\\n    \\n    if pos == 0 && neg == 0 {\\n        return 0\\n    }\\n    \\n    if pos == 0 {\\n        if neg > 0 {\\n            return neg\\n        }\\n        if neg < 0 {\\n            if nc == 1 {\\n                if zc != 0 {\\n                    return 0\\n                }\\n                return neg\\n            }\\n            return neg/int64(maxNeg)\\n        }\\n    }\\n    \\n    if neg > 0 {\\n        return pos*neg\\n    }\\n    \\n    if neg == 0 {\\n        return pos\\n    }\\n    \\n    return pos*(neg/int64(maxNeg))\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc maxStrength(nums []int) int64 {\\n    neg := int64(0)\\n    pos := int64(0)\\n    zc := 0\\n    nc := 0\\n    maxNeg := -1000000\\n    for _, n := range nums {\\n        if n < 0 {\\n            if n > maxNeg {\\n                maxNeg = n\\n            }\\n            if neg == 0{\\n                neg = 1\\n            }\\n            nc++\\n            neg *= int64(n)\\n            continue\\n        }\\n        if n > 0 {\\n            if pos == 0{\\n                pos = 1\\n            }\\n            pos *= int64(n)\\n            continue\\n        }\\n        zc++\\n    }\\n    \\n    if pos == 0 && neg == 0 {\\n        return 0\\n    }\\n    \\n    if pos == 0 {\\n        if neg > 0 {\\n            return neg\\n        }\\n        if neg < 0 {\\n            if nc == 1 {\\n                if zc != 0 {\\n                    return 0\\n                }\\n                return neg\\n            }\\n            return neg/int64(maxNeg)\\n        }\\n    }\\n    \\n    if neg > 0 {\\n        return pos*neg\\n    }\\n    \\n    if neg == 0 {\\n        return pos\\n    }\\n    \\n    return pos*(neg/int64(maxNeg))\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3823746,
                "title": "c-simple-solution-beats-100",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MaxStrength(int[] nums) {\\n        long result = 1;\\n        \\n        List<int> pos = new();\\n        List<int> neg = new();\\n\\n        for(int i = 0; i < nums.Length; i++){\\n            if(nums[i] > 0){\\n                pos.Add(nums[i]);\\n            }else if(nums[i] < 0){\\n                neg.Add(nums[i]);\\n            } \\n        }\\n        \\n        neg = neg.OrderBy(n => n).ToList();\\n        for(int i = 0; i < pos.Count; i++){\\n            result *= pos[i];\\n        }\\n\\n        for(int i = 0; i < neg.Count - 1; i = i + 2){\\n            result *= neg[i];\\n            result *= neg[i+1];\\n        }\\n\\n        if(result == 1 && pos.Count == 0 && neg.Count <= 1){\\n            if(nums.Length > 1 || (neg.Count == 0 && nums.Length > 0)){\\n                result = 0;\\n            } else {\\n                result = neg[0];\\n            }\\n        }\\n\\n        return result;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long MaxStrength(int[] nums) {\\n        long result = 1;\\n        \\n        List<int> pos = new();\\n        List<int> neg = new();\\n\\n        for(int i = 0; i < nums.Length; i++){\\n            if(nums[i] > 0){\\n                pos.Add(nums[i]);\\n            }else if(nums[i] < 0){\\n                neg.Add(nums[i]);\\n            } \\n        }\\n        \\n        neg = neg.OrderBy(n => n).ToList();\\n        for(int i = 0; i < pos.Count; i++){\\n            result *= pos[i];\\n        }\\n\\n        for(int i = 0; i < neg.Count - 1; i = i + 2){\\n            result *= neg[i];\\n            result *= neg[i+1];\\n        }\\n\\n        if(result == 1 && pos.Count == 0 && neg.Count <= 1){\\n            if(nums.Length > 1 || (neg.Count == 0 && nums.Length > 0)){\\n                result = 0;\\n            } else {\\n                result = neg[0];\\n            }\\n        }\\n\\n        return result;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819732,
                "title": "using-priority-queue-java-tc-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        int n = nums.length,i,count=0,zeros=0;\\n        long prod=1;\\n        boolean flag=false;\\n        if(n==1){\\n            return (long)nums[0];\\n        }\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\\n        for(i=0; i<n; i++){\\n            if(nums[i]==0){\\n                zeros++;\\n                continue;\\n            }\\n            if(nums[i]<0){\\n                pq.add(nums[i]);\\n                count++;\\n            }\\n            else{\\n                prod *= nums[i];\\n            }\\n            flag=true;\\n        }\\n        if(count==1 && zeros==(n-1)){\\n            return 0;\\n        }\\n        if(count%2==1){\\n            count--;\\n        }\\n        while(count!=0){\\n            prod *= (int)pq.remove();\\n            count--;\\n        }\\n        if(flag==true){\\n            return prod;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        int n = nums.length,i,count=0,zeros=0;\\n        long prod=1;\\n        boolean flag=false;\\n        if(n==1){\\n            return (long)nums[0];\\n        }\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\\n        for(i=0; i<n; i++){\\n            if(nums[i]==0){\\n                zeros++;\\n                continue;\\n            }\\n            if(nums[i]<0){\\n                pq.add(nums[i]);\\n                count++;\\n            }\\n            else{\\n                prod *= nums[i];\\n            }\\n            flag=true;\\n        }\\n        if(count==1 && zeros==(n-1)){\\n            return 0;\\n        }\\n        if(count%2==1){\\n            count--;\\n        }\\n        while(count!=0){\\n            prod *= (int)pq.remove();\\n            count--;\\n        }\\n        if(flag==true){\\n            return prod;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3815449,
                "title": "c-knapsack-0-1-with-corner-cases",
                "content": "```\\nclass Solution {\\n    long long strength(vector<int>& nums, long long current, int i, int N) {\\n        if(i == N) {\\n            return current;\\n        }\\n                               \\n        auto with_current = strength(nums, current * nums[i], i + 1, N);\\n        auto without_current = strength(nums, current, i + 1, N);\\n        \\n        return max(with_current, without_current);\\n    }\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        const int N = nums.size();\\n        if(N == 1)\\n            return nums[0];\\n        \\n        int nz = 0;\\n        int min_nz = INT_MAX;\\n        for(int i : nums) {\\n            if(i == 0) {\\n                nz++;\\n            } else\\n                min_nz = min(min_nz, i);\\n        }\\n        if(nz == N)\\n            return 0;\\n        if(nz == N - 1)\\n            return max(min_nz, 0);\\n        return strength(nums, 1LL, 0, N);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long long strength(vector<int>& nums, long long current, int i, int N) {\\n        if(i == N) {\\n            return current;\\n        }\\n                               \\n        auto with_current = strength(nums, current * nums[i], i + 1, N);\\n        auto without_current = strength(nums, current, i + 1, N);\\n        \\n        return max(with_current, without_current);\\n    }\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        const int N = nums.size();\\n        if(N == 1)\\n            return nums[0];\\n        \\n        int nz = 0;\\n        int min_nz = INT_MAX;\\n        for(int i : nums) {\\n            if(i == 0) {\\n                nz++;\\n            } else\\n                min_nz = min(min_nz, i);\\n        }\\n        if(nz == N)\\n            return 0;\\n        if(nz == N - 1)\\n            return max(min_nz, 0);\\n        return strength(nums, 1LL, 0, N);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810690,
                "title": "o-n-time-o-1-space-simplest-python-solution-simple-explanation",
                "content": "# Intuition\\nthe best solution for the arr nums[i:] where i must be included \\n\\nis either nums[i]\\nor \\n\\nnums[i]*maximum negative product in nums[i+1:] if nums[i] is negative \\n\\nor \\n\\nnums[i]*maximum positive product in nums[i+1:] if nums[i] is positive \\n\\n# Approach\\n\\nthe solution = max(best solution for nums[i:] index 0 <= i <= n)\\n\\nlet vals[2] =  an array of size of 2 whre index 1 denotes the maximum negative element seen upto now and another one denoting the maximum positive product seen upto now \\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n# Code\\n```\\nclass Solution:\\n    def maxStrength(self, nums) :\\n        n = len(nums)\\n        extrms = [nums[-1],nums[-1]]\\n        for i in range(n-2,-1,-1) :\\n        \\ttemp = [nums[i]*extrms[0],nums[i]*extrms[1],nums[i]]\\n        \\textrms[0] = min(temp + [extrms[0]])\\n        \\textrms[1] = max(temp + [extrms[1]])\\n        return extrms[1]\\n\\n# smaller code \\n\\nclass Solution: \\n    def maxStrength(self, nums) :\\n        n = len(nums)\\n        extrms = [nums[-1],nums[-1]]\\n        for i in range(n-2,-1,-1) :\\n        \\textrms[0],extrms[1] = sorted([nums[i]*extrms[0],nums[i]*extrms[1],nums[i]]+ extrms)[0::4]\\n        return extrms[1]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxStrength(self, nums) :\\n        n = len(nums)\\n        extrms = [nums[-1],nums[-1]]\\n        for i in range(n-2,-1,-1) :\\n        \\ttemp = [nums[i]*extrms[0],nums[i]*extrms[1],nums[i]]\\n        \\textrms[0] = min(temp + [extrms[0]])\\n        \\textrms[1] = max(temp + [extrms[1]])\\n        return extrms[1]\\n\\n# smaller code \\n\\nclass Solution: \\n    def maxStrength(self, nums) :\\n        n = len(nums)\\n        extrms = [nums[-1],nums[-1]]\\n        for i in range(n-2,-1,-1) :\\n        \\textrms[0],extrms[1] = sorted([nums[i]*extrms[0],nums[i]*extrms[1],nums[i]]+ extrms)[0::4]\\n        return extrms[1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804872,
                "title": "easy-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def check__eve(self, nums: List[int]) -> bool:\\n            if (len(nums))%2 == 0:\\n                return True\\n            else:\\n                return False\\n\\n    def multi(self, nums:List[int]) -> int:\\n        j = 1\\n        for i in nums:\\n            j = i*j\\n        return j\\n\\n    def maxStrength(self, nums: List[int]) -> int:\\n        data = {}\\n        num_zer = 0\\n\\n        if len(nums) == 1:\\n            return nums[0]\\n\\n        \"\"\"for i in nums:\\n            if i == 0:\\n                num_zer += 1\"\"\"\\n\\n        pos_items = [x for x in nums if x > 0]\\n        neg_items = [x for x in nums if x < 0]\\n        zer_items = num_zer + sum(1 for i in nums if i == 0)\\n\\n        pos_items.sort()\\n        neg_items.sort()\\n\\n        print(neg_items)\\n        print(len(neg_items))\\n        print(zer_items)\\n\\n        \\n        if((len(pos_items) == 0) and zer_items !=0):\\n            if ((len(neg_items) != 0) and self.check__eve(neg_items) == True):\\n                return (self.multi(neg_items))\\n            elif ((len(neg_items) <= 1) ):\\n                return 0\\n            else:\\n                neg_items.pop(-1)\\n                return (self.multi(neg_items))\\n        if self.check__eve(neg_items) == True:\\n            a = self.multi(neg_items)\\n            b = self.multi(pos_items)\\n            return a*b\\n        elif self.check__eve(neg_items) == False:\\n            neg_items.pop(-1)\\n            a = self.multi(neg_items)\\n            b = self.multi(pos_items)\\n            return a*b\\n\\n\\n\\n        return 0 \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def check__eve(self, nums: List[int]) -> bool:\\n            if (len(nums))%2 == 0:\\n                return True\\n            else:\\n                return False\\n\\n    def multi(self, nums:List[int]) -> int:\\n        j = 1\\n        for i in nums:\\n            j = i*j\\n        return j\\n\\n    def maxStrength(self, nums: List[int]) -> int:\\n        data = {}\\n        num_zer = 0\\n\\n        if len(nums) == 1:\\n            return nums[0]\\n\\n        \"\"\"for i in nums:\\n            if i == 0:\\n                num_zer += 1\"\"\"\\n\\n        pos_items = [x for x in nums if x > 0]\\n        neg_items = [x for x in nums if x < 0]\\n        zer_items = num_zer + sum(1 for i in nums if i == 0)\\n\\n        pos_items.sort()\\n        neg_items.sort()\\n\\n        print(neg_items)\\n        print(len(neg_items))\\n        print(zer_items)\\n\\n        \\n        if((len(pos_items) == 0) and zer_items !=0):\\n            if ((len(neg_items) != 0) and self.check__eve(neg_items) == True):\\n                return (self.multi(neg_items))\\n            elif ((len(neg_items) <= 1) ):\\n                return 0\\n            else:\\n                neg_items.pop(-1)\\n                return (self.multi(neg_items))\\n        if self.check__eve(neg_items) == True:\\n            a = self.multi(neg_items)\\n            b = self.multi(pos_items)\\n            return a*b\\n        elif self.check__eve(neg_items) == False:\\n            neg_items.pop(-1)\\n            a = self.multi(neg_items)\\n            b = self.multi(pos_items)\\n            return a*b\\n\\n\\n\\n        return 0 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799006,
                "title": "python-dfs-7loc-simple-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nat each pos, we can take or not take.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        def dfs(i, p):\\n            if i >= len(nums):\\n                return\\n            yield p * nums[i]\\n            yield from dfs(i + 1, p) # not take\\n            yield from dfs(i + 1, p * nums[i]) # take\\n        return max(dfs(0,1))\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        def dfs(i, p):\\n            if i >= len(nums):\\n                return\\n            yield p * nums[i]\\n            yield from dfs(i + 1, p) # not take\\n            yield from dfs(i + 1, p * nums[i]) # take\\n        return max(dfs(0,1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793371,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    O(n*long(n))\\n\\n- Space complexity:\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        if(nums.length == 1) {\\n            return (long)nums[0];\\n        }\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        long ans = 1;\\n        boolean flag = false;\\n        for(int i=0;i<nums.length;i++) {\\n            if(nums[i] < 0) {\\n                pq.add(nums[i]);\\n            } else if(nums[i] > 0) {\\n                ans = ans * (long)nums[i];\\n                flag = true;\\n            }\\n        }\\n        while(pq.size() >= 2) {\\n            int num1 = pq.remove();\\n            int num2 = pq.remove();\\n            flag = true;\\n            ans = ans * (long)num1 * (long)num2;\\n        }\\n        if(flag == false) return 0;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        if(nums.length == 1) {\\n            return (long)nums[0];\\n        }\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        long ans = 1;\\n        boolean flag = false;\\n        for(int i=0;i<nums.length;i++) {\\n            if(nums[i] < 0) {\\n                pq.add(nums[i]);\\n            } else if(nums[i] > 0) {\\n                ans = ans * (long)nums[i];\\n                flag = true;\\n            }\\n        }\\n        while(pq.size() >= 2) {\\n            int num1 = pq.remove();\\n            int num2 = pq.remove();\\n            flag = true;\\n            ans = ans * (long)num1 * (long)num2;\\n        }\\n        if(flag == false) return 0;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784259,
                "title": "simple-greedy-solution-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long maxStrength(vector<int>& nums) {\\n        int p=0;\\n        int n=0;\\n        int z=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0)p=p+1;\\n            else if(nums[i]<0)n=n+1;\\n            else if(nums[i]==0)z=z+1;\\n        }\\n        if(p==0 && n==0 && z!=0)return 0;\\n        else if(n==1 && p==0 && z!=0)return 0;\\n        else if(n==1 && p==0 && z==0)return nums[0];\\n        long long ans=1;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0)ans=ans*nums[i];\\n        }\\n        if(ans>0)return ans;\\n        sort(nums.begin(),nums.end());\\n        int divide=nums[0];\\n        for(int i=0;i<nums.size();i++){\\n            if(divide<nums[i] && divide<0 && nums[i]<0)divide=nums[i];\\n        }\\n        ans=ans/divide;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long maxStrength(vector<int>& nums) {\\n        int p=0;\\n        int n=0;\\n        int z=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0)p=p+1;\\n            else if(nums[i]<0)n=n+1;\\n            else if(nums[i]==0)z=z+1;\\n        }\\n        if(p==0 && n==0 && z!=0)return 0;\\n        else if(n==1 && p==0 && z!=0)return 0;\\n        else if(n==1 && p==0 && z==0)return nums[0];\\n        long long ans=1;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=0)ans=ans*nums[i];\\n        }\\n        if(ans>0)return ans;\\n        sort(nums.begin(),nums.end());\\n        int divide=nums[0];\\n        for(int i=0;i<nums.size();i++){\\n            if(divide<nums[i] && divide<0 && nums[i]<0)divide=nums[i];\\n        }\\n        ans=ans/divide;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782374,
                "title": "c-short-1-pass-with-explanation-time-o-n-space-o-1",
                "content": "# Intuition\\nCalculate the product of the non-negative elementss in the array. Then we can have 3 possible outcomes:\\n\\n1) All elements in the array = 0 => return 0\\n2) The product is positive => return the product \\n3) The product is negative: \\n- More than 1 element added => divide the product by the max negative element, thus making the result positive and minimally reducing it\\n- 1 element added => return it or 0 if there\\'s any zero elements in the array\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) \\n    {\\n        size_t nonZeroElemsNum{ 0 };\\n        long long maxNeg{ -10 };\\n        long long res{ 1 };\\n\\n        for (long long i : nums)\\n        {\\n            if (i == 0) continue;\\n\\n            ++nonZeroElemsNum;\\n            res *= i;\\n            if (i < 0)\\n                maxNeg = std::max(maxNeg, i);\\n        }\\n\\n        if (nonZeroElemsNum == 0)\\n            res = 0;\\n        else if (res < 0 && nums.size() > 1)\\n            res = nonZeroElemsNum > 1? res/maxNeg : 0;\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) \\n    {\\n        size_t nonZeroElemsNum{ 0 };\\n        long long maxNeg{ -10 };\\n        long long res{ 1 };\\n\\n        for (long long i : nums)\\n        {\\n            if (i == 0) continue;\\n\\n            ++nonZeroElemsNum;\\n            res *= i;\\n            if (i < 0)\\n                maxNeg = std::max(maxNeg, i);\\n        }\\n\\n        if (nonZeroElemsNum == 0)\\n            res = 0;\\n        else if (res < 0 && nums.size() > 1)\\n            res = nonZeroElemsNum > 1? res/maxNeg : 0;\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782107,
                "title": "dp-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf max product of arr [0..i] => Max (max(arr[0..i-1])*arr[i] , min(arr[0..i-1])*arr[i] , arr[i] , max(arr[0..i-1]) )\\n\\nIf min product of arr[0..i] => Min (max(arr[0..i-1])*arr[i] , min(arr[0..i-1])*arr[i] , arr[i] , min(arr[0..i-1]))\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nmax = Max( max*arr[i] , min*arr[i], arr[i], max)\\nmin = Min( max*arr[i] , min*arr[i], arr[i], min)\\n\\n\\nThe above covers cases like [-1,0,1,-8] =>\\nStep 1 : max = -1, min = -1\\nStep 2 : max = Max( -1*0 , -1*0 , 0, -1 ) = 0\\n        min = Min( -1*0 , -1*0 , 0, -1 ) = -1\\nStep 3 : max = Max(0*1, -1*1 , 1, 0) = 1\\n        min = Min(0*1, -1*1 , 1, -1) = -1\\nStep 4 : max = Max(1*-8, -1*-8 , -8, 1) = 8\\n        min = Min(1*-8, -1*-8 , -8, -1) = -8\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        int n = nums.length;\\n\\n        //Sort the array\\n        //Arrays.sort(nums);\\n\\n        \\n\\n        if(n==1){\\n            return nums[0];\\n        }\\n\\n        long maxTillNow = nums[0];\\n\\n        long minTillNow = nums[0];\\n\\n        //System.out.println(0 + \"\\\\t\" + maxTillNow + \"\\\\t\" + minTillNow);\\n\\n        for(int i=1;i<n;i++){\\n            long max = maxTillNow;\\n            long min = minTillNow;\\n            minTillNow = Math.min(Math.min(max*nums[i],min*nums[i]),Math.min(nums[i],min));\\n            maxTillNow = Math.max(Math.max(max*nums[i],min*nums[i]),Math.max(nums[i],max));\\n            //System.out.println(i + \"\\\\t\" + maxTillNow + \"\\\\t\" + minTillNow);\\n        }\\n\\n        return maxTillNow;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        int n = nums.length;\\n\\n        //Sort the array\\n        //Arrays.sort(nums);\\n\\n        \\n\\n        if(n==1){\\n            return nums[0];\\n        }\\n\\n        long maxTillNow = nums[0];\\n\\n        long minTillNow = nums[0];\\n\\n        //System.out.println(0 + \"\\\\t\" + maxTillNow + \"\\\\t\" + minTillNow);\\n\\n        for(int i=1;i<n;i++){\\n            long max = maxTillNow;\\n            long min = minTillNow;\\n            minTillNow = Math.min(Math.min(max*nums[i],min*nums[i]),Math.min(nums[i],min));\\n            maxTillNow = Math.max(Math.max(max*nums[i],min*nums[i]),Math.max(nums[i],max));\\n            //System.out.println(i + \"\\\\t\" + maxTillNow + \"\\\\t\" + minTillNow);\\n        }\\n\\n        return maxTillNow;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781412,
                "title": "python3-o-n-time-and-o-1-space-simple-direct-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        max_neg = float(\\'-inf\\')\\n        strength = 1\\n        neg = 0\\n        pos = 0\\n        zeroes = 0\\n        n = len(nums)\\n\\n        if len(nums) == 0:\\n            return 0\\n        if len(nums) == 1:\\n            return nums[0]\\n\\n        for i in nums:\\n            if i != 0:\\n                strength *= i\\n\\n            if i < 0:\\n                neg += 1\\n                max_neg = max(i, max_neg)\\n            elif i > 0:\\n                pos +=1\\n            else:\\n                zeroes +=1\\n\\n        # if no positives and single negative and multiple zeroes\\n        if pos == 0 and neg == 1 and zeroes > 0:\\n            return 0\\n\\n        # if all zeroes\\n        if n == zeroes:\\n            return 0\\n\\n        # odd number of negative numbers, then make it pos \\n        if neg % 2 == 1:\\n            strength /= max_neg\\n\\n        return int(strength)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        max_neg = float(\\'-inf\\')\\n        strength = 1\\n        neg = 0\\n        pos = 0\\n        zeroes = 0\\n        n = len(nums)\\n\\n        if len(nums) == 0:\\n            return 0\\n        if len(nums) == 1:\\n            return nums[0]\\n\\n        for i in nums:\\n            if i != 0:\\n                strength *= i\\n\\n            if i < 0:\\n                neg += 1\\n                max_neg = max(i, max_neg)\\n            elif i > 0:\\n                pos +=1\\n            else:\\n                zeroes +=1\\n\\n        # if no positives and single negative and multiple zeroes\\n        if pos == 0 and neg == 1 and zeroes > 0:\\n            return 0\\n\\n        # if all zeroes\\n        if n == zeroes:\\n            return 0\\n\\n        # odd number of negative numbers, then make it pos \\n        if neg % 2 == 1:\\n            strength /= max_neg\\n\\n        return int(strength)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775819,
                "title": "dart-specially-treat-negative-values",
                "content": "# Special cases\\n\\n* The `nums` has only one number. We will have to take it as the answer.\\n* There is no positive number, nor any pair of negative numbers. That means the maximum value is `0`;\\n\\n# Code\\n```\\nclass Solution {\\n  int maxStrength(List<int> nums) {\\n    if (nums.length == 1) return nums[0];\\n    bool haspositive = false;\\n    final List<int> negs = [];\\n    var res = 1;\\n    for (final v in nums) {\\n      if (v > 0) {\\n        haspositive = true;\\n        res *= v;\\n      } else if (v < 0) {\\n        negs.add(v);\\n      }\\n    }\\n    negs.sort();\\n    if (negs.length % 2 == 1)\\n      negs.removeLast();\\n    for (final v in negs)\\n      res *= v;\\n\\n    if (negs.isEmpty && haspositive == false)\\n      return 0;\\n\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int maxStrength(List<int> nums) {\\n    if (nums.length == 1) return nums[0];\\n    bool haspositive = false;\\n    final List<int> negs = [];\\n    var res = 1;\\n    for (final v in nums) {\\n      if (v > 0) {\\n        haspositive = true;\\n        res *= v;\\n      } else if (v < 0) {\\n        negs.add(v);\\n      }\\n    }\\n    negs.sort();\\n    if (negs.length % 2 == 1)\\n      negs.removeLast();\\n    for (final v in negs)\\n      res *= v;\\n\\n    if (negs.isEmpty && haspositive == false)\\n      return 0;\\n\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771634,
                "title": "best-solution-complete-explanation-with-example-o-n-time-o-1-space-100-beats",
                "content": "# Intuition\\nIf we talk about the problem statement we have to find the maximum strength of group that teacher can form and the strength of group is given by the product of marks of each student of the group i.e, if 3  students having marks 2,4,6 are present in the group then the strength will be equal to 48.\\n\\nSo the main idea is to find a subsequence of the given array whose product is maximum among all.\\n\\n# Approach\\n- If there is **no negative element** present in the array then we simply return the product of whole array and while computing the product of whole array we have to **avoid the product with zero** otherwise the whole product will be zero.\\n\\n- Now let\\'s say some negative numbers are also present in the array. If **frequency of negative elements in the array is even** the we again return the whole product because the product of even number of negative numbers gives a positive result.\\n\\n- If the **frequency of negative numbers is odd** then we will leave one negative number to keep the result positve and that negative number should be maximum in magnitude in order to maximise the product.\\n\\n- Let\\'s take a example for better understanding:\\n    - nums = [3,-1,-5,2,5,-9]\\n    - Here we can see the frequency of negative numbers is 3 i.e. -1,-5,-9. so we will take any two of negative numbers which give the result as positive. Notice we have to give the maximum value so  we  **will take -9 and -5 but exclude -1 because -9*-5 will give the maximum result**.\\n\\n- There is one edge case we have to handle seperatly :-\\n    - If there is no positve element present in the array and frequency of negative elements is less than 2 which means product cannot be positve then in that case if zero is present in the array then zero will be max prodcut since zero is greater than some negative value and if zero is not present then max negative value is the required answer.  \\n    - nums = [0, -1] => Here the max product can be 0.\\n    - nums = [-1] => Here max product can be -1.\\n\\n# Complexity\\n- Time complexity:\\n    -All computations are done within single for loop sso time complexity will be O(size of nums).\\n\\n- Space complexity:\\n    - No extra space is used so space complexity is O(1).\\n\\n# Code\\n## Java\\n```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        long strength = 1;\\n        int negative = 0, maxNegativeVal = Integer.MIN_VALUE;\\n        boolean flag = false, isZero = false;\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] == 0)  {\\n                isZero = true; \\n                continue;\\n            }\\n            if(nums[i] > 0) flag = true;\\n            strength *= nums[i];\\n            if(nums[i] < 0) {\\n                maxNegativeVal = Math.max(maxNegativeVal, nums[i]);\\n                negative += 1;\\n            }\\n        }\\n        if(maxNegativeVal >= 0) return strength;\\n        if(flag == false && negative < 2) return isZero ? 0 : maxNegativeVal;\\n        if(negative%2 == 1) strength /= maxNegativeVal;\\n        return strength;\\n    }\\n}\\n```\\n## CPP\\n```\\nclass Solution {\\npublic:\\n    long maxStrength(vector<int>& nums) {\\n        long strength = 1;\\n        int negative = 0, maxNegativeVal = numeric_limits<int>::min();\\n        bool flag = false, isZero = false;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] == 0)  {\\n                isZero = true; \\n                continue;\\n            }\\n            if(nums[i] > 0) flag = true;\\n            strength *= nums[i];\\n            if(nums[i] < 0) {\\n                maxNegativeVal = max(maxNegativeVal, nums[i]);\\n                negative += 1;\\n            }\\n        }\\n        if(maxNegativeVal >= 0) return strength;\\n        if(flag == false && negative < 2) return isZero ? 0 : maxNegativeVal;\\n        if(negative%2 == 1) strength /= maxNegativeVal;\\n        return strength;\\n    }\\n};\\n```\\n## Python\\n```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        strength = 1\\n        negative = 0\\n        maxNegativeVal = float(\\'-inf\\')\\n        flag = False\\n        isZero = False\\n        for i in range(len(nums)):\\n            if nums[i] == 0:\\n                isZero = True\\n                continue\\n            if nums[i] > 0:\\n                flag = True\\n            strength *= nums[i]\\n            if nums[i] < 0:\\n                maxNegativeVal = max(maxNegativeVal, nums[i])\\n                negative += 1\\n        if maxNegativeVal >= 0:\\n            return strength\\n        if flag == False and negative < 2:\\n            return 0 if isZero else maxNegativeVal\\n        if negative % 2 == 1:\\n            strength //= maxNegativeVal\\n        return strength\\n```\\n### Upvote if this was helpful.\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        long strength = 1;\\n        int negative = 0, maxNegativeVal = Integer.MIN_VALUE;\\n        boolean flag = false, isZero = false;\\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] == 0)  {\\n                isZero = true; \\n                continue;\\n            }\\n            if(nums[i] > 0) flag = true;\\n            strength *= nums[i];\\n            if(nums[i] < 0) {\\n                maxNegativeVal = Math.max(maxNegativeVal, nums[i]);\\n                negative += 1;\\n            }\\n        }\\n        if(maxNegativeVal >= 0) return strength;\\n        if(flag == false && negative < 2) return isZero ? 0 : maxNegativeVal;\\n        if(negative%2 == 1) strength /= maxNegativeVal;\\n        return strength;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    long maxStrength(vector<int>& nums) {\\n        long strength = 1;\\n        int negative = 0, maxNegativeVal = numeric_limits<int>::min();\\n        bool flag = false, isZero = false;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] == 0)  {\\n                isZero = true; \\n                continue;\\n            }\\n            if(nums[i] > 0) flag = true;\\n            strength *= nums[i];\\n            if(nums[i] < 0) {\\n                maxNegativeVal = max(maxNegativeVal, nums[i]);\\n                negative += 1;\\n            }\\n        }\\n        if(maxNegativeVal >= 0) return strength;\\n        if(flag == false && negative < 2) return isZero ? 0 : maxNegativeVal;\\n        if(negative%2 == 1) strength /= maxNegativeVal;\\n        return strength;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        strength = 1\\n        negative = 0\\n        maxNegativeVal = float(\\'-inf\\')\\n        flag = False\\n        isZero = False\\n        for i in range(len(nums)):\\n            if nums[i] == 0:\\n                isZero = True\\n                continue\\n            if nums[i] > 0:\\n                flag = True\\n            strength *= nums[i]\\n            if nums[i] < 0:\\n                maxNegativeVal = max(maxNegativeVal, nums[i])\\n                negative += 1\\n        if maxNegativeVal >= 0:\\n            return strength\\n        if flag == False and negative < 2:\\n            return 0 if isZero else maxNegativeVal\\n        if negative % 2 == 1:\\n            strength //= maxNegativeVal\\n        return strength\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770046,
                "title": "c-easy-sorting-based-greedy-approach-time-o-nlogn-space-o-n",
                "content": "# Intuition\\nIf numbers were all positives, then just multiplying will give the answer.\\nBut we have negative and 0 numbers also and two negative can also result in big number, So sorting it with taking care of absolute value can help.\\n\\nNow we just have to make sure that whenever we are considering a negative number in the result then there should be another negative number so that multiplication can become positive. \\n\\n# Complexity\\n- Time complexity: O( nlogn ) -- Sorting is O( nlogn )\\n\\n- Space complexity: O(1) : If we assume that sorting is inplace.\\n\\n# Code\\n```\\n// Comparator function to sort the input array\\n// [3,-1,-5,2,5,-9] ---> [-1, 2, 3, -5, 5, -9]\\nbool myComprator( int x, int y ) {\\n    return abs(x) < abs(y);\\n}\\n\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        // Sort the array using comparator.\\n        sort(nums.begin(), nums.end(), myComprator );\\n\\n        // Variable to store the max Strength of a Group\\n        long long max = INT_MIN;\\n        // Variable to store the current seen negative number.\\n        int negativeNum = 1;\\n\\n        // iterate from back because array is sorted in decending order\\n        for (int i = nums.size() -1; i >=0; i--) {\\n            // If current number is positive.\\n            if (nums[i] > 0 ) {\\n                if (max == INT_MIN) max = nums[i];\\n                else max *= nums[i];\\n            } else { // Current number is negatice or 0\\n                // If number is negative and previous negative is seen.\\n                if (negativeNum < 0 && nums[i] < 0 ) {\\n                    if (max == INT_MIN) max = nums[i] * negativeNum;\\n                    else max *= negativeNum * nums[i];\\n                    negativeNum = 1;\\n                } \\n                // If number is negative but no previous negative is seen\\n                else if (negativeNum > 0 && nums[i] < 0 ) {\\n                    negativeNum = nums[i];\\n\\n                } else {\\n                    // If number is zero\\n                    if (max == INT_MIN && nums[i] == 0) max = 0;\\n                }\\n            }\\n            // cout << nums[i] << \" \" << negativeNum << \" \" << max << endl;\\n        }\\n        // Corner case when there is a single number and is negaitve.\\n        if (max == INT_MIN && negativeNum < 0) return negativeNum;\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n// Comparator function to sort the input array\\n// [3,-1,-5,2,5,-9] ---> [-1, 2, 3, -5, 5, -9]\\nbool myComprator( int x, int y ) {\\n    return abs(x) < abs(y);\\n}\\n\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        // Sort the array using comparator.\\n        sort(nums.begin(), nums.end(), myComprator );\\n\\n        // Variable to store the max Strength of a Group\\n        long long max = INT_MIN;\\n        // Variable to store the current seen negative number.\\n        int negativeNum = 1;\\n\\n        // iterate from back because array is sorted in decending order\\n        for (int i = nums.size() -1; i >=0; i--) {\\n            // If current number is positive.\\n            if (nums[i] > 0 ) {\\n                if (max == INT_MIN) max = nums[i];\\n                else max *= nums[i];\\n            } else { // Current number is negatice or 0\\n                // If number is negative and previous negative is seen.\\n                if (negativeNum < 0 && nums[i] < 0 ) {\\n                    if (max == INT_MIN) max = nums[i] * negativeNum;\\n                    else max *= negativeNum * nums[i];\\n                    negativeNum = 1;\\n                } \\n                // If number is negative but no previous negative is seen\\n                else if (negativeNum > 0 && nums[i] < 0 ) {\\n                    negativeNum = nums[i];\\n\\n                } else {\\n                    // If number is zero\\n                    if (max == INT_MIN && nums[i] == 0) max = 0;\\n                }\\n            }\\n            // cout << nums[i] << \" \" << negativeNum << \" \" << max << endl;\\n        }\\n        // Corner case when there is a single number and is negaitve.\\n        if (max == INT_MIN && negativeNum < 0) return negativeNum;\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3740453,
                "title": "dry-run-fully-explained-i-bet-you-will-understand-beginner-friendly-c",
                "content": "# Intuition Try to carefully understand \\nCount the negative numbers and positive numbers and zeros in the given problem,Now \\nCase 1 : Suppose nums is (0,0,0,0,0,0) or (0,0,0,0) or(0,0) there is no negative and no positive number in our problem so we will return 0 beacause we have to choose atleast one zero.\\nCase 2 : If there present negative and positive number in our array suppose (-3,4,-7,5,0,-5,-4) then what will be our answer?\\nclearly our answer will mutilplication of all nonzero numbers that will be be -3 * 4 * -7 * 5 * -5 *-4=8400.\\nNow one again if our nums is (-3,4,7,5,0,-5,-4) then what will be our answer?\\nIf we multimply all the non zero numbers then our answer will be -3 *4 * 7 * 5 * -5 *-4=-8400.\\nThis is a huge negative number, and this is clearly not our answer beacause even if we take Index 4 as a group then answer will be 0 but -8400 is much negative.\\nSo right now what strike in your mind,that is the main point of this problem,thinks carefully 5 minute?\\nI think you got it,if the total number if negative number is even then we will return our answer but if the total number of negative number is even then  we have to exclude one negative number multiplication from our answer.\\nNow again in my example negative numbers are -3,-5,-4 see carefully which negative number will have least impact on our multiplication,We will already take mutliplication of all negative and postive so exclude means to divide\\nif we ignore -3 our answer will be-8400/-3=2800\\nif we ignore -4 our answer will be-8400/-4=2100\\nif we ignore -5 our answer will be-8400/-5=1680\\nwhat comes in your mind?\\nThe least abs negative number will exclude that means most biggest negative number we will exclude from our answer in this case -3 is the most biggest(IMP).\\nNow come to code you will very carefull understand the problem and happy coding .\\nTake care yourself and your beloved family\\nUpvote if you find this post helpfull\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach Greedy Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) \\n    {\\n        int negative_max=INT_MIN;\\n        //to get the minimum abs(value) of negative one\\n        long long ans=1;\\n        int negative=0,positive=0,zero=0;\\n        //Declaring variable for counting positive\\n        //negative and zero numbers\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                positive++;\\n                ans=ans*nums[i];\\n                //For sure if a number is positive we will take it\\n                //in our group\\n            }\\n            else if(nums[i]<0)\\n            {\\n                ans=ans*nums[i];\\n                /*\\n                We will also take the negative one into our \\n                multiplication but remember one thing that\\n                if total number of negative number is even\\n                then no problem but if it is odd like(-1,-2,-4)\\n                then we will take the -2 and -4 into consideration\\n                and we will ignore the -1 or in other word we will\\n                ignore the -1 or maximum of all negative number\\n                */\\n                negative_max=max(negative_max,nums[i]);\\n                //to get the maximum of all the negative number\\n                negative++;\\n            }\\n            else\\n            zero++;\\n        }\\n        if(positive==0 && negative==0)\\n        {\\n            //if no negative and positive number is present our ans will be zero\\n            return 0;\\n        }\\n        else if(positive==0)\\n        {\\n            //This is a important corner case\\n            if(negative%2)\\n            {\\n                if(negative!=1)\\n                {\\n                    /*\\n                if(number is like (-2,-4,-7) or (-8,-3,-4,-3,-1))\\n                here negative numbers are odd but not 1 we will \\n                return ans/maxnegative \\n                */\\n                    return ans/negative_max;\\n                }\\n                else\\n                {\\n                    if(zero==0)\\n                    {\\n                        //for case like [-6],[-7],[-2]\\n                        return ans;\\n                    }\\n                    else\\n                    {\\n                        //for cases like [0,-2,0,0],[0,-3],[0,-8,0,0]\\n                    }\\n                }\\n            }\\n            else \\n            return ans;\\n        }\\n        else if(negative%2)\\n        {\\n        //for cases like [2,-5,-4,-2],[4,5,3,-4]\\n        return ans/negative_max;\\n        }\\n        else\\n        {\\n            //for cases like [2,-3,-9],[2,4,6,7,-5,-6,-3,-2]\\n        return ans;\\n        }\\n        //Take care yourself and your Beloved family\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) \\n    {\\n        int negative_max=INT_MIN;\\n        //to get the minimum abs(value) of negative one\\n        long long ans=1;\\n        int negative=0,positive=0,zero=0;\\n        //Declaring variable for counting positive\\n        //negative and zero numbers\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                positive++;\\n                ans=ans*nums[i];\\n                //For sure if a number is positive we will take it\\n                //in our group\\n            }\\n            else if(nums[i]<0)\\n            {\\n                ans=ans*nums[i];\\n                /*\\n                We will also take the negative one into our \\n                multiplication but remember one thing that\\n                if total number of negative number is even\\n                then no problem but if it is odd like(-1,-2,-4)\\n                then we will take the -2 and -4 into consideration\\n                and we will ignore the -1 or in other word we will\\n                ignore the -1 or maximum of all negative number\\n                */\\n                negative_max=max(negative_max,nums[i]);\\n                //to get the maximum of all the negative number\\n                negative++;\\n            }\\n            else\\n            zero++;\\n        }\\n        if(positive==0 && negative==0)\\n        {\\n            //if no negative and positive number is present our ans will be zero\\n            return 0;\\n        }\\n        else if(positive==0)\\n        {\\n            //This is a important corner case\\n            if(negative%2)\\n            {\\n                if(negative!=1)\\n                {\\n                    /*\\n                if(number is like (-2,-4,-7) or (-8,-3,-4,-3,-1))\\n                here negative numbers are odd but not 1 we will \\n                return ans/maxnegative \\n                */\\n                    return ans/negative_max;\\n                }\\n                else\\n                {\\n                    if(zero==0)\\n                    {\\n                        //for case like [-6],[-7],[-2]\\n                        return ans;\\n                    }\\n                    else\\n                    {\\n                        //for cases like [0,-2,0,0],[0,-3],[0,-8,0,0]\\n                    }\\n                }\\n            }\\n            else \\n            return ans;\\n        }\\n        else if(negative%2)\\n        {\\n        //for cases like [2,-5,-4,-2],[4,5,3,-4]\\n        return ans/negative_max;\\n        }\\n        else\\n        {\\n            //for cases like [2,-3,-9],[2,4,6,7,-5,-6,-3,-2]\\n        return ans;\\n        }\\n        //Take care yourself and your Beloved family\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736673,
                "title": "beat-90-runtime",
                "content": "# Complexity\\n- Time complexity: O(nlogn)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n\\n    @staticmethod\\n    def maxStrength(nums):\\n        nums.sort()\\n        max_strength = 1\\n        atleast1found = False\\n\\n        if len(nums) == 1:\\n            return nums[0]\\n\\n        for i in range(0,len(nums),2):\\n            if i < len(nums) - 1:\\n                if nums[i] * nums[i+1] * max_strength >= max_strength:\\n                    max_strength *= nums[i] * nums[i+1]\\n                    atleast1found = True\\n                elif nums[i+1] * max_strength >= max_strength:\\n                    max_strength *= nums[i+1]\\n                    atleast1found = True\\n            else:\\n                if nums[i] * max_strength >= max_strength:\\n                    max_strength *= nums[i]\\n                    atleast1found = True\\n\\n        if not atleast1found:\\n            return max(nums)\\n        else:    \\n            return max_strength\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n\\n    @staticmethod\\n    def maxStrength(nums):\\n        nums.sort()\\n        max_strength = 1\\n        atleast1found = False\\n\\n        if len(nums) == 1:\\n            return nums[0]\\n\\n        for i in range(0,len(nums),2):\\n            if i < len(nums) - 1:\\n                if nums[i] * nums[i+1] * max_strength >= max_strength:\\n                    max_strength *= nums[i] * nums[i+1]\\n                    atleast1found = True\\n                elif nums[i+1] * max_strength >= max_strength:\\n                    max_strength *= nums[i+1]\\n                    atleast1found = True\\n            else:\\n                if nums[i] * max_strength >= max_strength:\\n                    max_strength *= nums[i]\\n                    atleast1found = True\\n\\n        if not atleast1found:\\n            return max(nums)\\n        else:    \\n            return max_strength\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735710,
                "title": "maximum-strength-of-a-group-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. we sort the array through which we can saw which element is less than 0 and which is greater.\\n2. count the negative elements if count of negative elements is even so we product all the elements but if count of negative elements is odd so we left the smallest one that is  NegativeCount-1 and product it.\\n3. there is edge case [-1,0] where we saw that NegativeCount is 1 annd positiveCount is 0 so vo return zero.\\n4. at the end we just multilpied the total answer  \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        long long ans=0,tot1=1,tot2=1;\\n        int NegativeCount=0,PositiveCount=0;\\n\\n        if(nums.size()==1) return nums[0];\\n\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0) {\\n                tot1*=nums[i];\\n                PositiveCount++;\\n            }\\n            else if(nums[i]<0){\\n                NegativeCount++;\\n            }\\n        }\\n\\n        if(NegativeCount%2==0){\\n            for(int i=0;i<NegativeCount;i++){\\n                tot2*=nums[i];\\n            }\\n        }\\n        else {\\n            for(int i=0;i<NegativeCount-1;i++){\\n                tot2*=nums[i];  \\n            }\\n        }\\n        if(NegativeCount<2 && PositiveCount<1) return\\xA00;\\n        ans=tot1*tot2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        long long ans=0,tot1=1,tot2=1;\\n        int NegativeCount=0,PositiveCount=0;\\n\\n        if(nums.size()==1) return nums[0];\\n\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>0) {\\n                tot1*=nums[i];\\n                PositiveCount++;\\n            }\\n            else if(nums[i]<0){\\n                NegativeCount++;\\n            }\\n        }\\n\\n        if(NegativeCount%2==0){\\n            for(int i=0;i<NegativeCount;i++){\\n                tot2*=nums[i];\\n            }\\n        }\\n        else {\\n            for(int i=0;i<NegativeCount-1;i++){\\n                tot2*=nums[i];  \\n            }\\n        }\\n        if(NegativeCount<2 && PositiveCount<1) return\\xA00;\\n        ans=tot1*tot2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732161,
                "title": "c-math-greedy-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        long long int ans = 1;\\n        int count0 = 0;\\n        int count_neg = 0;\\n        int n = nums.size();\\n        int x = INT_MIN;\\n        int toggle = 0;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(nums[i] == 0)\\n            {\\n                count0++;\\n                continue;\\n            }\\n            if(nums[i] < 0)\\n            {\\n                x = max(x,nums[i]);\\n                count_neg++;\\n            }\\n            ans *= nums[i];\\n        }\\n        if(ans < 0 && n-count0 > 1)\\n        {\\n            ans /= x;\\n        }\\n        if(count0 > 0 && (ans < 0 || count0 == n))\\n        {\\n            return 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        long long int ans = 1;\\n        int count0 = 0;\\n        int count_neg = 0;\\n        int n = nums.size();\\n        int x = INT_MIN;\\n        int toggle = 0;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(nums[i] == 0)\\n            {\\n                count0++;\\n                continue;\\n            }\\n            if(nums[i] < 0)\\n            {\\n                x = max(x,nums[i]);\\n                count_neg++;\\n            }\\n            ans *= nums[i];\\n        }\\n        if(ans < 0 && n-count0 > 1)\\n        {\\n            ans /= x;\\n        }\\n        if(count0 > 0 && (ans < 0 || count0 == n))\\n        {\\n            return 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723987,
                "title": "explain-c-simple-and-easy-with-3-steps",
                "content": "# Approach\\n1. Step 1: Declare the variable needed to calculate the number of positive integers, the number of negative integers, the number of zeros, the maximum negative integer in nums.\\n2. Step 2: Iterate over all elements in nums. \\n    - If it is a positive number, it will multiply by the desired result variable (strength = strength * x).\\n    - If it is a nagative number, it will multiply by the desired result variable (strength = strength * x). Additionally will compare with current largest negative integer to find the largest negative integer in nums (max_negative = max(max_negative, x)).\\n    - If it is a zero, continue.\\n3. Step 3: \\n    - If nums has an even number of negative integers, return strength\\n    - If nums has an odd number of negative integers, strength is now negative. So must divide by the largest negative integer (max_negative) to get the result you are looking for.\\n\\n# Note\\nThere are 3 cases you need to pay attention to:\\n1. Nums have only one element, so the result is that element. Example: nums = [-3], nums = [0], nums[2]\\n2. Nums contains only the number 0. Example: nums[] = [0,0,0,0,0,0]\\n3. Nums has no positive integers, but many zeros and one negative integer. Example: nums[0,0,0,0,0,-1,0,0]\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        // nums have only one element\\n        if (nums.size() == 1) return nums[0];\\n\\n        long long strength = 1; // answer \\n\\n        int numOfPositive = 0;  // number of positive numbers\\n        int numOfZero = 0;      // number of zeros \\n        int numOfNegative = 0;  // number of negative numbers\\n\\n        int max_negative = INT_MIN; // maximum negative number\\n\\n        for (auto x : nums) {\\n            if (x > 0) {\\n                strength = strength * x;\\n                ++numOfPositive;\\n            }\\n            else if (x < 0) {\\n                strength = strength * x;\\n                ++numOfNegative;\\n                max_negative = max(max_negative, x); \\n            } \\n            else ++numOfZero;\\n        }\\n\\n        // nums contains only the number 0\\n        if (numOfPositive == 0 && numOfZero > 0 && numOfNegative == 0)\\n            return 0;\\n\\n        // nums has no positive integers, but many zeros and one negative integer\\n        if (numOfPositive == 0 && numOfZero > 0 && numOfNegative == 1)\\n            return 0;\\n\\n        // num has an even number of negative integers\\n        if (numOfNegative % 2 == 0) return strength;\\n\\n        // num has an odd number of negative integers\\n        return strength / max_negative;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        // nums have only one element\\n        if (nums.size() == 1) return nums[0];\\n\\n        long long strength = 1; // answer \\n\\n        int numOfPositive = 0;  // number of positive numbers\\n        int numOfZero = 0;      // number of zeros \\n        int numOfNegative = 0;  // number of negative numbers\\n\\n        int max_negative = INT_MIN; // maximum negative number\\n\\n        for (auto x : nums) {\\n            if (x > 0) {\\n                strength = strength * x;\\n                ++numOfPositive;\\n            }\\n            else if (x < 0) {\\n                strength = strength * x;\\n                ++numOfNegative;\\n                max_negative = max(max_negative, x); \\n            } \\n            else ++numOfZero;\\n        }\\n\\n        // nums contains only the number 0\\n        if (numOfPositive == 0 && numOfZero > 0 && numOfNegative == 0)\\n            return 0;\\n\\n        // nums has no positive integers, but many zeros and one negative integer\\n        if (numOfPositive == 0 && numOfZero > 0 && numOfNegative == 1)\\n            return 0;\\n\\n        // num has an even number of negative integers\\n        if (numOfNegative % 2 == 0) return strength;\\n\\n        // num has an odd number of negative integers\\n        return strength / max_negative;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719115,
                "title": "c-90-beats-easy-to-read-and-understand-sorting-and-greedy-solution",
                "content": "# Complexity\\n- Time complexity: O(n) + O(neg) + O(pos)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(pos) + O(neg)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        vector<int> negative;\\n        vector<int> positive;\\n        \\n        if(nums.size() == 1)\\n        {\\n            return nums[0];\\n        } \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i] > 0)\\n            positive.push_back(nums[i]);\\n\\n            if(nums[i] < 0)\\n            negative.push_back(nums[i]);\\n        }\\n\\n        sort(positive.begin(), positive.end());\\n        sort(negative.begin(), negative.end());\\n\\n        long long pro1 = 0;\\n        long long pro2 = 0;\\n        for(int i = 0;i<negative.size();i++)\\n        {\\n            if(i == 0)\\n            pro1 = negative[i];\\n\\n            else\\n            {\\n                if(negative.size() % 2 == 0)\\n                {\\n                    pro1 *= (long long) negative[i];\\n                }\\n                else\\n                {\\n                    if(i < negative.size()-1)\\n                    {\\n                        pro1 *= (long long) negative[i];\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int j=0;j<positive.size();j++)\\n        {\\n            if(j == 0)\\n            pro2 = positive[j];\\n\\n            else\\n            pro2 *= (long long) positive[j];\\n        }\\n\\n        if(pro1 > 0 && pro2 > 0)\\n        {\\n            return pro1 * pro2;\\n        }\\n        else if(pro1 > 0)\\n        {\\n            return pro1;\\n        }\\n        else if(pro2 > 0)\\n        {\\n            return pro2;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        vector<int> negative;\\n        vector<int> positive;\\n        \\n        if(nums.size() == 1)\\n        {\\n            return nums[0];\\n        } \\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i] > 0)\\n            positive.push_back(nums[i]);\\n\\n            if(nums[i] < 0)\\n            negative.push_back(nums[i]);\\n        }\\n\\n        sort(positive.begin(), positive.end());\\n        sort(negative.begin(), negative.end());\\n\\n        long long pro1 = 0;\\n        long long pro2 = 0;\\n        for(int i = 0;i<negative.size();i++)\\n        {\\n            if(i == 0)\\n            pro1 = negative[i];\\n\\n            else\\n            {\\n                if(negative.size() % 2 == 0)\\n                {\\n                    pro1 *= (long long) negative[i];\\n                }\\n                else\\n                {\\n                    if(i < negative.size()-1)\\n                    {\\n                        pro1 *= (long long) negative[i];\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int j=0;j<positive.size();j++)\\n        {\\n            if(j == 0)\\n            pro2 = positive[j];\\n\\n            else\\n            pro2 *= (long long) positive[j];\\n        }\\n\\n        if(pro1 > 0 && pro2 > 0)\\n        {\\n            return pro1 * pro2;\\n        }\\n        else if(pro1 > 0)\\n        {\\n            return pro1;\\n        }\\n        else if(pro2 > 0)\\n        {\\n            return pro2;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3706566,
                "title": "python-o-n-solution-very-similar-to-maximum-product-subarray",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nVery similar to the problem [Maximum Product Subarray\\n](https://leetcode.com/problems/maximum-product-subarray/), except we can take any element from the list, or not. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep track of current minimum and current maximum product, and update as we encounter new elements.\\n\\nCurrMax and CurrMin must be set to an element in `nums`, because if we set it to, say 1, we might encounter a case where that is larger than any element and product of elements in `nums`, returning 1 which is wrong. (think of example: `[0, -1]`) Thus we take the first value of the array and iterate through the rest of the array.\\n\\nNotice how we take the maximum of 4 values. currMax/currMin is for the case when we account `n == 0`. We are allowed to do this because we are not looking for a contiguous subarray, we are looking for a subset of these elements. The rest is the same as aforementioned maximum product subarray problem.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        currMax, currMin = nums[0], nums[0]\\n        for n in nums[1:]:\\n            tmp = currMax\\n            currMax = max(currMax, tmp * n, currMin * n, n)\\n            currMin = min(currMin, tmp * n, currMin * n, n)\\n        return currMax\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        currMax, currMin = nums[0], nums[0]\\n        for n in nums[1:]:\\n            tmp = currMax\\n            currMax = max(currMax, tmp * n, currMin * n, n)\\n            currMin = min(currMin, tmp * n, currMin * n, n)\\n        return currMax\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705696,
                "title": "beats-99-70-ez-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        if len(nums)==1:return nums[0]\\n        neg,pos=[],[]\\n        for  i in nums:\\n            if i>0:pos.append(i)\\n            elif i<0:neg.append(i)\\n        neg.sort()\\n        pos.sort()\\n        if pos==neg==[]:return 0\\n        if len(neg)==0:return prod(pos)\\n        elif len(pos)==0:\\n           \\n            if len(neg)%2==0:return prod(neg)\\n            else:\\n                if max(nums)==0 and len(neg)==1:return 0\\n                return prod(neg[:-1])*prod(pos)\\n        else:\\n            prod_pos=prod(pos)\\n            if len(neg)%2==0:neg_prod=prod(neg)\\n            else:neg_prod=prod(neg[:-1])\\n            return prod_pos*neg_prod\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        if len(nums)==1:return nums[0]\\n        neg,pos=[],[]\\n        for  i in nums:\\n            if i>0:pos.append(i)\\n            elif i<0:neg.append(i)\\n        neg.sort()\\n        pos.sort()\\n        if pos==neg==[]:return 0\\n        if len(neg)==0:return prod(pos)\\n        elif len(pos)==0:\\n           \\n            if len(neg)%2==0:return prod(neg)\\n            else:\\n                if max(nums)==0 and len(neg)==1:return 0\\n                return prod(neg[:-1])*prod(pos)\\n        else:\\n            prod_pos=prod(pos)\\n            if len(neg)%2==0:neg_prod=prod(neg)\\n            else:neg_prod=prod(neg[:-1])\\n            return prod_pos*neg_prod\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701881,
                "title": "c-greedy-sorting",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        if(nums.size() == 1) return nums[0];\\n        if(nums[1] >= 0 && nums.back() == 0) return 0;\\n        long long ans = 1;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(i + 1 < nums.size() && nums[i] * nums[i + 1] > 0) ans *= nums[i] * 1L * nums[i + 1], i++;\\n            else if(nums[i] > 0) ans *= nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        if(nums.size() == 1) return nums[0];\\n        if(nums[1] >= 0 && nums.back() == 0) return 0;\\n        long long ans = 1;\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(i + 1 < nums.size() && nums[i] * nums[i + 1] > 0) ans *= nums[i] * 1L * nums[i + 1], i++;\\n            else if(nums[i] > 0) ans *= nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700894,
                "title": "python-solution",
                "content": "\\n```python\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        negative, positive = [], []\\n        for num in nums:\\n            if num == 0:\\n                continue\\n            if num > 0:\\n                positive.append(num)\\n            else:\\n                negative.append(num)\\n        if len(negative) % 2 == 1:\\n            negative.remove(max(negative))\\n        if len(negative) + len(positive) == 0:\\n            return max(nums)\\n        return reduce(lambda x, y: x * y, negative + positive)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        negative, positive = [], []\\n        for num in nums:\\n            if num == 0:\\n                continue\\n            if num > 0:\\n                positive.append(num)\\n            else:\\n                negative.append(num)\\n        if len(negative) % 2 == 1:\\n            negative.remove(max(negative))\\n        if len(negative) + len(positive) == 0:\\n            return max(nums)\\n        return reduce(lambda x, y: x * y, negative + positive)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691424,
                "title": "maximum-strength-of-a-group",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo find the maximum strength of a group, we can utilize a brute force approach that checks all possible combinations of subgroups. By iterating through all possible subsets of the given array, we calculate the product of the elements in each subset and update the maximum strength accordingly. Since the input size is small (up to 13 elements), this approach will run in a reasonable time frame.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize maxStrength as the minimum integer value.\\nIterate through all possible subsets of the given array using bitmasking.\\nFor each subset, calculate the product of the elements.\\nUpdate maxStrength as the maximum of maxStrength and the calculated product.\\nReturn maxStrength as the maximum strength of a group.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^n), where n is the length of the input array. The algorithm checks all possible subsets, which can be represented by 2^n.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1), as no extra space is used apart from the input and the variables.\\n\\n# Code\\n```\\n#include <vector>\\n#include <algorithm>\\n\\nclass Solution {\\npublic:\\n    long long maxStrength(std::vector<int>& nums) {\\n        int n = nums.size();\\n        long long maxStrength = INT64_MIN;\\n\\n        for (int i = 1; i < (1 << n); i++) {\\n            long long product = 1;\\n\\n            for (int j = 0; j < n; j++) {\\n                if (i & (1 << j)) {\\n                    product *= nums[j];\\n                }\\n            }\\n\\n            maxStrength = std::max(maxStrength, product);\\n        }\\n\\n        return maxStrength;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <vector>\\n#include <algorithm>\\n\\nclass Solution {\\npublic:\\n    long long maxStrength(std::vector<int>& nums) {\\n        int n = nums.size();\\n        long long maxStrength = INT64_MIN;\\n\\n        for (int i = 1; i < (1 << n); i++) {\\n            long long product = 1;\\n\\n            for (int j = 0; j < n; j++) {\\n                if (i & (1 << j)) {\\n                    product *= nums[j];\\n                }\\n            }\\n\\n            maxStrength = std::max(maxStrength, product);\\n        }\\n\\n        return maxStrength;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3675219,
                "title": "sorting-o-nlogn",
                "content": "# ***Upvote if you understood the solution \\uD83D\\uDC4D***\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        if(nums.length<2){\\n            return nums[0];\\n        }\\n        long ms=1;  //maximum strength\\n\\n        long nc=0;\\n        long np=0;  \\n        for(int i=0;i<nums.length;i++){\\n           if(nums[i]<0){\\n               nc++;     //calc count of neg no\\n           }\\n           if(nums[i]>0){\\n               np++;       //calc count of pos no\\n           }\\n        } \\n        if(nc==0 && np==0){ // example :[0,0,0,0,0,0,0,0,0,0,0,0,0]\\n            return 0;\\n        }\\n      \\n        Arrays.sort(nums);\\n\\n        long maxneg=nums[0]; //remove the less value (-9) [-3,-5,-9] from testcase 1 \\n\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]<0 ){\\n                if(nums[i]>maxneg){\\n                    maxneg=nums[i];\\n                }\\n            }\\n        } \\n#        //maximum strength calculation\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>0){\\n              ms*=nums[i];\\n            }\\n            if(nums[i]<0){\\n              ms*=nums[i];\\n            }\\n        } \\n        //special case---array containing only 0 and one nc\\n         boolean ispositive=true;\\n         for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0 && nc==1 && np==0){\\n                ispositive=false;\\n            }\\n        } \\n        if(ispositive==false){\\n           return 0 ;\\n        }\\n        if(nc%2==1){\\n          return Math.abs(ms/maxneg);  \\n        }\\n        else{\\n            return ms;\\n        }           \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        if(nums.length<2){\\n            return nums[0];\\n        }\\n        long ms=1;  //maximum strength\\n\\n        long nc=0;\\n        long np=0;  \\n        for(int i=0;i<nums.length;i++){\\n           if(nums[i]<0){\\n               nc++;     //calc count of neg no\\n           }\\n           if(nums[i]>0){\\n               np++;       //calc count of pos no\\n           }\\n        } \\n        if(nc==0 && np==0){ // example :[0,0,0,0,0,0,0,0,0,0,0,0,0]\\n            return 0;\\n        }\\n      \\n        Arrays.sort(nums);\\n\\n        long maxneg=nums[0]; //remove the less value (-9) [-3,-5,-9] from testcase 1 \\n\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]<0 ){\\n                if(nums[i]>maxneg){\\n                    maxneg=nums[i];\\n                }\\n            }\\n        } \\n#        //maximum strength calculation\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>0){\\n              ms*=nums[i];\\n            }\\n            if(nums[i]<0){\\n              ms*=nums[i];\\n            }\\n        } \\n        //special case---array containing only 0 and one nc\\n         boolean ispositive=true;\\n         for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0 && nc==1 && np==0){\\n                ispositive=false;\\n            }\\n        } \\n        if(ispositive==false){\\n           return 0 ;\\n        }\\n        if(nc%2==1){\\n          return Math.abs(ms/maxneg);  \\n        }\\n        else{\\n            return ms;\\n        }           \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671500,
                "title": "easy-to-understand-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        Arrays.sort(nums);\\n        int pos = 0;\\n        int neg = 0;\\n        for(int i = 0; i < nums.length; i++) { // count the number of positives and negatives\\n            if(nums[i] > 0) pos++;\\n            else if(nums[i] < 0) neg++;\\n        }\\n        long max;\\n        if(pos == 0 && neg <= 1) // in this case, max = 0 or the maximum negative\\n            max = nums[nums.length - 1];\\n        else // there must be at lease one positive or two negatives\\n            max = 1;\\n        for(int i = 0; i < ((neg % 2 == 0) ? neg : neg - 1); i++) {\\n            max *= nums[i];\\n        }\\n        for(int i = nums.length - 1; i >= nums.length - pos; i--) {\\n            max *= nums[i];\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        Arrays.sort(nums);\\n        int pos = 0;\\n        int neg = 0;\\n        for(int i = 0; i < nums.length; i++) { // count the number of positives and negatives\\n            if(nums[i] > 0) pos++;\\n            else if(nums[i] < 0) neg++;\\n        }\\n        long max;\\n        if(pos == 0 && neg <= 1) // in this case, max = 0 or the maximum negative\\n            max = nums[nums.length - 1];\\n        else // there must be at lease one positive or two negatives\\n            max = 1;\\n        for(int i = 0; i < ((neg % 2 == 0) ? neg : neg - 1); i++) {\\n            max *= nums[i];\\n        }\\n        for(int i = nums.length - 1; i >= nums.length - pos; i--) {\\n            max *= nums[i];\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670880,
                "title": "o-n-solution-by-counting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        positive = defaultdict(int)\\n        negative = defaultdict(int)\\n        zero = False\\n        negative_n = 0\\n        for n in nums:\\n            if n > 0:\\n                positive[n] += 1\\n            elif n < 0:\\n                negative[n] += 1\\n                negative_n += 1\\n            else:\\n                zero = True\\n\\n        if not positive and not negative and zero:\\n            return 0\\n\\n        result = 1\\n        for n, count in positive.items():\\n            result *= n ** count\\n\\n        for n, count in negative.items():\\n            result *= n ** count\\n\\n        if not positive and negative_n == 1:\\n            if zero:\\n                return 0\\n            return result\\n\\n        if negative_n % 2 == 1:\\n            for i in range(-1, -10, -1):\\n                if i in negative and result < 0:\\n                    result /= i\\n                    break\\n\\n        return int(result)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        positive = defaultdict(int)\\n        negative = defaultdict(int)\\n        zero = False\\n        negative_n = 0\\n        for n in nums:\\n            if n > 0:\\n                positive[n] += 1\\n            elif n < 0:\\n                negative[n] += 1\\n                negative_n += 1\\n            else:\\n                zero = True\\n\\n        if not positive and not negative and zero:\\n            return 0\\n\\n        result = 1\\n        for n, count in positive.items():\\n            result *= n ** count\\n\\n        for n, count in negative.items():\\n            result *= n ** count\\n\\n        if not positive and negative_n == 1:\\n            if zero:\\n                return 0\\n            return result\\n\\n        if negative_n % 2 == 1:\\n            for i in range(-1, -10, -1):\\n                if i in negative and result < 0:\\n                    result /= i\\n                    break\\n\\n        return int(result)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667648,
                "title": "easy-recursive-memoistaion-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long solve(vector<int> &nums,long long product,int index)\\n    {\\n\\n        if(index==nums.size())\\n        return product;\\n\\n\\n        //long long product = INT_MIN;\\n        //include\\n        /*if(dp[make_pair(index,product)].second!=false)\\n        return dp[make_pair(index,product)].first;*/\\n\\n        long long include;\\n        if(product == INT_MIN)\\n        {\\n            include = solve(nums,nums[index],index+1);\\n        }\\n        else\\n        {\\n            include = solve(nums,nums[index]*product,index+1);\\n        }\\n\\n\\n        long long exclude;\\n        exclude = solve(nums,product,index+1);\\n\\n        long long ans = max(include,exclude);\\n        //dp[make_pair(index,product)] = make_pair(ans,true);\\n        return ans;\\n    }\\n    long long maxStrength(vector<int>& nums) {\\n        //unordered_map<pair<int,long long>,pair<long long,bool>> dp;\\n        return solve(nums,INT_MIN,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(vector<int> &nums,long long product,int index)\\n    {\\n\\n        if(index==nums.size())\\n        return product;\\n\\n\\n        //long long product = INT_MIN;\\n        //include\\n        /*if(dp[make_pair(index,product)].second!=false)\\n        return dp[make_pair(index,product)].first;*/\\n\\n        long long include;\\n        if(product == INT_MIN)\\n        {\\n            include = solve(nums,nums[index],index+1);\\n        }\\n        else\\n        {\\n            include = solve(nums,nums[index]*product,index+1);\\n        }\\n\\n\\n        long long exclude;\\n        exclude = solve(nums,product,index+1);\\n\\n        long long ans = max(include,exclude);\\n        //dp[make_pair(index,product)] = make_pair(ans,true);\\n        return ans;\\n    }\\n    long long maxStrength(vector<int>& nums) {\\n        //unordered_map<pair<int,long long>,pair<long long,bool>> dp;\\n        return solve(nums,INT_MIN,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664824,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        if(nums.length==1) return nums[0];\\n\\n        int fl = 0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] != 0){\\n                fl = 1;\\n                break;\\n            }\\n        }\\n        if(fl==0) return 0;\\n        else{\\n        long prod = 1;\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]!=0){\\n                prod*=nums[i];\\n                count++;\\n            }\\n        }\\n\\n        long ans = 0;\\n        if(prod>0) return prod;\\n        else if(prod<0 && count<=1) return 0;\\n        else{\\n            for(int i=0; i<nums.length; i++){\\n                if(nums[i]!=0){\\n                    ans = Math.max(ans, prod/nums[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        if(nums.length==1) return nums[0];\\n\\n        int fl = 0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] != 0){\\n                fl = 1;\\n                break;\\n            }\\n        }\\n        if(fl==0) return 0;\\n        else{\\n        long prod = 1;\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]!=0){\\n                prod*=nums[i];\\n                count++;\\n            }\\n        }\\n\\n        long ans = 0;\\n        if(prod>0) return prod;\\n        else if(prod<0 && count<=1) return 0;\\n        else{\\n            for(int i=0; i<nums.length; i++){\\n                if(nums[i]!=0){\\n                    ans = Math.max(ans, prod/nums[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664285,
                "title": "my-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n       Arrays.sort(nums);\\n        long mul=1;long maxi=Integer.MIN_VALUE;\\n        int even=0,odd=0;int cnt=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0){\\n                odd++;\\n            }else{\\n                even++;\\n            }\\n        }\\n        if(odd%2==0){\\n            for(int i=0;i<nums.length;i++){\\n                if(nums[i]!=0){\\n                    mul*=nums[i];\\n                    maxi=Math.max(maxi,mul);\\n                }\\n            }\\n        }\\nelse if(odd%2!=0){\\n\\nfor(int i=nums.length-1;i>=0;i--){\\nif(i>1&&nums[i]<0&&cnt==0){\\n    i--;cnt++;\\n}\\nif(nums[i]!=0){\\nmul*=nums[i];\\nmaxi=Math.max(maxi,mul);}\\nelse if(nums[i]==0&&odd==1&&even!=0){\\n    mul*=nums[i];\\n    maxi=Math.max(maxi,mul);\\n}\\n}\\n}\\nif(maxi==Integer.MIN_VALUE){\\n    return 0;\\n}\\nreturn maxi; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n       Arrays.sort(nums);\\n        long mul=1;long maxi=Integer.MIN_VALUE;\\n        int even=0,odd=0;int cnt=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0){\\n                odd++;\\n            }else{\\n                even++;\\n            }\\n        }\\n        if(odd%2==0){\\n            for(int i=0;i<nums.length;i++){\\n                if(nums[i]!=0){\\n                    mul*=nums[i];\\n                    maxi=Math.max(maxi,mul);\\n                }\\n            }\\n        }\\nelse if(odd%2!=0){\\n\\nfor(int i=nums.length-1;i>=0;i--){\\nif(i>1&&nums[i]<0&&cnt==0){\\n    i--;cnt++;\\n}\\nif(nums[i]!=0){\\nmul*=nums[i];\\nmaxi=Math.max(maxi,mul);}\\nelse if(nums[i]==0&&odd==1&&even!=0){\\n    mul*=nums[i];\\n    maxi=Math.max(maxi,mul);\\n}\\n}\\n}\\nif(maxi==Integer.MIN_VALUE){\\n    return 0;\\n}\\nreturn maxi; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657841,
                "title": "python-beats-91-easy-intuition-iterative-no-sorting-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIdea is to solve in 2 passes and avoid extra memory for positive or negative numbers.\\n\\n# Approach\\n\\nWe need to set largest negative (closer to 0) to 0 if count of negative is odd,  then in 2nd pass multiply numbers if they are not zeros. Finally, need to account for edge cases of trivial and all numbers zero and negative.\\n\\n\\n# Complexity\\n- Time complexity:\\n2 passes - O(n)\\n\\n- Space complexity:\\nWe only store variables, so O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        # iterate array, remember largest negative(closer to 0), then replace that element with 0 if count of negative is odd; make second pass multiple if not zero\\n        if len(nums) == 1:\\n            return nums[0]\\n        largest_n, lindex,count = -float(\\'inf\\'), 0, 0\\n        for i, v in enumerate(nums):\\n            if v < 0:\\n                count += 1\\n                if v > largest_n:\\n                    lindex = i\\n                    largest_n = v\\n        \\n        if count % 2 != 0:\\n            nums[lindex] = 0\\n        strength = 1\\n        flag = False # flag to mark we had other numbers then zero\\n        for n in nums:\\n            if n != 0:\\n                strength *= n\\n                flag = True\\n        if not flag:\\n            return 0\\n        return strength\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        # iterate array, remember largest negative(closer to 0), then replace that element with 0 if count of negative is odd; make second pass multiple if not zero\\n        if len(nums) == 1:\\n            return nums[0]\\n        largest_n, lindex,count = -float(\\'inf\\'), 0, 0\\n        for i, v in enumerate(nums):\\n            if v < 0:\\n                count += 1\\n                if v > largest_n:\\n                    lindex = i\\n                    largest_n = v\\n        \\n        if count % 2 != 0:\\n            nums[lindex] = 0\\n        strength = 1\\n        flag = False # flag to mark we had other numbers then zero\\n        for n in nums:\\n            if n != 0:\\n                strength *= n\\n                flag = True\\n        if not flag:\\n            return 0\\n        return strength\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653750,
                "title": "python3-easy-to-understand-just-multiply-all-required-numbers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust Multiply all the necessary numbers, to achieve this , we first sort in reverse so that we know we have positive nos first , then 0, then the LARGEST NEGATIVE number, then other negative nos.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInclude all positive nos in ur product, because it will only increase the number. when we reach negative nos - check if the no of negative number is odd or even, if even then we are good - multiply all of them. otherwise if its odd , then we should remove one number so that the product remains positive, so we remove the LARGEST negative number (remove -1 instead of -100) because -100 will give higher product if multiplied with another negative number.\\nHow do we find largest negative number ? since its sorted we know the very first negative number we encounter is the largest one.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        def getProduct(arr): // helper method to return product of nos\\n            if not arr:\\n                return(0)\\n            f = 1\\n            for x in arr:\\n                f*=x\\n            return(f)\\n        if len(nums)==1: // base case if there is only one no\\n            return(nums[0])\\n        \\n        nums.sort(reverse=1)\\n        ans = 0\\n        N = len(nums)\\n        for i,x in enumerate(nums):\\n            if x==0:\\n                continue\\n            if x>0: // multiply all positive nos.\\n                if not ans: // done to take care of edge. case [0,-1], otherwise we could have started with ans=1, and just done ans*=nums[i]\\n                    ans+=nums[i]\\n                else:\\n                    ans*=nums[i]\\n            else:\\n                remain = N-i\\n                if remain&1: // if its odd, remove the largest negative number , its the current number\\n                    p = getProduct(nums[i+1:])\\n                else:\\n                    p = getProduct(nums[i:])\\n                if not ans: // if there were no positive number encountered earlier, then dont multiply our result(p) with 0.\\n                    negans = p\\n                else:\\n                    negans = ans*p // multiply positive product with negative product\\n                return max(ans, negans)\\n            \\n        return(ans)\\n                \\n                \\n                \\n            \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        def getProduct(arr): // helper method to return product of nos\\n            if not arr:\\n                return(0)\\n            f = 1\\n            for x in arr:\\n                f*=x\\n            return(f)\\n        if len(nums)==1: // base case if there is only one no\\n            return(nums[0])\\n        \\n        nums.sort(reverse=1)\\n        ans = 0\\n        N = len(nums)\\n        for i,x in enumerate(nums):\\n            if x==0:\\n                continue\\n            if x>0: // multiply all positive nos.\\n                if not ans: // done to take care of edge. case [0,-1], otherwise we could have started with ans=1, and just done ans*=nums[i]\\n                    ans+=nums[i]\\n                else:\\n                    ans*=nums[i]\\n            else:\\n                remain = N-i\\n                if remain&1: // if its odd, remove the largest negative number , its the current number\\n                    p = getProduct(nums[i+1:])\\n                else:\\n                    p = getProduct(nums[i:])\\n                if not ans: // if there were no positive number encountered earlier, then dont multiply our result(p) with 0.\\n                    negans = p\\n                else:\\n                    negans = ans*p // multiply positive product with negative product\\n                return max(ans, negans)\\n            \\n        return(ans)\\n                \\n                \\n                \\n            \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649503,
                "title": "easy-simple-by-using-loop-please-upvote-me",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        // handle 1st corner case - single element\\n        if(nums.size() == 1) return nums[0];\\n\\n        int negCount = 0;\\n        int largestNegElement = INT_MIN;\\n        int largestElement = INT_MIN;\\n        long long product = 1;\\n        for(int i=0; i<nums.size(); i++){\\n            // update -ve count and largestNegElement, largestElement\\n            if(nums[i] < 0){ \\n                negCount++;\\n                largestNegElement = max(largestNegElement, nums[i]);\\n            }\\n            largestElement = max(largestElement, nums[i]);\\n\\n            // update product if not 0\\n            if(nums[i]) product *= nums[i];\\n        }\\n        // handle 2nd corner case - one -ve, some 0\\'s , no +ve\\n        if(largestElement == 0 && negCount <= 1)  return 0;\\n        // hanlde odd -ve case\\n        if(negCount % 2) return product / largestNegElement;\\n        return product;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        // handle 1st corner case - single element\\n        if(nums.size() == 1) return nums[0];\\n\\n        int negCount = 0;\\n        int largestNegElement = INT_MIN;\\n        int largestElement = INT_MIN;\\n        long long product = 1;\\n        for(int i=0; i<nums.size(); i++){\\n            // update -ve count and largestNegElement, largestElement\\n            if(nums[i] < 0){ \\n                negCount++;\\n                largestNegElement = max(largestNegElement, nums[i]);\\n            }\\n            largestElement = max(largestElement, nums[i]);\\n\\n            // update product if not 0\\n            if(nums[i]) product *= nums[i];\\n        }\\n        // handle 2nd corner case - one -ve, some 0\\'s , no +ve\\n        if(largestElement == 0 && negCount <= 1)  return 0;\\n        // hanlde odd -ve case\\n        if(negCount % 2) return product / largestNegElement;\\n        return product;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649134,
                "title": "nasty-hash-not-a-good-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nat first, it seems too easy for me,\\n\\nfirst submit, add one edge case\\nsecond.. add another edge case\\n\\nlast.. add tons of edge cases \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n\\n        minus = [0] * 10\\n        plus = 0\\n        res = 1\\n        for n in nums:\\n            if n > 0:\\n                res *= n\\n                plus += 1\\n            elif n < 0:\\n                minus[-n] += 1\\n\\n        if sum(minus) <= 1 and plus ==0:\\n            return max(nums)\\n        cur = 0\\n        \\n        for i in range(9, 0, -1):\\n            \\n            if cur != 0 and minus[i] >0:\\n                res *= cur * i\\n                minus[i] -= 1\\n                cur = 0\\n\\n            if minus[i] >= 2 and i != 1:\\n                res *= (i**2)**(minus[i]>>1)\\n                minus[i] = minus[i] % 2 \\n\\n            if minus[i] > 0:\\n                cur = i\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n\\n        minus = [0] * 10\\n        plus = 0\\n        res = 1\\n        for n in nums:\\n            if n > 0:\\n                res *= n\\n                plus += 1\\n            elif n < 0:\\n                minus[-n] += 1\\n\\n        if sum(minus) <= 1 and plus ==0:\\n            return max(nums)\\n        cur = 0\\n        \\n        for i in range(9, 0, -1):\\n            \\n            if cur != 0 and minus[i] >0:\\n                res *= cur * i\\n                minus[i] -= 1\\n                cur = 0\\n\\n            if minus[i] >= 2 and i != 1:\\n                res *= (i**2)**(minus[i]>>1)\\n                minus[i] = minus[i] % 2 \\n\\n            if minus[i] > 0:\\n                cur = i\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649116,
                "title": "runtime-2-ms-beats-100-fast-solution-real-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static long maxStrength(int[] nums) {\\n        long str = 0;\\n        int lowestNegative = Integer.MIN_VALUE;\\n        boolean anyp = false;\\n        if (nums.length == 1) {\\n            return nums[0];\\n        }\\n        if (nums.length == 2) {\\n            if (nums[0] < 0 && nums[1] < 0) {\\n                return (long) nums[0] * nums[1];\\n            }\\n            if (nums[0] < 0) {\\n                return nums[1];\\n            }\\n            if (nums[1] < 0) {\\n                return nums[0];\\n            }\\n        }\\n        for (int num : nums) {\\n            if (num == 0) {\\n                continue;\\n            }\\n            if (num > 0) {\\n                anyp = true;\\n            }\\n            if (str != 0) {\\n                anyp = true;\\n                str *= num;\\n            } else {\\n                str = num;\\n            }\\n            if (num < 0 && lowestNegative < num) {\\n                lowestNegative = num;\\n            }\\n        }\\n        if (str < 0) {\\n            str /= lowestNegative;\\n        }\\n        return anyp ? str : 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static long maxStrength(int[] nums) {\\n        long str = 0;\\n        int lowestNegative = Integer.MIN_VALUE;\\n        boolean anyp = false;\\n        if (nums.length == 1) {\\n            return nums[0];\\n        }\\n        if (nums.length == 2) {\\n            if (nums[0] < 0 && nums[1] < 0) {\\n                return (long) nums[0] * nums[1];\\n            }\\n            if (nums[0] < 0) {\\n                return nums[1];\\n            }\\n            if (nums[1] < 0) {\\n                return nums[0];\\n            }\\n        }\\n        for (int num : nums) {\\n            if (num == 0) {\\n                continue;\\n            }\\n            if (num > 0) {\\n                anyp = true;\\n            }\\n            if (str != 0) {\\n                anyp = true;\\n                str *= num;\\n            } else {\\n                str = num;\\n            }\\n            if (num < 0 && lowestNegative < num) {\\n                lowestNegative = num;\\n            }\\n        }\\n        if (str < 0) {\\n            str /= lowestNegative;\\n        }\\n        return anyp ? str : 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648062,
                "title": "100-o-n-solution-easy-no-sorting",
                "content": "# No Sorting\\n\\n# Approach\\nFind the product of all positive number and same for negative, also find largest negative if number of negative numbers is odd then divide answer by largest negative number else answer is product of postive and negative number. Also corner case when there is only one negative number and one zero. then answer will be 0.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        // Arrays.parallelSort(nums);\\n        int n=0, z =0, p =0;\\n        long mul =1;\\n        for(int ele : nums){\\n            if(ele>0){\\n                mul*=ele;\\n                p++;\\n            }\\n            else if(ele<0){\\n                n++;\\n            }\\n            else{\\n                z++;\\n            }\\n        }\\n        if(p==0){\\n            mul=0;\\n        }\\n        int[] neg = new int[n];\\n        int i =0;\\n        long nmul = 1;\\n        int lar = Integer.MIN_VALUE;\\n        for(int ele : nums){\\n            if(ele<0){\\n                neg[i]=ele;\\n                i++;\\n                nmul *= Math.abs(ele);\\n                lar = lar > ele ? lar : ele;\\n            }\\n        }\\n        if(n==0){\\n            nmul=0;\\n        }\\n \\n        // if(p==0 && )\\n        if(mul!=0 && nmul!=0){\\n            if(neg.length%2==0){\\n                return (long)mul*(long)nmul;\\n            }\\n            else{\\n                return ((long)mul*(long)nmul)/(long)Math.abs(lar);\\n            }\\n        }\\n        else if(mul==0 && nmul!=0){\\n            if(z!=0 && n==1){\\n                return 0;\\n            }\\n            else{\\n                if(neg.length%2==0){\\n                    return (long)nmul;\\n                }\\n                else{\\n                    if(neg.length==1){\\n                        return lar;\\n                    }\\n                    return (long)nmul/Math.abs(lar);\\n                }\\n            }\\n        }   \\n        else if(mul!=0 && nmul==0){\\n            return (long)mul;\\n        } \\n        else{\\n            return 0;\\n        }    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        // Arrays.parallelSort(nums);\\n        int n=0, z =0, p =0;\\n        long mul =1;\\n        for(int ele : nums){\\n            if(ele>0){\\n                mul*=ele;\\n                p++;\\n            }\\n            else if(ele<0){\\n                n++;\\n            }\\n            else{\\n                z++;\\n            }\\n        }\\n        if(p==0){\\n            mul=0;\\n        }\\n        int[] neg = new int[n];\\n        int i =0;\\n        long nmul = 1;\\n        int lar = Integer.MIN_VALUE;\\n        for(int ele : nums){\\n            if(ele<0){\\n                neg[i]=ele;\\n                i++;\\n                nmul *= Math.abs(ele);\\n                lar = lar > ele ? lar : ele;\\n            }\\n        }\\n        if(n==0){\\n            nmul=0;\\n        }\\n \\n        // if(p==0 && )\\n        if(mul!=0 && nmul!=0){\\n            if(neg.length%2==0){\\n                return (long)mul*(long)nmul;\\n            }\\n            else{\\n                return ((long)mul*(long)nmul)/(long)Math.abs(lar);\\n            }\\n        }\\n        else if(mul==0 && nmul!=0){\\n            if(z!=0 && n==1){\\n                return 0;\\n            }\\n            else{\\n                if(neg.length%2==0){\\n                    return (long)nmul;\\n                }\\n                else{\\n                    if(neg.length==1){\\n                        return lar;\\n                    }\\n                    return (long)nmul/Math.abs(lar);\\n                }\\n            }\\n        }   \\n        else if(mul!=0 && nmul==0){\\n            return (long)mul;\\n        } \\n        else{\\n            return 0;\\n        }    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647874,
                "title": "east-c-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        long long  prod ; \\n        //if(nums.size()==1) return nums ; \\n        if(nums.size()==1){\\n            prod = nums[0];\\n            return prod ; \\n        }\\n         vector<long long > neg;\\n         vector<long long > pos;\\n        for(int i = 0 ; i<nums.size();i++){\\n         if(nums[i]>0){\\n          pos.push_back(nums[i]);\\n      }\\n        else if(nums[i]<0){\\n          neg.push_back(nums[i]);\\n      }\\n  }\\n  if(neg.size()<=1 && pos.size()==0){\\n      return *max_element(nums.begin(),nums.end());\\n  }\\n   long long posp = 1 ; \\n   long negp = 1 ; \\n   if(neg.size()==0){\\n      posp*1; \\n   }\\n    for(int r = 0 ; r<pos.size();r++){\\n     posp = posp*pos[r];\\n        }\\n  sort (neg.begin(),neg.end());\\n  reverse(neg.begin(),neg.end());\\n  int n = neg.size();\\n  if( n%2 != 0 ){\\n      for(int z = 1 ; z <neg.size();z++){\\n          negp = negp * neg[z];\\n          \\n      }\\n  }\\n  else if(n>0 && n%2==0){\\n      for(int l = 0 ; l <=neg.size()-1; l++){\\n          negp = negp * neg[l];\\n      }\\n  }\\n   prod = negp*posp;\\n  return prod ;\\n\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        long long  prod ; \\n        //if(nums.size()==1) return nums ; \\n        if(nums.size()==1){\\n            prod = nums[0];\\n            return prod ; \\n        }\\n         vector<long long > neg;\\n         vector<long long > pos;\\n        for(int i = 0 ; i<nums.size();i++){\\n         if(nums[i]>0){\\n          pos.push_back(nums[i]);\\n      }\\n        else if(nums[i]<0){\\n          neg.push_back(nums[i]);\\n      }\\n  }\\n  if(neg.size()<=1 && pos.size()==0){\\n      return *max_element(nums.begin(),nums.end());\\n  }\\n   long long posp = 1 ; \\n   long negp = 1 ; \\n   if(neg.size()==0){\\n      posp*1; \\n   }\\n    for(int r = 0 ; r<pos.size();r++){\\n     posp = posp*pos[r];\\n        }\\n  sort (neg.begin(),neg.end());\\n  reverse(neg.begin(),neg.end());\\n  int n = neg.size();\\n  if( n%2 != 0 ){\\n      for(int z = 1 ; z <neg.size();z++){\\n          negp = negp * neg[z];\\n          \\n      }\\n  }\\n  else if(n>0 && n%2==0){\\n      for(int l = 0 ; l <=neg.size()-1; l++){\\n          negp = negp * neg[l];\\n      }\\n  }\\n   prod = negp*posp;\\n  return prod ;\\n\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641435,
                "title": "simple-o-n-time-and-o-1-space-complexity-solution-in-c",
                "content": "# Intuition\\n    A max product can be multiplying all the positive integers and even no. of negative integers.\\n# Approach\\n Few steps while iterating the array.\\n 1. Skip all zeros and compute the product of all elements.\\n 2. Keep 2 flags to check the existance of 1 and 0.\\n 3. Check if the array is not full of zeros.\\n 4. Keep updating the highest (smallest magnitude) negative integer to find the max negative integer.\\n\\n***If the final product is > 0 simply return the product value.***\\n---\\nElse there are different scenarois causing the final product to be <=0.\\n- All zeros [0,0,0] = 0\\nIdeally also should return 0 but since we are skipping 0s this edge case should be handled.\\n---\\n***If final product is same as maxNegative number***\\n- for ex in [0,-7,1], check if both 0 and 1 exists then return 1.\\n- If it does not have both 0 and 1, for ex [-7] return the product itself.\\n- else just return 1, for ex [-7, 1]\\n\\n---\\nelse there is only one scenario left, we have included odd no of negative integers while calulating the product. So we need the exclude one negative integer which has the smallest magnitude which is nothing but maxNegative no. ***Hence return product/maxNegative.***\\n\\n# Complexity\\n- Time complexity:\\nO(n), we are simply iterating the array.\\n\\n- Space complexity:\\nO(1) no extra space involved.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int len = nums.size();\\n\\n        long long result = 1;\\n        int minNeg = -9;\\n        bool hasOne = 0;\\n        bool hasZero = 0;\\n        int count = 0;\\n\\n        for(int i = 0; i < len ; i++){\\n            if(nums[i] == 0){\\n                hasZero = 1;\\n                continue;\\n            }\\n            count ++;\\n            if(nums[i] == 1)\\n                hasOne =1;\\n            cout<< nums[i]<<\" \";\\n            result = result*nums[i];\\n            if(nums[i]<0)\\n                minNeg = max(minNeg, nums[i]);\\n        }\\n        if(count == 0)\\n            return 0;\\n        if(result > 0)\\n            return result;\\n        else if(result == minNeg){\\n            if(hasZero && !hasOne)\\n                return 0;\\n            else if(!hasZero && !hasOne)\\n                return result;\\n            return 1;\\n\\n        }          \\n        else\\n            return result/minNeg;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int len = nums.size();\\n\\n        long long result = 1;\\n        int minNeg = -9;\\n        bool hasOne = 0;\\n        bool hasZero = 0;\\n        int count = 0;\\n\\n        for(int i = 0; i < len ; i++){\\n            if(nums[i] == 0){\\n                hasZero = 1;\\n                continue;\\n            }\\n            count ++;\\n            if(nums[i] == 1)\\n                hasOne =1;\\n            cout<< nums[i]<<\" \";\\n            result = result*nums[i];\\n            if(nums[i]<0)\\n                minNeg = max(minNeg, nums[i]);\\n        }\\n        if(count == 0)\\n            return 0;\\n        if(result > 0)\\n            return result;\\n        else if(result == minNeg){\\n            if(hasZero && !hasOne)\\n                return 0;\\n            else if(!hasZero && !hasOne)\\n                return result;\\n            return 1;\\n\\n        }          \\n        else\\n            return result/minNeg;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3640006,
                "title": "sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction maxStrength(nums: number[]): number {\\n  const negatives = []\\n  const positives = []\\n  let hasZero = false\\n  for (let i = 0; i < nums.length; i++) {\\n    const num = nums[i]\\n    if (num > 0) {\\n      positives.push(num)\\n    } else if (num < 0) {\\n      negatives.push(num)\\n    } else {\\n      hasZero = true\\n    }\\n  }\\n  const len = negatives.length\\n  if (hasZero) {\\n    if (positives.length === 0) {\\n      if (negatives.length <= 1) {\\n        return 0\\n      }\\n    }\\n  } else {\\n     if (positives.length === 0) {\\n      if (negatives.length === 1) {\\n        return negatives[0]\\n      }\\n    }\\n  }\\n  return positives.reduce((pro, n) => pro * n, 1) * negatives.sort().slice(len % 2 === 0 ? 0 : 1).reduce((pro, n) => pro * n, 1)\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction maxStrength(nums: number[]): number {\\n  const negatives = []\\n  const positives = []\\n  let hasZero = false\\n  for (let i = 0; i < nums.length; i++) {\\n    const num = nums[i]\\n    if (num > 0) {\\n      positives.push(num)\\n    } else if (num < 0) {\\n      negatives.push(num)\\n    } else {\\n      hasZero = true\\n    }\\n  }\\n  const len = negatives.length\\n  if (hasZero) {\\n    if (positives.length === 0) {\\n      if (negatives.length <= 1) {\\n        return 0\\n      }\\n    }\\n  } else {\\n     if (positives.length === 0) {\\n      if (negatives.length === 1) {\\n        return negatives[0]\\n      }\\n    }\\n  }\\n  return positives.reduce((pro, n) => pro * n, 1) * negatives.sort().slice(len % 2 === 0 ? 0 : 1).reduce((pro, n) => pro * n, 1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3637430,
                "title": "9-lines-python-o-n-solution",
                "content": "# Approach\\nGreedy, calculate minimal and maximal result up to current number.\\nSpecially when current number is negative, compare minimal * num with current number and maximum; compare maximum * num with current number and minimal.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        mi = ma = nums[0]\\n        for num in nums[1:]:\\n            if num < 0:\\n                ma, mi = max(ma, mi*num, num), min(mi, ma*num, num)\\n            else:\\n                ma = max(ma, ma*num, num)\\n                mi = min(mi, mi*num, num)\\n        \\n        return max(ma, mi)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        mi = ma = nums[0]\\n        for num in nums[1:]:\\n            if num < 0:\\n                ma, mi = max(ma, mi*num, num), min(mi, ma*num, num)\\n            else:\\n                ma = max(ma, ma*num, num)\\n                mi = min(mi, mi*num, num)\\n        \\n        return max(ma, mi)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636386,
                "title": "optimized-approach-java-solution-beats-100",
                "content": "# Intuition\\nKeeping track of positives and negatives can help!\\n\\n# Approach\\nall positives need to be included, just smallest negative needs to be removed from the group if total number of negatives are odd.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        int negatives=0;\\n        int positives=0;\\n        long res=1;\\n        int smallestNegative=-10;\\n        if(nums.length == 1){\\n            return nums[0];\\n        }\\n        for(int i:nums){\\n            if(i<0){\\n                res=res*i;\\n                negatives++;\\n                if(Math.abs(smallestNegative) > Math.abs(i)){\\n                    smallestNegative=i;\\n                }\\n                \\n            }\\n            if(i>0){\\n                positives++;\\n                res=res*i;\\n            }\\n        }\\n       \\n        if(negatives%2!=0){\\n            res=res/smallestNegative;\\n            negatives--;\\n        }\\n        if(positives <=0 && negatives <=0){\\n            return 0;\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        int negatives=0;\\n        int positives=0;\\n        long res=1;\\n        int smallestNegative=-10;\\n        if(nums.length == 1){\\n            return nums[0];\\n        }\\n        for(int i:nums){\\n            if(i<0){\\n                res=res*i;\\n                negatives++;\\n                if(Math.abs(smallestNegative) > Math.abs(i)){\\n                    smallestNegative=i;\\n                }\\n                \\n            }\\n            if(i>0){\\n                positives++;\\n                res=res*i;\\n            }\\n        }\\n       \\n        if(negatives%2!=0){\\n            res=res/smallestNegative;\\n            negatives--;\\n        }\\n        if(positives <=0 && negatives <=0){\\n            return 0;\\n        }\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635717,
                "title": "c-solution-pick-notpick",
                "content": "class Solution {\\npublic:\\n    \\n    void rec(vector<int>& nums,int n,long long& ans,long long prod,int i,bool fl)\\n    {\\n        if(i<0)\\n        {\\n            if(fl)\\n               ans= max(ans,prod);\\n            \\n            return;\\n        }\\n        \\n        if(fl)\\n          { \\n            rec(nums,n,ans,prod*nums[i],i-1,true);\\n            rec(nums,n,ans,prod,i-1,true);\\n          }\\n\\n        else\\n        {\\n              rec(nums,n,ans,prod*nums[i],i-1,true);\\n              rec(nums,n,ans,prod,i-1,false);\\n        }\\n    }\\n    \\n    long long maxStrength(vector<int>& nums) {\\n        int n= nums.size();\\n        \\n        long long ans=INT_MIN;\\n        long long prod=1;\\n        \\n        rec(nums,n,ans,prod,n-1,false);\\n        \\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    void rec(vector<int>& nums,int n,long long& ans,long long prod,int i,bool fl)\\n    {\\n        if(i<0)\\n        {\\n            if(fl)\\n               ans= max(ans,prod);\\n            \\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3635514,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public long MaxStrength(int[] nums) {  \\n        if(nums.Length == 1) return nums[0];\\n\\n        long res= 0;\\n        var negative = new List<int>();\\n        var zero = 0;\\n        \\n        foreach(var n in nums){\\n            if(n != 0){\\n                if(res == 0)\\n                    res = n;\\n                else\\n                    res *= n;\\n                if(n < 0)\\n                    negative.Add(n);\\n            }               \\n            else\\n                zero++; \\n        }\\n\\n        if(zero == nums.Length - 1)\\n            return nums.Max();\\n\\n        negative.Sort();\\n         \\n        if(negative.Count % 2 != 0)\\n            res /=  negative[negative.Count - 1];\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long MaxStrength(int[] nums) {  \\n        if(nums.Length == 1) return nums[0];\\n\\n        long res= 0;\\n        var negative = new List<int>();\\n        var zero = 0;\\n        \\n        foreach(var n in nums){\\n            if(n != 0){\\n                if(res == 0)\\n                    res = n;\\n                else\\n                    res *= n;\\n                if(n < 0)\\n                    negative.Add(n);\\n            }               \\n            else\\n                zero++; \\n        }\\n\\n        if(zero == nums.Length - 1)\\n            return nums.Max();\\n\\n        negative.Sort();\\n         \\n        if(negative.Count % 2 != 0)\\n            res /=  negative[negative.Count - 1];\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634091,
                "title": "beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& v) {\\n        \\n\\nlong long pp=1,pn=1,c=0,m=-14,k=0;\\n         for(int i:v)\\n         {\\n            if (i>0)\\n                pp*=i;\\n            else if(i<0)\\n            {\\n                c++;\\n                pn*=i;\\n                if (i>m)\\n                  m=i;\\n            }\\n            else\\n             k++;\\n         }\\n         if ( ((c==1)&& (k) && (v.size()-c==k)) || (v.size()==k) )\\n            return(0);\\n         if(pn>0)\\n                return(pp*pn);\\n         else\\n         {\\n           if( (v.size()==1)&&(c==1) )\\n           m=1;\\n             return(pp*(pn/m));\\n         }\\n\\n\\n    };\\n\\n\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& v) {\\n        \\n\\nlong long pp=1,pn=1,c=0,m=-14,k=0;\\n         for(int i:v)\\n         {\\n            if (i>0)\\n                pp*=i;\\n            else if(i<0)\\n            {\\n                c++;\\n                pn*=i;\\n                if (i>m)\\n                  m=i;\\n            }\\n            else\\n             k++;\\n         }\\n         if ( ((c==1)&& (k) && (v.size()-c==k)) || (v.size()==k) )\\n            return(0);\\n         if(pn>0)\\n                return(pp*pn);\\n         else\\n         {\\n           if( (v.size()==1)&&(c==1) )\\n           m=1;\\n             return(pp*(pn/m));\\n         }\\n\\n\\n    };\\n\\n\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633700,
                "title": "sort-lot-of-if-s",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        if(nums.size()==1) return nums[0];\\n        sort(nums.begin(),nums.end());\\n        long long product=1; int cntneg=0; int cnt0=0;\\n        while(nums[cntneg]<0 && cntneg<nums.size()){\\n            product=product*nums[cntneg];\\n            cntneg++;\\n            if(cntneg==nums.size()) break;\\n        }\\n        if(cntneg%2!=0) product=product/nums[cntneg-1];\\n        for(int i=cntneg;i<nums.size();i++){\\n            if(nums[i]==0){\\n                cnt0++;\\n                continue;\\n            }\\n            product*=nums[i];\\n        }\\n        if( cntneg==1 && cnt0>0 && cnt0 + cntneg ==nums.size()) return 0;\\n        return cnt0==nums.size()? 0 : product ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        if(nums.size()==1) return nums[0];\\n        sort(nums.begin(),nums.end());\\n        long long product=1; int cntneg=0; int cnt0=0;\\n        while(nums[cntneg]<0 && cntneg<nums.size()){\\n            product=product*nums[cntneg];\\n            cntneg++;\\n            if(cntneg==nums.size()) break;\\n        }\\n        if(cntneg%2!=0) product=product/nums[cntneg-1];\\n        for(int i=cntneg;i<nums.size();i++){\\n            if(nums[i]==0){\\n                cnt0++;\\n                continue;\\n            }\\n            product*=nums[i];\\n        }\\n        if( cntneg==1 && cnt0>0 && cnt0 + cntneg ==nums.size()) return 0;\\n        return cnt0==nums.size()? 0 : product ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631770,
                "title": "c-faster-than-98-one-loop",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        long long res = -1, pos = 1, neg = 1;\\n        int posCnt = 0, negCnt = 0, maxNeg = INT_MIN;\\n        bool containsZero = false;\\n        for (int num : nums) {\\n            if (num > 0) {\\n                ++ posCnt;\\n                pos *= num;\\n            } else if (num < 0) {\\n                neg *= num;\\n                maxNeg = max(maxNeg, num);\\n                ++ negCnt;\\n            }\\n            else containsZero = true;\\n        }\\n        if (containsZero) res = 0;\\n        if (posCnt) res = pos;\\n        if (negCnt) {\\n            long long tmp = ((negCnt == 1 || negCnt % 2 == 0) ? neg : neg / maxNeg);\\n            if (res == -1) res = tmp;\\n            else if (res == 0 || tmp < 0) res = max(res, tmp);\\n            else res *= tmp;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        long long res = -1, pos = 1, neg = 1;\\n        int posCnt = 0, negCnt = 0, maxNeg = INT_MIN;\\n        bool containsZero = false;\\n        for (int num : nums) {\\n            if (num > 0) {\\n                ++ posCnt;\\n                pos *= num;\\n            } else if (num < 0) {\\n                neg *= num;\\n                maxNeg = max(maxNeg, num);\\n                ++ negCnt;\\n            }\\n            else containsZero = true;\\n        }\\n        if (containsZero) res = 0;\\n        if (posCnt) res = pos;\\n        if (negCnt) {\\n            long long tmp = ((negCnt == 1 || negCnt % 2 == 0) ? neg : neg / maxNeg);\\n            if (res == -1) res = tmp;\\n            else if (res == 0 || tmp < 0) res = max(res, tmp);\\n            else res *= tmp;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631135,
                "title": "python-o-n-log-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n\\n        if len(nums) == 1: return nums[0]\\n\\n        s = sorted(nums, key=lambda x: abs(x))\\n        cnt = 0\\n        for n in nums:\\n            if n<0:cnt +=1\\n        \\n        res = 1\\n        first = True\\n        calc = False\\n        for n in s:\\n            if n < 0 and first and cnt % 2 == 1:\\n                first = False\\n            elif abs(n) > 0:\\n                res = res * n\\n                calc = True\\n        \\n        if not calc: res = 0\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n\\n        if len(nums) == 1: return nums[0]\\n\\n        s = sorted(nums, key=lambda x: abs(x))\\n        cnt = 0\\n        for n in nums:\\n            if n<0:cnt +=1\\n        \\n        res = 1\\n        first = True\\n        calc = False\\n        for n in s:\\n            if n < 0 and first and cnt % 2 == 1:\\n                first = False\\n            elif abs(n) > 0:\\n                res = res * n\\n                calc = True\\n        \\n        if not calc: res = 0\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629572,
                "title": "straight-forward-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst you have to detremine the edge case\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst case you have to handle id length of array is 1 then just return the 0 index\\ncreate three variable\\nans=1\\nchange=0\\nneg=[]\\nzero=0\\nneg is used to store the negative number \\nchange is used to keep track of non negative number\\nzero is used to detect number of zeros in the array\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxStrength(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums)<=1:\\n            return nums[0]\\n        \\n        ans=1\\n        change=0\\n        neg=[]\\n        zero=0\\n        for i in nums:\\n            if i<0:\\n                neg.append(i)\\n            if i>0:\\n                ans*=i\\n                change+=1\\n            if i==0:\\n                zero+=1\\n        #print(ans)\\n        #if change is not greater than zero ten their were no poistive elemanets\\n        #if the value of zero is greater than 0 then zero exist and if it is equal to len of nums only zero exist\\n        if len(nums)==zero:\\n           # print(\"zero\")\\n            return 0\\n        \\n        neg=sorted(neg)\\n        if change==0 and zero>0:\\n            #print(\"condition active\")\\n            if len(neg)%2==0:\\n                for i in neg:\\n                    #print(i)\\n                    ans*=i\\n            elif len(neg)==1:\\n                ans*=neg[0]\\n            elif neg==[]:\\n                return 0\\n            else:\\n                for i in range(0,len(neg)-1):\\n                    ans*=neg[i]\\n            return max(0,ans)\\n        else:\\n            if len(neg)%2==0:\\n                for i in neg:\\n                    ans*=i\\n            else:\\n                for i in range(0,len(neg)-1):\\n                    ans*=neg[i]\\n        return  ans\\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxStrength(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums)<=1:\\n            return nums[0]\\n        \\n        ans=1\\n        change=0\\n        neg=[]\\n        zero=0\\n        for i in nums:\\n            if i<0:\\n                neg.append(i)\\n            if i>0:\\n                ans*=i\\n                change+=1\\n            if i==0:\\n                zero+=1\\n        #print(ans)\\n        #if change is not greater than zero ten their were no poistive elemanets\\n        #if the value of zero is greater than 0 then zero exist and if it is equal to len of nums only zero exist\\n        if len(nums)==zero:\\n           # print(\"zero\")\\n            return 0\\n        \\n        neg=sorted(neg)\\n        if change==0 and zero>0:\\n            #print(\"condition active\")\\n            if len(neg)%2==0:\\n                for i in neg:\\n                    #print(i)\\n                    ans*=i\\n            elif len(neg)==1:\\n                ans*=neg[0]\\n            elif neg==[]:\\n                return 0\\n            else:\\n                for i in range(0,len(neg)-1):\\n                    ans*=neg[i]\\n            return max(0,ans)\\n        else:\\n            if len(neg)%2==0:\\n                for i in neg:\\n                    ans*=i\\n            else:\\n                for i in range(0,len(neg)-1):\\n                    ans*=neg[i]\\n        return  ans\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628740,
                "title": "golang-dp-o-n-time-and-o-1-space",
                "content": "# Approach\\n\\nThis is very similar to finding maximum sum subarray using Kadane\\'s algorithm.\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n\\n# Code\\n\\n```\\nfunc maxStrength(nums []int) int64 {\\n  var prevMin, prevMax int64\\n  var currMin, currMax int64\\n  prevMin, prevMax = int64(nums[0]), int64(nums[0])\\n  for i := 1; i < len(nums); i++ {\\n    currMax = max(\\n      // We have 4 choices:\\n      // 1. Previous max * current, 2. Previous max alone\\n      // 3. Previous min * current, 4. Current alone\\n      max(prevMax * int64(nums[i]), prevMax),\\n      max(prevMin * int64(nums[i]), int64(nums[i])),\\n    )\\n    // Similar to the above we have 4 choices\\n    // 1. Previous max * current, 2. Previous min alone\\n    // 3. Previous min * current, 4. Current alone\\n    currMin = min(\\n      min(prevMax * int64(nums[i]), prevMin),\\n      min(prevMin * int64(nums[i]), int64(nums[i])),\\n    )\\n    prevMin, prevMax = currMin, currMax\\n  }\\n  return prevMax\\n}\\n\\nfunc min(a, b int64) int64 {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n\\nfunc max(a, b int64) int64 {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxStrength(nums []int) int64 {\\n  var prevMin, prevMax int64\\n  var currMin, currMax int64\\n  prevMin, prevMax = int64(nums[0]), int64(nums[0])\\n  for i := 1; i < len(nums); i++ {\\n    currMax = max(\\n      // We have 4 choices:\\n      // 1. Previous max * current, 2. Previous max alone\\n      // 3. Previous min * current, 4. Current alone\\n      max(prevMax * int64(nums[i]), prevMax),\\n      max(prevMin * int64(nums[i]), int64(nums[i])),\\n    )\\n    // Similar to the above we have 4 choices\\n    // 1. Previous max * current, 2. Previous min alone\\n    // 3. Previous min * current, 4. Current alone\\n    currMin = min(\\n      min(prevMax * int64(nums[i]), prevMin),\\n      min(prevMin * int64(nums[i]), int64(nums[i])),\\n    )\\n    prevMin, prevMax = currMin, currMax\\n  }\\n  return prevMax\\n}\\n\\nfunc min(a, b int64) int64 {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n\\nfunc max(a, b int64) int64 {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3627375,
                "title": "c-recursive-get-max-from-all-possible-subsets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem by two approach. \\n1. Generate all possible set and multiply set values\\n2. Sort the nums and linearly multiply values with considering edge cases. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- **`public void MultSet(int[] nums, int i, long cur, ref long? result)`** Function to recursively iterate over **all possible set**, \\n`int i` - Current index of iteration of set\\n`long cur` - equals to current set mult. state\\n`ref long? result`- store the global **maximum** of all all possible sets \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n\\n    public long MaxStrength(int[] nums) {\\n        long? result = null;\\n        MultSet(nums, -1, 1, ref result);\\n\\n        return result ?? 0;\\n    }\\n\\n    public void MultSet(int[] nums, int i, long cur, ref long? result) {\\n        if (i >= nums.Length) return;\\n\\n        if (i >= 0) {\\n            cur *= nums[i];\\n            if (result is null) result = cur;\\n\\n            result = Math.Max(result.Value, cur);\\n        }\\n\\n\\n        for (int curIdx = i + 1; curIdx < nums.Length; curIdx++) {\\n            MultSet(nums, curIdx, cur, ref result);\\n        }\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "C#",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n\\n    public long MaxStrength(int[] nums) {\\n        long? result = null;\\n        MultSet(nums, -1, 1, ref result);\\n\\n        return result ?? 0;\\n    }\\n\\n    public void MultSet(int[] nums, int i, long cur, ref long? result) {\\n        if (i >= nums.Length) return;\\n\\n        if (i >= 0) {\\n            cur *= nums[i];\\n            if (result is null) result = cur;\\n\\n            result = Math.Max(result.Value, cur);\\n        }\\n\\n\\n        for (int curIdx = i + 1; curIdx < nums.Length; curIdx++) {\\n            MultSet(nums, curIdx, cur, ref result);\\n        }\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627067,
                "title": "python-o-n-time-o-1-space-no-sort-just-counting",
                "content": "Was thinking about something else, but then it does not app up. Still have not found a case when greedy fails.\\nBtw, this is the first time I see constraints guiding you in the **wrong** direction.\\n\\nThe idea is to find a few details about the input:\\n1. Has `0`?\\n`-5,0` should return `-5` and not `0`\\n2. How many `positive` and `negative` nums?\\n`0 -> 0`\\n`0,0 -> 0`\\n`0,5 -> 5`\\n`-5,0 -> 0`\\n`-5,-4,0 -> 20`\\n`-5,-4,-3,0 -> 20`, here we throw away `max_negative number = -3`\\n3. Has `even` or `odd` number of negative numbers?\\n`-1,2 -> 2`\\n`-1,-2,2 -> 4`\\n\\nFind `max negative number` that you can throw away when you have `odd` negatives count \\n\\nYou can sort it, but you don\\'t need it.\\n\\n```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        \"\"\"\\n        group = set\\n        \\n        -9 <= [i] <= 9, edge cases for neg and 0\\n        1 <= max_len <= 13, backtracking but smells like greedy???\\n\\n        examples:\\n        -3 -2 -1 -> -3 -2\\n        -2 -1 -> 2\\n        -3 -2 -1 1 2 3 -> -3 -2 1 2 3\\n        -1 1 2 3 -> 1 2 3\\n        -1 -> -1\\n         0 -> 0\\n         0 0 -> 0\\n    !    0 -1 -> 0\\n        -3 -2 1 0 -> -3 -2 1\\n        -3  2 5 0 -> 2 5\\n        \"\"\"\\n        negative_count = 0\\n        positive_count = 0\\n        has_zero = False\\n        max_negative_num = float(-inf)\\n        max_res = 1\\n        for i,num in enumerate(nums):\\n            negative_count += num < 0\\n            positive_count += num > 0\\n            has_zero |= num == 0\\n            if num != 0: # -5 -5 -1 -1 0 1 or -5 -5 -1 0 1\\n                max_res *= num\\n            if num < 0:\\n                max_negative_num = max(max_negative_num, num)\\n        if negative_count == 0 and positive_count == 0: # 0 or 0,0\\n            return 0\\n        if negative_count == 1 and positive_count == 0: # -5 or -5,0\\n            max_res = max_negative_num\\n        elif negative_count % 2: # revert max_negative for odd negative counts -5,1\\n            max_res //= max_negative_num\\n        return max(max_res, 0) if has_zero else max_res\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        \"\"\"\\n        group = set\\n        \\n        -9 <= [i] <= 9, edge cases for neg and 0\\n        1 <= max_len <= 13, backtracking but smells like greedy???\\n\\n        examples:\\n        -3 -2 -1 -> -3 -2\\n        -2 -1 -> 2\\n        -3 -2 -1 1 2 3 -> -3 -2 1 2 3\\n        -1 1 2 3 -> 1 2 3\\n        -1 -> -1\\n         0 -> 0\\n         0 0 -> 0\\n    !    0 -1 -> 0\\n        -3 -2 1 0 -> -3 -2 1\\n        -3  2 5 0 -> 2 5\\n        \"\"\"\\n        negative_count = 0\\n        positive_count = 0\\n        has_zero = False\\n        max_negative_num = float(-inf)\\n        max_res = 1\\n        for i,num in enumerate(nums):\\n            negative_count += num < 0\\n            positive_count += num > 0\\n            has_zero |= num == 0\\n            if num != 0: # -5 -5 -1 -1 0 1 or -5 -5 -1 0 1\\n                max_res *= num\\n            if num < 0:\\n                max_negative_num = max(max_negative_num, num)\\n        if negative_count == 0 and positive_count == 0: # 0 or 0,0\\n            return 0\\n        if negative_count == 1 and positive_count == 0: # -5 or -5,0\\n            max_res = max_negative_num\\n        elif negative_count % 2: # revert max_negative for odd negative counts -5,1\\n            max_res //= max_negative_num\\n        return max(max_res, 0) if has_zero else max_res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623139,
                "title": "just-watch-out-corner-cases-easy-solution-o-n-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        if len(nums)==1:\\n            return nums[0]\\n        re=1\\n        neg = float(\\'-inf\\')\\n        neg_n= 0\\n        pos_n=0\\n        for i in nums:\\n            if i>0:\\n                pos_n+=1\\n                re*=i\\n            elif i<0:\\n                neg_n+=1\\n                if i>neg:\\n                    \\n                    neg = i\\n                re*=(-1*i)\\n            \\n        if pos_n!=0 or neg_n>1:\\n            if neg_n%2!=0:\\n                return int(re/(-1*neg))\\n            else:\\n                return int(re)\\n        else:\\n            return 0\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        if len(nums)==1:\\n            return nums[0]\\n        re=1\\n        neg = float(\\'-inf\\')\\n        neg_n= 0\\n        pos_n=0\\n        for i in nums:\\n            if i>0:\\n                pos_n+=1\\n                re*=i\\n            elif i<0:\\n                neg_n+=1\\n                if i>neg:\\n                    \\n                    neg = i\\n                re*=(-1*i)\\n            \\n        if pos_n!=0 or neg_n>1:\\n            if neg_n%2!=0:\\n                return int(re/(-1*neg))\\n            else:\\n                return int(re)\\n        else:\\n            return 0\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620454,
                "title": "c-solution-using-sorting-simple-and-easy-way",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int n=nums.size();\\n        long long int ans=1,ans1=1;\\n        int res=INT_MIN;\\n        int neg_count=0,pos_count=0;\\n        if(n==1)\\n            return nums[0];\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                ans*=nums[i];\\n                pos_count++;\\n            }\\n            if(nums[i]<0)\\n            {\\n                ans1*=nums[i];\\n                neg_count++;\\n            }\\n            if(nums[i]<0)\\n                res=max(res,nums[i]);\\n        }\\n        if(ans1<1)\\n            ans1/=res;\\n\\n        if(neg_count<2 && pos_count<1)\\n            return 0;\\n           \\n        return ans1*ans;\\n\\n    }\\n};\\n```\\nHope you understand the solution.",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int n=nums.size();\\n        long long int ans=1,ans1=1;\\n        int res=INT_MIN;\\n        int neg_count=0,pos_count=0;\\n        if(n==1)\\n            return nums[0];\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]>0)\\n            {\\n                ans*=nums[i];\\n                pos_count++;\\n            }\\n            if(nums[i]<0)\\n            {\\n                ans1*=nums[i];\\n                neg_count++;\\n            }\\n            if(nums[i]<0)\\n                res=max(res,nums[i]);\\n        }\\n        if(ans1<1)\\n            ans1/=res;\\n\\n        if(neg_count<2 && pos_count<1)\\n            return 0;\\n           \\n        return ans1*ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620120,
                "title": "c-easy-solution-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        vector<int>neg;\\n        long long ans = 1;\\n        bool positive=false;\\n        bool negative=false;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<0){\\n                negative=true;\\n                neg.push_back(nums[i]);\\n            }\\n            if(nums[i]>0){\\n                positive=true;\\n                ans*=nums[i];\\n            }\\n        }\\n        sort(neg.begin(),neg.end());\\n        if(neg.size()%2==0){\\n            for(int i=0;i<neg.size();i++){\\n                ans*=abs(neg[i]);\\n            }\\n        }\\n        else{\\n            for(int i=0;i<neg.size()-1;i++){\\n                ans*=abs(neg[i]);\\n            }\\n        }\\n        if(positive==false && negative==false){\\n            return 0;\\n        }\\n        if(neg.size()==1 && positive==false && nums.size()>1){\\n            return 0;\\n        }\\n        if(neg.size()==1 && nums.size()==1){\\n            return nums[0];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        vector<int>neg;\\n        long long ans = 1;\\n        bool positive=false;\\n        bool negative=false;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]<0){\\n                negative=true;\\n                neg.push_back(nums[i]);\\n            }\\n            if(nums[i]>0){\\n                positive=true;\\n                ans*=nums[i];\\n            }\\n        }\\n        sort(neg.begin(),neg.end());\\n        if(neg.size()%2==0){\\n            for(int i=0;i<neg.size();i++){\\n                ans*=abs(neg[i]);\\n            }\\n        }\\n        else{\\n            for(int i=0;i<neg.size()-1;i++){\\n                ans*=abs(neg[i]);\\n            }\\n        }\\n        if(positive==false && negative==false){\\n            return 0;\\n        }\\n        if(neg.size()==1 && positive==false && nums.size()>1){\\n            return 0;\\n        }\\n        if(neg.size()==1 && nums.size()==1){\\n            return nums[0];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616713,
                "title": "100-tc-java-new-different-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        long pod=1;\\n    int largestNeg=Integer.MIN_VALUE;\\n    int largest=Integer.MIN_VALUE;\\n   int negCount=0;\\n\\n    for(int num: nums){\\n        if(num!=0) pod*=num;\\n        if(num<0){\\n            largestNeg=Math.max(largestNeg,num);\\n            negCount++;\\n        }\\n        largest =Math.max(largest,num);\\n    }\\n    if(largest ==0 && negCount<2) return 0;\\n    if(largest<0 && negCount==1) return largestNeg;\\n    if(pod>0) return pod;\\n    return pod/largestNeg;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        long pod=1;\\n    int largestNeg=Integer.MIN_VALUE;\\n    int largest=Integer.MIN_VALUE;\\n   int negCount=0;\\n\\n    for(int num: nums){\\n        if(num!=0) pod*=num;\\n        if(num<0){\\n            largestNeg=Math.max(largestNeg,num);\\n            negCount++;\\n        }\\n        largest =Math.max(largest,num);\\n    }\\n    if(largest ==0 && negCount<2) return 0;\\n    if(largest<0 && negCount==1) return largestNeg;\\n    if(pod>0) return pod;\\n    return pod/largestNeg;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616570,
                "title": "simple-python-solution-beats-98-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe first sort the array. We simply multiply all the positive numbers and multiply two largest negative numbers in pairs.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Take some edge cases like if the array has a single element, and if there is one negative number all others are 0.\\n2. Go though the sorted array. Multiply two largest in magnitude negative numbers in pairs so that the result remains positive.\\n3. Simply multiply if the number is positive.\\n4. If 0, just increment the index. \\n\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxStrength(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        if len(nums)==1: return nums[0]\\n        if nums[1]==0 and nums[-1]==0: return 0\\n        i=0\\n        ans=1\\n        while(i<len(nums)):\\n            if nums[i]>0:\\n                ans*=nums[i]\\n                i+=1\\n            elif i<len(nums)-1 and nums[i]<0 and nums[i+1]<0:\\n                ans*=nums[i]*nums[i+1]\\n                i+=2\\n            else: i+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxStrength(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        if len(nums)==1: return nums[0]\\n        if nums[1]==0 and nums[-1]==0: return 0\\n        i=0\\n        ans=1\\n        while(i<len(nums)):\\n            if nums[i]>0:\\n                ans*=nums[i]\\n                i+=1\\n            elif i<len(nums)-1 and nums[i]<0 and nums[i+1]<0:\\n                ans*=nums[i]*nums[i+1]\\n                i+=2\\n            else: i+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615686,
                "title": "simple-o-n-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        int maxNegative = Integer.MIN_VALUE;\\n        int maxVal = Integer.MIN_VALUE;\\n        long result = 0;\\n\\n        for (int num : nums) {\\n            if (num < 0 && num > maxNegative) {\\n                maxNegative = num;\\n            }\\n\\n            if (num > maxVal) {\\n                maxVal = num;\\n            }\\n\\n            if (num != 0) {\\n                result = result == 0\\n                        ? num\\n                        : result * num;\\n            }\\n        }\\n        \\n        if (result < 0) {\\n            result = result / maxNegative;\\n\\n            return result == 1 ? Math.min(result, maxVal) : result;\\n        } else {\\n            return result;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        int maxNegative = Integer.MIN_VALUE;\\n        int maxVal = Integer.MIN_VALUE;\\n        long result = 0;\\n\\n        for (int num : nums) {\\n            if (num < 0 && num > maxNegative) {\\n                maxNegative = num;\\n            }\\n\\n            if (num > maxVal) {\\n                maxVal = num;\\n            }\\n\\n            if (num != 0) {\\n                result = result == 0\\n                        ? num\\n                        : result * num;\\n            }\\n        }\\n        \\n        if (result < 0) {\\n            result = result / maxNegative;\\n\\n            return result == 1 ? Math.min(result, maxVal) : result;\\n        } else {\\n            return result;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615547,
                "title": "rust-python-linear-time-with-detailed-explanation",
                "content": "# Intuition\\n\\nLets assume that the values are only positive (1 and above). Then maximum score is just product of all values. Now lets add negative numbers into a mix. Because any two negative numbers give positive product, at best we need to remove one number of the list to get the biggest product.\\n\\nSo if we have negative numbers we need to remove one number. Which number should we remove? The biggest negative numbers.\\n\\nNow what if we have zeros as well. If we could have allowed to have empty groups, we could have just removed them. So you need to select at least something (even if it is zero or negative).\\n\\nSo we have a couple of edge cases. \\n\\n - if all the values are zeros. Then the answer is zero\\n - if after removing of all zeros, you have only one number, then it is this number or zero\\n\\nIt is possible to do this in one loop, but it becomes ugly, so I have done it via a few steps.\\n\\n-----------------\\n\\nOf course this all relies on ability to multiply numbers in linear time. Which unfortunately is not the case in general as the product will accumulate and will be too big. \\n\\nIn a mathematical sense you can use logarithms. This is why you see logs so often in ML as $\\\\log \\\\prod a_i = \\\\sum \\\\log a_i$\\n\\nIf you have infinite precision, then you can just sum logarithms. \\n\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n\\n# Code\\n```Rust []\\nimpl Solution {\\n  pub fn max_strength(nums: Vec<i32>) -> i64 {\\n    let mut non_zeros = Vec::new();\\n    let mut is_zero = false;\\n\\n    for v in nums {\\n      if v != 0 {\\n        non_zeros.push(v);\\n      } else {\\n        is_zero = true;\\n      }\\n    }\\n\\n    if non_zeros.is_empty() {\\n      return 0;\\n    }\\n\\n    if non_zeros.len() == 1 {\\n      if is_zero {\\n        return 0.max(non_zeros[0]) as i64;\\n      }\\n      return non_zeros[0] as i64;\\n    }\\n\\n    let mut prod = 1i64;\\n    let mut max_neg = -100;\\n    for v in non_zeros {\\n      prod *= v as i64;\\n      if v < 0 {\\n        max_neg = max_neg.max(v);\\n      }\\n    }\\n\\n    if prod > 0 {\\n      return prod;\\n    }\\n\\n    return prod / (max_neg as i64);\\n  }\\n}\\n```\\n```python []\\nclass Solution:\\n  def maxStrength(self, nums: List[int]) -> int:\\n    non_zeros, is_zero = [], False\\n    for v in nums:\\n      if v != 0:\\n        non_zeros.append(v)\\n      else:\\n        is_zero = True\\n    \\n    if not non_zeros:\\n      return 0\\n\\n    if len(non_zeros) == 1:\\n      return max(non_zeros[0], 0) if is_zero else non_zeros[0]\\n\\n    prod, max_neg = 1, -float(\\'inf\\')\\n    for v in non_zeros:\\n      prod *= v\\n      if v < 0:\\n        max_neg = max(max_neg, v)\\n  \\n    if prod > 0:\\n      return prod\\n\\n    return prod // max_neg\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```Rust []\\nimpl Solution {\\n  pub fn max_strength(nums: Vec<i32>) -> i64 {\\n    let mut non_zeros = Vec::new();\\n    let mut is_zero = false;\\n\\n    for v in nums {\\n      if v != 0 {\\n        non_zeros.push(v);\\n      } else {\\n        is_zero = true;\\n      }\\n    }\\n\\n    if non_zeros.is_empty() {\\n      return 0;\\n    }\\n\\n    if non_zeros.len() == 1 {\\n      if is_zero {\\n        return 0.max(non_zeros[0]) as i64;\\n      }\\n      return non_zeros[0] as i64;\\n    }\\n\\n    let mut prod = 1i64;\\n    let mut max_neg = -100;\\n    for v in non_zeros {\\n      prod *= v as i64;\\n      if v < 0 {\\n        max_neg = max_neg.max(v);\\n      }\\n    }\\n\\n    if prod > 0 {\\n      return prod;\\n    }\\n\\n    return prod / (max_neg as i64);\\n  }\\n}\\n```\n```python []\\nclass Solution:\\n  def maxStrength(self, nums: List[int]) -> int:\\n    non_zeros, is_zero = [], False\\n    for v in nums:\\n      if v != 0:\\n        non_zeros.append(v)\\n      else:\\n        is_zero = True\\n    \\n    if not non_zeros:\\n      return 0\\n\\n    if len(non_zeros) == 1:\\n      return max(non_zeros[0], 0) if is_zero else non_zeros[0]\\n\\n    prod, max_neg = 1, -float(\\'inf\\')\\n    for v in non_zeros:\\n      prod *= v\\n      if v < 0:\\n        max_neg = max(max_neg, v)\\n  \\n    if prod > 0:\\n      return prod\\n\\n    return prod // max_neg\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3612754,
                "title": "greedy-solution-sort-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing DP can be expensive here, so better use greedy solution to sort.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nyou need to pick all positive numbers for sure. And pick only first even greatest negative numbers. Thats the strategy. simple. :)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        if(nums.length == 1 && nums[0]<0)\\n            return nums[0];\\n        Arrays.sort(nums);\\n        int negCount = 0;\\n        int smallestNeg= -1;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]<0)\\n            { \\n              negCount++;\\n              smallestNeg = i;\\n            }\\n            if(nums[i]>=0)\\n                break;\\n        }\\n        long res =0 ;\\n        if(negCount%2==0){\\n            for(int i=0; i<nums.length; i++)\\n            {\\n                if(nums[i]!=0){\\n                    if(res==0)\\n                        res = (long)nums[i];\\n                    else  res = res * (long)nums[i];\\n                }\\n                 \\n            }    \\n        } else {\\n            for(int i=0; i<nums.length; i++){\\n                if(nums[i]!=0 && i!=smallestNeg){\\n                    if(res==0)\\n                        res = (long)nums[i];\\n                    else res = res * (long)nums[i];\\n                }\\n            \\n            }\\n        }\\n        return res;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        if(nums.length == 1 && nums[0]<0)\\n            return nums[0];\\n        Arrays.sort(nums);\\n        int negCount = 0;\\n        int smallestNeg= -1;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]<0)\\n            { \\n              negCount++;\\n              smallestNeg = i;\\n            }\\n            if(nums[i]>=0)\\n                break;\\n        }\\n        long res =0 ;\\n        if(negCount%2==0){\\n            for(int i=0; i<nums.length; i++)\\n            {\\n                if(nums[i]!=0){\\n                    if(res==0)\\n                        res = (long)nums[i];\\n                    else  res = res * (long)nums[i];\\n                }\\n                 \\n            }    \\n        } else {\\n            for(int i=0; i<nums.length; i++){\\n                if(nums[i]!=0 && i!=smallestNeg){\\n                    if(res==0)\\n                        res = (long)nums[i];\\n                    else res = res * (long)nums[i];\\n                }\\n            \\n            }\\n        }\\n        return res;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610863,
                "title": "sort-the-negative-numbers-and-keep-an-even-number-of-smallest-ones",
                "content": "# Code\\n```\\ndef maxStrength(self, nums: List[int]) -> int:\\n    negs = sorted([x for x in nums if x < 0])\\n    poss = [x for x in nums if x > 0]\\n    if len(nums) == 1:\\n        return nums[0]\\n    negs = negs[0:(len(negs)//2*2)]\\n    if len(negs) == 0 and len(poss) == 0:\\n        return 0\\n    ret = 1\\n    for x in negs:\\n        ret *= x\\n    for x in poss:\\n        ret *= x\\n    return ret\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef maxStrength(self, nums: List[int]) -> int:\\n    negs = sorted([x for x in nums if x < 0])\\n    poss = [x for x in nums if x > 0]\\n    if len(nums) == 1:\\n        return nums[0]\\n    negs = negs[0:(len(negs)//2*2)]\\n    if len(negs) == 0 and len(poss) == 0:\\n        return 0\\n    ret = 1\\n    for x in negs:\\n        ret *= x\\n    for x in poss:\\n        ret *= x\\n    return ret\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3610451,
                "title": "c-short-and-simple-solution",
                "content": "# Approach\\nWe simply perform a recursive take or not-take while maintaining a variable for the product.\\n\\n# Complexity\\n- Time complexity: $$O(2^n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> curr;\\n    \\n    long long f(int index, vector<int>& nums, long long prod){\\n        if(index >= nums.size()){\\n            return prod;\\n        }\\n        long long ans = f(index + 1, nums, prod);\\n        ans = max(ans, f(index + 1, nums, (prod == INT_MIN ? nums[index] : prod*nums[index])));\\n        return ans;\\n    }\\n    \\n    long long maxStrength(vector<int>& nums) {\\n        return f(0, nums, INT_MIN);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> curr;\\n    \\n    long long f(int index, vector<int>& nums, long long prod){\\n        if(index >= nums.size()){\\n            return prod;\\n        }\\n        long long ans = f(index + 1, nums, prod);\\n        ans = max(ans, f(index + 1, nums, (prod == INT_MIN ? nums[index] : prod*nums[index])));\\n        return ans;\\n    }\\n    \\n    long long maxStrength(vector<int>& nums) {\\n        return f(0, nums, INT_MIN);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608299,
                "title": "c-solution-for-beginners",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), m = 0, p = 0, m_last = -1;\\n        long long product = 1;\\n        for (auto& num : nums) {\\n            if (num < 0) {\\n                m++;\\n                m_last++;\\n            } else if (num > 0) {\\n                p++;\\n                product *= num;\\n            }\\n        }\\n        for (int i = 0; i < m_last; i += 2) {\\n            product *= nums[i] * nums[i + 1];\\n        }\\n\\n        if (product == 1 && p == 0 && m <= 1) return nums[n - 1];\\n\\n        return product;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), m = 0, p = 0, m_last = -1;\\n        long long product = 1;\\n        for (auto& num : nums) {\\n            if (num < 0) {\\n                m++;\\n                m_last++;\\n            } else if (num > 0) {\\n                p++;\\n                product *= num;\\n            }\\n        }\\n        for (int i = 0; i < m_last; i += 2) {\\n            product *= nums[i] * nums[i + 1];\\n        }\\n\\n        if (product == 1 && p == 0 && m <= 1) return nums[n - 1];\\n\\n        return product;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606620,
                "title": "java-3ms-clean-and-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. In order to pick up the best group, you need to consider the edge cases\\n    - Do you have an odd or even number of negative numbers? If even, then all must be multiplied\\n    - If odd, you need to ditch the largest negative: eg: -6,-5,-2: Selecting -6 * -5 renders 30\\n    - Do you have only one negative number and 0 ? 0 is the best answer\\n2. Count the negative and 0 nums. Also sort them\\n3. From index i = 0 to last one\\n    - If number is negative and you have an even number of negative nums OR (odd number of negatives and their remaining count > 1), multiply that number.\\n    - If number if > 0, multiply it no matter what.\\n4. Also use a boolean flag to mark if number has been modified (or you can use the count of negative + zeroes)\\n    - If yes, return it\\n    - if No, check if you have a single negative and zero (to return 0) or just the single number in list.  \\n\\n# Complexity\\n- Time complexity:$$O(n(log n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        Arrays.sort(nums);\\n        // count negtives and zeroes\\n        int[] signCount = getSignCount(nums);\\n        long maxStrength = 1L;\\n        boolean multiplied = false;\\n        boolean hasOddNegatives = signCount[0] % 2 == 1;\\n        for (int num : nums) {\\n            if (num < 0) {\\n                if (!hasOddNegatives || (hasOddNegatives && signCount[0] > 1)) {\\n                    maxStrength *= num;\\n                    signCount[0]--;\\n                    multiplied = true;\\n                }\\n            } else if (num > 0) {\\n                maxStrength *= num;\\n                multiplied = true;\\n            }\\n        }\\n        return multiplied ? maxStrength : signCount[1] == 0 ? nums[0] : 0;\\n    }\\n\\n    private int[] getSignCount(int[] nums) {\\n        int[] signCount = new int[2];\\n        for (int num : nums) {\\n            if (num < 0) {\\n                signCount[0]++;\\n            } else if (num == 0) {\\n                signCount[1]++;\\n            }\\n        }\\n        return signCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxStrength(int[] nums) {\\n        Arrays.sort(nums);\\n        // count negtives and zeroes\\n        int[] signCount = getSignCount(nums);\\n        long maxStrength = 1L;\\n        boolean multiplied = false;\\n        boolean hasOddNegatives = signCount[0] % 2 == 1;\\n        for (int num : nums) {\\n            if (num < 0) {\\n                if (!hasOddNegatives || (hasOddNegatives && signCount[0] > 1)) {\\n                    maxStrength *= num;\\n                    signCount[0]--;\\n                    multiplied = true;\\n                }\\n            } else if (num > 0) {\\n                maxStrength *= num;\\n                multiplied = true;\\n            }\\n        }\\n        return multiplied ? maxStrength : signCount[1] == 0 ? nums[0] : 0;\\n    }\\n\\n    private int[] getSignCount(int[] nums) {\\n        int[] signCount = new int[2];\\n        for (int num : nums) {\\n            if (num < 0) {\\n                signCount[0]++;\\n            } else if (num == 0) {\\n                signCount[1]++;\\n            }\\n        }\\n        return signCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603593,
                "title": "very-easy-c-solution-for-beginners-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# sort the array and skip the greater negative number\\n\\n# Complexity\\n# - Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# - Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        long long mul=1;\\n        int negativecount=0,negativeflag=0,countflag=0;\\n        if(nums.size()==1)\\n        {\\n            return nums[0];\\n        }\\n        sort(nums.begin(),nums.end());\\n       \\n       for(int i=0;i<nums.size();i++)   //count negative number\\n        {\\n            if(nums[i]<0)\\n                negativecount++;\\n        }\\n      \\n       if(negativecount%2==1)   //if number of negative number is odd \\n         {\\n             negativecount--;\\n             negativeflag=1;\\n         }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n                                  \\n           if(i==negativecount && negativeflag==1 )  //skip greater negative number\\n               continue;\\n          else if(nums[i]==0)  //skip zero \\n               continue;\\n          else{\\n            mul*=nums[i];\\n            countflag=1; \\n           }\\n        }\\n        if(mul==1 && countflag==0) //if no element inter in else condition than result should we zero\\n            mul=0;\\n            \\n        return mul;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        long long mul=1;\\n        int negativecount=0,negativeflag=0,countflag=0;\\n        if(nums.size()==1)\\n        {\\n            return nums[0];\\n        }\\n        sort(nums.begin(),nums.end());\\n       \\n       for(int i=0;i<nums.size();i++)   //count negative number\\n        {\\n            if(nums[i]<0)\\n                negativecount++;\\n        }\\n      \\n       if(negativecount%2==1)   //if number of negative number is odd \\n         {\\n             negativecount--;\\n             negativeflag=1;\\n         }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n                                  \\n           if(i==negativecount && negativeflag==1 )  //skip greater negative number\\n               continue;\\n          else if(nums[i]==0)  //skip zero \\n               continue;\\n          else{\\n            mul*=nums[i];\\n            countflag=1; \\n           }\\n        }\\n        if(mul==1 && countflag==0) //if no element inter in else condition than result should we zero\\n            mul=0;\\n            \\n        return mul;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603368,
                "title": "easy-understanding-simple-greedy-approach-o-n-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        \\n        long long negative = 1,positive = 1,count_0 = 0,count_n = 0;\\n        int n = nums.size();\\n        \\n        // if n == 1 simply return nums[0] \\n        if( n == 1) return nums[0];\\n        \\n        // max_negative use to track maximum negative element \\n        int max_negative = INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i] == 0)\\n            {\\n                count_0++;\\n            }else if(nums[i]>0)\\n            {\\n               positive *= nums[i];\\n            }else{\\n               negative *= nums[i];\\n               count_n++;\\n               max_negative = max(max_negative,nums[i]);\\n            }\\n            \\n        }\\n        \\n        // when all  element are zero\\n        if(count_0 == n) return 0;\\n        \\n        // handle cases like [0,0,0,-1]\\n        if(count_0 == n-1 && count_n == 1) return 0;\\n        \\n        // if negative element are lie in odd numbers\\n        if(negative<0)\\n        {\\n            negative /= max_negative;\\n        }\\n        \\n        return negative * positive;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        \\n        long long negative = 1,positive = 1,count_0 = 0,count_n = 0;\\n        int n = nums.size();\\n        \\n        // if n == 1 simply return nums[0] \\n        if( n == 1) return nums[0];\\n        \\n        // max_negative use to track maximum negative element \\n        int max_negative = INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i] == 0)\\n            {\\n                count_0++;\\n            }else if(nums[i]>0)\\n            {\\n               positive *= nums[i];\\n            }else{\\n               negative *= nums[i];\\n               count_n++;\\n               max_negative = max(max_negative,nums[i]);\\n            }\\n            \\n        }\\n        \\n        // when all  element are zero\\n        if(count_0 == n) return 0;\\n        \\n        // handle cases like [0,0,0,-1]\\n        if(count_0 == n-1 && count_n == 1) return 0;\\n        \\n        // if negative element are lie in odd numbers\\n        if(negative<0)\\n        {\\n            negative /= max_negative;\\n        }\\n        \\n        return negative * positive;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1909790,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "The best testcase\\n```[0,-1]```"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "Indeed, I was able to solve by looking at this test case. Thankss..."
                    },
                    {
                        "username": "hail-cali",
                        "content": "True "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Don\\'t like when I need a lot of ```if-else```"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Drop the count of Wrong answer you got in this problem."
                    },
                    {
                        "username": "user9133dZ",
                        "content": "18 , did\\'nt expect it to be this complicated"
                    },
                    {
                        "username": "prabhashbhajani",
                        "content": "2, I\\'m happy with that"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "23 lmao.  This one was torture for me :("
                    },
                    {
                        "username": "ammarkhan575",
                        "content": "6 \\uD83D\\uDE3F"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "3 and a lot of frustration"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "only 2, I was very happy, and then I went to do the second problem of the contest and utterly failed"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "10 - 15 I lost count "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "T_T 5"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "20 WA \\uD83E\\uDD72"
                    },
                    {
                        "username": "ankush6014",
                        "content": ":( :( -6"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) Same :/ Next time I\\'ll probably try testing on custom testcases instead of official ones xD"
                    },
                    {
                        "username": "laticm",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) 10\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary)  mine 2"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Mine - 6 "
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "I hate negative numbers."
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Why dp won\\'t work here :    Since , using dp we will be following pick , not pick approach taking a subset of the array giving us the maximum product from that subset but it is possible that even negative product taken from that subset will combine with other negatives to form a positive product , so it is not suitable to use dp as it can give wrong answers \\n"
                    },
                    {
                        "username": "enigma_007",
                        "content": "The description should be better like for cases of [0,7] gave a result of 7 and I got a WA as i was printing 0.  Thankfully brute force came to rescue after 5 WA atleast"
                    },
                    {
                        "username": "laticm",
                        "content": "greedy worked for me"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Brute force worked here XD"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Why brute force backtracking algorithm by pick and not-pick method fails in below case. The subsets found using brute force method will contain one subset where it will consider all elements.\\n\\nnums: `[6,-3,-4,8,4,7,6,4,7,7,-3,-6,9]`\\noutput: `768144384`\\nexpected output: `3072577536` "
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int n=nums.size();\\n        long long  count=0;\\n        for(int i=0;i<n;i++)\\n        if(nums[i]<0) count++;\\n        long long ans=1;\\n        for(int i=0;i<n;i++){\\n            if(count%2==0){\\n                if(nums[i]==0) continue;\\n                else ans*=nums[i];\\n            }\\n            {\\n                long long  x=count-1;\\n                while(x--){\\n                    long long k=*min_element(nums.begin(),nums.end());\\n                    ans*=k;\\n                }\\n                if(nums[i]>0) ans*=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nwhat is wrong in this solution for the given problem?"
                    }
                ]
            },
            {
                "id": 1909801,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "The best testcase\\n```[0,-1]```"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "Indeed, I was able to solve by looking at this test case. Thankss..."
                    },
                    {
                        "username": "hail-cali",
                        "content": "True "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Don\\'t like when I need a lot of ```if-else```"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Drop the count of Wrong answer you got in this problem."
                    },
                    {
                        "username": "user9133dZ",
                        "content": "18 , did\\'nt expect it to be this complicated"
                    },
                    {
                        "username": "prabhashbhajani",
                        "content": "2, I\\'m happy with that"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "23 lmao.  This one was torture for me :("
                    },
                    {
                        "username": "ammarkhan575",
                        "content": "6 \\uD83D\\uDE3F"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "3 and a lot of frustration"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "only 2, I was very happy, and then I went to do the second problem of the contest and utterly failed"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "10 - 15 I lost count "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "T_T 5"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "20 WA \\uD83E\\uDD72"
                    },
                    {
                        "username": "ankush6014",
                        "content": ":( :( -6"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) Same :/ Next time I\\'ll probably try testing on custom testcases instead of official ones xD"
                    },
                    {
                        "username": "laticm",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) 10\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary)  mine 2"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Mine - 6 "
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "I hate negative numbers."
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Why dp won\\'t work here :    Since , using dp we will be following pick , not pick approach taking a subset of the array giving us the maximum product from that subset but it is possible that even negative product taken from that subset will combine with other negatives to form a positive product , so it is not suitable to use dp as it can give wrong answers \\n"
                    },
                    {
                        "username": "enigma_007",
                        "content": "The description should be better like for cases of [0,7] gave a result of 7 and I got a WA as i was printing 0.  Thankfully brute force came to rescue after 5 WA atleast"
                    },
                    {
                        "username": "laticm",
                        "content": "greedy worked for me"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Brute force worked here XD"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Why brute force backtracking algorithm by pick and not-pick method fails in below case. The subsets found using brute force method will contain one subset where it will consider all elements.\\n\\nnums: `[6,-3,-4,8,4,7,6,4,7,7,-3,-6,9]`\\noutput: `768144384`\\nexpected output: `3072577536` "
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int n=nums.size();\\n        long long  count=0;\\n        for(int i=0;i<n;i++)\\n        if(nums[i]<0) count++;\\n        long long ans=1;\\n        for(int i=0;i<n;i++){\\n            if(count%2==0){\\n                if(nums[i]==0) continue;\\n                else ans*=nums[i];\\n            }\\n            {\\n                long long  x=count-1;\\n                while(x--){\\n                    long long k=*min_element(nums.begin(),nums.end());\\n                    ans*=k;\\n                }\\n                if(nums[i]>0) ans*=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nwhat is wrong in this solution for the given problem?"
                    }
                ]
            },
            {
                "id": 1907414,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "The best testcase\\n```[0,-1]```"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "Indeed, I was able to solve by looking at this test case. Thankss..."
                    },
                    {
                        "username": "hail-cali",
                        "content": "True "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Don\\'t like when I need a lot of ```if-else```"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Drop the count of Wrong answer you got in this problem."
                    },
                    {
                        "username": "user9133dZ",
                        "content": "18 , did\\'nt expect it to be this complicated"
                    },
                    {
                        "username": "prabhashbhajani",
                        "content": "2, I\\'m happy with that"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "23 lmao.  This one was torture for me :("
                    },
                    {
                        "username": "ammarkhan575",
                        "content": "6 \\uD83D\\uDE3F"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "3 and a lot of frustration"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "only 2, I was very happy, and then I went to do the second problem of the contest and utterly failed"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "10 - 15 I lost count "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "T_T 5"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "20 WA \\uD83E\\uDD72"
                    },
                    {
                        "username": "ankush6014",
                        "content": ":( :( -6"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) Same :/ Next time I\\'ll probably try testing on custom testcases instead of official ones xD"
                    },
                    {
                        "username": "laticm",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) 10\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary)  mine 2"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Mine - 6 "
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "I hate negative numbers."
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Why dp won\\'t work here :    Since , using dp we will be following pick , not pick approach taking a subset of the array giving us the maximum product from that subset but it is possible that even negative product taken from that subset will combine with other negatives to form a positive product , so it is not suitable to use dp as it can give wrong answers \\n"
                    },
                    {
                        "username": "enigma_007",
                        "content": "The description should be better like for cases of [0,7] gave a result of 7 and I got a WA as i was printing 0.  Thankfully brute force came to rescue after 5 WA atleast"
                    },
                    {
                        "username": "laticm",
                        "content": "greedy worked for me"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Brute force worked here XD"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Why brute force backtracking algorithm by pick and not-pick method fails in below case. The subsets found using brute force method will contain one subset where it will consider all elements.\\n\\nnums: `[6,-3,-4,8,4,7,6,4,7,7,-3,-6,9]`\\noutput: `768144384`\\nexpected output: `3072577536` "
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int n=nums.size();\\n        long long  count=0;\\n        for(int i=0;i<n;i++)\\n        if(nums[i]<0) count++;\\n        long long ans=1;\\n        for(int i=0;i<n;i++){\\n            if(count%2==0){\\n                if(nums[i]==0) continue;\\n                else ans*=nums[i];\\n            }\\n            {\\n                long long  x=count-1;\\n                while(x--){\\n                    long long k=*min_element(nums.begin(),nums.end());\\n                    ans*=k;\\n                }\\n                if(nums[i]>0) ans*=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nwhat is wrong in this solution for the given problem?"
                    }
                ]
            },
            {
                "id": 1907482,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "The best testcase\\n```[0,-1]```"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "Indeed, I was able to solve by looking at this test case. Thankss..."
                    },
                    {
                        "username": "hail-cali",
                        "content": "True "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Don\\'t like when I need a lot of ```if-else```"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Drop the count of Wrong answer you got in this problem."
                    },
                    {
                        "username": "user9133dZ",
                        "content": "18 , did\\'nt expect it to be this complicated"
                    },
                    {
                        "username": "prabhashbhajani",
                        "content": "2, I\\'m happy with that"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "23 lmao.  This one was torture for me :("
                    },
                    {
                        "username": "ammarkhan575",
                        "content": "6 \\uD83D\\uDE3F"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "3 and a lot of frustration"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "only 2, I was very happy, and then I went to do the second problem of the contest and utterly failed"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "10 - 15 I lost count "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "T_T 5"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "20 WA \\uD83E\\uDD72"
                    },
                    {
                        "username": "ankush6014",
                        "content": ":( :( -6"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) Same :/ Next time I\\'ll probably try testing on custom testcases instead of official ones xD"
                    },
                    {
                        "username": "laticm",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) 10\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary)  mine 2"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Mine - 6 "
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "I hate negative numbers."
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Why dp won\\'t work here :    Since , using dp we will be following pick , not pick approach taking a subset of the array giving us the maximum product from that subset but it is possible that even negative product taken from that subset will combine with other negatives to form a positive product , so it is not suitable to use dp as it can give wrong answers \\n"
                    },
                    {
                        "username": "enigma_007",
                        "content": "The description should be better like for cases of [0,7] gave a result of 7 and I got a WA as i was printing 0.  Thankfully brute force came to rescue after 5 WA atleast"
                    },
                    {
                        "username": "laticm",
                        "content": "greedy worked for me"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Brute force worked here XD"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Why brute force backtracking algorithm by pick and not-pick method fails in below case. The subsets found using brute force method will contain one subset where it will consider all elements.\\n\\nnums: `[6,-3,-4,8,4,7,6,4,7,7,-3,-6,9]`\\noutput: `768144384`\\nexpected output: `3072577536` "
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int n=nums.size();\\n        long long  count=0;\\n        for(int i=0;i<n;i++)\\n        if(nums[i]<0) count++;\\n        long long ans=1;\\n        for(int i=0;i<n;i++){\\n            if(count%2==0){\\n                if(nums[i]==0) continue;\\n                else ans*=nums[i];\\n            }\\n            {\\n                long long  x=count-1;\\n                while(x--){\\n                    long long k=*min_element(nums.begin(),nums.end());\\n                    ans*=k;\\n                }\\n                if(nums[i]>0) ans*=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nwhat is wrong in this solution for the given problem?"
                    }
                ]
            },
            {
                "id": 1909726,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "The best testcase\\n```[0,-1]```"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "Indeed, I was able to solve by looking at this test case. Thankss..."
                    },
                    {
                        "username": "hail-cali",
                        "content": "True "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Don\\'t like when I need a lot of ```if-else```"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Drop the count of Wrong answer you got in this problem."
                    },
                    {
                        "username": "user9133dZ",
                        "content": "18 , did\\'nt expect it to be this complicated"
                    },
                    {
                        "username": "prabhashbhajani",
                        "content": "2, I\\'m happy with that"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "23 lmao.  This one was torture for me :("
                    },
                    {
                        "username": "ammarkhan575",
                        "content": "6 \\uD83D\\uDE3F"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "3 and a lot of frustration"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "only 2, I was very happy, and then I went to do the second problem of the contest and utterly failed"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "10 - 15 I lost count "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "T_T 5"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "20 WA \\uD83E\\uDD72"
                    },
                    {
                        "username": "ankush6014",
                        "content": ":( :( -6"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) Same :/ Next time I\\'ll probably try testing on custom testcases instead of official ones xD"
                    },
                    {
                        "username": "laticm",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) 10\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary)  mine 2"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Mine - 6 "
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "I hate negative numbers."
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Why dp won\\'t work here :    Since , using dp we will be following pick , not pick approach taking a subset of the array giving us the maximum product from that subset but it is possible that even negative product taken from that subset will combine with other negatives to form a positive product , so it is not suitable to use dp as it can give wrong answers \\n"
                    },
                    {
                        "username": "enigma_007",
                        "content": "The description should be better like for cases of [0,7] gave a result of 7 and I got a WA as i was printing 0.  Thankfully brute force came to rescue after 5 WA atleast"
                    },
                    {
                        "username": "laticm",
                        "content": "greedy worked for me"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Brute force worked here XD"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Why brute force backtracking algorithm by pick and not-pick method fails in below case. The subsets found using brute force method will contain one subset where it will consider all elements.\\n\\nnums: `[6,-3,-4,8,4,7,6,4,7,7,-3,-6,9]`\\noutput: `768144384`\\nexpected output: `3072577536` "
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int n=nums.size();\\n        long long  count=0;\\n        for(int i=0;i<n;i++)\\n        if(nums[i]<0) count++;\\n        long long ans=1;\\n        for(int i=0;i<n;i++){\\n            if(count%2==0){\\n                if(nums[i]==0) continue;\\n                else ans*=nums[i];\\n            }\\n            {\\n                long long  x=count-1;\\n                while(x--){\\n                    long long k=*min_element(nums.begin(),nums.end());\\n                    ans*=k;\\n                }\\n                if(nums[i]>0) ans*=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nwhat is wrong in this solution for the given problem?"
                    }
                ]
            },
            {
                "id": 1907716,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "The best testcase\\n```[0,-1]```"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "Indeed, I was able to solve by looking at this test case. Thankss..."
                    },
                    {
                        "username": "hail-cali",
                        "content": "True "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Don\\'t like when I need a lot of ```if-else```"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Drop the count of Wrong answer you got in this problem."
                    },
                    {
                        "username": "user9133dZ",
                        "content": "18 , did\\'nt expect it to be this complicated"
                    },
                    {
                        "username": "prabhashbhajani",
                        "content": "2, I\\'m happy with that"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "23 lmao.  This one was torture for me :("
                    },
                    {
                        "username": "ammarkhan575",
                        "content": "6 \\uD83D\\uDE3F"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "3 and a lot of frustration"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "only 2, I was very happy, and then I went to do the second problem of the contest and utterly failed"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "10 - 15 I lost count "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "T_T 5"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "20 WA \\uD83E\\uDD72"
                    },
                    {
                        "username": "ankush6014",
                        "content": ":( :( -6"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) Same :/ Next time I\\'ll probably try testing on custom testcases instead of official ones xD"
                    },
                    {
                        "username": "laticm",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) 10\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary)  mine 2"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Mine - 6 "
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "I hate negative numbers."
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Why dp won\\'t work here :    Since , using dp we will be following pick , not pick approach taking a subset of the array giving us the maximum product from that subset but it is possible that even negative product taken from that subset will combine with other negatives to form a positive product , so it is not suitable to use dp as it can give wrong answers \\n"
                    },
                    {
                        "username": "enigma_007",
                        "content": "The description should be better like for cases of [0,7] gave a result of 7 and I got a WA as i was printing 0.  Thankfully brute force came to rescue after 5 WA atleast"
                    },
                    {
                        "username": "laticm",
                        "content": "greedy worked for me"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Brute force worked here XD"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Why brute force backtracking algorithm by pick and not-pick method fails in below case. The subsets found using brute force method will contain one subset where it will consider all elements.\\n\\nnums: `[6,-3,-4,8,4,7,6,4,7,7,-3,-6,9]`\\noutput: `768144384`\\nexpected output: `3072577536` "
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int n=nums.size();\\n        long long  count=0;\\n        for(int i=0;i<n;i++)\\n        if(nums[i]<0) count++;\\n        long long ans=1;\\n        for(int i=0;i<n;i++){\\n            if(count%2==0){\\n                if(nums[i]==0) continue;\\n                else ans*=nums[i];\\n            }\\n            {\\n                long long  x=count-1;\\n                while(x--){\\n                    long long k=*min_element(nums.begin(),nums.end());\\n                    ans*=k;\\n                }\\n                if(nums[i]>0) ans*=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nwhat is wrong in this solution for the given problem?"
                    }
                ]
            },
            {
                "id": 1907579,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "The best testcase\\n```[0,-1]```"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "Indeed, I was able to solve by looking at this test case. Thankss..."
                    },
                    {
                        "username": "hail-cali",
                        "content": "True "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Don\\'t like when I need a lot of ```if-else```"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Drop the count of Wrong answer you got in this problem."
                    },
                    {
                        "username": "user9133dZ",
                        "content": "18 , did\\'nt expect it to be this complicated"
                    },
                    {
                        "username": "prabhashbhajani",
                        "content": "2, I\\'m happy with that"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "23 lmao.  This one was torture for me :("
                    },
                    {
                        "username": "ammarkhan575",
                        "content": "6 \\uD83D\\uDE3F"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "3 and a lot of frustration"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "only 2, I was very happy, and then I went to do the second problem of the contest and utterly failed"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "10 - 15 I lost count "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "T_T 5"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "20 WA \\uD83E\\uDD72"
                    },
                    {
                        "username": "ankush6014",
                        "content": ":( :( -6"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) Same :/ Next time I\\'ll probably try testing on custom testcases instead of official ones xD"
                    },
                    {
                        "username": "laticm",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) 10\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary)  mine 2"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Mine - 6 "
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "I hate negative numbers."
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Why dp won\\'t work here :    Since , using dp we will be following pick , not pick approach taking a subset of the array giving us the maximum product from that subset but it is possible that even negative product taken from that subset will combine with other negatives to form a positive product , so it is not suitable to use dp as it can give wrong answers \\n"
                    },
                    {
                        "username": "enigma_007",
                        "content": "The description should be better like for cases of [0,7] gave a result of 7 and I got a WA as i was printing 0.  Thankfully brute force came to rescue after 5 WA atleast"
                    },
                    {
                        "username": "laticm",
                        "content": "greedy worked for me"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Brute force worked here XD"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Why brute force backtracking algorithm by pick and not-pick method fails in below case. The subsets found using brute force method will contain one subset where it will consider all elements.\\n\\nnums: `[6,-3,-4,8,4,7,6,4,7,7,-3,-6,9]`\\noutput: `768144384`\\nexpected output: `3072577536` "
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int n=nums.size();\\n        long long  count=0;\\n        for(int i=0;i<n;i++)\\n        if(nums[i]<0) count++;\\n        long long ans=1;\\n        for(int i=0;i<n;i++){\\n            if(count%2==0){\\n                if(nums[i]==0) continue;\\n                else ans*=nums[i];\\n            }\\n            {\\n                long long  x=count-1;\\n                while(x--){\\n                    long long k=*min_element(nums.begin(),nums.end());\\n                    ans*=k;\\n                }\\n                if(nums[i]>0) ans*=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nwhat is wrong in this solution for the given problem?"
                    }
                ]
            },
            {
                "id": 1907527,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "The best testcase\\n```[0,-1]```"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "Indeed, I was able to solve by looking at this test case. Thankss..."
                    },
                    {
                        "username": "hail-cali",
                        "content": "True "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Don\\'t like when I need a lot of ```if-else```"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Drop the count of Wrong answer you got in this problem."
                    },
                    {
                        "username": "user9133dZ",
                        "content": "18 , did\\'nt expect it to be this complicated"
                    },
                    {
                        "username": "prabhashbhajani",
                        "content": "2, I\\'m happy with that"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "23 lmao.  This one was torture for me :("
                    },
                    {
                        "username": "ammarkhan575",
                        "content": "6 \\uD83D\\uDE3F"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "3 and a lot of frustration"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "only 2, I was very happy, and then I went to do the second problem of the contest and utterly failed"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "10 - 15 I lost count "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "T_T 5"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "20 WA \\uD83E\\uDD72"
                    },
                    {
                        "username": "ankush6014",
                        "content": ":( :( -6"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) Same :/ Next time I\\'ll probably try testing on custom testcases instead of official ones xD"
                    },
                    {
                        "username": "laticm",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) 10\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary)  mine 2"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Mine - 6 "
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "I hate negative numbers."
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Why dp won\\'t work here :    Since , using dp we will be following pick , not pick approach taking a subset of the array giving us the maximum product from that subset but it is possible that even negative product taken from that subset will combine with other negatives to form a positive product , so it is not suitable to use dp as it can give wrong answers \\n"
                    },
                    {
                        "username": "enigma_007",
                        "content": "The description should be better like for cases of [0,7] gave a result of 7 and I got a WA as i was printing 0.  Thankfully brute force came to rescue after 5 WA atleast"
                    },
                    {
                        "username": "laticm",
                        "content": "greedy worked for me"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Brute force worked here XD"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Why brute force backtracking algorithm by pick and not-pick method fails in below case. The subsets found using brute force method will contain one subset where it will consider all elements.\\n\\nnums: `[6,-3,-4,8,4,7,6,4,7,7,-3,-6,9]`\\noutput: `768144384`\\nexpected output: `3072577536` "
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int n=nums.size();\\n        long long  count=0;\\n        for(int i=0;i<n;i++)\\n        if(nums[i]<0) count++;\\n        long long ans=1;\\n        for(int i=0;i<n;i++){\\n            if(count%2==0){\\n                if(nums[i]==0) continue;\\n                else ans*=nums[i];\\n            }\\n            {\\n                long long  x=count-1;\\n                while(x--){\\n                    long long k=*min_element(nums.begin(),nums.end());\\n                    ans*=k;\\n                }\\n                if(nums[i]>0) ans*=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nwhat is wrong in this solution for the given problem?"
                    }
                ]
            },
            {
                "id": 2072599,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "The best testcase\\n```[0,-1]```"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "Indeed, I was able to solve by looking at this test case. Thankss..."
                    },
                    {
                        "username": "hail-cali",
                        "content": "True "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Don\\'t like when I need a lot of ```if-else```"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Drop the count of Wrong answer you got in this problem."
                    },
                    {
                        "username": "user9133dZ",
                        "content": "18 , did\\'nt expect it to be this complicated"
                    },
                    {
                        "username": "prabhashbhajani",
                        "content": "2, I\\'m happy with that"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "23 lmao.  This one was torture for me :("
                    },
                    {
                        "username": "ammarkhan575",
                        "content": "6 \\uD83D\\uDE3F"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "3 and a lot of frustration"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "only 2, I was very happy, and then I went to do the second problem of the contest and utterly failed"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "10 - 15 I lost count "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "T_T 5"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "20 WA \\uD83E\\uDD72"
                    },
                    {
                        "username": "ankush6014",
                        "content": ":( :( -6"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) Same :/ Next time I\\'ll probably try testing on custom testcases instead of official ones xD"
                    },
                    {
                        "username": "laticm",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) 10\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary)  mine 2"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Mine - 6 "
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "I hate negative numbers."
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Why dp won\\'t work here :    Since , using dp we will be following pick , not pick approach taking a subset of the array giving us the maximum product from that subset but it is possible that even negative product taken from that subset will combine with other negatives to form a positive product , so it is not suitable to use dp as it can give wrong answers \\n"
                    },
                    {
                        "username": "enigma_007",
                        "content": "The description should be better like for cases of [0,7] gave a result of 7 and I got a WA as i was printing 0.  Thankfully brute force came to rescue after 5 WA atleast"
                    },
                    {
                        "username": "laticm",
                        "content": "greedy worked for me"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Brute force worked here XD"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Why brute force backtracking algorithm by pick and not-pick method fails in below case. The subsets found using brute force method will contain one subset where it will consider all elements.\\n\\nnums: `[6,-3,-4,8,4,7,6,4,7,7,-3,-6,9]`\\noutput: `768144384`\\nexpected output: `3072577536` "
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int n=nums.size();\\n        long long  count=0;\\n        for(int i=0;i<n;i++)\\n        if(nums[i]<0) count++;\\n        long long ans=1;\\n        for(int i=0;i<n;i++){\\n            if(count%2==0){\\n                if(nums[i]==0) continue;\\n                else ans*=nums[i];\\n            }\\n            {\\n                long long  x=count-1;\\n                while(x--){\\n                    long long k=*min_element(nums.begin(),nums.end());\\n                    ans*=k;\\n                }\\n                if(nums[i]>0) ans*=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nwhat is wrong in this solution for the given problem?"
                    }
                ]
            },
            {
                "id": 1964028,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "The best testcase\\n```[0,-1]```"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "Indeed, I was able to solve by looking at this test case. Thankss..."
                    },
                    {
                        "username": "hail-cali",
                        "content": "True "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Don\\'t like when I need a lot of ```if-else```"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Drop the count of Wrong answer you got in this problem."
                    },
                    {
                        "username": "user9133dZ",
                        "content": "18 , did\\'nt expect it to be this complicated"
                    },
                    {
                        "username": "prabhashbhajani",
                        "content": "2, I\\'m happy with that"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "23 lmao.  This one was torture for me :("
                    },
                    {
                        "username": "ammarkhan575",
                        "content": "6 \\uD83D\\uDE3F"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "3 and a lot of frustration"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "only 2, I was very happy, and then I went to do the second problem of the contest and utterly failed"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "10 - 15 I lost count "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "T_T 5"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "20 WA \\uD83E\\uDD72"
                    },
                    {
                        "username": "ankush6014",
                        "content": ":( :( -6"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) Same :/ Next time I\\'ll probably try testing on custom testcases instead of official ones xD"
                    },
                    {
                        "username": "laticm",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) 10\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary)  mine 2"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Mine - 6 "
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "I hate negative numbers."
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Why dp won\\'t work here :    Since , using dp we will be following pick , not pick approach taking a subset of the array giving us the maximum product from that subset but it is possible that even negative product taken from that subset will combine with other negatives to form a positive product , so it is not suitable to use dp as it can give wrong answers \\n"
                    },
                    {
                        "username": "enigma_007",
                        "content": "The description should be better like for cases of [0,7] gave a result of 7 and I got a WA as i was printing 0.  Thankfully brute force came to rescue after 5 WA atleast"
                    },
                    {
                        "username": "laticm",
                        "content": "greedy worked for me"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Brute force worked here XD"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Why brute force backtracking algorithm by pick and not-pick method fails in below case. The subsets found using brute force method will contain one subset where it will consider all elements.\\n\\nnums: `[6,-3,-4,8,4,7,6,4,7,7,-3,-6,9]`\\noutput: `768144384`\\nexpected output: `3072577536` "
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int n=nums.size();\\n        long long  count=0;\\n        for(int i=0;i<n;i++)\\n        if(nums[i]<0) count++;\\n        long long ans=1;\\n        for(int i=0;i<n;i++){\\n            if(count%2==0){\\n                if(nums[i]==0) continue;\\n                else ans*=nums[i];\\n            }\\n            {\\n                long long  x=count-1;\\n                while(x--){\\n                    long long k=*min_element(nums.begin(),nums.end());\\n                    ans*=k;\\n                }\\n                if(nums[i]>0) ans*=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nwhat is wrong in this solution for the given problem?"
                    }
                ]
            },
            {
                "id": 1909790,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "The best testcase\\n```[0,-1]```"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "Indeed, I was able to solve by looking at this test case. Thankss..."
                    },
                    {
                        "username": "hail-cali",
                        "content": "True "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Don\\'t like when I need a lot of ```if-else```"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Drop the count of Wrong answer you got in this problem."
                    },
                    {
                        "username": "user9133dZ",
                        "content": "18 , did\\'nt expect it to be this complicated"
                    },
                    {
                        "username": "prabhashbhajani",
                        "content": "2, I\\'m happy with that"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "23 lmao.  This one was torture for me :("
                    },
                    {
                        "username": "ammarkhan575",
                        "content": "6 \\uD83D\\uDE3F"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "3 and a lot of frustration"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "only 2, I was very happy, and then I went to do the second problem of the contest and utterly failed"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "10 - 15 I lost count "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "T_T 5"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "20 WA \\uD83E\\uDD72"
                    },
                    {
                        "username": "ankush6014",
                        "content": ":( :( -6"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) Same :/ Next time I\\'ll probably try testing on custom testcases instead of official ones xD"
                    },
                    {
                        "username": "laticm",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) 10\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary)  mine 2"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Mine - 6 "
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "I hate negative numbers."
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Why dp won\\'t work here :    Since , using dp we will be following pick , not pick approach taking a subset of the array giving us the maximum product from that subset but it is possible that even negative product taken from that subset will combine with other negatives to form a positive product , so it is not suitable to use dp as it can give wrong answers \\n"
                    },
                    {
                        "username": "enigma_007",
                        "content": "The description should be better like for cases of [0,7] gave a result of 7 and I got a WA as i was printing 0.  Thankfully brute force came to rescue after 5 WA atleast"
                    },
                    {
                        "username": "laticm",
                        "content": "greedy worked for me"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Brute force worked here XD"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Why brute force backtracking algorithm by pick and not-pick method fails in below case. The subsets found using brute force method will contain one subset where it will consider all elements.\\n\\nnums: `[6,-3,-4,8,4,7,6,4,7,7,-3,-6,9]`\\noutput: `768144384`\\nexpected output: `3072577536` "
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int n=nums.size();\\n        long long  count=0;\\n        for(int i=0;i<n;i++)\\n        if(nums[i]<0) count++;\\n        long long ans=1;\\n        for(int i=0;i<n;i++){\\n            if(count%2==0){\\n                if(nums[i]==0) continue;\\n                else ans*=nums[i];\\n            }\\n            {\\n                long long  x=count-1;\\n                while(x--){\\n                    long long k=*min_element(nums.begin(),nums.end());\\n                    ans*=k;\\n                }\\n                if(nums[i]>0) ans*=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nwhat is wrong in this solution for the given problem?"
                    }
                ]
            },
            {
                "id": 1909801,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "The best testcase\\n```[0,-1]```"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "Indeed, I was able to solve by looking at this test case. Thankss..."
                    },
                    {
                        "username": "hail-cali",
                        "content": "True "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Don\\'t like when I need a lot of ```if-else```"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Drop the count of Wrong answer you got in this problem."
                    },
                    {
                        "username": "user9133dZ",
                        "content": "18 , did\\'nt expect it to be this complicated"
                    },
                    {
                        "username": "prabhashbhajani",
                        "content": "2, I\\'m happy with that"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "23 lmao.  This one was torture for me :("
                    },
                    {
                        "username": "ammarkhan575",
                        "content": "6 \\uD83D\\uDE3F"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "3 and a lot of frustration"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "only 2, I was very happy, and then I went to do the second problem of the contest and utterly failed"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "10 - 15 I lost count "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "T_T 5"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "20 WA \\uD83E\\uDD72"
                    },
                    {
                        "username": "ankush6014",
                        "content": ":( :( -6"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) Same :/ Next time I\\'ll probably try testing on custom testcases instead of official ones xD"
                    },
                    {
                        "username": "laticm",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) 10\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary)  mine 2"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Mine - 6 "
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "I hate negative numbers."
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Why dp won\\'t work here :    Since , using dp we will be following pick , not pick approach taking a subset of the array giving us the maximum product from that subset but it is possible that even negative product taken from that subset will combine with other negatives to form a positive product , so it is not suitable to use dp as it can give wrong answers \\n"
                    },
                    {
                        "username": "enigma_007",
                        "content": "The description should be better like for cases of [0,7] gave a result of 7 and I got a WA as i was printing 0.  Thankfully brute force came to rescue after 5 WA atleast"
                    },
                    {
                        "username": "laticm",
                        "content": "greedy worked for me"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Brute force worked here XD"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Why brute force backtracking algorithm by pick and not-pick method fails in below case. The subsets found using brute force method will contain one subset where it will consider all elements.\\n\\nnums: `[6,-3,-4,8,4,7,6,4,7,7,-3,-6,9]`\\noutput: `768144384`\\nexpected output: `3072577536` "
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int n=nums.size();\\n        long long  count=0;\\n        for(int i=0;i<n;i++)\\n        if(nums[i]<0) count++;\\n        long long ans=1;\\n        for(int i=0;i<n;i++){\\n            if(count%2==0){\\n                if(nums[i]==0) continue;\\n                else ans*=nums[i];\\n            }\\n            {\\n                long long  x=count-1;\\n                while(x--){\\n                    long long k=*min_element(nums.begin(),nums.end());\\n                    ans*=k;\\n                }\\n                if(nums[i]>0) ans*=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nwhat is wrong in this solution for the given problem?"
                    }
                ]
            },
            {
                "id": 1907414,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "The best testcase\\n```[0,-1]```"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "Indeed, I was able to solve by looking at this test case. Thankss..."
                    },
                    {
                        "username": "hail-cali",
                        "content": "True "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Don\\'t like when I need a lot of ```if-else```"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Drop the count of Wrong answer you got in this problem."
                    },
                    {
                        "username": "user9133dZ",
                        "content": "18 , did\\'nt expect it to be this complicated"
                    },
                    {
                        "username": "prabhashbhajani",
                        "content": "2, I\\'m happy with that"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "23 lmao.  This one was torture for me :("
                    },
                    {
                        "username": "ammarkhan575",
                        "content": "6 \\uD83D\\uDE3F"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "3 and a lot of frustration"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "only 2, I was very happy, and then I went to do the second problem of the contest and utterly failed"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "10 - 15 I lost count "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "T_T 5"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "20 WA \\uD83E\\uDD72"
                    },
                    {
                        "username": "ankush6014",
                        "content": ":( :( -6"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) Same :/ Next time I\\'ll probably try testing on custom testcases instead of official ones xD"
                    },
                    {
                        "username": "laticm",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) 10\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary)  mine 2"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Mine - 6 "
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "I hate negative numbers."
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Why dp won\\'t work here :    Since , using dp we will be following pick , not pick approach taking a subset of the array giving us the maximum product from that subset but it is possible that even negative product taken from that subset will combine with other negatives to form a positive product , so it is not suitable to use dp as it can give wrong answers \\n"
                    },
                    {
                        "username": "enigma_007",
                        "content": "The description should be better like for cases of [0,7] gave a result of 7 and I got a WA as i was printing 0.  Thankfully brute force came to rescue after 5 WA atleast"
                    },
                    {
                        "username": "laticm",
                        "content": "greedy worked for me"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Brute force worked here XD"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Why brute force backtracking algorithm by pick and not-pick method fails in below case. The subsets found using brute force method will contain one subset where it will consider all elements.\\n\\nnums: `[6,-3,-4,8,4,7,6,4,7,7,-3,-6,9]`\\noutput: `768144384`\\nexpected output: `3072577536` "
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int n=nums.size();\\n        long long  count=0;\\n        for(int i=0;i<n;i++)\\n        if(nums[i]<0) count++;\\n        long long ans=1;\\n        for(int i=0;i<n;i++){\\n            if(count%2==0){\\n                if(nums[i]==0) continue;\\n                else ans*=nums[i];\\n            }\\n            {\\n                long long  x=count-1;\\n                while(x--){\\n                    long long k=*min_element(nums.begin(),nums.end());\\n                    ans*=k;\\n                }\\n                if(nums[i]>0) ans*=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nwhat is wrong in this solution for the given problem?"
                    }
                ]
            },
            {
                "id": 1907482,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "The best testcase\\n```[0,-1]```"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "Indeed, I was able to solve by looking at this test case. Thankss..."
                    },
                    {
                        "username": "hail-cali",
                        "content": "True "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Don\\'t like when I need a lot of ```if-else```"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Drop the count of Wrong answer you got in this problem."
                    },
                    {
                        "username": "user9133dZ",
                        "content": "18 , did\\'nt expect it to be this complicated"
                    },
                    {
                        "username": "prabhashbhajani",
                        "content": "2, I\\'m happy with that"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "23 lmao.  This one was torture for me :("
                    },
                    {
                        "username": "ammarkhan575",
                        "content": "6 \\uD83D\\uDE3F"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "3 and a lot of frustration"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "only 2, I was very happy, and then I went to do the second problem of the contest and utterly failed"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "10 - 15 I lost count "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "T_T 5"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "20 WA \\uD83E\\uDD72"
                    },
                    {
                        "username": "ankush6014",
                        "content": ":( :( -6"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) Same :/ Next time I\\'ll probably try testing on custom testcases instead of official ones xD"
                    },
                    {
                        "username": "laticm",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) 10\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary)  mine 2"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Mine - 6 "
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "I hate negative numbers."
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Why dp won\\'t work here :    Since , using dp we will be following pick , not pick approach taking a subset of the array giving us the maximum product from that subset but it is possible that even negative product taken from that subset will combine with other negatives to form a positive product , so it is not suitable to use dp as it can give wrong answers \\n"
                    },
                    {
                        "username": "enigma_007",
                        "content": "The description should be better like for cases of [0,7] gave a result of 7 and I got a WA as i was printing 0.  Thankfully brute force came to rescue after 5 WA atleast"
                    },
                    {
                        "username": "laticm",
                        "content": "greedy worked for me"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Brute force worked here XD"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Why brute force backtracking algorithm by pick and not-pick method fails in below case. The subsets found using brute force method will contain one subset where it will consider all elements.\\n\\nnums: `[6,-3,-4,8,4,7,6,4,7,7,-3,-6,9]`\\noutput: `768144384`\\nexpected output: `3072577536` "
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int n=nums.size();\\n        long long  count=0;\\n        for(int i=0;i<n;i++)\\n        if(nums[i]<0) count++;\\n        long long ans=1;\\n        for(int i=0;i<n;i++){\\n            if(count%2==0){\\n                if(nums[i]==0) continue;\\n                else ans*=nums[i];\\n            }\\n            {\\n                long long  x=count-1;\\n                while(x--){\\n                    long long k=*min_element(nums.begin(),nums.end());\\n                    ans*=k;\\n                }\\n                if(nums[i]>0) ans*=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nwhat is wrong in this solution for the given problem?"
                    }
                ]
            },
            {
                "id": 1909726,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "The best testcase\\n```[0,-1]```"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "Indeed, I was able to solve by looking at this test case. Thankss..."
                    },
                    {
                        "username": "hail-cali",
                        "content": "True "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Don\\'t like when I need a lot of ```if-else```"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Drop the count of Wrong answer you got in this problem."
                    },
                    {
                        "username": "user9133dZ",
                        "content": "18 , did\\'nt expect it to be this complicated"
                    },
                    {
                        "username": "prabhashbhajani",
                        "content": "2, I\\'m happy with that"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "23 lmao.  This one was torture for me :("
                    },
                    {
                        "username": "ammarkhan575",
                        "content": "6 \\uD83D\\uDE3F"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "3 and a lot of frustration"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "only 2, I was very happy, and then I went to do the second problem of the contest and utterly failed"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "10 - 15 I lost count "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "T_T 5"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "20 WA \\uD83E\\uDD72"
                    },
                    {
                        "username": "ankush6014",
                        "content": ":( :( -6"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) Same :/ Next time I\\'ll probably try testing on custom testcases instead of official ones xD"
                    },
                    {
                        "username": "laticm",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) 10\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary)  mine 2"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Mine - 6 "
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "I hate negative numbers."
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Why dp won\\'t work here :    Since , using dp we will be following pick , not pick approach taking a subset of the array giving us the maximum product from that subset but it is possible that even negative product taken from that subset will combine with other negatives to form a positive product , so it is not suitable to use dp as it can give wrong answers \\n"
                    },
                    {
                        "username": "enigma_007",
                        "content": "The description should be better like for cases of [0,7] gave a result of 7 and I got a WA as i was printing 0.  Thankfully brute force came to rescue after 5 WA atleast"
                    },
                    {
                        "username": "laticm",
                        "content": "greedy worked for me"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Brute force worked here XD"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Why brute force backtracking algorithm by pick and not-pick method fails in below case. The subsets found using brute force method will contain one subset where it will consider all elements.\\n\\nnums: `[6,-3,-4,8,4,7,6,4,7,7,-3,-6,9]`\\noutput: `768144384`\\nexpected output: `3072577536` "
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int n=nums.size();\\n        long long  count=0;\\n        for(int i=0;i<n;i++)\\n        if(nums[i]<0) count++;\\n        long long ans=1;\\n        for(int i=0;i<n;i++){\\n            if(count%2==0){\\n                if(nums[i]==0) continue;\\n                else ans*=nums[i];\\n            }\\n            {\\n                long long  x=count-1;\\n                while(x--){\\n                    long long k=*min_element(nums.begin(),nums.end());\\n                    ans*=k;\\n                }\\n                if(nums[i]>0) ans*=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nwhat is wrong in this solution for the given problem?"
                    }
                ]
            },
            {
                "id": 1907716,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "The best testcase\\n```[0,-1]```"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "Indeed, I was able to solve by looking at this test case. Thankss..."
                    },
                    {
                        "username": "hail-cali",
                        "content": "True "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Don\\'t like when I need a lot of ```if-else```"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Drop the count of Wrong answer you got in this problem."
                    },
                    {
                        "username": "user9133dZ",
                        "content": "18 , did\\'nt expect it to be this complicated"
                    },
                    {
                        "username": "prabhashbhajani",
                        "content": "2, I\\'m happy with that"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "23 lmao.  This one was torture for me :("
                    },
                    {
                        "username": "ammarkhan575",
                        "content": "6 \\uD83D\\uDE3F"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "3 and a lot of frustration"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "only 2, I was very happy, and then I went to do the second problem of the contest and utterly failed"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "10 - 15 I lost count "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "T_T 5"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "20 WA \\uD83E\\uDD72"
                    },
                    {
                        "username": "ankush6014",
                        "content": ":( :( -6"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) Same :/ Next time I\\'ll probably try testing on custom testcases instead of official ones xD"
                    },
                    {
                        "username": "laticm",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) 10\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary)  mine 2"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Mine - 6 "
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "I hate negative numbers."
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Why dp won\\'t work here :    Since , using dp we will be following pick , not pick approach taking a subset of the array giving us the maximum product from that subset but it is possible that even negative product taken from that subset will combine with other negatives to form a positive product , so it is not suitable to use dp as it can give wrong answers \\n"
                    },
                    {
                        "username": "enigma_007",
                        "content": "The description should be better like for cases of [0,7] gave a result of 7 and I got a WA as i was printing 0.  Thankfully brute force came to rescue after 5 WA atleast"
                    },
                    {
                        "username": "laticm",
                        "content": "greedy worked for me"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Brute force worked here XD"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Why brute force backtracking algorithm by pick and not-pick method fails in below case. The subsets found using brute force method will contain one subset where it will consider all elements.\\n\\nnums: `[6,-3,-4,8,4,7,6,4,7,7,-3,-6,9]`\\noutput: `768144384`\\nexpected output: `3072577536` "
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int n=nums.size();\\n        long long  count=0;\\n        for(int i=0;i<n;i++)\\n        if(nums[i]<0) count++;\\n        long long ans=1;\\n        for(int i=0;i<n;i++){\\n            if(count%2==0){\\n                if(nums[i]==0) continue;\\n                else ans*=nums[i];\\n            }\\n            {\\n                long long  x=count-1;\\n                while(x--){\\n                    long long k=*min_element(nums.begin(),nums.end());\\n                    ans*=k;\\n                }\\n                if(nums[i]>0) ans*=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nwhat is wrong in this solution for the given problem?"
                    }
                ]
            },
            {
                "id": 1907579,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "The best testcase\\n```[0,-1]```"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "Indeed, I was able to solve by looking at this test case. Thankss..."
                    },
                    {
                        "username": "hail-cali",
                        "content": "True "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Don\\'t like when I need a lot of ```if-else```"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Drop the count of Wrong answer you got in this problem."
                    },
                    {
                        "username": "user9133dZ",
                        "content": "18 , did\\'nt expect it to be this complicated"
                    },
                    {
                        "username": "prabhashbhajani",
                        "content": "2, I\\'m happy with that"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "23 lmao.  This one was torture for me :("
                    },
                    {
                        "username": "ammarkhan575",
                        "content": "6 \\uD83D\\uDE3F"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "3 and a lot of frustration"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "only 2, I was very happy, and then I went to do the second problem of the contest and utterly failed"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "10 - 15 I lost count "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "T_T 5"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "20 WA \\uD83E\\uDD72"
                    },
                    {
                        "username": "ankush6014",
                        "content": ":( :( -6"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) Same :/ Next time I\\'ll probably try testing on custom testcases instead of official ones xD"
                    },
                    {
                        "username": "laticm",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) 10\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary)  mine 2"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Mine - 6 "
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "I hate negative numbers."
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Why dp won\\'t work here :    Since , using dp we will be following pick , not pick approach taking a subset of the array giving us the maximum product from that subset but it is possible that even negative product taken from that subset will combine with other negatives to form a positive product , so it is not suitable to use dp as it can give wrong answers \\n"
                    },
                    {
                        "username": "enigma_007",
                        "content": "The description should be better like for cases of [0,7] gave a result of 7 and I got a WA as i was printing 0.  Thankfully brute force came to rescue after 5 WA atleast"
                    },
                    {
                        "username": "laticm",
                        "content": "greedy worked for me"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Brute force worked here XD"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Why brute force backtracking algorithm by pick and not-pick method fails in below case. The subsets found using brute force method will contain one subset where it will consider all elements.\\n\\nnums: `[6,-3,-4,8,4,7,6,4,7,7,-3,-6,9]`\\noutput: `768144384`\\nexpected output: `3072577536` "
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int n=nums.size();\\n        long long  count=0;\\n        for(int i=0;i<n;i++)\\n        if(nums[i]<0) count++;\\n        long long ans=1;\\n        for(int i=0;i<n;i++){\\n            if(count%2==0){\\n                if(nums[i]==0) continue;\\n                else ans*=nums[i];\\n            }\\n            {\\n                long long  x=count-1;\\n                while(x--){\\n                    long long k=*min_element(nums.begin(),nums.end());\\n                    ans*=k;\\n                }\\n                if(nums[i]>0) ans*=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nwhat is wrong in this solution for the given problem?"
                    }
                ]
            },
            {
                "id": 1907527,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "The best testcase\\n```[0,-1]```"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "Indeed, I was able to solve by looking at this test case. Thankss..."
                    },
                    {
                        "username": "hail-cali",
                        "content": "True "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Don\\'t like when I need a lot of ```if-else```"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Drop the count of Wrong answer you got in this problem."
                    },
                    {
                        "username": "user9133dZ",
                        "content": "18 , did\\'nt expect it to be this complicated"
                    },
                    {
                        "username": "prabhashbhajani",
                        "content": "2, I\\'m happy with that"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "23 lmao.  This one was torture for me :("
                    },
                    {
                        "username": "ammarkhan575",
                        "content": "6 \\uD83D\\uDE3F"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "3 and a lot of frustration"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "only 2, I was very happy, and then I went to do the second problem of the contest and utterly failed"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "10 - 15 I lost count "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "T_T 5"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "20 WA \\uD83E\\uDD72"
                    },
                    {
                        "username": "ankush6014",
                        "content": ":( :( -6"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) Same :/ Next time I\\'ll probably try testing on custom testcases instead of official ones xD"
                    },
                    {
                        "username": "laticm",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) 10\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary)  mine 2"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Mine - 6 "
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "I hate negative numbers."
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Why dp won\\'t work here :    Since , using dp we will be following pick , not pick approach taking a subset of the array giving us the maximum product from that subset but it is possible that even negative product taken from that subset will combine with other negatives to form a positive product , so it is not suitable to use dp as it can give wrong answers \\n"
                    },
                    {
                        "username": "enigma_007",
                        "content": "The description should be better like for cases of [0,7] gave a result of 7 and I got a WA as i was printing 0.  Thankfully brute force came to rescue after 5 WA atleast"
                    },
                    {
                        "username": "laticm",
                        "content": "greedy worked for me"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Brute force worked here XD"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Why brute force backtracking algorithm by pick and not-pick method fails in below case. The subsets found using brute force method will contain one subset where it will consider all elements.\\n\\nnums: `[6,-3,-4,8,4,7,6,4,7,7,-3,-6,9]`\\noutput: `768144384`\\nexpected output: `3072577536` "
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int n=nums.size();\\n        long long  count=0;\\n        for(int i=0;i<n;i++)\\n        if(nums[i]<0) count++;\\n        long long ans=1;\\n        for(int i=0;i<n;i++){\\n            if(count%2==0){\\n                if(nums[i]==0) continue;\\n                else ans*=nums[i];\\n            }\\n            {\\n                long long  x=count-1;\\n                while(x--){\\n                    long long k=*min_element(nums.begin(),nums.end());\\n                    ans*=k;\\n                }\\n                if(nums[i]>0) ans*=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nwhat is wrong in this solution for the given problem?"
                    }
                ]
            },
            {
                "id": 2072599,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "The best testcase\\n```[0,-1]```"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "Indeed, I was able to solve by looking at this test case. Thankss..."
                    },
                    {
                        "username": "hail-cali",
                        "content": "True "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Don\\'t like when I need a lot of ```if-else```"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Drop the count of Wrong answer you got in this problem."
                    },
                    {
                        "username": "user9133dZ",
                        "content": "18 , did\\'nt expect it to be this complicated"
                    },
                    {
                        "username": "prabhashbhajani",
                        "content": "2, I\\'m happy with that"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "23 lmao.  This one was torture for me :("
                    },
                    {
                        "username": "ammarkhan575",
                        "content": "6 \\uD83D\\uDE3F"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "3 and a lot of frustration"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "only 2, I was very happy, and then I went to do the second problem of the contest and utterly failed"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "10 - 15 I lost count "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "T_T 5"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "20 WA \\uD83E\\uDD72"
                    },
                    {
                        "username": "ankush6014",
                        "content": ":( :( -6"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) Same :/ Next time I\\'ll probably try testing on custom testcases instead of official ones xD"
                    },
                    {
                        "username": "laticm",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) 10\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary)  mine 2"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Mine - 6 "
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "I hate negative numbers."
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Why dp won\\'t work here :    Since , using dp we will be following pick , not pick approach taking a subset of the array giving us the maximum product from that subset but it is possible that even negative product taken from that subset will combine with other negatives to form a positive product , so it is not suitable to use dp as it can give wrong answers \\n"
                    },
                    {
                        "username": "enigma_007",
                        "content": "The description should be better like for cases of [0,7] gave a result of 7 and I got a WA as i was printing 0.  Thankfully brute force came to rescue after 5 WA atleast"
                    },
                    {
                        "username": "laticm",
                        "content": "greedy worked for me"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Brute force worked here XD"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Why brute force backtracking algorithm by pick and not-pick method fails in below case. The subsets found using brute force method will contain one subset where it will consider all elements.\\n\\nnums: `[6,-3,-4,8,4,7,6,4,7,7,-3,-6,9]`\\noutput: `768144384`\\nexpected output: `3072577536` "
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int n=nums.size();\\n        long long  count=0;\\n        for(int i=0;i<n;i++)\\n        if(nums[i]<0) count++;\\n        long long ans=1;\\n        for(int i=0;i<n;i++){\\n            if(count%2==0){\\n                if(nums[i]==0) continue;\\n                else ans*=nums[i];\\n            }\\n            {\\n                long long  x=count-1;\\n                while(x--){\\n                    long long k=*min_element(nums.begin(),nums.end());\\n                    ans*=k;\\n                }\\n                if(nums[i]>0) ans*=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nwhat is wrong in this solution for the given problem?"
                    }
                ]
            },
            {
                "id": 1964028,
                "content": [
                    {
                        "username": "dmitryartux",
                        "content": "The best testcase\\n```[0,-1]```"
                    },
                    {
                        "username": "pavansai0813",
                        "content": "Indeed, I was able to solve by looking at this test case. Thankss..."
                    },
                    {
                        "username": "hail-cali",
                        "content": "True "
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Don\\'t like when I need a lot of ```if-else```"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Drop the count of Wrong answer you got in this problem."
                    },
                    {
                        "username": "user9133dZ",
                        "content": "18 , did\\'nt expect it to be this complicated"
                    },
                    {
                        "username": "prabhashbhajani",
                        "content": "2, I\\'m happy with that"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "23 lmao.  This one was torture for me :("
                    },
                    {
                        "username": "ammarkhan575",
                        "content": "6 \\uD83D\\uDE3F"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "3 and a lot of frustration"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "only 2, I was very happy, and then I went to do the second problem of the contest and utterly failed"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "10 - 15 I lost count "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "T_T 5"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "20 WA \\uD83E\\uDD72"
                    },
                    {
                        "username": "ankush6014",
                        "content": ":( :( -6"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) Same :/ Next time I\\'ll probably try testing on custom testcases instead of official ones xD"
                    },
                    {
                        "username": "laticm",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary) 10\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Vipul_Chaudhary](/Vipul_Chaudhary)  mine 2"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Mine - 6 "
                    },
                    {
                        "username": "mrprashantkumar",
                        "content": "I hate negative numbers."
                    },
                    {
                        "username": "jatinder1st",
                        "content": "Why dp won\\'t work here :    Since , using dp we will be following pick , not pick approach taking a subset of the array giving us the maximum product from that subset but it is possible that even negative product taken from that subset will combine with other negatives to form a positive product , so it is not suitable to use dp as it can give wrong answers \\n"
                    },
                    {
                        "username": "enigma_007",
                        "content": "The description should be better like for cases of [0,7] gave a result of 7 and I got a WA as i was printing 0.  Thankfully brute force came to rescue after 5 WA atleast"
                    },
                    {
                        "username": "laticm",
                        "content": "greedy worked for me"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Brute force worked here XD"
                    },
                    {
                        "username": "HansarajKosarkar",
                        "content": "Why brute force backtracking algorithm by pick and not-pick method fails in below case. The subsets found using brute force method will contain one subset where it will consider all elements.\\n\\nnums: `[6,-3,-4,8,4,7,6,4,7,7,-3,-6,9]`\\noutput: `768144384`\\nexpected output: `3072577536` "
                    },
                    {
                        "username": "visheshNITS",
                        "content": "class Solution {\\npublic:\\n    long long maxStrength(vector<int>& nums) {\\n        int n=nums.size();\\n        long long  count=0;\\n        for(int i=0;i<n;i++)\\n        if(nums[i]<0) count++;\\n        long long ans=1;\\n        for(int i=0;i<n;i++){\\n            if(count%2==0){\\n                if(nums[i]==0) continue;\\n                else ans*=nums[i];\\n            }\\n            {\\n                long long  x=count-1;\\n                while(x--){\\n                    long long k=*min_element(nums.begin(),nums.end());\\n                    ans*=k;\\n                }\\n                if(nums[i]>0) ans*=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nwhat is wrong in this solution for the given problem?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Interval Cancellation",
        "question_content": "<p>Given a function <code>fn</code>, an array of arguments&nbsp;<code>args</code>, and&nbsp;an interval time <code>t</code>, return a cancel function <code>cancelFn</code>.</p>\n\n<p>The function <code>fn</code> should be called with <code>args</code> immediately and then called again every&nbsp;<code>t</code> milliseconds&nbsp;until&nbsp;<code>cancelFn</code>&nbsp;is called at <code>cancelT</code> ms.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> fn = (x) =&gt; x * 2, args = [4], t = 35, cancelT = 190\n<strong>Output:</strong> \n[\n   {&quot;time&quot;: 0, &quot;returned&quot;: 8},\n   {&quot;time&quot;: 35, &quot;returned&quot;: 8},\n   {&quot;time&quot;: 70, &quot;returned&quot;: 8},\n   {&quot;time&quot;: 105, &quot;returned&quot;: 8},\n   {&quot;time&quot;: 140, &quot;returned&quot;: 8},\n   {&quot;time&quot;: 175, &quot;returned&quot;: 8}\n]\n<strong>Explanation:</strong> \nconst result = []\nconst fn = (x) =&gt; x * 2\nconst args = [4], t = 35, cancelT = 190\n\nconst start = performance.now()\n\nconst log = (...argsArr) =&gt; {\n    const diff = Math.floor(performance.now() - start)\n    result.push({&quot;time&quot;: diff, &quot;returned&quot;: fn(...argsArr)})\n}\n\nconst cancel = cancellable(log, [4], 35);\nsetTimeout(cancel, 190);\n\nsetTimeout(() =&gt; {\n    console.log(result) // Output\n }, cancelT + t + 15)  \n\nEvery 35ms, fn(4) is called. Until t=190ms, then it is cancelled.\n1st fn call is at 0ms. fn(4) returns 8.\n2nd fn call is at 35ms. fn(4) returns 8.\n3rd fn call is at 70ms. fn(4) returns 8.\n4th fn call is at&nbsp;105ms. fn(4) returns 8.\n5th fn call is at 140ms. fn(4) returns 8.\n6th fn call is at 175ms. fn(4) returns 8.\nCancelled at 190ms\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> fn = (x1, x2) =&gt; (x1 * x2), args = [2, 5], t = 30, cancelT = 165\n<strong>Output:</strong> \n[\n   {&quot;time&quot;: 0, &quot;returned&quot;: 10},\n   {&quot;time&quot;: 30, &quot;returned&quot;: 10},\n   {&quot;time&quot;: 60, &quot;returned&quot;: 10},\n   {&quot;time&quot;: 90, &quot;returned&quot;: 10},\n   {&quot;time&quot;: 120, &quot;returned&quot;: 10},\n   {&quot;time&quot;: 150, &quot;returned&quot;: 10}\n]\n<strong>Explanation:</strong> Every 30ms, fn(2, 5) is called. Until t=165ms, then it is cancelled.\n1st fn call is at 0ms&nbsp;\n2nd fn call is at 30ms&nbsp;\n3rd fn call is at 60ms&nbsp;\n4th fn call is at&nbsp;90ms&nbsp;\n5th fn call is at 120ms&nbsp;\n6th fn call is at 150ms\nCancelled at 165ms\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> fn = (x1, x2, x3) =&gt; (x1 + x2 + x3), args = [5, 1, 3], t = 50, cancelT = 180\n<strong>Output:</strong> \n[\n   {&quot;time&quot;: 0, &quot;returned&quot;: 9},\n   {&quot;time&quot;: 50, &quot;returned&quot;: 9},\n   {&quot;time&quot;: 100, &quot;returned&quot;: 9},\n   {&quot;time&quot;: 150, &quot;returned&quot;: 9}\n]\n<strong>Explanation:</strong> Every 50ms, fn(5, 1, 3) is called. Until t=180ms, then it is cancelled. \n1st fn call is at 0ms\n2nd fn call is at 50ms\n3rd fn call is at 100ms\n4th fn call is at&nbsp;150ms\nCancelled at 180ms\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>fn</code> is a function</li>\n\t<li><code>args</code> is a valid JSON array</li>\n\t<li><code>1 &lt;= args.length &lt;= 10</code></li>\n\t<li><code><font face=\"monospace\">30 &lt;= t &lt;= 100</font></code></li>\n\t<li><code><font face=\"monospace\">10 &lt;= cancelT &lt;= 500</font></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3624619,
                "title": "full-thorough-explanation-beginner-friendly",
                "content": "# Approach\\n- Call ```fn(...args)```.\\n- Set an interval ```timer```. The ```setInterval``` function in the code below will call ```() => fn(...args)``` every ```t``` milliseconds. Note, ```setInterval``` does not initially call the function before ```t``` milliseconds, which is why we call ```fn(...args)``` once before setting the interval.\\n- Now, we define a ```cancelFn``` function, which clears the interval when called. Return ```cancelFn```.\\n    - The function ```cancelFn``` is not called when our ```cancellable``` function is first defined. However, whenever someone calls ```cancellable```, the line ```return cancelFn```, in order to return, will call and execute ```cancelFn```, thereby cancelling the interval.\\n    - For example, if we define ```var myFunc = cancellable((num) => 1 + num, 13, 100)```, the interval will repeatedly call ```(num) => 1 + num``` until ```myFunc()``` is called. When ```myFunc()``` is called, the return line in ```myFunc``` is read, which will consequentially make ```cancelFn``` execute and return, thereby clearing the interval.\\n\\n# Code\\n```\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    let timer = setInterval(() => fn(...args), t);\\n\\n    let cancelFn = () => clearInterval(timer);\\n    return cancelFn;\\n};\\n```\\nUPVOTE if this was helpful \\uD83C\\uDF5E\\uD83C\\uDF5E\\uD83C\\uDF5E",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```fn(...args)```\n```timer```\n```setInterval```\n```() => fn(...args)```\n```t```\n```setInterval```\n```t```\n```fn(...args)```\n```cancelFn```\n```cancelFn```\n```cancelFn```\n```cancellable```\n```cancellable```\n```return cancelFn```\n```cancelFn```\n```var myFunc = cancellable((num) => 1 + num, 13, 100)```\n```(num) => 1 + num```\n```myFunc()```\n```myFunc()```\n```myFunc```\n```cancelFn```\n```\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    let timer = setInterval(() => fn(...args), t);\\n\\n    let cancelFn = () => clearInterval(timer);\\n    return cancelFn;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3607759,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  var timerId;\\n  var time = 0;\\n  var result = [];\\n\\n  function executeFn() {\\n    var returnedValue = fn.apply(null, args);\\n    result.push({ time: time, returned: returnedValue });\\n    time += t;\\n  }\\n\\n  function cancelFn() {\\n    clearInterval(timerId);\\n  }\\n\\n  executeFn();\\n  timerId = setInterval(executeFn, t);\\n\\n  return cancelFn;\\n};\\n\\n\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  var timerId;\\n  var time = 0;\\n  var result = [];\\n\\n  function executeFn() {\\n    var returnedValue = fn.apply(null, args);\\n    result.push({ time: time, returned: returnedValue });\\n    time += t;\\n  }\\n\\n  function cancelFn() {\\n    clearInterval(timerId);\\n  }\\n\\n  executeFn();\\n  timerId = setInterval(executeFn, t);\\n\\n  return cancelFn;\\n};\\n\\n\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805614,
                "title": "pass-the-args-without-arrow-function",
                "content": "# Intuition\\n\\nThe setInterval function can accept the arguments without creating a closure using arrow functions. Simply pass them using the spread operator: `setInterval(fn, t, ...args)`.\\n\\n# Code\\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    fn(...args);\\n    const handle = setInterval(fn, t, ...args);\\n    return () => clearInterval(handle);\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    fn(...args);\\n    const handle = setInterval(fn, t, ...args);\\n    return () => clearInterval(handle);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3657902,
                "title": "90-easy-recursive-solution",
                "content": "# Intuition\\nSince loop will break the application, it is wise to use recursion.\\n\\n# Approach\\nEach recursive call of setTimeout callback will call fn(...args), stop if stop function was called, and then call itself again.\\n\\n# Code\\n```\\nvar cancellable = function(fn, args, t) {\\n    let stop = false;\\n    fn(...args);\\n\\n    const startTimer = () => {\\n        setTimeout(() => {\\n            fn(...args);\\n            if (stop) return;\\n            startTimer();\\n        }, t)\\n    }\\n\\n   startTimer();\\n\\n    const stopF = () => {\\n        stop = true;\\n    }\\n\\n    return stopF;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar cancellable = function(fn, args, t) {\\n    let stop = false;\\n    fn(...args);\\n\\n    const startTimer = () => {\\n        setTimeout(() => {\\n            fn(...args);\\n            if (stop) return;\\n            startTimer();\\n        }, t)\\n    }\\n\\n   startTimer();\\n\\n    const stopF = () => {\\n        stop = true;\\n    }\\n\\n    return stopF;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3608415,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  fn(...args);\\n\\n  let id = setTimeout(function run() {\\n    fn(...args);\\n    id = setTimeout(run, t);\\n  }, t);\\n\\n  const cancelFn = () => clearTimeout(id);\\n\\n  return cancelFn; \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  fn(...args);\\n\\n  let id = setTimeout(function run() {\\n    fn(...args);\\n    id = setTimeout(run, t);\\n  }, t);\\n\\n  const cancelFn = () => clearTimeout(id);\\n\\n  return cancelFn; \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3670460,
                "title": "solution-with-setinterval-and-settimeout-with-explanation",
                "content": "# Intuition\\n1. using setInterval - you can just retun a function that clears the interval.\\n2. using setTimeout - here I create my own setInterval using setTimeout\\n\\n# Approach\\n1.\\n    A. setInterval and save it\\'s ID\\n    B. return a function that clears your interval\\n2. A. create a setInterval-like function, I called mine `startInterval`. The startInterval function will use a `setTimeout` that keeps on retriggering the `setInterval`. It does this by calling the `startInterval` function that wraps the `setTimeout` when it\\'s time elapses.*\\n\\n*(To rephrase this:\\nI trigger a startInterval.\\nThis triggers a setTimeout for i.e. 30 seconds.\\nAt the end of the 30 seconds, we trigger the startInterval again,\\nwhich in turn triggers a setTimeout again for i.e. 30 seconds.\\nAt the end of the 30 seconds, we trigger the startInterval again...)\\n\\nB. We make sure the `startInterval` function has a \"circuit breaker\" boolean flag, here `isActive`. If we turned this flag off, we stop calling the `setTimeout` wrapper function (aka `startInterval`).\\n\\n\\n# Code\\n```\\n/*\\n// Using setInterval()\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    let intervalID = setInterval(() => fn(...args), t);\\n\\n    return function cancelFn () {\\n        clearInterval(intervalID);\\n    }\\n}\\n*/\\n\\n// Using setTimeout()\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n\\n    let timeoutID;\\n    let isActive = true;\\n\\n    const startInterval = () => {\\n        timeoutID = setTimeout(() => {\\n            if(isActive) {\\n                fn(...args);\\n                startInterval();\\n            }\\n        }, t);\\n    }\\n    startInterval();\\n\\n    return function cancelFn () {\\n        clearTimeout(timeoutID);\\n        isActive = false;\\n    }\\n};\\n",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "# Intuition\\n1. using setInterval - you can just retun a function that clears the interval.\\n2. using setTimeout - here I create my own setInterval using setTimeout\\n\\n# Approach\\n1.\\n    A. setInterval and save it\\'s ID\\n    B. return a function that clears your interval\\n2. A. create a setInterval-like function, I called mine `startInterval`. The startInterval function will use a `setTimeout` that keeps on retriggering the `setInterval`. It does this by calling the `startInterval` function that wraps the `setTimeout` when it\\'s time elapses.*\\n\\n*(To rephrase this:\\nI trigger a startInterval.\\nThis triggers a setTimeout for i.e. 30 seconds.\\nAt the end of the 30 seconds, we trigger the startInterval again,\\nwhich in turn triggers a setTimeout again for i.e. 30 seconds.\\nAt the end of the 30 seconds, we trigger the startInterval again...)\\n\\nB. We make sure the `startInterval` function has a \"circuit breaker\" boolean flag, here `isActive`. If we turned this flag off, we stop calling the `setTimeout` wrapper function (aka `startInterval`).\\n\\n\\n# Code\\n```\\n/*\\n// Using setInterval()\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    let intervalID = setInterval(() => fn(...args), t);\\n\\n    return function cancelFn () {\\n        clearInterval(intervalID);\\n    }\\n}\\n*/\\n\\n// Using setTimeout()\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n\\n    let timeoutID;\\n    let isActive = true;\\n\\n    const startInterval = () => {\\n        timeoutID = setTimeout(() => {\\n            if(isActive) {\\n                fn(...args);\\n                startInterval();\\n            }\\n        }, t);\\n    }\\n    startInterval();\\n\\n    return function cancelFn () {\\n        clearTimeout(timeoutID);\\n        isActive = false;\\n    }\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3607260,
                "title": "javascript-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    \\n    fn(...args);\\n    \\n    let id = setInterval(() => {\\n        fn(...args);\\n    },t);\\n\\n    let cancelFn = () => clearInterval(id);\\n\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    \\n    fn(...args);\\n    \\n    let id = setInterval(() => {\\n        fn(...args);\\n    },t);\\n\\n    let cancelFn = () => clearInterval(id);\\n\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013787,
                "title": "71-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n   fn(...args)\\n\\n   let id = setInterval(()=>{\\n      fn(...args)\\n   },t)\\n\\n   let cancelFn = ()=> clearInterval(id)\\n\\n   return cancelFn\\n\\n\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 35, cancelT = 190\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":35,\"returned\":8},\\n *                         //      {\"time\":70,\"returned\":8},           \\n *                         //      {\"time\":105,\"returned\":8},\\n *                         //      {\"time\":140,\"returned\":8},\\n *                         //      {\"time\":175,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n   fn(...args)\\n\\n   let id = setInterval(()=>{\\n      fn(...args)\\n   },t)\\n\\n   let cancelFn = ()=> clearInterval(id)\\n\\n   return cancelFn\\n\\n\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 35, cancelT = 190\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":35,\"returned\":8},\\n *                         //      {\"time\":70,\"returned\":8},           \\n *                         //      {\"time\":105,\"returned\":8},\\n *                         //      {\"time\":140,\"returned\":8},\\n *                         //      {\"time\":175,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3628915,
                "title": "ts-recursive-calls-with-boolean-flag-69ms-42-6mb",
                "content": "Nice warm up problem we can fix thinking of a series of recursive calls that are perpetuated by a boolean flag: each function will keep calling itself (after `t` ms, via a timeout), as long as the boolean flag is not flipped.\\n\\nSo, we will start declaring our boolean flag `shouldRepeat` with a value of `true`.\\n\\nRight after, we need a function to unflag it and nothing else - this will be our first helper `cancel`, that will turn `shouldRepeat` to `false` when invoked.\\n\\nFinally, our many recursive function `repeat` will:\\n* call `fn` with the provided `args`, as requested;\\n* set a timeout to invoke `repeat` again in `t` milliseconds, but only if `shouldRepeat` is still `true`.\\n\\nWe will then boot `repeat` up and `return` `cancel`.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```ts\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    // support variables\\n    let shouldRepeat = true;\\n    // helper functions\\n    const cancel = () => shouldRepeat = false;\\n    const repeat = () => {\\n        fn(...args);\\n        setTimeout(() => {\\n            shouldRepeat && repeat();\\n        }, t);\\n    }\\n    // booting repeat up\\n    repeat();\\n    return cancel;\\n};\\n```\\n\\nAlternatively, `cancel` can just be `return`ed as a lambda:\\n\\n```ts\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    // support variables\\n    let shouldRepeat = true;\\n    // helper function\\n    const repeat = () => {\\n        fn(...args);\\n        setTimeout(() => {\\n            shouldRepeat && repeat();\\n        }, t);\\n    }\\n    // booting repeat up\\n    repeat();\\n    return () => shouldRepeat = false;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Recursion"
                ],
                "code": "```ts\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    // support variables\\n    let shouldRepeat = true;\\n    // helper functions\\n    const cancel = () => shouldRepeat = false;\\n    const repeat = () => {\\n        fn(...args);\\n        setTimeout(() => {\\n            shouldRepeat && repeat();\\n        }, t);\\n    }\\n    // booting repeat up\\n    repeat();\\n    return cancel;\\n};\\n```\n```ts\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    // support variables\\n    let shouldRepeat = true;\\n    // helper function\\n    const repeat = () => {\\n        fn(...args);\\n        setTimeout(() => {\\n            shouldRepeat && repeat();\\n        }, t);\\n    }\\n    // booting repeat up\\n    repeat();\\n    return () => shouldRepeat = false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4100154,
                "title": "sime-and-easy-js-ts-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype Fn = (...args: JSONValue[]) => void\\n\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    fn( ...args );\\n    const ref = setInterval(() => {\\n        fn(...args);\\n        }, t);\\n    return (cancelT: number) => setTimeout(()=>{\\n        clearInterval(ref);\\n    }, cancelT)\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 35, cancelT = 190\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":35,\"returned\":8},\\n *                         //      {\"time\":70,\"returned\":8},           \\n *                         //      {\"time\":105,\"returned\":8},\\n *                         //      {\"time\":140,\"returned\":8},\\n *                         //      {\"time\":175,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype Fn = (...args: JSONValue[]) => void\\n\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    fn( ...args );\\n    const ref = setInterval(() => {\\n        fn(...args);\\n        }, t);\\n    return (cancelT: number) => setTimeout(()=>{\\n        clearInterval(ref);\\n    }, cancelT)\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 35, cancelT = 190\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":35,\"returned\":8},\\n *                         //      {\"time\":70,\"returned\":8},           \\n *                         //      {\"time\":105,\"returned\":8},\\n *                         //      {\"time\":140,\"returned\":8},\\n *                         //      {\"time\":175,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4089352,
                "title": "interval-cancellation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timerID=setInterval(() =>fn(...args),t);\\n    (() => {\\n       fn(...args)\\n    })();\\n    const cancelFn=()=>{\\n        clearTimeout(timerID)\\n    }\\n    return cancelFn\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 35, cancelT = 190\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":35,\"returned\":8},\\n *                         //      {\"time\":70,\"returned\":8},           \\n *                         //      {\"time\":105,\"returned\":8},\\n *                         //      {\"time\":140,\"returned\":8},\\n *                         //      {\"time\":175,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timerID=setInterval(() =>fn(...args),t);\\n    (() => {\\n       fn(...args)\\n    })();\\n    const cancelFn=()=>{\\n        clearTimeout(timerID)\\n    }\\n    return cancelFn\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 35, cancelT = 190\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":35,\"returned\":8},\\n *                         //      {\"time\":70,\"returned\":8},           \\n *                         //      {\"time\":105,\"returned\":8},\\n *                         //      {\"time\":140,\"returned\":8},\\n *                         //      {\"time\":175,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4087798,
                "title": "interval-cancellation-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    let timer = setInterval(()=>fn(...args),t);\\n\\n    \\n    const cancelling = () => clearInterval(timer)\\n    return cancelling;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 35, cancelT = 190\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":35,\"returned\":8},\\n *                         //      {\"time\":70,\"returned\":8},           \\n *                         //      {\"time\":105,\"returned\":8},\\n *                         //      {\"time\":140,\"returned\":8},\\n *                         //      {\"time\":175,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    let timer = setInterval(()=>fn(...args),t);\\n\\n    \\n    const cancelling = () => clearInterval(timer)\\n    return cancelling;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 35, cancelT = 190\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":35,\"returned\":8},\\n *                         //      {\"time\":70,\"returned\":8},           \\n *                         //      {\"time\":105,\"returned\":8},\\n *                         //      {\"time\":140,\"returned\":8},\\n *                         //      {\"time\":175,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4060177,
                "title": "easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    let id=setInterval(()=>{\\n        fn(...args)\\n    },t)\\n     let x= ()=>{clearInterval(id)}\\n     return x;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 35, cancelT = 190\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":35,\"returned\":8},\\n *                         //      {\"time\":70,\"returned\":8},           \\n *                         //      {\"time\":105,\"returned\":8},\\n *                         //      {\"time\":140,\"returned\":8},\\n *                         //      {\"time\":175,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    let id=setInterval(()=>{\\n        fn(...args)\\n    },t)\\n     let x= ()=>{clearInterval(id)}\\n     return x;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 35, cancelT = 190\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":35,\"returned\":8},\\n *                         //      {\"time\":70,\"returned\":8},           \\n *                         //      {\"time\":105,\"returned\":8},\\n *                         //      {\"time\":140,\"returned\":8},\\n *                         //      {\"time\":175,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055667,
                "title": "beats-94-67",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n\\n    \\n    fn(...args)\\n\\n    const interval=setInterval(() => fn(...args),t)\\n  \\n    const clearIntr=() => {\\n        clearInterval(interval)\\n    }\\n\\n    return clearIntr;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 35, cancelT = 190\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":35,\"returned\":8},\\n *                         //      {\"time\":70,\"returned\":8},           \\n *                         //      {\"time\":105,\"returned\":8},\\n *                         //      {\"time\":140,\"returned\":8},\\n *                         //      {\"time\":175,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n\\n    \\n    fn(...args)\\n\\n    const interval=setInterval(() => fn(...args),t)\\n  \\n    const clearIntr=() => {\\n        clearInterval(interval)\\n    }\\n\\n    return clearIntr;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 35, cancelT = 190\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":35,\"returned\":8},\\n *                         //      {\"time\":70,\"returned\":8},           \\n *                         //      {\"time\":105,\"returned\":8},\\n *                         //      {\"time\":140,\"returned\":8},\\n *                         //      {\"time\":175,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4043124,
                "title": "javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n\\n    fn(...args);\\n    const interval = setInterval(()=>{\\n        fn(...args);\\n    }, t);\\n    return () => {\\n        clearInterval(interval);\\n    };\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 35, cancelT = 190\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":35,\"returned\":8},\\n *                         //      {\"time\":70,\"returned\":8},           \\n *                         //      {\"time\":105,\"returned\":8},\\n *                         //      {\"time\":140,\"returned\":8},\\n *                         //      {\"time\":175,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n\\n    fn(...args);\\n    const interval = setInterval(()=>{\\n        fn(...args);\\n    }, t);\\n    return () => {\\n        clearInterval(interval);\\n    };\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 35, cancelT = 190\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":35,\"returned\":8},\\n *                         //      {\"time\":70,\"returned\":8},           \\n *                         //      {\"time\":105,\"returned\":8},\\n *                         //      {\"time\":140,\"returned\":8},\\n *                         //      {\"time\":175,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035958,
                "title": "z",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\nfn(...args)\\nconst cancelFn = () => {clearInterval(ss)}\\nconst ss = setInterval(()=>{\\nreturn fn(...args)\\n},t);\\nreturn cancelFn\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 35, cancelT = 190\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":35,\"returned\":8},\\n *                         //      {\"time\":70,\"returned\":8},           \\n *                         //      {\"time\":105,\"returned\":8},\\n *                         //      {\"time\":140,\"returned\":8},\\n *                         //      {\"time\":175,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\nfn(...args)\\nconst cancelFn = () => {clearInterval(ss)}\\nconst ss = setInterval(()=>{\\nreturn fn(...args)\\n},t);\\nreturn cancelFn\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 35, cancelT = 190\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":35,\"returned\":8},\\n *                         //      {\"time\":70,\"returned\":8},           \\n *                         //      {\"time\":105,\"returned\":8},\\n *                         //      {\"time\":140,\"returned\":8},\\n *                         //      {\"time\":175,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4030912,
                "title": "simple-solution-with-explanation",
                "content": "# Explanation\\n`setInterval` calls the provided function the first time at the given time but we are asked to call the `fn(...args)` immediately and then call the function on provided time interval. So in order do so\\n\\n- First call the function `fn(...args)` without itself\\n- Then use The `setInterval` to call the same function `fn(...args)`\\n again.\\n- Now this setInterval will keep calling the function until it is cleared so when the cancenFn is called, it clears the intervalId.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args)\\n    let intervalId = setInterval(() => fn(...args), t)\\n\\n    return function cancelFn() {\\n        clearInterval(intervalId)\\n    }\\n    \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 35, cancelT = 190\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":35,\"returned\":8},\\n *                         //      {\"time\":70,\"returned\":8},           \\n *                         //      {\"time\":105,\"returned\":8},\\n *                         //      {\"time\":140,\"returned\":8},\\n *                         //      {\"time\":175,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args)\\n    let intervalId = setInterval(() => fn(...args), t)\\n\\n    return function cancelFn() {\\n        clearInterval(intervalId)\\n    }\\n    \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 35, cancelT = 190\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":35,\"returned\":8},\\n *                         //      {\"time\":70,\"returned\":8},           \\n *                         //      {\"time\":105,\"returned\":8},\\n *                         //      {\"time\":140,\"returned\":8},\\n *                         //      {\"time\":175,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4028039,
                "title": "beats-90-56-of-users-with-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    \\n    fn(...args);\\n    \\n    let id = setInterval(() => {\\n        fn(...args);\\n    },t);\\n\\n    let cancelFn = () => clearInterval(id);\\n\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    \\n    fn(...args);\\n    \\n    let id = setInterval(() => {\\n        fn(...args);\\n    },t);\\n\\n    let cancelFn = () => clearInterval(id);\\n\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4018501,
                "title": "line-by-line-explanation-beginner-friendly-javascript",
                "content": "# Explanation\\n1. Initialize an array results to store the results along with timestamps.\\n2. Immediately, we call fn with the provided args and store the initial result with a timestamp of 0 in results.\\n3. Set up an interval using setInterval to repeatedly call fn with the provided args at intervals of t milliseconds. Each result is stored with its respective timestamp in results.\\n4. Define a cancelFn function that cancels the interval using clearInterval when called. It also logs the results.\\n5. Finally, return the cancelFn function, allowing you to cancel the execution of fn and retrieve the results if needed.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const results = [];\\n\\n    // Immediately call fn and store the result\\n    const initialResult = fn(...args);\\n    results.push({ time: 0, returned: initialResult });\\n\\n    // Set an interval to call fn repeatedly with a delay of t milliseconds\\n    const intervalId = setInterval(() => {\\n        const result = fn(...args);\\n        results.push({ time: new Date().getTime(), returned: result });\\n    }, t);\\n\\n    // Define the cancellation function\\n    const cancelFn = function() {\\n        clearInterval(intervalId); // Cancel the interval\\n        console.log(results); // Output the results\\n    };\\n\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 35, cancelT = 190\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":35,\"returned\":8},\\n *                         //      {\"time\":70,\"returned\":8},           \\n *                         //      {\"time\":105,\"returned\":8},\\n *                         //      {\"time\":140,\"returned\":8},\\n *                         //      {\"time\":175,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const results = [];\\n\\n    // Immediately call fn and store the result\\n    const initialResult = fn(...args);\\n    results.push({ time: 0, returned: initialResult });\\n\\n    // Set an interval to call fn repeatedly with a delay of t milliseconds\\n    const intervalId = setInterval(() => {\\n        const result = fn(...args);\\n        results.push({ time: new Date().getTime(), returned: result });\\n    }, t);\\n\\n    // Define the cancellation function\\n    const cancelFn = function() {\\n        clearInterval(intervalId); // Cancel the interval\\n        console.log(results); // Output the results\\n    };\\n\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 35, cancelT = 190\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":35,\"returned\":8},\\n *                         //      {\"time\":70,\"returned\":8},           \\n *                         //      {\"time\":105,\"returned\":8},\\n *                         //      {\"time\":140,\"returned\":8},\\n *                         //      {\"time\":175,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4014626,
                "title": "best-of-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    let id = setInterval(() => {\\n        fn(...args);\\n    },t);\\n    let cancelFn = () => clearInterval(id);\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 35, cancelT = 190\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":35,\"returned\":8},\\n *                         //      {\"time\":70,\"returned\":8},           \\n *                         //      {\"time\":105,\"returned\":8},\\n *                         //      {\"time\":140,\"returned\":8},\\n *                         //      {\"time\":175,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    let id = setInterval(() => {\\n        fn(...args);\\n    },t);\\n    let cancelFn = () => clearInterval(id);\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 35, cancelT = 190\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":35,\"returned\":8},\\n *                         //      {\"time\":70,\"returned\":8},           \\n *                         //      {\"time\":105,\"returned\":8},\\n *                         //      {\"time\":140,\"returned\":8},\\n *                         //      {\"time\":175,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4002370,
                "title": "easy-simple-fast-beats-98-41-and-space-efficient-beats-99-09",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    const timeI= setInterval(()=>fn(...args),t);\\n    return ()=> clearInterval(timeI);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 35, cancelT = 190\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":35,\"returned\":8},\\n *                         //      {\"time\":70,\"returned\":8},           \\n *                         //      {\"time\":105,\"returned\":8},\\n *                         //      {\"time\":140,\"returned\":8},\\n *                         //      {\"time\":175,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    const timeI= setInterval(()=>fn(...args),t);\\n    return ()=> clearInterval(timeI);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 35, cancelT = 190\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":35,\"returned\":8},\\n *                         //      {\"time\":70,\"returned\":8},           \\n *                         //      {\"time\":105,\"returned\":8},\\n *                         //      {\"time\":140,\"returned\":8},\\n *                         //      {\"time\":175,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3974448,
                "title": "easy-solution-with-4lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is just like the previous question in this one we would use clearInterval apart from clearTimeout.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    const timer = setInterval(fn , t, ...args);\\n\\n    const cancelFn = () => clearInterval(timer);\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 35, cancelT = 190\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":35,\"returned\":8},\\n *                         //      {\"time\":70,\"returned\":8},           \\n *                         //      {\"time\":105,\"returned\":8},\\n *                         //      {\"time\":140,\"returned\":8},\\n *                         //      {\"time\":175,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    const timer = setInterval(fn , t, ...args);\\n\\n    const cancelFn = () => clearInterval(timer);\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 35, cancelT = 190\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":35,\"returned\":8},\\n *                         //      {\"time\":70,\"returned\":8},           \\n *                         //      {\"time\":105,\"returned\":8},\\n *                         //      {\"time\":140,\"returned\":8},\\n *                         //      {\"time\":175,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3959052,
                "title": "js-clear-solution-with-explanation",
                "content": "**fn(...args);** - calling a passed function immediately with a destructured array of arguments (we need to destructure because each **fn** operates on separate arguments inside, according to test scenarios)\\n\\n**let interval = setInterval(()=> fn(...args), t);** - setting an interval to call our **fn** function from the parameters every **t**, saving an interval to a variable to have the abtity to clear it later\\n\\n**return function() {clearInterval(interval);}** - returning a function to clear interval when called.\\n\\n\\n# Code\\n```\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    let interval = setInterval(()=> fn(...args), t);\\n\\n    return function() {\\n        clearInterval(interval);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    let interval = setInterval(()=> fn(...args), t);\\n\\n    return function() {\\n        clearInterval(interval);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3958919,
                "title": "beats-81-27-of-users-with-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    var cancelled = false;\\n    fn(...args);\\n    const cancelFn = () => { \\n        clearTimeout(timeoutId); \\n        cancelled = true;\\n    };\\n    const timeoutId = setInterval(() => {\\n        if(!cancelled)\\n            fn(...args);\\n    }, t);\\n    return cancelFn;\\n}\\n    \\n\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 35, cancelT = 190\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":35,\"returned\":8},\\n *                         //      {\"time\":70,\"returned\":8},           \\n *                         //      {\"time\":105,\"returned\":8},\\n *                         //      {\"time\":140,\"returned\":8},\\n *                         //      {\"time\":175,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    var cancelled = false;\\n    fn(...args);\\n    const cancelFn = () => { \\n        clearTimeout(timeoutId); \\n        cancelled = true;\\n    };\\n    const timeoutId = setInterval(() => {\\n        if(!cancelled)\\n            fn(...args);\\n    }, t);\\n    return cancelFn;\\n}\\n    \\n\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 35, cancelT = 190\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":35,\"returned\":8},\\n *                         //      {\"time\":70,\"returned\":8},           \\n *                         //      {\"time\":105,\"returned\":8},\\n *                         //      {\"time\":140,\"returned\":8},\\n *                         //      {\"time\":175,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3948196,
                "title": "short-simple-javascript",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args)\\n    const myInt = setInterval(() => {\\n        fn(...args)\\n    }, t)\\n\\n    return(() => {\\n        clearInterval(myInt)\\n    })\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args)\\n    const myInt = setInterval(() => {\\n        fn(...args)\\n    }, t)\\n\\n    return(() => {\\n        clearInterval(myInt)\\n    })\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938288,
                "title": "typescript-short-solution",
                "content": "# Complexity\\n- Time complexity: $O(1)$\\n- Space complexity: $O(1)$\\n# Code\\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    fn( ...args );\\n    const ref = setInterval( fn, t, ...args );\\n    return ( cancelT: number ) => setTimeout( clearInterval, cancelT, ref )\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    fn( ...args );\\n    const ref = setInterval( fn, t, ...args );\\n    return ( cancelT: number ) => setTimeout( clearInterval, cancelT, ref )\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3936442,
                "title": "editorial-solution-with-explaination-and-interview-tips",
                "content": "# Overview:\\n\\nYou are given a function fn, an array of arguments args, and an interval time t. You need to implement a function cancelFn that calls fn immediately with args and then schedules subsequent calls to fn every t milliseconds until cancelFn is called.\\n\\n# Use Cases:\\n\\n- **Auto-Saving in Editing Applications:** When working with text editors, document processors, or other content creation tools, it\\'s common to have an auto-save feature that periodically saves changes. You can use interval cancellation to schedule auto-saving at regular intervals. If the user explicitly saves the document or exits the application, you can cancel the interval to prevent unnecessary saving operations.\\n\\n- **Animation and Slideshow Timings:** While doing development, you may want to create animations or slideshows that automatically transition between different states or images. You can use interval cancellation to control the timing of these transitions. If the user interacts with the animation or slideshow, you can cancel the interval to pause or stop the automatic progression.\\n\\nNote: For more complex or performance-critical animations, it\\'s recommended to use the requestAnimationFrame method instead of setInterval, as it provides better performance and efficiency.\\n\\n- **Time-based Reminders:** Consider a task management application where users can set reminders for specific tasks. You can use interval cancellation to trigger reminders at specified intervals. Once the user acknowledges the reminder or the task is completed, you can cancel the interval to stop further reminders.\\n___\\n\\nBefore going any further we need to learn two concepts i.e ```setInterval``` and ```clearInterval```.\\n\\n1. **setInterval**:\\n    The ```setInterval``` function is used to repeatedly execute a function or a code snippet with a fixed time delay between each call. It takes two arguments: the function or code snippet to be executed, and the time delay specified in milliseconds.\\n```\\nsetInterval(function, delay);\\n```\\n\\n- The ```function``` parameter represents the function or code snippet that will be executed at each interval.\\n- The ```delay``` parameter specifies the time delay in milliseconds between each execution of the function.\\n\\nWhen ```setInterval``` is called, it schedules the first execution of the specified function after the initial delay. Subsequent executions will occur repeatedly based on the specified delay.\\n```setInterval``` returns an interval ID, which is a unique numeric value. This ID can be used later to identify and control the interval schedule. Also just a note that ```setInterval``` is not totally precise.\\n\\n2. **clearInterval**:\\n    The ```clearInterval``` function is used to cancel a timed, repeating action that was previously established by a call to ```setInterval```. It takes the interval ID returned by ```setInterval``` as an argument.\\n```\\nclearInterval(intervalID);\\n ```\\n- The intervalID parameter represents the unique ID returned by the setInterval function when the interval was created.\\nBy calling clearInterval with the appropriate interval ID, you can effectively stop the subsequent executions of the function specified in setInterval. It cancels the scheduled interval and prevents any further calls to the specified function.\\n---\\n## Approach 1: Using setInterval & clearInterval\\n\\nTo set an interval timer, we use the ```setInterval``` function. In the code snippet below, ```setInterval``` will repeatedly call ```() => fn(...args)``` every ```t``` milliseconds. It\\'s important to note that setInterval does not immediately call the function before t milliseconds, which is why we manually call fn(...args) once before setting the interval.\\n\\nNext, we define a function called ```cancelFn``` that clears the interval when it\\'s called. We return ```cancelFn``` from the main function. It\\'s worth mentioning that cancelFn is not called when our cancellable function is initially defined. However, whenever the ```cancellable``` function is called, it returns cancelFn. The cancelFn can then be called at a later time to clear the interval.\\n\\n### Implementation:\\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    fn(...args);\\n    const timer = setInterval(() => fn(...args), t);\\n\\n    const cancelFn = () => clearInterval(timer);\\n    return cancelFn;\\n}\\n```\\n### Complexity Analysis:\\n\\n- **Time complexity:** O(1)\\n\\n- **Space complexity**: O(1)\\n---\\n# Approach 2: Using Recursion\\n### Intuition:\\n\\nWe can set up a timed interval where the function is repeatedly executed. This will provide a way to cancel the interval execution when desired. In a more simpler words each function will keep calling itself (after t ms, via a timeout), as long as the boolean flag is not flipped.\\n### Algorithm:\\n\\nWhen we call the ```cancellable``` function, it first executes the provided function```(fn)``` with the given arguments (args) i.e ```(fn(...args))```. This ensures that the function is called at least once before we start the interval.\\n\\nNext, we define an internal function called ```startInterval```. This function will be held for setting up the interval by using ```setTimeout```. It waits for the specified t and then executes the function (fn) again. It repeats this process until we decide to cancel the interval which will be decided by the boolean isCancelled that we declared in the start of the code.\\n\\nTo create this repeated execution, ```startInterval``` uses a clever trick. It calls itself recursively within the ```setTimeout``` callback function. This means that after each execution of the function, it schedules the next execution by calling ```startInterval``` again. This creates a loop-like behavior where the function is executed, and then ```startInterval``` is called again to schedule the next execution.\\n\\n## Implementation 1:\\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n  let isCancelled: boolean = false;\\n  fn(...args);\\n  \\n  const startInterval = (): void => {\\n    setTimeout(() => {\\n      fn(...args);\\n      if (isCancelled) return;\\n      startInterval();\\n    }, t);\\n  };\\n  \\n  startInterval();\\n  \\n  const cancelInterval: Function = (): void => {\\n    isCancelled = true;\\n  };\\n\\n  return cancelInterval;\\n}\\n```\\n## Implementation 2:\\nImplementation 1 is good, but it\\'s more efficient to use ```clearTimeout``` to clear those recursive timeouts, this approach ensures that the callback isn\\'t called unnecessarily:\\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n  let timerId = null;\\n  fn(...args);\\n\\n  const startInterval = (): void => {\\n    timerId = setTimeout(() => {\\n      fn(...args);\\n      startInterval();\\n    }, t);\\n  };\\n  startInterval();\\n\\n  const cancelInterval: Function = (): void => {\\n    if (timerId !== null) {\\n      clearTimeout(timerId);\\n    }\\n  };\\n\\n  return cancelInterval;\\n}\\n```\\n### Complexity Analysis:\\n\\nIn the given implementations , the execution involves setting a ```setTimeout``` function with a delay of ```t``` milliseconds. However, it\\'s important to note that the scheduling of the function call does not introduce recursion or affect the complexity in terms of the JavaScript engine\\'s memory usage.\\n\\nLet\\'s dig a little deeper:\\n\\n- The JavaScript engine initializes and creates the context for the cancellable function.\\n- The statements of the cancellable function, including the setTimeout call, are executed.\\n- The setTimeout function instructs the JavaScript engine to schedule a function call after a delay of t milliseconds.\\n- The context of the cancellable function is destroyed, and the JavaScript engine continues with other operations.\\n- At this point, in terms of memory usage, the JavaScript engine returns to its initial state without any additional memory allocation or recursion. The only remaining information is a reference to the function and the scheduled time for the future call.\\n- After the specified delay, the JavaScript engine executes the scheduled function without any impact on memory usage or recursion.\\n- Once the function execution is completed, any remaining references or data related to the scheduled call are cleared.\\n\\nConsidering this sequence of events, we can conclude that the complexity of this code, is constant``` O(1)```. The memory utilization does not grow with the duration of the delay, and there is no recursion or memory buildup as the JavaScript engine handles the scheduling and execution of the function independently.\\n\\n- **Time complexity:** O(1)\\n\\n- **Space complexity:** O(1)\\n---\\n\\n# Interview Tips:\\n\\n- Can the interval time be dynamically changed after it has been set?\\n    - Yes, the interval time can be dynamically changed by canceling the existing interval using clearInterval and then setting a new interval using setInterval with the updated time. This allows you to adjust the timing dynamically based on changing requirements or user interactions.\\n\\n    Note: While it\\'s true that you can create the illusion of a dynamic interval by clearing and resetting it, it\\'s important to note that this doesn\\'t truly change the original interval time dynamically. It rather cancels the previous interval and starts a new one.\\n\\n- Are there any limitations or performance considerations to keep in mind when using interval cancellation?\\n    - When working with interval cancellation, it\\'s important to consider the interval time and the potential impact on performance. Frequent and short intervals can consume significant CPU resources. Additionally, if the execution time of the ```fn``` function is longer than the interval time, the subsequent calls may overlap, leading to unexpected behavior. It\\'s crucial to ensure the interval time and the execution time of ```fn``` are appropriately balanced. That\\'s why in some situations it is highly recommended to use something else like ```requestAnimationFrame```.\\n    - The ```requestAnimationFrame``` accepts a single parameter, a function to execute. When the browser is ready to repaint the screen, the function you specify to ```requestAnimationFrame``` will be called. When this function runs, it depends on the CPU power of the computer executing the code, the refresh rate of the display the browser is on, and a few other criteria to guarantee the animation is as smooth as possible while taking as little resources as feasible.\\n\\n- What happens if the interval time ```(t)``` is set to a negative value or zero?\\n    - It is going to execute immediately and continuously and will keep repeating for 0 or negative nums, potentially blocking the main thread and causing the browser to become unresponsive.\\n\\n- Is it possible to restart or reschedule the interval after it has been canceled?\\n    - While you can\\'t directly restart a canceled interval, you can create a new interval by calling setInterval again with the desired interval time and the function to be executed.\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```setInterval```\n```clearInterval```\n```setInterval```\n```\\nsetInterval(function, delay);\\n```\n```function```\n```delay```\n```setInterval```\n```setInterval```\n```setInterval```\n```clearInterval```\n```setInterval```\n```setInterval```\n```\\nclearInterval(intervalID);\\n ```\n```setInterval```\n```setInterval```\n```() => fn(...args)```\n```t```\n```cancelFn```\n```cancelFn```\n```cancellable```\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    fn(...args);\\n    const timer = setInterval(() => fn(...args), t);\\n\\n    const cancelFn = () => clearInterval(timer);\\n    return cancelFn;\\n}\\n```\n```cancellable```\n```(fn)```\n```(fn(...args))```\n```startInterval```\n```setTimeout```\n```startInterval```\n```setTimeout```\n```startInterval```\n```startInterval```\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n  let isCancelled: boolean = false;\\n  fn(...args);\\n  \\n  const startInterval = (): void => {\\n    setTimeout(() => {\\n      fn(...args);\\n      if (isCancelled) return;\\n      startInterval();\\n    }, t);\\n  };\\n  \\n  startInterval();\\n  \\n  const cancelInterval: Function = (): void => {\\n    isCancelled = true;\\n  };\\n\\n  return cancelInterval;\\n}\\n```\n```clearTimeout```\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n  let timerId = null;\\n  fn(...args);\\n\\n  const startInterval = (): void => {\\n    timerId = setTimeout(() => {\\n      fn(...args);\\n      startInterval();\\n    }, t);\\n  };\\n  startInterval();\\n\\n  const cancelInterval: Function = (): void => {\\n    if (timerId !== null) {\\n      clearTimeout(timerId);\\n    }\\n  };\\n\\n  return cancelInterval;\\n}\\n```\n```setTimeout```\n```t```\n``` O(1)```\n```fn```\n```fn```\n```requestAnimationFrame```\n```requestAnimationFrame```\n```requestAnimationFrame```\n```(t)```",
                "codeTag": "Unknown"
            },
            {
                "id": 3931444,
                "title": "javascript-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function (fn, args, t) {\\n    fn(...args);\\n    let timer = setInterval(() => fn(...args), t);\\n\\n    return () => clearInterval(timer);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function (fn, args, t) {\\n    fn(...args);\\n    let timer = setInterval(() => fn(...args), t);\\n\\n    return () => clearInterval(timer);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3930594,
                "title": "interval-cancellation-js-setinterval-clearinterval",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    func = () => fn(...args)\\n\\n    func()\\n    id = setInterval(func, t)\\n\\n    cancelFn = () => clearInterval(id)\\n\\n    return cancelFn\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    func = () => fn(...args)\\n\\n    func()\\n    id = setInterval(func, t)\\n\\n    cancelFn = () => clearInterval(id)\\n\\n    return cancelFn\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3907288,
                "title": "simple-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args)\\n    const intervalId = setInterval(() => fn(...args), t);\\n    return () => clearInterval(intervalId);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args)\\n    const intervalId = setInterval(() => fn(...args), t);\\n    return () => clearInterval(intervalId);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3892058,
                "title": "js-solution-runtime-60-ms-beats-88-92-memory-41-8-mb-beats-76-98",
                "content": "# Code\\n```\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    let interval = setInterval(()=>fn(...args),t);\\n    return ()=>clearInterval(interval);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    let interval = setInterval(()=>fn(...args),t);\\n    return ()=>clearInterval(interval);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3891360,
                "title": "simple-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    // create a variable to store the interval id\\n  var intervalId = null;\\n  // create a variable to store the cancellation flag\\n  var cancelled = false;\\n  // create a function to cancel the execution of fn\\n  var cancelFn = function() {\\n    // set the cancellation flag to true\\n    cancelled = true;\\n    // clear the interval if it exists\\n    if (intervalId) {\\n      clearInterval(intervalId);\\n    }\\n  };\\n  // call fn with args immediately\\n  fn(...args);\\n  // set an interval to execute fn every t milliseconds\\n  intervalId = setInterval(function() {\\n    // check if the cancellation flag is false\\n    if (!cancelled) {\\n      // call fn with args as parameters\\n      fn(...args);\\n    }\\n  }, t);\\n  // return the cancel function\\n  return cancelFn;  \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    // create a variable to store the interval id\\n  var intervalId = null;\\n  // create a variable to store the cancellation flag\\n  var cancelled = false;\\n  // create a function to cancel the execution of fn\\n  var cancelFn = function() {\\n    // set the cancellation flag to true\\n    cancelled = true;\\n    // clear the interval if it exists\\n    if (intervalId) {\\n      clearInterval(intervalId);\\n    }\\n  };\\n  // call fn with args immediately\\n  fn(...args);\\n  // set an interval to execute fn every t milliseconds\\n  intervalId = setInterval(function() {\\n    // check if the cancellation flag is false\\n    if (!cancelled) {\\n      // call fn with args as parameters\\n      fn(...args);\\n    }\\n  }, t);\\n  // return the cancel function\\n  return cancelFn;  \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3890224,
                "title": "here-is-one-way-to-doing-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    var timeout = setInterval(()=>{\\n        fn(...args);\\n    },t)\\n    var cancelFn = ()=>{\\n        clearInterval(timeout);\\n    }\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    var timeout = setInterval(()=>{\\n        fn(...args);\\n    },t)\\n    var cancelFn = ()=>{\\n        clearInterval(timeout);\\n    }\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3886466,
                "title": "solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args)\\n    const interval = setInterval(() =>fn(...args), t)\\n    return () => clearInterval(interval);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args)\\n    const interval = setInterval(() =>fn(...args), t)\\n    return () => clearInterval(interval);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3882505,
                "title": "full-explanation-easy-to-understand-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to use a timer object to repeatedly call the fn function. The cancelFn function is used to stop the timer.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to first call the fn function with the args passed as parameters. Then, the code creates a timer object that is set to fire every t milliseconds. When the timer fires, the fn function is called with the args passed as parameters.\\n\\nThe cancelFn function is then defined. The cancelFn function takes a parameter, cancelT, which is the time in milliseconds at which the timer should be stopped. The cancelFn function then calls the clearInterval() function to clear the timer object. This will prevent the fn function from being called again.\\n\\nThe return statement returns the cancelFn function. This allows the caller of the cancellable() function to stop the timer when they want to.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(1). This is because the solution only needs to create a timer object and call the fn function.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(1). This is because the solution only needs to store the timer object.\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    var check = setInterval(() => {\\n        fn(...args);\\n    }, t);\\n    var cancelFn = () => \\n        clearInterval(check);\\n\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    var check = setInterval(() => {\\n        fn(...args);\\n    }, t);\\n    var cancelFn = () => \\n        clearInterval(check);\\n\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3882480,
                "title": "full-explanation-easy-to-understand-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to use a timer object to repeatedly call the fn function. The cancelFn function is used to stop the timer.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to first call the fn function with the args passed as parameters. Then, the code creates a timer object that is set to fire every t milliseconds. When the timer fires, the fn function is called with the args passed as parameters.\\n\\nThe cancelFn function is then defined. The cancelFn function takes a parameter, cancelT, which is the time in milliseconds at which the timer should be stopped. The cancelFn function then calls the clearInterval() function to clear the timer object. This will prevent the fn function from being called again.\\n\\nThe return statement returns the cancelFn function. This allows the caller of the cancellable() function to stop the timer when they want to.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(1). This is because the solution only needs to create a timer object and call the fn function.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(1). This is because the solution only needs to store the timer object.\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    var check = setInterval(() => {\\n        fn(...args);\\n    }, t);\\n    var cancelFn = () => \\n        clearInterval(check);\\n\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    var check = setInterval(() => {\\n        fn(...args);\\n    }, t);\\n    var cancelFn = () => \\n        clearInterval(check);\\n\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3876306,
                "title": "accepted-javascript",
                "content": "```\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    let i = setInterval(fn, t, ...args);\\n    return function() { clearInterval(i); };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    let i = setInterval(fn, t, ...args);\\n    return function() { clearInterval(i); };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3875061,
                "title": "beats-98-86-simple-solution-with-minimal-code",
                "content": "# Intuition\\nThese approach emphasizes achieving **performance with minimal code**.\\n\\nPlease **Upvote** if you find helpful.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    let intervalId = setInterval(()=> fn(...args), t);\\n    return () => clearInterval(intervalId);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    let intervalId = setInterval(()=> fn(...args), t);\\n    return () => clearInterval(intervalId);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3863209,
                "title": "easy-solution-iife",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNeed to start an interval, create a function to cancel/clear it, and also call the fn(args) immediately.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use the advantage of IIFE to immediatley call the fn(args), then start the interval inside of that function call. We can declare at the top of our main function scope a variable to capture the interval, so we can later clear it in our cancel function. So we do just that and create the cancel function. Then we just return the cancel function, and out interval will cancel when the timer reaches appropriately.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    //so we can clear in cancel\\n    let timer;\\n\\n    //IIFE\\n    (function(){\\n       fn(...args);\\n       timer = setInterval(() => {\\n           fn(...args);\\n       },t);\\n   })();\\n\\n    //define cancel\\n   var stopInterval = () => clearInterval(timer);\\n   \\n    //return so cancel gets called\\n   return stopInterval; \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    //so we can clear in cancel\\n    let timer;\\n\\n    //IIFE\\n    (function(){\\n       fn(...args);\\n       timer = setInterval(() => {\\n           fn(...args);\\n       },t);\\n   })();\\n\\n    //define cancel\\n   var stopInterval = () => clearInterval(timer);\\n   \\n    //return so cancel gets called\\n   return stopInterval; \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3848510,
                "title": "2725-interval-cancellation",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let lock = false;\\n    let results = [fn(...args)]\\n    let coroutine = () => setTimeout(() => {\\n        if (lock) return;\\n        results.push(fn(...args));\\n        coroutine();\\n    }, t);\\n    coroutine();\\n    return () => {lock = true}\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let lock = false;\\n    let results = [fn(...args)]\\n    let coroutine = () => setTimeout(() => {\\n        if (lock) return;\\n        results.push(fn(...args));\\n        coroutine();\\n    }, t);\\n    coroutine();\\n    return () => {lock = true}\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3840402,
                "title": "interval-cancellation-easy-solution-javascript",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n   fn(...args);\\n    const ref = setInterval(()=>fn(...args),t);\\n    return () => clearInterval(ref);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n   fn(...args);\\n    const ref = setInterval(()=>fn(...args),t);\\n    return () => clearInterval(ref);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3830251,
                "title": "setinterval-clearinterval",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args)\\n    const intervalTime = setInterval(()=>{\\n        fn(...args)\\n    },t)\\n    return cancelFn = ()=>{\\n        clearInterval(intervalTime)\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args)\\n    const intervalTime = setInterval(()=>{\\n        fn(...args)\\n    },t)\\n    return cancelFn = ()=>{\\n        clearInterval(intervalTime)\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3818359,
                "title": "interval-cancellation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n     let canceled = false;\\n\\n  const cancelFn = function () {\\n    canceled = true;\\n  };\\n\\n  function executeFn() {\\n    if (!canceled) {\\n      fn(...args);\\n    } else {\\n      clearInterval(intervalId);\\n    }\\n  }\\n\\n  const intervalId = setInterval(executeFn, t);\\n  executeFn(); // Execute the function immediately\\n\\n  return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n     let canceled = false;\\n\\n  const cancelFn = function () {\\n    canceled = true;\\n  };\\n\\n  function executeFn() {\\n    if (!canceled) {\\n      fn(...args);\\n    } else {\\n      clearInterval(intervalId);\\n    }\\n  }\\n\\n  const intervalId = setInterval(executeFn, t);\\n  executeFn(); // Execute the function immediately\\n\\n  return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3817526,
                "title": "clean-soln",
                "content": "\\n\\n# Code\\n```\\nconst cancellable = (fn, args, time) => {\\n  fn(...args)\\n  let timeout = setInterval(() => {\\n    fn(...args)\\n  }, time)\\n  return () => clearInterval(timeout)\\n\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst cancellable = (fn, args, time) => {\\n  fn(...args)\\n  let timeout = setInterval(() => {\\n    fn(...args)\\n  }, time)\\n  return () => clearInterval(timeout)\\n\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3816613,
                "title": "editorial-for-the-win",
                "content": "## Intuition\\nThis was a difficult one because the prompt didn\\'t give a great explanation of what is to be expected.\\n\\n## Approach\\nI had to read through the editorial to even get started with this one. I \"refined\" my solution by removing the comments and improved my runtime and memory.\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  fn(...args);\\n  \\n  const timer = setInterval(() => {\\n    return fn(...args);\\n  }, t);\\n\\n\\n  function cancelFn() {\\n    return clearInterval(timer);\\n  }\\n\\n  return cancelFn;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  fn(...args);\\n  \\n  const timer = setInterval(() => {\\n    return fn(...args);\\n  }, t);\\n\\n\\n  function cancelFn() {\\n    return clearInterval(timer);\\n  }\\n\\n  return cancelFn;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3813825,
                "title": "2725-interval-cancellation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  fn(...args)\\n  let d = setInterval(()=>fn(...args),t,...args)\\n  return ()=>clearInterval(d)\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  fn(...args)\\n  let d = setInterval(()=>fn(...args),t,...args)\\n  return ()=>clearInterval(d)\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3811090,
                "title": "javascript-o-1-solution",
                "content": "# Intuition\\nReturn a clearInterval of a setInterval\\n\\n# Approach\\n1. As the question says, we need to immediately call the function once, lets do it : fn(...args)\\n2. The question next asks to execute it every \\'t\\' ms, and we know setTimeout is a function that we can utillize for periodic execution.\\n3. Take a reference variable pointint to the memory location of this setInterval.\\n4. Return a clearInterrval of the ref. of setInterval to complete the questions\\' requirement.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nconst cancellable = (fn, args, t) => {\\n    fn(...args);\\n    const ref = setInterval(()=>fn(...args),t);\\n    return () => clearInterval(ref);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nconst cancellable = (fn, args, t) => {\\n    fn(...args);\\n    const ref = setInterval(()=>fn(...args),t);\\n    return () => clearInterval(ref);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3806171,
                "title": "implementation-via-setinterval-and-clearinterval-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nconst cancellable = (fn, args, t) => {\\n  fn.apply(null, args);\\n\\n  const intervalId = setInterval(function() {\\n    fn.apply(null, args);\\n  }, t);\\n\\n  const cancelFn = () => {\\n    clearInterval(intervalId);\\n  };\\n\\n  return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nconst cancellable = (fn, args, t) => {\\n  fn.apply(null, args);\\n\\n  const intervalId = setInterval(function() {\\n    fn.apply(null, args);\\n  }, t);\\n\\n  const cancelFn = () => {\\n    clearInterval(intervalId);\\n  };\\n\\n  return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3790010,
                "title": "simple-javascript-solution-using-setinterval-and-clearinterval-methods",
                "content": "\\n# Approach\\n1.We call function Fn(...args) immediately.\\n2.We used setInterval() to repeatedly call our function until delay time t.\\n  2.1.setInterval() here , takes 2 arguments .Function \\n      Fn(...args) and time delay t.\\n  2.2.This method returns an interval id which uniquely         identifies the interval\\n3.We can remove it by using clearInterval().\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n\\n    const intervalId = setInterval(()=>{\\n        fn(...args);\\n    },t);\\n\\n    function cancelFn(){\\n        clearInterval(intervalId);\\n    }\\n\\n    return cancelFn;\\n\\n\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n\\n    const intervalId = setInterval(()=>{\\n        fn(...args);\\n    },t);\\n\\n    function cancelFn(){\\n        clearInterval(intervalId);\\n    }\\n\\n    return cancelFn;\\n\\n\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3784228,
                "title": "interval-cancellation-using-the-setinterval-method",
                "content": "# Intuition\\nThe problem requires us to create a function that calls another given function fn immediately with the provided arguments `args` and then calls it again at regular intervals of `t` milliseconds until a cancel function `cancelFn` is called. To solve this problem, we need to set up an interval using `setInterval`, execute `fn` with `args` at each interval, and provide a way to cancel the interval when needed.\\n\\n# Approach\\nOur approach is to create a function `cancellable` that takes the function `fn`, an array of arguments $$args$$, and the interval time $$t$$ as inputs. In this function, we call `fn` once immediately with the provided $$args$$, and then set up an interval using `setInterval` to repeatedly call `fn` with $$args$$ every $$t$$ milliseconds. We store the interval ID returned by `setInterval` to use it later for cancellation. We also define a function `cancelFn` inside `cancellable`, which clears the interval using `clearInterval` when invoked. Finally, we return `cancelFn` so that the caller can use it to stop the recurring calls of `fn`.\\n\\n# Complexity\\n- Time complexity:\\n\\nThe time complexity of the cancellable function is constant, as it calls fn immediately and then sets up the interval using setInterval, which runs independently and doesn\\'t depend on the size of any input.\\n\\nSpace complexity:\\n\\nThe space complexity of the cancellable function is also constant. It only creates a few variables (intervalId, count, currentTime) and two functions (fn and cancelFn) that don\\'t scale with the input size. Hence, the space complexity is constant.\\n\\nIn summary, our solution has a time complexity of O(1) and a space complexity of O(1).\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n\\n    fn(...args)\\n\\n    let intervalId = setInterval(()=>{\\n        fn(...args)\\n    },t)\\n\\n    function cancelFn(){\\n        clearInterval(intervalId)\\n    }\\n\\n    return cancelFn\\n\\n   \\n    \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Intuition\\nThe problem requires us to create a function that calls another given function fn immediately with the provided arguments `args` and then calls it again at regular intervals of `t` milliseconds until a cancel function `cancelFn` is called. To solve this problem, we need to set up an interval using `setInterval`, execute `fn` with `args` at each interval, and provide a way to cancel the interval when needed.\\n\\n# Approach\\nOur approach is to create a function `cancellable` that takes the function `fn`, an array of arguments $$args$$, and the interval time $$t$$ as inputs. In this function, we call `fn` once immediately with the provided $$args$$, and then set up an interval using `setInterval` to repeatedly call `fn` with $$args$$ every $$t$$ milliseconds. We store the interval ID returned by `setInterval` to use it later for cancellation. We also define a function `cancelFn` inside `cancellable`, which clears the interval using `clearInterval` when invoked. Finally, we return `cancelFn` so that the caller can use it to stop the recurring calls of `fn`.\\n\\n# Complexity\\n- Time complexity:\\n\\nThe time complexity of the cancellable function is constant, as it calls fn immediately and then sets up the interval using setInterval, which runs independently and doesn\\'t depend on the size of any input.\\n\\nSpace complexity:\\n\\nThe space complexity of the cancellable function is also constant. It only creates a few variables (intervalId, count, currentTime) and two functions (fn and cancelFn) that don\\'t scale with the input size. Hence, the space complexity is constant.\\n\\nIn summary, our solution has a time complexity of O(1) and a space complexity of O(1).\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n\\n    fn(...args)\\n\\n    let intervalId = setInterval(()=>{\\n        fn(...args)\\n    },t)\\n\\n    function cancelFn(){\\n        clearInterval(intervalId)\\n    }\\n\\n    return cancelFn\\n\\n   \\n    \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3781377,
                "title": "step-by-step-easy-js-answer-fully-explained-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to perform a task at repeted intervals so it seems we will have to use set interval. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBased on the problem statement - First : invole fn function with arguments as provided (..args)\\n-Second : define a timer/anyOtherName function that executes the fn function again and aagin after t time intervals- Use setInterval\\n-Third : you have to define a cancel function what uses \\nclearInterval(intervalName) method so that it can be used to cancel the interval we defined earlier- Remember only define it  and not invoke the function(use syntax carefully)\\n-Finally : return the cancel function so that once it is returned it gets invoked and stops the timer.\\n\\nThese steps fulfill all the requirements of the question \\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args)\\n    var timer = setInterval(()=>{\\n        fn(...args)\\n    },t)\\n    \\n    var cancelFn = ()=>{\\n        clearInterval(timer)\\n    }\\n\\n    return cancelFn\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args)\\n    var timer = setInterval(()=>{\\n        fn(...args)\\n    },t)\\n    \\n    var cancelFn = ()=>{\\n        clearInterval(timer)\\n    }\\n\\n    return cancelFn\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3758024,
                "title": "2725-interval-cancellation-umarbek-s-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n     const intervalId = setInterval(() => {\\n    fn(...args);\\n  }, t);\\n\\n  const cancelFn = function() {\\n    clearInterval(intervalId);\\n  };\\n\\n  fn(...args); // Call the function immediately\\n\\n  return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n     const intervalId = setInterval(() => {\\n    fn(...args);\\n  }, t);\\n\\n  const cancelFn = function() {\\n    clearInterval(intervalId);\\n  };\\n\\n  fn(...args); // Call the function immediately\\n\\n  return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3757821,
                "title": "ts-very-easy-solution-setinterval-clearinterval",
                "content": "# Code\\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    fn(...args);\\n    const intervalId = setInterval(()=>{\\n        fn(...args);\\n    },t);\\n\\n    const cancelInterval:Function = ()=>{\\n        clearInterval(intervalId);\\n    }\\n    return cancelInterval;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    fn(...args);\\n    const intervalId = setInterval(()=>{\\n        fn(...args);\\n    },t);\\n\\n    const cancelInterval:Function = ()=>{\\n        clearInterval(intervalId);\\n    }\\n    return cancelInterval;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3746064,
                "title": "easy-3-line-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args)\\n    const id = setInterval(fn,t,...args)\\n    return cancelFn = () => {\\n        clearInterval(id)\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args)\\n    const id = setInterval(fn,t,...args)\\n    return cancelFn = () => {\\n        clearInterval(id)\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start)\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *   \\n *  setTimeout(() => {\\n *    console.log(result)  // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT + t + 15)    \\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3732755,
                "title": "my-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nvar cancellable = function(fn, args, t) {\\n    fn(...args)\\n    const id1 = setInterval(fn,t,...args)\\n    return cancelFn = () => {\\n        clearInterval(id1)\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar cancellable = function(fn, args, t) {\\n    fn(...args)\\n    const id1 = setInterval(fn,t,...args)\\n    return cancelFn = () => {\\n        clearInterval(id1)\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3721740,
                "title": "easiest-way-to-solve-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    let timeout = setInterval(()=> fn(...args),t)\\n    \\n\\n    let cancelFn = () => clearInterval(timeout)\\n\\n    return cancelFn\\n    \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *\\t\\tconst val = fn(...argsArr)\\n *      result.push({\"time\": Math.floor(performance.now() - start), \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    let timeout = setInterval(()=> fn(...args),t)\\n    \\n\\n    let cancelFn = () => clearInterval(timeout)\\n\\n    return cancelFn\\n    \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *\\t\\tconst val = fn(...argsArr)\\n *      result.push({\"time\": Math.floor(performance.now() - start), \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3715213,
                "title": "explained-js-ts-solution",
                "content": "# Intuition\\nThe problem requires us to create a function repeatFunction that takes a function fn, an array of arguments args, and an interval time t, and returns a cancel function cancelFn. The fn function should be called immediately with the given args, and then repeatedly called every t milliseconds until the cancelFn is called.\\n\\n\\n\\n# Approach\\nApproach:\\nTo solve this problem, we can use the setInterval function in JavaScript, which repeatedly calls a given function at a specified time interval. We can use setInterval to call the fn function with the provided args every t milliseconds.\\n\\nHere\\'s the step-by-step approach:\\n\\n1) Define a variable interval and assign it the result of calling setInterval with the following arguments:\\n\\nA function that calls fn with the provided args.\\nThe interval time t in milliseconds.\\n\\n2) Define a function cancelFn that clears the interval using clearInterval with the interval variable as the argument.\\n\\n3) Return the cancelFn function.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nfunction cancellable(fn, args, t) {\\n  // Call the `fn` function immediately with the provided `args`\\n  fn(...args);\\n\\n  // Set up an interval to call `fn` every `t` milliseconds\\n  let intervalId = setInterval(() => fn(...args), t);\\n\\n  // Define a cancel function that clears the interval\\n  function cancelFn() {\\n    clearInterval(intervalId);\\n  }\\n\\n  // Return the cancel function\\n  return cancelFn;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable(fn, args, t) {\\n  // Call the `fn` function immediately with the provided `args`\\n  fn(...args);\\n\\n  // Set up an interval to call `fn` every `t` milliseconds\\n  let intervalId = setInterval(() => fn(...args), t);\\n\\n  // Define a cancel function that clears the interval\\n  function cancelFn() {\\n    clearInterval(intervalId);\\n  }\\n\\n  // Return the cancel function\\n  return cancelFn;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3700248,
                "title": "4-liner-setinterval",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    let interval = setInterval(()=>fn(...args),t);\\n    let cancelFn =()=> clearInterval(interval);\\n    return cancelFn;\\n};\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    let interval = setInterval(()=>fn(...args),t);\\n    let cancelFn =()=> clearInterval(interval);\\n    return cancelFn;\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3698671,
                "title": "3-lines-js-ts-easy-solution",
                "content": "\\n# Code\\n``` Javascript []\\nfunction cancellable(fn, args, t){  \\n    fn(...args)  \\n    const interval= setInterval(()=> fn(...args),t)\\n    return () => clearInterval(interval)\\n};\\n```\\n``` Typescript []\\nfunction cancellable(fn: Function, args: any[], t: number): Function {  \\n    fn(...args)  \\n    const interval :ReturnType<typeof setInterval> = setInterval(():void=> fn(...args),t)\\n    return ():void=> clearInterval(interval)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "``` Javascript []\\nfunction cancellable(fn, args, t){  \\n    fn(...args)  \\n    const interval= setInterval(()=> fn(...args),t)\\n    return () => clearInterval(interval)\\n};\\n```\n``` Typescript []\\nfunction cancellable(fn: Function, args: any[], t: number): Function {  \\n    fn(...args)  \\n    const interval :ReturnType<typeof setInterval> = setInterval(():void=> fn(...args),t)\\n    return ():void=> clearInterval(interval)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3688465,
                "title": "with-set-interval-90-accuracy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\nconst intervalId = setInterval(() => {\\n    fn.apply(null, args);\\n  }, t);\\n\\n  const cancelFn = () => {\\n    clearInterval(intervalId);\\n  };\\n\\n  fn.apply(null, args);\\n\\n  return cancelFn;\\n};\\n\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *\\t\\tconst val = fn(...argsArr)\\n *      result.push({\"time\": Math.floor(performance.now() - start), \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\nconst intervalId = setInterval(() => {\\n    fn.apply(null, args);\\n  }, t);\\n\\n  const cancelFn = () => {\\n    clearInterval(intervalId);\\n  };\\n\\n  fn.apply(null, args);\\n\\n  return cancelFn;\\n};\\n\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *\\t\\tconst val = fn(...argsArr)\\n *      result.push({\"time\": Math.floor(performance.now() - start), \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3683578,
                "title": "using-setinterval-in-constant-space",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\na function called cancellable that takes in a function fn, an array of arguments args, and a time interval t. The function immediately calls fn with the provided arguments args, and then sets up an interval using setInterval to repeatedly call fn with the same arguments every t milliseconds.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwe can say that the time complexity of the cancellable function is O(cancelT / t), where cancelT is the total time duration and t is the time interval between function calls.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nsince it doesn\\'t create any additional data structures that grow with the input size. It only creates a local variable intervalID to store the ID of the interval. Therefore, the space complexity of the cancellable function is O(1).\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args); // Call the function immediately\\n    const intervalID = setInterval(()=>fn(...args),t)\\n   \\n    function cancelFn() {\\n    clearInterval(intervalID);\\n    }\\n    \\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *\\t\\tconst val = fn(...argsArr)\\n *      result.push({\"time\": Math.floor(performance.now() - start), \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args); // Call the function immediately\\n    const intervalID = setInterval(()=>fn(...args),t)\\n   \\n    function cancelFn() {\\n    clearInterval(intervalID);\\n    }\\n    \\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *\\t\\tconst val = fn(...argsArr)\\n *      result.push({\"time\": Math.floor(performance.now() - start), \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3682911,
                "title": "cleartimeout-solution-don-t-do-this",
                "content": "# Intuition\\nFun Fact: clearInterval and clearTimeout are the same function and can be used interchangably. They are named differently for code readablitiy purposes\\n\\n```typescrip \\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    fn(...args)\\n    const intervalId = setInterval(() => fn(...args), t)\\n    return () => clearTimeout(intervalId)\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *\\t\\tconst val = fn(...argsArr)\\n *      result.push({\"time\": Math.floor(performance.now() - start), \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```typescrip \\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    fn(...args)\\n    const intervalId = setInterval(() => fn(...args), t)\\n    return () => clearTimeout(intervalId)\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *\\t\\tconst val = fn(...argsArr)\\n *      result.push({\"time\": Math.floor(performance.now() - start), \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3677249,
                "title": "js-setinterval-clearinterval",
                "content": "```js\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    \\n    let timerId = setInterval(fn, t, ...args);\\n\\n    let cancelFn = function() { \\n        clearInterval(timerId);\\n    };\\n\\n    return cancelFn;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    \\n    let timerId = setInterval(fn, t, ...args);\\n\\n    let cancelFn = function() { \\n        clearInterval(timerId);\\n    };\\n\\n    return cancelFn;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3668408,
                "title": "typescript-solution",
                "content": "# Code\\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    fn(...args);\\n    const timer = setInterval(() => {\\n        fn(...args);\\n    }, t);\\n\\n    return () => clearTimeout(timer);\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    fn(...args);\\n    const timer = setInterval(() => {\\n        fn(...args);\\n    }, t);\\n\\n    return () => clearTimeout(timer);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3668383,
                "title": "a-piece-of-cake",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let intervalId;\\n    Promise.resolve(fn(...args)).then(() => {\\n        intervalId = setInterval(fn, t, ...args)\\n    });\\n\\n    return () => clearTimeout(intervalId);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *\\t\\tconst val = fn(...argsArr)\\n *      result.push({\"time\": Math.floor(performance.now() - start), \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let intervalId;\\n    Promise.resolve(fn(...args)).then(() => {\\n        intervalId = setInterval(fn, t, ...args)\\n    });\\n\\n    return () => clearTimeout(intervalId);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *\\t\\tconst val = fn(...argsArr)\\n *      result.push({\"time\": Math.floor(performance.now() - start), \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3641288,
                "title": "javascript-simple-setinterval-clearinterval",
                "content": "# Code\\n```\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    const intervalID = setInterval(fn, t, ...args);\\n    return () => clearInterval(intervalID);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    const intervalID = setInterval(fn, t, ...args);\\n    return () => clearInterval(intervalID);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3640666,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(lon)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(logn)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    let timer = setInterval(() => fn(...args), t);\\n\\n    let cancelFn = () => clearInterval(timer);\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *\\t\\tconst val = fn(...argsArr)\\n *      result.push({\"time\": Math.floor(performance.now() - start), \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    let timer = setInterval(() => fn(...args), t);\\n\\n    let cancelFn = () => clearInterval(timer);\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *\\t\\tconst val = fn(...argsArr)\\n *      result.push({\"time\": Math.floor(performance.now() - start), \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3639847,
                "title": "simple-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n\\n    let ans = setInterval(() => fn(...args),t);\\n\\n    return () => clearInterval(ans);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n\\n    let ans = setInterval(() => fn(...args),t);\\n\\n    return () => clearInterval(ans);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3624736,
                "title": "3-lines-js-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  fn(...args);\\n  let intervalId = setInterval(() => fn(...args), t);\\n  return () => clearInterval(intervalId);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *\\t\\tconst val = fn(...argsArr)\\n *      result.push({\"time\": Math.floor(performance.now() - start), \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  fn(...args);\\n  let intervalId = setInterval(() => fn(...args), t);\\n  return () => clearInterval(intervalId);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *\\t\\tconst val = fn(...argsArr)\\n *      result.push({\"time\": Math.floor(performance.now() - start), \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3621775,
                "title": "javascript-3-lines",
                "content": "```\\nconst cancellable = (fn, args, t) => {\\n  fn(...args);\\n  let timer = setInterval(() => fn(...args), t);\\n  return () => clearInterval(timer);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst cancellable = (fn, args, t) => {\\n  fn(...args);\\n  let timer = setInterval(() => fn(...args), t);\\n  return () => clearInterval(timer);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3621005,
                "title": "easy-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n        \\n    fn(...args);\\n    \\n    let id = setInterval(() => {\\n        fn(...args);\\n    },t);\\n\\n    return () => clearInterval(id);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *\\t\\tconst val = fn(...argsArr)\\n *      result.push({\"time\": Math.floor(performance.now() - start), \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n        \\n    fn(...args);\\n    \\n    let id = setInterval(() => {\\n        fn(...args);\\n    },t);\\n\\n    return () => clearInterval(id);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *\\t\\tconst val = fn(...argsArr)\\n *      result.push({\"time\": Math.floor(performance.now() - start), \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3620963,
                "title": "use-setinterval-and-bind-method",
                "content": "# Intuition\\nA simple solution with the built-in setInterval function and the bind method\\n\\n# Code\\n\\n**JavaScript**\\n```js\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nconst cancellable = function(fn, args, t) {\\n    fn(...args)\\n    const itervalId = setInterval(() => fn(...args), t)\\n\\n    return clearInterval.bind(null, itervalId)\\n}\\n```\\n\\n**TypeScript**\\n```ts\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    fn(...args)\\n    const itervalId = setInterval(() => fn(...args), t)\\n\\n    return clearInterval.bind(null, itervalId)\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```js\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nconst cancellable = function(fn, args, t) {\\n    fn(...args)\\n    const itervalId = setInterval(() => fn(...args), t)\\n\\n    return clearInterval.bind(null, itervalId)\\n}\\n```\n```ts\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    fn(...args)\\n    const itervalId = setInterval(() => fn(...args), t)\\n\\n    return clearInterval.bind(null, itervalId)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3620024,
                "title": "is-it-good-solution-in-typescript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCreate thread and call function periodically till canceled function is called.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI want to create a thread-like object and found the `setInterval` function, and the `clearInterval` function stops the periodic call.\\n\\nAt first, I just called setInterval and return the function which calls the `clearInterval`.\\nHowever, the `setInterval` doesn\\'t call function immediately. I insert direct function call `fn(...args);` at the top.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nNone\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAs `setInterval` uses  \\n# Code\\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    fn(...args);\\n    let func = setInterval(\\n        fn,\\n        t,\\n        ...args,\\n    )\\n    return function() {\\n        clearInterval(func);\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *\\t\\tconst val = fn(...argsArr)\\n *      result.push({\"time\": Math.floor(performance.now() - start), \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    fn(...args);\\n    let func = setInterval(\\n        fn,\\n        t,\\n        ...args,\\n    )\\n    return function() {\\n        clearInterval(func);\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *\\t\\tconst val = fn(...argsArr)\\n *      result.push({\"time\": Math.floor(performance.now() - start), \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3619925,
                "title": "beat-95-with-short-code",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn.apply(this, args);\\n    const interval = setInterval(() => fn.apply(this, args), t);\\n    return () => clearInterval(interval);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *\\t\\tconst val = fn(...argsArr)\\n *      result.push({\"time\": Math.floor(performance.now() - start), \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn.apply(this, args);\\n    const interval = setInterval(() => fn.apply(this, args), t);\\n    return () => clearInterval(interval);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *\\t\\tconst val = fn(...argsArr)\\n *      result.push({\"time\": Math.floor(performance.now() - start), \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3618981,
                "title": "68ms-short-typescript-click",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    fn(...args);\\n    let k = setInterval(() => {\\n        fn(...args);\\n    }, t)\\n    return () => clearInterval(k)\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *\\t\\tconst val = fn(...argsArr)\\n *      result.push({\"time\": Math.floor(performance.now() - start), \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    fn(...args);\\n    let k = setInterval(() => {\\n        fn(...args);\\n    }, t)\\n    return () => clearInterval(k)\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *\\t\\tconst val = fn(...argsArr)\\n *      result.push({\"time\": Math.floor(performance.now() - start), \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3618762,
                "title": "easy-javascript-solution-with-explanation",
                "content": "# Intuition\\n- call fn with args\\n- - (necessary to ensure fn function is called immediately before setting up the interval, guaranteeing first call to fn occurs immediately, and subsequent calls occur at the specified interval)\\n- create interval to call fn with args every t ms\\n- create cancelFn() function to clear interval\\n- return cancelFn();\\n\\n# Approach\\nFunctional approach\\n\\n# Complexity\\n- Time complexity:\\nO(1) / constant\\n\\n- Space complexity:\\nO(n) / linear\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    \\n    let intervalId = setInterval(() => {\\n        fn(...args);\\n    }, t)\\n\\n    function cancelFn() {\\n            clearInterval(intervalId);\\n    }\\n\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    \\n    let intervalId = setInterval(() => {\\n        fn(...args);\\n    }, t)\\n\\n    function cancelFn() {\\n            clearInterval(intervalId);\\n    }\\n\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3616861,
                "title": "setinterval-or-settimeout",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\n /* with setInterval */\\nvar cancellable = function(fn, args, t) {\\n    setTimeout(fn, 0, ...args);\\n    let timeid = setInterval(fn, t, ...args);\\n    return () => clearInterval(timeid);\\n};\\n\\n/* with setTimeout only */\\nvar cancellable = function(fn, args, t) {\\n    let timeid;\\n    let repeat = () => {\\n        timeid = setTimeout(repeat, t);\\n        fn(...args);\\n    };\\n    setTimeout(repeat, 0);\\n    return () => clearInterval(timeid);\\n};\\n\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\n /* with setInterval */\\nvar cancellable = function(fn, args, t) {\\n    setTimeout(fn, 0, ...args);\\n    let timeid = setInterval(fn, t, ...args);\\n    return () => clearInterval(timeid);\\n};\\n\\n/* with setTimeout only */\\nvar cancellable = function(fn, args, t) {\\n    let timeid;\\n    let repeat = () => {\\n        timeid = setTimeout(repeat, t);\\n        fn(...args);\\n    };\\n    setTimeout(repeat, 0);\\n    return () => clearInterval(timeid);\\n};\\n\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3616205,
                "title": "easy-javascript-solution",
                "content": "\\n\\n# Code\\n```\\n\\nvar cancellable = function(fn, args, t) {\\n\\n    fn(...args);\\n    let intrvl = setInterval(()=>{ fn(...args); }, t);\\n    return ()=>{ clearInterval(intrvl); }\\n\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar cancellable = function(fn, args, t) {\\n\\n    fn(...args);\\n    let intrvl = setInterval(()=>{ fn(...args); }, t);\\n    return ()=>{ clearInterval(intrvl); }\\n\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3614065,
                "title": "js-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    \\n    fn(...args);\\n    \\n    let id = setInterval(() => {\\n        fn(...args);\\n    },t);\\n\\n    let cancelFn = () => clearInterval(id);\\n\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    \\n    fn(...args);\\n    \\n    let id = setInterval(() => {\\n        fn(...args);\\n    },t);\\n\\n    let cancelFn = () => clearInterval(id);\\n\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3613656,
                "title": "simple-setinterval-solution",
                "content": "# Approach\\nSchedule the first execution with `setTimeout()` to avoid scheduling delay for `setInterval()` in case `fn` is a long-running function.\\n\\n# Code\\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    setTimeout(() => fn(...args), 0)\\n    const intervalId = setInterval(() => fn(...args), t)\\n    return () => clearInterval(intervalId)\\n}\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    setTimeout(() => fn(...args), 0)\\n    const intervalId = setInterval(() => fn(...args), t)\\n    return () => clearInterval(intervalId)\\n}\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3612728,
                "title": "javascript-easy-3-line-solution-beats-100",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    const interval = setInterval(() => fn(...args), t);\\n    return () => clearInterval(interval);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    const interval = setInterval(() => fn(...args), t);\\n    return () => clearInterval(interval);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3612212,
                "title": "4-line-easy-to-understand-w-line-by-line-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1- fn(...args)\\nThis line immediately invokes the fn function by passing the args as arguments. It calls the function once immediately when the cancellable function is called.\\n\\n2- const intervalId = setInterval(() => { fn(...args); }, t);\\nThis line sets up a recurring interval using the setInterval function. It takes an anonymous function as its first argument, which invokes the fn function with the args as arguments. The interval duration is specified by t, which represents the time in milliseconds.\\n\\n3-const cancelFn = function() { clearInterval(intervalId); };\\nThis line declares a variable named cancelFn and assigns it an anonymous function. This function is responsible for canceling the interval. It calls clearInterval and passes the intervalId as an argument to stop the recurring execution of the anonymous function defined in the setInterval call.\\n\\n4- return cancelFn;\\nThis line returns the cancelFn function from the cancellable function. By returning this function, the caller of cancellable can store it and later invoke it to cancel the interval execution.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  fn(...args); // Call fn immediately\\n\\n  const intervalId = setInterval(() => {\\n    fn(...args);\\n  }, t);\\n\\n  const cancelFn = function() {\\n    clearInterval(intervalId);\\n  };\\n\\n  return cancelFn;\\n};\\n\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  fn(...args); // Call fn immediately\\n\\n  const intervalId = setInterval(() => {\\n    fn(...args);\\n  }, t);\\n\\n  const cancelFn = function() {\\n    clearInterval(intervalId);\\n  };\\n\\n  return cancelFn;\\n};\\n\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3611718,
                "title": "javascript-4-line-easy-solution",
                "content": "# Code\\n```\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    const interval = setInterval(() => fn(...args), t);\\n    const cancelFn = () => clearInterval(interval);\\n    return cancelFn;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    const interval = setInterval(() => fn(...args), t);\\n    const cancelFn = () => clearInterval(interval);\\n    return cancelFn;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3610420,
                "title": "ok",
                "content": "```\\nvar cancellable = function(f, args, t)\\n{\\n    f(...args);\\n    let interval = setInterval(()=>f(...args), t);\\n    return ()=>clearInterval(interval);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar cancellable = function(f, args, t)\\n{\\n    f(...args);\\n    let interval = setInterval(()=>f(...args), t);\\n    return ()=>clearInterval(interval);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3609217,
                "title": "js-3-lines-setinterval-clearinterval",
                "content": "# Intuition\\nsetInterval, return function that executes clearInterval. \\nThere is kind of corner case, need to execute function first on time 0\\n\\n# Code\\n```\\nconst cancellable = (fn, args, t) => {\\n    fn(...args);\\n    const handle = setInterval(() => fn(...args), t);    \\n    return () =>  clearInterval(handle);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst cancellable = (fn, args, t) => {\\n    fn(...args);\\n    const handle = setInterval(() => fn(...args), t);    \\n    return () =>  clearInterval(handle);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3609164,
                "title": "setinterval-clearinterval-arrow-syntax",
                "content": "# Code\\n```\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    let intervalID = setInterval(() => {\\n        fn(...args);\\n    }, t);\\n    return () => clearInterval(intervalID);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    let intervalID = setInterval(() => {\\n        fn(...args);\\n    }, t);\\n    return () => clearInterval(intervalID);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3609109,
                "title": "simple-easiest-js-solution-setinterval-clearinterval",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  fn(...args);\\n\\n  let intervalId = setInterval(() => {\\n      fn(...args);\\n  }, t)\\n\\n  return function () {\\n    clearInterval(intervalId)\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  fn(...args);\\n\\n  let intervalId = setInterval(() => {\\n      fn(...args);\\n  }, t)\\n\\n  return function () {\\n    clearInterval(intervalId)\\n  }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3608463,
                "title": "settimeout-cleartimeout-javascript",
                "content": "# Intuition\\nuse the handle to keep track whether it is cancelled or not.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let handle;\\n    const intervalFn = function() {\\n        fn.apply(null, args);\\n        if (handle) {\\n            handle = setTimeout(intervalFn, t);\\n        }\\n    }\\n    fn.apply(null, args);\\n    handle = setTimeout(intervalFn, t);\\n    return function() {\\n        clearTimeout(handle);\\n        handle = null;\\n    };\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let handle;\\n    const intervalFn = function() {\\n        fn.apply(null, args);\\n        if (handle) {\\n            handle = setTimeout(intervalFn, t);\\n        }\\n    }\\n    fn.apply(null, args);\\n    handle = setTimeout(intervalFn, t);\\n    return function() {\\n        clearTimeout(handle);\\n        handle = null;\\n    };\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3608240,
                "title": "interval-cancellation",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    const handler = setInterval(() => fn(...args), t);\\n\\n    return () => clearInterval(handler);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    fn(...args);\\n    const handler = setInterval(() => fn(...args), t);\\n\\n    return () => clearInterval(handler);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 2\\n *  const args = [4], t = 20, cancelT = 110\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [\\n *                         //      {\"time\":0,\"returned\":8},\\n *                         //      {\"time\":20,\"returned\":8},\\n *                         //      {\"time\":40,\"returned\":8},           \\n *                         //      {\"time\":60,\"returned\":8},\\n *                         //      {\"time\":80,\"returned\":8},\\n *                         //      {\"time\":100,\"returned\":8}\\n *                         //  ]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3608232,
                "title": "comments-are-misleading-here-are-the-correct-comments-that-produce-the-expected-output",
                "content": "# Intuition\\nThe comments are misleading. In order to test the solution properly you need the following comments:\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n\\n    fn(...args);\\n\\n    let intervalId = setInterval(() => {\\n        fn(...args);\\n    }, t);\\n\\n    return () => {\\n        clearInterval(intervalId);\\n    }\\n};\\n\\n// Comments for testing to get the expected output:\\nconst result = []\\n\\nconst fn = (x) => x * 2\\nconst args = [4], t = 20, cancelT = 110\\n\\nconst startTime = new Date().getTime()\\n\\nconst log = (...argsArr) => {    \\n    result.push(\\'{\"time\": \\' +\\n          (new Date().getTime() - startTime) + \\n          \\', \"returned\": \\' +\\n          fn(...argsArr) + \\'}\\');\\n}\\n     \\nconst cancel = cancellable(log, args, t);\\n         \\nsetTimeout(() => {\\n   cancel()\\n   console.log(result) // [\\n                       //      {\"time\":0,\"returned\":8},\\n                       //      {\"time\":20,\"returned\":8},\\n                       //      {\"time\":40,\"returned\":8},           \\n                       //      {\"time\":60,\"returned\":8},\\n                       //      {\"time\":80,\"returned\":8},\\n                       //      {\"time\":100,\"returned\":8}\\n                       //  ]\\n}, cancelT)\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n\\n    fn(...args);\\n\\n    let intervalId = setInterval(() => {\\n        fn(...args);\\n    }, t);\\n\\n    return () => {\\n        clearInterval(intervalId);\\n    }\\n};\\n\\n// Comments for testing to get the expected output:\\nconst result = []\\n\\nconst fn = (x) => x * 2\\nconst args = [4], t = 20, cancelT = 110\\n\\nconst startTime = new Date().getTime()\\n\\nconst log = (...argsArr) => {    \\n    result.push(\\'{\"time\": \\' +\\n          (new Date().getTime() - startTime) + \\n          \\', \"returned\": \\' +\\n          fn(...argsArr) + \\'}\\');\\n}\\n     \\nconst cancel = cancellable(log, args, t);\\n         \\nsetTimeout(() => {\\n   cancel()\\n   console.log(result) // [\\n                       //      {\"time\":0,\"returned\":8},\\n                       //      {\"time\":20,\"returned\":8},\\n                       //      {\"time\":40,\"returned\":8},           \\n                       //      {\"time\":60,\"returned\":8},\\n                       //      {\"time\":80,\"returned\":8},\\n                       //      {\"time\":100,\"returned\":8}\\n                       //  ]\\n}, cancelT)\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1921129,
                "content": [
                    {
                        "username": "powerup7",
                        "content": "test case 1 is actually incorrect.\n\nMy failed results\n```\n[{\"time\":0,\"returned\":8},{\"time\":21,\"returned\":8},{\"time\":41,\"returned\":8},{\"time\":64,\"returned\":8},{\"time\":86,\"returned\":8},{\"time\":106,\"returned\":8}]\n```\n\nexpected from test case - missing one value before being canceled at 110ms\n```\n[{\"time\":0,\"returned\":8},{\"time\":29,\"returned\":8},{\"time\":49,\"returned\":8},{\"time\":69,\"returned\":8},{\"time\":90,\"returned\":8}]\n```\n\nwritten expected\n```\n[\n   {\"time\": 0, \"returned\": 8},\n   {\"time\": 20, \"returned\": 8},\n   {\"time\": 40, \"returned\": 8},\n   {\"time\": 60, \"returned\": 8},\n   {\"time\": 80, \"returned\": 8},\n   {\"time\": 100, \"returned\": 8}\n]```"
                    },
                    {
                        "username": "devsargam",
                        "content": "Yea, same here. I am also facing same issue"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@todor91](/todor91) \\nIt makes no sense.\\nMy tests run closer to the expected written test outcome than what they say is the expected outcome upon testing. \\n\\nThey are also missing an entire interval in their expected outcome.\\n\\nSomebody made a mistake for test case 1. That\\'s the only test case that has this weird bug."
                    },
                    {
                        "username": "todor91",
                        "content": "Seems like racing issue. You can try again, but indeed the tester has timing issues. Either the testcases should use bigger time intervals, or the timeouts should be simulated (mocked)."
                    },
                    {
                        "username": "danek1313",
                        "content": "If cancelT never gets passed into `cancellable`, how can you complete this?"
                    },
                    {
                        "username": "antonbrypto",
                        "content": "Read about closures, setInterval and clearInterval, sir."
                    },
                    {
                        "username": "elborracho420",
                        "content": "I had a couple of issues with the description. \\n\\nFirst, the example cases state an input of cancelT is being passed, but it is not. Approach this problem as if that is not there--very confusing.\\n\\nOnce I realized this, the next hurdle I had to get over was that I needed to call fn with args immediately at the start of the function before calling it again in the interval.\\n\\nThis was the logic I had to follow:\\n\\n- call fn with args\\n- - (necessary to ensure fn function is called immediately before setting up the interval, guaranteeing first call to fn occurs immediately, and subsequent calls occur at the specified interval)\\n- create interval to call fn with args every t ms\\n- create cancelFn() function to clear interval\\n- return cancelFn();"
                    },
                    {
                        "username": "ScottMCook",
                        "content": "Yeah the explanation for this one is poor."
                    },
                    {
                        "username": "_shl",
                        "content": "Tip: Don\\'t forget that `setInterval()` starts its countdown only after the first interval. `fn()` should be called with `args` immediately - Task Conditions."
                    },
                    {
                        "username": "antonbrypto",
                        "content": "bro, I always knew capys are the smartest"
                    },
                    {
                        "username": "cptn3m0",
                        "content": "Had to look at editorial just to understand what the question is asking us to do. \\nThis can be re-written in other words, it is complicating a very easy concept."
                    },
                    {
                        "username": "todor91",
                        "content": "The comments are misleading. In order to get the expected output you need to use the following code:\\n```\\nconst result = []\\n\\nconst fn = (x) => x * 2\\nconst args = [4], t = 20, cancelT = 110\\n\\nconst startTime = new Date().getTime()\\n\\nconst log = (...argsArr) => {    \\n    result.push(\\'{\"time\": \\' +\\n          (new Date().getTime() - startTime) + \\n          \\', \"returned\": \\' +\\n          fn(...argsArr) + \\'}\\');\\n}\\n     \\nconst cancel = cancellable(log, args, t);\\n         \\nsetTimeout(() => {\\n   cancel()\\n   console.log(result) // [\\n                       //      {\"time\":0,\"returned\":8},\\n                       //      {\"time\":20,\"returned\":8},\\n                       //      {\"time\":40,\"returned\":8},           \\n                       //      {\"time\":60,\"returned\":8},\\n                       //      {\"time\":80,\"returned\":8},\\n                       //      {\"time\":100,\"returned\":8}\\n                       //  ]\\n}, cancelT)\\n```"
                    }
                ]
            },
            {
                "id": 1941487,
                "content": [
                    {
                        "username": "powerup7",
                        "content": "test case 1 is actually incorrect.\n\nMy failed results\n```\n[{\"time\":0,\"returned\":8},{\"time\":21,\"returned\":8},{\"time\":41,\"returned\":8},{\"time\":64,\"returned\":8},{\"time\":86,\"returned\":8},{\"time\":106,\"returned\":8}]\n```\n\nexpected from test case - missing one value before being canceled at 110ms\n```\n[{\"time\":0,\"returned\":8},{\"time\":29,\"returned\":8},{\"time\":49,\"returned\":8},{\"time\":69,\"returned\":8},{\"time\":90,\"returned\":8}]\n```\n\nwritten expected\n```\n[\n   {\"time\": 0, \"returned\": 8},\n   {\"time\": 20, \"returned\": 8},\n   {\"time\": 40, \"returned\": 8},\n   {\"time\": 60, \"returned\": 8},\n   {\"time\": 80, \"returned\": 8},\n   {\"time\": 100, \"returned\": 8}\n]```"
                    },
                    {
                        "username": "devsargam",
                        "content": "Yea, same here. I am also facing same issue"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@todor91](/todor91) \\nIt makes no sense.\\nMy tests run closer to the expected written test outcome than what they say is the expected outcome upon testing. \\n\\nThey are also missing an entire interval in their expected outcome.\\n\\nSomebody made a mistake for test case 1. That\\'s the only test case that has this weird bug."
                    },
                    {
                        "username": "todor91",
                        "content": "Seems like racing issue. You can try again, but indeed the tester has timing issues. Either the testcases should use bigger time intervals, or the timeouts should be simulated (mocked)."
                    },
                    {
                        "username": "danek1313",
                        "content": "If cancelT never gets passed into `cancellable`, how can you complete this?"
                    },
                    {
                        "username": "antonbrypto",
                        "content": "Read about closures, setInterval and clearInterval, sir."
                    },
                    {
                        "username": "elborracho420",
                        "content": "I had a couple of issues with the description. \\n\\nFirst, the example cases state an input of cancelT is being passed, but it is not. Approach this problem as if that is not there--very confusing.\\n\\nOnce I realized this, the next hurdle I had to get over was that I needed to call fn with args immediately at the start of the function before calling it again in the interval.\\n\\nThis was the logic I had to follow:\\n\\n- call fn with args\\n- - (necessary to ensure fn function is called immediately before setting up the interval, guaranteeing first call to fn occurs immediately, and subsequent calls occur at the specified interval)\\n- create interval to call fn with args every t ms\\n- create cancelFn() function to clear interval\\n- return cancelFn();"
                    },
                    {
                        "username": "ScottMCook",
                        "content": "Yeah the explanation for this one is poor."
                    },
                    {
                        "username": "_shl",
                        "content": "Tip: Don\\'t forget that `setInterval()` starts its countdown only after the first interval. `fn()` should be called with `args` immediately - Task Conditions."
                    },
                    {
                        "username": "antonbrypto",
                        "content": "bro, I always knew capys are the smartest"
                    },
                    {
                        "username": "cptn3m0",
                        "content": "Had to look at editorial just to understand what the question is asking us to do. \\nThis can be re-written in other words, it is complicating a very easy concept."
                    },
                    {
                        "username": "todor91",
                        "content": "The comments are misleading. In order to get the expected output you need to use the following code:\\n```\\nconst result = []\\n\\nconst fn = (x) => x * 2\\nconst args = [4], t = 20, cancelT = 110\\n\\nconst startTime = new Date().getTime()\\n\\nconst log = (...argsArr) => {    \\n    result.push(\\'{\"time\": \\' +\\n          (new Date().getTime() - startTime) + \\n          \\', \"returned\": \\' +\\n          fn(...argsArr) + \\'}\\');\\n}\\n     \\nconst cancel = cancellable(log, args, t);\\n         \\nsetTimeout(() => {\\n   cancel()\\n   console.log(result) // [\\n                       //      {\"time\":0,\"returned\":8},\\n                       //      {\"time\":20,\"returned\":8},\\n                       //      {\"time\":40,\"returned\":8},           \\n                       //      {\"time\":60,\"returned\":8},\\n                       //      {\"time\":80,\"returned\":8},\\n                       //      {\"time\":100,\"returned\":8}\\n                       //  ]\\n}, cancelT)\\n```"
                    }
                ]
            },
            {
                "id": 1922559,
                "content": [
                    {
                        "username": "powerup7",
                        "content": "test case 1 is actually incorrect.\n\nMy failed results\n```\n[{\"time\":0,\"returned\":8},{\"time\":21,\"returned\":8},{\"time\":41,\"returned\":8},{\"time\":64,\"returned\":8},{\"time\":86,\"returned\":8},{\"time\":106,\"returned\":8}]\n```\n\nexpected from test case - missing one value before being canceled at 110ms\n```\n[{\"time\":0,\"returned\":8},{\"time\":29,\"returned\":8},{\"time\":49,\"returned\":8},{\"time\":69,\"returned\":8},{\"time\":90,\"returned\":8}]\n```\n\nwritten expected\n```\n[\n   {\"time\": 0, \"returned\": 8},\n   {\"time\": 20, \"returned\": 8},\n   {\"time\": 40, \"returned\": 8},\n   {\"time\": 60, \"returned\": 8},\n   {\"time\": 80, \"returned\": 8},\n   {\"time\": 100, \"returned\": 8}\n]```"
                    },
                    {
                        "username": "devsargam",
                        "content": "Yea, same here. I am also facing same issue"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@todor91](/todor91) \\nIt makes no sense.\\nMy tests run closer to the expected written test outcome than what they say is the expected outcome upon testing. \\n\\nThey are also missing an entire interval in their expected outcome.\\n\\nSomebody made a mistake for test case 1. That\\'s the only test case that has this weird bug."
                    },
                    {
                        "username": "todor91",
                        "content": "Seems like racing issue. You can try again, but indeed the tester has timing issues. Either the testcases should use bigger time intervals, or the timeouts should be simulated (mocked)."
                    },
                    {
                        "username": "danek1313",
                        "content": "If cancelT never gets passed into `cancellable`, how can you complete this?"
                    },
                    {
                        "username": "antonbrypto",
                        "content": "Read about closures, setInterval and clearInterval, sir."
                    },
                    {
                        "username": "elborracho420",
                        "content": "I had a couple of issues with the description. \\n\\nFirst, the example cases state an input of cancelT is being passed, but it is not. Approach this problem as if that is not there--very confusing.\\n\\nOnce I realized this, the next hurdle I had to get over was that I needed to call fn with args immediately at the start of the function before calling it again in the interval.\\n\\nThis was the logic I had to follow:\\n\\n- call fn with args\\n- - (necessary to ensure fn function is called immediately before setting up the interval, guaranteeing first call to fn occurs immediately, and subsequent calls occur at the specified interval)\\n- create interval to call fn with args every t ms\\n- create cancelFn() function to clear interval\\n- return cancelFn();"
                    },
                    {
                        "username": "ScottMCook",
                        "content": "Yeah the explanation for this one is poor."
                    },
                    {
                        "username": "_shl",
                        "content": "Tip: Don\\'t forget that `setInterval()` starts its countdown only after the first interval. `fn()` should be called with `args` immediately - Task Conditions."
                    },
                    {
                        "username": "antonbrypto",
                        "content": "bro, I always knew capys are the smartest"
                    },
                    {
                        "username": "cptn3m0",
                        "content": "Had to look at editorial just to understand what the question is asking us to do. \\nThis can be re-written in other words, it is complicating a very easy concept."
                    },
                    {
                        "username": "todor91",
                        "content": "The comments are misleading. In order to get the expected output you need to use the following code:\\n```\\nconst result = []\\n\\nconst fn = (x) => x * 2\\nconst args = [4], t = 20, cancelT = 110\\n\\nconst startTime = new Date().getTime()\\n\\nconst log = (...argsArr) => {    \\n    result.push(\\'{\"time\": \\' +\\n          (new Date().getTime() - startTime) + \\n          \\', \"returned\": \\' +\\n          fn(...argsArr) + \\'}\\');\\n}\\n     \\nconst cancel = cancellable(log, args, t);\\n         \\nsetTimeout(() => {\\n   cancel()\\n   console.log(result) // [\\n                       //      {\"time\":0,\"returned\":8},\\n                       //      {\"time\":20,\"returned\":8},\\n                       //      {\"time\":40,\"returned\":8},           \\n                       //      {\"time\":60,\"returned\":8},\\n                       //      {\"time\":80,\"returned\":8},\\n                       //      {\"time\":100,\"returned\":8}\\n                       //  ]\\n}, cancelT)\\n```"
                    }
                ]
            },
            {
                "id": 2057063,
                "content": [
                    {
                        "username": "powerup7",
                        "content": "test case 1 is actually incorrect.\n\nMy failed results\n```\n[{\"time\":0,\"returned\":8},{\"time\":21,\"returned\":8},{\"time\":41,\"returned\":8},{\"time\":64,\"returned\":8},{\"time\":86,\"returned\":8},{\"time\":106,\"returned\":8}]\n```\n\nexpected from test case - missing one value before being canceled at 110ms\n```\n[{\"time\":0,\"returned\":8},{\"time\":29,\"returned\":8},{\"time\":49,\"returned\":8},{\"time\":69,\"returned\":8},{\"time\":90,\"returned\":8}]\n```\n\nwritten expected\n```\n[\n   {\"time\": 0, \"returned\": 8},\n   {\"time\": 20, \"returned\": 8},\n   {\"time\": 40, \"returned\": 8},\n   {\"time\": 60, \"returned\": 8},\n   {\"time\": 80, \"returned\": 8},\n   {\"time\": 100, \"returned\": 8}\n]```"
                    },
                    {
                        "username": "devsargam",
                        "content": "Yea, same here. I am also facing same issue"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@todor91](/todor91) \\nIt makes no sense.\\nMy tests run closer to the expected written test outcome than what they say is the expected outcome upon testing. \\n\\nThey are also missing an entire interval in their expected outcome.\\n\\nSomebody made a mistake for test case 1. That\\'s the only test case that has this weird bug."
                    },
                    {
                        "username": "todor91",
                        "content": "Seems like racing issue. You can try again, but indeed the tester has timing issues. Either the testcases should use bigger time intervals, or the timeouts should be simulated (mocked)."
                    },
                    {
                        "username": "danek1313",
                        "content": "If cancelT never gets passed into `cancellable`, how can you complete this?"
                    },
                    {
                        "username": "antonbrypto",
                        "content": "Read about closures, setInterval and clearInterval, sir."
                    },
                    {
                        "username": "elborracho420",
                        "content": "I had a couple of issues with the description. \\n\\nFirst, the example cases state an input of cancelT is being passed, but it is not. Approach this problem as if that is not there--very confusing.\\n\\nOnce I realized this, the next hurdle I had to get over was that I needed to call fn with args immediately at the start of the function before calling it again in the interval.\\n\\nThis was the logic I had to follow:\\n\\n- call fn with args\\n- - (necessary to ensure fn function is called immediately before setting up the interval, guaranteeing first call to fn occurs immediately, and subsequent calls occur at the specified interval)\\n- create interval to call fn with args every t ms\\n- create cancelFn() function to clear interval\\n- return cancelFn();"
                    },
                    {
                        "username": "ScottMCook",
                        "content": "Yeah the explanation for this one is poor."
                    },
                    {
                        "username": "_shl",
                        "content": "Tip: Don\\'t forget that `setInterval()` starts its countdown only after the first interval. `fn()` should be called with `args` immediately - Task Conditions."
                    },
                    {
                        "username": "antonbrypto",
                        "content": "bro, I always knew capys are the smartest"
                    },
                    {
                        "username": "cptn3m0",
                        "content": "Had to look at editorial just to understand what the question is asking us to do. \\nThis can be re-written in other words, it is complicating a very easy concept."
                    },
                    {
                        "username": "todor91",
                        "content": "The comments are misleading. In order to get the expected output you need to use the following code:\\n```\\nconst result = []\\n\\nconst fn = (x) => x * 2\\nconst args = [4], t = 20, cancelT = 110\\n\\nconst startTime = new Date().getTime()\\n\\nconst log = (...argsArr) => {    \\n    result.push(\\'{\"time\": \\' +\\n          (new Date().getTime() - startTime) + \\n          \\', \"returned\": \\' +\\n          fn(...argsArr) + \\'}\\');\\n}\\n     \\nconst cancel = cancellable(log, args, t);\\n         \\nsetTimeout(() => {\\n   cancel()\\n   console.log(result) // [\\n                       //      {\"time\":0,\"returned\":8},\\n                       //      {\"time\":20,\"returned\":8},\\n                       //      {\"time\":40,\"returned\":8},           \\n                       //      {\"time\":60,\"returned\":8},\\n                       //      {\"time\":80,\"returned\":8},\\n                       //      {\"time\":100,\"returned\":8}\\n                       //  ]\\n}, cancelT)\\n```"
                    }
                ]
            },
            {
                "id": 2000053,
                "content": [
                    {
                        "username": "powerup7",
                        "content": "test case 1 is actually incorrect.\n\nMy failed results\n```\n[{\"time\":0,\"returned\":8},{\"time\":21,\"returned\":8},{\"time\":41,\"returned\":8},{\"time\":64,\"returned\":8},{\"time\":86,\"returned\":8},{\"time\":106,\"returned\":8}]\n```\n\nexpected from test case - missing one value before being canceled at 110ms\n```\n[{\"time\":0,\"returned\":8},{\"time\":29,\"returned\":8},{\"time\":49,\"returned\":8},{\"time\":69,\"returned\":8},{\"time\":90,\"returned\":8}]\n```\n\nwritten expected\n```\n[\n   {\"time\": 0, \"returned\": 8},\n   {\"time\": 20, \"returned\": 8},\n   {\"time\": 40, \"returned\": 8},\n   {\"time\": 60, \"returned\": 8},\n   {\"time\": 80, \"returned\": 8},\n   {\"time\": 100, \"returned\": 8}\n]```"
                    },
                    {
                        "username": "devsargam",
                        "content": "Yea, same here. I am also facing same issue"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@todor91](/todor91) \\nIt makes no sense.\\nMy tests run closer to the expected written test outcome than what they say is the expected outcome upon testing. \\n\\nThey are also missing an entire interval in their expected outcome.\\n\\nSomebody made a mistake for test case 1. That\\'s the only test case that has this weird bug."
                    },
                    {
                        "username": "todor91",
                        "content": "Seems like racing issue. You can try again, but indeed the tester has timing issues. Either the testcases should use bigger time intervals, or the timeouts should be simulated (mocked)."
                    },
                    {
                        "username": "danek1313",
                        "content": "If cancelT never gets passed into `cancellable`, how can you complete this?"
                    },
                    {
                        "username": "antonbrypto",
                        "content": "Read about closures, setInterval and clearInterval, sir."
                    },
                    {
                        "username": "elborracho420",
                        "content": "I had a couple of issues with the description. \\n\\nFirst, the example cases state an input of cancelT is being passed, but it is not. Approach this problem as if that is not there--very confusing.\\n\\nOnce I realized this, the next hurdle I had to get over was that I needed to call fn with args immediately at the start of the function before calling it again in the interval.\\n\\nThis was the logic I had to follow:\\n\\n- call fn with args\\n- - (necessary to ensure fn function is called immediately before setting up the interval, guaranteeing first call to fn occurs immediately, and subsequent calls occur at the specified interval)\\n- create interval to call fn with args every t ms\\n- create cancelFn() function to clear interval\\n- return cancelFn();"
                    },
                    {
                        "username": "ScottMCook",
                        "content": "Yeah the explanation for this one is poor."
                    },
                    {
                        "username": "_shl",
                        "content": "Tip: Don\\'t forget that `setInterval()` starts its countdown only after the first interval. `fn()` should be called with `args` immediately - Task Conditions."
                    },
                    {
                        "username": "antonbrypto",
                        "content": "bro, I always knew capys are the smartest"
                    },
                    {
                        "username": "cptn3m0",
                        "content": "Had to look at editorial just to understand what the question is asking us to do. \\nThis can be re-written in other words, it is complicating a very easy concept."
                    },
                    {
                        "username": "todor91",
                        "content": "The comments are misleading. In order to get the expected output you need to use the following code:\\n```\\nconst result = []\\n\\nconst fn = (x) => x * 2\\nconst args = [4], t = 20, cancelT = 110\\n\\nconst startTime = new Date().getTime()\\n\\nconst log = (...argsArr) => {    \\n    result.push(\\'{\"time\": \\' +\\n          (new Date().getTime() - startTime) + \\n          \\', \"returned\": \\' +\\n          fn(...argsArr) + \\'}\\');\\n}\\n     \\nconst cancel = cancellable(log, args, t);\\n         \\nsetTimeout(() => {\\n   cancel()\\n   console.log(result) // [\\n                       //      {\"time\":0,\"returned\":8},\\n                       //      {\"time\":20,\"returned\":8},\\n                       //      {\"time\":40,\"returned\":8},           \\n                       //      {\"time\":60,\"returned\":8},\\n                       //      {\"time\":80,\"returned\":8},\\n                       //      {\"time\":100,\"returned\":8}\\n                       //  ]\\n}, cancelT)\\n```"
                    }
                ]
            },
            {
                "id": 1919827,
                "content": [
                    {
                        "username": "powerup7",
                        "content": "test case 1 is actually incorrect.\n\nMy failed results\n```\n[{\"time\":0,\"returned\":8},{\"time\":21,\"returned\":8},{\"time\":41,\"returned\":8},{\"time\":64,\"returned\":8},{\"time\":86,\"returned\":8},{\"time\":106,\"returned\":8}]\n```\n\nexpected from test case - missing one value before being canceled at 110ms\n```\n[{\"time\":0,\"returned\":8},{\"time\":29,\"returned\":8},{\"time\":49,\"returned\":8},{\"time\":69,\"returned\":8},{\"time\":90,\"returned\":8}]\n```\n\nwritten expected\n```\n[\n   {\"time\": 0, \"returned\": 8},\n   {\"time\": 20, \"returned\": 8},\n   {\"time\": 40, \"returned\": 8},\n   {\"time\": 60, \"returned\": 8},\n   {\"time\": 80, \"returned\": 8},\n   {\"time\": 100, \"returned\": 8}\n]```"
                    },
                    {
                        "username": "devsargam",
                        "content": "Yea, same here. I am also facing same issue"
                    },
                    {
                        "username": "powerup7",
                        "content": "[@todor91](/todor91) \\nIt makes no sense.\\nMy tests run closer to the expected written test outcome than what they say is the expected outcome upon testing. \\n\\nThey are also missing an entire interval in their expected outcome.\\n\\nSomebody made a mistake for test case 1. That\\'s the only test case that has this weird bug."
                    },
                    {
                        "username": "todor91",
                        "content": "Seems like racing issue. You can try again, but indeed the tester has timing issues. Either the testcases should use bigger time intervals, or the timeouts should be simulated (mocked)."
                    },
                    {
                        "username": "danek1313",
                        "content": "If cancelT never gets passed into `cancellable`, how can you complete this?"
                    },
                    {
                        "username": "antonbrypto",
                        "content": "Read about closures, setInterval and clearInterval, sir."
                    },
                    {
                        "username": "elborracho420",
                        "content": "I had a couple of issues with the description. \\n\\nFirst, the example cases state an input of cancelT is being passed, but it is not. Approach this problem as if that is not there--very confusing.\\n\\nOnce I realized this, the next hurdle I had to get over was that I needed to call fn with args immediately at the start of the function before calling it again in the interval.\\n\\nThis was the logic I had to follow:\\n\\n- call fn with args\\n- - (necessary to ensure fn function is called immediately before setting up the interval, guaranteeing first call to fn occurs immediately, and subsequent calls occur at the specified interval)\\n- create interval to call fn with args every t ms\\n- create cancelFn() function to clear interval\\n- return cancelFn();"
                    },
                    {
                        "username": "ScottMCook",
                        "content": "Yeah the explanation for this one is poor."
                    },
                    {
                        "username": "_shl",
                        "content": "Tip: Don\\'t forget that `setInterval()` starts its countdown only after the first interval. `fn()` should be called with `args` immediately - Task Conditions."
                    },
                    {
                        "username": "antonbrypto",
                        "content": "bro, I always knew capys are the smartest"
                    },
                    {
                        "username": "cptn3m0",
                        "content": "Had to look at editorial just to understand what the question is asking us to do. \\nThis can be re-written in other words, it is complicating a very easy concept."
                    },
                    {
                        "username": "todor91",
                        "content": "The comments are misleading. In order to get the expected output you need to use the following code:\\n```\\nconst result = []\\n\\nconst fn = (x) => x * 2\\nconst args = [4], t = 20, cancelT = 110\\n\\nconst startTime = new Date().getTime()\\n\\nconst log = (...argsArr) => {    \\n    result.push(\\'{\"time\": \\' +\\n          (new Date().getTime() - startTime) + \\n          \\', \"returned\": \\' +\\n          fn(...argsArr) + \\'}\\');\\n}\\n     \\nconst cancel = cancellable(log, args, t);\\n         \\nsetTimeout(() => {\\n   cancel()\\n   console.log(result) // [\\n                       //      {\"time\":0,\"returned\":8},\\n                       //      {\"time\":20,\"returned\":8},\\n                       //      {\"time\":40,\"returned\":8},           \\n                       //      {\"time\":60,\"returned\":8},\\n                       //      {\"time\":80,\"returned\":8},\\n                       //      {\"time\":100,\"returned\":8}\\n                       //  ]\\n}, cancelT)\\n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Collecting Chocolates",
        "question_content": "<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code> of size <code>n</code> representing the cost of collecting different chocolates. The cost of collecting the chocolate at the index <code>i</code>&nbsp;is <code>nums[i]</code>. Each chocolate is of a different type, and initially, the chocolate at the index&nbsp;<code>i</code>&nbsp;is of <code>i<sup>th</sup></code> type.</p>\n\n<p>In one operation, you can do the following with an incurred <strong>cost</strong> of <code>x</code>:</p>\n\n<ul>\n\t<li>Simultaneously change the chocolate of <code>i<sup>th</sup></code> type to <code>((i + 1) mod n)<sup>th</sup></code> type for all chocolates.</li>\n</ul>\n\n<p>Return <em>the minimum cost to collect chocolates of all types, given that you can perform as many operations as you would like.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [20,1,15], x = 5\n<strong>Output:</strong> 13\n<strong>Explanation:</strong> Initially, the chocolate types are [0,1,2]. We will buy the 1<sup>st</sup>&nbsp;type of chocolate at a cost of 1.\nNow, we will perform the operation at a cost of 5, and the types of chocolates will become [1,2,0]. We will buy the 2<sup>nd</sup><sup> </sup>type of chocolate at a cost of 1.\nNow, we will again perform the operation at a cost of 5, and the chocolate types will become [2,0,1]. We will buy the 0<sup>th </sup>type of chocolate at a cost of 1. \nThus, the total cost will become (1 + 5 + 1 + 5 + 1) = 13. We can prove that this is optimal.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3], x = 4\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> We will collect all three types of chocolates at their own price without performing any operations. Therefore, the total cost is 1 + 2 + 3 = 6.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= x &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3623904,
                "title": "garbage-problem-description-is-wrong",
                "content": "EDIT: As of June 11, Leetcode has fixed their erroneous description.\\n\\nFrom the description:\\n\\n> Simultaneously change the chocolate of ith type to (i + 1)th type for all indexes i where 0 <= i < n - 1. When i == n - 1, that chocolate will be changed to type of the chocolate at index 0.\\n\\nFrom the first example:\\n\\n>Input: nums = [20,1,15], x = 5\\nOutput: 13\\nExplanation: Initially, the chocolate types are [0,1,2]. We will buy the 1st type of chocolate at a cost of 1.\\nNow, we will perform the operation at a cost of 5, and the types of chocolates will become [2,0,1].\\n\\nWRONG. The example lists the array rotating forwards, but the problem description describes it going backwards. The problem description says that the (n-1) index becomes the (0) index for example, so after the operation the array should be [1, 2, 0].\\n\\nFor this first example, the answer will be the same regardless of whether we rotate forwards or backwards, so we can\\'t deduce which way we are expected to rotate. The second example is trivial (never rotate), so we still can\\'t deduce which way we are expected to rotate. Unsolvable. So what do we believe? The example, or the description?\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "EDIT: As of June 11, Leetcode has fixed their erroneous description.\\n\\nFrom the description:\\n\\n> Simultaneously change the chocolate of ith type to (i + 1)th type for all indexes i where 0 <= i < n - 1. When i == n - 1, that chocolate will be changed to type of the chocolate at index 0.\\n\\nFrom the first example:\\n\\n>Input: nums = [20,1,15], x = 5\\nOutput: 13\\nExplanation: Initially, the chocolate types are [0,1,2]. We will buy the 1st type of chocolate at a cost of 1.\\nNow, we will perform the operation at a cost of 5, and the types of chocolates will become [2,0,1].\\n\\nWRONG. The example lists the array rotating forwards, but the problem description describes it going backwards. The problem description says that the (n-1) index becomes the (0) index for example, so after the operation the array should be [1, 2, 0].\\n\\nFor this first example, the answer will be the same regardless of whether we rotate forwards or backwards, so we can\\'t deduce which way we are expected to rotate. The second example is trivial (never rotate), so we still can\\'t deduce which way we are expected to rotate. Unsolvable. So what do we believe? The example, or the description?\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3623841,
                "title": "java-c-python-rotate",
                "content": "# **Preword**\\nI feel,\\nthe description and the explanation in example 1,\\nare totaly **opposite**...\\nthough it doesn\\'t change the result..\\n<br>\\n\\n# **Intuition**\\nIf we do rotate operation `k` times,\\nwe can use the `min(A[i-k], .. , A[i - 1], A[i])` as the cost for type `i`.\\n<br>\\n\\n# **Explanation**\\nInitilize result array `res`.\\n`res[k]` means the result for `k` times operation,\\nand we initilize `res[k] = k * x` for rotation cost.\\n\\nTo collect type `i`\\nwe calculate `cur = min(A[i-k], .. , A[i - 1], A[i])`,\\nand increment `res[k] += cur`,\\nso we calculate the minimum cost to get type `i` with `k` operation.\\n\\nFinally we return the `min(res)` as final result.\\n<br>\\n\\n# **Complexity**\\nTime `O(n^2)`, can be `O(n)` using stack, check this [solution](https://leetcode.com/problems/collecting-chocolates/discuss/3651340/JavaC%2B%2BPython-Stack-and-Calculous-O(n))\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public long minCost(int[] A, int x) {\\n        int n = A.length;\\n        long[] res = new long[n];\\n        for (int i = 0; i < n; i++) {\\n            res[i] += 1L * i * x;\\n            int cur = A[i];\\n            for (int k = 0; k < n; k++) {\\n                cur = Math.min(cur, A[(i - k + n) % n]);\\n                res[k] += cur;\\n            }\\n        }\\n\\n        long min_res = Long.MAX_VALUE;\\n        for (long element : res) {\\n            min_res = Math.min(min_res, element);\\n        }\\n\\n        return min_res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    long long minCost(vector<int>& A, int x) {\\n        int n = A.size();\\n        vector<long long> res(n);\\n        for (int i = 0; i < n; i++) {\\n            res[i] += 1L * i * x;\\n            int cur = A[i];\\n            for (int k = 0; k < n; k++) {\\n                cur = min(cur, A[(i - k + n) % n]);\\n                res[k] += cur;\\n            }\\n        }\\n        return *std::min_element(res.begin(), res.end());\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minCost(self, A: List[int], x: int) -> int:\\n        n = len(A)\\n        res = [x * k for k in range(n)]\\n        for i in range(n):\\n            cur = A[i]\\n            for k in range(n):\\n                cur = min(cur, A[i - k])\\n                res[k] += cur\\n        return min(res)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public long minCost(int[] A, int x) {\\n        int n = A.length;\\n        long[] res = new long[n];\\n        for (int i = 0; i < n; i++) {\\n            res[i] += 1L * i * x;\\n            int cur = A[i];\\n            for (int k = 0; k < n; k++) {\\n                cur = Math.min(cur, A[(i - k + n) % n]);\\n                res[k] += cur;\\n            }\\n        }\\n\\n        long min_res = Long.MAX_VALUE;\\n        for (long element : res) {\\n            min_res = Math.min(min_res, element);\\n        }\\n\\n        return min_res;\\n    }\\n```\n```cpp\\n    long long minCost(vector<int>& A, int x) {\\n        int n = A.size();\\n        vector<long long> res(n);\\n        for (int i = 0; i < n; i++) {\\n            res[i] += 1L * i * x;\\n            int cur = A[i];\\n            for (int k = 0; k < n; k++) {\\n                cur = min(cur, A[(i - k + n) % n]);\\n                res[k] += cur;\\n            }\\n        }\\n        return *std::min_element(res.begin(), res.end());\\n    }\\n```\n```py\\n    def minCost(self, A: List[int], x: int) -> int:\\n        n = len(A)\\n        res = [x * k for k in range(n)]\\n        for i in range(n):\\n            cur = A[i]\\n            for k in range(n):\\n                cur = min(cur, A[i - k])\\n                res[k] += cur\\n        return min(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3623883,
                "title": "simply-check-cost-after-each-rotation-very-simple-easy-to-understand-solution",
                "content": "<b> Up vote if you like the solution </b>\\n# Approach\\nTrick : Keep rotating the array and then collect the min value possible at each type and check for the total cost after each roation and take the minimum.\\n\\nCould not get above !!!\\n\\nHere is the step wise explanation:\\n1. We take a vector \"checked\" which stores minimum possible value of type when we keep on rotating.\\n2. There is one outer loop that basically keep track of the number of rotation we performed.\\n3. There will be a inner loop that basically check the total cost till that rotation.\\n4. Keep taking the smallest value of all rotations.\\n\\n### Note : \\n- eventually the checked vector will store only min value in all its indexes but the optimal solution may be encountered in between as well.\\n\\n- Also we have taken a cnum of size double of the nums to nullify the effect of rotation.\\n\\n# Code\\n```\\nlong long minCost(vector<int>& nums, int x) {\\n    long long ans = LONG_MAX;\\n    vector<int> checked(nums.size(), INT_MAX), cnum(nums.begin(), nums.end());\\n    for(auto n: nums) cnum.push_back(n);\\n    for(int i = 0; i < nums.size(); ++i){\\n        long long sum = 0;\\n        for(int j = 0; j < nums.size(); ++j){\\n            checked[j] = min(checked[j], cnum[i+j]);\\n            sum += checked[j];\\n        }\\n        sum += (long long)i*(long long)x;\\n        ans = min(ans, sum);\\n    }\\n    return ans;\\n}\\n```\\n\\n<b>Here is an article of my recent interview experience at Amazon, you may like :\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nlong long minCost(vector<int>& nums, int x) {\\n    long long ans = LONG_MAX;\\n    vector<int> checked(nums.size(), INT_MAX), cnum(nums.begin(), nums.end());\\n    for(auto n: nums) cnum.push_back(n);\\n    for(int i = 0; i < nums.size(); ++i){\\n        long long sum = 0;\\n        for(int j = 0; j < nums.size(); ++j){\\n            checked[j] = min(checked[j], cnum[i+j]);\\n            sum += checked[j];\\n        }\\n        sum += (long long)i*(long long)x;\\n        ans = min(ans, sum);\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3624087,
                "title": "o-n-log-n",
                "content": "We binary-search for the number of shifts that produce the lowest cost.\\n\\nWe can do it because the cost function `f(shifts)` is unimodal (\\'V\"-shaped).\\n\\nWe find the minimum cost for `m` and `m + 1`, and go either left or right.\\n\\nWe can find the minimum cost for `m` and `m + 1` using a sliding window. \\n\\n> We can do it in O(n) by using a deque, as in the [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) problem. \\n\\n**Why the cost function is \"V\"-shaped?**\\n\\nThe cost function has two parts:\\n- Collecting cost: it decreases till it reaches `min(nums) * n`.\\n\\t- The function is strictly decreasing until it reaches the minimum.\\n\\t- Most importantly, the rate of decrease is does not increase with the number of shifts:\\n\\t\\t- For example, the function could look like: [40, 20, 15, 10, 8, 6, 5, 5, 5].\\n\\t\\t- The cost decrease is [20, 5, 5, 2, 2, 1].\\n- Change cost: `shifts * x` is always increasing.\\n\\nSince the first part is strictly decreasing, and the rate of decrease is non-increasing, the function can only have one minimum.\\n\\n**C++**\\n```cpp\\nlong long minCost(vector<int>& nums, int x) {\\n    long long cost, cost1, l = 0, r = nums.size();\\n    while (l < r) {\\n        long long m = (l + r) / 2;\\n        cost = m * x, cost1 = (m + 1) * x;\\n        deque<int> d; \\n        for (int i = 0; i < nums.size() + m + 1; ++i) {\\n            while (!d.empty() && d.back() > nums[i % nums.size()])\\n                d.pop_back();\\n            d.push_back(nums[i % nums.size()]);\\n            if (i >= m + 1) {\\n                cost1 += d.front();\\n                if (d.front() == nums[i - m - 1])\\n                    d.pop_front();\\n            }\\n            if (i >= m && i < nums.size() + m)\\n                cost += d.front();\\n        }\\n        if (cost > cost1)\\n            l = m + 1;\\n        else\\n            r = m;\\n    }\\n    return min(cost, cost1);\\n}  \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long minCost(vector<int>& nums, int x) {\\n    long long cost, cost1, l = 0, r = nums.size();\\n    while (l < r) {\\n        long long m = (l + r) / 2;\\n        cost = m * x, cost1 = (m + 1) * x;\\n        deque<int> d; \\n        for (int i = 0; i < nums.size() + m + 1; ++i) {\\n            while (!d.empty() && d.back() > nums[i % nums.size()])\\n                d.pop_back();\\n            d.push_back(nums[i % nums.size()]);\\n            if (i >= m + 1) {\\n                cost1 += d.front();\\n                if (d.front() == nums[i - m - 1])\\n                    d.pop_front();\\n            }\\n            if (i >= m && i < nums.size() + m)\\n                cost += d.front();\\n        }\\n        if (cost > cost1)\\n            l = m + 1;\\n        else\\n            r = m;\\n    }\\n    return min(cost, cost1);\\n}  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3624014,
                "title": "c-detailed-explaination-rotate-and-check",
                "content": "/*\\n...............................GOOD THINGS TAKE TIME............................\\nAPPROACH / INTUITION:\\nSo the operation we are given is to right shift the vector each time by 1.\\nIf we think after n - 1 operations, we will get the original array back.\\nSo any shifts more than n - 1 would be repeating ourselves.\\n\\nFirst, I create a min_cost array to keep track of min_cost for each index.\\nFirst, I initialize it with the nums array.\\nI start shifting the array by 1 each time.\\nNow, I compare this shifted array with the min_cost array.\\n\\nHere, I see two things:\\n1. Benefit of applying the operation:\\nI declare total = 0.\\nIf (min_cost[i] > nums[i]), total += (min_cost[i] - nums[i]).\\n\\n2. Cost of applying the operation:\\ncurrent_cost = (i + 1) * x.\\nBut I don\\'t have to pay the whole cost each time.\\nIf I have paid prev_cost,\\nthen I have to pay (current_cost - prev_cost) to apply the operation.\\n\\nIf (current_cost - prev_cost) <= total,\\nthen I can apply the operation.\\nThen I update the min_cost array,\\nand prev_cost = current_cost.\\nElse,\\nif applying the operation is not feasible this time,\\nit won\\'t be feasible in the future as well,\\nso I break the loop.\\n*/\\n\\n```\\n*/\\n#include <bits/stdc++.h>\\nusing namespace std;\\n#define rep(i, a, b) for (int i = a; i < b; i++)\\n#define print(p) cout << p << endl\\nconst int mod = 1e9 + 7;\\n#define printValue(val) printer(val, #val)\\nvoid printer(int num, const char *name)\\n{\\n    cout << name << \": {\" << num << \"}\" << endl;\\n}\\n\\nclass Solution\\n{\\nprivate:\\n// function to right shift vector by 1 each time.. \\n    void rightShiftVector(vector<int> &vec)\\n    {\\n        if (vec.empty())\\n        {\\n            return;\\n        }\\n        // Store the last element\\n        int lastElement = vec.back();\\n\\n        // Shift each element one position to the right\\n        for (int i = vec.size() - 2; i >= 0; i--)\\n        {\\n            vec[i + 1] = vec[i];\\n        }\\n\\n        // Place the last element at the beginning\\n        vec[0] = lastElement;\\n    }\\n\\npublic:\\n    long long minCost(vector<int> &nums, int x)\\n    {\\n#define int long long int\\n        int n = nums.size();\\n        vector<int> min_cost(n, 0);\\n        for (int i = 0; i < n; i++)\\n        {\\n            min_cost[i] = nums[i];\\n        }\\n        int prev_cost = 0;\\n        // we have to right shift the array nums by 1 each time\\n        for (int i = 0; i < n; i++)\\n        {\\n            int new_cost = (i + 1) * x;\\n            rightShiftVector(nums);\\n            // now we see if at this stage we want to apply\\n            // operation and use this cost or not\\n            // compare min_cost[i] and nums[i]\\n            int total = 0;\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (min_cost[j] > nums[j])\\n                {\\n                    total += (min_cost[j] - nums[j]);\\n                }\\n            }\\n            int net_cost = new_cost - prev_cost;\\n            // printValue(total);\\n            // printValue(net_cost);\\n            if (net_cost <= total)\\n            {\\n                // print(\"Here\");\\n                // we can apply the operation\\n                for (int j = 0; j < n; j++)\\n                {\\n                    // min_cost[j] = min(min_cost[j],nums[j]);\\n                    if (min_cost[j] > nums[j])\\n                    {\\n                        min_cost[j] = nums[j];\\n                    }\\n                }\\n                prev_cost = new_cost;\\n            }\\n            else\\n            {\\n                // we cannot apply the operation\\n                break;\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans += min_cost[i];\\n        }\\n        ans += prev_cost; // we also have to add the cost of operations we have applied\\n        return ans;\\n#undef int\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n*/\\n#include <bits/stdc++.h>\\nusing namespace std;\\n#define rep(i, a, b) for (int i = a; i < b; i++)\\n#define print(p) cout << p << endl\\nconst int mod = 1e9 + 7;\\n#define printValue(val) printer(val, #val)\\nvoid printer(int num, const char *name)\\n{\\n    cout << name << \": {\" << num << \"}\" << endl;\\n}\\n\\nclass Solution\\n{\\nprivate:\\n// function to right shift vector by 1 each time.. \\n    void rightShiftVector(vector<int> &vec)\\n    {\\n        if (vec.empty())\\n        {\\n            return;\\n        }\\n        // Store the last element\\n        int lastElement = vec.back();\\n\\n        // Shift each element one position to the right\\n        for (int i = vec.size() - 2; i >= 0; i--)\\n        {\\n            vec[i + 1] = vec[i];\\n        }\\n\\n        // Place the last element at the beginning\\n        vec[0] = lastElement;\\n    }\\n\\npublic:\\n    long long minCost(vector<int> &nums, int x)\\n    {\\n#define int long long int\\n        int n = nums.size();\\n        vector<int> min_cost(n, 0);\\n        for (int i = 0; i < n; i++)\\n        {\\n            min_cost[i] = nums[i];\\n        }\\n        int prev_cost = 0;\\n        // we have to right shift the array nums by 1 each time\\n        for (int i = 0; i < n; i++)\\n        {\\n            int new_cost = (i + 1) * x;\\n            rightShiftVector(nums);\\n            // now we see if at this stage we want to apply\\n            // operation and use this cost or not\\n            // compare min_cost[i] and nums[i]\\n            int total = 0;\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (min_cost[j] > nums[j])\\n                {\\n                    total += (min_cost[j] - nums[j]);\\n                }\\n            }\\n            int net_cost = new_cost - prev_cost;\\n            // printValue(total);\\n            // printValue(net_cost);\\n            if (net_cost <= total)\\n            {\\n                // print(\"Here\");\\n                // we can apply the operation\\n                for (int j = 0; j < n; j++)\\n                {\\n                    // min_cost[j] = min(min_cost[j],nums[j]);\\n                    if (min_cost[j] > nums[j])\\n                    {\\n                        min_cost[j] = nums[j];\\n                    }\\n                }\\n                prev_cost = new_cost;\\n            }\\n            else\\n            {\\n                // we cannot apply the operation\\n                break;\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans += min_cost[i];\\n        }\\n        ans += prev_cost; // we also have to add the cost of operations we have applied\\n        return ans;\\n#undef int\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3623812,
                "title": "keep-the-min-value-of-each-element-during-moving",
                "content": "```\\nclass Solution {\\n    public long minCost(int[] nums, int x) {\\n        long res = Long.MAX_VALUE;\\n        int n = nums.length;\\n        int[] min = new int[n];\\n        Arrays.fill(min, Integer.MAX_VALUE);\\n        for (int k = 0; k < n; k++) {\\n            long sum = (long) k * x;\\n            for (int i = 0; i < n; i++) {\\n                min[i] = Math.min(min[i], nums[(i + k) % n]);\\n                sum += min[i];\\n            }\\n            res = Math.min(res, sum);\\n        }\\n        \\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minCost(int[] nums, int x) {\\n        long res = Long.MAX_VALUE;\\n        int n = nums.length;\\n        int[] min = new int[n];\\n        Arrays.fill(min, Integer.MAX_VALUE);\\n        for (int k = 0; k < n; k++) {\\n            long sum = (long) k * x;\\n            for (int i = 0; i < n; i++) {\\n                min[i] = Math.min(min[i], nums[(i + k) % n]);\\n                sum += min[i];\\n            }\\n            res = Math.min(res, sum);\\n        }\\n        \\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651340,
                "title": "java-c-python-stack-and-calculous-o-n",
                "content": "# Preword\\nContinue from this solution [Rotate](https://leetcode.com/problems/collecting-chocolates/discuss/3623841/JavaC%2B%2BPython-Rotate)\\n\\n`res = min(min(A[i], .. A[i + k]) + kx)`,\\nwe want to find the minimize `min(A[i], .. A[i + k]) + kx` with `1 <= k <= n`.\\n\\n\\nFor stack part, needs to study these two stack problems first:\\n- 503. [Next Greater Element II](https://leetcode.com/problems/next-greater-element-ii/discuss/98270/JavaC++Python-Loop-Twice)\\n- 496. Next Greater Element I\\n<br>\\n\\n# **Intuition**\\nTake a look on `A[i]`,\\nand think when it will be the smallest in the window.\\n\\nAssume its a local minimum value,\\nthen it will the smallest value in the window,\\nand contribute to reuslts.\\n\\n\\n# **Explanation**\\nAssume `A[i - l]` is the next smaller on left of `A[i]`\\nand `A[i + r]` is the next smaller on left of `A[i]`:\\n\\n\\nFor `k = 1`,\\nwe have 1 window `[A[i]]`,\\nin which `A[i]` contributes as smallest.\\n\\nFor `k = 2`,\\nwe have 2 window `[A[i - 1], A[i]], [A[i], A[i + 1]]`,\\nin which `A[i]` contributes as smallest.\\n\\n...\\n\\nFor `min(l, r) <= k <= max(l, r) `,\\nwe have `min(l, r)`windows,\\nin which `A[i]` contributes as smallest.\\n\\nFor `k >= max(l, r)`,\\nwe have `l + r - k` windows,\\nin which `A[i]` contributes as smallest.\\n\\nWe can see that `A[i]` contributs in a curve of trapezoid.\\n\\n\\nThe deviation of curve is the slope,\\nand the deviation of slope is `A[i]`.\\n\\nSo we can initilize `res` as the second deviation of final results,\\nand accumulate the trapezoid for each `A[i]`,\\nthen integrate the prefix sum twice,\\nand return the minimum of the curve.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public static long minCost(int[] nums, int x) {\\n        // rotate min(A) to A[0]\\n        int mi = 0, n = nums.length, A[] = new int[n];\\n        for (int i = 0; i < n; i++)\\n            if (nums[i] < nums[mi])\\n                mi = i;\\n        for (int i = 0; i < n; i++)\\n            A[i] = nums[(i + mi) % n];\\n\\n        // find next smaller elements on left and right\\n        int[] left = new int[n], right = new int[n];\\n        Stack<Integer> st = new Stack<>();\\n        for (int i = 0; i < n; i++) {\\n            right[i] = n;\\n            while (!st.isEmpty() && A[st.peek()] > A[i])\\n                right[st.pop()] = i;\\n            if (!st.isEmpty())\\n                left[i] = st.peek();\\n            st.push(i);\\n        }\\n\\n        // delta of delta of results\\n        long[] res = new long[n + 1];\\n        res[0] = A[0];\\n        res[1] = x;\\n\\n        // trapezoid curve for A[i] contribution\\n        for (int i = 1; i < n; i++) {\\n            res[0] += A[i];\\n            res[Math.min(i - left[i], right[i] - i)] -= A[i];\\n            res[Math.max(i - left[i], right[i] - i)] -= A[i];\\n            res[right[i] - left[i]] += A[i];\\n        }\\n\\n        // Calculate prefix sum of res for twice\\n        for (int i = 1; i <= n; i++)\\n            res[i] += res[i - 1];\\n        for (int i = 1; i <= n; i++)\\n            res[i] += res[i - 1];\\n        return Arrays.stream(res).min().getAsLong();\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    long long minCost(vector<int>& A, int x) {\\n        // rotate min(A) to A[0]\\n        int mi = min_element(A.begin(), A.end()) - A.begin(), n = A.size();\\n        rotate(A.begin(), A.begin() + mi, A.end());\\n\\n        // find next smaller elements on left and right\\n        vector<int> left(n, 0), right(n, n), st;\\n        for (int i = 0; i < n; ++i) {\\n            while (!st.empty() && A[st.back()] > A[i]) {\\n                right[st.back()] = i;\\n                st.pop_back();\\n            }\\n            if (!st.empty()) {\\n                left[i] = st.back();\\n            }\\n            st.push_back(i);\\n        }\\n\\n        // delta of delta of results\\n        vector<long long> res(n + 1, 0);\\n        res[0] = accumulate(A.begin(), A.end(), 0L);\\n        res[1] = x;\\n\\n        // trapezoid curve for A[i] contribution\\n        for (int i = 1; i < n; ++i) {\\n            res[min(i - left[i], right[i] - i)] -= A[i];\\n            res[max(i - left[i], right[i] - i)] -= A[i];\\n            res[right[i] - left[i]] += A[i];\\n        }\\n\\n        // Accumulate res for twice\\n        for (int i = 1; i <= n; ++i)\\n            res[i] += res[i - 1];\\n        for (int i = 1; i <= n; ++i)\\n            res[i] += res[i - 1];\\n        return *min_element(res.begin(), res.end());\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minCost(self, A: List[int], x: int) -> int:\\n        # rotate min(A) to A[0]\\n        mi = A.index(min(A))\\n        A = A[mi:] + A[:mi]\\n        n = len(A)\\n\\n        # find next smaller elements on left and right\\n        left = [0] * n\\n        right = [n] * n\\n        stack = []\\n        for i in range(n):\\n            while stack and A[stack[-1]] > A[i]:\\n                right[stack.pop()] = i\\n            if stack:\\n                left[i] = stack[-1]\\n            stack.append(i)\\n\\n        # delta of delta of results\\n        res = [0] * (n + 1)\\n        res[0] = sum(A)\\n        res[1] = x\\n\\n        # trapezoid curve for A[i] contribution\\n        for i in range(1, n):  # trapezoid curve for A[i] contribution\\n            res[min(i - left[i], right[i] - i)] -= A[i]\\n            res[max(i - left[i], right[i] - i)] -= A[i]\\n            res[right[i] - left[i]] += A[i]\\n\\n        # calculate prefix sum of res for twice\\n        return min(accumulate(accumulate(res)))\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public static long minCost(int[] nums, int x) {\\n        // rotate min(A) to A[0]\\n        int mi = 0, n = nums.length, A[] = new int[n];\\n        for (int i = 0; i < n; i++)\\n            if (nums[i] < nums[mi])\\n                mi = i;\\n        for (int i = 0; i < n; i++)\\n            A[i] = nums[(i + mi) % n];\\n\\n        // find next smaller elements on left and right\\n        int[] left = new int[n], right = new int[n];\\n        Stack<Integer> st = new Stack<>();\\n        for (int i = 0; i < n; i++) {\\n            right[i] = n;\\n            while (!st.isEmpty() && A[st.peek()] > A[i])\\n                right[st.pop()] = i;\\n            if (!st.isEmpty())\\n                left[i] = st.peek();\\n            st.push(i);\\n        }\\n\\n        // delta of delta of results\\n        long[] res = new long[n + 1];\\n        res[0] = A[0];\\n        res[1] = x;\\n\\n        // trapezoid curve for A[i] contribution\\n        for (int i = 1; i < n; i++) {\\n            res[0] += A[i];\\n            res[Math.min(i - left[i], right[i] - i)] -= A[i];\\n            res[Math.max(i - left[i], right[i] - i)] -= A[i];\\n            res[right[i] - left[i]] += A[i];\\n        }\\n\\n        // Calculate prefix sum of res for twice\\n        for (int i = 1; i <= n; i++)\\n            res[i] += res[i - 1];\\n        for (int i = 1; i <= n; i++)\\n            res[i] += res[i - 1];\\n        return Arrays.stream(res).min().getAsLong();\\n    }\\n```\n```cpp\\n    long long minCost(vector<int>& A, int x) {\\n        // rotate min(A) to A[0]\\n        int mi = min_element(A.begin(), A.end()) - A.begin(), n = A.size();\\n        rotate(A.begin(), A.begin() + mi, A.end());\\n\\n        // find next smaller elements on left and right\\n        vector<int> left(n, 0), right(n, n), st;\\n        for (int i = 0; i < n; ++i) {\\n            while (!st.empty() && A[st.back()] > A[i]) {\\n                right[st.back()] = i;\\n                st.pop_back();\\n            }\\n            if (!st.empty()) {\\n                left[i] = st.back();\\n            }\\n            st.push_back(i);\\n        }\\n\\n        // delta of delta of results\\n        vector<long long> res(n + 1, 0);\\n        res[0] = accumulate(A.begin(), A.end(), 0L);\\n        res[1] = x;\\n\\n        // trapezoid curve for A[i] contribution\\n        for (int i = 1; i < n; ++i) {\\n            res[min(i - left[i], right[i] - i)] -= A[i];\\n            res[max(i - left[i], right[i] - i)] -= A[i];\\n            res[right[i] - left[i]] += A[i];\\n        }\\n\\n        // Accumulate res for twice\\n        for (int i = 1; i <= n; ++i)\\n            res[i] += res[i - 1];\\n        for (int i = 1; i <= n; ++i)\\n            res[i] += res[i - 1];\\n        return *min_element(res.begin(), res.end());\\n    }\\n```\n```py\\n    def minCost(self, A: List[int], x: int) -> int:\\n        # rotate min(A) to A[0]\\n        mi = A.index(min(A))\\n        A = A[mi:] + A[:mi]\\n        n = len(A)\\n\\n        # find next smaller elements on left and right\\n        left = [0] * n\\n        right = [n] * n\\n        stack = []\\n        for i in range(n):\\n            while stack and A[stack[-1]] > A[i]:\\n                right[stack.pop()] = i\\n            if stack:\\n                left[i] = stack[-1]\\n            stack.append(i)\\n\\n        # delta of delta of results\\n        res = [0] * (n + 1)\\n        res[0] = sum(A)\\n        res[1] = x\\n\\n        # trapezoid curve for A[i] contribution\\n        for i in range(1, n):  # trapezoid curve for A[i] contribution\\n            res[min(i - left[i], right[i] - i)] -= A[i]\\n            res[max(i - left[i], right[i] - i)] -= A[i]\\n            res[right[i] - left[i]] += A[i]\\n\\n        # calculate prefix sum of res for twice\\n        return min(accumulate(accumulate(res)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3623893,
                "title": "simple-brute-force-c-solution",
                "content": "\\n# Approach\\nMaintain the cost of taking each type of chocolate after each operation.There can be atmost n-1 operations as after that the operations are repeated.Compute the cost of taking all types of chocolate after each operation and update the minimum cost of each chocolate.\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& a, int x) {\\n        long long ans = 0;\\n        long long n = a.size();\\n        vector<long long> mi(n,1e9);\\n        for(int i=0;i<n;i++)\\n        {\\n            mi[i] = a[i];\\n            ans+=mi[i];\\n        }\\n        for(long long i=1;i<n;i++)\\n        {\\n            long long f = x;\\n            long long cost = i*f;\\n            for(long long j=0;j<n;j++)\\n            {\\n                long long d = a[(j+i)%n];\\n                mi[j] = min(mi[j],d);\\n                cost+=mi[j];\\n            }\\n            ans=min(ans,cost);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& a, int x) {\\n        long long ans = 0;\\n        long long n = a.size();\\n        vector<long long> mi(n,1e9);\\n        for(int i=0;i<n;i++)\\n        {\\n            mi[i] = a[i];\\n            ans+=mi[i];\\n        }\\n        for(long long i=1;i<n;i++)\\n        {\\n            long long f = x;\\n            long long cost = i*f;\\n            for(long long j=0;j<n;j++)\\n            {\\n                long long d = a[(j+i)%n];\\n                mi[j] = min(mi[j],d);\\n                cost+=mi[j];\\n            }\\n            ans=min(ans,cost);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778221,
                "title": "python3-maintain-best-cost-after-r-rotations",
                "content": "Suppose we rotate `R` times.  Then the cost to collect at `i` is `min(A[i], A[i-1], ..., A[i-R+1])` (negative indices wrap around.)\\n\\nWe can maintain this cost by doing `R` steps of `A[i] = min(A[i], A[i-1])`.\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, A: List[int], X: int) -> int:\\n        ans = sum(A)\\n        for rotations in range(1, len(A)):\\n            A = [min(A[i], A[i-1]) for i in range(len(A))]\\n            ans = min(ans, rotations * X + sum(A))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, A: List[int], X: int) -> int:\\n        ans = sum(A)\\n        for rotations in range(1, len(A)):\\n            A = [min(A[i], A[i-1]) for i in range(len(A))]\\n            ans = min(ans, rotations * X + sum(A))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624747,
                "title": "most-simplified-solution-just-rotate-and-check",
                "content": "# APPROACH\\nWe will be maintaining a cost vector to keep the minimal cost possible for a chocolate. RightShifting function shifts the price to the right by one place. We calculate the totalSum upon each rotation and then the minimal is returned. Note that each chocolate will encounter the price once and atmost there will be n-1 rotations and at the n th time , original and rotated nums will be same.**DO UPVOTE**\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void rightShifting(vector<int> &nums) {\\n        int last = nums[nums.size() - 1];\\n        for(int i = nums.size() - 2; i >=0 ; i--) {\\n            nums[i+1] = nums[i];\\n        }\\n        nums[0] = last;\\n    }\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        vector<long long> cost(n, LONG_MAX);\\n        long long mini = LONG_MAX;\\n        for(int i = 0; i < n; i++) {\\n            rightShifting(nums);\\n            long long totalCost = (long long)(x) * (long long)(i);\\n            for(int j = 0; j < n; j++) {\\n                cost[j] = min(cost[j],(long long)nums[j]);\\n                totalCost+=cost[j];\\n            }\\n            mini = min(mini, totalCost);\\n        }\\n        return mini;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void rightShifting(vector<int> &nums) {\\n        int last = nums[nums.size() - 1];\\n        for(int i = nums.size() - 2; i >=0 ; i--) {\\n            nums[i+1] = nums[i];\\n        }\\n        nums[0] = last;\\n    }\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        vector<long long> cost(n, LONG_MAX);\\n        long long mini = LONG_MAX;\\n        for(int i = 0; i < n; i++) {\\n            rightShifting(nums);\\n            long long totalCost = (long long)(x) * (long long)(i);\\n            for(int j = 0; j < n; j++) {\\n                cost[j] = min(cost[j],(long long)nums[j]);\\n                totalCost+=cost[j];\\n            }\\n            mini = min(mini, totalCost);\\n        }\\n        return mini;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623985,
                "title": "explained-simple-and-clear-python3-code",
                "content": "# Intuition\\nThe problem requires finding the minimum cost to collect chocolates of all types by performing operations that involve changing the type of chocolates. We need to minimize the overall cost while ensuring that each chocolate type is eventually collected.\\n\\n\\n# Approach\\nThe given solution approach utilizes a greedy strategy to determine the minimum cost. It starts by initializing the variables eat and cost. The eat list stores the current state of the chocolates, and the cost variable tracks the total cost incurred so far.\\n\\nThe solution iterates over the array nums starting from index 1 to n-1. For each iteration, it increments the cost by the value of x, as this represents the cost of the operation to change the chocolate types.\\n\\nNext, it updates the eat list by comparing the current element at index j with the element at j-i in nums. The eat list stores the minimum cost for each chocolate type at any given iteration.\\n\\nAfter updating the eat list, the solution calculates the sum of the elements in eat and adds it to the current value of cost. This represents the total cost incurred after the operation and updating the eat list.\\n\\nFinally, the solution compares the current result (sum of eat and cost) with the minimum result obtained so far (res). If the current result is smaller than res, it updates res with the current result.\\n\\nThe solution returns the final value of res, which represents the minimum cost to collect all types of chocolates.\\n# Complexity\\n- Time complexity:\\nThe solution utilizes nested loops to iterate over the array, resulting in a time complexity of O(n^2), where n is the size of the input array.\\n- Space complexity:\\nThe space complexity of the solution is O(n) because it requires an additional list eat to store the current state of the chocolates.\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, nums, x):\\n        n = len(nums)\\n        eat = [nums[i] for i in range(n)]\\n        cost=0\\n        res=sum(nums)\\n        for i in range(1, n):\\n            cost+=x\\n            for j in range(n):\\n                \\n                eat[j]=min(eat[j],nums[j-i])\\n            res=min(res,sum(eat)+cost)\\n        return res\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums, x):\\n        n = len(nums)\\n        eat = [nums[i] for i in range(n)]\\n        cost=0\\n        res=sum(nums)\\n        for i in range(1, n):\\n            cost+=x\\n            for j in range(n):\\n                \\n                eat[j]=min(eat[j],nums[j-i])\\n            res=min(res,sum(eat)+cost)\\n        return res\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623929,
                "title": "keep-track-the-minimum-in-each-rotate-easy-to-understand",
                "content": "In each rotate just keep track of the minimum of every element and update the sum of all elements at each rotate and the number of shifts done\\nFor example consider array [31 25 18 59] and cost 27. You can do atmost 4 rotate.\\n\\nshift1 - 31 25 18 59     -> sum(element) + (27)*0 = 133\\nshift2 - 25 18 18 31     -> sum(element) + (27)*1 = 119\\nshift3 - 18 18 18 25     -> sum(element) + (27)*2 = 133\\nshift4 - 18 18 18 18     -> sum(element) + (27)*3 = 153\\n\\nThe minimum amoung this is the answer. That is 119.\\n\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        long long best = LONG_MAX;\\n        vector<int> curr = nums;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                curr[j] = min(curr[j], nums[(j+i)%n]);\\n            }\\n            long long total = 0;\\n            for(auto it : curr) total += (1LL*it);\\n            best = min(best, total + 1LL*(i)*x);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        long long best = LONG_MAX;\\n        vector<int> curr = nums;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                curr[j] = min(curr[j], nums[(j+i)%n]);\\n            }\\n            long long total = 0;\\n            for(auto it : curr) total += (1LL*it);\\n            best = min(best, total + 1LL*(i)*x);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623875,
                "title": "brute-force-c",
                "content": "# if this code helpful for you, please upvote that\\'s more help full for me.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        if(nums.size()==1){\\n            return nums[0];\\n        }else if(nums.size()==2){\\n            return min(min(nums[0],nums[1])*1LL*2+x,nums[0]*1LL+nums[1]);\\n        }\\n        int k = nums.size();\\n        int n = k,i,y;\\n        long long int sum = 0, ans = LONG_LONG_MAX;\\n        while(k--){\\n            sum = 0;\\n            for(i = 0; i < n; i++){\\n                sum += nums[i];\\n            }\\n            ans = min(ans,sum+(n-(k+1))*1LL*x);\\n            y = nums[n-1];\\n            for(i = n-1; i >= 1; i--){\\n                nums[i] = min(nums[i],nums[i-1]);\\n            }\\n            nums[0] = min(nums[0],y);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        if(nums.size()==1){\\n            return nums[0];\\n        }else if(nums.size()==2){\\n            return min(min(nums[0],nums[1])*1LL*2+x,nums[0]*1LL+nums[1]);\\n        }\\n        int k = nums.size();\\n        int n = k,i,y;\\n        long long int sum = 0, ans = LONG_LONG_MAX;\\n        while(k--){\\n            sum = 0;\\n            for(i = 0; i < n; i++){\\n                sum += nums[i];\\n            }\\n            ans = min(ans,sum+(n-(k+1))*1LL*x);\\n            y = nums[n-1];\\n            for(i = n-1; i >= 1; i--){\\n                nums[i] = min(nums[i],nums[i-1]);\\n            }\\n            nums[0] = min(nums[0],y);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623796,
                "title": "simulate-smallest-prefix-cost",
                "content": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        n = len(nums)\\n        costs = [i * x for i in range(n)]\\n        for i in range(n):\\n            curr = nums[i]\\n            for j in range(n):\\n                curr = min(curr, nums[(i + j) % n])\\n                costs[j] += curr\\n        return min(costs)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        n = len(nums)\\n        costs = [i * x for i in range(n)]\\n        for i in range(n):\\n            curr = nums[i]\\n            for j in range(n):\\n                curr = min(curr, nums[(i + j) % n])\\n                costs[j] += curr\\n        return min(costs)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633915,
                "title": "python-3-6-lines-deque-t-m-82-86",
                "content": "Here\\'s how this code works:\\n\\n1. Initialize variables: N as a range object from 0 to the length of nums, dp as a copy of nums, ans as infinity, and nums as a deque (double-ended queue) created from nums.\\n\\n2. Iterate over each rotation rot in the range N:\\n\\n- Update dp by taking the minimum value between dp[i] and nums[i] for each index i in the range N. This operation ensures that dp[i] contains the minimum value encountered so far for each index.\\n\\n- Calculate the sum of dp and add the product of x and rot to it. This represents the cost of the current rotation.\\n\\n- Update ans by taking the minimum value between the current ans and the calculated cost.\\n\\n- Rotate the nums deque by one position to the right. This moves the last element to the first position, shifting the elements to the right.\\n\\n3. Return the final ans, which represents the minimum cost.  *--ChatGPT*\\n\\n```\\n\\nclass Solution:\\n    def minCost(self, nums: list[int], x: int) -> int:\\n        \\n        N, dp, ans, nums = range(len(nums)), nums[:], inf, deque(nums)\\n        \\n        for rot in N:\\n\\n            dp = [min(dp[i], nums[i]) for i in N]\\n            ans = min(ans, sum(dp) + x*rot)\\n\\n            nums.rotate(1)\\n\\n        return ans\\n```\\n[https://leetcode.com/problems/collecting-chocolates/submissions/970412580/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^2) and space complexity is *O*(*N*), in which *N* ~`len(nums)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def minCost(self, nums: list[int], x: int) -> int:\\n        \\n        N, dp, ans, nums = range(len(nums)), nums[:], inf, deque(nums)\\n        \\n        for rot in N:\\n\\n            dp = [min(dp[i], nums[i]) for i in N]\\n            ans = min(ans, sum(dp) + x*rot)\\n\\n            nums.rotate(1)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624556,
                "title": "easiest-brute-dry-run-explained",
                "content": "**Approach:**\\nJust do what it says: Need no brain to solve this problem.\\n* Operation:  Change the chocolate of ith type to (i + 1)th type for all indexes i where 0 <= i < n - 1. When i == n - 1, that chocolate will be changed to type of the chocolate at index 0.\\n* So, just rotate it \\'n-1\\' times and check its sum each time. Find and Return the minimum sum\\n* Notice rotating \\'n\\' times is same as **Not** rotating it. Similarly, rotating \\'n+1\\' times is same as rotating \\'1\\' times. So, atmost \\'n-1\\' rotation is sufficient.\\n* At each rotation: just check wheather (nums[i+1]>nums[i]) and replace nums[i+1] with min(nums[i+1], nums[i]).\\n\\n**DRY RUN**: Let: ```arr= [20, 1, 15], and Operation Cost, X= 5```\\n```\\n  ARRAY                    SUM\\n[20, 1, 15]                 36\\n ----- After 1 rotation -----\\n [15, 1, 1]                 17 + (1*5) = 22 [Adding operation cost after 1 rotation]\\n  ----- After 2 rotation -----\\n [1, 1, 1]                  3 + (2*5) = 13 [Adding operation cost after 2 rotation]\\n                           ------------------\\n\\t\\t\\t\\tfinalAns= min(36, 22, 13) = 13 \\t\\t   \\n```\\n**CODE:**\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n= nums.size();\\n        long long sum= 0; for(int i=0; i<n; i++){ sum+=nums[i]; } long long ans=sum;\\n        \\n        for(int cycle=1; cycle<=n; cycle++){\\n            vector<int> temp= nums; sum=0;\\n            for(int i=0; i<n-1; i++){\\n                if(nums[i+1]>nums[i]){  temp[i+1]=nums[i];  }\\n            }\\n            if(nums[0]>nums.back()){  temp[0]=nums.back();  }\\n            \\n            for(int i=0; i<n; i++){ sum+=temp[i]; }\\n            ans= min(ans, sum+ (1LL*x*cycle));\\n            nums= temp;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\nNOTE: I know there are lot of scope for optimization, but still, I believe that this is the eaiest code to understand\\nTime Complexity: O(N^2) || Space Complexity: O(N)",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```arr= [20, 1, 15], and Operation Cost, X= 5```\n```\\n  ARRAY                    SUM\\n[20, 1, 15]                 36\\n ----- After 1 rotation -----\\n [15, 1, 1]                 17 + (1*5) = 22 [Adding operation cost after 1 rotation]\\n  ----- After 2 rotation -----\\n [1, 1, 1]                  3 + (2*5) = 13 [Adding operation cost after 2 rotation]\\n                           ------------------\\n\\t\\t\\t\\tfinalAns= min(36, 22, 13) = 13 \\t\\t   \\n```\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n= nums.size();\\n        long long sum= 0; for(int i=0; i<n; i++){ sum+=nums[i]; } long long ans=sum;\\n        \\n        for(int cycle=1; cycle<=n; cycle++){\\n            vector<int> temp= nums; sum=0;\\n            for(int i=0; i<n-1; i++){\\n                if(nums[i+1]>nums[i]){  temp[i+1]=nums[i];  }\\n            }\\n            if(nums[0]>nums.back()){  temp[0]=nums.back();  }\\n            \\n            for(int i=0; i<n; i++){ sum+=temp[i]; }\\n            ans= min(ans, sum+ (1LL*x*cycle));\\n            nums= temp;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624149,
                "title": "video-explanation-building-solution-with-intuition",
                "content": "# Explanation\\n\\n[Click here to watch the video](https://youtu.be/rjfWqr-eFLI)\\n\\n# Code\\n```\\ntypedef long long int ll;\\n\\nclass Solution {\\n    vector<int> ShiftRight (vector<int>& v) {\\n        if (v.empty()) return {};\\n        \\n        vector<int> result(v.size());\\n        for (int j = 0; j < v.size()-1; j ++) {\\n            result[j] = v[j+1];\\n        }\\n        result.back() = v[0];\\n        \\n        return result;\\n    }\\n    \\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        vector<int> order(n);\\n        for (int j = 0; j < n; j ++) order[j] = j;\\n        \\n        ll operation_cost = 0;\\n        ll result = 1e18;\\n        vector<int> min_cost = nums;\\n        \\n        for (int op = 0; op < n; op ++) {\\n            ll val = 0;\\n            for (int j = 0; j < n; j ++) val += min_cost[j];\\n            \\n            result = min (result, val + operation_cost);\\n            \\n            order = ShiftRight (order);\\n            operation_cost += x;\\n            for (int j = 0; j < n; j ++) \\n                min_cost[j] = min(min_cost[j], nums[order[j]]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long int ll;\\n\\nclass Solution {\\n    vector<int> ShiftRight (vector<int>& v) {\\n        if (v.empty()) return {};\\n        \\n        vector<int> result(v.size());\\n        for (int j = 0; j < v.size()-1; j ++) {\\n            result[j] = v[j+1];\\n        }\\n        result.back() = v[0];\\n        \\n        return result;\\n    }\\n    \\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        vector<int> order(n);\\n        for (int j = 0; j < n; j ++) order[j] = j;\\n        \\n        ll operation_cost = 0;\\n        ll result = 1e18;\\n        vector<int> min_cost = nums;\\n        \\n        for (int op = 0; op < n; op ++) {\\n            ll val = 0;\\n            for (int j = 0; j < n; j ++) val += min_cost[j];\\n            \\n            result = min (result, val + operation_cost);\\n            \\n            order = ShiftRight (order);\\n            operation_cost += x;\\n            for (int j = 0; j < n; j ++) \\n                min_cost[j] = min(min_cost[j], nums[order[j]]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623851,
                "title": "java-all-rotations-cost-map",
                "content": "Try all rotations, at max there will be **`n-1`** rotations after which the array comes back to the **initial state**.\\nHere I used **Queue** to rotate the array, however there can be better ways to calculate instead of simulating the rotation.\\n\\nMaintain a variable **`totalCost`** that will keep track of total cost.\\nFirst calculate the initial **`totalCost`** by considering all the **`costs`**. From here on, you have to try to reduce your cost after every rotation.\\nUse a **HashMap** to store the **`cost`** at which you bought a chocolate type. `<key, value> = <chocolate-type, cost>`\\n\\nAfter each rotation, iterate the rotated list and ask yourselves is there any chocolate type that has a better **`cost`** **now** compared to **prev** **`cost`**.\\nIf yes then remove the **prev cost** from the **`totalCost`** and add the **current cost** and check if this new **`totalCost`** is a minimum.\\n\\n```\\n\\tpublic long minCost(int[] nums, int x) {\\n        int n = nums.length;\\n        long totalCost = 0;\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        Queue<Integer> q = new LinkedList<>();\\n        \\n        for(int i=n-1;i>=0;i--){\\n            totalCost += nums[i];\\n            map.put(i, nums[i]);\\n            q.add(nums[i]);\\n        }\\n        \\n        long ans = totalCost;\\n        \\n        for(int rotations = 0; rotations < n-1; rotations++){\\n            q.add(q.poll());\\n            totalCost += x;\\n            \\n            Iterator<Integer> it = q.iterator();\\n            int i = n-1;\\n            \\n            while(it.hasNext()){\\n                int currCost = it.next();\\n                int prevCost = map.get(i);\\n                \\n                if(currCost < prevCost){\\n                    totalCost = totalCost - prevCost + currCost;\\n                    map.put(i, currCost);\\n                }\\n                \\n                i--;\\n            }\\n            \\n            ans = Math.min(ans, totalCost);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\n\\tpublic long minCost(int[] nums, int x) {\\n        int n = nums.length;\\n        long totalCost = 0;\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        Queue<Integer> q = new LinkedList<>();\\n        \\n        for(int i=n-1;i>=0;i--){\\n            totalCost += nums[i];\\n            map.put(i, nums[i]);\\n            q.add(nums[i]);\\n        }\\n        \\n        long ans = totalCost;\\n        \\n        for(int rotations = 0; rotations < n-1; rotations++){\\n            q.add(q.poll());\\n            totalCost += x;\\n            \\n            Iterator<Integer> it = q.iterator();\\n            int i = n-1;\\n            \\n            while(it.hasNext()){\\n                int currCost = it.next();\\n                int prevCost = map.get(i);\\n                \\n                if(currCost < prevCost){\\n                    totalCost = totalCost - prevCost + currCost;\\n                    map.put(i, currCost);\\n                }\\n                \\n                i--;\\n            }\\n            \\n            ans = Math.min(ans, totalCost);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3650056,
                "title": "intuitive-approach",
                "content": "# Intuition\\n1. Let the cost of chocklates be (a0, a1, ..., an-1), the types of chocklates be (0, 1, ..., n-1). \\n2. We initialize our expected lowest = sum(a0, a1, ...)\\n3. When we rotate the types rightward, we might get lower cost for some chocklate type. To get lowest total cost we need rotate at most n-1 times\\n4. Each rotation has a fixed cost x. After each rotation we compute the total cost and compare it with the values so far\\n \\nIf you like it please vote, thanks!\\n\\n# Complexity\\n- Time complexity:\\nO(nxn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, a: List[int], x: int) -> int:\\n        n = len(a)\\n        cost = list(a)\\n        lowest = sum(a)\\n        for i in range(1, n):\\n            for j in range(n):\\n                cost[j] = min(cost[j], a[(j+i)%n])\\n            lowest = min(lowest, sum(cost) + i * x)\\n        return lowest\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, a: List[int], x: int) -> int:\\n        n = len(a)\\n        cost = list(a)\\n        lowest = sum(a)\\n        for i in range(1, n):\\n            for j in range(n):\\n                cost[j] = min(cost[j], a[(j+i)%n])\\n            lowest = min(lowest, sum(cost) + i * x)\\n        return lowest\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626729,
                "title": "java-detailed-explanation-thinking-process",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe just try all the sequence of rotation and find the minimum cost.\\nLet n be the length of the array, the total number of rotation will be <= n, because if you rotate n times, it will come back to the original sequence. \\nThe tricky part is the how do we calculate the minimum cost for each rotation?\\nI started drawing a matrix that shows the cost after each rotation to help me understand the problem. \\nThe total cost = Sum of{ minCost for each Column that you picked at that rotation.}\\nSo we need an array to save the min_cost for each column that we have seen so far after each rotation.\\nAnd we sum the min cost for each column for current rotation. And return the minimum one.\\nAnother tricky part is that the cost of rotation, it turns out that you should not add this cost to each column. Instead you should add this cost to the final total cost. The reason is because once you add this extra cost to one column, all the other columns in that row should NOT add the cost again because you are duplicating the cost. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor example: \\narr=    [15 150 56 69 214 203]  X \\n\\nrow 0:  15  150  56  69  214  203   + 0*X\\nrow 1:  203 15  150  56  69   214   + 1*X\\nrow 2:  214 203 15   150 56    69   + 2*X\\nrow 3:  69  214 203  15  150   56   + 3*X\\nrow 4:  56  69  214  203  15  150   + 4*X\\n\\nDraw a matrix m[][] which shows the cost after each rotation shown as above. We just brutal force get the minimum cost after each rotation. \\nwe use an array to save the min cost for each column seen so far, and use that value to add to our cost for that row. \\n\\nIn the contest, I made a mistake of adding X to each column, and then use greedy approach to find the minimum cost, after drawing an example, and test run a few examples, finally get the solution to work. The extra cost should be added only once for current rotation.\\nThe mincost array will save the min cost that we have seen so far while we rotate the cost array, and they are eligbile to contribute to the final result. \\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public long minCost(int[] nums, int x) {\\n        int n = nums.length;\\n        // Initial the min cost array for each column as the initial number\\n        long[] minCost = Arrays.stream(nums).mapToLong(i -> i).toArray();\\n        // final result\\n        long cost = Long.MAX_VALUE;\\n        for(int i=0; i<n; i++)\\n        {   \\n            // min cost for current row\\n            long temp = 0L;\\n            for(int j=0; j<n; j++)\\n            {\\n                // nums[(j-i+n)%n] will give you cost for current column\\n               minCost[j] = Math.min(minCost[j], nums[(j-i+n)%n]);\\n               temp+=minCost[j];\\n            }\\n            // need add 1L in the front otherwise it will overflow\\n            temp += 1L*x*i ;\\n            cost = Math.min(cost, temp);\\n        }\\n        return cost;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minCost(int[] nums, int x) {\\n        int n = nums.length;\\n        // Initial the min cost array for each column as the initial number\\n        long[] minCost = Arrays.stream(nums).mapToLong(i -> i).toArray();\\n        // final result\\n        long cost = Long.MAX_VALUE;\\n        for(int i=0; i<n; i++)\\n        {   \\n            // min cost for current row\\n            long temp = 0L;\\n            for(int j=0; j<n; j++)\\n            {\\n                // nums[(j-i+n)%n] will give you cost for current column\\n               minCost[j] = Math.min(minCost[j], nums[(j-i+n)%n]);\\n               temp+=minCost[j];\\n            }\\n            // need add 1L in the front otherwise it will overflow\\n            temp += 1L*x*i ;\\n            cost = Math.min(cost, temp);\\n        }\\n        return cost;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624622,
                "title": "c-simple-18-lines-o-n-2-solution-with-explain",
                "content": "```C++\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        ll ans=LONG_MAX;\\n        vector<ll> mincosts = vector<ll>(n,(ll)INT_MAX);\\n        for(int i = 0;i<n;i++) {\\n            ll potans = 0;//The potential answer is the total mini costs that turn i times.\\n            for(int j = 0;j<n;j++) {\\n                mincosts[j] = min(mincosts[j], (ll)nums[(j+i)%n]);\\n                potans+=mincosts[j];\\n            }\\n            ans = min(ans,potans + (ll)i*(ll)x); //x*i is the based cost to turn i times.\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Explanation\\n\\nInput: nums = [1,2,3], x = 4\\nOutput: 6\\n\\n```\\n[  1,  2,  3]\\n[  0,  1,  2] \\n[0->min cost 1, 1->min cost 2, 2->min cost 3]\\ntotal min = 1+2+3=6... with base=0  => 6 is solution \\n\\n[  1,  2,  3]\\n[  0,  1,  2] \\n[  2,  0,  1]\\nbase=4\\n[0->min cost 1, 1->min cost 2, 2->min cost 1]\\ntotal min = 1+2+1=4... with base=4  => 8 is solution \\n\\n[  1,  2,  3]\\n[  0,  1,  2] \\n[  2,  0,  1]\\n[  1,  2,  0]\\nbase=8\\n[0->min cost 1, 1->min cost 1, 2->min cost 1]\\ntotal min = 1+1+1=3 +base=> 11 \\n\\nturn 0 times, we have minimum cost 6\\nturn 1 times, we have minimum cost 8\\nturn 2 times, we have minimum cost 11\\nSo the best solution is 6 here.\\n```\\n\\n\\nInput: nums = [20,1,5], x = 5\\nOutput: 13\\n```\\n[ 20,  1, 15]\\n[  0,  1,  2]\\n[0->min cost 20, 1->min cost 1, 2->min cost 5]\\ntotal min = 20+1+5=26... with base=0  => 26 is solution \\n\\n\\n[ 20,  1, 15]\\n[  0,  1,  2]\\n[  2,  0,  1]\\n\\n[0->min cost 1, 1->min cost 1, 2->min cost 15]\\ntotal min = 1+1+15=17... with base=5  => 22 is solution \\n\\n[ 20,  1, 15]\\n[  0,  1,  2]\\n[  2,  0,  1]\\n[  1,  2,  0]\\n[0->min cost 1, 1->min cost 1, 2->min cost 1]\\ntotal min = 1+1+1=3... with base=10  => 13 is solution \\n\\nturn 0 times, we have minimum cost 26\\nturn 1 times, we have minimum cost 22\\nturn 2 times, we have minimum cost 13\\nSo the best solution is 13 here.\\n```\\n\\n\\nWe can solve the problem by above way\\nJust figure out mini total cost for turn 0, turn 1, turn 2,..., turn n-1\\nAnd decide which is the best solution. \\n\\nFor the reason to saving time, we setup a array mincosts[n] that always keep track the min cost for each run in our code. \\n\\n## Complexity\\nSpace O(N)\\nTime O(N^2)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        ll ans=LONG_MAX;\\n        vector<ll> mincosts = vector<ll>(n,(ll)INT_MAX);\\n        for(int i = 0;i<n;i++) {\\n            ll potans = 0;//The potential answer is the total mini costs that turn i times.\\n            for(int j = 0;j<n;j++) {\\n                mincosts[j] = min(mincosts[j], (ll)nums[(j+i)%n]);\\n                potans+=mincosts[j];\\n            }\\n            ans = min(ans,potans + (ll)i*(ll)x); //x*i is the based cost to turn i times.\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n[  1,  2,  3]\\n[  0,  1,  2] \\n[0->min cost 1, 1->min cost 2, 2->min cost 3]\\ntotal min = 1+2+3=6... with base=0  => 6 is solution \\n\\n[  1,  2,  3]\\n[  0,  1,  2] \\n[  2,  0,  1]\\nbase=4\\n[0->min cost 1, 1->min cost 2, 2->min cost 1]\\ntotal min = 1+2+1=4... with base=4  => 8 is solution \\n\\n[  1,  2,  3]\\n[  0,  1,  2] \\n[  2,  0,  1]\\n[  1,  2,  0]\\nbase=8\\n[0->min cost 1, 1->min cost 1, 2->min cost 1]\\ntotal min = 1+1+1=3 +base=> 11 \\n\\nturn 0 times, we have minimum cost 6\\nturn 1 times, we have minimum cost 8\\nturn 2 times, we have minimum cost 11\\nSo the best solution is 6 here.\\n```\n```\\n[ 20,  1, 15]\\n[  0,  1,  2]\\n[0->min cost 20, 1->min cost 1, 2->min cost 5]\\ntotal min = 20+1+5=26... with base=0  => 26 is solution \\n\\n\\n[ 20,  1, 15]\\n[  0,  1,  2]\\n[  2,  0,  1]\\n\\n[0->min cost 1, 1->min cost 1, 2->min cost 15]\\ntotal min = 1+1+15=17... with base=5  => 22 is solution \\n\\n[ 20,  1, 15]\\n[  0,  1,  2]\\n[  2,  0,  1]\\n[  1,  2,  0]\\n[0->min cost 1, 1->min cost 1, 2->min cost 1]\\ntotal min = 1+1+1=3... with base=10  => 13 is solution \\n\\nturn 0 times, we have minimum cost 26\\nturn 1 times, we have minimum cost 22\\nturn 2 times, we have minimum cost 13\\nSo the best solution is 13 here.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624424,
                "title": "simplest-logic-easiest-implementation-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        vector<long long>arr(nums.begin(), nums.end());\\n        long long sum = 0;\\n        for(auto i:arr) sum += i;\\n\\n        for(int i=1; i<n; i++){\\n            long long tempSum = 0;\\n            for(int j=0; j<n; j++){\\n                arr[j] = min(arr[j], (long long)nums[(j+i) % n]);\\n                tempSum += arr[j];\\n            }\\n            tempSum += ((long long)i * (long long)x);\\n            sum = min(sum, tempSum);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        vector<long long>arr(nums.begin(), nums.end());\\n        long long sum = 0;\\n        for(auto i:arr) sum += i;\\n\\n        for(int i=1; i<n; i++){\\n            long long tempSum = 0;\\n            for(int j=0; j<n; j++){\\n                arr[j] = min(arr[j], (long long)nums[(j+i) % n]);\\n                tempSum += arr[j];\\n            }\\n            tempSum += ((long long)i * (long long)x);\\n            sum = min(sum, tempSum);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623938,
                "title": "python-o-n-2-min-table",
                "content": "Try all possible n-1 rotations and use a min table to get range queries in O(1).\\nstart index for curr index will be subarray consisting of y elements preceding curr index and curr index.\\nif start index is to right of current index, then take min from (0,curr) and from(start,n-1)\\nelse take min of (start,curr).\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        n=len(nums)\\n        ans=sys.maxsize\\n        mmin=[[-1]*n for _ in range(n)]\\n        for i in range(n): mmin[i][i]=nums[i]\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                mmin[i][j]=min(mmin[i][j-1],nums[j])\\n        #rotate y times\\n        for y in range(n):\\n            val=y*x\\n            for i in range(n):\\n                l=(i-y)%n\\n                r=i\\n                if l>r:\\n                    val+=min(mmin[0][r],mmin[l][n-1])\\n                else:\\n                    val+=mmin[l][r]\\n            ans=min(ans,val)\\n        return ans\\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        n=len(nums)\\n        ans=sys.maxsize\\n        mmin=[[-1]*n for _ in range(n)]\\n        for i in range(n): mmin[i][i]=nums[i]\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                mmin[i][j]=min(mmin[i][j-1],nums[j])\\n        #rotate y times\\n        for y in range(n):\\n            val=y*x\\n            for i in range(n):\\n                l=(i-y)%n\\n                r=i\\n                if l>r:\\n                    val+=min(mmin[0][r],mmin[l][n-1])\\n                else:\\n                    val+=mmin[l][r]\\n            ans=min(ans,val)\\n        return ans\\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623806,
                "title": "python-3-rotate-n-1-times",
                "content": "# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport copy\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        result = []\\n        for d in nums:\\n            result.append(d)\\n        out = sum(result)\\n        n = len(nums)\\n        for i in range(1, n):\\n            nums = nums[n-1:n] + nums[:n-1]\\n            for j in range(n):\\n                if result[j] > nums[j]:\\n                    result[j] = nums[j]\\n            out = min(sum(result) + i*x, out)\\n        return out\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport copy\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        result = []\\n        for d in nums:\\n            result.append(d)\\n        out = sum(result)\\n        n = len(nums)\\n        for i in range(1, n):\\n            nums = nums[n-1:n] + nums[:n-1]\\n            for j in range(n):\\n                if result[j] > nums[j]:\\n                    result[j] = nums[j]\\n            out = min(sum(result) + i*x, out)\\n        return out\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623780,
                "title": "simple-c-2-solution",
                "content": "**UpVote**\\n\\n\\n \\n **SOLUTION** \\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& v, int x) {\\n        int n = v.size();\\n        for (int i=0;i<n;++i) v.push_back(v[i]);\\n        \\n        vector<vector<int> > mnv(n + n, vector<int>(n + n, (int)1e9 + 5));\\n        for (int i=0;i<n+n;++i) mnv[i][i] = v[i];\\n        for (int i=0;i<n+n;++i) {\\n            for (int j=i+1;j<n+n;++j) {\\n                mnv[i][j] = min(mnv[i][j-1], v[j]);\\n            }\\n        }\\n        long long ans = ((long long)1e9) * n;\\n        for (int k=0;k<n;++k) {\\n            long long cost = 0;\\n            for (int i=0;i<n;++i) {\\n                cost += mnv[i][i + k];\\n            }\\n            cost += x * 1LL * k;\\n            ans = min(ans, cost);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**2nd Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void rotate(vector<int>& nums) {\\n        int n = nums.size();\\n        int last = nums[n-1];\\n        for(int i = n-1; i > 0; i--) \\n            nums[i] = nums[i-1];\\n        nums[0] = last;\\n    }\\n    \\n    long long minCost(vector<int>& nums, int x) {\\n        \\n        long long cost = 0;\\n        int n = nums.size();\\n        vector<long long> res(n);\\n        long long sum = 0;\\n        for(int i = 0; i < n; i++) {\\n            res[i] = nums[i];\\n            sum += res[i];\\n        }\\n        \\n        long long fans = sum;\\n        \\n        for(int r = 1; r <= n-1; r++) {\\n            cost += x;\\n            rotate(nums);\\n            // for(auto it: nums) cout << it << \" \"; cout << endl;\\n            long long ans = 0;\\n            for(int i = 0; i < n; i++) {\\n                res[i] = min(res[i], (long long)nums[i]);\\n                ans += res[i];\\n            }\\n            \\n            fans = min(ans + cost, fans);\\n        }\\n        \\n        return fans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& v, int x) {\\n        int n = v.size();\\n        for (int i=0;i<n;++i) v.push_back(v[i]);\\n        \\n        vector<vector<int> > mnv(n + n, vector<int>(n + n, (int)1e9 + 5));\\n        for (int i=0;i<n+n;++i) mnv[i][i] = v[i];\\n        for (int i=0;i<n+n;++i) {\\n            for (int j=i+1;j<n+n;++j) {\\n                mnv[i][j] = min(mnv[i][j-1], v[j]);\\n            }\\n        }\\n        long long ans = ((long long)1e9) * n;\\n        for (int k=0;k<n;++k) {\\n            long long cost = 0;\\n            for (int i=0;i<n;++i) {\\n                cost += mnv[i][i + k];\\n            }\\n            cost += x * 1LL * k;\\n            ans = min(ans, cost);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void rotate(vector<int>& nums) {\\n        int n = nums.size();\\n        int last = nums[n-1];\\n        for(int i = n-1; i > 0; i--) \\n            nums[i] = nums[i-1];\\n        nums[0] = last;\\n    }\\n    \\n    long long minCost(vector<int>& nums, int x) {\\n        \\n        long long cost = 0;\\n        int n = nums.size();\\n        vector<long long> res(n);\\n        long long sum = 0;\\n        for(int i = 0; i < n; i++) {\\n            res[i] = nums[i];\\n            sum += res[i];\\n        }\\n        \\n        long long fans = sum;\\n        \\n        for(int r = 1; r <= n-1; r++) {\\n            cost += x;\\n            rotate(nums);\\n            // for(auto it: nums) cout << it << \" \"; cout << endl;\\n            long long ans = 0;\\n            for(int i = 0; i < n; i++) {\\n                res[i] = min(res[i], (long long)nums[i]);\\n                ans += res[i];\\n            }\\n            \\n            fans = min(ans + cost, fans);\\n        }\\n        \\n        return fans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3658471,
                "title": "chocolate-solution-with-nifty-diagram",
                "content": "# Approach 1 - Triple Loops\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Intuition\\n\\nNote that the number of price shifts must be some number from `0` to `n-1`. If there were `n` shifts, the chocolates would loop back to their original prices, a waste of money. The minimum cost can be found by examining the minimum cost for every number of total price shifts from `0` to `n-1`. Let\\'s look at Example 1 for a better idea of what this looks like:\\n![cropped chocolate diagram.jpg](https://assets.leetcode.com/users/images/76babe7a-dcea-4ace-bf68-db87393fde03_1686940754.4992702.jpeg)\\nAs seen in the diagram, the procedure compares the minimum collection cost for different numbers of price shifts. Because Example 1 has three chocolates, shifts `0` through `2` are examined.\\n\\nFor a given number of shifts $$k$$, $$\\\\text{cost} = kx + \\\\sum\\\\limits_{i=0}^{n-1}p_i$$ where $$p_i$$ is the price of chocolate $$i$$. This equation can be minimized with a greedy approach. Choose the lowest price within `k` shifts for each chocolate type to find the minimum collection cost for a particular `k`. In Example 1, chocolates `0`, `1`, and `2` have possible prices of `[[20,15], [1,20], [15,1]]` when there is one shift. The minimums of those prices are `[15, 1, 1]`, so the minimum total cost for `k=1` is `1*5 + 15 + 1 + 1 = 22`. Using this process for zero and two shifts yields minimum totals of `36` and `13` respectively. \\n\\nThe final answer is the minimum of minimums. For Example 1, the output is `min(36, 22, 13) = 13`.\\n\\n# Algorithm\\n- Have `k` iterate from `0` to `n-1` where `k` is the number of shifts\\n- For each `k`, have `i` iterate from  `0` to `n-1` where `i` is chocolate type\\n- For each `i`, have `j` iterate from `i-k` to `i`. `nums[j mod n]` represents all price options of chocolate `i` under `k` shifts.\\n- The minimum total cost for a certain `k` is `k*x + p(0) + p(1) +...+ p(n-1)` where `p(i) = min(nums[j mod n])` for `i-k <= j <= i`.\\n- Output the lowest total cost amongst all values of `k` \\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    long long minCost(const vector<int>& nums, const int& x) {\\n        long long ans = 1000*pow(10, 9);\\n        const int n = nums.size();\\n       \\n        //examining costs for 0 to n - 1 shifts\\n        for (int k = 0; k < n; k++) {\\n            long long total = (long long) k*x;\\n\\n            //finding minimum price of each chocolate\\n            for (int i = 0; i < n; i++) {\\n                int minPrice = nums[i];\\n\\n                //finding minimum price of type i chocolate within k shifts\\n                for (int j = i - k; j <= i; j++) {\\n                    minPrice = min(minPrice, nums[(j+n) % n]);\\n                }\\n\\n                total += minPrice;\\n            }\\n\\n            ans = min(ans, total);\\n        }\\n            \\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public long minCost(int[] nums, int x) {\\n        long ans = (long) Math.pow(10, 9)*1000;\\n        final int n = nums.length;\\n       \\n        //examining costs for 0 to n - 1 shifts\\n        for (int k = 0; k < n; k++) {\\n            long total = (long) k*x;\\n\\n            //finding minimum price of each chocolate\\n            for (int i = 0; i < n; i++) {\\n                int minPrice = nums[i];\\n\\n                //finding minimum price of type i chocolate within k shifts\\n                for (int j = i - k; j <= i; j++) {\\n                    minPrice = Math.min(minPrice, nums[(j+n) % n]);\\n                }\\n\\n                total += minPrice;\\n            }\\n\\n            ans = Math.min(ans, total);\\n        }\\n            \\n        return ans;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        ans = 1000*10**9\\n        n = len(nums)\\n       \\n        #examining costs for 0 to n - 1 shifts\\n        for k in range(n):\\n            total = k*x\\n\\n            #finding minimum price of each candy\\n            for i in range(n):\\n                minPrice = nums[i]\\n\\n                #finding minimum price of type i candy within k shifts\\n                for j in range(i-k, i+1):\\n                    minPrice = min(minPrice, nums[j])\\n\\n                total += minPrice\\n\\n            ans = min(ans, total)\\n            \\n        return ans\\n```\\n\\n\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n    - There are $$n$$ shifts examined\\n    - For each shift the prices of $$n$$ chocolates are computed\\n    - For each chocolate there are at most $$n$$ prices evaluated\\n    - Overall, the time is $$n*n*O(n) = O(n^3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n    - All the primitive variables take up constant space \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Approach 2 - Dynamic Programming\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Intuition\\nApproach 1 can be optimized. Note that $$\\\\min(\\\\text{arr}[i{\\\\ldots}j]) = \\\\min(\\\\text{arr}[i],\\\\ \\\\min(\\\\text{arr}[i+1{\\\\ldots}j]))$$ where $$\\\\text{arr}$$ is an array. This works even for subarrays that \"wrap around\" the ends. Let $$i_k=k\\\\mod n$$. Then $$\\\\min(\\\\text{arr}[i_k{\\\\ldots}i_{k+m}]) = \\\\min(\\\\text{arr}[i_k],\\\\ \\\\min(\\\\text{arr}[i_{k+1}{\\\\ldots}i_{k+m}]))$$ even when $$ start <= k <= start + m,\\\\ start < 0,\\\\ start + m >= 0$$.\\n\\nThe above observation can be used to speed up the process for finding a chocolate\\'s minimum price within a certain number of shifts. Create an array called `minPrice` where `minPrice[i]` is the lowest price of chocolate `i` within `k-1` shifts. When the procedure moves on to `k` shifts, update the `minPrice` using `minPrice[i] = min(minPrice[i], nums[(i-k) mod n])`. In Example 1, `minPrice = [20, 1, 15]` when `k=0`. When `k=1`, the chocolates gain new prices of `[15, 20, 1]` so `minPrice = [min(20,15), min(1,20), min(15,1)] = [15, 1, 1]`. Finally when `k=2`, the chocolates gain new prices of `[1, 15, 20]` so `minPrice = [min(15,1), min(1,15), min(1,20)] = [1, 1, 1]`. \\n\\nStoring the minimums in an array lets you compare two prices instead of `k` prices whenever the lowest chocolate price must be updated, improving performance considerably.\\n\\n# Algorithm\\n\\n- Create `minPrice` array. Initialize values so that `minPrice[i] = nums[i]`.\\n- Have `k` iterate from `0` to `n-1` where `k` is the number of shifts\\n- For each `k`, have `i` iterate from  `0` to `n-1` where `i` is chocolate type\\n- For a given `k` and `i`, update `minPrice` with `minPrice[i] = min(minPrice[i], nums[(i-k) mod n])`\\n- The minimum total cost for a certain `k` is `k*x + minPrice[0] + minPrice[1] +...+ minPrice[n-1]`\\n- Output the lowest total cost amongst all values of `k` \\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    long long minCost(const vector<int>& nums, const int& x) {\\n        vector<int> minPrice = nums;\\n        long long ans = 1000*pow(10, 9);\\n        const int n = nums.size();\\n        \\n        //examining costs for 0 to n-1 shifts\\n        for (int k = 0; k < nums.size(); k++) {\\n            //finding minimum price of each candy\\n            for (int i = 0; i < nums.size(); i++) {\\n                minPrice[i] = min(minPrice[i], nums[(i-k+n) % n]);\\n            }\\n\\n            const long long total = accumulate(minPrice.begin(), minPrice.end(), (long long) k*x); \\n            ans = min(ans, total);\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public long minCost(int[] nums, int x) {\\n        int[] minPrice = Arrays.copyOf(nums, nums.length);\\n        long ans = (long) Math.pow(10, 9)*1000;\\n        final int n = nums.length;\\n        \\n        //examining costs for 0 to n-1 shifts\\n        for (int k = 0; k < nums.length; k++) {\\n            //finding minimum price of each candy\\n            for (int i = 0; i < nums.length; i++) {\\n                minPrice[i] = Math.min(minPrice[i], nums[(i-k+n) % n]);\\n            }\\n\\n            long total = (long) k*x;\\n\\n            //calculating minimum total cost for k shifts\\n            for (int price : minPrice) {\\n                total += price;\\n            }\\n\\n            ans = Math.min(ans, total);\\n        }\\n       \\n        return ans;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        minPrice = list(nums)\\n        ans = 1000*10**9\\n        n = len(nums)\\n        \\n        #examining costs for 0 to n-1 shifts\\n        for k in range(n):\\n            #finding minimum price of each candy\\n            for i in range(n):\\n                minPrice[i] = min(minPrice[i], nums[(i-k) % n])\\n                \\n            total = k*x + sum(minPrice) \\n            ans = min(ans, total)\\n            \\n        return ans\\n```\\n\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n    - There are $$n$$ shifts examined\\n    - For each shift the prices of $$n$$ chocolates are computed\\n    - Computing a chocolate\\'s minimum price takes $$O(1)$$ thanks to the `minPrice` array\\n    - Overall, the time is $$n*n*O(1) = O(n^2)$$    \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n    - The `minPrice` array holds $$n$$ elements\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    long long minCost(const vector<int>& nums, const int& x) {\\n        long long ans = 1000*pow(10, 9);\\n        const int n = nums.size();\\n       \\n        //examining costs for 0 to n - 1 shifts\\n        for (int k = 0; k < n; k++) {\\n            long long total = (long long) k*x;\\n\\n            //finding minimum price of each chocolate\\n            for (int i = 0; i < n; i++) {\\n                int minPrice = nums[i];\\n\\n                //finding minimum price of type i chocolate within k shifts\\n                for (int j = i - k; j <= i; j++) {\\n                    minPrice = min(minPrice, nums[(j+n) % n]);\\n                }\\n\\n                total += minPrice;\\n            }\\n\\n            ans = min(ans, total);\\n        }\\n            \\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public long minCost(int[] nums, int x) {\\n        long ans = (long) Math.pow(10, 9)*1000;\\n        final int n = nums.length;\\n       \\n        //examining costs for 0 to n - 1 shifts\\n        for (int k = 0; k < n; k++) {\\n            long total = (long) k*x;\\n\\n            //finding minimum price of each chocolate\\n            for (int i = 0; i < n; i++) {\\n                int minPrice = nums[i];\\n\\n                //finding minimum price of type i chocolate within k shifts\\n                for (int j = i - k; j <= i; j++) {\\n                    minPrice = Math.min(minPrice, nums[(j+n) % n]);\\n                }\\n\\n                total += minPrice;\\n            }\\n\\n            ans = Math.min(ans, total);\\n        }\\n            \\n        return ans;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        ans = 1000*10**9\\n        n = len(nums)\\n       \\n        #examining costs for 0 to n - 1 shifts\\n        for k in range(n):\\n            total = k*x\\n\\n            #finding minimum price of each candy\\n            for i in range(n):\\n                minPrice = nums[i]\\n\\n                #finding minimum price of type i candy within k shifts\\n                for j in range(i-k, i+1):\\n                    minPrice = min(minPrice, nums[j])\\n\\n                total += minPrice\\n\\n            ans = min(ans, total)\\n            \\n        return ans\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    long long minCost(const vector<int>& nums, const int& x) {\\n        vector<int> minPrice = nums;\\n        long long ans = 1000*pow(10, 9);\\n        const int n = nums.size();\\n        \\n        //examining costs for 0 to n-1 shifts\\n        for (int k = 0; k < nums.size(); k++) {\\n            //finding minimum price of each candy\\n            for (int i = 0; i < nums.size(); i++) {\\n                minPrice[i] = min(minPrice[i], nums[(i-k+n) % n]);\\n            }\\n\\n            const long long total = accumulate(minPrice.begin(), minPrice.end(), (long long) k*x); \\n            ans = min(ans, total);\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public long minCost(int[] nums, int x) {\\n        int[] minPrice = Arrays.copyOf(nums, nums.length);\\n        long ans = (long) Math.pow(10, 9)*1000;\\n        final int n = nums.length;\\n        \\n        //examining costs for 0 to n-1 shifts\\n        for (int k = 0; k < nums.length; k++) {\\n            //finding minimum price of each candy\\n            for (int i = 0; i < nums.length; i++) {\\n                minPrice[i] = Math.min(minPrice[i], nums[(i-k+n) % n]);\\n            }\\n\\n            long total = (long) k*x;\\n\\n            //calculating minimum total cost for k shifts\\n            for (int price : minPrice) {\\n                total += price;\\n            }\\n\\n            ans = Math.min(ans, total);\\n        }\\n       \\n        return ans;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        minPrice = list(nums)\\n        ans = 1000*10**9\\n        n = len(nums)\\n        \\n        #examining costs for 0 to n-1 shifts\\n        for k in range(n):\\n            #finding minimum price of each candy\\n            for i in range(n):\\n                minPrice[i] = min(minPrice[i], nums[(i-k) % n])\\n                \\n            total = k*x + sum(minPrice) \\n            ans = min(ans, total)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650083,
                "title": "a-few-solutions",
                "content": "Perform the simulation (brute-force), ie. consider all `k = 0..N-1` inclusive `rotations`.\\n\\nFor each `k`<sup>th</sup> `rotation`, we accumulate the minimum total `t` to find the `best` answer by tracking the *ongoing* minimum `cost` of each `i`<sup>th</sup> index from `i = 0..N-1` inclusive.\\n\\n* Note: each candidate total `t` is intialized to `k * rotations`, ie. we initially pay the cost to perform `k` rotations\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minCost(A: IntArray, rotations: Int): Long {\\n        var N = A.size\\n        var (best, cost) = Pair(Long.MAX_VALUE, A.copyOf())\\n        for (k in 0..N - 1) {\\n            var t = k.toLong() * rotations\\n            for (i in 0..N - 1) {\\n                cost[i] = Math.min(cost[i], A[(i + k) % N]); t += cost[i].toLong()\\n            }\\n            best = Math.min(best, t)\\n        }\\n        return best\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minCost = (A, rotations, N = A.length, cost = [...A], best = Infinity) => {\\n    for (let k = 0; k < N; ++k) {\\n        let t = k * rotations;\\n        for (let i = 0; i < N; ++i)\\n            t += cost[i] = Math.min(cost[i], A[(i + k) % N]);\\n        best = Math.min(best, t);\\n    }\\n    return best;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minCost(self, A: List[int], rotations: int) -> int:\\n        N = len(A)\\n        best, cost = sum(A), A[:]\\n        for k in range(N):\\n            t = k * rotations\\n            for i in range(N):\\n                cost[i] = min(cost[i], A[(i + k) % N]); t += cost[i]\\n            best = min(best, t)\\n        return best\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn min_cost(A: VI, rotations: i32) -> i64 {\\n        let N = A.len();\\n        let (mut best, mut cost) = (i64::MAX, A.clone());\\n        for k in 0..N {\\n            let mut t = k as i64 * rotations as i64;\\n            for i in 0..N {\\n                cost[i] = min(cost[i], A[(i + k) % N]); t += cost[i] as i64;\\n            }\\n            best = min(best, t)\\n        }\\n        best\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using LL = long long;\\n    LL minCost(VI& A, int rotations, LL best = numeric_limits<LL>::max()) {\\n        auto N = A.size();\\n        VI cost{ A };\\n        for (auto k{ 0 }; k < N; ++k) {\\n            LL t = LL(k) * rotations;\\n            for (auto i{ 0 }; i < N; ++i)\\n                t += cost[i] = min(cost[i], A[(i + k) % N]);\\n            best = min(best, t);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minCost(A: IntArray, rotations: Int): Long {\\n        var N = A.size\\n        var (best, cost) = Pair(Long.MAX_VALUE, A.copyOf())\\n        for (k in 0..N - 1) {\\n            var t = k.toLong() * rotations\\n            for (i in 0..N - 1) {\\n                cost[i] = Math.min(cost[i], A[(i + k) % N]); t += cost[i].toLong()\\n            }\\n            best = Math.min(best, t)\\n        }\\n        return best\\n    }\\n}\\n```\n```\\nlet minCost = (A, rotations, N = A.length, cost = [...A], best = Infinity) => {\\n    for (let k = 0; k < N; ++k) {\\n        let t = k * rotations;\\n        for (let i = 0; i < N; ++i)\\n            t += cost[i] = Math.min(cost[i], A[(i + k) % N]);\\n        best = Math.min(best, t);\\n    }\\n    return best;\\n};\\n```\n```\\nclass Solution:\\n    def minCost(self, A: List[int], rotations: int) -> int:\\n        N = len(A)\\n        best, cost = sum(A), A[:]\\n        for k in range(N):\\n            t = k * rotations\\n            for i in range(N):\\n                cost[i] = min(cost[i], A[(i + k) % N]); t += cost[i]\\n            best = min(best, t)\\n        return best\\n```\n```\\ntype VI = Vec<i32>;\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn min_cost(A: VI, rotations: i32) -> i64 {\\n        let N = A.len();\\n        let (mut best, mut cost) = (i64::MAX, A.clone());\\n        for k in 0..N {\\n            let mut t = k as i64 * rotations as i64;\\n            for i in 0..N {\\n                cost[i] = min(cost[i], A[(i + k) % N]); t += cost[i] as i64;\\n            }\\n            best = min(best, t)\\n        }\\n        best\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using LL = long long;\\n    LL minCost(VI& A, int rotations, LL best = numeric_limits<LL>::max()) {\\n        auto N = A.size();\\n        VI cost{ A };\\n        for (auto k{ 0 }; k < N; ++k) {\\n            LL t = LL(k) * rotations;\\n            for (auto i{ 0 }; i < N; ++i)\\n                t += cost[i] = min(cost[i], A[(i + k) % N]);\\n            best = min(best, t);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626593,
                "title": "o-n-rotate-the-array-and-recalculate-sum-javascript",
                "content": "JS implementation of [this solution](https://leetcode.com/problems/collecting-chocolates/solutions/3623806/python-3-rotate-n-1-times/)\\n\\n# Intuition\\nSince the constraints are not too big we can apply brute force here.\\n\\nFirst initialize the `results` array, which is essentially a copy of `nums`.\\nAlso declare `min` variable, which will store the sum of all numbers in `nums`.\\n\\n`n-1` times rotate `nums` array (`nums.unshift(nums.pop())`)\\n\\nFor each rotation check if `j-th` value of `nums` is smaller than `j-th` value of `results`. If it is smaller override `i-th` value in `results`.\\n\\nAfter checking all numbers of `results` recalculate `min`.\\n\\n# Complexity\\n- Time complexity: O(n\\xB2)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nvar minCost = function(nums, x) {\\n    const results = [...nums]\\n    let min = results.reduce((a,b) => a+b, 0)\\n\\n    for (let i=1; i<nums.length; i++) {\\n        nums.unshift(nums.pop())\\n        for (j=0; j<nums.length; j++) {\\n            if (results[j] > nums[j]) {\\n                results[j] = nums[j]\\n            }\\n        }\\n        min = Math.min(min, results.reduce((a,b) => a+b, 0) + i*x)\\n    }\\n\\n    return min\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minCost = function(nums, x) {\\n    const results = [...nums]\\n    let min = results.reduce((a,b) => a+b, 0)\\n\\n    for (let i=1; i<nums.length; i++) {\\n        nums.unshift(nums.pop())\\n        for (j=0; j<nums.length; j++) {\\n            if (results[j] > nums[j]) {\\n                results[j] = nums[j]\\n            }\\n        }\\n        min = Math.min(min, results.reduce((a,b) => a+b, 0) + i*x)\\n    }\\n\\n    return min\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3626448,
                "title": "kotlin-simple-solution",
                "content": "# Approach\\nWe can try every possible number of rotations and use a sliding window+PriorityQueue to find the min for each number\\n\\n# Complexity\\n- Time complexity:\\n- O(n * n log n)\\n\\n# Code\\n```\\nclass Solution {\\n    fun minCost(nums: IntArray, x: Int): Long {\\n        var min = Long.MAX_VALUE\\n        var n = nums.size\\n        for (rots in 0 until n) {\\n            var start = 0\\n            var pq = PriorityQueue(nums.toList().subList(start, start + rots + 1))\\n            \\n            var sum = 0L\\n            while (start < n) {\\n                sum += pq.peek()\\n                pq.remove(nums[start % n])\\n                pq.add(nums[(++start + rots) % n])\\n            }\\n            min = minOf(min, sum + x.toLong() * rots)\\n        }\\n        return min\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minCost(nums: IntArray, x: Int): Long {\\n        var min = Long.MAX_VALUE\\n        var n = nums.size\\n        for (rots in 0 until n) {\\n            var start = 0\\n            var pq = PriorityQueue(nums.toList().subList(start, start + rots + 1))\\n            \\n            var sum = 0L\\n            while (start < n) {\\n                sum += pq.peek()\\n                pq.remove(nums[start % n])\\n                pq.add(nums[(++start + rots) % n])\\n            }\\n            min = minOf(min, sum + x.toLong() * rots)\\n        }\\n        return min\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625413,
                "title": "simple-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long \\n    \\n    ll minCost(vector<int>& Nums, int X) {\\n        ll n = Nums.size(); \\n        ll x = (ll)X; \\n        vector<ll> nums(n);\\n        ll ans = 0;\\n        for(ll i = 0; i < n; i++) {\\n            nums[i] = (ll)Nums[i];\\n            ans += nums[i];\\n        }\\n        \\n        vector<ll> tree(4*n+1);\\n        \\n        for(int i = 1; i < n; i++) {\\n            ll cost = i*x; \\n            \\n            deque<ll> dq;\\n            int idx = (n-i);\\n            for(int j = idx; j < n; j++) {\\n                while(!dq.empty() and nums[j] <= nums[dq.back()]) dq.pop_back();\\n                dq.push_back(j);\\n            }\\n            \\n            for(int j = 0; j < n; j++) {\\n                \\n                while(!dq.empty() and nums[dq.back()] >= nums[j]) dq.pop_back();\\n                \\n                while(!dq.empty() and (j-dq.front()+n)%n > i) dq.pop_front(); \\n                dq.push_back(j);\\n                \\n                cost += nums[dq.front()];\\n            }\\n            \\n            ans = min(ans, cost);\\n        }\\n        \\n        return ans;\\n        \\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long \\n    \\n    ll minCost(vector<int>& Nums, int X) {\\n        ll n = Nums.size(); \\n        ll x = (ll)X; \\n        vector<ll> nums(n);\\n        ll ans = 0;\\n        for(ll i = 0; i < n; i++) {\\n            nums[i] = (ll)Nums[i];\\n            ans += nums[i];\\n        }\\n        \\n        vector<ll> tree(4*n+1);\\n        \\n        for(int i = 1; i < n; i++) {\\n            ll cost = i*x; \\n            \\n            deque<ll> dq;\\n            int idx = (n-i);\\n            for(int j = idx; j < n; j++) {\\n                while(!dq.empty() and nums[j] <= nums[dq.back()]) dq.pop_back();\\n                dq.push_back(j);\\n            }\\n            \\n            for(int j = 0; j < n; j++) {\\n                \\n                while(!dq.empty() and nums[dq.back()] >= nums[j]) dq.pop_back();\\n                \\n                while(!dq.empty() and (j-dq.front()+n)%n > i) dq.pop_front(); \\n                dq.push_back(j);\\n                \\n                cost += nums[dq.front()];\\n            }\\n            \\n            ans = min(ans, cost);\\n        }\\n        \\n        return ans;\\n        \\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624791,
                "title": "simple-iterative-solution-with-space-o-1-with-video-explanation",
                "content": "# Approach\\nApproach for below Code has been explained in detail at below youtube video.\\n\\nhttps://youtu.be/NB0F8odXBks\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        long long result=0;\\n        int n=nums.size();\\n        for(auto y: nums) result+=y;\\n        for(int i=0;i<n;i++)\\n        {\\n            long long sum=0;\\n            int temp=nums[0];\\n            for(int j=0;j<n;j++)\\n            {\\n                if(j==n-1)\\n                {\\n                    if(nums[j] > temp)\\n                        nums[j]=temp;\\n                }\\n                else if(nums[j] > nums[j+1])\\n                {\\n                    nums[j]=nums[j+1];\\n                }\\n                sum+=nums[j];\\n            }\\n            sum+=(long long ) x * (long long)(i+1);\\n            result= min(result,sum);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        long long result=0;\\n        int n=nums.size();\\n        for(auto y: nums) result+=y;\\n        for(int i=0;i<n;i++)\\n        {\\n            long long sum=0;\\n            int temp=nums[0];\\n            for(int j=0;j<n;j++)\\n            {\\n                if(j==n-1)\\n                {\\n                    if(nums[j] > temp)\\n                        nums[j]=temp;\\n                }\\n                else if(nums[j] > nums[j+1])\\n                {\\n                    nums[j]=nums[j+1];\\n                }\\n                sum+=nums[j];\\n            }\\n            sum+=(long long ) x * (long long)(i+1);\\n            result= min(result,sum);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624288,
                "title": "easy-c-dp-approach",
                "content": "# Approach\\nmat[i][j] will denote the minimum possible value of ith chocolate after j rotations. Just initialize the value of first column of the mat and then find the minimum of every ith chocolate after j operations.\\nNote- you can further space optimize the solution by using two 1-D arrays one for previous and one for current.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*n)$$\\n\\n- Space complexity:\\n$$O(n*n)$$\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        ll n = nums.size() , ans = 0;\\n        ll mat[n][n];\\n        //Initialization\\n        for(ll i = 0 ; i < n ; i++){\\n            mat[i][0] = nums[i];\\n            ans += nums[i];\\n        }\\n        //outer loop will denote the rotation\\n        for(ll i = 1 ; i < n ; i++){\\n            ll sum = i * x;\\n            //inner loop will calculate the total cost after i rotations\\n            for(ll j = 0 ; j < n ; j++){\\n                mat[j][i] = min(mat[j][i-1] , (ll)nums[(i+j)%n]);\\n                sum += mat[j][i];\\n            }\\n            //take the minimum\\n            ans = min(ans , sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        ll n = nums.size() , ans = 0;\\n        ll mat[n][n];\\n        //Initialization\\n        for(ll i = 0 ; i < n ; i++){\\n            mat[i][0] = nums[i];\\n            ans += nums[i];\\n        }\\n        //outer loop will denote the rotation\\n        for(ll i = 1 ; i < n ; i++){\\n            ll sum = i * x;\\n            //inner loop will calculate the total cost after i rotations\\n            for(ll j = 0 ; j < n ; j++){\\n                mat[j][i] = min(mat[j][i-1] , (ll)nums[(i+j)%n]);\\n                sum += mat[j][i];\\n            }\\n            //take the minimum\\n            ans = min(ans , sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624262,
                "title": "beginner-friendly-solution-brute-force-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> Rotate(vector<int>arr, int d, int n)\\n    {\\n        vector<int>temp(n);\\n        int k = 0;\\n        for (int i = d; i < n; i++) {\\n            temp[k] = arr[i];\\n            k++;\\n        }\\n        for (int i = 0; i < d; i++) {\\n            temp[k] = arr[i];\\n            k++;\\n        }\\n        return temp; \\n    }\\n\\n    long long minCost(vector<int>& nums, int x) {\\n        long long int cost = 0;\\n        int n = nums.size();\\n        vector<long long int> final(n, LLONG_MAX);\\n        long long int spare = LLONG_MAX;\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            long long temp = 0;\\n            for(int j = 0 ; j < nums.size() ; j++){\\n                //cout << nums[j] << endl;\\n                if(nums[j] < final[j]) final[j] = nums[j];\\n                temp += final[j];\\n            }\\n            //cout << endl;\\n            spare = min(spare, cost+temp);\\n            cost += x;\\n            nums = Rotate(nums,1,n);\\n        }\\n\\n        return spare;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> Rotate(vector<int>arr, int d, int n)\\n    {\\n        vector<int>temp(n);\\n        int k = 0;\\n        for (int i = d; i < n; i++) {\\n            temp[k] = arr[i];\\n            k++;\\n        }\\n        for (int i = 0; i < d; i++) {\\n            temp[k] = arr[i];\\n            k++;\\n        }\\n        return temp; \\n    }\\n\\n    long long minCost(vector<int>& nums, int x) {\\n        long long int cost = 0;\\n        int n = nums.size();\\n        vector<long long int> final(n, LLONG_MAX);\\n        long long int spare = LLONG_MAX;\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            long long temp = 0;\\n            for(int j = 0 ; j < nums.size() ; j++){\\n                //cout << nums[j] << endl;\\n                if(nums[j] < final[j]) final[j] = nums[j];\\n                temp += final[j];\\n            }\\n            //cout << endl;\\n            spare = min(spare, cost+temp);\\n            cost += x;\\n            nums = Rotate(nums,1,n);\\n        }\\n\\n        return spare;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3624079,
                "title": "beat-100-o-n-log-n-python-binary-search-dp-sliding-window-minimum",
                "content": "# Preword\\nI usually never write solution because i have shit skills. But this time i dont see anyone posted O(n log n), and @lee215 also posted O(n^2), so i thought i want to chime in.\\nBut this approach requires you to do sliding window maximum problem before, which is hard leetcode. So you can skip this if you expect medium leetcode level. \\n\\n# Intuition\\n- given maxshift `k` for element `i`, the cost can be given as :\\n```\\ncost[i] = k * x + min(cost[i], cost[i-1], ... cost[i-k])\\n```\\nor plus sign, as the problem has ambiguity in description vs example.\\n```\\ncost[i] = k * x + min(cost[i], cost[i+1], ... cost[i+k])\\n```\\n\\n- total minimum cost would be \\n```\\ntotal = sum(cost[i]) (fixed at maximum k needed)\\n```\\n- this indicates we need to figure out `k` by binary search (log n)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- to find k, use binary search condition, the first element such that ```cost(mid) <= cost(mid+1)``` O(log2(1000))\\n- to find `min(cost[i], cost[i-1], ... cost[i-k])`, use deque for sliding window problem O(n)\\n- since we may not need to utilize all k shift, we use dp to track if we can achieve same minimum arr with less shift, memory O(n * 1000)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        # use dp to memoize seen minimum array\\n        dp = {} # arr -> min cost\\n        def cost(maxshift):\\n            arr = getMinWindow(maxshift + 1)\\n            key = tuple(arr)\\n            if key in dp:\\n                dp[key] = min(dp[key], maxshift * x + sum(arr))\\n            else:\\n                dp[key] = maxshift * x + sum(arr)\\n            return dp[key]\\n            \\n        # see sliding window maximum problem, leetcode hard\\n        def getMinWindow(k):\\n            res = []\\n            minq = deque()\\n            m = len(nums)\\n            lst = nums + nums.copy()\\n            for i, n in enumerate(lst):\\n                if i >= k and minq and minq[0] == lst[i - k]:\\n                    minq.popleft()\\n                while minq and n < minq[-1]:\\n                    minq.pop()\\n                minq.append(n)\\n                if i >= k - 1:\\n                    res.append(minq[0])\\n                if i == m + k - 2:\\n                    break\\n            return res[:m]\\n                \\n        # binary search to look for the right shift\\n        lo, hi = 0, len(nums) - 1\\n\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if cost(mid) <= cost(mid + 1):\\n                hi = mid\\n            else:\\n                lo = mid + 1\\n            \\n        return cost(lo)\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Dynamic Programming",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\ncost[i] = k * x + min(cost[i], cost[i-1], ... cost[i-k])\\n```\n```\\ncost[i] = k * x + min(cost[i], cost[i+1], ... cost[i+k])\\n```\n```\\ntotal = sum(cost[i]) (fixed at maximum k needed)\\n```\n```cost(mid) <= cost(mid+1)```\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        # use dp to memoize seen minimum array\\n        dp = {} # arr -> min cost\\n        def cost(maxshift):\\n            arr = getMinWindow(maxshift + 1)\\n            key = tuple(arr)\\n            if key in dp:\\n                dp[key] = min(dp[key], maxshift * x + sum(arr))\\n            else:\\n                dp[key] = maxshift * x + sum(arr)\\n            return dp[key]\\n            \\n        # see sliding window maximum problem, leetcode hard\\n        def getMinWindow(k):\\n            res = []\\n            minq = deque()\\n            m = len(nums)\\n            lst = nums + nums.copy()\\n            for i, n in enumerate(lst):\\n                if i >= k and minq and minq[0] == lst[i - k]:\\n                    minq.popleft()\\n                while minq and n < minq[-1]:\\n                    minq.pop()\\n                minq.append(n)\\n                if i >= k - 1:\\n                    res.append(minq[0])\\n                if i == m + k - 2:\\n                    break\\n            return res[:m]\\n                \\n        # binary search to look for the right shift\\n        lo, hi = 0, len(nums) - 1\\n\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if cost(mid) <= cost(mid + 1):\\n                hi = mid\\n            else:\\n                lo = mid + 1\\n            \\n        return cost(lo)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623973,
                "title": "c-easy-to-understand-solution-brute-force",
                "content": "# Intuition\\nSee as the the size of array can be at most be 1000 . So a O(N^2) solution will also be accepted. \\n\\nWe can simply store all the possible values of Cost Of Chocolates and return minimum one. \\n\\nSo `mp[i]` will store the cost of buying all the chocolates if we have rotated/shifted the array i times .\\n\\n\\n\\n\\n\\n# Approach\\n1. Create an array mp of size N .\\n2. Now calculate the value of minimum value of ith type of chocolate if the array has been rotated j times .\\n3. Iterate through all mp[i] and store the minimum ans .\\n\\n\\n// I Hope You liked my explanation , an UpVote will be appreciated .\\n\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        long long ans = 1e18;\\n        int n = nums.size();\\n        vector<long long> mp(n, 0);\\n        \\n        \\n        \\n        for(int i = 0 ; i<n ; i++){\\n            int t = nums[i];\\n            mp[0] += t;\\n            mp[i] += (long long)i * x;\\n            \\n            for(int j = 1 ; j<n ; j++){\\n                t = min(t, nums[(i-j+n)%n]);\\n                mp[j]+= t;\\n            }\\n        }\\n        \\n        ans = mp[0];\\n        for(int i = 1 ; i<n ; i++){\\n            if(ans> mp[i]) ans = mp[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        long long ans = 1e18;\\n        int n = nums.size();\\n        vector<long long> mp(n, 0);\\n        \\n        \\n        \\n        for(int i = 0 ; i<n ; i++){\\n            int t = nums[i];\\n            mp[0] += t;\\n            mp[i] += (long long)i * x;\\n            \\n            for(int j = 1 ; j<n ; j++){\\n                t = min(t, nums[(i-j+n)%n]);\\n                mp[j]+= t;\\n            }\\n        }\\n        \\n        ans = mp[0];\\n        for(int i = 1 ; i<n ; i++){\\n            if(ans> mp[i]) ans = mp[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623941,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\nThe overall logic iterates over the array and performs rotations while keeping track of the cumulative costs. Finally, it returns the minimum cost among all the rotations.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& A, int x) {\\n        int n = A.size();\\n\\n        // Step 1: Initialize a vector to store the cumulative costs\\n        vector<long long> res(n);\\n\\n        // Step 2: Calculate the cumulative costs for each rotation count\\n        for (int i = 0; i < n; i++) {\\n            res[i] += 1LL * i * x; // Rotation cost\\n\\n            int cur = A[i]; // Current minimum value\\n\\n            // Find the minimum value for each rotation count and update the cumulative costs\\n            for (int k = 0; k < n; k++) {\\n                cur = std::min(cur, A[(i - k + n) % n]);\\n                res[k] += cur;\\n            }\\n        }\\n\\n        // Step 3: Find the minimum cost among all rotation counts\\n        return *min_element(res.begin(), res.end());\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& A, int x) {\\n        int n = A.size();\\n\\n        // Step 1: Initialize a vector to store the cumulative costs\\n        vector<long long> res(n);\\n\\n        // Step 2: Calculate the cumulative costs for each rotation count\\n        for (int i = 0; i < n; i++) {\\n            res[i] += 1LL * i * x; // Rotation cost\\n\\n            int cur = A[i]; // Current minimum value\\n\\n            // Find the minimum value for each rotation count and update the cumulative costs\\n            for (int k = 0; k < n; k++) {\\n                cur = std::min(cur, A[(i - k + n) % n]);\\n                res[k] += cur;\\n            }\\n        }\\n\\n        // Step 3: Find the minimum cost among all rotation counts\\n        return *min_element(res.begin(), res.end());\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623902,
                "title": "c-just-two-array-greedy-n-2-easy-solution",
                "content": "\\n# Just check till minimum for each element\\n\\n\"\"\"class Solution {\\npublic:\\n  \\n  \\n  long long minCost(vector<int>& nums, int x) {\\n        long long sum = 0;\\n        vector<long long> temp;\\n        int n = nums.size();\\n        for(int i = 0;i < n;i++){\\n            temp.push_back(nums[i]);\\n            sum += nums[i];\\n        }\\n        long long xsum = 0;\\n        long long x1 = x;\\n        \\n        for(int i = 0;i < n;i++){\\n            xsum += x1;\\n            long long currsum = xsum;\\n            \\n            int start = nums[0];\\n            for(int j = 0;j < n-1;j++){\\n                nums[j] = nums[j+1];\\n            }\\n            nums[n-1] = start;\\n            \\n            for(int j = 0;j < n;j++){\\n                if(temp[j] > nums[j])\\n                    temp[j] = nums[j];\\n                currsum += temp[j];\\n            }\\n            \\n            if(sum > currsum)sum = currsum;\\n        }\\n        return sum;\\n    }\\n* };\"\"\"",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n  \\n  \\n  long long minCost(vector<int>& nums, int x) {\\n        long long sum = 0;\\n        vector<long long> temp;\\n        int n = nums.size();\\n        for(int i = 0;i < n;i++){\\n            temp.push_back(nums[i]);\\n            sum += nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3623849,
                "title": "java-dp",
                "content": "dp[i][j] : until the ith move, the smallest cost to buy jth chocolate.\\nwe don\\'t need to record the prev cost so could optimized space complexity.\\n```\\nclass Solution {\\n    public long minCost(int[] nums, int x) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        long res = 0;\\n        for (int i = 0; i < n; i++) {\\n            dp[i] = nums[i];\\n            res += (long) nums[i];\\n        }\\n        for (int i = 1; i < n; i++) { // move times\\n            long sum = (long) i * (long)x;\\n            for (int j = 0; j < n; j++) { // index\\n                int curr_index = j + i >= n ? j + i - n : j + i;\\n                dp[j] = Math.min(dp[j], nums[curr_index]);\\n                sum += (long) dp[j];\\n            }\\n            res = Math.min(res, sum);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long minCost(int[] nums, int x) {\\n        int n = nums.length;\\n        int[] dp = new int[n];\\n        long res = 0;\\n        for (int i = 0; i < n; i++) {\\n            dp[i] = nums[i];\\n            res += (long) nums[i];\\n        }\\n        for (int i = 1; i < n; i++) { // move times\\n            long sum = (long) i * (long)x;\\n            for (int j = 0; j < n; j++) { // index\\n                int curr_index = j + i >= n ? j + i - n : j + i;\\n                dp[j] = Math.min(dp[j], nums[curr_index]);\\n                sum += (long) dp[j];\\n            }\\n            res = Math.min(res, sum);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623801,
                "title": "step-by-step-explanation-in-python-with-examples",
                "content": "# Intuition\\n- Let us take the length of nums be n\\n- The maximum number of rotations that can happen is n-1\\n- If n = 10, 10th rotation configuration is going to be just the same as the original array\\n- So we would have got the minimum of the cost at some point\\n\\n# Approach\\n- Let us take an example and understand\\n   [20 1 15]\\n- After 0 rotations, the minimum we have encountered at each index = [20,1,15]\\n- We may choose this so the sum = 20+1+15 + 0 rotations = 36\\n\\n- Now after 1 rotation, the array is going to be [15, 20, 1], the minimum we have encountered at each index = [15, 1, 1] TOtal cost = 15+1+1+1rotation(x=5) = 22\\n`Note that 1 at index 1 comes from 0th rotation, Since we have rotated 1 times, we could very well pick the one that was lowest in all, which is the 0th rotation`\\n\\n- Now after two rotations The array is going to be [1,15,20] and the minimum we have encountered is [1,1,1] Total cost = 1+1+1 + 2 rotations = 13\\n\\n\\n- Total costs at each rotation = 36, 22, 13\\nMinimum = 13\\n\\n- After all rotations, we know that the least cost is 13\\n## That\\'s the process\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*n)$$\\n\\n- Space complexity:\\n$$O(n*n)$$: To store ar\\n\\n# Code\\n```python []\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        n = len(nums)\\n        ar = [[0]*n for i in range(n)]\\n        #ith row tells the element change after ith rotation\\n        #eg. ar[i][j] tells the jth elements of nums after i rotations\\n        for i in range(n):\\n            for j in range(n):\\n                ar[i][j] = nums[(j+i)%n]\\n        ans = float(\\'inf\\')\\n        \\n        #To keep track of the minimum after each round\\n        min_scores = [float(\\'inf\\') for i in range(n)]\\n        for i in range(n):\\n            \\n            for j in range(n):\\n                min_scores[j] = min(min_scores[j], ar[i][j])\\n            # We take the cost + rotations cost\\n            ans = min(ans, sum(min_scores)+(i*x))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        n = len(nums)\\n        ar = [[0]*n for i in range(n)]\\n        #ith row tells the element change after ith rotation\\n        #eg. ar[i][j] tells the jth elements of nums after i rotations\\n        for i in range(n):\\n            for j in range(n):\\n                ar[i][j] = nums[(j+i)%n]\\n        ans = float(\\'inf\\')\\n        \\n        #To keep track of the minimum after each round\\n        min_scores = [float(\\'inf\\') for i in range(n)]\\n        for i in range(n):\\n            \\n            for j in range(n):\\n                min_scores[j] = min(min_scores[j], ar[i][j])\\n            # We take the cost + rotations cost\\n            ans = min(ans, sum(min_scores)+(i*x))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097350,
                "title": "o-n-2-c-mindp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        long long int ans=LLONG_MAX;\\n        vector<long long int> minValArr(n,LLONG_MAX);\\n        for(int i=0;i<n;i++){\\n\\n            for(int j=0;j<n;j++){\\n\\n                int idx = i+j;\\n                idx%=n;\\n                minValArr[j] = min(minValArr[j], (long long int)nums[idx]);\\n            }\\n            long long int sum=0;\\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                sum+= minValArr[i];\\n            }\\n            ans = min (ans, (long long int)sum + (long long int)i*(long long int)x);\\n            \\n        }\\n        \\n       \\n        return ans;\\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        long long int ans=LLONG_MAX;\\n        vector<long long int> minValArr(n,LLONG_MAX);\\n        for(int i=0;i<n;i++){\\n\\n            for(int j=0;j<n;j++){\\n\\n                int idx = i+j;\\n                idx%=n;\\n                minValArr[j] = min(minValArr[j], (long long int)nums[idx]);\\n            }\\n            long long int sum=0;\\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                sum+= minValArr[i];\\n            }\\n            ans = min (ans, (long long int)sum + (long long int)i*(long long int)x);\\n            \\n        }\\n        \\n       \\n        return ans;\\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999917,
                "title": "2735-collecting-chocolates",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<int>v(nums.begin(),nums.end());\\n        long long ans=accumulate(v.begin(),v.end(),0LL);\\n        long long y=ans;\\n        for(int i=1;i<n;i++){\\n            rotate(nums.begin(),nums.begin()+1,nums.end());\\n            for(int j=0;j<n;j++){\\n                if(v[j]>nums[j]){\\n                    y-=v[j];\\n                    v[j]=nums[j];\\n                    y+=v[j];\\n                }\\n                long long sum=(long long)x*i+y;\\n                ans=min(ans,sum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<int>v(nums.begin(),nums.end());\\n        long long ans=accumulate(v.begin(),v.end(),0LL);\\n        long long y=ans;\\n        for(int i=1;i<n;i++){\\n            rotate(nums.begin(),nums.begin()+1,nums.end());\\n            for(int j=0;j<n;j++){\\n                if(v[j]>nums[j]){\\n                    y-=v[j];\\n                    v[j]=nums[j];\\n                    y+=v[j];\\n                }\\n                long long sum=(long long)x*i+y;\\n                ans=min(ans,sum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953163,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        vector<int> buffer(nums.begin(),nums.end());\\n        long long answer = accumulate(nums.begin(),nums.end(),0LL);\\n        for(int i =1;i<n;i++){\\n            for(int k=0;k<n;k++){\\n                buffer[k] = min(buffer[k],nums[(k+n-i)%n]);\\n            }\\n            answer = min(answer,accumulate(buffer.begin(),buffer.end(),0LL) + (long long)i*x);\\n        }\\n        \\n        return answer;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        vector<int> buffer(nums.begin(),nums.end());\\n        long long answer = accumulate(nums.begin(),nums.end(),0LL);\\n        for(int i =1;i<n;i++){\\n            for(int k=0;k<n;k++){\\n                buffer[k] = min(buffer[k],nums[(k+n-i)%n]);\\n            }\\n            answer = min(answer,accumulate(buffer.begin(),buffer.end(),0LL) + (long long)i*x);\\n        }\\n        \\n        return answer;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949250,
                "title": "easiest-solution-simple-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n\\n    long long minCost(vector<int>& nums, int x) {\\n        // map<int,int> min;\\n        int n=nums.size();\\n        vector<long long> mini(n,INT_MAX);\\n        long long ans=1e18;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                int ind=(i+j)%n;\\n                mini[j]=min(mini[j],1ll*nums[ind]);\\n            }\\n            long long sum=0;\\n            for(auto it:mini)sum+=it;\\n            ans=min(ans,1ll*i*x+sum);\\n            \\n        }\\n        \\n       \\n        return ans;\\n        // return func(nums,x,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\n    long long minCost(vector<int>& nums, int x) {\\n        // map<int,int> min;\\n        int n=nums.size();\\n        vector<long long> mini(n,INT_MAX);\\n        long long ans=1e18;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                int ind=(i+j)%n;\\n                mini[j]=min(mini[j],1ll*nums[ind]);\\n            }\\n            long long sum=0;\\n            for(auto it:mini)sum+=it;\\n            ans=min(ans,1ll*i*x+sum);\\n            \\n        }\\n        \\n       \\n        return ans;\\n        // return func(nums,x,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941954,
                "title": "golang-brute-force-solution",
                "content": "# Complexity\\n- Time complexity: O(n\\xB2)\\n- Space complexity: O(n)\\n\\n# Code\\n```go\\nfunc minCost(nums []int, x int) int64 {\\n\\tnumMinArray := make([]int, len(nums))\\n\\tcopy(numMinArray, nums)\\n\\tminCostVal := 0\\n\\tfor _, v := range nums {\\n\\t\\tminCostVal += v\\n\\t}\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tcurCostVal := i * x\\n\\t\\tnums = append(nums, nums[0])\\n\\t\\tnums = nums[1:]\\n\\t\\tfor i, v := range numMinArray {\\n\\t\\t\\tif nums[i] < v {\\n\\t\\t\\t\\tnumMinArray[i] = nums[i]\\n\\t\\t\\t}\\n\\t\\t\\tcurCostVal += numMinArray[i]\\n\\t\\t}\\n\\t\\tif curCostVal < minCostVal {\\n\\t\\t\\tminCostVal = curCostVal\\n\\t\\t}\\n\\t}\\n\\treturn int64(minCostVal)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minCost(nums []int, x int) int64 {\\n\\tnumMinArray := make([]int, len(nums))\\n\\tcopy(numMinArray, nums)\\n\\tminCostVal := 0\\n\\tfor _, v := range nums {\\n\\t\\tminCostVal += v\\n\\t}\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tcurCostVal := i * x\\n\\t\\tnums = append(nums, nums[0])\\n\\t\\tnums = nums[1:]\\n\\t\\tfor i, v := range numMinArray {\\n\\t\\t\\tif nums[i] < v {\\n\\t\\t\\t\\tnumMinArray[i] = nums[i]\\n\\t\\t\\t}\\n\\t\\t\\tcurCostVal += numMinArray[i]\\n\\t\\t}\\n\\t\\tif curCostVal < minCostVal {\\n\\t\\t\\tminCostVal = curCostVal\\n\\t\\t}\\n\\t}\\n\\treturn int64(minCostVal)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3867263,
                "title": "easy-to-get-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minCost(int[] nums, int x) {\\n        int n = nums.length;\\n        long sum = 0;\\n        long temp[] = new long[n];\\n\\n        for(int i = 0 ; i < nums.length ; i++){\\n            sum += nums[i];\\n            temp[i] = nums[i];\\n        }\\n\\n        for(int rotation = 1; rotation < n ; rotation++ ){\\n            long cost = 1L * rotation * x;\\n\\n            for(int i = 0 ; i < n ; i++){\\n                long val = nums[(rotation+i)% n];\\n                temp[i] = Math.min(temp[i],val);\\n                cost += temp[i];\\n            }\\n\\n            sum = Math.min(sum,cost);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minCost(int[] nums, int x) {\\n        int n = nums.length;\\n        long sum = 0;\\n        long temp[] = new long[n];\\n\\n        for(int i = 0 ; i < nums.length ; i++){\\n            sum += nums[i];\\n            temp[i] = nums[i];\\n        }\\n\\n        for(int rotation = 1; rotation < n ; rotation++ ){\\n            long cost = 1L * rotation * x;\\n\\n            for(int i = 0 ; i < n ; i++){\\n                long val = nums[(rotation+i)% n];\\n                temp[i] = Math.min(temp[i],val);\\n                cost += temp[i];\\n            }\\n\\n            sum = Math.min(sum,cost);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829329,
                "title": "sliding-window-sliding-window-maximum",
                "content": "~~~java\\nclass Solution {\\n    public long minCost(int[] nums, int x) {\\n        int n=nums.length;\\n        int [] copy = new int [2*n];\\n        for(int i=0;i<2*n;i++) copy[i] = nums[i%n];\\n        \\n        Stack<Integer> sc = new Stack<>();\\n        sc.push(n-1);\\n        int [] min_indx = new int [2*n];\\n        min_indx[copy.length-1] = copy.length;\\n        for(int i=copy.length-2;i>=0;i--){\\n            while(sc.size()>0 && copy[sc.peek()]>=copy[i]) sc.pop();\\n            if(sc.size()==0) min_indx[i] = copy.length;\\n            else min_indx[i] = sc.peek();\\n            sc.push(i);\\n        }\\n        \\n\\n        long ans = Long.MAX_VALUE;\\n        for(int window = 1; window<=n;window++){\\n            long internal = Long.MAX_VALUE;\\n            internal = 1l* (window-1)* x;\\n            int k = window;\\n            int j=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(j<i) j=i;\\n                while(j<min_indx.length && min_indx[j]<=i+k-1) j=min_indx[j];\\n                internal+=copy[j];\\n            }\\n            ans = Math.min(ans, internal);\\n        }\\n        \\n        return ans;\\n    }\\n\\n}",
                "solutionTags": [
                    "Stack",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n    public long minCost(int[] nums, int x) {\\n        int n=nums.length;\\n        int [] copy = new int [2*n];\\n        for(int i=0;i<2*n;i++) copy[i] = nums[i%n];\\n        \\n        Stack<Integer> sc = new Stack<>();\\n        sc.push(n-1);\\n        int [] min_indx = new int [2*n];\\n        min_indx[copy.length-1] = copy.length;\\n        for(int i=copy.length-2;i>=0;i--){\\n            while(sc.size()>0 && copy[sc.peek()]>=copy[i]) sc.pop();\\n            if(sc.size()==0) min_indx[i] = copy.length;\\n            else min_indx[i] = sc.peek();\\n            sc.push(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3798114,
                "title": "c-dynamic-programming",
                "content": "# Intuition\\nWe need to check all posibilities after moving an element.\\nMax number of moves = number of elements in nums.\\nDP hold min value of chocolate type (based on index).\\n\\n# Complexity\\n- Time complexity:\\nO(N*N) -> N = number of elements in nums.\\n\\n- Space complexity:\\nO(N) -> N = number of elements in nums. Required for dp \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int sz = nums.size();\\n        vector<int> dp(nums.begin(),nums.end());\\n        long long ans=LLONG_MAX,cur=0;\\n\\n        for (int i=0;i<sz;i++){\\n            cur=0;\\n            for(int j=0;j<sz;j++){\\n                if (dp[j]>nums[(j+sz-i)%sz]) dp[j]= nums[(j+sz-i)%sz];\\n                cur += dp[j];\\n            }\\n            ans = min(ans,cur+1LL*x*i);\\n            //cout << \"Iteratui: \" << i << \" ans:\" << ans << endl;\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int sz = nums.size();\\n        vector<int> dp(nums.begin(),nums.end());\\n        long long ans=LLONG_MAX,cur=0;\\n\\n        for (int i=0;i<sz;i++){\\n            cur=0;\\n            for(int j=0;j<sz;j++){\\n                if (dp[j]>nums[(j+sz-i)%sz]) dp[j]= nums[(j+sz-i)%sz];\\n                cur += dp[j];\\n            }\\n            ans = min(ans,cur+1LL*x*i);\\n            //cout << \"Iteratui: \" << i << \" ans:\" << ans << endl;\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3797169,
                "title": "kotlin-o-n-2",
                "content": "# Intuition\\nPerforming an operation is the same as changing the price of the ith chocolate to the price of the i+1 ith chocolate.\\n\\nFor n chocolates, you can at most rotate the prices n - 1 times.\\n\\nSimulate the n - 1 rotations while tracking of each chocolate\\'s best purchase to easily compute the results of the next rotation (effectively dp, where dp[0] is the best prices after 0 rotation)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n^2)$$\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\n    fun minCost(nums: IntArray, x: Int): Long {\\n        val purchasePrice = nums.map { it.toLong() }.toMutableList()\\n        var min = Long.MAX_VALUE\\n        for (operations in 0 until nums.size) {\\n            for (chocolate in nums.indices) {\\n                purchasePrice[chocolate] = minOf(purchasePrice[chocolate], nums[(chocolate+operations)%nums.size].toLong())\\n            }\\n            min = minOf(min, purchasePrice.sum().toLong() + operations * x.toLong())\\n        }\\n        return min\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    fun minCost(nums: IntArray, x: Int): Long {\\n        val purchasePrice = nums.map { it.toLong() }.toMutableList()\\n        var min = Long.MAX_VALUE\\n        for (operations in 0 until nums.size) {\\n            for (chocolate in nums.indices) {\\n                purchasePrice[chocolate] = minOf(purchasePrice[chocolate], nums[(chocolate+operations)%nums.size].toLong())\\n            }\\n            min = minOf(min, purchasePrice.sum().toLong() + operations * x.toLong())\\n        }\\n        return min\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758973,
                "title": "c-tricky-not-hard",
                "content": "# Complexity\\n- Time complexity:\\nO(N*N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        long long ans = accumulate(nums.begin(),nums.end(),0ll);\\n        int len = nums.size();\\n        long long count=1;\\n        vector<int> minVal(nums.begin(),nums.end());\\n        for(int i=0;i<len-1;i++){\\n            int last = nums[len-1];\\n            nums.pop_back();\\n            nums.insert(nums.begin(),last);\\n            for(int i=0;i<len;i++) minVal[i] = min(minVal[i],nums[i]);\\n            long long sum =(count*x)+accumulate(minVal.begin(),minVal.end(),0ll);\\n            if(sum<ans) ans = sum;\\n            count++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        long long ans = accumulate(nums.begin(),nums.end(),0ll);\\n        int len = nums.size();\\n        long long count=1;\\n        vector<int> minVal(nums.begin(),nums.end());\\n        for(int i=0;i<len-1;i++){\\n            int last = nums[len-1];\\n            nums.pop_back();\\n            nums.insert(nums.begin(),last);\\n            for(int i=0;i<len;i++) minVal[i] = min(minVal[i],nums[i]);\\n            long long sum =(count*x)+accumulate(minVal.begin(),minVal.end(),0ll);\\n            if(sum<ans) ans = sum;\\n            count++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751106,
                "title": "c-o-n-2-code",
                "content": "# Complexity\\n- Time complexity:\\n  O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n  O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int> &nums, int x) {\\n        vector<int> dp = nums;\\n        long long ans = accumulate(nums.begin(), nums.end(), 0ll);\\n        for (int i = 1; i < nums.size(); ++i) {\\n            for (int j = 0; j < nums.size(); ++j) {\\n                dp[j] = min(nums[(j + i) % nums.size()], dp[j]);\\n            }\\n            long long tmp = accumulate(dp.begin(), dp.end(), x * 1ll * i);\\n            ans = min(ans, tmp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int> &nums, int x) {\\n        vector<int> dp = nums;\\n        long long ans = accumulate(nums.begin(), nums.end(), 0ll);\\n        for (int i = 1; i < nums.size(); ++i) {\\n            for (int j = 0; j < nums.size(); ++j) {\\n                dp[j] = min(nums[(j + i) % nums.size()], dp[j]);\\n            }\\n            long long tmp = accumulate(dp.begin(), dp.end(), x * 1ll * i);\\n            ans = min(ans, tmp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739545,
                "title": "python-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince the length of Nums is less than 1000, we can use a simulation approach. Each chocolate has an initial price, and we rotate the array to determine the total cost we save by cutting off chocolates. We then compare this cost to the cost of rotation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBased on the aforementioned intuition, we have devised the following algorithm. During the implementation, we maintain a current array to record the minimum cost we accept. We use the \"ans\" variable to store the additional cost incurred by the rotations, and the \"count\" variable is used to track the cost of the accepted rotations. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        current = nums[:]\\n        n = len(nums)\\n        ans = 0\\n        cost = 0\\n        for i in range(1, n):\\n            cost += x\\n            bias = i\\n            count = 0\\n            for j in range(n):\\n                if nums[(j + bias) % n] < current[j]:\\n                    count += current[j] - nums[(j + bias) % n]\\n            if count >= cost:\\n                ans += cost \\n                cost = 0\\n                for j in range(n):\\n                    if nums[(j + bias) % n] < current[j]:\\n                        current[j] = nums[(j + bias) % n]\\n        return ans + sum(current)\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        current = nums[:]\\n        n = len(nums)\\n        ans = 0\\n        cost = 0\\n        for i in range(1, n):\\n            cost += x\\n            bias = i\\n            count = 0\\n            for j in range(n):\\n                if nums[(j + bias) % n] < current[j]:\\n                    count += current[j] - nums[(j + bias) % n]\\n            if count >= cost:\\n                ans += cost \\n                cost = 0\\n                for j in range(n):\\n                    if nums[(j + bias) % n] < current[j]:\\n                        current[j] = nums[(j + bias) % n]\\n        return ans + sum(current)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736779,
                "title": "c-rotate",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n    long long ans = 1e16;\\n    vector<int> checked(nums.size(), 1e9) ,rotate;\\n    for(auto n: nums) rotate.push_back(n);\\n    for(auto n: nums) rotate.push_back(n);\\n    for(int i = 0; i < nums.size();i++){\\n        long long sum = 0;\\n        for(int j = 0; j < nums.size();j++){\\n            checked[j] = min(checked[j], rotate[i+j]);\\n            sum += checked[j];\\n        }\\n        sum +=(long)i*(long)x;\\n        ans = min(ans, sum);\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n    long long ans = 1e16;\\n    vector<int> checked(nums.size(), 1e9) ,rotate;\\n    for(auto n: nums) rotate.push_back(n);\\n    for(auto n: nums) rotate.push_back(n);\\n    for(int i = 0; i < nums.size();i++){\\n        long long sum = 0;\\n        for(int j = 0; j < nums.size();j++){\\n            checked[j] = min(checked[j], rotate[i+j]);\\n            sum += checked[j];\\n        }\\n        sum +=(long)i*(long)x;\\n        ans = min(ans, sum);\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693634,
                "title": "brute-force-very-easy-to-understand-o-n-2",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe do not need to do more than n-1 operations as doing so will make the array as the initial array.\\nsince the constraints are low we can do $$O(n^2)$$ algorithm.\\narr[x][y] in my solution represents the minimum value the xth chocolate can have if we have done y number of operations.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        \\n        int n = nums.size();\\n        \\n        vector<vector<int>> arr(n,vector<int>(n));\\n        \\n        // calculating for every chocolate\\n        for(int i = 0; i<n ;i++){\\n            int id = i;\\n            int cnt = 0;\\n            int mn = INT_MAX;\\n            // finding the minimum for every possible number of      \\n            // operations\\n            while(cnt<n){\\n                id = (id+n)%n;\\n                mn = min(mn,nums[id]);\\n                // updating the value for ith chocolate\\n                // with cnt number of operations done\\n                arr[i][cnt] = mn;\\n                id--;\\n                cnt++;\\n            }\\n            \\n        }\\n        \\n        long long ans = LLONG_MAX;\\n        \\n        for(int i = 0;i<n;i++){\\n            long long sum = (long long)x*i; // cost of i number\\n                                            // of operations\\n            for(int j = 0;j<n;j++){\\n                sum += arr[j][i];\\n            }\\n            ans = min(sum,ans);\\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        \\n        int n = nums.size();\\n        \\n        vector<vector<int>> arr(n,vector<int>(n));\\n        \\n        // calculating for every chocolate\\n        for(int i = 0; i<n ;i++){\\n            int id = i;\\n            int cnt = 0;\\n            int mn = INT_MAX;\\n            // finding the minimum for every possible number of      \\n            // operations\\n            while(cnt<n){\\n                id = (id+n)%n;\\n                mn = min(mn,nums[id]);\\n                // updating the value for ith chocolate\\n                // with cnt number of operations done\\n                arr[i][cnt] = mn;\\n                id--;\\n                cnt++;\\n            }\\n            \\n        }\\n        \\n        long long ans = LLONG_MAX;\\n        \\n        for(int i = 0;i<n;i++){\\n            long long sum = (long long)x*i; // cost of i number\\n                                            // of operations\\n            for(int j = 0;j<n;j++){\\n                sum += arr[j][i];\\n            }\\n            ans = min(sum,ans);\\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679448,
                "title": "simple-solution-pre-array-explained-solution",
                "content": "# Intuition\\nIn this problem for each index we have to find its minimum cost but we have to also consider that after every rotation x will be added to whole cost not each array , so this part is little tricky;\\n\\n# Approach\\nSo what we can do is that we will make a temporary vector temp and in that we will store what previous cost we have taken for each index and after each rotation we will compare our increased maincost to new which we can get. And we are done :)\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size(), rot = 1 ;\\n        \\n        // initializing cost\\n        long long cost = 1e18 ;\\n\\n        // getting sum of vector for condition if we take all chocolates without any rotation\\n        long long maincost=accumulate(nums.begin() , nums.end(),0L);\\n\\n        // getting minimum cost for first case\\n        cost = min(cost, maincost);\\n\\n        // A temp vector to store previous value taken of each index\\n        vector<int>temp = nums;\\n\\n        // we will go till n rotations\\n        while(rot != n){\\n            maincost += x;\\n            for(int i = 0;i<n;i++){\\n\\n                // checking if we can get less new maincost\\n                if(maincost > maincost + nums[(i+rot)%n] - temp[i]){\\n\\n                    //adding new cost to each index and subtracting previous one to avoid multiple addition\\n                    maincost += nums[(i+rot)%n] - temp[i];\\n\\n                    // updating previous cost of each index\\n                    temp[i] = nums[(i+rot)%n];\\n                }\\n            }\\n            rot++;\\n            cost = min(cost, maincost);\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size(), rot = 1 ;\\n        \\n        // initializing cost\\n        long long cost = 1e18 ;\\n\\n        // getting sum of vector for condition if we take all chocolates without any rotation\\n        long long maincost=accumulate(nums.begin() , nums.end(),0L);\\n\\n        // getting minimum cost for first case\\n        cost = min(cost, maincost);\\n\\n        // A temp vector to store previous value taken of each index\\n        vector<int>temp = nums;\\n\\n        // we will go till n rotations\\n        while(rot != n){\\n            maincost += x;\\n            for(int i = 0;i<n;i++){\\n\\n                // checking if we can get less new maincost\\n                if(maincost > maincost + nums[(i+rot)%n] - temp[i]){\\n\\n                    //adding new cost to each index and subtracting previous one to avoid multiple addition\\n                    maincost += nums[(i+rot)%n] - temp[i];\\n\\n                    // updating previous cost of each index\\n                    temp[i] = nums[(i+rot)%n];\\n                }\\n            }\\n            rot++;\\n            cost = min(cost, maincost);\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677362,
                "title": "maximum-of-all-subarrays-of-size-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMaximum element in a lenght of k subarry.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTry for all  0 To N-1 Moves and check maximum elemnt .\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        long long ans=1e18;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            long long currans=0;\\n            int j=0;\\n            deque<int>dq;\\n             while(j<=i){\\n                 if(dq.empty()||dq.back()<=nums[j%n]){\\n                    dq.push_back(nums[j%n]);\\n                    j++;\\n                    continue;\\n                }\\n                while(!dq.empty()&&dq.back()>nums[j%n])dq.pop_back();\\n                dq.push_back(nums[j]);\\n                j++;\\n            }\\n            currans+=dq.front();\\n            int k=0;\\n            while(j<n+i){\\n                if(nums[k++]==dq.front())dq.pop_front();\\n                if(dq.empty()||dq.back()<=nums[j%n]){\\n                    dq.push_back(nums[j%n]);\\n                     currans+=dq.front();\\n                     j++;\\n                     continue;\\n                }\\n                while(!dq.empty()&&dq.back()>nums[j%n])dq.pop_back();\\n                dq.push_back(nums[j%n]);\\n                currans+=dq.front();\\n                j++;\\n            }\\n            currans+=(long long)i*x;\\n            ans=min(ans,currans);\\n        }\\n        return ans;\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        long long ans=1e18;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            long long currans=0;\\n            int j=0;\\n            deque<int>dq;\\n             while(j<=i){\\n                 if(dq.empty()||dq.back()<=nums[j%n]){\\n                    dq.push_back(nums[j%n]);\\n                    j++;\\n                    continue;\\n                }\\n                while(!dq.empty()&&dq.back()>nums[j%n])dq.pop_back();\\n                dq.push_back(nums[j]);\\n                j++;\\n            }\\n            currans+=dq.front();\\n            int k=0;\\n            while(j<n+i){\\n                if(nums[k++]==dq.front())dq.pop_front();\\n                if(dq.empty()||dq.back()<=nums[j%n]){\\n                    dq.push_back(nums[j%n]);\\n                     currans+=dq.front();\\n                     j++;\\n                     continue;\\n                }\\n                while(!dq.empty()&&dq.back()>nums[j%n])dq.pop_back();\\n                dq.push_back(nums[j%n]);\\n                currans+=dq.front();\\n                j++;\\n            }\\n            currans+=(long long)i*x;\\n            ans=min(ans,currans);\\n        }\\n        return ans;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675541,
                "title": "easy-to-understand-python-3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe should think of this as greedily checking the total cost after we do 0 to N rotations.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we know that we can always just take everything at their initial cost and do no rotation. Cost is sum(nums).\\n\\nAs we do more rotations, we always encounter a new type at each index since we\\'re adding 1 before taking mod.\\n\\nThe cost after each round is rd*x, plus the sum of the cost for each type. Since we want the lowest total cost, we look for the lowest cost for each type, which can occur at any round after we rotate so we need to keep track of the lowest cost for each type after each round.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        n = len(nums)\\n        costs = [c for c in nums]\\n        types = [i for i in range(n)]\\n        lowest = sum(costs)\\n        \\n        for rd in range(1,n):\\n            # apply changes\\n            for i in range(n):\\n                types[i]=(types[i]+1)%n\\n                \\n            # get the lower cost after type change\\n            for i, typ in enumerate(types):\\n                costs[typ] = min(costs[typ], nums[i]) # the typ_th type now has the original i_th cost\\n            \\n            lowest = min(lowest, sum(costs)+x*rd)\\n        \\n        return lowest\\n                \\n                    \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        n = len(nums)\\n        costs = [c for c in nums]\\n        types = [i for i in range(n)]\\n        lowest = sum(costs)\\n        \\n        for rd in range(1,n):\\n            # apply changes\\n            for i in range(n):\\n                types[i]=(types[i]+1)%n\\n                \\n            # get the lower cost after type change\\n            for i, typ in enumerate(types):\\n                costs[typ] = min(costs[typ], nums[i]) # the typ_th type now has the original i_th cost\\n            \\n            lowest = min(lowest, sum(costs)+x*rd)\\n        \\n        return lowest\\n                \\n                    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668004,
                "title": "simple-solution",
                "content": "# Intuition\\nFor understanding the intuition please see the youtube solution of Aryan Mittal.\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        vector<int>checked(nums.size(), INT_MAX);\\n        vector<int>cnum(nums.begin(), nums.end());\\n\\n        for(auto x: nums) cnum.push_back(x);\\n\\n        long long ans = LONG_MAX;\\n\\n        for(int rot = 0; rot < nums.size(); rot++){\\n            long long sum = 0;\\n            for(int i = 0; i<nums.size(); i++){\\n                if(checked[i] > cnum[rot + i]) checked[i] = cnum[rot + i];\\n                sum += checked[i];\\n            }\\n            sum += (long long)rot * (long long)x;\\n            ans = min(ans, sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        vector<int>checked(nums.size(), INT_MAX);\\n        vector<int>cnum(nums.begin(), nums.end());\\n\\n        for(auto x: nums) cnum.push_back(x);\\n\\n        long long ans = LONG_MAX;\\n\\n        for(int rot = 0; rot < nums.size(); rot++){\\n            long long sum = 0;\\n            for(int i = 0; i<nums.size(); i++){\\n                if(checked[i] > cnum[rot + i]) checked[i] = cnum[rot + i];\\n                sum += checked[i];\\n            }\\n            sum += (long long)rot * (long long)x;\\n            ans = min(ans, sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666885,
                "title": "c-solution-o-n-n-solution-faster-and-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        long long ans = LLONG_MAX;\\n        \\n        vector<int> minCost(n,INT_MAX);\\n        for(int i=0;i<n;i++){\\n            long long sum = (x*1LL*i);\\n\\n            for(int j=0;j<n;j++){\\n                minCost[j] = min(minCost[j],nums[(i - j + n)%n]);\\n                sum += minCost[j];\\n            }\\n\\n            ans = min(ans,sum);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        long long ans = LLONG_MAX;\\n        \\n        vector<int> minCost(n,INT_MAX);\\n        for(int i=0;i<n;i++){\\n            long long sum = (x*1LL*i);\\n\\n            for(int j=0;j<n;j++){\\n                minCost[j] = min(minCost[j],nums[(i - j + n)%n]);\\n                sum += minCost[j];\\n            }\\n\\n            ans = min(ans,sum);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665119,
                "title": "python-brute-force-o-n-2",
                "content": "1. Since `1 <= nums.length <= 1000`, we could compute the answer simply.\\n2. Assume that we can make at most `move` shifts. \\nCheck all types one by one without considering the cost of making shifts. After finishing this, just sum up the cost so far and add `move*x` to it, the sum would be the minimal cost with at most `move` shifts.\\n3. For each `move`, compute the sum described above and compare with `ans`.\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        N = len(nums)\\n        arr = nums.copy()\\n        ans = sum(nums)\\n        for move in range(1, N):\\n            for i in range(N):\\n                p = nums[(i-move)%N]\\n                if p < arr[i]:\\n                    arr[i] = p\\n            ans = min(ans, sum(arr) + move*x)\\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "1. Since `1 <= nums.length <= 1000`, we could compute the answer simply.\\n2. Assume that we can make at most `move` shifts. \\nCheck all types one by one without considering the cost of making shifts. After finishing this, just sum up the cost so far and add `move*x` to it, the sum would be the minimal cost with at most `move` shifts.\\n3. For each `move`, compute the sum described above and compare with `ans`.\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        N = len(nums)\\n        arr = nums.copy()\\n        ans = sum(nums)\\n        for move in range(1, N):\\n            for i in range(N):\\n                p = nums[(i-move)%N]\\n                if p < arr[i]:\\n                    arr[i] = p\\n            ans = min(ans, sum(arr) + move*x)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 3664754,
                "title": "c-simple-solution",
                "content": "# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) \\n    {\\n        int n=nums.size();\\n        vector<vector<ll>>cost(n,vector<ll>(n,0));\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                cost[i][j]=nums[(i+j)%n];\\n                if(j!=0)cost[i][j]=min(cost[i][j],cost[i][j-1]);\\n            }\\n        ll res=LLONG_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            ll tot=1ll*i*x;\\n            for(int j=0;j<n;j++)tot+=cost[j][i];\\n            res=min(tot,res);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) \\n    {\\n        int n=nums.size();\\n        vector<vector<ll>>cost(n,vector<ll>(n,0));\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                cost[i][j]=nums[(i+j)%n];\\n                if(j!=0)cost[i][j]=min(cost[i][j],cost[i][j-1]);\\n            }\\n        ll res=LLONG_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            ll tot=1ll*i*x;\\n            for(int j=0;j<n;j++)tot+=cost[j][i];\\n            res=min(tot,res);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655870,
                "title": "c-brute-force-go-for-each-rotation-and-store",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Check for each rotation possible and store a minimum possible for each index i from 0 to current rotation \\n\\n# Complexity\\n- Time complexity: $$O(N*N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        // curr_x<cost kardo\\n        int n=nums.size();\\n        long long ans=0;\\n        vector<long long> mi(n);\\n\\n        for(int i=0;i<n;i++){\\n            mi[i]=nums[i];\\n            ans+=mi[i];\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            long long cost=i*(long long)(x);\\n\\n            for(int j=0;j<n;j++){\\n                long long val=nums[(j+i)%n];\\n                mi[j]=min(mi[j],val);\\n                cost+=mi[j];\\n            }\\n\\n            ans=min(ans,cost);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        // curr_x<cost kardo\\n        int n=nums.size();\\n        long long ans=0;\\n        vector<long long> mi(n);\\n\\n        for(int i=0;i<n;i++){\\n            mi[i]=nums[i];\\n            ans+=mi[i];\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            long long cost=i*(long long)(x);\\n\\n            for(int j=0;j<n;j++){\\n                long long val=nums[(j+i)%n];\\n                mi[j]=min(mi[j],val);\\n                cost+=mi[j];\\n            }\\n\\n            ans=min(ans,cost);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642339,
                "title": "very-easy-order-of-n-2-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs we know that we can perform maximum n number of operations as if more than n number of operations we come back to same observation.\\nThen we start performing operations from 0 to n-1 times. We store minimum cost for every index with respect to number of operations.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long minCost(int[] nums, int x) {\\n        long ans = Long.MAX_VALUE;\\n        int n = nums.length;\\n        int mincost[] = new int[n];\\n        Arrays.fill(mincost,Integer.MAX_VALUE);\\n        for(int i = 0 ; i < n ;i++){\\n            // This is number of operations loop\\n            long sum = 1L*x*i;\\n            for(int j = 0 ; j < n ;j++){\\n                mincost[j] = Math.min(mincost[j],nums[(i-j+n)%n]);\\n                sum += mincost[j];\\n            }\\n            ans = Math.min(ans,sum);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minCost(int[] nums, int x) {\\n        long ans = Long.MAX_VALUE;\\n        int n = nums.length;\\n        int mincost[] = new int[n];\\n        Arrays.fill(mincost,Integer.MAX_VALUE);\\n        for(int i = 0 ; i < n ;i++){\\n            // This is number of operations loop\\n            long sum = 1L*x*i;\\n            for(int j = 0 ; j < n ;j++){\\n                mincost[j] = Math.min(mincost[j],nums[(i-j+n)%n]);\\n                sum += mincost[j];\\n            }\\n            ans = Math.min(ans,sum);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642124,
                "title": "ruby-solution-with-explanation-100-100",
                "content": "# Intuition\\nKeep track of the lowest price so far for each chocolate while trying every number of rotations.\\n\\n# Approach\\n1. Create a copy of nums that represents the lowest price of a chocolate so far.  (Right now it\\'s a copy, but after e.g., 3 rotations, it will give the lowest price you can buy that chocolate for.)\\n2. Initialize min to be the sum of arr.\\n3. Perform one rotation, up until n.  At each rotation:\\n    - Find the total cost of all rotations so far\\n    - Check if any of the chocolates now have a lower price\\n    - Add the new min prices to the cost and see if it\\'s less than min\\n4. Return min\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\ndef min_cost(nums, x)\\n    n = nums.length\\n    arr = nums.dup\\n    min = arr.sum\\n\\n    (1...n).each do |i|\\n        cost = i * x\\n        (0...n).each { |j| arr[j] = nums[j-i] if nums[j-i] < arr[j] }\\n\\n        min = [min,arr.sum + cost].min\\n    end\\n\\n    min\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef min_cost(nums, x)\\n    n = nums.length\\n    arr = nums.dup\\n    min = arr.sum\\n\\n    (1...n).each do |i|\\n        cost = i * x\\n        (0...n).each { |j| arr[j] = nums[j-i] if nums[j-i] < arr[j] }\\n\\n        min = [min,arr.sum + cost].min\\n    end\\n\\n    min\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3641820,
                "title": "c-chocolates-matrix-representation-best-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ndont change the indices , change the elment position in the form of matrix\\n* used ( 20 1 15 ) to ( 1 15 20 ) and check which has smaller cost\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\niterate over the matrix and maintain the col array of min cost position \\nand calculate cost in cans and update to rans for every row\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        \\n       // main intitution is that instead of converting indices convert the elements\\n        int n = nums.size();\\n        vector<vector<int>> v(n,vector<int> (n,0));\\n        for(int i =0 ;i<n ;i++)\\n            v[0][i] = nums[i];\\n        \\n        for(int i =1 ;i<n ;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(j == n-1)\\n                    v[i][j] = v[i-1][0];\\n                else\\n                    v[i][j] = v[i-1][j+1];\\n            }\\n        }\\n\\n        vector<int> col(n,0);\\n        long long ans=0;\\n        for(int j=0;j<n;j++)\\n        {\\n            col[j]=v[0][j];\\n            ans+=(long long)v[0][j];\\n        }\\n\\n        long long rans = ans;\\n        for(int i=1;i<n;i++)\\n        {\\n            long long cans=ans;\\n            cans+=(long long )x;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(v[i][j] < col[j])\\n                {\\n                    cans-=col[j];\\n                    col[j]=v[i][j];\\n                    cans+=col[j];\\n                }\\n            }\\n            rans=min(cans,rans);\\n            ans = cans;\\n        }\\n        return rans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        \\n       // main intitution is that instead of converting indices convert the elements\\n        int n = nums.size();\\n        vector<vector<int>> v(n,vector<int> (n,0));\\n        for(int i =0 ;i<n ;i++)\\n            v[0][i] = nums[i];\\n        \\n        for(int i =1 ;i<n ;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(j == n-1)\\n                    v[i][j] = v[i-1][0];\\n                else\\n                    v[i][j] = v[i-1][j+1];\\n            }\\n        }\\n\\n        vector<int> col(n,0);\\n        long long ans=0;\\n        for(int j=0;j<n;j++)\\n        {\\n            col[j]=v[0][j];\\n            ans+=(long long)v[0][j];\\n        }\\n\\n        long long rans = ans;\\n        for(int i=1;i<n;i++)\\n        {\\n            long long cans=ans;\\n            cans+=(long long )x;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(v[i][j] < col[j])\\n                {\\n                    cans-=col[j];\\n                    col[j]=v[i][j];\\n                    cans+=col[j];\\n                }\\n            }\\n            rans=min(cans,rans);\\n            ans = cans;\\n        }\\n        return rans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639902,
                "title": "c-calculate-min-cost-for-each-operation-up-to-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDidn\\'t solved this problem myself. Thought that it can be solved by recursion, calculating each possible min cost, but hard to implement. It\\'s interesting approach of shifting problem that can be solved by accumulating for each operation min cost.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- **`var res = new long[N];`** Store min cost for each operation up to `N`. So, initially we can store for each operation `i = (0,1,2..,N), res[i] = x*i` cost\\n\\n- **`Outer loop, for (int i = 0; i < N; i++)`** First initialize `res[i]`, `i*x` cost for `i` operation. Then use `cur=nums[i]` element as starting point. \\n\\n- **`Inner lopp, for (int k = 0; k < N; k++)`** Then for each `cur` item calculate min cost for each shift to left `min(nums[i], nums[i - 1], ..., nums[i - k])` and add it for each shift `result[k]`.\\n- Finally return `min` result from all shift operations\\n\\n\\n# Complexity\\n- Time complexity:$$O(N^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n\\n    public long MinCost(int[] nums, int x) {\\n        int N = nums.Length;\\n        var res = new long[N];\\n\\n        for (int i = 0; i < N; i++) {\\n            res[i] += i * (long)x;\\n            int cur = nums[i];\\n\\n            for (int k = 0; k < N; k++) {\\n                cur = Math.Min(cur, nums[(i - k + N) % N]);\\n                res[k] += cur;\\n            }\\n        }\\n\\n        return res.Min();\\n    }\\n\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n\\n    public long MinCost(int[] nums, int x) {\\n        int N = nums.Length;\\n        var res = new long[N];\\n\\n        for (int i = 0; i < N; i++) {\\n            res[i] += i * (long)x;\\n            int cur = nums[i];\\n\\n            for (int k = 0; k < N; k++) {\\n                cur = Math.Min(cur, nums[(i - k + N) % N]);\\n                res[k] += cur;\\n            }\\n        }\\n\\n        return res.Min();\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639034,
                "title": "javascript-keep-rotating",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} x\\n * @return {number}\\n */\\nvar minCost = function (nums, x) {\\n  let ans = Infinity;\\n  const n = nums.length;\\n  const minCost = new Array(n).fill(Infinity);\\n\\n  for (let i = 0; i < n; i++) {\\n    let totalCost = 0;\\n    for (let j = 0; j < n; j++) {\\n      const nj = (i + j) % n;\\n      minCost[nj] = Math.min(minCost[nj], nums[j]);\\n      totalCost += minCost[nj];\\n    }\\n    totalCost += i * x;\\n    ans = Math.min(ans, totalCost);\\n  }\\n\\n  return ans;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} x\\n * @return {number}\\n */\\nvar minCost = function (nums, x) {\\n  let ans = Infinity;\\n  const n = nums.length;\\n  const minCost = new Array(n).fill(Infinity);\\n\\n  for (let i = 0; i < n; i++) {\\n    let totalCost = 0;\\n    for (let j = 0; j < n; j++) {\\n      const nj = (i + j) % n;\\n      minCost[nj] = Math.min(minCost[nj], nums[j]);\\n      totalCost += minCost[nj];\\n    }\\n    totalCost += i * x;\\n    ans = Math.min(ans, totalCost);\\n  }\\n\\n  return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3638930,
                "title": "c-faster-than-95",
                "content": "# Intuition\\nCalculate the result for each shift between 0 and len(nums).\\n\\n# Approach\\nAt first get the initial result as a sum of all items in array nums:\\n```\\nvar rs = InitResult(nums);\\n```\\nThen create a copy of array nums:\\n```\\nvar aux = CreateAux(nums);\\n```\\nFinally calculate the best result for each shift int interval [1, len(nums)[:\\n```\\nfor (int shift = 1; shift < nums.Length; shift++)\\n{\\n    var rs0 = shift * (long)x;\\n    for (int j = 0; j < aux.Length; j++)\\n    {\\n        var index = j - shift;\\n        if (index < 0) index += aux.Length;\\n        aux[j] = Math.Min(aux[j], nums[index]);\\n        rs0 += aux[j];\\n    }\\n    if (rs > rs0) rs = rs0;\\n}\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(len(nums)^2)$$\\n\\n- Space complexity:\\n$$O(len(nums))$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MinCost(int[] nums, int x) {\\n        var rs = InitResult(nums);\\n        var aux = CreateAux(nums);\\n        for (int shift = 1; shift < nums.Length; shift++)\\n        {\\n            var rs0 = shift * (long)x;\\n            for (int j = 0; j < aux.Length; j++)\\n            {\\n                var index = j - shift;\\n                if (index < 0) index += aux.Length;\\n                aux[j] = Math.Min(aux[j], nums[index]);\\n                rs0 += aux[j];\\n            }\\n            if (rs > rs0) rs = rs0;\\n        }\\n        return rs;\\n    }\\n    private long InitResult(int[] nums)\\n    {\\n        var rs = 0L;\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            rs += nums[i];\\n        }\\n        return rs;\\n    }\\n    private int[] CreateAux(int[] nums)\\n    {\\n        var rs = new int[nums.Length];\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            rs[i] = nums[i];\\n        }\\n        return rs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nvar rs = InitResult(nums);\\n```\n```\\nvar aux = CreateAux(nums);\\n```\n```\\nfor (int shift = 1; shift < nums.Length; shift++)\\n{\\n    var rs0 = shift * (long)x;\\n    for (int j = 0; j < aux.Length; j++)\\n    {\\n        var index = j - shift;\\n        if (index < 0) index += aux.Length;\\n        aux[j] = Math.Min(aux[j], nums[index]);\\n        rs0 += aux[j];\\n    }\\n    if (rs > rs0) rs = rs0;\\n}\\n```\n```\\npublic class Solution {\\n    public long MinCost(int[] nums, int x) {\\n        var rs = InitResult(nums);\\n        var aux = CreateAux(nums);\\n        for (int shift = 1; shift < nums.Length; shift++)\\n        {\\n            var rs0 = shift * (long)x;\\n            for (int j = 0; j < aux.Length; j++)\\n            {\\n                var index = j - shift;\\n                if (index < 0) index += aux.Length;\\n                aux[j] = Math.Min(aux[j], nums[index]);\\n                rs0 += aux[j];\\n            }\\n            if (rs > rs0) rs = rs0;\\n        }\\n        return rs;\\n    }\\n    private long InitResult(int[] nums)\\n    {\\n        var rs = 0L;\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            rs += nums[i];\\n        }\\n        return rs;\\n    }\\n    private int[] CreateAux(int[] nums)\\n    {\\n        var rs = new int[nums.Length];\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            rs[i] = nums[i];\\n        }\\n        return rs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638690,
                "title": "easy-c-solution-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // TC : O(N^2)\\n    // SC : O(N)\\n\\n    // a function to RIGHT shift the array by one\\n    void shift (vector<int>& nums){\\n        int n = nums.size();\\n        int last = nums[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            nums[i+1] = nums[i];\\n        }\\n        nums[0] = last;\\n    }\\n\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        // an extra array to store the minCost of each chocolate\\n        vector<int> minCost(n, 0);\\n\\n        // initially answer is 0 and we are gonna check whether the \\n        // intial array configuration is our answer\\n        // by adding the elements in answer\\n        long long answer = 0;\\n        for(int i=0; i<n; i++){\\n            minCost[i] = nums[i];\\n            answer += minCost[i];\\n        }\\n\\n        // for an array of size n we can have at max n-1 operations\\n        // after that we will be at our initial configuration or array\\n\\n        // going to each operation by shifting the array\\n        for(int op=0; op<n; op++){\\n\\n            // say if we shift our array x times then the total\\n            // operationCost will be (op+1)*x\\n            // why ? let\\'s understand\\n            // say i shifted my array one time : cost to be added is X\\n            // now if i again shifted my array the cost will be 2*x\\n            // which is (op+1)*x (as we are starting op from 0)\\n            long long operationCost = (long long)(op+1)*x;\\n\\n            // shifting the nums by 1\\n            shift(nums);\\n\\n\\n            long long currentCost = 0;\\n\\n            // for each element we want the minCost\\n            // so we will compare and update the minCost only if it is lesser\\n            // than the existing value of minCost\\n            // ex : nums = [15 20 1]\\n            // minCost = [20 1 15]\\n            // current op = 1;\\n            // now we will preserve our mincost of element if it is smaller than \\n            // that of nums or else we will update them\\n            // 20 > 15 -> update minCost[0] = 15\\n            // 1 > 20 -> false\\n            // 15 > 1 -> true minCost[2] = 1\\n            // updates minCost array -> [15, 1, 1]\\n            // total Cost = 15 + 1 + 1 + (operationCost)\\n            // operationCost = op*x = 1*x;\\n            // total cost = 15 + 1 + 1 + 1*5 = 23\\n            for(int i=0; i<n; i++){\\n                if(minCost[i] > nums[i]){\\n                    minCost[i] = nums[i];\\n                }\\n                // adding currentChocolate\\'s cost to our currentCost\\n                currentCost += minCost[i];\\n            }\\n            // total Cost will be the sum of operationCost + currentCost\\n            long long finalCost = operationCost + currentCost;\\n            answer = min(answer, finalCost);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // TC : O(N^2)\\n    // SC : O(N)\\n\\n    // a function to RIGHT shift the array by one\\n    void shift (vector<int>& nums){\\n        int n = nums.size();\\n        int last = nums[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            nums[i+1] = nums[i];\\n        }\\n        nums[0] = last;\\n    }\\n\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        // an extra array to store the minCost of each chocolate\\n        vector<int> minCost(n, 0);\\n\\n        // initially answer is 0 and we are gonna check whether the \\n        // intial array configuration is our answer\\n        // by adding the elements in answer\\n        long long answer = 0;\\n        for(int i=0; i<n; i++){\\n            minCost[i] = nums[i];\\n            answer += minCost[i];\\n        }\\n\\n        // for an array of size n we can have at max n-1 operations\\n        // after that we will be at our initial configuration or array\\n\\n        // going to each operation by shifting the array\\n        for(int op=0; op<n; op++){\\n\\n            // say if we shift our array x times then the total\\n            // operationCost will be (op+1)*x\\n            // why ? let\\'s understand\\n            // say i shifted my array one time : cost to be added is X\\n            // now if i again shifted my array the cost will be 2*x\\n            // which is (op+1)*x (as we are starting op from 0)\\n            long long operationCost = (long long)(op+1)*x;\\n\\n            // shifting the nums by 1\\n            shift(nums);\\n\\n\\n            long long currentCost = 0;\\n\\n            // for each element we want the minCost\\n            // so we will compare and update the minCost only if it is lesser\\n            // than the existing value of minCost\\n            // ex : nums = [15 20 1]\\n            // minCost = [20 1 15]\\n            // current op = 1;\\n            // now we will preserve our mincost of element if it is smaller than \\n            // that of nums or else we will update them\\n            // 20 > 15 -> update minCost[0] = 15\\n            // 1 > 20 -> false\\n            // 15 > 1 -> true minCost[2] = 1\\n            // updates minCost array -> [15, 1, 1]\\n            // total Cost = 15 + 1 + 1 + (operationCost)\\n            // operationCost = op*x = 1*x;\\n            // total cost = 15 + 1 + 1 + 1*5 = 23\\n            for(int i=0; i<n; i++){\\n                if(minCost[i] > nums[i]){\\n                    minCost[i] = nums[i];\\n                }\\n                // adding currentChocolate\\'s cost to our currentCost\\n                currentCost += minCost[i];\\n            }\\n            // total Cost will be the sum of operationCost + currentCost\\n            long long finalCost = operationCost + currentCost;\\n            answer = min(answer, finalCost);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636022,
                "title": "c-try-every-possibility",
                "content": "```\\n\\tpublic long MinCost(int[] nums, int x) {\\n        var min = new long[nums.Length];\\n        Array.Fill(min, long.MaxValue);\\n        var res = long.MaxValue;\\n        for (int i = 0; i < nums.Length; i++) {\\n            var sum = (long)x * i;\\n            for (int j = 0; j < nums.Length; j++) {\\n                min[j] = Math.Min(min[j], nums[(i + j) % nums.Length]);\\n                sum += min[j];\\n            }\\n            res = Math.Min(res, sum);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic long MinCost(int[] nums, int x) {\\n        var min = new long[nums.Length];\\n        Array.Fill(min, long.MaxValue);\\n        var res = long.MaxValue;\\n        for (int i = 0; i < nums.Length; i++) {\\n            var sum = (long)x * i;\\n            for (int j = 0; j < nums.Length; j++) {\\n                min[j] = Math.Min(min[j], nums[(i + j) % nums.Length]);\\n                sum += min[j];\\n            }\\n            res = Math.Min(res, sum);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3635550,
                "title": "brute-force",
                "content": "The idea is to try out all rotations. for some rotation by ``` shift``` ( variable from 0 to n-1), we choose minimum cost available from index ```i ``` to index ``` (i + shift)%n``` . Keep in mind the rotation cost will be added only once.\\n\\nThe time comp. can be improved by using min Heap for every element of the array, then time comp. will be O(nlogn), otherwise it is O(n^2).\\n```\\nclass Solution {\\npublic:\\n    \\n    long long minCost(vector<int>& nums, int x) {\\n        long long res = 1e18;\\n        int max_shift = 0;\\n        int n = nums.size();\\n          \\n        // brute force \\n        \\n        // arr[i][shift] tells the minimum cost if we are seeing \\'shift\\' elements ahead of i\\n        vector<vector<int>> arr(n, vector<int>(n));\\n        \\n        for(int i = 0; i < n; i++){\\n            int j = (i + 1)%n;\\n            arr[i][0] = nums[i];\\n            for(int shift = 1; shift < n; shift++, j = (j + 1)%n){\\n                arr[i][shift] = min(nums[j], arr[i][shift - 1]);\\n            }\\n        }\\n        \\n        for(int shift = 0; shift < n; shift++){\\n            long long curr = shift * 1LL * x;\\n            for(int i = 0; i<n; i++){\\n                curr += arr[i][shift];\\n            }\\n            res = min(res, curr);\\n        }\\n        \\n        return res;\\n    }\\n    \\n};\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "``` shift```\n```i ```\n``` (i + shift)%n```\n```\\nclass Solution {\\npublic:\\n    \\n    long long minCost(vector<int>& nums, int x) {\\n        long long res = 1e18;\\n        int max_shift = 0;\\n        int n = nums.size();\\n          \\n        // brute force \\n        \\n        // arr[i][shift] tells the minimum cost if we are seeing \\'shift\\' elements ahead of i\\n        vector<vector<int>> arr(n, vector<int>(n));\\n        \\n        for(int i = 0; i < n; i++){\\n            int j = (i + 1)%n;\\n            arr[i][0] = nums[i];\\n            for(int shift = 1; shift < n; shift++, j = (j + 1)%n){\\n                arr[i][shift] = min(nums[j], arr[i][shift - 1]);\\n            }\\n        }\\n        \\n        for(int shift = 0; shift < n; shift++){\\n            long long curr = shift * 1LL * x;\\n            for(int i = 0; i<n; i++){\\n                curr += arr[i][shift];\\n            }\\n            res = min(res, curr);\\n        }\\n        \\n        return res;\\n    }\\n    \\n};\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633040,
                "title": "python-left-shift-beats-80-time-and-60-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI know Leetcode changed its problem description for this problem from the Weekly Contest and this is me solving this problem after the contest ended.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore the minimum value in a list $m$ after performing $i$ shifts to collect the $i^{th}$ chocolate, where $0<=i<n$ and $n = len(nums)$. Initially, $m[i] = nums[i]$\\nAfter performing $n$ shifts, we will reach the same array again so we stop here since we are at the same array configuration when we started. \\nLoop through each shift and calculate the new index which will be $(i - shifts)  \\\\mod  n$. Since python supports negative indexes as reverse indexes, we don\\'t need indexes to be non-negative. \\nNow, we can calculate $m[new\\\\_index] = min(m[new\\\\_index], nums[i])$ and store them in a loop variable temporarily. If this total is less than the minimum encountered so far, we update the minimum so far variable to total and continue looping forward. Else, we return the minimum so far.\\n\\n\\n# Complexity\\n- Time complexity: $$O(N^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        n = len(nums)\\n        m = nums.copy()\\n        \\n        min_so_far = float(\"inf\")\\n\\n        for shifts in range(n):\\n            total = shifts * x\\n            for i in range(n):\\n                new_index = (i - shifts) % n\\n                m[new_index] = min(m[new_index], nums[i])\\n                total += m[new_index]\\n            if total < min_so_far:\\n                min_so_far = total \\n            else:\\n                return min_so_far\\n            \\n\\n        return min_so_far\\n            \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        n = len(nums)\\n        m = nums.copy()\\n        \\n        min_so_far = float(\"inf\")\\n\\n        for shifts in range(n):\\n            total = shifts * x\\n            for i in range(n):\\n                new_index = (i - shifts) % n\\n                m[new_index] = min(m[new_index], nums[i])\\n                total += m[new_index]\\n            if total < min_so_far:\\n                min_so_far = total \\n            else:\\n                return min_so_far\\n            \\n\\n        return min_so_far\\n            \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631919,
                "title": "using-priorityqueue-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minCost(int[] nums, int x) {\\n        \\n        long mod=1000000007L;\\n        int len=nums.length;\\n        \\n        int ind[]=new int[len];\\n        \\n        List<PriorityQueue<Integer>> pqs=new ArrayList<>();\\n        \\n        long mul=1;\\n        \\n        long min=0;\\n        for(int i=0;i<len;i++){\\n            \\n          PriorityQueue<Integer> pq=new PriorityQueue<>();\\n            pq.add(nums[i]);\\n            pqs.add(pq);\\n            min=min+(long)nums[i];\\n            \\n            ind[i]=i;\\n        }\\n        \\n        for(int i=0;i<len;i++){\\n            \\n            long nsum=0;\\n            \\n            for(int j=0;j<len;j++){\\n                \\n                PriorityQueue<Integer> pq1=pqs.get(j);\\n                int index=ind[j];\\n                index++;\\n                if(index==len){\\n                    index=0;\\n                }\\n                ind[j]=index;\\n                pq1.add(nums[index]);\\n                \\n                int min2=pq1.peek();\\n                nsum=nsum+(long)min2;\\n            }\\n            long shiftCost=mul*x;\\n            nsum+=shiftCost;\\n            \\n            if(nsum<min)\\n                min=nsum;\\n            \\n            mul++;\\n        }\\n        \\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minCost(int[] nums, int x) {\\n        \\n        long mod=1000000007L;\\n        int len=nums.length;\\n        \\n        int ind[]=new int[len];\\n        \\n        List<PriorityQueue<Integer>> pqs=new ArrayList<>();\\n        \\n        long mul=1;\\n        \\n        long min=0;\\n        for(int i=0;i<len;i++){\\n            \\n          PriorityQueue<Integer> pq=new PriorityQueue<>();\\n            pq.add(nums[i]);\\n            pqs.add(pq);\\n            min=min+(long)nums[i];\\n            \\n            ind[i]=i;\\n        }\\n        \\n        for(int i=0;i<len;i++){\\n            \\n            long nsum=0;\\n            \\n            for(int j=0;j<len;j++){\\n                \\n                PriorityQueue<Integer> pq1=pqs.get(j);\\n                int index=ind[j];\\n                index++;\\n                if(index==len){\\n                    index=0;\\n                }\\n                ind[j]=index;\\n                pq1.add(nums[index]);\\n                \\n                int min2=pq1.peek();\\n                nsum=nsum+(long)min2;\\n            }\\n            long shiftCost=mul*x;\\n            nsum+=shiftCost;\\n            \\n            if(nsum<min)\\n                min=nsum;\\n            \\n            mul++;\\n        }\\n        \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631319,
                "title": "c-optimal-solution-o-n-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long int ll;\\n    // vector<int> shifRight(vector<int>& order){\\n    //     int n = order.size();\\n    //     for(int i=0;i<n;i++){\\n    //         order[i] = (order[i]+n-1)%n;\\n    //     }\\n    //     return order;\\n    // }\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        // vector<int> Order(n);\\n        // for(int i=0;i<n;i++)Order[i] = i;\\n        vector<int> _minCost = nums;\\n        ll result = 1e18;\\n        ll operationCost = 0;\\n        for(int i=0;i<n;i++){\\n            ll totalSum = 0;\\n            for(int j=0;j<n;j++)totalSum += _minCost[j];\\n            \\n            result = min(result, totalSum + operationCost);\\n            operationCost += x;\\n            for(int j=0;j<n;j++){\\n                _minCost[j] = min(_minCost[j],nums[(i+j+1)%n]);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long int ll;\\n    // vector<int> shifRight(vector<int>& order){\\n    //     int n = order.size();\\n    //     for(int i=0;i<n;i++){\\n    //         order[i] = (order[i]+n-1)%n;\\n    //     }\\n    //     return order;\\n    // }\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        // vector<int> Order(n);\\n        // for(int i=0;i<n;i++)Order[i] = i;\\n        vector<int> _minCost = nums;\\n        ll result = 1e18;\\n        ll operationCost = 0;\\n        for(int i=0;i<n;i++){\\n            ll totalSum = 0;\\n            for(int j=0;j<n;j++)totalSum += _minCost[j];\\n            \\n            result = min(result, totalSum + operationCost);\\n            operationCost += x;\\n            for(int j=0;j<n;j++){\\n                _minCost[j] = min(_minCost[j],nums[(i+j+1)%n]);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630145,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N*N)\\n\\n- Space complexity:\\nO(N+N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size();\\n\\n        vector<int>check(n,INT_MAX);\\n        vector<int>temp(nums.begin(),nums.end());\\n        for(auto i : nums) temp.push_back(i);\\n        \\n        long long ans = LONG_MAX;\\n        \\n        for(int rot = 0 ;rot<n;rot++){\\n                long long sum = 0;\\n                \\n                for(int j = 0 ;j<n;j++){\\n                    check[j] = min( heck[j], temp[j+rot]);\\n                    sum += check[j];\\n                  }\\n\\n              sum =  (long long)sum + ((long long)x * (long long)rot);\\n              ans = min(ans,sum);\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size();\\n\\n        vector<int>check(n,INT_MAX);\\n        vector<int>temp(nums.begin(),nums.end());\\n        for(auto i : nums) temp.push_back(i);\\n        \\n        long long ans = LONG_MAX;\\n        \\n        for(int rot = 0 ;rot<n;rot++){\\n                long long sum = 0;\\n                \\n                for(int j = 0 ;j<n;j++){\\n                    check[j] = min( heck[j], temp[j+rot]);\\n                    sum += check[j];\\n                  }\\n\\n              sum =  (long long)sum + ((long long)x * (long long)rot);\\n              ans = min(ans,sum);\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629471,
                "title": "c-manually-rotate-and-check-the-smallest-cost-required-short-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        long long ans=LLONG_MAX,i,j,n=nums.size();\\n        vector<long long> dp(n,LLONG_MAX);\\n        for(i=0;i<n;i++)\\n        {\\n            long long tmp=0;\\n            for(j=0;j<n;j++)\\n            {\\n                int ind=j-i;\\n                if(ind<0)\\n                ind=n+ind;\\n                long long p=nums[ind];\\n                dp[j]=min(dp[j],p);\\n                tmp+=dp[j];\\n            }\\n            ans=min(ans,tmp+i*x);\\n        }\\n       return ans;         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        long long ans=LLONG_MAX,i,j,n=nums.size();\\n        vector<long long> dp(n,LLONG_MAX);\\n        for(i=0;i<n;i++)\\n        {\\n            long long tmp=0;\\n            for(j=0;j<n;j++)\\n            {\\n                int ind=j-i;\\n                if(ind<0)\\n                ind=n+ind;\\n                long long p=nums[ind];\\n                dp[j]=min(dp[j],p);\\n                tmp+=dp[j];\\n            }\\n            ans=min(ans,tmp+i*x);\\n        }\\n       return ans;         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629375,
                "title": "c-easy-solution-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        long long ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans+=nums[i];\\n        }\\n        vector<long long>dp(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            dp[i]=nums[i];\\n        }\\n        for(int i=1;i<1000;i++){\\n            long long ww = (long long)x*(long long)i;\\n            long long sum = ww;\\n            for(int j=0;j<nums.size();j++){\\n                int index = (j+i)%nums.size();\\n                dp[j]=min(dp[j],(long long)nums[index]);\\n                sum+=dp[j];\\n            }\\n            ans=min(ans,sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        long long ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans+=nums[i];\\n        }\\n        vector<long long>dp(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            dp[i]=nums[i];\\n        }\\n        for(int i=1;i<1000;i++){\\n            long long ww = (long long)x*(long long)i;\\n            long long sum = ww;\\n            for(int j=0;j<nums.size();j++){\\n                int index = (j+i)%nums.size();\\n                dp[j]=min(dp[j],(long long)nums[index]);\\n                sum+=dp[j];\\n            }\\n            ans=min(ans,sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629079,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MinCost(int[] A, int x) {\\n        int n = A.Length;\\n        long[] res = new long[n];\\n        for (int i = 0; i < n; i++)\\n        {\\n            res[i] += 1L * i * x;\\n            int cur = A[i];\\n            for (int k = 0; k < n; k++)\\n            {\\n                cur = Math.Min(cur, A[(i - k + n) % n]);\\n                res[k] += cur;\\n            }\\n        }\\n\\n        long min_res = long.MaxValue;\\n        foreach (long element in res)\\n        {\\n            min_res = Math.Min(min_res, element);\\n        }\\n\\n        return min_res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long MinCost(int[] A, int x) {\\n        int n = A.Length;\\n        long[] res = new long[n];\\n        for (int i = 0; i < n; i++)\\n        {\\n            res[i] += 1L * i * x;\\n            int cur = A[i];\\n            for (int k = 0; k < n; k++)\\n            {\\n                cur = Math.Min(cur, A[(i - k + n) % n]);\\n                res[k] += cur;\\n            }\\n        }\\n\\n        long min_res = long.MaxValue;\\n        foreach (long element in res)\\n        {\\n            min_res = Math.Min(min_res, element);\\n        }\\n\\n        return min_res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628162,
                "title": "c-o-n-2-weekly-contest-349",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        vector<vector<long long>> allArr(nums.size(),vector<long long>(nums.size(),0));\\n        for(int i=0;i<nums.size();i++)allArr[0][i]=nums[i];\\n        for(int i=1;i<nums.size();i++){\\n            for(int j=0;j<nums.size();j++){\\n                if(j>0)allArr[i][j]=allArr[i-1][j-1];\\n                else allArr[i][j]=allArr[i-1][nums.size()-1];\\n            }\\n        }\\n        \\n        long long sum=0;\\n        for(auto i:nums)sum+=(long long)i;\\n        vector<long long> num;\\n        for(auto i:nums)num.push_back(i);\\n        for(int i=1;i<num.size();i++){\\n            long long csum=(long long)x*i;\\n            for(int j=0;j<num.size();j++){\\n                num[j]=min(num[j],allArr[i][j]);\\n                csum+=(long long)num[j];\\n            }\\n            sum=min(sum,csum);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        vector<vector<long long>> allArr(nums.size(),vector<long long>(nums.size(),0));\\n        for(int i=0;i<nums.size();i++)allArr[0][i]=nums[i];\\n        for(int i=1;i<nums.size();i++){\\n            for(int j=0;j<nums.size();j++){\\n                if(j>0)allArr[i][j]=allArr[i-1][j-1];\\n                else allArr[i][j]=allArr[i-1][nums.size()-1];\\n            }\\n        }\\n        \\n        long long sum=0;\\n        for(auto i:nums)sum+=(long long)i;\\n        vector<long long> num;\\n        for(auto i:nums)num.push_back(i);\\n        for(int i=1;i<num.size();i++){\\n            long long csum=(long long)x*i;\\n            for(int j=0;j<num.size();j++){\\n                num[j]=min(num[j],allArr[i][j]);\\n                csum+=(long long)num[j];\\n            }\\n            sum=min(sum,csum);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628025,
                "title": "cpp-try-all-possible-shifts",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven the constraints we can just simulate for all possible shifts. Each type i can be picked at some optimal rotation.\\nEach subsequent rotation incurs a cost x.\\nBut there is possiblity of reducing cost for picking type i by the shift.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAll possible shifts accounted for and min out of all of them is taken\\n# Complexity\\n- Time complexity:\\n- $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\nwe can solve it by thinking of doing all possible shifts.\\ni can shift by 0,1,....n-1 \\nso i can try to get total ans for all kinds of shifts\\n\\nso lets say i shift by k, then i try to find min val for each possible type\\nand store in arre mnVal[i] for each type i\\nsome type will have optimal in some rotation and some will have optimal in other rotation\\n\\nand cost of rotation is only added in the overall sum\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n\\n        long long ans = LONG_MAX;\\n        int n= nums.size();\\n        vector<int>bestVal(n,INT_MAX);\\n        for(int k=0;k<n;k++)\\n        {\\n            //kth shift\\n            long long sum=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                bestVal[i]= min(bestVal[i],nums[(i+k)%n]);\\n                sum+=bestVal[i];\\n            }\\n            sum += (long long)k*x;\\n            ans= min(ans,sum);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\nwe can solve it by thinking of doing all possible shifts.\\ni can shift by 0,1,....n-1 \\nso i can try to get total ans for all kinds of shifts\\n\\nso lets say i shift by k, then i try to find min val for each possible type\\nand store in arre mnVal[i] for each type i\\nsome type will have optimal in some rotation and some will have optimal in other rotation\\n\\nand cost of rotation is only added in the overall sum\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n\\n        long long ans = LONG_MAX;\\n        int n= nums.size();\\n        vector<int>bestVal(n,INT_MAX);\\n        for(int k=0;k<n;k++)\\n        {\\n            //kth shift\\n            long long sum=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                bestVal[i]= min(bestVal[i],nums[(i+k)%n]);\\n                sum+=bestVal[i];\\n            }\\n            sum += (long long)k*x;\\n            ans= min(ans,sum);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628005,
                "title": "c-dp-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N*N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        long long result[n];\\n        long long min_res;\\n        for (int i=0;i<n;i++) {\\n            result[i] = (long long)x*(long long)i;\\n        }\\n        for (int i=0;i<n;i++) {\\n            int cur = nums[i];\\n            for (int j=0;j<n;j++) {\\n                cur=min(nums[(i-j+n)%n], cur);\\n                result[j]+=(long long)(cur);\\n            }\\n        }\\n        min_res = result[0];\\n        for (int i=1;i<n;i++) {\\n            min_res = min(min_res, result[i]);\\n        }\\n        return min_res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        long long result[n];\\n        long long min_res;\\n        for (int i=0;i<n;i++) {\\n            result[i] = (long long)x*(long long)i;\\n        }\\n        for (int i=0;i<n;i++) {\\n            int cur = nums[i];\\n            for (int j=0;j<n;j++) {\\n                cur=min(nums[(i-j+n)%n], cur);\\n                result[j]+=(long long)(cur);\\n            }\\n        }\\n        min_res = result[0];\\n        for (int i=1;i<n;i++) {\\n            min_res = min(min_res, result[i]);\\n        }\\n        return min_res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627918,
                "title": "best-c-solution-by-swapping",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSwap each elements of the array. Find the Minimum One.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     void Swap(vector<int>& nums, vector<int> &copy,long long &sum,int x){\\n        int n=nums.size();\\n        long long d=sum + x;\\n        for(int i=0; i<n; i++){\\n            if(i+1<n)swap(nums[i],nums[i+1]);\\n            if(nums[i]<copy[i]){\\n                d += (nums[i] - copy[i]);\\n                copy[i]=nums[i];\\n            }\\n        }\\n        sum=min(sum,d);\\n    }\\n    long long minCost(vector<int>& nums, int x) {\\n        vector<int> copy=nums;\\n        long long sum=0;\\n        for(auto it : nums) sum += it;\\n        for(int i=0; i<nums.size(); i++){\\n            Swap(nums,copy,sum,x);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     void Swap(vector<int>& nums, vector<int> &copy,long long &sum,int x){\\n        int n=nums.size();\\n        long long d=sum + x;\\n        for(int i=0; i<n; i++){\\n            if(i+1<n)swap(nums[i],nums[i+1]);\\n            if(nums[i]<copy[i]){\\n                d += (nums[i] - copy[i]);\\n                copy[i]=nums[i];\\n            }\\n        }\\n        sum=min(sum,d);\\n    }\\n    long long minCost(vector<int>& nums, int x) {\\n        vector<int> copy=nums;\\n        long long sum=0;\\n        for(auto it : nums) sum += it;\\n        for(int i=0; i<nums.size(); i++){\\n            Swap(nums,copy,sum,x);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627500,
                "title": "python-runtime-o-n-2-memory-o-n",
                "content": "`picked` records the smallest cost up until this point for every type. For each iteration, calcualate the smallest possible cost, then compare it with the previous interations.  \\n```\\nfrom collections import deque\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        nums = deque(nums)\\n        N = len(nums)\\n        picked = [x for x in nums]\\n        ans = sum(nums)\\n    \\n        for k in range(1, N):\\n            cost = x*k\\n            nums.rotate(1)\\n            for c in range(N):\\n                if nums[c] < picked[c]:\\n                    picked[c] = nums[c]\\n                cost += picked[c]\\n            ans = min(ans, cost)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        nums = deque(nums)\\n        N = len(nums)\\n        picked = [x for x in nums]\\n        ans = sum(nums)\\n    \\n        for k in range(1, N):\\n            cost = x*k\\n            nums.rotate(1)\\n            for c in range(N):\\n                if nums[c] < picked[c]:\\n                    picked[c] = nums[c]\\n                cost += picked[c]\\n            ans = min(ans, cost)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627499,
                "title": "python-runtime-o-n-2-memory-o-n",
                "content": "`picked` records the smallest cost up until this point for every type. For each iteration, calcualate the smallest possible cost, then compare it with the previous interations.  \\n```\\nfrom collections import deque\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        nums = deque(nums)\\n        N = len(nums)\\n        picked = [x for x in nums]\\n        ans = sum(nums)\\n    \\n        for k in range(1, N):\\n            cost = x*k\\n            nums.rotate(1)\\n            for c in range(N):\\n                if nums[c] < picked[c]:\\n                    picked[c] = nums[c]\\n                cost += picked[c]\\n            ans = min(ans, cost)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        nums = deque(nums)\\n        N = len(nums)\\n        picked = [x for x in nums]\\n        ans = sum(nums)\\n    \\n        for k in range(1, N):\\n            cost = x*k\\n            nums.rotate(1)\\n            for c in range(N):\\n                if nums[c] < picked[c]:\\n                    picked[c] = nums[c]\\n                cost += picked[c]\\n            ans = min(ans, cost)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627243,
                "title": "simple-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        totalX=0\\n        minN=[ x for x in nums]\\n        choices=sum(nums)\\n        minCost=choices\\n        for i in range(1,len(nums)):\\n            for j in range(len(nums)):\\n                if nums[( j+i) %  len(nums)] < minN[j]:\\n                    choices-=  minN[j] -  nums[( j+i) %  len(nums)]\\n                    minN[j]= nums[( j+i) %  len(nums)] \\n            totalX+=x\\n            minCost=min(minCost,choices+totalX)\\n        return minCost\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        totalX=0\\n        minN=[ x for x in nums]\\n        choices=sum(nums)\\n        minCost=choices\\n        for i in range(1,len(nums)):\\n            for j in range(len(nums)):\\n                if nums[( j+i) %  len(nums)] < minN[j]:\\n                    choices-=  minN[j] -  nums[( j+i) %  len(nums)]\\n                    minN[j]= nums[( j+i) %  len(nums)] \\n            totalX+=x\\n            minCost=min(minCost,choices+totalX)\\n        return minCost\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626945,
                "title": "rust-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple double loop. \\n\\nA very nice problem. However, the description could/should be much better.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nimpl Solution {\\n    pub fn min_cost(nums: Vec<i32>, x: i32) -> i64 {\\n        let mut nums = nums;\\n        let (n, mut ret) = (nums.len(), i64::MAX);\\n\\n        for k in 0 .. n as i64 {\\n            let temp = nums.iter().map(|a| (*a) as i64).sum::<i64>();\\n            ret = ret.min(temp + k * x as i64);\\n            if k == n as i64 - 1 { break }\\n\\n            let mut temp = vec![0; n];\\n            for i in 0 .. n {\\n                temp[i] = nums[i].min(nums[(i + 1) % n]);\\n            }\\n            nums = temp;\\n        } \\n\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_cost(nums: Vec<i32>, x: i32) -> i64 {\\n        let mut nums = nums;\\n        let (n, mut ret) = (nums.len(), i64::MAX);\\n\\n        for k in 0 .. n as i64 {\\n            let temp = nums.iter().map(|a| (*a) as i64).sum::<i64>();\\n            ret = ret.min(temp + k * x as i64);\\n            if k == n as i64 - 1 { break }\\n\\n            let mut temp = vec![0; n];\\n            for i in 0 .. n {\\n                temp[i] = nums[i].min(nums[(i + 1) % n]);\\n            }\\n            nums = temp;\\n        } \\n\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3626818,
                "title": "c",
                "content": "Time complexity: O(n ^ 2)\\nSpace complexity: O(n)\\n```C []\\nint64_t minCost(\\n\\tconst int * const nums,\\n\\tconst int numsLen,\\n\\tconst int x\\n){\\n\\tint costs[numsLen];\\n\\n\\tint64_t minTotal = x * 0;\\n\\tmemcpy(costs, nums, sizeof (int) * numsLen);\\n\\tfor (int i = 0; i < numsLen; i += 1){\\n\\t\\tminTotal += costs[i];\\n\\t}\\n\\n\\tfor (int shift = 1; shift < numsLen; shift += 1){\\n\\t\\tint64_t curTotal = (int64_t)x * (int64_t)shift;\\n\\t\\tfor (int i = 0; i < numsLen; i += 1){\\n\\t\\t\\tconst int curCost = nums[i + shift - (i + shift < numsLen? 0 : numsLen)];\\n\\t\\t\\tif (curCost < costs[i]){\\n\\t\\t\\t\\tcosts[i] = curCost;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < numsLen; i += 1){\\n\\t\\t\\tcurTotal += costs[i];\\n\\t\\t}\\n\\n\\t\\tif (curTotal < minTotal){\\n\\t\\t\\tminTotal = curTotal;\\n\\t\\t}\\n\\t}\\n\\n\\treturn minTotal;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C []\\nint64_t minCost(\\n\\tconst int * const nums,\\n\\tconst int numsLen,\\n\\tconst int x\\n){\\n\\tint costs[numsLen];\\n\\n\\tint64_t minTotal = x * 0;\\n\\tmemcpy(costs, nums, sizeof (int) * numsLen);\\n\\tfor (int i = 0; i < numsLen; i += 1){\\n\\t\\tminTotal += costs[i];\\n\\t}\\n\\n\\tfor (int shift = 1; shift < numsLen; shift += 1){\\n\\t\\tint64_t curTotal = (int64_t)x * (int64_t)shift;\\n\\t\\tfor (int i = 0; i < numsLen; i += 1){\\n\\t\\t\\tconst int curCost = nums[i + shift - (i + shift < numsLen? 0 : numsLen)];\\n\\t\\t\\tif (curCost < costs[i]){\\n\\t\\t\\t\\tcosts[i] = curCost;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < numsLen; i += 1){\\n\\t\\t\\tcurTotal += costs[i];\\n\\t\\t}\\n\\n\\t\\tif (curTotal < minTotal){\\n\\t\\t\\tminTotal = curTotal;\\n\\t\\t}\\n\\t}\\n\\n\\treturn minTotal;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3626634,
                "title": "easy-java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt max there should be `n-1` rotations, find the minimum possible cost after each rotation. Finally consider smallest cost.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHold minimum possible cost of ith chocolate at every rotation, and update it accordingly. Solution is self explainatory\\n\\n# Complexity\\n- Time complexity: $$O(N*N)$$\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long minCost(int[] nums, int x) {\\n        long ans = 0;\\n        for(int num: nums) ans += num;\\n        int n = nums.length;\\n        int[] mins = nums.clone(); // Holds minimum costs at each rotation\\n        for(int r = 1;r < n;r++) {\\n            long temp = 0;\\n            for(int i = 0;i<n;i++) {\\n                if (mins[i] > nums[(i+r)%n]) {\\n                    temp += nums[(i+r)%n];\\n                    mins[i] = nums[(i+r)%n]; // update\\n                } else {\\n                    temp += mins[i];\\n                }\\n            }\\n            \\n            ans = Math.min(ans, temp + 1l*r*x);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minCost(int[] nums, int x) {\\n        long ans = 0;\\n        for(int num: nums) ans += num;\\n        int n = nums.length;\\n        int[] mins = nums.clone(); // Holds minimum costs at each rotation\\n        for(int r = 1;r < n;r++) {\\n            long temp = 0;\\n            for(int i = 0;i<n;i++) {\\n                if (mins[i] > nums[(i+r)%n]) {\\n                    temp += nums[(i+r)%n];\\n                    mins[i] = nums[(i+r)%n]; // update\\n                } else {\\n                    temp += mins[i];\\n                }\\n            }\\n            \\n            ans = Math.min(ans, temp + 1l*r*x);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626345,
                "title": "o-n-2-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        long long ans =0;\\n        for(int i=0;i<n;i++)\\n            ans += nums[i];\\n        int k =1;\\n        vector<long long> dp(nums.begin(),nums.end());\\n        for(int i=1;i<n;i++){\\n            long long s=0;\\n            for(int j=n-i-1,k=n-1;k>=0;j--,k--){\\n                dp[k] = min(dp[k],1ll * nums[(n+j)%n]);\\n                s+= dp[k];\\n            }\\n            s += x*1ll*k;\\n            k++;\\n            ans =  min(ans,s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        long long ans =0;\\n        for(int i=0;i<n;i++)\\n            ans += nums[i];\\n        int k =1;\\n        vector<long long> dp(nums.begin(),nums.end());\\n        for(int i=1;i<n;i++){\\n            long long s=0;\\n            for(int j=n-i-1,k=n-1;k>=0;j--,k--){\\n                dp[k] = min(dp[k],1ll * nums[(n+j)%n]);\\n                s+= dp[k];\\n            }\\n            s += x*1ll*k;\\n            k++;\\n            ans =  min(ans,s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626314,
                "title": "c-easy-explanation-simple",
                "content": "# Intuition\\nI was thinking that there will be some amount of rotations that we will have to do to find the correct answer. If we know the amount of rotation we will be doing, I would find the minimum cost among that and add it to the answer.\\n\\n# Approach\\nInstead of guessing(binary search) the number of rotations we require to find the correct answer, I decided to check for all the rotation and calculate the best answer for each result.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        long long int ans = 0;\\n        int n = nums.size();\\n        // Store then minimum value for ith chocolate\\n        vector<int> arr = nums;\\n        for(int i=0;i<n;i++){\\n            ans += nums[i];\\n        }\\n        int k = n-1;\\n        long long int rot = x;\\n        // k is for all the rotation\\n        while(k--){\\n            // Roation start\\n            int temp = nums[0];\\n            for(int i=0;i<n-1;i++){\\n                nums[i] = nums[i+1];\\n            }\\n            nums[n-1] = temp;\\n            // Rotation end\\n\\n            // Update the best result for each chocolate after rotation\\n            long long int sum = 0;\\n            for(int i=0;i<n;i++){\\n                arr[i] = min(arr[i], nums[i]);\\n                sum += arr[i];\\n            }\\n\\n            // Add the rotation cost\\n            sum += rot;\\n            rot += x;\\n\\n            // Update answer\\n            ans = min<long long int>(ans, sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        long long int ans = 0;\\n        int n = nums.size();\\n        // Store then minimum value for ith chocolate\\n        vector<int> arr = nums;\\n        for(int i=0;i<n;i++){\\n            ans += nums[i];\\n        }\\n        int k = n-1;\\n        long long int rot = x;\\n        // k is for all the rotation\\n        while(k--){\\n            // Roation start\\n            int temp = nums[0];\\n            for(int i=0;i<n-1;i++){\\n                nums[i] = nums[i+1];\\n            }\\n            nums[n-1] = temp;\\n            // Rotation end\\n\\n            // Update the best result for each chocolate after rotation\\n            long long int sum = 0;\\n            for(int i=0;i<n;i++){\\n                arr[i] = min(arr[i], nums[i]);\\n                sum += arr[i];\\n            }\\n\\n            // Add the rotation cost\\n            sum += rot;\\n            rot += x;\\n\\n            // Update answer\\n            ans = min<long long int>(ans, sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626299,
                "title": "python3-brute-force-store-min-prices",
                "content": "# Intuition\\nWe are storing min price for each item in array `nums`.\\nEach step we are updating min prices.\\nWe stop the process when price for iteration `i*x` is higher that the minimal total price.\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        n=len(nums)\\n        price=sum(nums)\\n        X=0\\n        for i in range(n):\\n            nums0=nums[0]\\n            for j in range(n-1):\\n                nums[j]=min(nums[j],nums[j+1])\\n            nums[n-1]=min(nums[n-1],nums0)\\n            X+=x\\n            price=min(X+sum(nums),price)\\n            if price<X: break\\n        return price   \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        n=len(nums)\\n        price=sum(nums)\\n        X=0\\n        for i in range(n):\\n            nums0=nums[0]\\n            for j in range(n-1):\\n                nums[j]=min(nums[j],nums[j+1])\\n            nums[n-1]=min(nums[n-1],nums0)\\n            X+=x\\n            price=min(X+sum(nums),price)\\n            if price<X: break\\n        return price   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625754,
                "title": "python-greedy-o-n-2-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        n = len(nums)\\n        curmins = [float(\\'inf\\')]*n\\n        res = float(\\'inf\\')\\n        for delta in range(n):\\n            for i in range(n):\\n                curmins[i] = min(curmins[i], nums[(i+delta)%n])\\n            res = min(res, sum(curmins) + x*delta)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        n = len(nums)\\n        curmins = [float(\\'inf\\')]*n\\n        res = float(\\'inf\\')\\n        for delta in range(n):\\n            for i in range(n):\\n                curmins[i] = min(curmins[i], nums[(i+delta)%n])\\n            res = min(res, sum(curmins) + x*delta)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625668,
                "title": "python-shifting-with-minimum-cost-update",
                "content": "# Intuition\\nOptimization problem with 2 things in mind, I had an issue understanding question in a first place, that is the hard part.\\nQuadratic approach is obvious, a lot of this kind of problems allow binary search also.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nfrom math import inf\\n\\nclass Solution:\\n    def minCost(self, A: List[int], x: int) -> int:\\n        N, result = len(A), inf\\n        min_costs, total_cost = A[:], sum(A)\\n\\n        def update_costs(shifts):\\n            cost =  total_cost\\n            for i in range(N):\\n                candidate_cost = A[(i + shifts) % N]\\n                if candidate_cost < min_costs[i]:\\n                    cost -= min_costs[i] - candidate_cost\\n                    min_costs[i] = candidate_cost\\n            return cost \\n\\n        for i in range(N):            \\n            result = min(result, total_cost + i * x)\\n            total_cost = update_costs(i+1)\\n                \\n        return result\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nfrom math import inf\\n\\nclass Solution:\\n    def minCost(self, A: List[int], x: int) -> int:\\n        N, result = len(A), inf\\n        min_costs, total_cost = A[:], sum(A)\\n\\n        def update_costs(shifts):\\n            cost =  total_cost\\n            for i in range(N):\\n                candidate_cost = A[(i + shifts) % N]\\n                if candidate_cost < min_costs[i]:\\n                    cost -= min_costs[i] - candidate_cost\\n                    min_costs[i] = candidate_cost\\n            return cost \\n\\n        for i in range(N):            \\n            result = min(result, total_cost + i * x)\\n            total_cost = update_costs(i+1)\\n                \\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625494,
                "title": "python-medium-dp",
                "content": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        N = len(nums)\\n        dp = nums.copy()\\n        ans = float(\"inf\")\\n\\n        for i in range(N):\\n            for j in range(N):\\n                dp[j] = min(dp[j], nums[j - i])\\n\\n            ans = min(ans, sum(dp) + i * x)\\n\\n\\n        return ans\\n\\n\\n            \\n        \\n        \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        N = len(nums)\\n        dp = nums.copy()\\n        ans = float(\"inf\")\\n\\n        for i in range(N):\\n            for j in range(N):\\n                dp[j] = min(dp[j], nums[j - i])\\n\\n            ans = min(ans, sum(dp) + i * x)\\n\\n\\n        return ans\\n\\n\\n            \\n        \\n        \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625475,
                "title": "logical-approach-greedy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- when will we move to `ith step` if **total money I have spend to reach ith step** is less than total profit i am making by reduing overall cost if i reach to that state.\\n- `(totalProfit>=fuelCost)`.\\n- if u alredy paid to read 4th step and want to move to 5th state ,how much will be fuelCost = x*5-x*4 or **prevState-currState**\\n- `fuelCost=currCost-prevCost`\\n- totalProfit : if cost to pick an iteam at ith shift is less than what its price to pick in previous state(effecient one).\\n- `totalPrice=max(cost[j]-cost[effectiveJ],0)`\\n- look at code now everything will be clear now.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- $$O(N^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n-  $$O(N)$$\\n\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) \\n    {\\n\\n        ll finalAnswer=0;\\n        ll n=nums.size();\\n        vector<ll>cost(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            cost[i]=nums[i];\\n            finalAnswer+=cost[i];\\n        } \\n        ll prevCost=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            ll profit=0;\\n            ll currCost=i*1ll*x;\\n            for(int j=0;j<n;j++)\\n            {\\n                int jeff=(j-i+n)%n;\\n                if (cost[j]>nums[jeff])\\n                {\\n                    profit+=cost[j]-nums[jeff];\\n                }\\n            }\\n            if (profit>=currCost-prevCost)\\n            {\\n                for(int j=0;j<n;j++)\\n                {\\n                    int jeff=(j-i+n)%n;\\n                    if (cost[j]>nums[jeff])\\n                    {\\n                        cost[j]=nums[jeff];\\n                    }\\n                }\\n                finalAnswer-=profit-(currCost-prevCost);\\n                prevCost=currCost;\\n            }\\n            // cout<<finalAnswer<<\"\\\\n\";\\n        } \\n        return finalAnswer;  \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) \\n    {\\n\\n        ll finalAnswer=0;\\n        ll n=nums.size();\\n        vector<ll>cost(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            cost[i]=nums[i];\\n            finalAnswer+=cost[i];\\n        } \\n        ll prevCost=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            ll profit=0;\\n            ll currCost=i*1ll*x;\\n            for(int j=0;j<n;j++)\\n            {\\n                int jeff=(j-i+n)%n;\\n                if (cost[j]>nums[jeff])\\n                {\\n                    profit+=cost[j]-nums[jeff];\\n                }\\n            }\\n            if (profit>=currCost-prevCost)\\n            {\\n                for(int j=0;j<n;j++)\\n                {\\n                    int jeff=(j-i+n)%n;\\n                    if (cost[j]>nums[jeff])\\n                    {\\n                        cost[j]=nums[jeff];\\n                    }\\n                }\\n                finalAnswer-=profit-(currCost-prevCost);\\n                prevCost=currCost;\\n            }\\n            // cout<<finalAnswer<<\"\\\\n\";\\n        } \\n        return finalAnswer;  \\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3625351,
                "title": "java-easy-to-understand-solution-100-beats",
                "content": "\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minCost(int[] nums, int x) {\\n        int n = nums.length;\\n\\n        long sum = 0;\\n        long temp[] = new long[n];\\n\\n        for(int i = 0 ; i < nums.length ; i++){\\n            sum += nums[i];\\n            temp[i] = nums[i];\\n        }\\n\\n        for(int rotation = 1; rotation < n ; rotation++ ){\\n            long cost = 1L * rotation * x;\\n\\n            for(int i = 0 ; i < n ; i++){\\n                long val = nums[(rotation+i)% n];\\n                temp[i] = Math.min(temp[i],val);\\n                cost += temp[i];\\n            }\\n\\n            sum = Math.min(sum,cost);\\n        }\\n        return sum;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long minCost(int[] nums, int x) {\\n        int n = nums.length;\\n\\n        long sum = 0;\\n        long temp[] = new long[n];\\n\\n        for(int i = 0 ; i < nums.length ; i++){\\n            sum += nums[i];\\n            temp[i] = nums[i];\\n        }\\n\\n        for(int rotation = 1; rotation < n ; rotation++ ){\\n            long cost = 1L * rotation * x;\\n\\n            for(int i = 0 ; i < n ; i++){\\n                long val = nums[(rotation+i)% n];\\n                temp[i] = Math.min(temp[i],val);\\n                cost += temp[i];\\n            }\\n\\n            sum = Math.min(sum,cost);\\n        }\\n        return sum;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625322,
                "title": "javascript-try-all-rotations",
                "content": "**Solution: Try All Rotations**\\n\\nKeep track of the minimum state of `nums[i]` for any number of rotations <= `r`.\\nFind the number of rotations which results in the minimum total cost: `(x * rotations) + sum of min cost of each nums[i]` for every `i`\\n\\nTime Complexity: `O(n^2)` \\nSpace Complexity: `O(n)`\\n```\\nvar minCost = function(nums, x) {\\n  let n = nums.length, ans = Array(n).fill(0);\\n  for (let i = 0; i < n; i++) {\\n    let currMinCost = Infinity;\\n    for (let r = 0; r < n; r++) { // number of rotations\\n      let cost = nums[((i - r) + n) % n];\\n      currMinCost = Math.min(currMinCost, cost);\\n      ans[r] += currMinCost;\\n    }\\n  }\\n  let res = Infinity;\\n  for (let r = 0; r < n; r++) {\\n    let rotationCost = x * r;\\n    res = Math.min(res, ans[r] + rotationCost);\\n  }\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minCost = function(nums, x) {\\n  let n = nums.length, ans = Array(n).fill(0);\\n  for (let i = 0; i < n; i++) {\\n    let currMinCost = Infinity;\\n    for (let r = 0; r < n; r++) { // number of rotations\\n      let cost = nums[((i - r) + n) % n];\\n      currMinCost = Math.min(currMinCost, cost);\\n      ans[r] += currMinCost;\\n    }\\n  }\\n  let res = Infinity;\\n  for (let r = 0; r < n; r++) {\\n    let rotationCost = x * r;\\n    res = Math.min(res, ans[r] + rotationCost);\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3625261,
                "title": "o-n-2-solution-c",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        long long ans=LONG_MAX;\\n        for(int i=0;i<n;i++)\\n            nums.push_back(nums[i]);\\n        vector<int> temp(n,INT_MAX);\\n        for(int i=0;i<n;i++){\\n            long long sum=0;\\n            for(int j=0;j<n;j++){\\n                temp[j]=min(temp[j],nums[i+j]);\\n                sum+=temp[j];\\n            }\\n            sum+=1ll*i*x;\\n            ans=min(ans,sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        long long ans=LONG_MAX;\\n        for(int i=0;i<n;i++)\\n            nums.push_back(nums[i]);\\n        vector<int> temp(n,INT_MAX);\\n        for(int i=0;i<n;i++){\\n            long long sum=0;\\n            for(int j=0;j<n;j++){\\n                temp[j]=min(temp[j],nums[i+j]);\\n                sum+=temp[j];\\n            }\\n            sum+=1ll*i*x;\\n            ans=min(ans,sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625225,
                "title": "easy-c-solution-n-2-solution",
                "content": "```\\n  long long minCost(vector<int>& nums, int x) {\\n        vector<int>temp=nums;\\n        int len=nums.size();\\n        vector<int>mn(len,1e9);\\n        long long ans=LONG_MAX;\\n        for(long long  i=0;i<len;i++){\\n            long long sum=0;\\n            for(int j=0;j<len;j++){\\n                int val=min(nums[j],nums[(j+i)%len]);\\n                mn[j]=min(mn[j],val);\\n              \\n                sum+=(long long)mn[j];\\n            }\\n            ans=min(ans,sum+(long long )x*i);\\n          \\n        }\\n        return ans;\\n    }\\n\\t\\n```",
                "solutionTags": [],
                "code": "```\\n  long long minCost(vector<int>& nums, int x) {\\n        vector<int>temp=nums;\\n        int len=nums.size();\\n        vector<int>mn(len,1e9);\\n        long long ans=LONG_MAX;\\n        for(long long  i=0;i<len;i++){\\n            long long sum=0;\\n            for(int j=0;j<len;j++){\\n                int val=min(nums[j],nums[(j+i)%len]);\\n                mn[j]=min(mn[j],val);\\n              \\n                sum+=(long long)mn[j];\\n            }\\n            ans=min(ans,sum+(long long )x*i);\\n          \\n        }\\n        return ans;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3625043,
                "title": "intuitive-dp-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal is to find how many rotate that we need to perform.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse DP\\n\\n# Complexity\\n- Time complexity: $O(n^2)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n^2)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    using ll = long long;\\n    const ll MAXN = numeric_limits<ll>::max();\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n       // We will use DP.\\n       // dp[element id][rotate number] = minimum cost to buy element id\\n        int n = nums.size();\\n       vector<vector<ll>> dp(n, vector<ll>(n, MAXN));\\n\\n        // The goal is to find how many rotate that we need to perform.\\n        // dp[element id][max rorate number] = minimum cost to buy element id\\n       for (int i = 0; i < n; ++i) {\\n           dp[i][0] = (ll)nums[i];\\n           for (int j = 1; j < n; ++j) {\\n               // don\\'t need rotate or need rotate\\n               dp[i][j] = min(dp[i][j-1], (ll)nums[(i+j)%n]);\\n           }\\n       }\\n\\n        ll ans = MAXN;\\n        for (int i = 0; i < n; ++i) {\\n            ll tmp = 0;\\n            // for each maximum rotate number, find the corresponding cost.\\n            for (int j = 0; j < n; ++j) {\\n                tmp += dp[j][i];\\n            }\\n            ans = min(ans, tmp + 1LL * (ll)i * (ll)x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    using ll = long long;\\n    const ll MAXN = numeric_limits<ll>::max();\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n       // We will use DP.\\n       // dp[element id][rotate number] = minimum cost to buy element id\\n        int n = nums.size();\\n       vector<vector<ll>> dp(n, vector<ll>(n, MAXN));\\n\\n        // The goal is to find how many rotate that we need to perform.\\n        // dp[element id][max rorate number] = minimum cost to buy element id\\n       for (int i = 0; i < n; ++i) {\\n           dp[i][0] = (ll)nums[i];\\n           for (int j = 1; j < n; ++j) {\\n               // don\\'t need rotate or need rotate\\n               dp[i][j] = min(dp[i][j-1], (ll)nums[(i+j)%n]);\\n           }\\n       }\\n\\n        ll ans = MAXN;\\n        for (int i = 0; i < n; ++i) {\\n            ll tmp = 0;\\n            // for each maximum rotate number, find the corresponding cost.\\n            for (int j = 0; j < n; ++j) {\\n                tmp += dp[j][i];\\n            }\\n            ans = min(ans, tmp + 1LL * (ll)i * (ll)x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625022,
                "title": "c-simple-brute-force-tc-o-n-2-sc-o-n",
                "content": "# Complexity\\n- Time complexity: O(N^2)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<int> mincost(n,INT_MAX);\\n        ll ans=1e18;;\\n        for(int i=0;i<n;i++){\\n            ll totalcost=0;\\n            for(int j=0;j<n;j++){\\n                int shift=(j+i)%n;\\n                mincost[j]=min(mincost[j],nums[shift]);\\n                totalcost+=mincost[j];\\n            }\\n            ans=min(ans,totalcost+(i*(ll)x));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<int> mincost(n,INT_MAX);\\n        ll ans=1e18;;\\n        for(int i=0;i<n;i++){\\n            ll totalcost=0;\\n            for(int j=0;j<n;j++){\\n                int shift=(j+i)%n;\\n                mincost[j]=min(mincost[j],nums[shift]);\\n                totalcost+=mincost[j];\\n            }\\n            ans=min(ans,totalcost+(i*(ll)x));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624985,
                "title": "easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n   void leftRotate(vector<int> &arr, int d, int n)\\n{\\n    d = d % n;\\n    int g_c_d = gcd(d, n);\\n    for (int i = 0; i < g_c_d; i++) {\\n        int temp = arr[i];\\n        int j = i;\\n \\n        while (1) {\\n            int k = j + d;\\n            if (k >= n)\\n                k = k - n;\\n \\n            if (k == i)\\n                break;\\n \\n            arr[j] = arr[k];\\n            j = k;\\n        }\\n        arr[j] = temp;\\n    }\\n}\\n\\n\\n    long long minCost(vector<int>& nums, int x) {\\n        vector<int> cost = nums;\\n        int n = nums.size();\\n        long long total_cost = accumulate(nums.begin(), nums.end(), (long long)0);\\n        // cout<<0<<\" \"<<total_cost<<endl;\\n        for(int i = 1; i < n; i++){\\n            leftRotate(nums, 1, nums.size());\\n            long long temp_cost = i * (long long)x;\\n            for(int j = 0; j < n; j++){\\n                if(nums[j] < cost[j])\\n                    cost[j] = nums[j];\\n\\n                temp_cost += cost[j];\\n            }\\n            total_cost = min(total_cost, temp_cost);\\n            // cout<<i<<\" \"<<total_cost<<endl;\\n        }\\n        return total_cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n   void leftRotate(vector<int> &arr, int d, int n)\\n{\\n    d = d % n;\\n    int g_c_d = gcd(d, n);\\n    for (int i = 0; i < g_c_d; i++) {\\n        int temp = arr[i];\\n        int j = i;\\n \\n        while (1) {\\n            int k = j + d;\\n            if (k >= n)\\n                k = k - n;\\n \\n            if (k == i)\\n                break;\\n \\n            arr[j] = arr[k];\\n            j = k;\\n        }\\n        arr[j] = temp;\\n    }\\n}\\n\\n\\n    long long minCost(vector<int>& nums, int x) {\\n        vector<int> cost = nums;\\n        int n = nums.size();\\n        long long total_cost = accumulate(nums.begin(), nums.end(), (long long)0);\\n        // cout<<0<<\" \"<<total_cost<<endl;\\n        for(int i = 1; i < n; i++){\\n            leftRotate(nums, 1, nums.size());\\n            long long temp_cost = i * (long long)x;\\n            for(int j = 0; j < n; j++){\\n                if(nums[j] < cost[j])\\n                    cost[j] = nums[j];\\n\\n                temp_cost += cost[j];\\n            }\\n            total_cost = min(total_cost, temp_cost);\\n            // cout<<i<<\" \"<<total_cost<<endl;\\n        }\\n        return total_cost;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3624941,
                "title": "golang-try-all-possible-rotations",
                "content": "# Code\\n```\\nfunc minCost(nums []int, x int) int64 {\\n  var res int64\\n  for _, num := range nums {\\n    res += int64(num)\\n  }\\n  n := len(nums)\\n  for rotations := 1; rotations < n; rotations++ {\\n    cost := make([]int, n)\\n    // for each position, let\\'s get the minimum cost based on allowed rotations\\n    for i := 0; i < n; i++ {\\n      cost[i] = nums[i]\\n      allowed := rotations\\n      for j := i-1; j >= 0 && allowed > 0; j, allowed = j-1, allowed-1 {\\n        if nums[j] < cost[i] {\\n          cost[i] = nums[j]\\n        }\\n      }\\n      for j := n-1; j >= 0 && allowed > 0; j, allowed = j-1, allowed-1 {\\n        if nums[j] < cost[i] {\\n          cost[i] = nums[j]\\n        }\\n      }\\n    }\\n    var tot int64\\n    for i := 0; i < len(cost); i++ {\\n      tot += int64(cost[i])\\n    }\\n    res = min(res, tot + int64(x * rotations))\\n  }\\n  return res\\n}\\n\\nfunc min(a, b int64) int64 {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minCost(nums []int, x int) int64 {\\n  var res int64\\n  for _, num := range nums {\\n    res += int64(num)\\n  }\\n  n := len(nums)\\n  for rotations := 1; rotations < n; rotations++ {\\n    cost := make([]int, n)\\n    // for each position, let\\'s get the minimum cost based on allowed rotations\\n    for i := 0; i < n; i++ {\\n      cost[i] = nums[i]\\n      allowed := rotations\\n      for j := i-1; j >= 0 && allowed > 0; j, allowed = j-1, allowed-1 {\\n        if nums[j] < cost[i] {\\n          cost[i] = nums[j]\\n        }\\n      }\\n      for j := n-1; j >= 0 && allowed > 0; j, allowed = j-1, allowed-1 {\\n        if nums[j] < cost[i] {\\n          cost[i] = nums[j]\\n        }\\n      }\\n    }\\n    var tot int64\\n    for i := 0; i < len(cost); i++ {\\n      tot += int64(cost[i])\\n    }\\n    res = min(res, tot + int64(x * rotations))\\n  }\\n  return res\\n}\\n\\nfunc min(a, b int64) int64 {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3624888,
                "title": "python-easy-to-understand-solution",
                "content": "My wrote my code during competition without optimizing it.\\nI believe it is easy to understand.\\n\\nWith more rotation steps (t), each chocolate type (i) can achieve lower cost, which is min_dp[i]. \\n\\nTime: O(N^2)\\nSpace: O(N)\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        ans = float(\\'inf\\')\\n        n = len(nums)\\n        min_dp = nums[:]\\n        for t in range(0, n):        \\n            for i in range(0, n):\\n                min_dp[i] = min(min_dp[i], nums[i-t])\\n            ans = min(ans, sum(min_dp) + t*x)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        ans = float(\\'inf\\')\\n        n = len(nums)\\n        min_dp = nums[:]\\n        for t in range(0, n):        \\n            for i in range(0, n):\\n                min_dp[i] = min(min_dp[i], nums[i-t])\\n            ans = min(ans, sum(min_dp) + t*x)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624694,
                "title": "dynamic-programming-rotate-and-check-easy-to-understand",
                "content": "Basically the transition of the dp chooses the minimal value between commiting the particular operation and the cost incurred in not commiting the particular operation, and compromise using the previously used operations.\\n\\n```\\n#define ll long long\\nclass Solution {\\n    long long dp[1010][1010]; // operations,index\\npublic:\\n    long long minCost(vector<int>& a, int x) {\\n        \\n        int n = a.size();\\n        ll ans = 1e15;\\n        \\n        dp[0][0] = 0;\\n        \\n        for(ll i=1;i<=n;i++)\\n        {\\n            dp[i][0] = dp[i-1][0] + x;\\n            dp[0][i] = a[i-1];\\n        }\\n        \\n        for(ll op=1;op<=n;op++)\\n        {\\n            for(int i=1;i<=n;i++)\\n            {\\n                dp[op][i] = min(dp[op - 1][i], 1ll * a[(i - op - 1 + 2*n) % n]);\\n            }\\n        }\\n        \\n        \\n        for(int op=0;op<=n;op++)\\n        {\\n            ll tmp = 0;\\n            \\n            for(int i=0;i<=n;i++)\\n                tmp += dp[op][i];\\n            \\n            ans = min(ans,tmp);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\n    long long dp[1010][1010]; // operations,index\\npublic:\\n    long long minCost(vector<int>& a, int x) {\\n        \\n        int n = a.size();\\n        ll ans = 1e15;\\n        \\n        dp[0][0] = 0;\\n        \\n        for(ll i=1;i<=n;i++)\\n        {\\n            dp[i][0] = dp[i-1][0] + x;\\n            dp[0][i] = a[i-1];\\n        }\\n        \\n        for(ll op=1;op<=n;op++)\\n        {\\n            for(int i=1;i<=n;i++)\\n            {\\n                dp[op][i] = min(dp[op - 1][i], 1ll * a[(i - op - 1 + 2*n) % n]);\\n            }\\n        }\\n        \\n        \\n        for(int op=0;op<=n;op++)\\n        {\\n            ll tmp = 0;\\n            \\n            for(int i=0;i<=n;i++)\\n                tmp += dp[op][i];\\n            \\n            ans = min(ans,tmp);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624639,
                "title": "brute-greedy",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        long long minCost(vector<int> &nums, int x)\\n        {\\n            int n = nums.size();\\n            vector<int> checked(n, INT_MAX);\\n            vector<int> numsCircular(nums.begin(), nums.end());\\n\\n            for (auto it: nums)\\n                numsCircular.push_back(it);\\n\\n            long long ans = LONG_MAX;\\n\\n            for (int rt = 0; rt < n; rt++)\\n            {\\n                long long sum = 0;\\n                for (int j = 0; j < n; j++)\\n                {\\n                    if (checked[j] > numsCircular[j + rt])\\n                        checked[j] = numsCircular[j + rt];\\n                    sum += checked[j];\\n                }\\n                sum += ((long long) rt *(long long) x);\\n                ans = min(ans, sum);\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        long long minCost(vector<int> &nums, int x)\\n        {\\n            int n = nums.size();\\n            vector<int> checked(n, INT_MAX);\\n            vector<int> numsCircular(nums.begin(), nums.end());\\n\\n            for (auto it: nums)\\n                numsCircular.push_back(it);\\n\\n            long long ans = LONG_MAX;\\n\\n            for (int rt = 0; rt < n; rt++)\\n            {\\n                long long sum = 0;\\n                for (int j = 0; j < n; j++)\\n                {\\n                    if (checked[j] > numsCircular[j + rt])\\n                        checked[j] = numsCircular[j + rt];\\n                    sum += checked[j];\\n                }\\n                sum += ((long long) rt *(long long) x);\\n                ans = min(ans, sum);\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624593,
                "title": "easier-than-i-thought-i-was-just-upset-during-contest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<long long> vals(n);\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+=nums[i];\\n            vals[i]=nums[i];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                vals[j]=min(vals[j],(long long)nums[(i+j)%n]);\\n            }\\n            long long temp=0;\\n            for(auto v:vals)temp+=v;\\n            ans=min(ans,temp+(long long)i*x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<long long> vals(n);\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            ans+=nums[i];\\n            vals[i]=nums[i];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                vals[j]=min(vals[j],(long long)nums[(i+j)%n]);\\n            }\\n            long long temp=0;\\n            for(auto v:vals)temp+=v;\\n            ans=min(ans,temp+(long long)i*x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624588,
                "title": "a-easy-python-solution",
                "content": "# Approach\\n1. Check the base cases:\\n- If the input array nums is empty, return `None`.\\n- If the length of nums is 1, return the single element as it represents the cost of collecting the only type of chocolate.\\n2. Initialize variables:\\n- `ans` to keep track of the minimum cost. Set it to the sum of all elements in `nums` initially.\\n- `offset` to keep track of the number of operations performed. Initialize it to 0.\\n- `min_nums` to store the minimum values encountered for each index. Initialize it with the original nums array.\\n3. Iterate while `offset` is less than the length of nums:\\n- Increment `offset` by 1.\\n- Perform the operation by shifting the elements in nums one position to the left and setting the last element to the value of the first element.\\n- Update `min_nums` by taking the minimum between the corresponding elements of `min_nums` and `nums`.\\n- Calculate the cost for the current operation by summing all the elements in `min_nums` and adding `offset * x` to account for the cost of the operation.\\n- Update `ans` with the minimum between the current `ans` and the calculated cost.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        if nums == []: return None\\n        if len(nums) == 1: return nums[0]\\n\\n        ans, offset, min_nums = sum(nums), 0, nums\\n        while offset < len(nums):\\n            offset += 1\\n            nums = nums[1:] + [nums[0]]\\n            min_nums = [min(min_nums[i], nums[i]) for i in range(len(nums))]\\n            ans = min(ans, sum(min_nums)+offset*x)\\n        return ans\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        if nums == []: return None\\n        if len(nums) == 1: return nums[0]\\n\\n        ans, offset, min_nums = sum(nums), 0, nums\\n        while offset < len(nums):\\n            offset += 1\\n            nums = nums[1:] + [nums[0]]\\n            min_nums = [min(min_nums[i], nums[i]) for i in range(len(nums))]\\n            ans = min(ans, sum(min_nums)+offset*x)\\n        return ans\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624572,
                "title": "simple-bruteforce-check-c-constraints-allow-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncheck for value of minimum value of a cell after each rotation\\nthen take sum of these value and add rotation cost to the sum.\\ni*x is the rotation cost for nth rotation\\nwe return the minimum of such values\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        long long final=1e13;\\n        vector<long long>arr(nums.size(),1e10);\\n        for(int i=0;i<=nums.size();i++){\\n            long long sum=0;\\n            for(int j=0;j<nums.size();j++){\\n                 arr[j]=min(arr[j],(long long)nums[ (j+i)%nums.size()]);\\n                 sum+=arr[j];\\n            }\\n          final=min(final,sum+ (long long)i*x);\\n        }\\n        return final;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        long long final=1e13;\\n        vector<long long>arr(nums.size(),1e10);\\n        for(int i=0;i<=nums.size();i++){\\n            long long sum=0;\\n            for(int j=0;j<nums.size();j++){\\n                 arr[j]=min(arr[j],(long long)nums[ (j+i)%nums.size()]);\\n                 sum+=arr[j];\\n            }\\n          final=min(final,sum+ (long long)i*x);\\n        }\\n        return final;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624504,
                "title": "java-easy-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public long minCost(int[] nums, int x) {\\n    int n = nums.length;\\n\\n    long num[] = new long[n];\\n    long p[] = new long[n<<1];\\n    for(int i = 0, j = n; i != n; ++i, ++j) p[i] = p[j] = num[i] = nums[i];\\n\\n    long ans = Long.MAX_VALUE, c = 0, sum = 0;\\n    for(int i = 0; i != n; ++i, sum = c += x){\\n      for(int j = n, z = 0; j != p.length; ++j, ++z)\\n        sum += (num[z] = Math.min(num[z], p[j-i]));\\n      \\n      if(sum <= ans) ans = sum;\\n      else break;\\n    }\\n      \\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public long minCost(int[] nums, int x) {\\n    int n = nums.length;\\n\\n    long num[] = new long[n];\\n    long p[] = new long[n<<1];\\n    for(int i = 0, j = n; i != n; ++i, ++j) p[i] = p[j] = num[i] = nums[i];\\n\\n    long ans = Long.MAX_VALUE, c = 0, sum = 0;\\n    for(int i = 0; i != n; ++i, sum = c += x){\\n      for(int j = n, z = 0; j != p.length; ++j, ++z)\\n        sum += (num[z] = Math.min(num[z], p[j-i]));\\n      \\n      if(sum <= ans) ans = sum;\\n      else break;\\n    }\\n      \\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624425,
                "title": "easy-java-solution-with-explanation-o-n-2",
                "content": "### ```Up vote if you like the solution```\\n\\n# Intuition\\nTo solve this problem we need to find the minimum cost (we can rotate any number of time), for each rotation we need to calculate the cost\\n\\n# Approach\\n1. Outer forloop is for each rotation.\\n2. inner for loop is where we will store the min value for particular index untill ith rotation.\\n3. (1L * i * x) is to add the cost for i rotations.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n0(n) - as we are crating the min array of length n to keep track of min value after rotation\\n\\n# Code\\n```\\nclass Solution {\\n    public long minCost(int[] nums, int x) {\\n        long ans = 0;\\n        int n = nums.length;\\n        long[] min = new long[n];\\n        for(int i = 0;i < n; i++){\\n            ans+=nums[i];\\n            min[i] = nums[i];\\n        }\\n        for(int i = 1; i<n;i++){\\n            long cost = 1L * i * x;\\n            for(int j=0;j<n;j++){\\n                long val = nums[(i+j)%n];\\n                min[j]=Math.min(min[j], val);\\n                cost+=min[j];\\n            }\\n            ans = Math.min(ans,cost);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Up vote if you like the solution```\n```\\nclass Solution {\\n    public long minCost(int[] nums, int x) {\\n        long ans = 0;\\n        int n = nums.length;\\n        long[] min = new long[n];\\n        for(int i = 0;i < n; i++){\\n            ans+=nums[i];\\n            min[i] = nums[i];\\n        }\\n        for(int i = 1; i<n;i++){\\n            long cost = 1L * i * x;\\n            for(int j=0;j<n;j++){\\n                long val = nums[(i+j)%n];\\n                min[j]=Math.min(min[j], val);\\n                cost+=min[j];\\n            }\\n            ans = Math.min(ans,cost);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624409,
                "title": "simple-easy-solution-in-c-o-n2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n           long long ans=0,sum=0;\\n        for(int i=1;i<=nums.size();i++){\\n            sum+=nums[i-1];\\n        }\\n        ans=sum;\\n        for(int i=1;i<=nums.size();i++){\\n         long long m=nums[0];\\n           for(int j=0;j<nums.size();j++){\\n               if(j!=nums.size()-1){\\n                   sum-=nums[j];\\n                   sum+=min(nums[j],nums[j+1]);\\n                   nums[j]=min(nums[j],nums[j+1]);\\n               }\\n               else{\\n                   sum-=nums[j];\\n                   sum+=min(1LL*nums[j],m);\\n                   nums[j]=min(1LL*nums[j],m);\\n                   \\n                   \\n               }\\n               ans=min(ans,sum+1LL*i*x);\\n           } \\n            \\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n           long long ans=0,sum=0;\\n        for(int i=1;i<=nums.size();i++){\\n            sum+=nums[i-1];\\n        }\\n        ans=sum;\\n        for(int i=1;i<=nums.size();i++){\\n         long long m=nums[0];\\n           for(int j=0;j<nums.size();j++){\\n               if(j!=nums.size()-1){\\n                   sum-=nums[j];\\n                   sum+=min(nums[j],nums[j+1]);\\n                   nums[j]=min(nums[j],nums[j+1]);\\n               }\\n               else{\\n                   sum-=nums[j];\\n                   sum+=min(1LL*nums[j],m);\\n                   nums[j]=min(1LL*nums[j],m);\\n                   \\n                   \\n               }\\n               ans=min(ans,sum+1LL*i*x);\\n           } \\n            \\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624381,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  long long minCost(const vector<int> &nums, const int x) {\\n    const int n = static_cast<int>(nums.size());\\n    int collected[n];\\n    fill(collected, collected + n, numeric_limits<int>::max());\\n    long long ret = numeric_limits<long long>::max();\\n    \\n    for (int move = 0; move < n; ++move) {\\n      long long cost = static_cast<long long>(move) * x;\\n      for (int i = 0; i < n; ++i) {\\n        collected[i] = min(collected[i], nums[(i + move) % n]);\\n        cost += collected[i];\\n      }\\n      ret = min(ret, cost);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  long long minCost(const vector<int> &nums, const int x) {\\n    const int n = static_cast<int>(nums.size());\\n    int collected[n];\\n    fill(collected, collected + n, numeric_limits<int>::max());\\n    long long ret = numeric_limits<long long>::max();\\n    \\n    for (int move = 0; move < n; ++move) {\\n      long long cost = static_cast<long long>(move) * x;\\n      for (int i = 0; i < n; ++i) {\\n        collected[i] = min(collected[i], nums[(i + move) % n]);\\n        cost += collected[i];\\n      }\\n      ret = min(ret, cost);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624368,
                "title": "100-beats-simple-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFix number of operations  to be i then find find find min for all possible nums[j] after i operations \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n);\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n100% memory  // O(1);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n         long long ans=0,sum=0;\\n        for(int i=1;i<=nums.size();i++){\\n            sum+=nums[i-1];\\n        }\\n        ans=sum;\\n        for(int i=1;i<=nums.size();i++){\\n         long long m=nums[0];\\n           for(int j=0;j<nums.size();j++){\\n               if(j!=nums.size()-1){\\n                   sum-=nums[j];\\n                   sum+=min(nums[j],nums[j+1]);\\n                   nums[j]=min(nums[j],nums[j+1]);\\n               }\\n               else{\\n                   sum-=nums[j];\\n                   sum+=min(1LL*nums[j],m);\\n                   nums[j]=min(1LL*nums[j],m);\\n                   \\n                   \\n               }\\n               ans=min(ans,sum+1LL*i*x);\\n           } \\n            \\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n         long long ans=0,sum=0;\\n        for(int i=1;i<=nums.size();i++){\\n            sum+=nums[i-1];\\n        }\\n        ans=sum;\\n        for(int i=1;i<=nums.size();i++){\\n         long long m=nums[0];\\n           for(int j=0;j<nums.size();j++){\\n               if(j!=nums.size()-1){\\n                   sum-=nums[j];\\n                   sum+=min(nums[j],nums[j+1]);\\n                   nums[j]=min(nums[j],nums[j+1]);\\n               }\\n               else{\\n                   sum-=nums[j];\\n                   sum+=min(1LL*nums[j],m);\\n                   nums[j]=min(1LL*nums[j],m);\\n                   \\n                   \\n               }\\n               ans=min(ans,sum+1LL*i*x);\\n           } \\n            \\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624362,
                "title": "easy-c-solution-tc-o-n-2-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo this was quite a tricky problem, many think that the test cases are wrong/mis-leading but they are actully correct. The costs of the chocolates in each rotation are left shifted(according to problem statement), the indexes are right shited (in the test case 1). So they are basically the same. My explanation is using the approach of right shifting the indexes at each rotation.\\n\\nThe main question is in which iteration (rotation) should I pick a particular chocolate to get minimum cost? \\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInstead let us check what is the minimum possible cost after **\\'i\\'** rotations. So let me take the case where we have done **\\'i\\'** rotations.\\nSo the cost to perform **\\'i\\'** rotations is **i*x**.\\n\\nThe minimum cost to pick a chocolate **\\'j\\'** after **\\'i\\'** rotations is? (Try to think of this on your own)\\n\\n\\n\\nAnswer :- \\nLet us see what all the are costs incurred to pick the chocolate **\\'j\\'** from iteration 0 to i . The costs will be \\n{ nums[j] , nums[(j+1)%n], nums[(j+2)%n], .... , nums[(j+i)%n]}\\n\\n*%n beacuse we are right shifting the indexes and we want it to be circular*\\n\\nSo to get the minimum cost to pick chocolate **\\'j\\'** on or before **\\'i\\'** rotations is basically \\n**min** (  { nums[j] , nums[(j+1)%n], nums[(j+2)%n], .... , nums[(j+i)%n]}  )\\n\\n\\nHence the minimum cost assuming that all the chocolates are picked on or before **\\'i\\'th** rotation is :- \\n**i*x + ({summation for all indices j going from 0 to n-1 } **min** (  { nums[j] , nums[(j+1)%n], nums[(j+2)%n], .... , nums[(j+i)%n]}  )  )**\\n\\nAnd since we know that after n rotations the array is same as initial , we only have to do n-1 rotations.\\nWe now have to find the minimum of the costs in each rotation.\\n\\n\\nHere the **val** array holds the minimum cost to pick chocolate **j** on or before **\\'i\\' th** rotation.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        long long ans = LLONG_MAX;\\n        int n = nums.size();\\n        vector<int> val(n);\\n        for(int i = 0; i < n; i++)val[i]=nums[i];\\n        for(int i = 0; i < n; i++) {\\n            long long cur = 0;\\n            for(int j = 0; j < n; j++) {\\n                cur += val[j];\\n                val[j]=min(val[j], nums[(i+j+1)%n]);\\n            }\\n            ans =min(ans,cur+1ll*i*x);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\\nTried My best to explain in an easy way.\\nPlease **Upvote** if this was useful.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        long long ans = LLONG_MAX;\\n        int n = nums.size();\\n        vector<int> val(n);\\n        for(int i = 0; i < n; i++)val[i]=nums[i];\\n        for(int i = 0; i < n; i++) {\\n            long long cur = 0;\\n            for(int j = 0; j < n; j++) {\\n                cur += val[j];\\n                val[j]=min(val[j], nums[(i+j+1)%n]);\\n            }\\n            ans =min(ans,cur+1ll*i*x);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624356,
                "title": "c-video",
                "content": "\\n    using ll = long long;\\n    class Solution {\\n    public:\\n    long long minCost(vector<int>& nums, int x) {\\n        \\n        int n = nums.size();\\n        ll ans = LONG_MAX;\\n\\n        vector<int> m(n, INT_MAX);\\n\\n        for(int r = 0; r <= n-1; ++r) {\\n            ll res = (ll)r *x;\\n\\n            for(int i = 0; i <n; ++i) {\\n                m[i] = min(m[i], nums[(i+ r) % n]);\\n                res += m[i];\\n            }\\n            \\n            cout << res << endl;\\n            ans = min(ans, res);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\nhttps://youtu.be/SiRRVK5UUzs",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    long long minCost(vector<int>& nums, int x) {\\n        \\n        int n = nums.size();\\n        ll ans = LONG_MAX;\\n\\n        vector<int> m(n, INT_MAX);\\n\\n        for(int r = 0; r <= n-1; ++r) {\\n            ll res = (ll)r *x;\\n\\n            for(int i = 0; i <n; ++i) {\\n                m[i] = min(m[i], nums[(i+ r) % n]);\\n                res += m[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3624339,
                "title": "line-by-line-explanation-c",
                "content": "# Intuition\\nset your intital result as the given array and check after each iteration what can be the minimum and update your answer \\n\\n# Approach\\nmake a rotate function and do the iteration n-1 times and then udpate ans accordingly \\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   void rotate(vector<int> &nums){\\n       int n=nums.size();\\n       int temp=nums[n-1];\\n       for(int i=n-1; i>0; i--){\\n           nums[i]=nums[i-1];\\n       }\\n       nums[0]=temp;\\n   }\\n\\n    long long minCost(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<int> res(n);\\n        long long sum=0;\\n        for(int i=0; i<n; i++){\\n            res[i]=nums[i];\\n            sum+=res[i];\\n        }\\n        long long fans=sum;\\n        for(long long i=1; i<=n-1; i++){\\n            long long cost=i*x;\\n            rotate(nums);\\n            long long ans=0;\\n           for(int j=0; j<n; j++){\\n               res[j]=min(res[j],nums[j]);\\n               ans+=res[j];\\n           }\\n \\n           fans=min(ans+cost,fans);\\n\\n\\n        }\\n     return fans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   void rotate(vector<int> &nums){\\n       int n=nums.size();\\n       int temp=nums[n-1];\\n       for(int i=n-1; i>0; i--){\\n           nums[i]=nums[i-1];\\n       }\\n       nums[0]=temp;\\n   }\\n\\n    long long minCost(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<int> res(n);\\n        long long sum=0;\\n        for(int i=0; i<n; i++){\\n            res[i]=nums[i];\\n            sum+=res[i];\\n        }\\n        long long fans=sum;\\n        for(long long i=1; i<=n-1; i++){\\n            long long cost=i*x;\\n            rotate(nums);\\n            long long ans=0;\\n           for(int j=0; j<n; j++){\\n               res[j]=min(res[j],nums[j]);\\n               ans+=res[j];\\n           }\\n \\n           fans=min(ans+cost,fans);\\n\\n\\n        }\\n     return fans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624259,
                "title": "range-min-query-sparse-table",
                "content": "# Complexity\\n- Time complexity: $O(n.log(n))$\\n\\n- Space complexity: $O(n.log(n))$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntemplate<typename T>\\nclass RMQ {\\npublic:\\n    vector<vector<T>> st;\\n    function<T(T, T)> op;\\n    int n, m;\\n \\n    RMQ(const vector<T>& a, function<T(T, T)> _op) {\\n        n = (int)a.size(); m = __lg(n) + 1; // ceil(log(r - l + 1))\\n        st = vector<vector<T>>(n, vector<T>(m));\\n        op = _op;\\n        int p = 1;\\n        for(int j = 0; j < m; j++) {\\n            for(int i = 0; i + p - 1 < n; i++) {\\n                if(j == 0) st[i][j] = a[i];\\n                else st[i][j] = op(st[i][j - 1], st[i + (p >> 1)][j - 1]);\\n            }\\n            p *= 2;\\n        }\\n    }\\n \\n    T query(int l, int r) {\\n        int sz = __lg(r - l + 1); // floor(log(r - l + 1))\\n        return op(st[l][sz], st[r + 1 - (1 << sz)][sz]);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& a, int x) {\\n        const int n = (int)a.size();\\n        RMQ<int> rmq(a, [](int x, int y) -> int { return min(x, y); });\\n        \\n        long long ans = 1e18;\\n        for (int t = 0; t < n; t++) {\\n            long long res = x * 1LL * t;\\n            for (int i = 0; i < n; i++) {\\n                if (t > i) {\\n                    int left = t - i;\\n                    res += min(rmq.query(0, i), rmq.query(n - left, n - 1));\\n                } else {\\n                    res += rmq.query(i - t, i);\\n                }\\n            }\\n            ans = min(res, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntemplate<typename T>\\nclass RMQ {\\npublic:\\n    vector<vector<T>> st;\\n    function<T(T, T)> op;\\n    int n, m;\\n \\n    RMQ(const vector<T>& a, function<T(T, T)> _op) {\\n        n = (int)a.size(); m = __lg(n) + 1; // ceil(log(r - l + 1))\\n        st = vector<vector<T>>(n, vector<T>(m));\\n        op = _op;\\n        int p = 1;\\n        for(int j = 0; j < m; j++) {\\n            for(int i = 0; i + p - 1 < n; i++) {\\n                if(j == 0) st[i][j] = a[i];\\n                else st[i][j] = op(st[i][j - 1], st[i + (p >> 1)][j - 1]);\\n            }\\n            p *= 2;\\n        }\\n    }\\n \\n    T query(int l, int r) {\\n        int sz = __lg(r - l + 1); // floor(log(r - l + 1))\\n        return op(st[l][sz], st[r + 1 - (1 << sz)][sz]);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& a, int x) {\\n        const int n = (int)a.size();\\n        RMQ<int> rmq(a, [](int x, int y) -> int { return min(x, y); });\\n        \\n        long long ans = 1e18;\\n        for (int t = 0; t < n; t++) {\\n            long long res = x * 1LL * t;\\n            for (int i = 0; i < n; i++) {\\n                if (t > i) {\\n                    int left = t - i;\\n                    res += min(rmq.query(0, i), rmq.query(n - left, n - 1));\\n                } else {\\n                    res += rmq.query(i - t, i);\\n                }\\n            }\\n            ans = min(res, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624223,
                "title": "easy-solution-with-simple-intuition",
                "content": "# Intuition\\nJust use an extra vector to maintain the minimum value of particular index that we can get after all rotation of values and simultaneously find the total sum and maintain it with current total.\\n\\n# Approach\\nif you want, can share complete approach .\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n         int n = nums.size();\\n         long long total=0;\\n        vector<int> v(n,0);\\n        for(int i=0;i<n;i++){\\n            total+=nums[i];\\n            v[i]=nums[i];\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            long long a=0;\\n            for(int j=n-1;j>=0;j--){\\n                int b=j-i;\\n                if(b<0)\\n                    b=n+b;\\n                \\n                v[j]=min(v[j],nums[b]);\\n                a+=v[j];\\n            }\\n            a+=(long long)i*x;\\n            \\n            if(total>a)\\n                total=a;\\n        }\\n\\n    return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n         int n = nums.size();\\n         long long total=0;\\n        vector<int> v(n,0);\\n        for(int i=0;i<n;i++){\\n            total+=nums[i];\\n            v[i]=nums[i];\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            long long a=0;\\n            for(int j=n-1;j>=0;j--){\\n                int b=j-i;\\n                if(b<0)\\n                    b=n+b;\\n                \\n                v[j]=min(v[j],nums[b]);\\n                a+=v[j];\\n            }\\n            a+=(long long)i*x;\\n            \\n            if(total>a)\\n                total=a;\\n        }\\n\\n    return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624148,
                "title": "c-o-n-2-solution-using-minimum-with-rotation",
                "content": "```\\nlong long minCost(vector<int>& nums, int x) \\n{\\n\\tlong long result=1000000000000000000,n=nums.size(),total[n][n];\\n\\tfor(int i=0;i<n;i++)\\n\\t\\tfor(int j=0;j<n;j++) total[i][j]=1000000000000000000;\\n\\n\\tfor(int i=0;i<n;i++)\\n\\t{\\n\\t\\ttotal[i][0]=nums[i];\\n\\t\\tfor(int j=1;j<n;j++) total[i][j]=min(total[i][j-1],1ll*nums[(i-j+n)%n]);\\n\\t}\\n\\tfor(int i=0;i<n;i++)\\n\\t{\\n\\t\\tlong long c=1ll*x*i;\\n\\t\\tfor(int j=0;j<n;j++) c+=total[j][i];\\n\\t\\tresult=min(result,c);\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nlong long minCost(vector<int>& nums, int x) \\n{\\n\\tlong long result=1000000000000000000,n=nums.size(),total[n][n];\\n\\tfor(int i=0;i<n;i++)\\n\\t\\tfor(int j=0;j<n;j++) total[i][j]=1000000000000000000;\\n\\n\\tfor(int i=0;i<n;i++)\\n\\t{\\n\\t\\ttotal[i][0]=nums[i];\\n\\t\\tfor(int j=1;j<n;j++) total[i][j]=min(total[i][j-1],1ll*nums[(i-j+n)%n]);\\n\\t}\\n\\tfor(int i=0;i<n;i++)\\n\\t{\\n\\t\\tlong long c=1ll*x*i;\\n\\t\\tfor(int j=0;j<n;j++) c+=total[j][i];\\n\\t\\tresult=min(result,c);\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3624145,
                "title": "normally-calculate-the-sum-after-every-rotation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        long long cost = 0;\\n        vector<long long> ans (nums.size(),LLONG_MAX);\\n        long long final_ans = LLONG_MAX;\\n        // for every rotation i we will calculate its minimum sum\\n        for(int i = 0; i < nums.size(); i++) {\\n           // sum after ith rotation\\n            long long sum = 0;\\n            for(int j = 0; j < nums.size(); j++) {\\n                int y = (j - i);\\n                if(y < 0) y += nums.size(); \\n                if(ans[j] > nums[y]) ans[j] = nums[y];\\n                sum += ans[j];      \\n            }\\n            //update the final ans\\n            final_ans = min(fans, cost + sum);\\n            // update the cost\\n            cost += x;\\n        }\\n        return final_ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        long long cost = 0;\\n        vector<long long> ans (nums.size(),LLONG_MAX);\\n        long long final_ans = LLONG_MAX;\\n        // for every rotation i we will calculate its minimum sum\\n        for(int i = 0; i < nums.size(); i++) {\\n           // sum after ith rotation\\n            long long sum = 0;\\n            for(int j = 0; j < nums.size(); j++) {\\n                int y = (j - i);\\n                if(y < 0) y += nums.size(); \\n                if(ans[j] > nums[y]) ans[j] = nums[y];\\n                sum += ans[j];      \\n            }\\n            //update the final ans\\n            final_ans = min(fans, cost + sum);\\n            // update the cost\\n            cost += x;\\n        }\\n        return final_ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624127,
                "title": "simple-bruteforce-solution-array-rotation",
                "content": "I feel like Description of the question doesn\\'t match with the first example, helps me to get 2 WA :(\\n\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n =nums.size();\\n        long long sum=0,res=LONG_MAX;\\n        vector<long long> ans(n,LONG_MAX);\\n        for(int i=0;i<n;i++){\\n            sum=0;\\n            for(int j=0;j<n;j++){\\n                ans[j]=min((long long)ans[j],(long long)nums[(n-i+j)%n]);\\n                sum+=ans[j];\\n            }\\n            sum+=(1ll*i*x);\\n            res=min(res,sum);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n =nums.size();\\n        long long sum=0,res=LONG_MAX;\\n        vector<long long> ans(n,LONG_MAX);\\n        for(int i=0;i<n;i++){\\n            sum=0;\\n            for(int j=0;j<n;j++){\\n                ans[j]=min((long long)ans[j],(long long)nums[(n-i+j)%n]);\\n                sum+=ans[j];\\n            }\\n            sum+=(1ll*i*x);\\n            res=min(res,sum);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624100,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nexplained in code itself but it was a tricky one I was thinking a solution using recusrion in o(n^3) during contest and i guess explaination is correct as they only wanted to say is will cyclically rotate forward\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<long long>dp(n,0);\\n        // here dp[i] is representing the cost of buying the all the types till ith round\\n     // that is it might be possible that some types are bought in previous rounds and some are bought in this\\n        for(int i=0;i<n;i++){\\n          // buying the ith types \\n          dp[i]+=1LL*i*x;\\n          int curr=1e9;\\n          // cost of buying ith type till current round\\n     \\n          for(int j=0;j<n;j++){\\n              curr=min(curr,nums[(i-j+n)%n]);\\n             \\n              dp[j]+=curr;\\n          }\\n        \\n         \\n        }\\n     \\n        return *min_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<long long>dp(n,0);\\n        // here dp[i] is representing the cost of buying the all the types till ith round\\n     // that is it might be possible that some types are bought in previous rounds and some are bought in this\\n        for(int i=0;i<n;i++){\\n          // buying the ith types \\n          dp[i]+=1LL*i*x;\\n          int curr=1e9;\\n          // cost of buying ith type till current round\\n     \\n          for(int j=0;j<n;j++){\\n              curr=min(curr,nums[(i-j+n)%n]);\\n             \\n              dp[j]+=curr;\\n          }\\n        \\n         \\n        }\\n     \\n        return *min_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624090,
                "title": "java-lose-python-win",
                "content": "\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecord the best choice of all the type of choalate.\\n```\\nint n = nums.length;\\nlong[][] record = new long[n][n];\\nfor(int i = 0; i < n; i++){\\n    for(int j = i; j < n + i; j++){\\n        int abs = 0;\\n        int tmp = 0;\\n        if( j < i){\\n            abs = j + n - i;\\n        }else{\\n            abs = j - i;\\n        }\\n        tmp = nums[j%n]; \\n        if(j == i){\\n            record[i][j%n] = tmp;\\n        }else{\\n            record[i][j%n] = Math.min(tmp, record[i][(j-1)%n]);\\n        }\\n        \\n    }\\n}\\n```\\nfor example\\nfor the array: [15,150,56,69,214,203]\\nthe record will be\\n15 15 15 15 15 15 \\n15 150 56 56 56 56 \\n15 15 56 56 56 56 \\n15 15 15 69 69 69 \\n15 15 15 15 214 203 \\n15 15 15 15 15 203 \\n\\nand finally we can iterate n times to find the min cost\\n```\\nlong res = Long.MAX_VALUE;\\n        \\n        for(int i = 0; i < n; i++){\\n            long cur = i * x;\\n            for(int j = 0; j < n; j++){\\n                cur += record[j][(j+i)%n];\\n            }\\n            // System.out.print(cur + \" \");\\n            res = Math.min(res,cur);\\n            \\n        }\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach will make java long overflow.\\nuse chatgpt to transform java to python and you will win!!!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!n-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n# Code\\npython\\n```\\nclass Solution:\\n    def minCost(self, nums, x):\\n        n = len(nums)\\n        record = [[0] * n for _ in range(n)]\\n        \\n        for i in range(n):\\n            for j in range(i, n + i):\\n                if j < i:\\n                    abs_val = j + n - i\\n                else:\\n                    abs_val = j - i\\n                tmp = nums[j % n]\\n                \\n                if j == i:\\n                    record[i][j % n] = tmp\\n                else:\\n                    record[i][j % n] = min(tmp, record[i][(j - 1) % n])\\n        \\n        res = float(\\'inf\\')\\n        \\n        for i in range(n):\\n            cur = i * x\\n            for j in range(n):\\n                cur += record[j][(j + i) % n]\\n            res = min(res, cur)\\n            \\n        return res\\n\\n```\\nJava(result will overflow)\\n```\\nclass Solution {\\n    public long minCost(int[] nums, int x) {\\n        int n = nums.length;\\n        long[][] record = new long[n][n];\\n        for(int i = 0; i < n; i++){\\n            for(int j = i; j < n + i; j++){\\n                int abs = 0;\\n                int tmp = 0;\\n                if( j < i){\\n                    abs = j + n - i;\\n                }else{\\n                    abs = j - i;\\n                }\\n                tmp = nums[j%n]; \\n                if(j == i){\\n                    record[i][j%n] = tmp;\\n                }else{\\n                    record[i][j%n] = Math.min(tmp, record[i][(j-1)%n]);\\n                }\\n                \\n            }\\n        }\\n        // for(long[] re : record){\\n        //     for(long r: re){\\n        //         System.out.print(r + \" \");\\n        //     }\\n        //     System.out.println();\\n        // }\\n        \\n        long res = Long.MAX_VALUE;\\n        \\n        for(int i = 0; i < n; i++){\\n            long cur = i * x;\\n            for(int j = 0; j < n; j++){\\n                cur += record[j][(j+i)%n];\\n            }\\n            // System.out.print(cur + \" \");\\n            res = Math.min(res,cur);\\n            \\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\nint n = nums.length;\\nlong[][] record = new long[n][n];\\nfor(int i = 0; i < n; i++){\\n    for(int j = i; j < n + i; j++){\\n        int abs = 0;\\n        int tmp = 0;\\n        if( j < i){\\n            abs = j + n - i;\\n        }else{\\n            abs = j - i;\\n        }\\n        tmp = nums[j%n]; \\n        if(j == i){\\n            record[i][j%n] = tmp;\\n        }else{\\n            record[i][j%n] = Math.min(tmp, record[i][(j-1)%n]);\\n        }\\n        \\n    }\\n}\\n```\n```\\nlong res = Long.MAX_VALUE;\\n        \\n        for(int i = 0; i < n; i++){\\n            long cur = i * x;\\n            for(int j = 0; j < n; j++){\\n                cur += record[j][(j+i)%n];\\n            }\\n            // System.out.print(cur + \" \");\\n            res = Math.min(res,cur);\\n            \\n        }\\n```\n```\\nclass Solution:\\n    def minCost(self, nums, x):\\n        n = len(nums)\\n        record = [[0] * n for _ in range(n)]\\n        \\n        for i in range(n):\\n            for j in range(i, n + i):\\n                if j < i:\\n                    abs_val = j + n - i\\n                else:\\n                    abs_val = j - i\\n                tmp = nums[j % n]\\n                \\n                if j == i:\\n                    record[i][j % n] = tmp\\n                else:\\n                    record[i][j % n] = min(tmp, record[i][(j - 1) % n])\\n        \\n        res = float(\\'inf\\')\\n        \\n        for i in range(n):\\n            cur = i * x\\n            for j in range(n):\\n                cur += record[j][(j + i) % n]\\n            res = min(res, cur)\\n            \\n        return res\\n\\n```\n```\\nclass Solution {\\n    public long minCost(int[] nums, int x) {\\n        int n = nums.length;\\n        long[][] record = new long[n][n];\\n        for(int i = 0; i < n; i++){\\n            for(int j = i; j < n + i; j++){\\n                int abs = 0;\\n                int tmp = 0;\\n                if( j < i){\\n                    abs = j + n - i;\\n                }else{\\n                    abs = j - i;\\n                }\\n                tmp = nums[j%n]; \\n                if(j == i){\\n                    record[i][j%n] = tmp;\\n                }else{\\n                    record[i][j%n] = Math.min(tmp, record[i][(j-1)%n]);\\n                }\\n                \\n            }\\n        }\\n        // for(long[] re : record){\\n        //     for(long r: re){\\n        //         System.out.print(r + \" \");\\n        //     }\\n        //     System.out.println();\\n        // }\\n        \\n        long res = Long.MAX_VALUE;\\n        \\n        for(int i = 0; i < n; i++){\\n            long cur = i * x;\\n            for(int j = 0; j < n; j++){\\n                cur += record[j][(j+i)%n];\\n            }\\n            // System.out.print(cur + \" \");\\n            res = Math.min(res,cur);\\n            \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624076,
                "title": "c-o-n-2-predict-the-index",
                "content": "# Approach\\nStore the minimum cost u can achieve by moving to the right by changing the type. Predict the type that will be present at an index after each right shift and calculate the min out of it.\\nAfter finding the min cost of each index simlpy calculate the sum of all the values with the cost of right shifts.\\nMinimum values after these n shifts is the answer.\\n\\n# Complexity\\n- Time complexity: O(n ^ 2)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, long long x) {\\n        long long n = nums.size();\\n        long long totalC = 0;\\n        vector<long long> minn(n);\\n        for(int i = 0; i < n; i++) {\\n            minn[i] = nums[i];\\n            totalC += minn[i];\\n        }\\n        for(int i = 0; i < n; i++) {\\n            long long cost = x * i;\\n            for(int j = 0; j < n; j++) {\\n                int newIdx = (i + j);\\n                if(newIdx >= n)\\n                    newIdx %= n;\\n                minn[newIdx] = min(minn[newIdx], 1ll * nums[j]);\\n                cost += minn[newIdx];\\n            }\\n            totalC = min(totalC, cost);\\n        }\\n        return totalC;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, long long x) {\\n        long long n = nums.size();\\n        long long totalC = 0;\\n        vector<long long> minn(n);\\n        for(int i = 0; i < n; i++) {\\n            minn[i] = nums[i];\\n            totalC += minn[i];\\n        }\\n        for(int i = 0; i < n; i++) {\\n            long long cost = x * i;\\n            for(int j = 0; j < n; j++) {\\n                int newIdx = (i + j);\\n                if(newIdx >= n)\\n                    newIdx %= n;\\n                minn[newIdx] = min(minn[newIdx], 1ll * nums[j]);\\n                cost += minn[newIdx];\\n            }\\n            totalC = min(totalC, cost);\\n        }\\n        return totalC;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624046,
                "title": "can-anybody-help-me-understand-this-problem",
                "content": "for this case \\n```\\n[15,150,56,69,214,203]\\n42\\n```\\nBasically, I thought the array after being rotated should be \\n`[15, 56, 56, 69, 15, 15];`\\nand answer should be \\n`15 + 56 + 69 + (56  + 15 + 42) + (15 + 42 )  = 310`\\nBut the answer is 298, can any body tell me why, Did I misunderstand anything or there was a better rotation?\\n",
                "solutionTags": [],
                "code": "```\\n[15,150,56,69,214,203]\\n42\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3624045,
                "title": "fix-the-number-of-operations-and-keep-minum-greedy-or-segment-tree-c",
                "content": "I have to say that first I solved with the segment tree, but just after that I realized that it is really easy to get the needed information, so I left here the two solutions\\n# Approach\\nFix the number of operations, for each fixed number of operations the cost for some index $j$ will be the minimum value in some range. \\nFor example if we are at index $j = 5$ and we set the number of operations to be $x = 7$ that means we can buy the chocolate at any price in the range $[max(0,j-x),j]$ and $[n-x-j,n-1]$ if $x > j$, so if you can get that minimum in the range you have it solved, for that I use the segment tree in the contest, but another solution is to notice that every time we increase the number of operations some index $i$ of $nums$ can reach exactly one $j$ value more than with one operation less, so we just need to know what new index we will reach and update its minimum.\\n\\n# Complexity\\n- Time complexity:\\n $O(n\\xB2)$ or $O(n\\xB2 log(n))$ with segment tree\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long minCost(vector<int>& nums, long long x) {\\n        long long ans = 1e18;\\n        int n = nums.size();\\n\\n        vector<int> MIN = nums;\\n        \\n        for(int i = 0;i<n;i++){\\n                \\n            long long res = 0;\\n            for(int j = 0;j<n;j++)\\n                res+=MIN[j];\\n            \\n            for(int j = 0;j<n;j++){   \\n                int idx = j+(i+1);\\n                idx%=n;\\n                MIN[idx] = min(MIN[idx],nums[j]);\\n            }\\n            res+=x*i;\\n            ans = min(ans,res);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n### Code with segment tree\\n```\\nclass Solution {\\npublic:\\n    struct STmin{\\n        int n;\\n        vector<int> st;\\n        STmin(int n):n(n){\\n            st.resize(2*n,1e9+7);\\n        }\\n        inline void update(int x, int val) {\\n            x += n;\\n            st[x] = val;\\n            for (; x >>=1 ; st[x] = min(st[x<<1], st[x<<1|1]));\\n        }\\n        inline int query(int l, int r) {\\n            int ans = 1e9+7;\\n            if(r<l)return 0;\\n            for (l += n, r += n; l <= r; l = (l + 1) / 2, r = (r - 1) / 2) {\\n                if (l & 1) ans = min(ans, st[l]);\\n                if (~r & 1) ans = min(ans, st[r]);\\n            }\\n            return ans;\\n        }\\n    };\\n    long long minCost(vector<int>& nums, long long x) {\\n        long long ans = 1e18;\\n        int n = nums.size();\\n        \\n        STmin st(n);\\n        for(int i = 0;i<n;i++){\\n            st.update(i,nums[i]);\\n        }\\n        \\n        for(int i = 0;i<n;i++){\\n                \\n            long long res = 0;\\n            for(int j = 0;j<n;j++){\\n                int l = max(0,j-i);\\n                \\n                int mn = st.query(l,j);\\n                    \\n                if(j<i)\\n                    mn = min(mn,st.query(n-(i-j),n-1));      \\n                \\n                res+=mn;\\n            }\\n            res+=x*i;\\n            ans = min(ans,res);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long minCost(vector<int>& nums, long long x) {\\n        long long ans = 1e18;\\n        int n = nums.size();\\n\\n        vector<int> MIN = nums;\\n        \\n        for(int i = 0;i<n;i++){\\n                \\n            long long res = 0;\\n            for(int j = 0;j<n;j++)\\n                res+=MIN[j];\\n            \\n            for(int j = 0;j<n;j++){   \\n                int idx = j+(i+1);\\n                idx%=n;\\n                MIN[idx] = min(MIN[idx],nums[j]);\\n            }\\n            res+=x*i;\\n            ans = min(ans,res);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    struct STmin{\\n        int n;\\n        vector<int> st;\\n        STmin(int n):n(n){\\n            st.resize(2*n,1e9+7);\\n        }\\n        inline void update(int x, int val) {\\n            x += n;\\n            st[x] = val;\\n            for (; x >>=1 ; st[x] = min(st[x<<1], st[x<<1|1]));\\n        }\\n        inline int query(int l, int r) {\\n            int ans = 1e9+7;\\n            if(r<l)return 0;\\n            for (l += n, r += n; l <= r; l = (l + 1) / 2, r = (r - 1) / 2) {\\n                if (l & 1) ans = min(ans, st[l]);\\n                if (~r & 1) ans = min(ans, st[r]);\\n            }\\n            return ans;\\n        }\\n    };\\n    long long minCost(vector<int>& nums, long long x) {\\n        long long ans = 1e18;\\n        int n = nums.size();\\n        \\n        STmin st(n);\\n        for(int i = 0;i<n;i++){\\n            st.update(i,nums[i]);\\n        }\\n        \\n        for(int i = 0;i<n;i++){\\n                \\n            long long res = 0;\\n            for(int j = 0;j<n;j++){\\n                int l = max(0,j-i);\\n                \\n                int mn = st.query(l,j);\\n                    \\n                if(j<i)\\n                    mn = min(mn,st.query(n-(i-j),n-1));      \\n                \\n                res+=mn;\\n            }\\n            res+=x*i;\\n            ans = min(ans,res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624025,
                "title": "using-matrix-for-min-element-from-i-to-j-mn-i-j",
                "content": "# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<vector<int>> mn(n,vector<int>(n,INT_MAX));\\n        for(int i=0;i<n;i++){\\n            int curr_mn=nums[i];\\n            for(int j=i;j<n;j++){\\n                curr_mn=min(curr_mn,nums[j]);\\n                mn[i][j]=curr_mn;\\n            }\\n        }\\n        \\n        ll ans=1e17;\\n        for(int k=0;k<n;k++){\\n            ll curr=1ll*x*k;\\n            for(int i=0;i<n;i++){\\n                if(i-k<0){\\n                    curr+=min(mn[i-k+n][n-1],mn[0][i]);\\n                }\\n                else curr+=mn[i-k][i];\\n            }\\n            ans=min(ans,curr);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n=nums.size();\\n        vector<vector<int>> mn(n,vector<int>(n,INT_MAX));\\n        for(int i=0;i<n;i++){\\n            int curr_mn=nums[i];\\n            for(int j=i;j<n;j++){\\n                curr_mn=min(curr_mn,nums[j]);\\n                mn[i][j]=curr_mn;\\n            }\\n        }\\n        \\n        ll ans=1e17;\\n        for(int k=0;k<n;k++){\\n            ll curr=1ll*x*k;\\n            for(int i=0;i<n;i++){\\n                if(i-k<0){\\n                    curr+=min(mn[i-k+n][n-1],mn[0][i]);\\n                }\\n                else curr+=mn[i-k][i];\\n            }\\n            ans=min(ans,curr);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624015,
                "title": "pretty-neat-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        n = len(nums)\\n\\n        def costs():\\n            table = [inf] * n\\n            queue = deque(nums)\\n            for r in range(n):\\n                table = list(map(min, queue, table))\\n                yield sum(table) + r * x\\n                queue.rotate(-1)\\n\\n        return min(costs())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        n = len(nums)\\n\\n        def costs():\\n            table = [inf] * n\\n            queue = deque(nums)\\n            for r in range(n):\\n                table = list(map(min, queue, table))\\n                yield sum(table) + r * x\\n                queue.rotate(-1)\\n\\n        return min(costs())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624002,
                "title": "brute-force-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size(); long long ans = LONG_MAX;\\n        vector<int> mini = nums;\\n        // vector<int> temp(n);\\n        for(int j=0; j<n; j++){\\n            long long sum=0;\\n            sum = (long long)x*j;\\n            for(int i=0; i<n; i++){\\n                // if(i==n-1){\\n                //     nums[i]=val;\\n                // }else{\\n                //     nums[i] = nums[i+1];\\n                // }\\n                mini[i] = min(mini[i],nums[(i+j)%n]);\\n                sum+=mini[i];\\n            }\\n            ans = min(ans,sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size(); long long ans = LONG_MAX;\\n        vector<int> mini = nums;\\n        // vector<int> temp(n);\\n        for(int j=0; j<n; j++){\\n            long long sum=0;\\n            sum = (long long)x*j;\\n            for(int i=0; i<n; i++){\\n                // if(i==n-1){\\n                //     nums[i]=val;\\n                // }else{\\n                //     nums[i] = nums[i+1];\\n                // }\\n                mini[i] = min(mini[i],nums[(i+j)%n]);\\n                sum+=mini[i];\\n            }\\n            ans = min(ans,sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623977,
                "title": "beats-100-o-n-log-n-log-n-using-binary-search-sortedlist",
                "content": "# Intuition\\nIf shifting by $$k$$ positions minimizes the total cost of collecting each chocolates (excluding the shift cost), then shifting more will only increase the shift cost without decreasing the collecting cost.\\n\\n# Approach\\n- Use binary search to find the optimal number of shifts.\\n- Calculate the total cost: `ans = (shift cost) + (collecting cost)`, where the collecting cost of chocolate type `i` is the minimum number in the subarray of `nums` of length `shift + 1` starting at `i`.\\n\\n# Complexity\\n- Time complexity: $$O(n \\\\log n)$$.\\n    - The body of binary search calls `cost` at most 2 times and `cost` takes $$O(n \\\\log n)$$ time, so the algorithm takes $$O(n \\\\log n \\\\log n)$$ time in total.\\n- Space complexity: $$O(n)$$.\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        n = len(nums)\\n        \\n        @cache\\n        def cost(shift):\\n            sl = SortedList(nums[:shift + 1])\\n            ans = 0\\n            for i in range(n):\\n                ans += sl[0]\\n                sl.discard(nums[i])\\n                sl.add(nums[(i + shift + 1) % n])\\n            ans = ans + x * shift\\n            return ans\\n        \\n        l, r = 1, n\\n        while l < r:\\n            m = (l + r) // 2\\n            if cost(m) > cost(m-1):\\n                r = m\\n            else:\\n                l = m + 1\\n        return cost(l-1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minCost(self, nums: List[int], x: int) -> int:\\n        n = len(nums)\\n        \\n        @cache\\n        def cost(shift):\\n            sl = SortedList(nums[:shift + 1])\\n            ans = 0\\n            for i in range(n):\\n                ans += sl[0]\\n                sl.discard(nums[i])\\n                sl.add(nums[(i + shift + 1) % n])\\n            ans = ans + x * shift\\n            return ans\\n        \\n        l, r = 1, n\\n        while l < r:\\n            m = (l + r) // 2\\n            if cost(m) > cost(m-1):\\n                r = m\\n            else:\\n                l = m + 1\\n        return cost(l-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623974,
                "title": "minimum-sparse-table",
                "content": "```\\nclass Solution {\\n    public long minCost(int[] nums, int x) {\\n        int n = nums.length;\\n        int[] arr = new int[2*n];\\n        long answer = 0L;\\n        for(int i=0;i<2*n;i++){\\n            arr[i] = nums[i%n];\\n            answer += arr[i];\\n        }\\n        MinSparseTable st = new MinSparseTable(arr);\\n        answer /= 2;\\n        for(int len=2;len<=n;len++){\\n            long cur = (len-1)*(long)x;\\n            for(int i=0;i<n;i++) cur += st.getMinimum(i,i+len-1);\\n            answer = Math.min(answer,cur);\\n        }\\n        return answer;\\n    }\\n}\\nclass MinSparseTable{\\n    int n;\\n    int[] logs;\\n    int[] arr;\\n    int[][] table;\\n    MinSparseTable(int[] a){\\n        this.n = a.length;\\n        this.arr = new int[n];\\n        for(int i=0;i<a.length;i++) arr[i] = a[i];\\n        int maxPowerOfTwo = Math.max(1,(int)Math.ceil(Math.log(n)/Math.log(2)));\\n        this.logs = new int[n+1];\\n        computeLogs();\\n        this.table = new int[maxPowerOfTwo+1][n];\\n        for(int i=0;i<=logs[n];i++){\\n            int curLen = 1<<i;\\n            for(int j=0;j<=n-curLen;j++){\\n                if(curLen==1) table[i][j] = arr[j];\\n                else table[i][j] = Math.min(table[i-1][j],table[i-1][j+(curLen/2)]);\\n            }\\n        }\\n    }\\n    private void computeLogs(){\\n        for(int i=2;i<=n;i++) logs[i] = logs[i/2]+1;\\n\\n    }\\n    public int getMinimum(int left, int right){\\n        int p = logs[right-left+1];\\n        int pLen = 1 << p;\\n        return Math.min(table[p][left],table[p][right-pLen+1]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long minCost(int[] nums, int x) {\\n        int n = nums.length;\\n        int[] arr = new int[2*n];\\n        long answer = 0L;\\n        for(int i=0;i<2*n;i++){\\n            arr[i] = nums[i%n];\\n            answer += arr[i];\\n        }\\n        MinSparseTable st = new MinSparseTable(arr);\\n        answer /= 2;\\n        for(int len=2;len<=n;len++){\\n            long cur = (len-1)*(long)x;\\n            for(int i=0;i<n;i++) cur += st.getMinimum(i,i+len-1);\\n            answer = Math.min(answer,cur);\\n        }\\n        return answer;\\n    }\\n}\\nclass MinSparseTable{\\n    int n;\\n    int[] logs;\\n    int[] arr;\\n    int[][] table;\\n    MinSparseTable(int[] a){\\n        this.n = a.length;\\n        this.arr = new int[n];\\n        for(int i=0;i<a.length;i++) arr[i] = a[i];\\n        int maxPowerOfTwo = Math.max(1,(int)Math.ceil(Math.log(n)/Math.log(2)));\\n        this.logs = new int[n+1];\\n        computeLogs();\\n        this.table = new int[maxPowerOfTwo+1][n];\\n        for(int i=0;i<=logs[n];i++){\\n            int curLen = 1<<i;\\n            for(int j=0;j<=n-curLen;j++){\\n                if(curLen==1) table[i][j] = arr[j];\\n                else table[i][j] = Math.min(table[i-1][j],table[i-1][j+(curLen/2)]);\\n            }\\n        }\\n    }\\n    private void computeLogs(){\\n        for(int i=2;i<=n;i++) logs[i] = logs[i/2]+1;\\n\\n    }\\n    public int getMinimum(int left, int right){\\n        int p = logs[right-left+1];\\n        int pLen = 1 << p;\\n        return Math.min(table[p][left],table[p][right-pLen+1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623959,
                "title": "intuitive-easy-to-understand-detailed-approach-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition is that we have to minimise the cost of the chocolate taking care of the cost of shifting.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, to cancel out the rotation, add the same array nums at the end of nums.\\nThen, I have taken the 2-D array where i is index of intial elements and j is the index within which we have to calculate the minimum number. \\nFor eg: nums: [15 150 56 69 12 8], therefore for i=0,\\nres[0][0] = 15\\nres[0][1] = 15\\nres[0][2] = 15\\nres[0][3] = 15\\nres[0][4] = 12\\nres[0][5] = 18\\nand so on... for other indexes\\n\\nThen, fix the maximum no. of shifts a number can get, and iterate over the array and add the minimum number in the range of mx for every element.\\n\\nThen, take the minimum from the final answer i.e.ansf .\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        \\n        for(int i=0;i<n;i++){\\n            nums.push_back(nums[i]);\\n        }\\n        \\n        vector<vector<int>> res(n+1,vector<int>(n+1,0));\\n        for(int i=0;i<n;i++){\\n            res[i][0] = nums[i];\\n            for(int j=1;j<n;j++){\\n                res[i][j] = min(res[i][j-1],nums[j+i]);\\n            }\\n        }\\n        ll ansf=0,ans=0;\\n        for(int k=0;k<n;k++){\\n            ansf+=nums[k];\\n        }\\n        for(ll mx=1;mx<n;mx++){\\n            ans=0;\\n            for(int l=0;l<n;l++){\\n                ans += (res[l][mx]); \\n            }\\n            ans += (mx*x);\\n            \\n            if(ansf>=ans){\\n                ansf = ans;\\n            }else{\\n                return ansf;\\n            }\\n        }\\n\\n        return ansf;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        \\n        for(int i=0;i<n;i++){\\n            nums.push_back(nums[i]);\\n        }\\n        \\n        vector<vector<int>> res(n+1,vector<int>(n+1,0));\\n        for(int i=0;i<n;i++){\\n            res[i][0] = nums[i];\\n            for(int j=1;j<n;j++){\\n                res[i][j] = min(res[i][j-1],nums[j+i]);\\n            }\\n        }\\n        ll ansf=0,ans=0;\\n        for(int k=0;k<n;k++){\\n            ansf+=nums[k];\\n        }\\n        for(ll mx=1;mx<n;mx++){\\n            ans=0;\\n            for(int l=0;l<n;l++){\\n                ans += (res[l][mx]); \\n            }\\n            ans += (mx*x);\\n            \\n            if(ansf>=ans){\\n                ansf = ans;\\n            }else{\\n                return ansf;\\n            }\\n        }\\n\\n        return ansf;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623939,
                "title": "c-fastest-simple-solution",
                "content": "# Intuition:\\nThe array will be rotated for a max of N times, so try all possibilities as N = 1000.\\n\\n\\nclass Solution {\\npublic:\\n\\tlong long minCost(vector<int>& nums, int x) {\\n\\t\\tlong long n = nums.size(), i, j, k, s, INF = 1LL << 60, ans = INF;\\n\\t\\tvector<long long> a(n + n);\\n\\t\\tfor (i = 0; i < n + n; i++) {\\n\\t\\t\\ta[i] = nums[i % n];\\n\\t\\t}\\n\\n\\t\\tvector<long long> minn(n, INF);\\n\\t\\tfor (i = 0; i <= n; i++) {\\n\\t\\t\\ts = 0;\\n\\t\\t\\tfor (j = 0; j < n; j++) {\\n\\t\\t\\t\\tminn[j] = min(minn[j], (long long)a[j + i]);\\n\\t\\t\\t\\ts += minn[j];\\n\\t\\t\\t}\\n\\t\\t\\tans = min(ans, s + x * i);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n\\tlong long minCost(vector<int>& nums, int x) {\\n\\t\\tlong long n = nums.size(), i, j, k, s, INF = 1LL << 60, ans = INF;\\n\\t\\tvector<long long> a(n + n);\\n\\t\\tfor (i = 0; i < n + n; i++) {\\n\\t\\t\\ta[i] = nums[i % n];\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3623930,
                "title": "c-keep-track-min",
                "content": "\\nAssume having a window size t, iterate t from 0 to n-1.\\nUpdate min element for each index i with i+t.\\nCalculate cost while iteration.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nusing ll = long long;\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        ll res = LLONG_MAX;\\n        vector<int> costs;\\n        for(int num: nums)\\n            costs.push_back(num);\\n        for(int t = 0; t < n; t++) {\\n            ll cost = 0;\\n            for(int i = 0; i < n; i++) {\\n                costs[i] = min(costs[i], nums[(i+t)%n]);\\n                cost += costs[i];\\n            }\\n            cost += (ll)t*x;\\n            res = min(res, cost);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nusing ll = long long;\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int n = nums.size();\\n        ll res = LLONG_MAX;\\n        vector<int> costs;\\n        for(int num: nums)\\n            costs.push_back(num);\\n        for(int t = 0; t < n; t++) {\\n            ll cost = 0;\\n            for(int i = 0; i < n; i++) {\\n                costs[i] = min(costs[i], nums[(i+t)%n]);\\n                cost += costs[i];\\n            }\\n            cost += (ll)t*x;\\n            res = min(res, cost);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623914,
                "title": "n-2-prefix-min-matrix-try-n-1-possible-shifts-c",
                "content": "* Set up a prefix min matrix `p`, where `p[i][t]` is the min number within `t` steps forward from `i`, i.e.: `min(nums[i], nums[(i+1)%N], ... nums[(i+t)%N)`.  \\n* This is `O(N^2)`, it is fine since `N<=1000`.\\n* Note the shift operation can be applied a maximum of `N-1` possible times, since after `N` shifts we are back to the original array.\\n* For a given shift `t`, the min cost will be `x*t + p[i][t]` for `0<=i<N`. This is because since `t` is fixed, we can \"grab\" the lowest of `nums[i], nums[(i+1)%N]...nums[(i+t)%N]` for free\\n* Try every possible shift from `0..N-1`.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int N = nums.size();\\n        vector<vector<int>> p(N, vector<int>(N));\\n        long long res = -1;\\n        for(int i=0;i<N;++i){\\n            int mn = nums[i];\\n            for(int t=0;t<N;++t){\\n                int nn = nums[(i+t)%N];\\n                p[i][t] = mn = min(mn, nn);\\n            }\\n        }\\n        for(int t=0;t<N;++t){\\n            long long loc = (long long)t * x;\\n            for(int i=0;i<N;++i){\\n                loc += p[i][t];\\n            }\\n            if(res==-1 || loc<res) res = loc;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& nums, int x) {\\n        int N = nums.size();\\n        vector<vector<int>> p(N, vector<int>(N));\\n        long long res = -1;\\n        for(int i=0;i<N;++i){\\n            int mn = nums[i];\\n            for(int t=0;t<N;++t){\\n                int nn = nums[(i+t)%N];\\n                p[i][t] = mn = min(mn, nn);\\n            }\\n        }\\n        for(int t=0;t<N;++t){\\n            long long loc = (long long)t * x;\\n            for(int i=0;i<N;++i){\\n                loc += p[i][t];\\n            }\\n            if(res==-1 || loc<res) res = loc;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1924944,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "Problem creator was high on weeds."
                    },
                    {
                        "username": "15o1",
                        "content": "Is the explanation of first test case incorrect or am I just dumb??!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "Changing the type of chocolate from i to i+1 means that the price of chocolate i will become the price of chocolate i+1.\nSo lets take the original array for prices [20,1,15].\nAfter first operation we will get: [1, 15, 20]\nAfter second operation: [15, 20, 1]\nBut you don't have to shift values in array. You just need to calculate the index of value in original array that will represent current price after k operatioins.\nprice for element i after k operations = nums[(i+k)%n], where n = nums.length.\nSo after 1 operation, price for chocolate 0 = nums[1], for chocolate 1 = nums[2], for chocolate 2 = nums[0].\n[2,0,1] mean exactly that: values in that array represents types. And for prices -- position of element is matching position in nums: for type 2 it is 0, so the price for type 2 = nums[0];"
                    },
                    {
                        "username": "Wanhao",
                        "content": "[@tungpham](/tungpham) Now I find reason why i cant get the correct answer, this case so confusing on rotation direction "
                    },
                    {
                        "username": "ZQGao",
                        "content": "Same. Failed to understand this question. So *** confusing. And I think the first example is wrong."
                    },
                    {
                        "username": "uuu06222",
                        "content": "I think the [2,0,1] and [1,2,0] part in the description should be swapped"
                    },
                    {
                        "username": "Shkev",
                        "content": "It\\'s just very weirdly explained imo. Basically index `i` of `nums` tells you the price of chocolate `i`. When they call the operation, the index of the chocolates doesn\\'t change, but their types shift.\\nIn the first example they basically shift the type of the chocolates until every type falls on the chocolate that costs 1 and then they buy."
                    },
                    {
                        "username": "tungpham",
                        "content": "Same here. Couldn\\'t make sense of [0,1,2] becomes [2,0,1].It seems i => (i-1) instead of (i+1)"
                    },
                    {
                        "username": "shivamxSK",
                        "content": "description esa likho ki char log bhi na samaj paye\\n"
                    },
                    {
                        "username": "vishal75",
                        "content": "lol"
                    },
                    {
                        "username": "devJuneja",
                        "content": "They could have explained the question with better test cases. : |"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Absolute Garbage Explanation of 1st TC. I wonder why I woke @7:30 just to scream \"Good Morning\"."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I replied Happy Sunday! for the 4th problem 1403/1414"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Namaste sabhi namaste sabhi."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "description aisa do jisko dekhkr chocolate khaane ka mann kare zehar nahi :p"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "I am not able to understand the question waster 25 min.."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "Is the question really confusing or  am I the one who is stupid?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "For those having difficulty in understanding the question , I found one example that might help:\\nThe costs given to us are fixed:[20,1,15]\\nConsider a conveyer belt moving one step ahead each time. The conveyer belt has n types(here 3) of chocolates and price of each chocolate is the lane in front of which it is kept. So, initially, \\nCost:[20,1,15](remains fixed)\\nBelt:[0,1,2]\\nNow belt moves one step ahead(imagine it moving in ur head , it helps!)\\nCost:[20,1,15]                             [20,1,15]                [20,1,15]\\nBelt:[2,0,1]--moves with cost x->[1,2,0]--x cost---->[0,1,2]\\nSo we pick chocolates while conveyer belt is moving each type once and try to minimize cost . Here we pick all chocolates when they reach in front of 1 cost.\\nHope it helps!"
                    },
                    {
                        "username": "rnishant29",
                        "content": "nums: [15,150,56,69,214,203]\\nx: 42\\nhow answer 298 is possible?Please guide...\\nThanks.\\n"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@seafmch](/seafmch) That\\'s because after 1 operation you can get type 4 chocolate for min(nums[4], nums[5]) = min(214, 203) = 203. Same idea goes for type 5: min(nums[5], nums[0]) = min(203, 15) = 15.\\n\\nThough that idea is based on examples before they were updated (the description and examples were not clear enough, so I assumed that after performing operation, price for type i chocolate will be nums[(i+1)%n], where n = nums.length.\\n\\nAfter examples were clarified it\\'s clear that after 1 operation price for type i will be nums[i-1] (i>0).\\nSo after 1 operation you should calculate min possible price for type i as min(nums[i], nums[i-1]) (i>0).\\nBut it looks like they way you shift prices doesn\\'t effect the result since my initial approach passed all tests."
                    },
                    {
                        "username": "rnishant29",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot for great explanation!!!"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@VektorMD](/VektorMD) What? From 0 to 1, both 150 and 214 disappear. Why?"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@rnishant29](/rnishant29) me too"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@suniiiiidhi](/suniiiiidhi) My understanding to the problem was partially based on examples provided. Before they were updated, is seems like the logic was following: after one operation you can calculate a price for type i as min(nums[i], nums[(i+1)%n]) where n = nums.length.\n\nIf you perform k operations then you can calculate price as min(nums[i], .., nums[(i+k)%n]).\nSo lets take a look on all possible outcomes:\n0: [15,150,56,69,214,203] -- original\n1: [15,56,56,69,203,15]\n2: [15,56,56,69,15,15]\n3: [15,56,56,15,15,15]\n4: [15,56,15,15,15,15]\n5: [15,15,15,15,15,15]\n(number on the left  is amount of operations performed)\nConsidering the price of operation x = 42, minimum can be achieved after 3 operations (=298).\n\nBut examples for this problem now are updated. And you have to use reversed logic: after 1 operation for price for type i is min(nums[i], nums[(i-1)]) (for i > 0).\nI'm not sure if this change will affect testcases, maybe some of them will need an update"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) please elaborate"
                    },
                    {
                        "username": "VektorMD",
                        "content": "In 3 operations you can get type 0,3,4,5 for 15, type 1,2 for 56 = 4 * 15 + 56 * 2+42 * 3 = 298"
                    },
                    {
                        "username": "rnishant29",
                        "content": "I am getting 300 as minimum\\n"
                    }
                ]
            },
            {
                "id": 1924530,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "Problem creator was high on weeds."
                    },
                    {
                        "username": "15o1",
                        "content": "Is the explanation of first test case incorrect or am I just dumb??!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "Changing the type of chocolate from i to i+1 means that the price of chocolate i will become the price of chocolate i+1.\nSo lets take the original array for prices [20,1,15].\nAfter first operation we will get: [1, 15, 20]\nAfter second operation: [15, 20, 1]\nBut you don't have to shift values in array. You just need to calculate the index of value in original array that will represent current price after k operatioins.\nprice for element i after k operations = nums[(i+k)%n], where n = nums.length.\nSo after 1 operation, price for chocolate 0 = nums[1], for chocolate 1 = nums[2], for chocolate 2 = nums[0].\n[2,0,1] mean exactly that: values in that array represents types. And for prices -- position of element is matching position in nums: for type 2 it is 0, so the price for type 2 = nums[0];"
                    },
                    {
                        "username": "Wanhao",
                        "content": "[@tungpham](/tungpham) Now I find reason why i cant get the correct answer, this case so confusing on rotation direction "
                    },
                    {
                        "username": "ZQGao",
                        "content": "Same. Failed to understand this question. So *** confusing. And I think the first example is wrong."
                    },
                    {
                        "username": "uuu06222",
                        "content": "I think the [2,0,1] and [1,2,0] part in the description should be swapped"
                    },
                    {
                        "username": "Shkev",
                        "content": "It\\'s just very weirdly explained imo. Basically index `i` of `nums` tells you the price of chocolate `i`. When they call the operation, the index of the chocolates doesn\\'t change, but their types shift.\\nIn the first example they basically shift the type of the chocolates until every type falls on the chocolate that costs 1 and then they buy."
                    },
                    {
                        "username": "tungpham",
                        "content": "Same here. Couldn\\'t make sense of [0,1,2] becomes [2,0,1].It seems i => (i-1) instead of (i+1)"
                    },
                    {
                        "username": "shivamxSK",
                        "content": "description esa likho ki char log bhi na samaj paye\\n"
                    },
                    {
                        "username": "vishal75",
                        "content": "lol"
                    },
                    {
                        "username": "devJuneja",
                        "content": "They could have explained the question with better test cases. : |"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Absolute Garbage Explanation of 1st TC. I wonder why I woke @7:30 just to scream \"Good Morning\"."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I replied Happy Sunday! for the 4th problem 1403/1414"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Namaste sabhi namaste sabhi."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "description aisa do jisko dekhkr chocolate khaane ka mann kare zehar nahi :p"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "I am not able to understand the question waster 25 min.."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "Is the question really confusing or  am I the one who is stupid?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "For those having difficulty in understanding the question , I found one example that might help:\\nThe costs given to us are fixed:[20,1,15]\\nConsider a conveyer belt moving one step ahead each time. The conveyer belt has n types(here 3) of chocolates and price of each chocolate is the lane in front of which it is kept. So, initially, \\nCost:[20,1,15](remains fixed)\\nBelt:[0,1,2]\\nNow belt moves one step ahead(imagine it moving in ur head , it helps!)\\nCost:[20,1,15]                             [20,1,15]                [20,1,15]\\nBelt:[2,0,1]--moves with cost x->[1,2,0]--x cost---->[0,1,2]\\nSo we pick chocolates while conveyer belt is moving each type once and try to minimize cost . Here we pick all chocolates when they reach in front of 1 cost.\\nHope it helps!"
                    },
                    {
                        "username": "rnishant29",
                        "content": "nums: [15,150,56,69,214,203]\\nx: 42\\nhow answer 298 is possible?Please guide...\\nThanks.\\n"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@seafmch](/seafmch) That\\'s because after 1 operation you can get type 4 chocolate for min(nums[4], nums[5]) = min(214, 203) = 203. Same idea goes for type 5: min(nums[5], nums[0]) = min(203, 15) = 15.\\n\\nThough that idea is based on examples before they were updated (the description and examples were not clear enough, so I assumed that after performing operation, price for type i chocolate will be nums[(i+1)%n], where n = nums.length.\\n\\nAfter examples were clarified it\\'s clear that after 1 operation price for type i will be nums[i-1] (i>0).\\nSo after 1 operation you should calculate min possible price for type i as min(nums[i], nums[i-1]) (i>0).\\nBut it looks like they way you shift prices doesn\\'t effect the result since my initial approach passed all tests."
                    },
                    {
                        "username": "rnishant29",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot for great explanation!!!"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@VektorMD](/VektorMD) What? From 0 to 1, both 150 and 214 disappear. Why?"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@rnishant29](/rnishant29) me too"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@suniiiiidhi](/suniiiiidhi) My understanding to the problem was partially based on examples provided. Before they were updated, is seems like the logic was following: after one operation you can calculate a price for type i as min(nums[i], nums[(i+1)%n]) where n = nums.length.\n\nIf you perform k operations then you can calculate price as min(nums[i], .., nums[(i+k)%n]).\nSo lets take a look on all possible outcomes:\n0: [15,150,56,69,214,203] -- original\n1: [15,56,56,69,203,15]\n2: [15,56,56,69,15,15]\n3: [15,56,56,15,15,15]\n4: [15,56,15,15,15,15]\n5: [15,15,15,15,15,15]\n(number on the left  is amount of operations performed)\nConsidering the price of operation x = 42, minimum can be achieved after 3 operations (=298).\n\nBut examples for this problem now are updated. And you have to use reversed logic: after 1 operation for price for type i is min(nums[i], nums[(i-1)]) (for i > 0).\nI'm not sure if this change will affect testcases, maybe some of them will need an update"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) please elaborate"
                    },
                    {
                        "username": "VektorMD",
                        "content": "In 3 operations you can get type 0,3,4,5 for 15, type 1,2 for 56 = 4 * 15 + 56 * 2+42 * 3 = 298"
                    },
                    {
                        "username": "rnishant29",
                        "content": "I am getting 300 as minimum\\n"
                    }
                ]
            },
            {
                "id": 1929668,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "Problem creator was high on weeds."
                    },
                    {
                        "username": "15o1",
                        "content": "Is the explanation of first test case incorrect or am I just dumb??!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "Changing the type of chocolate from i to i+1 means that the price of chocolate i will become the price of chocolate i+1.\nSo lets take the original array for prices [20,1,15].\nAfter first operation we will get: [1, 15, 20]\nAfter second operation: [15, 20, 1]\nBut you don't have to shift values in array. You just need to calculate the index of value in original array that will represent current price after k operatioins.\nprice for element i after k operations = nums[(i+k)%n], where n = nums.length.\nSo after 1 operation, price for chocolate 0 = nums[1], for chocolate 1 = nums[2], for chocolate 2 = nums[0].\n[2,0,1] mean exactly that: values in that array represents types. And for prices -- position of element is matching position in nums: for type 2 it is 0, so the price for type 2 = nums[0];"
                    },
                    {
                        "username": "Wanhao",
                        "content": "[@tungpham](/tungpham) Now I find reason why i cant get the correct answer, this case so confusing on rotation direction "
                    },
                    {
                        "username": "ZQGao",
                        "content": "Same. Failed to understand this question. So *** confusing. And I think the first example is wrong."
                    },
                    {
                        "username": "uuu06222",
                        "content": "I think the [2,0,1] and [1,2,0] part in the description should be swapped"
                    },
                    {
                        "username": "Shkev",
                        "content": "It\\'s just very weirdly explained imo. Basically index `i` of `nums` tells you the price of chocolate `i`. When they call the operation, the index of the chocolates doesn\\'t change, but their types shift.\\nIn the first example they basically shift the type of the chocolates until every type falls on the chocolate that costs 1 and then they buy."
                    },
                    {
                        "username": "tungpham",
                        "content": "Same here. Couldn\\'t make sense of [0,1,2] becomes [2,0,1].It seems i => (i-1) instead of (i+1)"
                    },
                    {
                        "username": "shivamxSK",
                        "content": "description esa likho ki char log bhi na samaj paye\\n"
                    },
                    {
                        "username": "vishal75",
                        "content": "lol"
                    },
                    {
                        "username": "devJuneja",
                        "content": "They could have explained the question with better test cases. : |"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Absolute Garbage Explanation of 1st TC. I wonder why I woke @7:30 just to scream \"Good Morning\"."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I replied Happy Sunday! for the 4th problem 1403/1414"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Namaste sabhi namaste sabhi."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "description aisa do jisko dekhkr chocolate khaane ka mann kare zehar nahi :p"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "I am not able to understand the question waster 25 min.."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "Is the question really confusing or  am I the one who is stupid?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "For those having difficulty in understanding the question , I found one example that might help:\\nThe costs given to us are fixed:[20,1,15]\\nConsider a conveyer belt moving one step ahead each time. The conveyer belt has n types(here 3) of chocolates and price of each chocolate is the lane in front of which it is kept. So, initially, \\nCost:[20,1,15](remains fixed)\\nBelt:[0,1,2]\\nNow belt moves one step ahead(imagine it moving in ur head , it helps!)\\nCost:[20,1,15]                             [20,1,15]                [20,1,15]\\nBelt:[2,0,1]--moves with cost x->[1,2,0]--x cost---->[0,1,2]\\nSo we pick chocolates while conveyer belt is moving each type once and try to minimize cost . Here we pick all chocolates when they reach in front of 1 cost.\\nHope it helps!"
                    },
                    {
                        "username": "rnishant29",
                        "content": "nums: [15,150,56,69,214,203]\\nx: 42\\nhow answer 298 is possible?Please guide...\\nThanks.\\n"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@seafmch](/seafmch) That\\'s because after 1 operation you can get type 4 chocolate for min(nums[4], nums[5]) = min(214, 203) = 203. Same idea goes for type 5: min(nums[5], nums[0]) = min(203, 15) = 15.\\n\\nThough that idea is based on examples before they were updated (the description and examples were not clear enough, so I assumed that after performing operation, price for type i chocolate will be nums[(i+1)%n], where n = nums.length.\\n\\nAfter examples were clarified it\\'s clear that after 1 operation price for type i will be nums[i-1] (i>0).\\nSo after 1 operation you should calculate min possible price for type i as min(nums[i], nums[i-1]) (i>0).\\nBut it looks like they way you shift prices doesn\\'t effect the result since my initial approach passed all tests."
                    },
                    {
                        "username": "rnishant29",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot for great explanation!!!"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@VektorMD](/VektorMD) What? From 0 to 1, both 150 and 214 disappear. Why?"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@rnishant29](/rnishant29) me too"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@suniiiiidhi](/suniiiiidhi) My understanding to the problem was partially based on examples provided. Before they were updated, is seems like the logic was following: after one operation you can calculate a price for type i as min(nums[i], nums[(i+1)%n]) where n = nums.length.\n\nIf you perform k operations then you can calculate price as min(nums[i], .., nums[(i+k)%n]).\nSo lets take a look on all possible outcomes:\n0: [15,150,56,69,214,203] -- original\n1: [15,56,56,69,203,15]\n2: [15,56,56,69,15,15]\n3: [15,56,56,15,15,15]\n4: [15,56,15,15,15,15]\n5: [15,15,15,15,15,15]\n(number on the left  is amount of operations performed)\nConsidering the price of operation x = 42, minimum can be achieved after 3 operations (=298).\n\nBut examples for this problem now are updated. And you have to use reversed logic: after 1 operation for price for type i is min(nums[i], nums[(i-1)]) (for i > 0).\nI'm not sure if this change will affect testcases, maybe some of them will need an update"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) please elaborate"
                    },
                    {
                        "username": "VektorMD",
                        "content": "In 3 operations you can get type 0,3,4,5 for 15, type 1,2 for 56 = 4 * 15 + 56 * 2+42 * 3 = 298"
                    },
                    {
                        "username": "rnishant29",
                        "content": "I am getting 300 as minimum\\n"
                    }
                ]
            },
            {
                "id": 1924606,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "Problem creator was high on weeds."
                    },
                    {
                        "username": "15o1",
                        "content": "Is the explanation of first test case incorrect or am I just dumb??!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "Changing the type of chocolate from i to i+1 means that the price of chocolate i will become the price of chocolate i+1.\nSo lets take the original array for prices [20,1,15].\nAfter first operation we will get: [1, 15, 20]\nAfter second operation: [15, 20, 1]\nBut you don't have to shift values in array. You just need to calculate the index of value in original array that will represent current price after k operatioins.\nprice for element i after k operations = nums[(i+k)%n], where n = nums.length.\nSo after 1 operation, price for chocolate 0 = nums[1], for chocolate 1 = nums[2], for chocolate 2 = nums[0].\n[2,0,1] mean exactly that: values in that array represents types. And for prices -- position of element is matching position in nums: for type 2 it is 0, so the price for type 2 = nums[0];"
                    },
                    {
                        "username": "Wanhao",
                        "content": "[@tungpham](/tungpham) Now I find reason why i cant get the correct answer, this case so confusing on rotation direction "
                    },
                    {
                        "username": "ZQGao",
                        "content": "Same. Failed to understand this question. So *** confusing. And I think the first example is wrong."
                    },
                    {
                        "username": "uuu06222",
                        "content": "I think the [2,0,1] and [1,2,0] part in the description should be swapped"
                    },
                    {
                        "username": "Shkev",
                        "content": "It\\'s just very weirdly explained imo. Basically index `i` of `nums` tells you the price of chocolate `i`. When they call the operation, the index of the chocolates doesn\\'t change, but their types shift.\\nIn the first example they basically shift the type of the chocolates until every type falls on the chocolate that costs 1 and then they buy."
                    },
                    {
                        "username": "tungpham",
                        "content": "Same here. Couldn\\'t make sense of [0,1,2] becomes [2,0,1].It seems i => (i-1) instead of (i+1)"
                    },
                    {
                        "username": "shivamxSK",
                        "content": "description esa likho ki char log bhi na samaj paye\\n"
                    },
                    {
                        "username": "vishal75",
                        "content": "lol"
                    },
                    {
                        "username": "devJuneja",
                        "content": "They could have explained the question with better test cases. : |"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Absolute Garbage Explanation of 1st TC. I wonder why I woke @7:30 just to scream \"Good Morning\"."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I replied Happy Sunday! for the 4th problem 1403/1414"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Namaste sabhi namaste sabhi."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "description aisa do jisko dekhkr chocolate khaane ka mann kare zehar nahi :p"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "I am not able to understand the question waster 25 min.."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "Is the question really confusing or  am I the one who is stupid?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "For those having difficulty in understanding the question , I found one example that might help:\\nThe costs given to us are fixed:[20,1,15]\\nConsider a conveyer belt moving one step ahead each time. The conveyer belt has n types(here 3) of chocolates and price of each chocolate is the lane in front of which it is kept. So, initially, \\nCost:[20,1,15](remains fixed)\\nBelt:[0,1,2]\\nNow belt moves one step ahead(imagine it moving in ur head , it helps!)\\nCost:[20,1,15]                             [20,1,15]                [20,1,15]\\nBelt:[2,0,1]--moves with cost x->[1,2,0]--x cost---->[0,1,2]\\nSo we pick chocolates while conveyer belt is moving each type once and try to minimize cost . Here we pick all chocolates when they reach in front of 1 cost.\\nHope it helps!"
                    },
                    {
                        "username": "rnishant29",
                        "content": "nums: [15,150,56,69,214,203]\\nx: 42\\nhow answer 298 is possible?Please guide...\\nThanks.\\n"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@seafmch](/seafmch) That\\'s because after 1 operation you can get type 4 chocolate for min(nums[4], nums[5]) = min(214, 203) = 203. Same idea goes for type 5: min(nums[5], nums[0]) = min(203, 15) = 15.\\n\\nThough that idea is based on examples before they were updated (the description and examples were not clear enough, so I assumed that after performing operation, price for type i chocolate will be nums[(i+1)%n], where n = nums.length.\\n\\nAfter examples were clarified it\\'s clear that after 1 operation price for type i will be nums[i-1] (i>0).\\nSo after 1 operation you should calculate min possible price for type i as min(nums[i], nums[i-1]) (i>0).\\nBut it looks like they way you shift prices doesn\\'t effect the result since my initial approach passed all tests."
                    },
                    {
                        "username": "rnishant29",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot for great explanation!!!"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@VektorMD](/VektorMD) What? From 0 to 1, both 150 and 214 disappear. Why?"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@rnishant29](/rnishant29) me too"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@suniiiiidhi](/suniiiiidhi) My understanding to the problem was partially based on examples provided. Before they were updated, is seems like the logic was following: after one operation you can calculate a price for type i as min(nums[i], nums[(i+1)%n]) where n = nums.length.\n\nIf you perform k operations then you can calculate price as min(nums[i], .., nums[(i+k)%n]).\nSo lets take a look on all possible outcomes:\n0: [15,150,56,69,214,203] -- original\n1: [15,56,56,69,203,15]\n2: [15,56,56,69,15,15]\n3: [15,56,56,15,15,15]\n4: [15,56,15,15,15,15]\n5: [15,15,15,15,15,15]\n(number on the left  is amount of operations performed)\nConsidering the price of operation x = 42, minimum can be achieved after 3 operations (=298).\n\nBut examples for this problem now are updated. And you have to use reversed logic: after 1 operation for price for type i is min(nums[i], nums[(i-1)]) (for i > 0).\nI'm not sure if this change will affect testcases, maybe some of them will need an update"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) please elaborate"
                    },
                    {
                        "username": "VektorMD",
                        "content": "In 3 operations you can get type 0,3,4,5 for 15, type 1,2 for 56 = 4 * 15 + 56 * 2+42 * 3 = 298"
                    },
                    {
                        "username": "rnishant29",
                        "content": "I am getting 300 as minimum\\n"
                    }
                ]
            },
            {
                "id": 1924809,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "Problem creator was high on weeds."
                    },
                    {
                        "username": "15o1",
                        "content": "Is the explanation of first test case incorrect or am I just dumb??!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "Changing the type of chocolate from i to i+1 means that the price of chocolate i will become the price of chocolate i+1.\nSo lets take the original array for prices [20,1,15].\nAfter first operation we will get: [1, 15, 20]\nAfter second operation: [15, 20, 1]\nBut you don't have to shift values in array. You just need to calculate the index of value in original array that will represent current price after k operatioins.\nprice for element i after k operations = nums[(i+k)%n], where n = nums.length.\nSo after 1 operation, price for chocolate 0 = nums[1], for chocolate 1 = nums[2], for chocolate 2 = nums[0].\n[2,0,1] mean exactly that: values in that array represents types. And for prices -- position of element is matching position in nums: for type 2 it is 0, so the price for type 2 = nums[0];"
                    },
                    {
                        "username": "Wanhao",
                        "content": "[@tungpham](/tungpham) Now I find reason why i cant get the correct answer, this case so confusing on rotation direction "
                    },
                    {
                        "username": "ZQGao",
                        "content": "Same. Failed to understand this question. So *** confusing. And I think the first example is wrong."
                    },
                    {
                        "username": "uuu06222",
                        "content": "I think the [2,0,1] and [1,2,0] part in the description should be swapped"
                    },
                    {
                        "username": "Shkev",
                        "content": "It\\'s just very weirdly explained imo. Basically index `i` of `nums` tells you the price of chocolate `i`. When they call the operation, the index of the chocolates doesn\\'t change, but their types shift.\\nIn the first example they basically shift the type of the chocolates until every type falls on the chocolate that costs 1 and then they buy."
                    },
                    {
                        "username": "tungpham",
                        "content": "Same here. Couldn\\'t make sense of [0,1,2] becomes [2,0,1].It seems i => (i-1) instead of (i+1)"
                    },
                    {
                        "username": "shivamxSK",
                        "content": "description esa likho ki char log bhi na samaj paye\\n"
                    },
                    {
                        "username": "vishal75",
                        "content": "lol"
                    },
                    {
                        "username": "devJuneja",
                        "content": "They could have explained the question with better test cases. : |"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Absolute Garbage Explanation of 1st TC. I wonder why I woke @7:30 just to scream \"Good Morning\"."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I replied Happy Sunday! for the 4th problem 1403/1414"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Namaste sabhi namaste sabhi."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "description aisa do jisko dekhkr chocolate khaane ka mann kare zehar nahi :p"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "I am not able to understand the question waster 25 min.."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "Is the question really confusing or  am I the one who is stupid?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "For those having difficulty in understanding the question , I found one example that might help:\\nThe costs given to us are fixed:[20,1,15]\\nConsider a conveyer belt moving one step ahead each time. The conveyer belt has n types(here 3) of chocolates and price of each chocolate is the lane in front of which it is kept. So, initially, \\nCost:[20,1,15](remains fixed)\\nBelt:[0,1,2]\\nNow belt moves one step ahead(imagine it moving in ur head , it helps!)\\nCost:[20,1,15]                             [20,1,15]                [20,1,15]\\nBelt:[2,0,1]--moves with cost x->[1,2,0]--x cost---->[0,1,2]\\nSo we pick chocolates while conveyer belt is moving each type once and try to minimize cost . Here we pick all chocolates when they reach in front of 1 cost.\\nHope it helps!"
                    },
                    {
                        "username": "rnishant29",
                        "content": "nums: [15,150,56,69,214,203]\\nx: 42\\nhow answer 298 is possible?Please guide...\\nThanks.\\n"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@seafmch](/seafmch) That\\'s because after 1 operation you can get type 4 chocolate for min(nums[4], nums[5]) = min(214, 203) = 203. Same idea goes for type 5: min(nums[5], nums[0]) = min(203, 15) = 15.\\n\\nThough that idea is based on examples before they were updated (the description and examples were not clear enough, so I assumed that after performing operation, price for type i chocolate will be nums[(i+1)%n], where n = nums.length.\\n\\nAfter examples were clarified it\\'s clear that after 1 operation price for type i will be nums[i-1] (i>0).\\nSo after 1 operation you should calculate min possible price for type i as min(nums[i], nums[i-1]) (i>0).\\nBut it looks like they way you shift prices doesn\\'t effect the result since my initial approach passed all tests."
                    },
                    {
                        "username": "rnishant29",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot for great explanation!!!"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@VektorMD](/VektorMD) What? From 0 to 1, both 150 and 214 disappear. Why?"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@rnishant29](/rnishant29) me too"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@suniiiiidhi](/suniiiiidhi) My understanding to the problem was partially based on examples provided. Before they were updated, is seems like the logic was following: after one operation you can calculate a price for type i as min(nums[i], nums[(i+1)%n]) where n = nums.length.\n\nIf you perform k operations then you can calculate price as min(nums[i], .., nums[(i+k)%n]).\nSo lets take a look on all possible outcomes:\n0: [15,150,56,69,214,203] -- original\n1: [15,56,56,69,203,15]\n2: [15,56,56,69,15,15]\n3: [15,56,56,15,15,15]\n4: [15,56,15,15,15,15]\n5: [15,15,15,15,15,15]\n(number on the left  is amount of operations performed)\nConsidering the price of operation x = 42, minimum can be achieved after 3 operations (=298).\n\nBut examples for this problem now are updated. And you have to use reversed logic: after 1 operation for price for type i is min(nums[i], nums[(i-1)]) (for i > 0).\nI'm not sure if this change will affect testcases, maybe some of them will need an update"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) please elaborate"
                    },
                    {
                        "username": "VektorMD",
                        "content": "In 3 operations you can get type 0,3,4,5 for 15, type 1,2 for 56 = 4 * 15 + 56 * 2+42 * 3 = 298"
                    },
                    {
                        "username": "rnishant29",
                        "content": "I am getting 300 as minimum\\n"
                    }
                ]
            },
            {
                "id": 1928079,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "Problem creator was high on weeds."
                    },
                    {
                        "username": "15o1",
                        "content": "Is the explanation of first test case incorrect or am I just dumb??!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "Changing the type of chocolate from i to i+1 means that the price of chocolate i will become the price of chocolate i+1.\nSo lets take the original array for prices [20,1,15].\nAfter first operation we will get: [1, 15, 20]\nAfter second operation: [15, 20, 1]\nBut you don't have to shift values in array. You just need to calculate the index of value in original array that will represent current price after k operatioins.\nprice for element i after k operations = nums[(i+k)%n], where n = nums.length.\nSo after 1 operation, price for chocolate 0 = nums[1], for chocolate 1 = nums[2], for chocolate 2 = nums[0].\n[2,0,1] mean exactly that: values in that array represents types. And for prices -- position of element is matching position in nums: for type 2 it is 0, so the price for type 2 = nums[0];"
                    },
                    {
                        "username": "Wanhao",
                        "content": "[@tungpham](/tungpham) Now I find reason why i cant get the correct answer, this case so confusing on rotation direction "
                    },
                    {
                        "username": "ZQGao",
                        "content": "Same. Failed to understand this question. So *** confusing. And I think the first example is wrong."
                    },
                    {
                        "username": "uuu06222",
                        "content": "I think the [2,0,1] and [1,2,0] part in the description should be swapped"
                    },
                    {
                        "username": "Shkev",
                        "content": "It\\'s just very weirdly explained imo. Basically index `i` of `nums` tells you the price of chocolate `i`. When they call the operation, the index of the chocolates doesn\\'t change, but their types shift.\\nIn the first example they basically shift the type of the chocolates until every type falls on the chocolate that costs 1 and then they buy."
                    },
                    {
                        "username": "tungpham",
                        "content": "Same here. Couldn\\'t make sense of [0,1,2] becomes [2,0,1].It seems i => (i-1) instead of (i+1)"
                    },
                    {
                        "username": "shivamxSK",
                        "content": "description esa likho ki char log bhi na samaj paye\\n"
                    },
                    {
                        "username": "vishal75",
                        "content": "lol"
                    },
                    {
                        "username": "devJuneja",
                        "content": "They could have explained the question with better test cases. : |"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Absolute Garbage Explanation of 1st TC. I wonder why I woke @7:30 just to scream \"Good Morning\"."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I replied Happy Sunday! for the 4th problem 1403/1414"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Namaste sabhi namaste sabhi."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "description aisa do jisko dekhkr chocolate khaane ka mann kare zehar nahi :p"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "I am not able to understand the question waster 25 min.."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "Is the question really confusing or  am I the one who is stupid?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "For those having difficulty in understanding the question , I found one example that might help:\\nThe costs given to us are fixed:[20,1,15]\\nConsider a conveyer belt moving one step ahead each time. The conveyer belt has n types(here 3) of chocolates and price of each chocolate is the lane in front of which it is kept. So, initially, \\nCost:[20,1,15](remains fixed)\\nBelt:[0,1,2]\\nNow belt moves one step ahead(imagine it moving in ur head , it helps!)\\nCost:[20,1,15]                             [20,1,15]                [20,1,15]\\nBelt:[2,0,1]--moves with cost x->[1,2,0]--x cost---->[0,1,2]\\nSo we pick chocolates while conveyer belt is moving each type once and try to minimize cost . Here we pick all chocolates when they reach in front of 1 cost.\\nHope it helps!"
                    },
                    {
                        "username": "rnishant29",
                        "content": "nums: [15,150,56,69,214,203]\\nx: 42\\nhow answer 298 is possible?Please guide...\\nThanks.\\n"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@seafmch](/seafmch) That\\'s because after 1 operation you can get type 4 chocolate for min(nums[4], nums[5]) = min(214, 203) = 203. Same idea goes for type 5: min(nums[5], nums[0]) = min(203, 15) = 15.\\n\\nThough that idea is based on examples before they were updated (the description and examples were not clear enough, so I assumed that after performing operation, price for type i chocolate will be nums[(i+1)%n], where n = nums.length.\\n\\nAfter examples were clarified it\\'s clear that after 1 operation price for type i will be nums[i-1] (i>0).\\nSo after 1 operation you should calculate min possible price for type i as min(nums[i], nums[i-1]) (i>0).\\nBut it looks like they way you shift prices doesn\\'t effect the result since my initial approach passed all tests."
                    },
                    {
                        "username": "rnishant29",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot for great explanation!!!"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@VektorMD](/VektorMD) What? From 0 to 1, both 150 and 214 disappear. Why?"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@rnishant29](/rnishant29) me too"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@suniiiiidhi](/suniiiiidhi) My understanding to the problem was partially based on examples provided. Before they were updated, is seems like the logic was following: after one operation you can calculate a price for type i as min(nums[i], nums[(i+1)%n]) where n = nums.length.\n\nIf you perform k operations then you can calculate price as min(nums[i], .., nums[(i+k)%n]).\nSo lets take a look on all possible outcomes:\n0: [15,150,56,69,214,203] -- original\n1: [15,56,56,69,203,15]\n2: [15,56,56,69,15,15]\n3: [15,56,56,15,15,15]\n4: [15,56,15,15,15,15]\n5: [15,15,15,15,15,15]\n(number on the left  is amount of operations performed)\nConsidering the price of operation x = 42, minimum can be achieved after 3 operations (=298).\n\nBut examples for this problem now are updated. And you have to use reversed logic: after 1 operation for price for type i is min(nums[i], nums[(i-1)]) (for i > 0).\nI'm not sure if this change will affect testcases, maybe some of them will need an update"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) please elaborate"
                    },
                    {
                        "username": "VektorMD",
                        "content": "In 3 operations you can get type 0,3,4,5 for 15, type 1,2 for 56 = 4 * 15 + 56 * 2+42 * 3 = 298"
                    },
                    {
                        "username": "rnishant29",
                        "content": "I am getting 300 as minimum\\n"
                    }
                ]
            },
            {
                "id": 1924544,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "Problem creator was high on weeds."
                    },
                    {
                        "username": "15o1",
                        "content": "Is the explanation of first test case incorrect or am I just dumb??!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "Changing the type of chocolate from i to i+1 means that the price of chocolate i will become the price of chocolate i+1.\nSo lets take the original array for prices [20,1,15].\nAfter first operation we will get: [1, 15, 20]\nAfter second operation: [15, 20, 1]\nBut you don't have to shift values in array. You just need to calculate the index of value in original array that will represent current price after k operatioins.\nprice for element i after k operations = nums[(i+k)%n], where n = nums.length.\nSo after 1 operation, price for chocolate 0 = nums[1], for chocolate 1 = nums[2], for chocolate 2 = nums[0].\n[2,0,1] mean exactly that: values in that array represents types. And for prices -- position of element is matching position in nums: for type 2 it is 0, so the price for type 2 = nums[0];"
                    },
                    {
                        "username": "Wanhao",
                        "content": "[@tungpham](/tungpham) Now I find reason why i cant get the correct answer, this case so confusing on rotation direction "
                    },
                    {
                        "username": "ZQGao",
                        "content": "Same. Failed to understand this question. So *** confusing. And I think the first example is wrong."
                    },
                    {
                        "username": "uuu06222",
                        "content": "I think the [2,0,1] and [1,2,0] part in the description should be swapped"
                    },
                    {
                        "username": "Shkev",
                        "content": "It\\'s just very weirdly explained imo. Basically index `i` of `nums` tells you the price of chocolate `i`. When they call the operation, the index of the chocolates doesn\\'t change, but their types shift.\\nIn the first example they basically shift the type of the chocolates until every type falls on the chocolate that costs 1 and then they buy."
                    },
                    {
                        "username": "tungpham",
                        "content": "Same here. Couldn\\'t make sense of [0,1,2] becomes [2,0,1].It seems i => (i-1) instead of (i+1)"
                    },
                    {
                        "username": "shivamxSK",
                        "content": "description esa likho ki char log bhi na samaj paye\\n"
                    },
                    {
                        "username": "vishal75",
                        "content": "lol"
                    },
                    {
                        "username": "devJuneja",
                        "content": "They could have explained the question with better test cases. : |"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Absolute Garbage Explanation of 1st TC. I wonder why I woke @7:30 just to scream \"Good Morning\"."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I replied Happy Sunday! for the 4th problem 1403/1414"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Namaste sabhi namaste sabhi."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "description aisa do jisko dekhkr chocolate khaane ka mann kare zehar nahi :p"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "I am not able to understand the question waster 25 min.."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "Is the question really confusing or  am I the one who is stupid?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "For those having difficulty in understanding the question , I found one example that might help:\\nThe costs given to us are fixed:[20,1,15]\\nConsider a conveyer belt moving one step ahead each time. The conveyer belt has n types(here 3) of chocolates and price of each chocolate is the lane in front of which it is kept. So, initially, \\nCost:[20,1,15](remains fixed)\\nBelt:[0,1,2]\\nNow belt moves one step ahead(imagine it moving in ur head , it helps!)\\nCost:[20,1,15]                             [20,1,15]                [20,1,15]\\nBelt:[2,0,1]--moves with cost x->[1,2,0]--x cost---->[0,1,2]\\nSo we pick chocolates while conveyer belt is moving each type once and try to minimize cost . Here we pick all chocolates when they reach in front of 1 cost.\\nHope it helps!"
                    },
                    {
                        "username": "rnishant29",
                        "content": "nums: [15,150,56,69,214,203]\\nx: 42\\nhow answer 298 is possible?Please guide...\\nThanks.\\n"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@seafmch](/seafmch) That\\'s because after 1 operation you can get type 4 chocolate for min(nums[4], nums[5]) = min(214, 203) = 203. Same idea goes for type 5: min(nums[5], nums[0]) = min(203, 15) = 15.\\n\\nThough that idea is based on examples before they were updated (the description and examples were not clear enough, so I assumed that after performing operation, price for type i chocolate will be nums[(i+1)%n], where n = nums.length.\\n\\nAfter examples were clarified it\\'s clear that after 1 operation price for type i will be nums[i-1] (i>0).\\nSo after 1 operation you should calculate min possible price for type i as min(nums[i], nums[i-1]) (i>0).\\nBut it looks like they way you shift prices doesn\\'t effect the result since my initial approach passed all tests."
                    },
                    {
                        "username": "rnishant29",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot for great explanation!!!"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@VektorMD](/VektorMD) What? From 0 to 1, both 150 and 214 disappear. Why?"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@rnishant29](/rnishant29) me too"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@suniiiiidhi](/suniiiiidhi) My understanding to the problem was partially based on examples provided. Before they were updated, is seems like the logic was following: after one operation you can calculate a price for type i as min(nums[i], nums[(i+1)%n]) where n = nums.length.\n\nIf you perform k operations then you can calculate price as min(nums[i], .., nums[(i+k)%n]).\nSo lets take a look on all possible outcomes:\n0: [15,150,56,69,214,203] -- original\n1: [15,56,56,69,203,15]\n2: [15,56,56,69,15,15]\n3: [15,56,56,15,15,15]\n4: [15,56,15,15,15,15]\n5: [15,15,15,15,15,15]\n(number on the left  is amount of operations performed)\nConsidering the price of operation x = 42, minimum can be achieved after 3 operations (=298).\n\nBut examples for this problem now are updated. And you have to use reversed logic: after 1 operation for price for type i is min(nums[i], nums[(i-1)]) (for i > 0).\nI'm not sure if this change will affect testcases, maybe some of them will need an update"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) please elaborate"
                    },
                    {
                        "username": "VektorMD",
                        "content": "In 3 operations you can get type 0,3,4,5 for 15, type 1,2 for 56 = 4 * 15 + 56 * 2+42 * 3 = 298"
                    },
                    {
                        "username": "rnishant29",
                        "content": "I am getting 300 as minimum\\n"
                    }
                ]
            },
            {
                "id": 1924921,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "Problem creator was high on weeds."
                    },
                    {
                        "username": "15o1",
                        "content": "Is the explanation of first test case incorrect or am I just dumb??!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "Changing the type of chocolate from i to i+1 means that the price of chocolate i will become the price of chocolate i+1.\nSo lets take the original array for prices [20,1,15].\nAfter first operation we will get: [1, 15, 20]\nAfter second operation: [15, 20, 1]\nBut you don't have to shift values in array. You just need to calculate the index of value in original array that will represent current price after k operatioins.\nprice for element i after k operations = nums[(i+k)%n], where n = nums.length.\nSo after 1 operation, price for chocolate 0 = nums[1], for chocolate 1 = nums[2], for chocolate 2 = nums[0].\n[2,0,1] mean exactly that: values in that array represents types. And for prices -- position of element is matching position in nums: for type 2 it is 0, so the price for type 2 = nums[0];"
                    },
                    {
                        "username": "Wanhao",
                        "content": "[@tungpham](/tungpham) Now I find reason why i cant get the correct answer, this case so confusing on rotation direction "
                    },
                    {
                        "username": "ZQGao",
                        "content": "Same. Failed to understand this question. So *** confusing. And I think the first example is wrong."
                    },
                    {
                        "username": "uuu06222",
                        "content": "I think the [2,0,1] and [1,2,0] part in the description should be swapped"
                    },
                    {
                        "username": "Shkev",
                        "content": "It\\'s just very weirdly explained imo. Basically index `i` of `nums` tells you the price of chocolate `i`. When they call the operation, the index of the chocolates doesn\\'t change, but their types shift.\\nIn the first example they basically shift the type of the chocolates until every type falls on the chocolate that costs 1 and then they buy."
                    },
                    {
                        "username": "tungpham",
                        "content": "Same here. Couldn\\'t make sense of [0,1,2] becomes [2,0,1].It seems i => (i-1) instead of (i+1)"
                    },
                    {
                        "username": "shivamxSK",
                        "content": "description esa likho ki char log bhi na samaj paye\\n"
                    },
                    {
                        "username": "vishal75",
                        "content": "lol"
                    },
                    {
                        "username": "devJuneja",
                        "content": "They could have explained the question with better test cases. : |"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Absolute Garbage Explanation of 1st TC. I wonder why I woke @7:30 just to scream \"Good Morning\"."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I replied Happy Sunday! for the 4th problem 1403/1414"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Namaste sabhi namaste sabhi."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "description aisa do jisko dekhkr chocolate khaane ka mann kare zehar nahi :p"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "I am not able to understand the question waster 25 min.."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "Is the question really confusing or  am I the one who is stupid?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "For those having difficulty in understanding the question , I found one example that might help:\\nThe costs given to us are fixed:[20,1,15]\\nConsider a conveyer belt moving one step ahead each time. The conveyer belt has n types(here 3) of chocolates and price of each chocolate is the lane in front of which it is kept. So, initially, \\nCost:[20,1,15](remains fixed)\\nBelt:[0,1,2]\\nNow belt moves one step ahead(imagine it moving in ur head , it helps!)\\nCost:[20,1,15]                             [20,1,15]                [20,1,15]\\nBelt:[2,0,1]--moves with cost x->[1,2,0]--x cost---->[0,1,2]\\nSo we pick chocolates while conveyer belt is moving each type once and try to minimize cost . Here we pick all chocolates when they reach in front of 1 cost.\\nHope it helps!"
                    },
                    {
                        "username": "rnishant29",
                        "content": "nums: [15,150,56,69,214,203]\\nx: 42\\nhow answer 298 is possible?Please guide...\\nThanks.\\n"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@seafmch](/seafmch) That\\'s because after 1 operation you can get type 4 chocolate for min(nums[4], nums[5]) = min(214, 203) = 203. Same idea goes for type 5: min(nums[5], nums[0]) = min(203, 15) = 15.\\n\\nThough that idea is based on examples before they were updated (the description and examples were not clear enough, so I assumed that after performing operation, price for type i chocolate will be nums[(i+1)%n], where n = nums.length.\\n\\nAfter examples were clarified it\\'s clear that after 1 operation price for type i will be nums[i-1] (i>0).\\nSo after 1 operation you should calculate min possible price for type i as min(nums[i], nums[i-1]) (i>0).\\nBut it looks like they way you shift prices doesn\\'t effect the result since my initial approach passed all tests."
                    },
                    {
                        "username": "rnishant29",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot for great explanation!!!"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@VektorMD](/VektorMD) What? From 0 to 1, both 150 and 214 disappear. Why?"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@rnishant29](/rnishant29) me too"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@suniiiiidhi](/suniiiiidhi) My understanding to the problem was partially based on examples provided. Before they were updated, is seems like the logic was following: after one operation you can calculate a price for type i as min(nums[i], nums[(i+1)%n]) where n = nums.length.\n\nIf you perform k operations then you can calculate price as min(nums[i], .., nums[(i+k)%n]).\nSo lets take a look on all possible outcomes:\n0: [15,150,56,69,214,203] -- original\n1: [15,56,56,69,203,15]\n2: [15,56,56,69,15,15]\n3: [15,56,56,15,15,15]\n4: [15,56,15,15,15,15]\n5: [15,15,15,15,15,15]\n(number on the left  is amount of operations performed)\nConsidering the price of operation x = 42, minimum can be achieved after 3 operations (=298).\n\nBut examples for this problem now are updated. And you have to use reversed logic: after 1 operation for price for type i is min(nums[i], nums[(i-1)]) (for i > 0).\nI'm not sure if this change will affect testcases, maybe some of them will need an update"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) please elaborate"
                    },
                    {
                        "username": "VektorMD",
                        "content": "In 3 operations you can get type 0,3,4,5 for 15, type 1,2 for 56 = 4 * 15 + 56 * 2+42 * 3 = 298"
                    },
                    {
                        "username": "rnishant29",
                        "content": "I am getting 300 as minimum\\n"
                    }
                ]
            },
            {
                "id": 1926785,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "Problem creator was high on weeds."
                    },
                    {
                        "username": "15o1",
                        "content": "Is the explanation of first test case incorrect or am I just dumb??!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "Changing the type of chocolate from i to i+1 means that the price of chocolate i will become the price of chocolate i+1.\nSo lets take the original array for prices [20,1,15].\nAfter first operation we will get: [1, 15, 20]\nAfter second operation: [15, 20, 1]\nBut you don't have to shift values in array. You just need to calculate the index of value in original array that will represent current price after k operatioins.\nprice for element i after k operations = nums[(i+k)%n], where n = nums.length.\nSo after 1 operation, price for chocolate 0 = nums[1], for chocolate 1 = nums[2], for chocolate 2 = nums[0].\n[2,0,1] mean exactly that: values in that array represents types. And for prices -- position of element is matching position in nums: for type 2 it is 0, so the price for type 2 = nums[0];"
                    },
                    {
                        "username": "Wanhao",
                        "content": "[@tungpham](/tungpham) Now I find reason why i cant get the correct answer, this case so confusing on rotation direction "
                    },
                    {
                        "username": "ZQGao",
                        "content": "Same. Failed to understand this question. So *** confusing. And I think the first example is wrong."
                    },
                    {
                        "username": "uuu06222",
                        "content": "I think the [2,0,1] and [1,2,0] part in the description should be swapped"
                    },
                    {
                        "username": "Shkev",
                        "content": "It\\'s just very weirdly explained imo. Basically index `i` of `nums` tells you the price of chocolate `i`. When they call the operation, the index of the chocolates doesn\\'t change, but their types shift.\\nIn the first example they basically shift the type of the chocolates until every type falls on the chocolate that costs 1 and then they buy."
                    },
                    {
                        "username": "tungpham",
                        "content": "Same here. Couldn\\'t make sense of [0,1,2] becomes [2,0,1].It seems i => (i-1) instead of (i+1)"
                    },
                    {
                        "username": "shivamxSK",
                        "content": "description esa likho ki char log bhi na samaj paye\\n"
                    },
                    {
                        "username": "vishal75",
                        "content": "lol"
                    },
                    {
                        "username": "devJuneja",
                        "content": "They could have explained the question with better test cases. : |"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Absolute Garbage Explanation of 1st TC. I wonder why I woke @7:30 just to scream \"Good Morning\"."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I replied Happy Sunday! for the 4th problem 1403/1414"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Namaste sabhi namaste sabhi."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "description aisa do jisko dekhkr chocolate khaane ka mann kare zehar nahi :p"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "I am not able to understand the question waster 25 min.."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "Is the question really confusing or  am I the one who is stupid?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "For those having difficulty in understanding the question , I found one example that might help:\\nThe costs given to us are fixed:[20,1,15]\\nConsider a conveyer belt moving one step ahead each time. The conveyer belt has n types(here 3) of chocolates and price of each chocolate is the lane in front of which it is kept. So, initially, \\nCost:[20,1,15](remains fixed)\\nBelt:[0,1,2]\\nNow belt moves one step ahead(imagine it moving in ur head , it helps!)\\nCost:[20,1,15]                             [20,1,15]                [20,1,15]\\nBelt:[2,0,1]--moves with cost x->[1,2,0]--x cost---->[0,1,2]\\nSo we pick chocolates while conveyer belt is moving each type once and try to minimize cost . Here we pick all chocolates when they reach in front of 1 cost.\\nHope it helps!"
                    },
                    {
                        "username": "rnishant29",
                        "content": "nums: [15,150,56,69,214,203]\\nx: 42\\nhow answer 298 is possible?Please guide...\\nThanks.\\n"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@seafmch](/seafmch) That\\'s because after 1 operation you can get type 4 chocolate for min(nums[4], nums[5]) = min(214, 203) = 203. Same idea goes for type 5: min(nums[5], nums[0]) = min(203, 15) = 15.\\n\\nThough that idea is based on examples before they were updated (the description and examples were not clear enough, so I assumed that after performing operation, price for type i chocolate will be nums[(i+1)%n], where n = nums.length.\\n\\nAfter examples were clarified it\\'s clear that after 1 operation price for type i will be nums[i-1] (i>0).\\nSo after 1 operation you should calculate min possible price for type i as min(nums[i], nums[i-1]) (i>0).\\nBut it looks like they way you shift prices doesn\\'t effect the result since my initial approach passed all tests."
                    },
                    {
                        "username": "rnishant29",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot for great explanation!!!"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@VektorMD](/VektorMD) What? From 0 to 1, both 150 and 214 disappear. Why?"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@rnishant29](/rnishant29) me too"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@suniiiiidhi](/suniiiiidhi) My understanding to the problem was partially based on examples provided. Before they were updated, is seems like the logic was following: after one operation you can calculate a price for type i as min(nums[i], nums[(i+1)%n]) where n = nums.length.\n\nIf you perform k operations then you can calculate price as min(nums[i], .., nums[(i+k)%n]).\nSo lets take a look on all possible outcomes:\n0: [15,150,56,69,214,203] -- original\n1: [15,56,56,69,203,15]\n2: [15,56,56,69,15,15]\n3: [15,56,56,15,15,15]\n4: [15,56,15,15,15,15]\n5: [15,15,15,15,15,15]\n(number on the left  is amount of operations performed)\nConsidering the price of operation x = 42, minimum can be achieved after 3 operations (=298).\n\nBut examples for this problem now are updated. And you have to use reversed logic: after 1 operation for price for type i is min(nums[i], nums[(i-1)]) (for i > 0).\nI'm not sure if this change will affect testcases, maybe some of them will need an update"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) please elaborate"
                    },
                    {
                        "username": "VektorMD",
                        "content": "In 3 operations you can get type 0,3,4,5 for 15, type 1,2 for 56 = 4 * 15 + 56 * 2+42 * 3 = 298"
                    },
                    {
                        "username": "rnishant29",
                        "content": "I am getting 300 as minimum\\n"
                    }
                ]
            },
            {
                "id": 1925197,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "Problem creator was high on weeds."
                    },
                    {
                        "username": "15o1",
                        "content": "Is the explanation of first test case incorrect or am I just dumb??!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "Changing the type of chocolate from i to i+1 means that the price of chocolate i will become the price of chocolate i+1.\nSo lets take the original array for prices [20,1,15].\nAfter first operation we will get: [1, 15, 20]\nAfter second operation: [15, 20, 1]\nBut you don't have to shift values in array. You just need to calculate the index of value in original array that will represent current price after k operatioins.\nprice for element i after k operations = nums[(i+k)%n], where n = nums.length.\nSo after 1 operation, price for chocolate 0 = nums[1], for chocolate 1 = nums[2], for chocolate 2 = nums[0].\n[2,0,1] mean exactly that: values in that array represents types. And for prices -- position of element is matching position in nums: for type 2 it is 0, so the price for type 2 = nums[0];"
                    },
                    {
                        "username": "Wanhao",
                        "content": "[@tungpham](/tungpham) Now I find reason why i cant get the correct answer, this case so confusing on rotation direction "
                    },
                    {
                        "username": "ZQGao",
                        "content": "Same. Failed to understand this question. So *** confusing. And I think the first example is wrong."
                    },
                    {
                        "username": "uuu06222",
                        "content": "I think the [2,0,1] and [1,2,0] part in the description should be swapped"
                    },
                    {
                        "username": "Shkev",
                        "content": "It\\'s just very weirdly explained imo. Basically index `i` of `nums` tells you the price of chocolate `i`. When they call the operation, the index of the chocolates doesn\\'t change, but their types shift.\\nIn the first example they basically shift the type of the chocolates until every type falls on the chocolate that costs 1 and then they buy."
                    },
                    {
                        "username": "tungpham",
                        "content": "Same here. Couldn\\'t make sense of [0,1,2] becomes [2,0,1].It seems i => (i-1) instead of (i+1)"
                    },
                    {
                        "username": "shivamxSK",
                        "content": "description esa likho ki char log bhi na samaj paye\\n"
                    },
                    {
                        "username": "vishal75",
                        "content": "lol"
                    },
                    {
                        "username": "devJuneja",
                        "content": "They could have explained the question with better test cases. : |"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Absolute Garbage Explanation of 1st TC. I wonder why I woke @7:30 just to scream \"Good Morning\"."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I replied Happy Sunday! for the 4th problem 1403/1414"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Namaste sabhi namaste sabhi."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "description aisa do jisko dekhkr chocolate khaane ka mann kare zehar nahi :p"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "I am not able to understand the question waster 25 min.."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "Is the question really confusing or  am I the one who is stupid?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "For those having difficulty in understanding the question , I found one example that might help:\\nThe costs given to us are fixed:[20,1,15]\\nConsider a conveyer belt moving one step ahead each time. The conveyer belt has n types(here 3) of chocolates and price of each chocolate is the lane in front of which it is kept. So, initially, \\nCost:[20,1,15](remains fixed)\\nBelt:[0,1,2]\\nNow belt moves one step ahead(imagine it moving in ur head , it helps!)\\nCost:[20,1,15]                             [20,1,15]                [20,1,15]\\nBelt:[2,0,1]--moves with cost x->[1,2,0]--x cost---->[0,1,2]\\nSo we pick chocolates while conveyer belt is moving each type once and try to minimize cost . Here we pick all chocolates when they reach in front of 1 cost.\\nHope it helps!"
                    },
                    {
                        "username": "rnishant29",
                        "content": "nums: [15,150,56,69,214,203]\\nx: 42\\nhow answer 298 is possible?Please guide...\\nThanks.\\n"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@seafmch](/seafmch) That\\'s because after 1 operation you can get type 4 chocolate for min(nums[4], nums[5]) = min(214, 203) = 203. Same idea goes for type 5: min(nums[5], nums[0]) = min(203, 15) = 15.\\n\\nThough that idea is based on examples before they were updated (the description and examples were not clear enough, so I assumed that after performing operation, price for type i chocolate will be nums[(i+1)%n], where n = nums.length.\\n\\nAfter examples were clarified it\\'s clear that after 1 operation price for type i will be nums[i-1] (i>0).\\nSo after 1 operation you should calculate min possible price for type i as min(nums[i], nums[i-1]) (i>0).\\nBut it looks like they way you shift prices doesn\\'t effect the result since my initial approach passed all tests."
                    },
                    {
                        "username": "rnishant29",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot for great explanation!!!"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@VektorMD](/VektorMD) What? From 0 to 1, both 150 and 214 disappear. Why?"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@rnishant29](/rnishant29) me too"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@suniiiiidhi](/suniiiiidhi) My understanding to the problem was partially based on examples provided. Before they were updated, is seems like the logic was following: after one operation you can calculate a price for type i as min(nums[i], nums[(i+1)%n]) where n = nums.length.\n\nIf you perform k operations then you can calculate price as min(nums[i], .., nums[(i+k)%n]).\nSo lets take a look on all possible outcomes:\n0: [15,150,56,69,214,203] -- original\n1: [15,56,56,69,203,15]\n2: [15,56,56,69,15,15]\n3: [15,56,56,15,15,15]\n4: [15,56,15,15,15,15]\n5: [15,15,15,15,15,15]\n(number on the left  is amount of operations performed)\nConsidering the price of operation x = 42, minimum can be achieved after 3 operations (=298).\n\nBut examples for this problem now are updated. And you have to use reversed logic: after 1 operation for price for type i is min(nums[i], nums[(i-1)]) (for i > 0).\nI'm not sure if this change will affect testcases, maybe some of them will need an update"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) please elaborate"
                    },
                    {
                        "username": "VektorMD",
                        "content": "In 3 operations you can get type 0,3,4,5 for 15, type 1,2 for 56 = 4 * 15 + 56 * 2+42 * 3 = 298"
                    },
                    {
                        "username": "rnishant29",
                        "content": "I am getting 300 as minimum\\n"
                    }
                ]
            },
            {
                "id": 1924944,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "Problem creator was high on weeds."
                    },
                    {
                        "username": "15o1",
                        "content": "Is the explanation of first test case incorrect or am I just dumb??!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "Changing the type of chocolate from i to i+1 means that the price of chocolate i will become the price of chocolate i+1.\nSo lets take the original array for prices [20,1,15].\nAfter first operation we will get: [1, 15, 20]\nAfter second operation: [15, 20, 1]\nBut you don't have to shift values in array. You just need to calculate the index of value in original array that will represent current price after k operatioins.\nprice for element i after k operations = nums[(i+k)%n], where n = nums.length.\nSo after 1 operation, price for chocolate 0 = nums[1], for chocolate 1 = nums[2], for chocolate 2 = nums[0].\n[2,0,1] mean exactly that: values in that array represents types. And for prices -- position of element is matching position in nums: for type 2 it is 0, so the price for type 2 = nums[0];"
                    },
                    {
                        "username": "Wanhao",
                        "content": "[@tungpham](/tungpham) Now I find reason why i cant get the correct answer, this case so confusing on rotation direction "
                    },
                    {
                        "username": "ZQGao",
                        "content": "Same. Failed to understand this question. So *** confusing. And I think the first example is wrong."
                    },
                    {
                        "username": "uuu06222",
                        "content": "I think the [2,0,1] and [1,2,0] part in the description should be swapped"
                    },
                    {
                        "username": "Shkev",
                        "content": "It\\'s just very weirdly explained imo. Basically index `i` of `nums` tells you the price of chocolate `i`. When they call the operation, the index of the chocolates doesn\\'t change, but their types shift.\\nIn the first example they basically shift the type of the chocolates until every type falls on the chocolate that costs 1 and then they buy."
                    },
                    {
                        "username": "tungpham",
                        "content": "Same here. Couldn\\'t make sense of [0,1,2] becomes [2,0,1].It seems i => (i-1) instead of (i+1)"
                    },
                    {
                        "username": "shivamxSK",
                        "content": "description esa likho ki char log bhi na samaj paye\\n"
                    },
                    {
                        "username": "vishal75",
                        "content": "lol"
                    },
                    {
                        "username": "devJuneja",
                        "content": "They could have explained the question with better test cases. : |"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Absolute Garbage Explanation of 1st TC. I wonder why I woke @7:30 just to scream \"Good Morning\"."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I replied Happy Sunday! for the 4th problem 1403/1414"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Namaste sabhi namaste sabhi."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "description aisa do jisko dekhkr chocolate khaane ka mann kare zehar nahi :p"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "I am not able to understand the question waster 25 min.."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "Is the question really confusing or  am I the one who is stupid?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "For those having difficulty in understanding the question , I found one example that might help:\\nThe costs given to us are fixed:[20,1,15]\\nConsider a conveyer belt moving one step ahead each time. The conveyer belt has n types(here 3) of chocolates and price of each chocolate is the lane in front of which it is kept. So, initially, \\nCost:[20,1,15](remains fixed)\\nBelt:[0,1,2]\\nNow belt moves one step ahead(imagine it moving in ur head , it helps!)\\nCost:[20,1,15]                             [20,1,15]                [20,1,15]\\nBelt:[2,0,1]--moves with cost x->[1,2,0]--x cost---->[0,1,2]\\nSo we pick chocolates while conveyer belt is moving each type once and try to minimize cost . Here we pick all chocolates when they reach in front of 1 cost.\\nHope it helps!"
                    },
                    {
                        "username": "rnishant29",
                        "content": "nums: [15,150,56,69,214,203]\\nx: 42\\nhow answer 298 is possible?Please guide...\\nThanks.\\n"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@seafmch](/seafmch) That\\'s because after 1 operation you can get type 4 chocolate for min(nums[4], nums[5]) = min(214, 203) = 203. Same idea goes for type 5: min(nums[5], nums[0]) = min(203, 15) = 15.\\n\\nThough that idea is based on examples before they were updated (the description and examples were not clear enough, so I assumed that after performing operation, price for type i chocolate will be nums[(i+1)%n], where n = nums.length.\\n\\nAfter examples were clarified it\\'s clear that after 1 operation price for type i will be nums[i-1] (i>0).\\nSo after 1 operation you should calculate min possible price for type i as min(nums[i], nums[i-1]) (i>0).\\nBut it looks like they way you shift prices doesn\\'t effect the result since my initial approach passed all tests."
                    },
                    {
                        "username": "rnishant29",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot for great explanation!!!"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@VektorMD](/VektorMD) What? From 0 to 1, both 150 and 214 disappear. Why?"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@rnishant29](/rnishant29) me too"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@suniiiiidhi](/suniiiiidhi) My understanding to the problem was partially based on examples provided. Before they were updated, is seems like the logic was following: after one operation you can calculate a price for type i as min(nums[i], nums[(i+1)%n]) where n = nums.length.\n\nIf you perform k operations then you can calculate price as min(nums[i], .., nums[(i+k)%n]).\nSo lets take a look on all possible outcomes:\n0: [15,150,56,69,214,203] -- original\n1: [15,56,56,69,203,15]\n2: [15,56,56,69,15,15]\n3: [15,56,56,15,15,15]\n4: [15,56,15,15,15,15]\n5: [15,15,15,15,15,15]\n(number on the left  is amount of operations performed)\nConsidering the price of operation x = 42, minimum can be achieved after 3 operations (=298).\n\nBut examples for this problem now are updated. And you have to use reversed logic: after 1 operation for price for type i is min(nums[i], nums[(i-1)]) (for i > 0).\nI'm not sure if this change will affect testcases, maybe some of them will need an update"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) please elaborate"
                    },
                    {
                        "username": "VektorMD",
                        "content": "In 3 operations you can get type 0,3,4,5 for 15, type 1,2 for 56 = 4 * 15 + 56 * 2+42 * 3 = 298"
                    },
                    {
                        "username": "rnishant29",
                        "content": "I am getting 300 as minimum\\n"
                    }
                ]
            },
            {
                "id": 1924530,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "Problem creator was high on weeds."
                    },
                    {
                        "username": "15o1",
                        "content": "Is the explanation of first test case incorrect or am I just dumb??!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "Changing the type of chocolate from i to i+1 means that the price of chocolate i will become the price of chocolate i+1.\nSo lets take the original array for prices [20,1,15].\nAfter first operation we will get: [1, 15, 20]\nAfter second operation: [15, 20, 1]\nBut you don't have to shift values in array. You just need to calculate the index of value in original array that will represent current price after k operatioins.\nprice for element i after k operations = nums[(i+k)%n], where n = nums.length.\nSo after 1 operation, price for chocolate 0 = nums[1], for chocolate 1 = nums[2], for chocolate 2 = nums[0].\n[2,0,1] mean exactly that: values in that array represents types. And for prices -- position of element is matching position in nums: for type 2 it is 0, so the price for type 2 = nums[0];"
                    },
                    {
                        "username": "Wanhao",
                        "content": "[@tungpham](/tungpham) Now I find reason why i cant get the correct answer, this case so confusing on rotation direction "
                    },
                    {
                        "username": "ZQGao",
                        "content": "Same. Failed to understand this question. So *** confusing. And I think the first example is wrong."
                    },
                    {
                        "username": "uuu06222",
                        "content": "I think the [2,0,1] and [1,2,0] part in the description should be swapped"
                    },
                    {
                        "username": "Shkev",
                        "content": "It\\'s just very weirdly explained imo. Basically index `i` of `nums` tells you the price of chocolate `i`. When they call the operation, the index of the chocolates doesn\\'t change, but their types shift.\\nIn the first example they basically shift the type of the chocolates until every type falls on the chocolate that costs 1 and then they buy."
                    },
                    {
                        "username": "tungpham",
                        "content": "Same here. Couldn\\'t make sense of [0,1,2] becomes [2,0,1].It seems i => (i-1) instead of (i+1)"
                    },
                    {
                        "username": "shivamxSK",
                        "content": "description esa likho ki char log bhi na samaj paye\\n"
                    },
                    {
                        "username": "vishal75",
                        "content": "lol"
                    },
                    {
                        "username": "devJuneja",
                        "content": "They could have explained the question with better test cases. : |"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Absolute Garbage Explanation of 1st TC. I wonder why I woke @7:30 just to scream \"Good Morning\"."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I replied Happy Sunday! for the 4th problem 1403/1414"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Namaste sabhi namaste sabhi."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "description aisa do jisko dekhkr chocolate khaane ka mann kare zehar nahi :p"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "I am not able to understand the question waster 25 min.."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "Is the question really confusing or  am I the one who is stupid?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "For those having difficulty in understanding the question , I found one example that might help:\\nThe costs given to us are fixed:[20,1,15]\\nConsider a conveyer belt moving one step ahead each time. The conveyer belt has n types(here 3) of chocolates and price of each chocolate is the lane in front of which it is kept. So, initially, \\nCost:[20,1,15](remains fixed)\\nBelt:[0,1,2]\\nNow belt moves one step ahead(imagine it moving in ur head , it helps!)\\nCost:[20,1,15]                             [20,1,15]                [20,1,15]\\nBelt:[2,0,1]--moves with cost x->[1,2,0]--x cost---->[0,1,2]\\nSo we pick chocolates while conveyer belt is moving each type once and try to minimize cost . Here we pick all chocolates when they reach in front of 1 cost.\\nHope it helps!"
                    },
                    {
                        "username": "rnishant29",
                        "content": "nums: [15,150,56,69,214,203]\\nx: 42\\nhow answer 298 is possible?Please guide...\\nThanks.\\n"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@seafmch](/seafmch) That\\'s because after 1 operation you can get type 4 chocolate for min(nums[4], nums[5]) = min(214, 203) = 203. Same idea goes for type 5: min(nums[5], nums[0]) = min(203, 15) = 15.\\n\\nThough that idea is based on examples before they were updated (the description and examples were not clear enough, so I assumed that after performing operation, price for type i chocolate will be nums[(i+1)%n], where n = nums.length.\\n\\nAfter examples were clarified it\\'s clear that after 1 operation price for type i will be nums[i-1] (i>0).\\nSo after 1 operation you should calculate min possible price for type i as min(nums[i], nums[i-1]) (i>0).\\nBut it looks like they way you shift prices doesn\\'t effect the result since my initial approach passed all tests."
                    },
                    {
                        "username": "rnishant29",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot for great explanation!!!"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@VektorMD](/VektorMD) What? From 0 to 1, both 150 and 214 disappear. Why?"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@rnishant29](/rnishant29) me too"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@suniiiiidhi](/suniiiiidhi) My understanding to the problem was partially based on examples provided. Before they were updated, is seems like the logic was following: after one operation you can calculate a price for type i as min(nums[i], nums[(i+1)%n]) where n = nums.length.\n\nIf you perform k operations then you can calculate price as min(nums[i], .., nums[(i+k)%n]).\nSo lets take a look on all possible outcomes:\n0: [15,150,56,69,214,203] -- original\n1: [15,56,56,69,203,15]\n2: [15,56,56,69,15,15]\n3: [15,56,56,15,15,15]\n4: [15,56,15,15,15,15]\n5: [15,15,15,15,15,15]\n(number on the left  is amount of operations performed)\nConsidering the price of operation x = 42, minimum can be achieved after 3 operations (=298).\n\nBut examples for this problem now are updated. And you have to use reversed logic: after 1 operation for price for type i is min(nums[i], nums[(i-1)]) (for i > 0).\nI'm not sure if this change will affect testcases, maybe some of them will need an update"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) please elaborate"
                    },
                    {
                        "username": "VektorMD",
                        "content": "In 3 operations you can get type 0,3,4,5 for 15, type 1,2 for 56 = 4 * 15 + 56 * 2+42 * 3 = 298"
                    },
                    {
                        "username": "rnishant29",
                        "content": "I am getting 300 as minimum\\n"
                    }
                ]
            },
            {
                "id": 1929668,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "Problem creator was high on weeds."
                    },
                    {
                        "username": "15o1",
                        "content": "Is the explanation of first test case incorrect or am I just dumb??!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "Changing the type of chocolate from i to i+1 means that the price of chocolate i will become the price of chocolate i+1.\nSo lets take the original array for prices [20,1,15].\nAfter first operation we will get: [1, 15, 20]\nAfter second operation: [15, 20, 1]\nBut you don't have to shift values in array. You just need to calculate the index of value in original array that will represent current price after k operatioins.\nprice for element i after k operations = nums[(i+k)%n], where n = nums.length.\nSo after 1 operation, price for chocolate 0 = nums[1], for chocolate 1 = nums[2], for chocolate 2 = nums[0].\n[2,0,1] mean exactly that: values in that array represents types. And for prices -- position of element is matching position in nums: for type 2 it is 0, so the price for type 2 = nums[0];"
                    },
                    {
                        "username": "Wanhao",
                        "content": "[@tungpham](/tungpham) Now I find reason why i cant get the correct answer, this case so confusing on rotation direction "
                    },
                    {
                        "username": "ZQGao",
                        "content": "Same. Failed to understand this question. So *** confusing. And I think the first example is wrong."
                    },
                    {
                        "username": "uuu06222",
                        "content": "I think the [2,0,1] and [1,2,0] part in the description should be swapped"
                    },
                    {
                        "username": "Shkev",
                        "content": "It\\'s just very weirdly explained imo. Basically index `i` of `nums` tells you the price of chocolate `i`. When they call the operation, the index of the chocolates doesn\\'t change, but their types shift.\\nIn the first example they basically shift the type of the chocolates until every type falls on the chocolate that costs 1 and then they buy."
                    },
                    {
                        "username": "tungpham",
                        "content": "Same here. Couldn\\'t make sense of [0,1,2] becomes [2,0,1].It seems i => (i-1) instead of (i+1)"
                    },
                    {
                        "username": "shivamxSK",
                        "content": "description esa likho ki char log bhi na samaj paye\\n"
                    },
                    {
                        "username": "vishal75",
                        "content": "lol"
                    },
                    {
                        "username": "devJuneja",
                        "content": "They could have explained the question with better test cases. : |"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Absolute Garbage Explanation of 1st TC. I wonder why I woke @7:30 just to scream \"Good Morning\"."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I replied Happy Sunday! for the 4th problem 1403/1414"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Namaste sabhi namaste sabhi."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "description aisa do jisko dekhkr chocolate khaane ka mann kare zehar nahi :p"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "I am not able to understand the question waster 25 min.."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "Is the question really confusing or  am I the one who is stupid?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "For those having difficulty in understanding the question , I found one example that might help:\\nThe costs given to us are fixed:[20,1,15]\\nConsider a conveyer belt moving one step ahead each time. The conveyer belt has n types(here 3) of chocolates and price of each chocolate is the lane in front of which it is kept. So, initially, \\nCost:[20,1,15](remains fixed)\\nBelt:[0,1,2]\\nNow belt moves one step ahead(imagine it moving in ur head , it helps!)\\nCost:[20,1,15]                             [20,1,15]                [20,1,15]\\nBelt:[2,0,1]--moves with cost x->[1,2,0]--x cost---->[0,1,2]\\nSo we pick chocolates while conveyer belt is moving each type once and try to minimize cost . Here we pick all chocolates when they reach in front of 1 cost.\\nHope it helps!"
                    },
                    {
                        "username": "rnishant29",
                        "content": "nums: [15,150,56,69,214,203]\\nx: 42\\nhow answer 298 is possible?Please guide...\\nThanks.\\n"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@seafmch](/seafmch) That\\'s because after 1 operation you can get type 4 chocolate for min(nums[4], nums[5]) = min(214, 203) = 203. Same idea goes for type 5: min(nums[5], nums[0]) = min(203, 15) = 15.\\n\\nThough that idea is based on examples before they were updated (the description and examples were not clear enough, so I assumed that after performing operation, price for type i chocolate will be nums[(i+1)%n], where n = nums.length.\\n\\nAfter examples were clarified it\\'s clear that after 1 operation price for type i will be nums[i-1] (i>0).\\nSo after 1 operation you should calculate min possible price for type i as min(nums[i], nums[i-1]) (i>0).\\nBut it looks like they way you shift prices doesn\\'t effect the result since my initial approach passed all tests."
                    },
                    {
                        "username": "rnishant29",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot for great explanation!!!"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@VektorMD](/VektorMD) What? From 0 to 1, both 150 and 214 disappear. Why?"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@rnishant29](/rnishant29) me too"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@suniiiiidhi](/suniiiiidhi) My understanding to the problem was partially based on examples provided. Before they were updated, is seems like the logic was following: after one operation you can calculate a price for type i as min(nums[i], nums[(i+1)%n]) where n = nums.length.\n\nIf you perform k operations then you can calculate price as min(nums[i], .., nums[(i+k)%n]).\nSo lets take a look on all possible outcomes:\n0: [15,150,56,69,214,203] -- original\n1: [15,56,56,69,203,15]\n2: [15,56,56,69,15,15]\n3: [15,56,56,15,15,15]\n4: [15,56,15,15,15,15]\n5: [15,15,15,15,15,15]\n(number on the left  is amount of operations performed)\nConsidering the price of operation x = 42, minimum can be achieved after 3 operations (=298).\n\nBut examples for this problem now are updated. And you have to use reversed logic: after 1 operation for price for type i is min(nums[i], nums[(i-1)]) (for i > 0).\nI'm not sure if this change will affect testcases, maybe some of them will need an update"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) please elaborate"
                    },
                    {
                        "username": "VektorMD",
                        "content": "In 3 operations you can get type 0,3,4,5 for 15, type 1,2 for 56 = 4 * 15 + 56 * 2+42 * 3 = 298"
                    },
                    {
                        "username": "rnishant29",
                        "content": "I am getting 300 as minimum\\n"
                    }
                ]
            },
            {
                "id": 1924606,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "Problem creator was high on weeds."
                    },
                    {
                        "username": "15o1",
                        "content": "Is the explanation of first test case incorrect or am I just dumb??!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "Changing the type of chocolate from i to i+1 means that the price of chocolate i will become the price of chocolate i+1.\nSo lets take the original array for prices [20,1,15].\nAfter first operation we will get: [1, 15, 20]\nAfter second operation: [15, 20, 1]\nBut you don't have to shift values in array. You just need to calculate the index of value in original array that will represent current price after k operatioins.\nprice for element i after k operations = nums[(i+k)%n], where n = nums.length.\nSo after 1 operation, price for chocolate 0 = nums[1], for chocolate 1 = nums[2], for chocolate 2 = nums[0].\n[2,0,1] mean exactly that: values in that array represents types. And for prices -- position of element is matching position in nums: for type 2 it is 0, so the price for type 2 = nums[0];"
                    },
                    {
                        "username": "Wanhao",
                        "content": "[@tungpham](/tungpham) Now I find reason why i cant get the correct answer, this case so confusing on rotation direction "
                    },
                    {
                        "username": "ZQGao",
                        "content": "Same. Failed to understand this question. So *** confusing. And I think the first example is wrong."
                    },
                    {
                        "username": "uuu06222",
                        "content": "I think the [2,0,1] and [1,2,0] part in the description should be swapped"
                    },
                    {
                        "username": "Shkev",
                        "content": "It\\'s just very weirdly explained imo. Basically index `i` of `nums` tells you the price of chocolate `i`. When they call the operation, the index of the chocolates doesn\\'t change, but their types shift.\\nIn the first example they basically shift the type of the chocolates until every type falls on the chocolate that costs 1 and then they buy."
                    },
                    {
                        "username": "tungpham",
                        "content": "Same here. Couldn\\'t make sense of [0,1,2] becomes [2,0,1].It seems i => (i-1) instead of (i+1)"
                    },
                    {
                        "username": "shivamxSK",
                        "content": "description esa likho ki char log bhi na samaj paye\\n"
                    },
                    {
                        "username": "vishal75",
                        "content": "lol"
                    },
                    {
                        "username": "devJuneja",
                        "content": "They could have explained the question with better test cases. : |"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Absolute Garbage Explanation of 1st TC. I wonder why I woke @7:30 just to scream \"Good Morning\"."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I replied Happy Sunday! for the 4th problem 1403/1414"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Namaste sabhi namaste sabhi."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "description aisa do jisko dekhkr chocolate khaane ka mann kare zehar nahi :p"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "I am not able to understand the question waster 25 min.."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "Is the question really confusing or  am I the one who is stupid?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "For those having difficulty in understanding the question , I found one example that might help:\\nThe costs given to us are fixed:[20,1,15]\\nConsider a conveyer belt moving one step ahead each time. The conveyer belt has n types(here 3) of chocolates and price of each chocolate is the lane in front of which it is kept. So, initially, \\nCost:[20,1,15](remains fixed)\\nBelt:[0,1,2]\\nNow belt moves one step ahead(imagine it moving in ur head , it helps!)\\nCost:[20,1,15]                             [20,1,15]                [20,1,15]\\nBelt:[2,0,1]--moves with cost x->[1,2,0]--x cost---->[0,1,2]\\nSo we pick chocolates while conveyer belt is moving each type once and try to minimize cost . Here we pick all chocolates when they reach in front of 1 cost.\\nHope it helps!"
                    },
                    {
                        "username": "rnishant29",
                        "content": "nums: [15,150,56,69,214,203]\\nx: 42\\nhow answer 298 is possible?Please guide...\\nThanks.\\n"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@seafmch](/seafmch) That\\'s because after 1 operation you can get type 4 chocolate for min(nums[4], nums[5]) = min(214, 203) = 203. Same idea goes for type 5: min(nums[5], nums[0]) = min(203, 15) = 15.\\n\\nThough that idea is based on examples before they were updated (the description and examples were not clear enough, so I assumed that after performing operation, price for type i chocolate will be nums[(i+1)%n], where n = nums.length.\\n\\nAfter examples were clarified it\\'s clear that after 1 operation price for type i will be nums[i-1] (i>0).\\nSo after 1 operation you should calculate min possible price for type i as min(nums[i], nums[i-1]) (i>0).\\nBut it looks like they way you shift prices doesn\\'t effect the result since my initial approach passed all tests."
                    },
                    {
                        "username": "rnishant29",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot for great explanation!!!"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@VektorMD](/VektorMD) What? From 0 to 1, both 150 and 214 disappear. Why?"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@rnishant29](/rnishant29) me too"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@suniiiiidhi](/suniiiiidhi) My understanding to the problem was partially based on examples provided. Before they were updated, is seems like the logic was following: after one operation you can calculate a price for type i as min(nums[i], nums[(i+1)%n]) where n = nums.length.\n\nIf you perform k operations then you can calculate price as min(nums[i], .., nums[(i+k)%n]).\nSo lets take a look on all possible outcomes:\n0: [15,150,56,69,214,203] -- original\n1: [15,56,56,69,203,15]\n2: [15,56,56,69,15,15]\n3: [15,56,56,15,15,15]\n4: [15,56,15,15,15,15]\n5: [15,15,15,15,15,15]\n(number on the left  is amount of operations performed)\nConsidering the price of operation x = 42, minimum can be achieved after 3 operations (=298).\n\nBut examples for this problem now are updated. And you have to use reversed logic: after 1 operation for price for type i is min(nums[i], nums[(i-1)]) (for i > 0).\nI'm not sure if this change will affect testcases, maybe some of them will need an update"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) please elaborate"
                    },
                    {
                        "username": "VektorMD",
                        "content": "In 3 operations you can get type 0,3,4,5 for 15, type 1,2 for 56 = 4 * 15 + 56 * 2+42 * 3 = 298"
                    },
                    {
                        "username": "rnishant29",
                        "content": "I am getting 300 as minimum\\n"
                    }
                ]
            },
            {
                "id": 1924809,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "Problem creator was high on weeds."
                    },
                    {
                        "username": "15o1",
                        "content": "Is the explanation of first test case incorrect or am I just dumb??!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "Changing the type of chocolate from i to i+1 means that the price of chocolate i will become the price of chocolate i+1.\nSo lets take the original array for prices [20,1,15].\nAfter first operation we will get: [1, 15, 20]\nAfter second operation: [15, 20, 1]\nBut you don't have to shift values in array. You just need to calculate the index of value in original array that will represent current price after k operatioins.\nprice for element i after k operations = nums[(i+k)%n], where n = nums.length.\nSo after 1 operation, price for chocolate 0 = nums[1], for chocolate 1 = nums[2], for chocolate 2 = nums[0].\n[2,0,1] mean exactly that: values in that array represents types. And for prices -- position of element is matching position in nums: for type 2 it is 0, so the price for type 2 = nums[0];"
                    },
                    {
                        "username": "Wanhao",
                        "content": "[@tungpham](/tungpham) Now I find reason why i cant get the correct answer, this case so confusing on rotation direction "
                    },
                    {
                        "username": "ZQGao",
                        "content": "Same. Failed to understand this question. So *** confusing. And I think the first example is wrong."
                    },
                    {
                        "username": "uuu06222",
                        "content": "I think the [2,0,1] and [1,2,0] part in the description should be swapped"
                    },
                    {
                        "username": "Shkev",
                        "content": "It\\'s just very weirdly explained imo. Basically index `i` of `nums` tells you the price of chocolate `i`. When they call the operation, the index of the chocolates doesn\\'t change, but their types shift.\\nIn the first example they basically shift the type of the chocolates until every type falls on the chocolate that costs 1 and then they buy."
                    },
                    {
                        "username": "tungpham",
                        "content": "Same here. Couldn\\'t make sense of [0,1,2] becomes [2,0,1].It seems i => (i-1) instead of (i+1)"
                    },
                    {
                        "username": "shivamxSK",
                        "content": "description esa likho ki char log bhi na samaj paye\\n"
                    },
                    {
                        "username": "vishal75",
                        "content": "lol"
                    },
                    {
                        "username": "devJuneja",
                        "content": "They could have explained the question with better test cases. : |"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Absolute Garbage Explanation of 1st TC. I wonder why I woke @7:30 just to scream \"Good Morning\"."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I replied Happy Sunday! for the 4th problem 1403/1414"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Namaste sabhi namaste sabhi."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "description aisa do jisko dekhkr chocolate khaane ka mann kare zehar nahi :p"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "I am not able to understand the question waster 25 min.."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "Is the question really confusing or  am I the one who is stupid?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "For those having difficulty in understanding the question , I found one example that might help:\\nThe costs given to us are fixed:[20,1,15]\\nConsider a conveyer belt moving one step ahead each time. The conveyer belt has n types(here 3) of chocolates and price of each chocolate is the lane in front of which it is kept. So, initially, \\nCost:[20,1,15](remains fixed)\\nBelt:[0,1,2]\\nNow belt moves one step ahead(imagine it moving in ur head , it helps!)\\nCost:[20,1,15]                             [20,1,15]                [20,1,15]\\nBelt:[2,0,1]--moves with cost x->[1,2,0]--x cost---->[0,1,2]\\nSo we pick chocolates while conveyer belt is moving each type once and try to minimize cost . Here we pick all chocolates when they reach in front of 1 cost.\\nHope it helps!"
                    },
                    {
                        "username": "rnishant29",
                        "content": "nums: [15,150,56,69,214,203]\\nx: 42\\nhow answer 298 is possible?Please guide...\\nThanks.\\n"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@seafmch](/seafmch) That\\'s because after 1 operation you can get type 4 chocolate for min(nums[4], nums[5]) = min(214, 203) = 203. Same idea goes for type 5: min(nums[5], nums[0]) = min(203, 15) = 15.\\n\\nThough that idea is based on examples before they were updated (the description and examples were not clear enough, so I assumed that after performing operation, price for type i chocolate will be nums[(i+1)%n], where n = nums.length.\\n\\nAfter examples were clarified it\\'s clear that after 1 operation price for type i will be nums[i-1] (i>0).\\nSo after 1 operation you should calculate min possible price for type i as min(nums[i], nums[i-1]) (i>0).\\nBut it looks like they way you shift prices doesn\\'t effect the result since my initial approach passed all tests."
                    },
                    {
                        "username": "rnishant29",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot for great explanation!!!"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@VektorMD](/VektorMD) What? From 0 to 1, both 150 and 214 disappear. Why?"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@rnishant29](/rnishant29) me too"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@suniiiiidhi](/suniiiiidhi) My understanding to the problem was partially based on examples provided. Before they were updated, is seems like the logic was following: after one operation you can calculate a price for type i as min(nums[i], nums[(i+1)%n]) where n = nums.length.\n\nIf you perform k operations then you can calculate price as min(nums[i], .., nums[(i+k)%n]).\nSo lets take a look on all possible outcomes:\n0: [15,150,56,69,214,203] -- original\n1: [15,56,56,69,203,15]\n2: [15,56,56,69,15,15]\n3: [15,56,56,15,15,15]\n4: [15,56,15,15,15,15]\n5: [15,15,15,15,15,15]\n(number on the left  is amount of operations performed)\nConsidering the price of operation x = 42, minimum can be achieved after 3 operations (=298).\n\nBut examples for this problem now are updated. And you have to use reversed logic: after 1 operation for price for type i is min(nums[i], nums[(i-1)]) (for i > 0).\nI'm not sure if this change will affect testcases, maybe some of them will need an update"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) please elaborate"
                    },
                    {
                        "username": "VektorMD",
                        "content": "In 3 operations you can get type 0,3,4,5 for 15, type 1,2 for 56 = 4 * 15 + 56 * 2+42 * 3 = 298"
                    },
                    {
                        "username": "rnishant29",
                        "content": "I am getting 300 as minimum\\n"
                    }
                ]
            },
            {
                "id": 1928079,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "Problem creator was high on weeds."
                    },
                    {
                        "username": "15o1",
                        "content": "Is the explanation of first test case incorrect or am I just dumb??!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "Changing the type of chocolate from i to i+1 means that the price of chocolate i will become the price of chocolate i+1.\nSo lets take the original array for prices [20,1,15].\nAfter first operation we will get: [1, 15, 20]\nAfter second operation: [15, 20, 1]\nBut you don't have to shift values in array. You just need to calculate the index of value in original array that will represent current price after k operatioins.\nprice for element i after k operations = nums[(i+k)%n], where n = nums.length.\nSo after 1 operation, price for chocolate 0 = nums[1], for chocolate 1 = nums[2], for chocolate 2 = nums[0].\n[2,0,1] mean exactly that: values in that array represents types. And for prices -- position of element is matching position in nums: for type 2 it is 0, so the price for type 2 = nums[0];"
                    },
                    {
                        "username": "Wanhao",
                        "content": "[@tungpham](/tungpham) Now I find reason why i cant get the correct answer, this case so confusing on rotation direction "
                    },
                    {
                        "username": "ZQGao",
                        "content": "Same. Failed to understand this question. So *** confusing. And I think the first example is wrong."
                    },
                    {
                        "username": "uuu06222",
                        "content": "I think the [2,0,1] and [1,2,0] part in the description should be swapped"
                    },
                    {
                        "username": "Shkev",
                        "content": "It\\'s just very weirdly explained imo. Basically index `i` of `nums` tells you the price of chocolate `i`. When they call the operation, the index of the chocolates doesn\\'t change, but their types shift.\\nIn the first example they basically shift the type of the chocolates until every type falls on the chocolate that costs 1 and then they buy."
                    },
                    {
                        "username": "tungpham",
                        "content": "Same here. Couldn\\'t make sense of [0,1,2] becomes [2,0,1].It seems i => (i-1) instead of (i+1)"
                    },
                    {
                        "username": "shivamxSK",
                        "content": "description esa likho ki char log bhi na samaj paye\\n"
                    },
                    {
                        "username": "vishal75",
                        "content": "lol"
                    },
                    {
                        "username": "devJuneja",
                        "content": "They could have explained the question with better test cases. : |"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Absolute Garbage Explanation of 1st TC. I wonder why I woke @7:30 just to scream \"Good Morning\"."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I replied Happy Sunday! for the 4th problem 1403/1414"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Namaste sabhi namaste sabhi."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "description aisa do jisko dekhkr chocolate khaane ka mann kare zehar nahi :p"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "I am not able to understand the question waster 25 min.."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "Is the question really confusing or  am I the one who is stupid?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "For those having difficulty in understanding the question , I found one example that might help:\\nThe costs given to us are fixed:[20,1,15]\\nConsider a conveyer belt moving one step ahead each time. The conveyer belt has n types(here 3) of chocolates and price of each chocolate is the lane in front of which it is kept. So, initially, \\nCost:[20,1,15](remains fixed)\\nBelt:[0,1,2]\\nNow belt moves one step ahead(imagine it moving in ur head , it helps!)\\nCost:[20,1,15]                             [20,1,15]                [20,1,15]\\nBelt:[2,0,1]--moves with cost x->[1,2,0]--x cost---->[0,1,2]\\nSo we pick chocolates while conveyer belt is moving each type once and try to minimize cost . Here we pick all chocolates when they reach in front of 1 cost.\\nHope it helps!"
                    },
                    {
                        "username": "rnishant29",
                        "content": "nums: [15,150,56,69,214,203]\\nx: 42\\nhow answer 298 is possible?Please guide...\\nThanks.\\n"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@seafmch](/seafmch) That\\'s because after 1 operation you can get type 4 chocolate for min(nums[4], nums[5]) = min(214, 203) = 203. Same idea goes for type 5: min(nums[5], nums[0]) = min(203, 15) = 15.\\n\\nThough that idea is based on examples before they were updated (the description and examples were not clear enough, so I assumed that after performing operation, price for type i chocolate will be nums[(i+1)%n], where n = nums.length.\\n\\nAfter examples were clarified it\\'s clear that after 1 operation price for type i will be nums[i-1] (i>0).\\nSo after 1 operation you should calculate min possible price for type i as min(nums[i], nums[i-1]) (i>0).\\nBut it looks like they way you shift prices doesn\\'t effect the result since my initial approach passed all tests."
                    },
                    {
                        "username": "rnishant29",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot for great explanation!!!"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@VektorMD](/VektorMD) What? From 0 to 1, both 150 and 214 disappear. Why?"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@rnishant29](/rnishant29) me too"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@suniiiiidhi](/suniiiiidhi) My understanding to the problem was partially based on examples provided. Before they were updated, is seems like the logic was following: after one operation you can calculate a price for type i as min(nums[i], nums[(i+1)%n]) where n = nums.length.\n\nIf you perform k operations then you can calculate price as min(nums[i], .., nums[(i+k)%n]).\nSo lets take a look on all possible outcomes:\n0: [15,150,56,69,214,203] -- original\n1: [15,56,56,69,203,15]\n2: [15,56,56,69,15,15]\n3: [15,56,56,15,15,15]\n4: [15,56,15,15,15,15]\n5: [15,15,15,15,15,15]\n(number on the left  is amount of operations performed)\nConsidering the price of operation x = 42, minimum can be achieved after 3 operations (=298).\n\nBut examples for this problem now are updated. And you have to use reversed logic: after 1 operation for price for type i is min(nums[i], nums[(i-1)]) (for i > 0).\nI'm not sure if this change will affect testcases, maybe some of them will need an update"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) please elaborate"
                    },
                    {
                        "username": "VektorMD",
                        "content": "In 3 operations you can get type 0,3,4,5 for 15, type 1,2 for 56 = 4 * 15 + 56 * 2+42 * 3 = 298"
                    },
                    {
                        "username": "rnishant29",
                        "content": "I am getting 300 as minimum\\n"
                    }
                ]
            },
            {
                "id": 1924544,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "Problem creator was high on weeds."
                    },
                    {
                        "username": "15o1",
                        "content": "Is the explanation of first test case incorrect or am I just dumb??!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "Changing the type of chocolate from i to i+1 means that the price of chocolate i will become the price of chocolate i+1.\nSo lets take the original array for prices [20,1,15].\nAfter first operation we will get: [1, 15, 20]\nAfter second operation: [15, 20, 1]\nBut you don't have to shift values in array. You just need to calculate the index of value in original array that will represent current price after k operatioins.\nprice for element i after k operations = nums[(i+k)%n], where n = nums.length.\nSo after 1 operation, price for chocolate 0 = nums[1], for chocolate 1 = nums[2], for chocolate 2 = nums[0].\n[2,0,1] mean exactly that: values in that array represents types. And for prices -- position of element is matching position in nums: for type 2 it is 0, so the price for type 2 = nums[0];"
                    },
                    {
                        "username": "Wanhao",
                        "content": "[@tungpham](/tungpham) Now I find reason why i cant get the correct answer, this case so confusing on rotation direction "
                    },
                    {
                        "username": "ZQGao",
                        "content": "Same. Failed to understand this question. So *** confusing. And I think the first example is wrong."
                    },
                    {
                        "username": "uuu06222",
                        "content": "I think the [2,0,1] and [1,2,0] part in the description should be swapped"
                    },
                    {
                        "username": "Shkev",
                        "content": "It\\'s just very weirdly explained imo. Basically index `i` of `nums` tells you the price of chocolate `i`. When they call the operation, the index of the chocolates doesn\\'t change, but their types shift.\\nIn the first example they basically shift the type of the chocolates until every type falls on the chocolate that costs 1 and then they buy."
                    },
                    {
                        "username": "tungpham",
                        "content": "Same here. Couldn\\'t make sense of [0,1,2] becomes [2,0,1].It seems i => (i-1) instead of (i+1)"
                    },
                    {
                        "username": "shivamxSK",
                        "content": "description esa likho ki char log bhi na samaj paye\\n"
                    },
                    {
                        "username": "vishal75",
                        "content": "lol"
                    },
                    {
                        "username": "devJuneja",
                        "content": "They could have explained the question with better test cases. : |"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Absolute Garbage Explanation of 1st TC. I wonder why I woke @7:30 just to scream \"Good Morning\"."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I replied Happy Sunday! for the 4th problem 1403/1414"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Namaste sabhi namaste sabhi."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "description aisa do jisko dekhkr chocolate khaane ka mann kare zehar nahi :p"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "I am not able to understand the question waster 25 min.."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "Is the question really confusing or  am I the one who is stupid?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "For those having difficulty in understanding the question , I found one example that might help:\\nThe costs given to us are fixed:[20,1,15]\\nConsider a conveyer belt moving one step ahead each time. The conveyer belt has n types(here 3) of chocolates and price of each chocolate is the lane in front of which it is kept. So, initially, \\nCost:[20,1,15](remains fixed)\\nBelt:[0,1,2]\\nNow belt moves one step ahead(imagine it moving in ur head , it helps!)\\nCost:[20,1,15]                             [20,1,15]                [20,1,15]\\nBelt:[2,0,1]--moves with cost x->[1,2,0]--x cost---->[0,1,2]\\nSo we pick chocolates while conveyer belt is moving each type once and try to minimize cost . Here we pick all chocolates when they reach in front of 1 cost.\\nHope it helps!"
                    },
                    {
                        "username": "rnishant29",
                        "content": "nums: [15,150,56,69,214,203]\\nx: 42\\nhow answer 298 is possible?Please guide...\\nThanks.\\n"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@seafmch](/seafmch) That\\'s because after 1 operation you can get type 4 chocolate for min(nums[4], nums[5]) = min(214, 203) = 203. Same idea goes for type 5: min(nums[5], nums[0]) = min(203, 15) = 15.\\n\\nThough that idea is based on examples before they were updated (the description and examples were not clear enough, so I assumed that after performing operation, price for type i chocolate will be nums[(i+1)%n], where n = nums.length.\\n\\nAfter examples were clarified it\\'s clear that after 1 operation price for type i will be nums[i-1] (i>0).\\nSo after 1 operation you should calculate min possible price for type i as min(nums[i], nums[i-1]) (i>0).\\nBut it looks like they way you shift prices doesn\\'t effect the result since my initial approach passed all tests."
                    },
                    {
                        "username": "rnishant29",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot for great explanation!!!"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@VektorMD](/VektorMD) What? From 0 to 1, both 150 and 214 disappear. Why?"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@rnishant29](/rnishant29) me too"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@suniiiiidhi](/suniiiiidhi) My understanding to the problem was partially based on examples provided. Before they were updated, is seems like the logic was following: after one operation you can calculate a price for type i as min(nums[i], nums[(i+1)%n]) where n = nums.length.\n\nIf you perform k operations then you can calculate price as min(nums[i], .., nums[(i+k)%n]).\nSo lets take a look on all possible outcomes:\n0: [15,150,56,69,214,203] -- original\n1: [15,56,56,69,203,15]\n2: [15,56,56,69,15,15]\n3: [15,56,56,15,15,15]\n4: [15,56,15,15,15,15]\n5: [15,15,15,15,15,15]\n(number on the left  is amount of operations performed)\nConsidering the price of operation x = 42, minimum can be achieved after 3 operations (=298).\n\nBut examples for this problem now are updated. And you have to use reversed logic: after 1 operation for price for type i is min(nums[i], nums[(i-1)]) (for i > 0).\nI'm not sure if this change will affect testcases, maybe some of them will need an update"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) please elaborate"
                    },
                    {
                        "username": "VektorMD",
                        "content": "In 3 operations you can get type 0,3,4,5 for 15, type 1,2 for 56 = 4 * 15 + 56 * 2+42 * 3 = 298"
                    },
                    {
                        "username": "rnishant29",
                        "content": "I am getting 300 as minimum\\n"
                    }
                ]
            },
            {
                "id": 1924921,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "Problem creator was high on weeds."
                    },
                    {
                        "username": "15o1",
                        "content": "Is the explanation of first test case incorrect or am I just dumb??!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "Changing the type of chocolate from i to i+1 means that the price of chocolate i will become the price of chocolate i+1.\nSo lets take the original array for prices [20,1,15].\nAfter first operation we will get: [1, 15, 20]\nAfter second operation: [15, 20, 1]\nBut you don't have to shift values in array. You just need to calculate the index of value in original array that will represent current price after k operatioins.\nprice for element i after k operations = nums[(i+k)%n], where n = nums.length.\nSo after 1 operation, price for chocolate 0 = nums[1], for chocolate 1 = nums[2], for chocolate 2 = nums[0].\n[2,0,1] mean exactly that: values in that array represents types. And for prices -- position of element is matching position in nums: for type 2 it is 0, so the price for type 2 = nums[0];"
                    },
                    {
                        "username": "Wanhao",
                        "content": "[@tungpham](/tungpham) Now I find reason why i cant get the correct answer, this case so confusing on rotation direction "
                    },
                    {
                        "username": "ZQGao",
                        "content": "Same. Failed to understand this question. So *** confusing. And I think the first example is wrong."
                    },
                    {
                        "username": "uuu06222",
                        "content": "I think the [2,0,1] and [1,2,0] part in the description should be swapped"
                    },
                    {
                        "username": "Shkev",
                        "content": "It\\'s just very weirdly explained imo. Basically index `i` of `nums` tells you the price of chocolate `i`. When they call the operation, the index of the chocolates doesn\\'t change, but their types shift.\\nIn the first example they basically shift the type of the chocolates until every type falls on the chocolate that costs 1 and then they buy."
                    },
                    {
                        "username": "tungpham",
                        "content": "Same here. Couldn\\'t make sense of [0,1,2] becomes [2,0,1].It seems i => (i-1) instead of (i+1)"
                    },
                    {
                        "username": "shivamxSK",
                        "content": "description esa likho ki char log bhi na samaj paye\\n"
                    },
                    {
                        "username": "vishal75",
                        "content": "lol"
                    },
                    {
                        "username": "devJuneja",
                        "content": "They could have explained the question with better test cases. : |"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Absolute Garbage Explanation of 1st TC. I wonder why I woke @7:30 just to scream \"Good Morning\"."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I replied Happy Sunday! for the 4th problem 1403/1414"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Namaste sabhi namaste sabhi."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "description aisa do jisko dekhkr chocolate khaane ka mann kare zehar nahi :p"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "I am not able to understand the question waster 25 min.."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "Is the question really confusing or  am I the one who is stupid?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "For those having difficulty in understanding the question , I found one example that might help:\\nThe costs given to us are fixed:[20,1,15]\\nConsider a conveyer belt moving one step ahead each time. The conveyer belt has n types(here 3) of chocolates and price of each chocolate is the lane in front of which it is kept. So, initially, \\nCost:[20,1,15](remains fixed)\\nBelt:[0,1,2]\\nNow belt moves one step ahead(imagine it moving in ur head , it helps!)\\nCost:[20,1,15]                             [20,1,15]                [20,1,15]\\nBelt:[2,0,1]--moves with cost x->[1,2,0]--x cost---->[0,1,2]\\nSo we pick chocolates while conveyer belt is moving each type once and try to minimize cost . Here we pick all chocolates when they reach in front of 1 cost.\\nHope it helps!"
                    },
                    {
                        "username": "rnishant29",
                        "content": "nums: [15,150,56,69,214,203]\\nx: 42\\nhow answer 298 is possible?Please guide...\\nThanks.\\n"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@seafmch](/seafmch) That\\'s because after 1 operation you can get type 4 chocolate for min(nums[4], nums[5]) = min(214, 203) = 203. Same idea goes for type 5: min(nums[5], nums[0]) = min(203, 15) = 15.\\n\\nThough that idea is based on examples before they were updated (the description and examples were not clear enough, so I assumed that after performing operation, price for type i chocolate will be nums[(i+1)%n], where n = nums.length.\\n\\nAfter examples were clarified it\\'s clear that after 1 operation price for type i will be nums[i-1] (i>0).\\nSo after 1 operation you should calculate min possible price for type i as min(nums[i], nums[i-1]) (i>0).\\nBut it looks like they way you shift prices doesn\\'t effect the result since my initial approach passed all tests."
                    },
                    {
                        "username": "rnishant29",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot for great explanation!!!"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@VektorMD](/VektorMD) What? From 0 to 1, both 150 and 214 disappear. Why?"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@rnishant29](/rnishant29) me too"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@suniiiiidhi](/suniiiiidhi) My understanding to the problem was partially based on examples provided. Before they were updated, is seems like the logic was following: after one operation you can calculate a price for type i as min(nums[i], nums[(i+1)%n]) where n = nums.length.\n\nIf you perform k operations then you can calculate price as min(nums[i], .., nums[(i+k)%n]).\nSo lets take a look on all possible outcomes:\n0: [15,150,56,69,214,203] -- original\n1: [15,56,56,69,203,15]\n2: [15,56,56,69,15,15]\n3: [15,56,56,15,15,15]\n4: [15,56,15,15,15,15]\n5: [15,15,15,15,15,15]\n(number on the left  is amount of operations performed)\nConsidering the price of operation x = 42, minimum can be achieved after 3 operations (=298).\n\nBut examples for this problem now are updated. And you have to use reversed logic: after 1 operation for price for type i is min(nums[i], nums[(i-1)]) (for i > 0).\nI'm not sure if this change will affect testcases, maybe some of them will need an update"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) please elaborate"
                    },
                    {
                        "username": "VektorMD",
                        "content": "In 3 operations you can get type 0,3,4,5 for 15, type 1,2 for 56 = 4 * 15 + 56 * 2+42 * 3 = 298"
                    },
                    {
                        "username": "rnishant29",
                        "content": "I am getting 300 as minimum\\n"
                    }
                ]
            },
            {
                "id": 1926785,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "Problem creator was high on weeds."
                    },
                    {
                        "username": "15o1",
                        "content": "Is the explanation of first test case incorrect or am I just dumb??!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "Changing the type of chocolate from i to i+1 means that the price of chocolate i will become the price of chocolate i+1.\nSo lets take the original array for prices [20,1,15].\nAfter first operation we will get: [1, 15, 20]\nAfter second operation: [15, 20, 1]\nBut you don't have to shift values in array. You just need to calculate the index of value in original array that will represent current price after k operatioins.\nprice for element i after k operations = nums[(i+k)%n], where n = nums.length.\nSo after 1 operation, price for chocolate 0 = nums[1], for chocolate 1 = nums[2], for chocolate 2 = nums[0].\n[2,0,1] mean exactly that: values in that array represents types. And for prices -- position of element is matching position in nums: for type 2 it is 0, so the price for type 2 = nums[0];"
                    },
                    {
                        "username": "Wanhao",
                        "content": "[@tungpham](/tungpham) Now I find reason why i cant get the correct answer, this case so confusing on rotation direction "
                    },
                    {
                        "username": "ZQGao",
                        "content": "Same. Failed to understand this question. So *** confusing. And I think the first example is wrong."
                    },
                    {
                        "username": "uuu06222",
                        "content": "I think the [2,0,1] and [1,2,0] part in the description should be swapped"
                    },
                    {
                        "username": "Shkev",
                        "content": "It\\'s just very weirdly explained imo. Basically index `i` of `nums` tells you the price of chocolate `i`. When they call the operation, the index of the chocolates doesn\\'t change, but their types shift.\\nIn the first example they basically shift the type of the chocolates until every type falls on the chocolate that costs 1 and then they buy."
                    },
                    {
                        "username": "tungpham",
                        "content": "Same here. Couldn\\'t make sense of [0,1,2] becomes [2,0,1].It seems i => (i-1) instead of (i+1)"
                    },
                    {
                        "username": "shivamxSK",
                        "content": "description esa likho ki char log bhi na samaj paye\\n"
                    },
                    {
                        "username": "vishal75",
                        "content": "lol"
                    },
                    {
                        "username": "devJuneja",
                        "content": "They could have explained the question with better test cases. : |"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Absolute Garbage Explanation of 1st TC. I wonder why I woke @7:30 just to scream \"Good Morning\"."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I replied Happy Sunday! for the 4th problem 1403/1414"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Namaste sabhi namaste sabhi."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "description aisa do jisko dekhkr chocolate khaane ka mann kare zehar nahi :p"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "I am not able to understand the question waster 25 min.."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "Is the question really confusing or  am I the one who is stupid?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "For those having difficulty in understanding the question , I found one example that might help:\\nThe costs given to us are fixed:[20,1,15]\\nConsider a conveyer belt moving one step ahead each time. The conveyer belt has n types(here 3) of chocolates and price of each chocolate is the lane in front of which it is kept. So, initially, \\nCost:[20,1,15](remains fixed)\\nBelt:[0,1,2]\\nNow belt moves one step ahead(imagine it moving in ur head , it helps!)\\nCost:[20,1,15]                             [20,1,15]                [20,1,15]\\nBelt:[2,0,1]--moves with cost x->[1,2,0]--x cost---->[0,1,2]\\nSo we pick chocolates while conveyer belt is moving each type once and try to minimize cost . Here we pick all chocolates when they reach in front of 1 cost.\\nHope it helps!"
                    },
                    {
                        "username": "rnishant29",
                        "content": "nums: [15,150,56,69,214,203]\\nx: 42\\nhow answer 298 is possible?Please guide...\\nThanks.\\n"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@seafmch](/seafmch) That\\'s because after 1 operation you can get type 4 chocolate for min(nums[4], nums[5]) = min(214, 203) = 203. Same idea goes for type 5: min(nums[5], nums[0]) = min(203, 15) = 15.\\n\\nThough that idea is based on examples before they were updated (the description and examples were not clear enough, so I assumed that after performing operation, price for type i chocolate will be nums[(i+1)%n], where n = nums.length.\\n\\nAfter examples were clarified it\\'s clear that after 1 operation price for type i will be nums[i-1] (i>0).\\nSo after 1 operation you should calculate min possible price for type i as min(nums[i], nums[i-1]) (i>0).\\nBut it looks like they way you shift prices doesn\\'t effect the result since my initial approach passed all tests."
                    },
                    {
                        "username": "rnishant29",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot for great explanation!!!"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@VektorMD](/VektorMD) What? From 0 to 1, both 150 and 214 disappear. Why?"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@rnishant29](/rnishant29) me too"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@suniiiiidhi](/suniiiiidhi) My understanding to the problem was partially based on examples provided. Before they were updated, is seems like the logic was following: after one operation you can calculate a price for type i as min(nums[i], nums[(i+1)%n]) where n = nums.length.\n\nIf you perform k operations then you can calculate price as min(nums[i], .., nums[(i+k)%n]).\nSo lets take a look on all possible outcomes:\n0: [15,150,56,69,214,203] -- original\n1: [15,56,56,69,203,15]\n2: [15,56,56,69,15,15]\n3: [15,56,56,15,15,15]\n4: [15,56,15,15,15,15]\n5: [15,15,15,15,15,15]\n(number on the left  is amount of operations performed)\nConsidering the price of operation x = 42, minimum can be achieved after 3 operations (=298).\n\nBut examples for this problem now are updated. And you have to use reversed logic: after 1 operation for price for type i is min(nums[i], nums[(i-1)]) (for i > 0).\nI'm not sure if this change will affect testcases, maybe some of them will need an update"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) please elaborate"
                    },
                    {
                        "username": "VektorMD",
                        "content": "In 3 operations you can get type 0,3,4,5 for 15, type 1,2 for 56 = 4 * 15 + 56 * 2+42 * 3 = 298"
                    },
                    {
                        "username": "rnishant29",
                        "content": "I am getting 300 as minimum\\n"
                    }
                ]
            },
            {
                "id": 1925197,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "Problem creator was high on weeds."
                    },
                    {
                        "username": "15o1",
                        "content": "Is the explanation of first test case incorrect or am I just dumb??!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "Changing the type of chocolate from i to i+1 means that the price of chocolate i will become the price of chocolate i+1.\nSo lets take the original array for prices [20,1,15].\nAfter first operation we will get: [1, 15, 20]\nAfter second operation: [15, 20, 1]\nBut you don't have to shift values in array. You just need to calculate the index of value in original array that will represent current price after k operatioins.\nprice for element i after k operations = nums[(i+k)%n], where n = nums.length.\nSo after 1 operation, price for chocolate 0 = nums[1], for chocolate 1 = nums[2], for chocolate 2 = nums[0].\n[2,0,1] mean exactly that: values in that array represents types. And for prices -- position of element is matching position in nums: for type 2 it is 0, so the price for type 2 = nums[0];"
                    },
                    {
                        "username": "Wanhao",
                        "content": "[@tungpham](/tungpham) Now I find reason why i cant get the correct answer, this case so confusing on rotation direction "
                    },
                    {
                        "username": "ZQGao",
                        "content": "Same. Failed to understand this question. So *** confusing. And I think the first example is wrong."
                    },
                    {
                        "username": "uuu06222",
                        "content": "I think the [2,0,1] and [1,2,0] part in the description should be swapped"
                    },
                    {
                        "username": "Shkev",
                        "content": "It\\'s just very weirdly explained imo. Basically index `i` of `nums` tells you the price of chocolate `i`. When they call the operation, the index of the chocolates doesn\\'t change, but their types shift.\\nIn the first example they basically shift the type of the chocolates until every type falls on the chocolate that costs 1 and then they buy."
                    },
                    {
                        "username": "tungpham",
                        "content": "Same here. Couldn\\'t make sense of [0,1,2] becomes [2,0,1].It seems i => (i-1) instead of (i+1)"
                    },
                    {
                        "username": "shivamxSK",
                        "content": "description esa likho ki char log bhi na samaj paye\\n"
                    },
                    {
                        "username": "vishal75",
                        "content": "lol"
                    },
                    {
                        "username": "devJuneja",
                        "content": "They could have explained the question with better test cases. : |"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Absolute Garbage Explanation of 1st TC. I wonder why I woke @7:30 just to scream \"Good Morning\"."
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I replied Happy Sunday! for the 4th problem 1403/1414"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Namaste sabhi namaste sabhi."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "++\\n"
                    },
                    {
                        "username": "Vedantuu",
                        "content": "description aisa do jisko dekhkr chocolate khaane ka mann kare zehar nahi :p"
                    },
                    {
                        "username": "deepsaxena00",
                        "content": "I am not able to understand the question waster 25 min.."
                    },
                    {
                        "username": "tripathiharish2001",
                        "content": "Is the question really confusing or  am I the one who is stupid?"
                    },
                    {
                        "username": "palak-agg",
                        "content": "For those having difficulty in understanding the question , I found one example that might help:\\nThe costs given to us are fixed:[20,1,15]\\nConsider a conveyer belt moving one step ahead each time. The conveyer belt has n types(here 3) of chocolates and price of each chocolate is the lane in front of which it is kept. So, initially, \\nCost:[20,1,15](remains fixed)\\nBelt:[0,1,2]\\nNow belt moves one step ahead(imagine it moving in ur head , it helps!)\\nCost:[20,1,15]                             [20,1,15]                [20,1,15]\\nBelt:[2,0,1]--moves with cost x->[1,2,0]--x cost---->[0,1,2]\\nSo we pick chocolates while conveyer belt is moving each type once and try to minimize cost . Here we pick all chocolates when they reach in front of 1 cost.\\nHope it helps!"
                    },
                    {
                        "username": "rnishant29",
                        "content": "nums: [15,150,56,69,214,203]\\nx: 42\\nhow answer 298 is possible?Please guide...\\nThanks.\\n"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@seafmch](/seafmch) That\\'s because after 1 operation you can get type 4 chocolate for min(nums[4], nums[5]) = min(214, 203) = 203. Same idea goes for type 5: min(nums[5], nums[0]) = min(203, 15) = 15.\\n\\nThough that idea is based on examples before they were updated (the description and examples were not clear enough, so I assumed that after performing operation, price for type i chocolate will be nums[(i+1)%n], where n = nums.length.\\n\\nAfter examples were clarified it\\'s clear that after 1 operation price for type i will be nums[i-1] (i>0).\\nSo after 1 operation you should calculate min possible price for type i as min(nums[i], nums[i-1]) (i>0).\\nBut it looks like they way you shift prices doesn\\'t effect the result since my initial approach passed all tests."
                    },
                    {
                        "username": "rnishant29",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot for great explanation!!!"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@VektorMD](/VektorMD) What? From 0 to 1, both 150 and 214 disappear. Why?"
                    },
                    {
                        "username": "seafmch",
                        "content": "[@rnishant29](/rnishant29) me too"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) Thanks a lot!"
                    },
                    {
                        "username": "VektorMD",
                        "content": "[@suniiiiidhi](/suniiiiidhi) My understanding to the problem was partially based on examples provided. Before they were updated, is seems like the logic was following: after one operation you can calculate a price for type i as min(nums[i], nums[(i+1)%n]) where n = nums.length.\n\nIf you perform k operations then you can calculate price as min(nums[i], .., nums[(i+k)%n]).\nSo lets take a look on all possible outcomes:\n0: [15,150,56,69,214,203] -- original\n1: [15,56,56,69,203,15]\n2: [15,56,56,69,15,15]\n3: [15,56,56,15,15,15]\n4: [15,56,15,15,15,15]\n5: [15,15,15,15,15,15]\n(number on the left  is amount of operations performed)\nConsidering the price of operation x = 42, minimum can be achieved after 3 operations (=298).\n\nBut examples for this problem now are updated. And you have to use reversed logic: after 1 operation for price for type i is min(nums[i], nums[(i-1)]) (for i > 0).\nI'm not sure if this change will affect testcases, maybe some of them will need an update"
                    },
                    {
                        "username": "itsmesuni19",
                        "content": "[@VektorMD](/VektorMD) please elaborate"
                    },
                    {
                        "username": "VektorMD",
                        "content": "In 3 operations you can get type 0,3,4,5 for 15, type 1,2 for 56 = 4 * 15 + 56 * 2+42 * 3 = 298"
                    },
                    {
                        "username": "rnishant29",
                        "content": "I am getting 300 as minimum\\n"
                    }
                ]
            },
            {
                "id": 1925479,
                "content": [
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Dekha ye leetcode hai aisa ghume ke question ata hai ki 4 log discussion me ake gali dete hai."
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "it should be hard category problem."
                    },
                    {
                        "username": "chandhugyana",
                        "content": "the explanation of the question was good.But the first test case is not the correct example for this question.(the values mentioned in the test case are wrong)"
                    },
                    {
                        "username": "entitled_american",
                        "content": "Actually a good question if the example and description matched up. I would probably put this as a hard. Also, I do hate when I waste so much time trying to imagine a linear time solution when a N^2 would have passed. "
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Anybody else solved this question using 2D prefix sum?"
                    },
                    {
                        "username": "adis176",
                        "content": "Can anyone tell me what category/topic this type of problem would come under?"
                    },
                    {
                        "username": "user5258V",
                        "content": "Dynamic programming"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can someone follow up a recursive solution for this?"
                    },
                    {
                        "username": "leet_alok",
                        "content": "Can someone explain why this 10^9 nums is running perfectly in O(n^2) code? I am never able to figure out this."
                    },
                    {
                        "username": "leet_alok",
                        "content": "[@Saza-e-TLE](/Saza-e-TLE) yes I didn\\'t see properly. Thank you."
                    },
                    {
                        "username": "DR4G0N_EMPER0R",
                        "content": "TC depends on length of nums not the value of individual element in an array..\\nnums.length = 1e3 and n^2 = 1e6 <1e8 so n2 will work.\\nHope u understand \\uD83D\\uDE09 "
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can anyone explain 1st testcase, how it take cost 6 for 0th chocolate? Should it not be 11, becoz array is already rotated 2 times , 2*5 + 1 = 11"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "cost of shifting = 1*5 (you will pick and remove that just chocolate after 1 rotation) + 1(cost at that position)\\n\\nYou are rotating chocolates and the price is position dependent."
                    },
                    {
                        "username": "azad_6021",
                        "content": "Would have been a hard question if array size would be 1e5. Will require nlogn solution which can be done with Binary Search."
                    }
                ]
            },
            {
                "id": 1925040,
                "content": [
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Dekha ye leetcode hai aisa ghume ke question ata hai ki 4 log discussion me ake gali dete hai."
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "it should be hard category problem."
                    },
                    {
                        "username": "chandhugyana",
                        "content": "the explanation of the question was good.But the first test case is not the correct example for this question.(the values mentioned in the test case are wrong)"
                    },
                    {
                        "username": "entitled_american",
                        "content": "Actually a good question if the example and description matched up. I would probably put this as a hard. Also, I do hate when I waste so much time trying to imagine a linear time solution when a N^2 would have passed. "
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Anybody else solved this question using 2D prefix sum?"
                    },
                    {
                        "username": "adis176",
                        "content": "Can anyone tell me what category/topic this type of problem would come under?"
                    },
                    {
                        "username": "user5258V",
                        "content": "Dynamic programming"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can someone follow up a recursive solution for this?"
                    },
                    {
                        "username": "leet_alok",
                        "content": "Can someone explain why this 10^9 nums is running perfectly in O(n^2) code? I am never able to figure out this."
                    },
                    {
                        "username": "leet_alok",
                        "content": "[@Saza-e-TLE](/Saza-e-TLE) yes I didn\\'t see properly. Thank you."
                    },
                    {
                        "username": "DR4G0N_EMPER0R",
                        "content": "TC depends on length of nums not the value of individual element in an array..\\nnums.length = 1e3 and n^2 = 1e6 <1e8 so n2 will work.\\nHope u understand \\uD83D\\uDE09 "
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can anyone explain 1st testcase, how it take cost 6 for 0th chocolate? Should it not be 11, becoz array is already rotated 2 times , 2*5 + 1 = 11"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "cost of shifting = 1*5 (you will pick and remove that just chocolate after 1 rotation) + 1(cost at that position)\\n\\nYou are rotating chocolates and the price is position dependent."
                    },
                    {
                        "username": "azad_6021",
                        "content": "Would have been a hard question if array size would be 1e5. Will require nlogn solution which can be done with Binary Search."
                    }
                ]
            },
            {
                "id": 1924807,
                "content": [
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Dekha ye leetcode hai aisa ghume ke question ata hai ki 4 log discussion me ake gali dete hai."
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "it should be hard category problem."
                    },
                    {
                        "username": "chandhugyana",
                        "content": "the explanation of the question was good.But the first test case is not the correct example for this question.(the values mentioned in the test case are wrong)"
                    },
                    {
                        "username": "entitled_american",
                        "content": "Actually a good question if the example and description matched up. I would probably put this as a hard. Also, I do hate when I waste so much time trying to imagine a linear time solution when a N^2 would have passed. "
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Anybody else solved this question using 2D prefix sum?"
                    },
                    {
                        "username": "adis176",
                        "content": "Can anyone tell me what category/topic this type of problem would come under?"
                    },
                    {
                        "username": "user5258V",
                        "content": "Dynamic programming"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can someone follow up a recursive solution for this?"
                    },
                    {
                        "username": "leet_alok",
                        "content": "Can someone explain why this 10^9 nums is running perfectly in O(n^2) code? I am never able to figure out this."
                    },
                    {
                        "username": "leet_alok",
                        "content": "[@Saza-e-TLE](/Saza-e-TLE) yes I didn\\'t see properly. Thank you."
                    },
                    {
                        "username": "DR4G0N_EMPER0R",
                        "content": "TC depends on length of nums not the value of individual element in an array..\\nnums.length = 1e3 and n^2 = 1e6 <1e8 so n2 will work.\\nHope u understand \\uD83D\\uDE09 "
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can anyone explain 1st testcase, how it take cost 6 for 0th chocolate? Should it not be 11, becoz array is already rotated 2 times , 2*5 + 1 = 11"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "cost of shifting = 1*5 (you will pick and remove that just chocolate after 1 rotation) + 1(cost at that position)\\n\\nYou are rotating chocolates and the price is position dependent."
                    },
                    {
                        "username": "azad_6021",
                        "content": "Would have been a hard question if array size would be 1e5. Will require nlogn solution which can be done with Binary Search."
                    }
                ]
            },
            {
                "id": 2068779,
                "content": [
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Dekha ye leetcode hai aisa ghume ke question ata hai ki 4 log discussion me ake gali dete hai."
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "it should be hard category problem."
                    },
                    {
                        "username": "chandhugyana",
                        "content": "the explanation of the question was good.But the first test case is not the correct example for this question.(the values mentioned in the test case are wrong)"
                    },
                    {
                        "username": "entitled_american",
                        "content": "Actually a good question if the example and description matched up. I would probably put this as a hard. Also, I do hate when I waste so much time trying to imagine a linear time solution when a N^2 would have passed. "
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Anybody else solved this question using 2D prefix sum?"
                    },
                    {
                        "username": "adis176",
                        "content": "Can anyone tell me what category/topic this type of problem would come under?"
                    },
                    {
                        "username": "user5258V",
                        "content": "Dynamic programming"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can someone follow up a recursive solution for this?"
                    },
                    {
                        "username": "leet_alok",
                        "content": "Can someone explain why this 10^9 nums is running perfectly in O(n^2) code? I am never able to figure out this."
                    },
                    {
                        "username": "leet_alok",
                        "content": "[@Saza-e-TLE](/Saza-e-TLE) yes I didn\\'t see properly. Thank you."
                    },
                    {
                        "username": "DR4G0N_EMPER0R",
                        "content": "TC depends on length of nums not the value of individual element in an array..\\nnums.length = 1e3 and n^2 = 1e6 <1e8 so n2 will work.\\nHope u understand \\uD83D\\uDE09 "
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can anyone explain 1st testcase, how it take cost 6 for 0th chocolate? Should it not be 11, becoz array is already rotated 2 times , 2*5 + 1 = 11"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "cost of shifting = 1*5 (you will pick and remove that just chocolate after 1 rotation) + 1(cost at that position)\\n\\nYou are rotating chocolates and the price is position dependent."
                    },
                    {
                        "username": "azad_6021",
                        "content": "Would have been a hard question if array size would be 1e5. Will require nlogn solution which can be done with Binary Search."
                    }
                ]
            },
            {
                "id": 2039791,
                "content": [
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Dekha ye leetcode hai aisa ghume ke question ata hai ki 4 log discussion me ake gali dete hai."
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "it should be hard category problem."
                    },
                    {
                        "username": "chandhugyana",
                        "content": "the explanation of the question was good.But the first test case is not the correct example for this question.(the values mentioned in the test case are wrong)"
                    },
                    {
                        "username": "entitled_american",
                        "content": "Actually a good question if the example and description matched up. I would probably put this as a hard. Also, I do hate when I waste so much time trying to imagine a linear time solution when a N^2 would have passed. "
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Anybody else solved this question using 2D prefix sum?"
                    },
                    {
                        "username": "adis176",
                        "content": "Can anyone tell me what category/topic this type of problem would come under?"
                    },
                    {
                        "username": "user5258V",
                        "content": "Dynamic programming"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can someone follow up a recursive solution for this?"
                    },
                    {
                        "username": "leet_alok",
                        "content": "Can someone explain why this 10^9 nums is running perfectly in O(n^2) code? I am never able to figure out this."
                    },
                    {
                        "username": "leet_alok",
                        "content": "[@Saza-e-TLE](/Saza-e-TLE) yes I didn\\'t see properly. Thank you."
                    },
                    {
                        "username": "DR4G0N_EMPER0R",
                        "content": "TC depends on length of nums not the value of individual element in an array..\\nnums.length = 1e3 and n^2 = 1e6 <1e8 so n2 will work.\\nHope u understand \\uD83D\\uDE09 "
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can anyone explain 1st testcase, how it take cost 6 for 0th chocolate? Should it not be 11, becoz array is already rotated 2 times , 2*5 + 1 = 11"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "cost of shifting = 1*5 (you will pick and remove that just chocolate after 1 rotation) + 1(cost at that position)\\n\\nYou are rotating chocolates and the price is position dependent."
                    },
                    {
                        "username": "azad_6021",
                        "content": "Would have been a hard question if array size would be 1e5. Will require nlogn solution which can be done with Binary Search."
                    }
                ]
            },
            {
                "id": 1933221,
                "content": [
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Dekha ye leetcode hai aisa ghume ke question ata hai ki 4 log discussion me ake gali dete hai."
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "it should be hard category problem."
                    },
                    {
                        "username": "chandhugyana",
                        "content": "the explanation of the question was good.But the first test case is not the correct example for this question.(the values mentioned in the test case are wrong)"
                    },
                    {
                        "username": "entitled_american",
                        "content": "Actually a good question if the example and description matched up. I would probably put this as a hard. Also, I do hate when I waste so much time trying to imagine a linear time solution when a N^2 would have passed. "
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Anybody else solved this question using 2D prefix sum?"
                    },
                    {
                        "username": "adis176",
                        "content": "Can anyone tell me what category/topic this type of problem would come under?"
                    },
                    {
                        "username": "user5258V",
                        "content": "Dynamic programming"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can someone follow up a recursive solution for this?"
                    },
                    {
                        "username": "leet_alok",
                        "content": "Can someone explain why this 10^9 nums is running perfectly in O(n^2) code? I am never able to figure out this."
                    },
                    {
                        "username": "leet_alok",
                        "content": "[@Saza-e-TLE](/Saza-e-TLE) yes I didn\\'t see properly. Thank you."
                    },
                    {
                        "username": "DR4G0N_EMPER0R",
                        "content": "TC depends on length of nums not the value of individual element in an array..\\nnums.length = 1e3 and n^2 = 1e6 <1e8 so n2 will work.\\nHope u understand \\uD83D\\uDE09 "
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can anyone explain 1st testcase, how it take cost 6 for 0th chocolate? Should it not be 11, becoz array is already rotated 2 times , 2*5 + 1 = 11"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "cost of shifting = 1*5 (you will pick and remove that just chocolate after 1 rotation) + 1(cost at that position)\\n\\nYou are rotating chocolates and the price is position dependent."
                    },
                    {
                        "username": "azad_6021",
                        "content": "Would have been a hard question if array size would be 1e5. Will require nlogn solution which can be done with Binary Search."
                    }
                ]
            },
            {
                "id": 1933197,
                "content": [
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Dekha ye leetcode hai aisa ghume ke question ata hai ki 4 log discussion me ake gali dete hai."
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "it should be hard category problem."
                    },
                    {
                        "username": "chandhugyana",
                        "content": "the explanation of the question was good.But the first test case is not the correct example for this question.(the values mentioned in the test case are wrong)"
                    },
                    {
                        "username": "entitled_american",
                        "content": "Actually a good question if the example and description matched up. I would probably put this as a hard. Also, I do hate when I waste so much time trying to imagine a linear time solution when a N^2 would have passed. "
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Anybody else solved this question using 2D prefix sum?"
                    },
                    {
                        "username": "adis176",
                        "content": "Can anyone tell me what category/topic this type of problem would come under?"
                    },
                    {
                        "username": "user5258V",
                        "content": "Dynamic programming"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can someone follow up a recursive solution for this?"
                    },
                    {
                        "username": "leet_alok",
                        "content": "Can someone explain why this 10^9 nums is running perfectly in O(n^2) code? I am never able to figure out this."
                    },
                    {
                        "username": "leet_alok",
                        "content": "[@Saza-e-TLE](/Saza-e-TLE) yes I didn\\'t see properly. Thank you."
                    },
                    {
                        "username": "DR4G0N_EMPER0R",
                        "content": "TC depends on length of nums not the value of individual element in an array..\\nnums.length = 1e3 and n^2 = 1e6 <1e8 so n2 will work.\\nHope u understand \\uD83D\\uDE09 "
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can anyone explain 1st testcase, how it take cost 6 for 0th chocolate? Should it not be 11, becoz array is already rotated 2 times , 2*5 + 1 = 11"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "cost of shifting = 1*5 (you will pick and remove that just chocolate after 1 rotation) + 1(cost at that position)\\n\\nYou are rotating chocolates and the price is position dependent."
                    },
                    {
                        "username": "azad_6021",
                        "content": "Would have been a hard question if array size would be 1e5. Will require nlogn solution which can be done with Binary Search."
                    }
                ]
            },
            {
                "id": 1926397,
                "content": [
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Dekha ye leetcode hai aisa ghume ke question ata hai ki 4 log discussion me ake gali dete hai."
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "it should be hard category problem."
                    },
                    {
                        "username": "chandhugyana",
                        "content": "the explanation of the question was good.But the first test case is not the correct example for this question.(the values mentioned in the test case are wrong)"
                    },
                    {
                        "username": "entitled_american",
                        "content": "Actually a good question if the example and description matched up. I would probably put this as a hard. Also, I do hate when I waste so much time trying to imagine a linear time solution when a N^2 would have passed. "
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Anybody else solved this question using 2D prefix sum?"
                    },
                    {
                        "username": "adis176",
                        "content": "Can anyone tell me what category/topic this type of problem would come under?"
                    },
                    {
                        "username": "user5258V",
                        "content": "Dynamic programming"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can someone follow up a recursive solution for this?"
                    },
                    {
                        "username": "leet_alok",
                        "content": "Can someone explain why this 10^9 nums is running perfectly in O(n^2) code? I am never able to figure out this."
                    },
                    {
                        "username": "leet_alok",
                        "content": "[@Saza-e-TLE](/Saza-e-TLE) yes I didn\\'t see properly. Thank you."
                    },
                    {
                        "username": "DR4G0N_EMPER0R",
                        "content": "TC depends on length of nums not the value of individual element in an array..\\nnums.length = 1e3 and n^2 = 1e6 <1e8 so n2 will work.\\nHope u understand \\uD83D\\uDE09 "
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can anyone explain 1st testcase, how it take cost 6 for 0th chocolate? Should it not be 11, becoz array is already rotated 2 times , 2*5 + 1 = 11"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "cost of shifting = 1*5 (you will pick and remove that just chocolate after 1 rotation) + 1(cost at that position)\\n\\nYou are rotating chocolates and the price is position dependent."
                    },
                    {
                        "username": "azad_6021",
                        "content": "Would have been a hard question if array size would be 1e5. Will require nlogn solution which can be done with Binary Search."
                    }
                ]
            },
            {
                "id": 1925746,
                "content": [
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Dekha ye leetcode hai aisa ghume ke question ata hai ki 4 log discussion me ake gali dete hai."
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "it should be hard category problem."
                    },
                    {
                        "username": "chandhugyana",
                        "content": "the explanation of the question was good.But the first test case is not the correct example for this question.(the values mentioned in the test case are wrong)"
                    },
                    {
                        "username": "entitled_american",
                        "content": "Actually a good question if the example and description matched up. I would probably put this as a hard. Also, I do hate when I waste so much time trying to imagine a linear time solution when a N^2 would have passed. "
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Anybody else solved this question using 2D prefix sum?"
                    },
                    {
                        "username": "adis176",
                        "content": "Can anyone tell me what category/topic this type of problem would come under?"
                    },
                    {
                        "username": "user5258V",
                        "content": "Dynamic programming"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can someone follow up a recursive solution for this?"
                    },
                    {
                        "username": "leet_alok",
                        "content": "Can someone explain why this 10^9 nums is running perfectly in O(n^2) code? I am never able to figure out this."
                    },
                    {
                        "username": "leet_alok",
                        "content": "[@Saza-e-TLE](/Saza-e-TLE) yes I didn\\'t see properly. Thank you."
                    },
                    {
                        "username": "DR4G0N_EMPER0R",
                        "content": "TC depends on length of nums not the value of individual element in an array..\\nnums.length = 1e3 and n^2 = 1e6 <1e8 so n2 will work.\\nHope u understand \\uD83D\\uDE09 "
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can anyone explain 1st testcase, how it take cost 6 for 0th chocolate? Should it not be 11, becoz array is already rotated 2 times , 2*5 + 1 = 11"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "cost of shifting = 1*5 (you will pick and remove that just chocolate after 1 rotation) + 1(cost at that position)\\n\\nYou are rotating chocolates and the price is position dependent."
                    },
                    {
                        "username": "azad_6021",
                        "content": "Would have been a hard question if array size would be 1e5. Will require nlogn solution which can be done with Binary Search."
                    }
                ]
            },
            {
                "id": 1925683,
                "content": [
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Dekha ye leetcode hai aisa ghume ke question ata hai ki 4 log discussion me ake gali dete hai."
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "it should be hard category problem."
                    },
                    {
                        "username": "chandhugyana",
                        "content": "the explanation of the question was good.But the first test case is not the correct example for this question.(the values mentioned in the test case are wrong)"
                    },
                    {
                        "username": "entitled_american",
                        "content": "Actually a good question if the example and description matched up. I would probably put this as a hard. Also, I do hate when I waste so much time trying to imagine a linear time solution when a N^2 would have passed. "
                    },
                    {
                        "username": "Goblin_Cyanide",
                        "content": "Anybody else solved this question using 2D prefix sum?"
                    },
                    {
                        "username": "adis176",
                        "content": "Can anyone tell me what category/topic this type of problem would come under?"
                    },
                    {
                        "username": "user5258V",
                        "content": "Dynamic programming"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can someone follow up a recursive solution for this?"
                    },
                    {
                        "username": "leet_alok",
                        "content": "Can someone explain why this 10^9 nums is running perfectly in O(n^2) code? I am never able to figure out this."
                    },
                    {
                        "username": "leet_alok",
                        "content": "[@Saza-e-TLE](/Saza-e-TLE) yes I didn\\'t see properly. Thank you."
                    },
                    {
                        "username": "DR4G0N_EMPER0R",
                        "content": "TC depends on length of nums not the value of individual element in an array..\\nnums.length = 1e3 and n^2 = 1e6 <1e8 so n2 will work.\\nHope u understand \\uD83D\\uDE09 "
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "can anyone explain 1st testcase, how it take cost 6 for 0th chocolate? Should it not be 11, becoz array is already rotated 2 times , 2*5 + 1 = 11"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "cost of shifting = 1*5 (you will pick and remove that just chocolate after 1 rotation) + 1(cost at that position)\\n\\nYou are rotating chocolates and the price is position dependent."
                    },
                    {
                        "username": "azad_6021",
                        "content": "Would have been a hard question if array size would be 1e5. Will require nlogn solution which can be done with Binary Search."
                    }
                ]
            }
        ]
    }
]