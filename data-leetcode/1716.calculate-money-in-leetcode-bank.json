[
    {
        "title": "Monotonic Array",
        "question_content": "An array is monotonic if it is either monotone increasing or monotone decreasing.\nAn array nums is monotone increasing if for all i <= j, nums[i] <= nums[j]. An array nums is monotone decreasing if for all i <= j, nums[i] >= nums[j].\nGiven an integer array nums, return true if the given array is monotonic, or false otherwise.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,2,3]\nOutput: true\n\nExample 2:\n\nInput: nums = [6,5,4,4]\nOutput: true\n\nExample 3:\n\nInput: nums = [1,3,2]\nOutput: false\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t-105 <= nums[i] <= 105",
        "solutions": [
            {
                "id": 165889,
                "title": "c-java-python-one-pass-o-n",
                "content": "We check if `A` is increasing and decreasing.\\n\\n**C++:**\\n```\\n    bool isMonotonic(vector<int> A) {\\n        bool inc = true, dec = true;\\n        for (int i = 1; i < A.size(); ++i)\\n            inc &= A[i - 1] <= A[i], dec &= A[i - 1] >= A[i];\\n        return inc || dec;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public boolean isMonotonic(int[] A) {\\n        boolean inc = true, dec = true;\\n        for (int i = 1; i < A.length; ++i) {\\n            inc &= A[i - 1] <= A[i];\\n            dec &= A[i - 1] >= A[i];\\n        }\\n        return inc || dec;\\n    }\\n```\\n\\n**Python:**\\n```\\n    def isMonotonic(self, A):\\n        return not {cmp(i, j) for i, j in zip(A, A[1:])} >= {1, -1}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    bool isMonotonic(vector<int> A) {\\n        bool inc = true, dec = true;\\n        for (int i = 1; i < A.size(); ++i)\\n            inc &= A[i - 1] <= A[i], dec &= A[i - 1] >= A[i];\\n        return inc || dec;\\n    }\\n```\n```\\n    public boolean isMonotonic(int[] A) {\\n        boolean inc = true, dec = true;\\n        for (int i = 1; i < A.length; ++i) {\\n            inc &= A[i - 1] <= A[i];\\n            dec &= A[i - 1] >= A[i];\\n        }\\n        return inc || dec;\\n    }\\n```\n```\\n    def isMonotonic(self, A):\\n        return not {cmp(i, j) for i, j in zip(A, A[1:])} >= {1, -1}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4102869,
                "title": "95-15-single-pass-check",
                "content": "# Interview Guide: \"Check Monotonic Array\" Problem\\n\\n## Problem Understanding\\n\\nThe \"Check Monotonic Array\" problem requires evaluating whether a given array is either entirely non-decreasing (monotonically increasing) or non-increasing (monotonically decreasing). The objective is to return a boolean value indicating the array\\'s monotonicity.\\n\\n## Key Points to Consider\\n\\n### 1. Understand the Constraints\\n\\nBefore diving into the solution, it\\'s crucial to recognize the problem\\'s constraints. The length of the array `nums` is between 1 and $$10^5$$, and the integers in `nums` range between $$-10^5$$ and $$10^5$$. These constraints offer insights into potential solutions in terms of time and space complexity.\\n\\n### 2. Single Pass Check\\n\\nOne efficient way to solve this problem is to use a single pass through the array to determine if it\\'s increasing, decreasing, or neither. This approach reduces the number of checks and can potentially exit early if the array is neither increasing nor decreasing.\\n\\n### 3. Understand Array Characteristics\\n\\nA key observation is that if an array starts by increasing, it should not switch to decreasing later and vice versa. This observation forms the basis of the solution.\\n\\n### 4. Explain Your Thought Process\\n\\nAlways articulate the rationale behind your approach. Describe the importance of determining the direction of monotonicity early on and how it can help in making the solution more efficient.\\n\\n## Conclusion\\n\\nThe \"Check Monotonic Array\" problem emphasizes the significance of understanding array traversal and condition checks. By performing a single pass through the array, you can efficiently determine its monotonicity.\\n\\n---\\n\\n## Live Coding & Explain\\nhttps://youtu.be/INyEvNkNRcg?si=R2VWH4FxIb_nHWoH\\n\\n# Approach: Single Pass Check\\n\\nTo solve the \"Check Monotonic Array\" problem using the single pass check:\\n\\n## Key Data Structures:\\n\\n- **direction**: A variable to keep track of the array\\'s direction (increasing, decreasing, or unknown).\\n\\n## Enhanced Breakdown:\\n\\n1. **Initialization**:\\n   - If the array\\'s length is less than 2, return `True` (arrays with 0 or 1 elements are always monotonic).\\n   - Initialize the `direction` as 0 (unknown).\\n   \\n2. **Traverse the Array**:\\n   - For every pair of adjacent elements, determine if the array is increasing, decreasing, or neither.\\n   - If the direction is set to increasing and a decreasing pattern is found, return `False`, and vice versa.\\n   \\n3. **Return the Result**:\\n   - If no violation of monotonicity is found during traversal, return `True`.\\n\\n# Complexity:\\n\\n**Time Complexity:** \\n- The solution involves traversing the array once, leading to a time complexity of $$O(n)$$, where `n` is the length of the array `nums`.\\n\\n**Space Complexity:** \\n- The space complexity is $$O(1)$$ since the solution doesn\\'t use any additional data structures that scale with the input size.\\n\\n# Code Single Pass Check\\n``` Python []\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        if len(nums) < 2:\\n            return True\\n        \\n        direction = 0  # 0 means unknown, 1 means increasing, -1 means decreasing\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:  # increasing\\n                if direction == 0:\\n                    direction = 1\\n                elif direction == -1:\\n                    return False\\n            elif nums[i] < nums[i-1]:  # decreasing\\n                if direction == 0:\\n                    direction = -1\\n                elif direction == 1:\\n                    return False\\n        \\n        return True\\n```\\n``` Go []\\nfunc isMonotonic(nums []int) bool {\\n    if len(nums) < 2 {\\n        return true\\n    }\\n\\n    direction := 0  // 0 means unknown, 1 means increasing, -1 means decreasing\\n\\n    for i := 1; i < len(nums); i++ {\\n        if nums[i] > nums[i-1] {  // increasing\\n            if direction == 0 {\\n                direction = 1\\n            } else if direction == -1 {\\n                return false\\n            }\\n        } else if nums[i] < nums[i-1] {  // decreasing\\n            if direction == 0 {\\n                direction = -1\\n            } else if direction == 1 {\\n                return false\\n            }\\n        }\\n    }\\n\\n    return true\\n}\\n```\\n``` Rust []\\nimpl Solution {\\n    pub fn is_monotonic(nums: Vec<i32>) -> bool {\\n        if nums.len() < 2 {\\n            return true;\\n        }\\n\\n        let mut direction = 0;  // 0 means unknown, 1 means increasing, -1 means decreasing\\n\\n        for i in 1..nums.len() {\\n            if nums[i] > nums[i-1] {  // increasing\\n                if direction == 0 {\\n                    direction = 1;\\n                } else if direction == -1 {\\n                    return false;\\n                }\\n            } else if nums[i] < nums[i-1] {  // decreasing\\n                if direction == 0 {\\n                    direction = -1;\\n                } else if direction == 1 {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        true\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool isMonotonic(std::vector<int>& nums) {\\n        if (nums.size() < 2) return true;\\n\\n        int direction = 0;  // 0 means unknown, 1 means increasing, -1 means decreasing\\n\\n        for (size_t i = 1; i < nums.size(); i++) {\\n            if (nums[i] > nums[i-1]) {  // increasing\\n                if (direction == 0) direction = 1;\\n                else if (direction == -1) return false;\\n            } else if (nums[i] < nums[i-1]) {  // decreasing\\n                if (direction == 0) direction = -1;\\n                else if (direction == 1) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        if (nums.length < 2) return true;\\n\\n        int direction = 0;  // 0 means unknown, 1 means increasing, -1 means decreasing\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > nums[i-1]) {  // increasing\\n                if (direction == 0) direction = 1;\\n                else if (direction == -1) return false;\\n            } else if (nums[i] < nums[i-1]) {  // decreasing\\n                if (direction == 0) direction = -1;\\n                else if (direction == 1) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n``` JavaScript []\\nvar isMonotonic = function(nums) {\\n    if (nums.length < 2) return true;\\n\\n    let direction = 0;  // 0 means unknown, 1 means increasing, -1 means decreasing\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] > nums[i-1]) {  // increasing\\n            if (direction === 0) direction = 1;\\n            else if (direction === -1) return false;\\n        } else if (nums[i] < nums[i-1]) {  // decreasing\\n            if (direction === 0) direction = -1;\\n            else if (direction === 1) return false;\\n        }\\n    }\\n\\n    return true;\\n};\\n```\\n``` PHP []\\nclass Solution {\\n    function isMonotonic($nums) {\\n        if (count($nums) < 2) return true;\\n\\n        $direction = 0;  // 0 means unknown, 1 means increasing, -1 means decreasing\\n\\n        for ($i = 1; $i < count($nums); $i++) {\\n            if ($nums[$i] > $nums[$i-1]) {  // increasing\\n                if ($direction == 0) $direction = 1;\\n                else if ($direction == -1) return false;\\n            } else if ($nums[$i] < $nums[$i-1]) {  // decreasing\\n                if ($direction == 0) $direction = -1;\\n                else if ($direction == 1) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public bool IsMonotonic(int[] nums) {\\n        if (nums.Length < 2) return true;\\n\\n        int direction = 0;  // 0 means unknown, 1 means increasing, -1 means decreasing\\n\\n        for (int i = 1; i < nums.Length; i++) {\\n            if (nums[i] > nums[i-1]) {  // increasing\\n                if (direction == 0) direction = 1;\\n                else if (direction == -1) return false;\\n            } else if (nums[i] < nums[i-1]) {  // decreasing\\n                if (direction == 0) direction = -1;\\n                else if (direction == 1) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n\\n## Performance\\n\\n| Language   | Time (ms) | Memory    |\\n|------------|-----------|-----------|\\n| Java       | 1 ms      | 55.4 MB   |\\n| Rust       | 12 ms     | 3.3 MB    |\\n| JavaScript | 80 ms     | 52.4 MB   |\\n| C++        | 131 ms    | 96.8 MB   |\\n| Go         | 135 ms    | 9.8 MB    |\\n| C#         | 241 ms    | 61.4 MB   |\\n| PHP        | 277 ms    | 31.7 MB   |\\n| Python3    | 812 ms    | 30.4 MB   |\\n\\n![v4.png](https://assets.leetcode.com/users/images/f7e8cef7-b85d-4335-82e6-2f3f0fc83197_1695948899.0787735.png)\\n\\nThe \"Check Monotonic Array\" problem is an interesting array traversal problem that tests the ability to keep track of a property (monotonicity) while traversing an array. It showcases the importance of efficient array traversal and conditional checks. \\uD83D\\uDE80\\uD83E\\uDDE0\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "PHP"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        if len(nums) < 2:\\n            return True\\n        \\n        direction = 0  # 0 means unknown, 1 means increasing, -1 means decreasing\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:  # increasing\\n                if direction == 0:\\n                    direction = 1\\n                elif direction == -1:\\n                    return False\\n            elif nums[i] < nums[i-1]:  # decreasing\\n                if direction == 0:\\n                    direction = -1\\n                elif direction == 1:\\n                    return False\\n        \\n        return True\\n```\n``` Go []\\nfunc isMonotonic(nums []int) bool {\\n    if len(nums) < 2 {\\n        return true\\n    }\\n\\n    direction := 0  // 0 means unknown, 1 means increasing, -1 means decreasing\\n\\n    for i := 1; i < len(nums); i++ {\\n        if nums[i] > nums[i-1] {  // increasing\\n            if direction == 0 {\\n                direction = 1\\n            } else if direction == -1 {\\n                return false\\n            }\\n        } else if nums[i] < nums[i-1] {  // decreasing\\n            if direction == 0 {\\n                direction = -1\\n            } else if direction == 1 {\\n                return false\\n            }\\n        }\\n    }\\n\\n    return true\\n}\\n```\n``` Rust []\\nimpl Solution {\\n    pub fn is_monotonic(nums: Vec<i32>) -> bool {\\n        if nums.len() < 2 {\\n            return true;\\n        }\\n\\n        let mut direction = 0;  // 0 means unknown, 1 means increasing, -1 means decreasing\\n\\n        for i in 1..nums.len() {\\n            if nums[i] > nums[i-1] {  // increasing\\n                if direction == 0 {\\n                    direction = 1;\\n                } else if direction == -1 {\\n                    return false;\\n                }\\n            } else if nums[i] < nums[i-1] {  // decreasing\\n                if direction == 0 {\\n                    direction = -1;\\n                } else if direction == 1 {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        true\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    bool isMonotonic(std::vector<int>& nums) {\\n        if (nums.size() < 2) return true;\\n\\n        int direction = 0;  // 0 means unknown, 1 means increasing, -1 means decreasing\\n\\n        for (size_t i = 1; i < nums.size(); i++) {\\n            if (nums[i] > nums[i-1]) {  // increasing\\n                if (direction == 0) direction = 1;\\n                else if (direction == -1) return false;\\n            } else if (nums[i] < nums[i-1]) {  // decreasing\\n                if (direction == 0) direction = -1;\\n                else if (direction == 1) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        if (nums.length < 2) return true;\\n\\n        int direction = 0;  // 0 means unknown, 1 means increasing, -1 means decreasing\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > nums[i-1]) {  // increasing\\n                if (direction == 0) direction = 1;\\n                else if (direction == -1) return false;\\n            } else if (nums[i] < nums[i-1]) {  // decreasing\\n                if (direction == 0) direction = -1;\\n                else if (direction == 1) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\n``` JavaScript []\\nvar isMonotonic = function(nums) {\\n    if (nums.length < 2) return true;\\n\\n    let direction = 0;  // 0 means unknown, 1 means increasing, -1 means decreasing\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] > nums[i-1]) {  // increasing\\n            if (direction === 0) direction = 1;\\n            else if (direction === -1) return false;\\n        } else if (nums[i] < nums[i-1]) {  // decreasing\\n            if (direction === 0) direction = -1;\\n            else if (direction === 1) return false;\\n        }\\n    }\\n\\n    return true;\\n};\\n```\n``` PHP []\\nclass Solution {\\n    function isMonotonic($nums) {\\n        if (count($nums) < 2) return true;\\n\\n        $direction = 0;  // 0 means unknown, 1 means increasing, -1 means decreasing\\n\\n        for ($i = 1; $i < count($nums); $i++) {\\n            if ($nums[$i] > $nums[$i-1]) {  // increasing\\n                if ($direction == 0) $direction = 1;\\n                else if ($direction == -1) return false;\\n            } else if ($nums[$i] < $nums[$i-1]) {  // decreasing\\n                if ($direction == 0) $direction = -1;\\n                else if ($direction == 1) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public bool IsMonotonic(int[] nums) {\\n        if (nums.Length < 2) return true;\\n\\n        int direction = 0;  // 0 means unknown, 1 means increasing, -1 means decreasing\\n\\n        for (int i = 1; i < nums.Length; i++) {\\n            if (nums[i] > nums[i-1]) {  // increasing\\n                if (direction == 0) direction = 1;\\n                else if (direction == -1) return false;\\n            } else if (nums[i] < nums[i-1]) {  // decreasing\\n                if (direction == 0) direction = -1;\\n                else if (direction == 1) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4102847,
                "title": "97-44-increasing-decreasing-1-line-code",
                "content": "# Problem\\n#### The problem statement asks you to determine whether a given array nums is monotonic. An array is considered monotonic if it is either monotone increasing or monotone decreasing.\\n\\n **1.** **Monotone Increasing :**   An array is considered monotone increasing if for all indices i and j where i <= j, the element at index i is less than or equal to the element at index j. In other words, the values in the array are non-decreasing as you move from left to right.\\n\\n**2.** **Monotone Decreasing :** An array is considered monotone decreasing if for all indices i and j where i <= j, the element at index i is greater than or equal to the element at index j. In other words, the values in the array are non-increasing as you move from left to right.\\n\\n#### The task is to check if the given nums array satisfies either of these conditions. If it does, the function should return true, indicating that the array is monotonic. Otherwise, it should return false.\\n---\\n# Solution\\n#### 1. Initialize two boolean variables, increasing and decreasing, to true. These variables will be used to track whether the array is monotone increasing or monotone decreasing.\\n\\n#### 2.Iterate through the array from the second element (i = 1) to the last element (i = nums.length - 1).\\n\\n#### 3.For each pair of adjacent elements at indices i and i - 1, compare them:\\n\\n- ***If nums[i] is greater than nums[i - 1], set decreasing to false. This means the array is not monotone decreasing.***\\n\\n- ***If nums[i] is less than nums[i - 1], set increasing to false. This means the array is not monotone increasing.***\\n\\n#### 4. During the iteration, if at any point both increasing and decreasing become false, you can immediately return false because the array is neither monotone increasing nor monotone decreasing.\\n\\n#### 5.After the loop, if either increasing or decreasing is still true, it means the array is either monotone increasing or monotone decreasing, so you return true. Otherwise, you return false because the array is not monotonic.\\n---\\n\\n```python []\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        return all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or all(A[i] >= A[i + 1] for i in range(len(A) - 1))\\n\\n```\\n```C# []\\npublic class Solution {\\n    public bool IsMonotonic(int[] nums) {\\n        bool increasing = true;\\n        bool decreasing = true;\\n\\n        for (int i = 1; i < nums.Length; i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                decreasing = false;\\n            } else if (nums[i] < nums[i - 1]) {\\n                increasing = false;\\n            }\\n\\n            if (!increasing && !decreasing) {\\n                return false;\\n            }\\n        }\\n\\n        return true; \\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool increasing = true;\\n        bool decreasing = true;\\n\\n        for (int i = 1; i < nums.size(); ++i) {\\n            if (nums[i] > nums[i - 1]) {\\n                decreasing = false;\\n            } else if (nums[i] < nums[i - 1]) {\\n                increasing = false;\\n            }\\n\\n            if (!increasing && !decreasing) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```\\n```C []\\nbool isMonotonic(int* nums, int numsSize) {\\n    bool increasing = true;\\n    bool decreasing = true;\\n\\n    for (int i = 1; i < numsSize; i++) {\\n        if (nums[i] > nums[i - 1]) {\\n            decreasing = false;\\n        } else if (nums[i] < nums[i - 1]) {\\n            increasing = false;\\n        }\\n\\n        if (!increasing && !decreasing) {\\n            return false;\\n        }\\n    }\\n\\n    return true; \\n}\\n\\n```\\n```Java []\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean increasing = true;\\n        boolean decreasing = true;\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                decreasing = false;\\n            } else if (nums[i] < nums[i - 1]) {\\n                increasing = false;\\n            }\\n\\n            if (!increasing && !decreasing) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```\\n```javascript []\\nvar isMonotonic = function(nums) {\\n    let increasing = true;\\n    let decreasing = true;\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] > nums[i - 1]) {\\n            decreasing = false;\\n        } else if (nums[i] < nums[i - 1]) {\\n            increasing = false;\\n        }\\n\\n        if (!increasing && !decreasing) {\\n            return false;\\n        }\\n    }\\n\\n    return true; \\n};\\n\\n```\\n```typescript []\\nfunction isMonotonic(nums: number[]): boolean {\\n    let increasing = true;\\n    let decreasing = true;\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] > nums[i - 1]) {\\n            decreasing = false;\\n        } else if (nums[i] < nums[i - 1]) {\\n            increasing = false;\\n        }\\n\\n        if (!increasing && !decreasing) {\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n}\\n\\n```\\n```Go []\\nfunc isMonotonic(nums []int) bool {\\n    increasing := true\\n    decreasing := true\\n    for i := 1; i < len(nums); i++ {\\n        if nums[i] > nums[i-1] {\\n            decreasing = false\\n        } else if nums[i] < nums[i-1] {\\n            increasing = false\\n        }\\n        if !increasing && !decreasing {\\n            return false\\n        }\\n    }\\n    return true \\n}\\n```\\n```rust []\\nimpl Solution {\\n    pub fn is_monotonic(nums: Vec<i32>) -> bool {\\n        let mut increasing = true;\\n        let mut decreasing = true;\\n\\n        for i in 1..nums.len() {\\n            if nums[i] > nums[i - 1] {\\n                decreasing = false;\\n            } else if nums[i] < nums[i - 1] {\\n                increasing = false;\\n            }\\n\\n            // If both increasing and decreasing become false, return false immediately.\\n            if !increasing && !decreasing {\\n                return false;\\n            }\\n        }\\n\\n        true // Either increasing or decreasing remains true, or both are true (monotonic).\\n    }\\n}\\n```\\n\\n![9c6f9412-c860-47d6-9a2e-7fcf37ff3321_1686334926.180891.png](https://assets.leetcode.com/users/images/372c6f32-ec84-4a05-9050-846fe3cc231a_1695946977.0907705.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "TypeScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        return all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or all(A[i] >= A[i + 1] for i in range(len(A) - 1))\\n\\n```\n```C# []\\npublic class Solution {\\n    public bool IsMonotonic(int[] nums) {\\n        bool increasing = true;\\n        bool decreasing = true;\\n\\n        for (int i = 1; i < nums.Length; i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                decreasing = false;\\n            } else if (nums[i] < nums[i - 1]) {\\n                increasing = false;\\n            }\\n\\n            if (!increasing && !decreasing) {\\n                return false;\\n            }\\n        }\\n\\n        return true; \\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool increasing = true;\\n        bool decreasing = true;\\n\\n        for (int i = 1; i < nums.size(); ++i) {\\n            if (nums[i] > nums[i - 1]) {\\n                decreasing = false;\\n            } else if (nums[i] < nums[i - 1]) {\\n                increasing = false;\\n            }\\n\\n            if (!increasing && !decreasing) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```\n```C []\\nbool isMonotonic(int* nums, int numsSize) {\\n    bool increasing = true;\\n    bool decreasing = true;\\n\\n    for (int i = 1; i < numsSize; i++) {\\n        if (nums[i] > nums[i - 1]) {\\n            decreasing = false;\\n        } else if (nums[i] < nums[i - 1]) {\\n            increasing = false;\\n        }\\n\\n        if (!increasing && !decreasing) {\\n            return false;\\n        }\\n    }\\n\\n    return true; \\n}\\n\\n```\n```Java []\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean increasing = true;\\n        boolean decreasing = true;\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                decreasing = false;\\n            } else if (nums[i] < nums[i - 1]) {\\n                increasing = false;\\n            }\\n\\n            if (!increasing && !decreasing) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```\n```javascript []\\nvar isMonotonic = function(nums) {\\n    let increasing = true;\\n    let decreasing = true;\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] > nums[i - 1]) {\\n            decreasing = false;\\n        } else if (nums[i] < nums[i - 1]) {\\n            increasing = false;\\n        }\\n\\n        if (!increasing && !decreasing) {\\n            return false;\\n        }\\n    }\\n\\n    return true; \\n};\\n\\n```\n```typescript []\\nfunction isMonotonic(nums: number[]): boolean {\\n    let increasing = true;\\n    let decreasing = true;\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] > nums[i - 1]) {\\n            decreasing = false;\\n        } else if (nums[i] < nums[i - 1]) {\\n            increasing = false;\\n        }\\n\\n        if (!increasing && !decreasing) {\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n}\\n\\n```\n```Go []\\nfunc isMonotonic(nums []int) bool {\\n    increasing := true\\n    decreasing := true\\n    for i := 1; i < len(nums); i++ {\\n        if nums[i] > nums[i-1] {\\n            decreasing = false\\n        } else if nums[i] < nums[i-1] {\\n            increasing = false\\n        }\\n        if !increasing && !decreasing {\\n            return false\\n        }\\n    }\\n    return true \\n}\\n```\n```rust []\\nimpl Solution {\\n    pub fn is_monotonic(nums: Vec<i32>) -> bool {\\n        let mut increasing = true;\\n        let mut decreasing = true;\\n\\n        for i in 1..nums.len() {\\n            if nums[i] > nums[i - 1] {\\n                decreasing = false;\\n            } else if nums[i] < nums[i - 1] {\\n                increasing = false;\\n            }\\n\\n            // If both increasing and decreasing become false, return false immediately.\\n            if !increasing && !decreasing {\\n                return false;\\n            }\\n        }\\n\\n        true // Either increasing or decreasing remains true, or both are true (monotonic).\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165960,
                "title": "python-solution-easy-to-understand",
                "content": "```\\nclass Solution(object):\\n    def isMonotonic(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: bool\\n        \"\"\"\\n\\n        n = len(A)\\n        if n <= 2: return True\\n\\t\\t\\t\\t\\n        isGreat = False\\n        isLess = False\\n        for i in range(1, n):\\n            if A[i - 1] > A[i]:\\n                isGreat = True\\n            if A[i - 1] < A[i]:\\n                isLess = True\\n\\n            if isGreat and isLess:\\n                return False\\n\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isMonotonic(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: bool\\n        \"\"\"\\n\\n        n = len(A)\\n        if n <= 2: return True\\n\\t\\t\\t\\t\\n        isGreat = False\\n        isLess = False\\n        for i in range(1, n):\\n            if A[i - 1] > A[i]:\\n                isGreat = True\\n            if A[i - 1] < A[i]:\\n                isLess = True\\n\\n            if isGreat and isLess:\\n                return False\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518215,
                "title": "c-easy-one-pass-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& A) {\\n        bool increase = true;\\n        bool decrease = true;\\n        for(int i = 0; i < A.size() - 1; i++) {\\n            if(A[i] > A[i+1]) increase = false;\\n            if(A[i] < A[i+1]) decrease = false;\\n            if(increase == false && decrease == false) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& A) {\\n        bool increase = true;\\n        bool decrease = true;\\n        for(int i = 0; i < A.size() - 1; i++) {\\n            if(A[i] > A[i+1]) increase = false;\\n            if(A[i] < A[i+1]) decrease = false;\\n            if(increase == false && decrease == false) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165917,
                "title": "java-tricky-solution",
                "content": "1. Find the trend based on A[0] and A[n-1]\\n2. Check if the consecutive neighbors are consistent with the trend.\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] A) {\\n        if (A.length==1) return true;\\n        int n=A.length;\\n        boolean up= (A[n-1]-A[0])>0;\\n        for (int i=0; i<n-1; i++)\\n            if (A[i+1]!=A[i] && (A[i+1]-A[i]>0)!=up) \\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] A) {\\n        if (A.length==1) return true;\\n        int n=A.length;\\n        boolean up= (A[n-1]-A[0])>0;\\n        for (int i=0; i<n-1; i++)\\n            if (A[i+1]!=A[i] && (A[i+1]-A[i]>0)!=up) \\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 172578,
                "title": "java-o-n-simple-solution",
                "content": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] A) {\\n        int inc=1;\\n        int dec=1;\\n        for(int i=1; i<A.length; i++){\\n            if(A[i] - A[i-1] > 0)\\n                inc++;\\n            else if(A[i] - A[i-1] < 0)\\n                dec++;\\n            else {\\n                inc++; dec++;\\n            }\\n                \\n        }\\n        return inc == A.length || dec == A.length;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] A) {\\n        int inc=1;\\n        int dec=1;\\n        for(int i=1; i<A.length; i++){\\n            if(A[i] - A[i-1] > 0)\\n                inc++;\\n            else if(A[i] - A[i-1] < 0)\\n                dec++;\\n            else {\\n                inc++; dec++;\\n            }\\n                \\n        }\\n        return inc == A.length || dec == A.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680607,
                "title": "python-simple-one-line-solution",
                "content": "**Python :**\\n\\n```\\ndef isMonotonic(self, nums: List[int]) -> bool:\\n\\treturn nums == sorted(nums) or nums == sorted(nums, reverse=True)\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef isMonotonic(self, nums: List[int]) -> bool:\\n\\treturn nums == sorted(nums) or nums == sorted(nums, reverse=True)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4103078,
                "title": "video-how-we-think-about-a-solution-two-flags-python-javascript-java-c",
                "content": "Welcome to my article! This artcle starts with \"How we think about a solution\". In other words, that is my thought process to solve the question. This article explains how I get to my solution instead of just posting solution codes or out of blue algorithms. I hope this aricle is helpful for someone.\\n\\n# Intuition\\nUse two flags to check this is increasing or decreasing.\\n\\n---\\n\\n# Solution Video\\n\\nhttps://youtu.be/UVEDSDDSP-U\\n\\n### \\u2B50\\uFE0F\\u2B50\\uFE0F Don\\'t forget to subscribe to my channel! \\u2B50\\uFE0F\\u2B50\\uFE0F\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nSubscribers: 2,533\\nMy initial goal is 10,000\\nThank you for your support!\\n\\n---\\n\\n# Approach\\n\\n## How we think about a solution.\\n\\nAt first, I solved this question with two loops simply like this.\\n\\n```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        if n == 1: return True\\n        \\n        # check if this is increasing        \\n        for i in range(1, n):\\n            if nums[i] < nums[i-1]:\\n                break\\n            \\n            if i == n - 1:\\n                return True\\n\\n        # check if this is decreasing\\n        for i in range(1, n):\\n            if nums[i] > nums[i-1]:\\n                break\\n            \\n            if i == n - 1:\\n                return True\\n\\n        return False\\n```\\nThis solution passed all test cases and beated about 60%... not bad. but I realized that we can check both simultaneously if we have `two flags`.\\n\\n---\\n\\n\\n**The `two flags` indicates that input is increasing or decreasing.**\\n\\n---\\n\\nThe both flags start with `True`\\n```\\nInput: nums = [1,2,2,3]\\n\\nis_inc = True\\nis_dec = True\\n```\\nFirst of all, check length of input and if length of input is `1` return `true`.\\n\\nNext, we start from `index 1`. Compare two numbers at `index 1` and `index 0`\\n\\n```\\nindex 0: 1\\nindex 1: 2\\n\\nis_inc = True\\nis_dec = False\\n```\\nThis is increasing case, so in the end the `two flags` should be above.\\n```\\nindex 1: 2\\nindex 2: 2\\n\\nis_inc = True\\nis_dec = False\\n```\\nWe can consider the same numbers as both cases, so this is increasing case because `is_dec` was already `false`, so in the end the `two flags` should be the same.\\n\\n```\\nindex 2: 2\\nindex 3: 3\\n\\nis_inc = True\\nis_dec = False\\n```\\nThis is increasing case, the `both flag` should be the same. Then finish looping.\\n\\nAfter that, check both flags and if one of them is still `true`, that means we have `Monotonic Array`, so return `true`.\\n\\nOf course, during looping, if both flags are `false`, we can immediately return `false`.\\n\\nAnd one more thing\\n\\nI use `or` at the last step in the codes. It covers cases like `[1,3,2]`. In this case, loop 2 times and `is_dec` turn into `false` in the first loop and `is_inc` turn into `false` in the second loop.\\n\\nSo now both flags are `false` and finish looping. \\n\\nWhat I\\'m trying to say is that \\n\\n---\\n\\nFinishing loop is not always true case. \\n\\n---\\n\\n\\nThat\\'s why I check `both flags` with `or`.\\n\\nBe careful.\\n\\nLet\\'s see a real algorithm!\\n\\nAlgorithm Overview:\\n1. Initialize variables `is_inc` and `is_dec` to `True` to track whether the sequence is increasing or decreasing.\\n2. Iterate through the input list `nums` starting from the second element.\\n3. Update `is_inc` to `False` if the current element is less than the previous element.\\n4. Update `is_dec` to `False` if the current element is greater than the previous element.\\n5. If both `is_inc` and `is_dec` are `False`, return `False` as the sequence is neither strictly increasing nor strictly decreasing.\\n6. Return `True` if either `is_inc` or `is_dec` is `True`, indicating that the sequence is either strictly increasing or strictly decreasing.\\n\\nDetailed Explanation:\\n1. Initialize variables `is_inc` and `is_dec` to `True` to indicate that the sequence is initially assumed to be both increasing and decreasing.\\n2. Iterate through the input list `nums` starting from the second element (index 1).\\n3. Check if the sequence is not both increasing and decreasing (i.e., both `is_inc` and `is_dec` are `False`). If so, return `False` since the sequence is neither strictly increasing nor strictly decreasing.\\n4. Check if the current element (`nums[i]`) is less than the previous element (`nums[i-1]`). If true, update `is_inc` to `False` since the sequence is no longer strictly increasing.\\n5. Check if the current element (`nums[i]`) is greater than the previous element (`nums[i-1]`). If true, update `is_dec` to `False` since the sequence is no longer strictly decreasing.\\n6. After iterating through the entire list, if either `is_inc` or `is_dec` is `True`, return `True` indicating that the sequence is either strictly increasing or strictly decreasing. If both are `False`, return `False`.\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n```python []\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        if n == 1: return True\\n\\n        is_inc = True\\n        is_dec = True\\n\\n        for i in range(1, n):\\n            if not is_inc and not is_dec:\\n                return False\\n\\n            if nums[i] < nums[i-1]:\\n                is_inc = False\\n            if nums[i] > nums[i-1]:\\n                is_dec = False\\n\\n        return is_inc or is_dec\\n```\\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar isMonotonic = function(nums) {\\n    const n = nums.length;\\n    if (n === 1) return true;\\n\\n    let isInc = true;\\n    let isDec = true;\\n\\n    for (let i = 1; i < n; i++) {\\n        if (!isInc && !isDec) {\\n            return false;\\n        }\\n\\n        if (nums[i] < nums[i - 1]) {\\n            isInc = false;\\n        }\\n        if (nums[i] > nums[i - 1]) {\\n            isDec = false;\\n        }\\n    }\\n\\n    return isInc || isDec;    \\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1) return true;\\n\\n        boolean isInc = true;\\n        boolean isDec = true;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (!isInc && !isDec) {\\n                return false;\\n            }\\n\\n            if (nums[i] < nums[i - 1]) {\\n                isInc = false;\\n            }\\n            if (nums[i] > nums[i - 1]) {\\n                isDec = false;\\n            }\\n        }\\n\\n        return isInc || isDec;        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) return true;\\n\\n        bool isInc = true;\\n        bool isDec = true;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (!isInc && !isDec) {\\n                return false;\\n            }\\n\\n            if (nums[i] < nums[i - 1]) {\\n                isInc = false;\\n            }\\n            if (nums[i] > nums[i - 1]) {\\n                isDec = false;\\n            }\\n        }\\n\\n        return isInc || isDec;        \\n    }\\n};\\n```\\n\\n\\n---\\n\\nThank you for reading my post.\\n\\u2B50\\uFE0F Please upvote it and don\\'t forget to subscribe to my channel!\\n\\nMy previous post for daily coding challenge\\nhttps://leetcode.com/problems/sort-array-by-parity/solutions/4098282/video-how-we-think-about-a-solution-one-pointer-python-javascript-java-c/",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        if n == 1: return True\\n        \\n        # check if this is increasing        \\n        for i in range(1, n):\\n            if nums[i] < nums[i-1]:\\n                break\\n            \\n            if i == n - 1:\\n                return True\\n\\n        # check if this is decreasing\\n        for i in range(1, n):\\n            if nums[i] > nums[i-1]:\\n                break\\n            \\n            if i == n - 1:\\n                return True\\n\\n        return False\\n```\n```\\nInput: nums = [1,2,2,3]\\n\\nis_inc = True\\nis_dec = True\\n```\n```\\nindex 0: 1\\nindex 1: 2\\n\\nis_inc = True\\nis_dec = False\\n```\n```\\nindex 1: 2\\nindex 2: 2\\n\\nis_inc = True\\nis_dec = False\\n```\n```\\nindex 2: 2\\nindex 3: 3\\n\\nis_inc = True\\nis_dec = False\\n```\n```python []\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        if n == 1: return True\\n\\n        is_inc = True\\n        is_dec = True\\n\\n        for i in range(1, n):\\n            if not is_inc and not is_dec:\\n                return False\\n\\n            if nums[i] < nums[i-1]:\\n                is_inc = False\\n            if nums[i] > nums[i-1]:\\n                is_dec = False\\n\\n        return is_inc or is_dec\\n```\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar isMonotonic = function(nums) {\\n    const n = nums.length;\\n    if (n === 1) return true;\\n\\n    let isInc = true;\\n    let isDec = true;\\n\\n    for (let i = 1; i < n; i++) {\\n        if (!isInc && !isDec) {\\n            return false;\\n        }\\n\\n        if (nums[i] < nums[i - 1]) {\\n            isInc = false;\\n        }\\n        if (nums[i] > nums[i - 1]) {\\n            isDec = false;\\n        }\\n    }\\n\\n    return isInc || isDec;    \\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1) return true;\\n\\n        boolean isInc = true;\\n        boolean isDec = true;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (!isInc && !isDec) {\\n                return false;\\n            }\\n\\n            if (nums[i] < nums[i - 1]) {\\n                isInc = false;\\n            }\\n            if (nums[i] > nums[i - 1]) {\\n                isDec = false;\\n            }\\n        }\\n\\n        return isInc || isDec;        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) return true;\\n\\n        bool isInc = true;\\n        bool isDec = true;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (!isInc && !isDec) {\\n                return false;\\n            }\\n\\n            if (nums[i] < nums[i - 1]) {\\n                isInc = false;\\n            }\\n            if (nums[i] > nums[i - 1]) {\\n                isDec = false;\\n            }\\n        }\\n\\n        return isInc || isDec;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4102860,
                "title": "93-24-one-pass-solution-commented-code",
                "content": "# Problem Description\\n\\nThe problem involves determining whether a given integer array, nums, is **monotonic**, meaning it is either non-decreasing or non-increasing.\\n\\nThe task is to **return** `true` if the array is monotonic, and `false` otherwise.\\n\\n**Monotonic array** is an array in which the elements are either entirely **non-increasing** (monotone decreasing) or entirely **non-decreasing** (monotone increasing). In other words, the elements in a monotonic array are in a consistently **increasing** or consistently **decreasing** order.\\n- **Monotone increasing**: `nums[i] <= nums[j]` for all `i <= j`.\\n- **Monotone decreasing**: `nums[i] >= nums[j]` for all `i <= j`.\\n\\n![image.png](https://assets.leetcode.com/users/images/3c360608-d0cb-4740-99f0-b8ffe7f99f46_1695946655.0437603.png)\\n\\n\\n---\\n\\n# Approach\\n1. Initialize two boolean variables: `isIncreasing` and `isDecreasing` to **true**.\\n2. Loop through the array:\\n    - Starting from the **second** element, compare each **element** with its **previous** element.\\n    - If an element is **less** than its previous element, set `isIncreasing` to **false** (indicating the array is **not increasing**).\\n    - If an element is **greater** than its previous element, set `isDecreasing` to **false** (indicating the array is **not decreasing**).\\n    - If both `isIncreasing` and `isDecreasing` are **false**, **break** the loop as the array is neither increasing nor decreasing and we don\\'t have to **continue** the loop.\\n3. Return if either `isIncreasing` or `isDecreasing` is **true** since the array is considered monotonic if **one** of them is **true** and non monotonic if both are **false**.\\n\\n\\n# Complexity\\n- **Time complexity:** $$O(N)$$\\nSince we are using one for loop then it is linear time which is `O(N)`.\\n- **Space complexity:** $$O(1)$$\\nSince we are using couple of constant variables then it is `O(1)`.\\n\\n---\\n\\n\\n\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool isIncreasing = true;  // Indicates if the array is increasing.\\n        bool isDecreasing = true;  // Indicates if the array is decreasing.\\n\\n        // Check if the array is either increasing or non-increasing.\\n        for (int i = 1; i < nums.size(); i++) {\\n            // Check increasing condition.\\n            if (nums[i] < nums[i - 1])\\n                isIncreasing = false;\\n                \\n            // Check decreasing condition.\\n            else if (nums[i] > nums[i - 1])\\n                isDecreasing = false;\\n\\n            // If it is neither increasing nor decreasing then don\\'t continue the loop\\n            if (!isIncreasing && !isDecreasing)\\n                break;\\n        }\\n\\n        return isIncreasing || isDecreasing;  // Return true if either condition is met.\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean isIncreasing = true;  // Indicates if the array is increasing\\n        boolean isDecreasing = true;  // Indicates if the array is decreasing\\n\\n        // Check if the array is either increasing or non-increasing\\n        for (int i = 1; i < nums.length; i++) {\\n            // Check increasing condition.\\n            if (nums[i] < nums[i - 1])\\n                isIncreasing = false;\\n\\n            // Check decreasing condition.\\n            else if (nums[i] > nums[i - 1])\\n                isDecreasing = false;\\n\\n            // If it is neither increasing nor decreasing then don\\'t continue the loop\\n            if (!isIncreasing && !isDecreasing)\\n                break;\\n        }\\n\\n        return isIncreasing || isDecreasing;  // Return true if either condition is met\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def isMonotonic(self, nums: list[int]) -> bool:\\n        is_increasing = True  # Indicates if the array is increasing.\\n        is_decreasing = True  # Indicates if the array is decreasing.\\n\\n        # Check if the array is either increasing or non-increasing.\\n        for i in range(1, len(nums)):\\n            # Check increasing condition.\\n            if nums[i] < nums[i - 1]:\\n                is_increasing = False\\n\\n            # Check decreasing condition.\\n            elif nums[i] > nums[i - 1]:\\n                is_decreasing = False\\n\\n            # If it is neither increasing nor decreasing then don\\'t continue the loop.\\n            if not is_increasing and not is_decreasing:\\n                break\\n\\n        return is_increasing or is_decreasing  # Return true if either condition is met.\\n```\\n\\n![leet_sol.jpg](https://assets.leetcode.com/users/images/ee804bfd-acfc-41bb-bc77-ec864144fe24_1695947355.9566755.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool isIncreasing = true;  // Indicates if the array is increasing.\\n        bool isDecreasing = true;  // Indicates if the array is decreasing.\\n\\n        // Check if the array is either increasing or non-increasing.\\n        for (int i = 1; i < nums.size(); i++) {\\n            // Check increasing condition.\\n            if (nums[i] < nums[i - 1])\\n                isIncreasing = false;\\n                \\n            // Check decreasing condition.\\n            else if (nums[i] > nums[i - 1])\\n                isDecreasing = false;\\n\\n            // If it is neither increasing nor decreasing then don\\'t continue the loop\\n            if (!isIncreasing && !isDecreasing)\\n                break;\\n        }\\n\\n        return isIncreasing || isDecreasing;  // Return true if either condition is met.\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean isIncreasing = true;  // Indicates if the array is increasing\\n        boolean isDecreasing = true;  // Indicates if the array is decreasing\\n\\n        // Check if the array is either increasing or non-increasing\\n        for (int i = 1; i < nums.length; i++) {\\n            // Check increasing condition.\\n            if (nums[i] < nums[i - 1])\\n                isIncreasing = false;\\n\\n            // Check decreasing condition.\\n            else if (nums[i] > nums[i - 1])\\n                isDecreasing = false;\\n\\n            // If it is neither increasing nor decreasing then don\\'t continue the loop\\n            if (!isIncreasing && !isDecreasing)\\n                break;\\n        }\\n\\n        return isIncreasing || isDecreasing;  // Return true if either condition is met\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def isMonotonic(self, nums: list[int]) -> bool:\\n        is_increasing = True  # Indicates if the array is increasing.\\n        is_decreasing = True  # Indicates if the array is decreasing.\\n\\n        # Check if the array is either increasing or non-increasing.\\n        for i in range(1, len(nums)):\\n            # Check increasing condition.\\n            if nums[i] < nums[i - 1]:\\n                is_increasing = False\\n\\n            # Check decreasing condition.\\n            elif nums[i] > nums[i - 1]:\\n                is_decreasing = False\\n\\n            # If it is neither increasing nor decreasing then don\\'t continue the loop.\\n            if not is_increasing and not is_decreasing:\\n                break\\n\\n        return is_increasing or is_decreasing  # Return true if either condition is met.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 501946,
                "title": "python-and-java-solution-beat-96-and-100",
                "content": "Since we only need to check if the array is either ascending or descending, we compare the first and last element value and reverse the list. As the result, we only need to do ascending check.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\nPython\\n```python\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        if A[-1] < A[0]: \\n            A = A[::-1]\\n        \\n        for i in range(1, len(A)):\\n            if A[i] < A[i-1]:\\n                return False\\n        return True\\n```\\n\\nJava\\n```java\\nclass Solution {\\n    public boolean isMonotonic(int[] arr) {\\n        if (arr[arr.length-1] < arr[0])\\n            reverse(arr);\\n        \\n        for (int i = 1; i < arr.length; i++) {\\n            if (arr[i] < arr[i-1]) \\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    private void reverse(int[] arr) {\\n        for (int i = 0; i < arr.length/2; i++) {\\n            int temp = arr[i];\\n            arr[i] = arr[arr.length - 1 - i];\\n            arr[arr.length - 1 - i] = temp;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        if A[-1] < A[0]: \\n            A = A[::-1]\\n        \\n        for i in range(1, len(A)):\\n            if A[i] < A[i-1]:\\n                return False\\n        return True\\n```\n```java\\nclass Solution {\\n    public boolean isMonotonic(int[] arr) {\\n        if (arr[arr.length-1] < arr[0])\\n            reverse(arr);\\n        \\n        for (int i = 1; i < arr.length; i++) {\\n            if (arr[i] < arr[i-1]) \\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    private void reverse(int[] arr) {\\n        for (int i = 0; i < arr.length/2; i++) {\\n            int temp = arr[i];\\n            arr[i] = arr[arr.length - 1 - i];\\n            arr[arr.length - 1 - i] = temp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2133433,
                "title": "c-one-liner-100-optimised-one-pass",
                "content": "```\\nbool isMonotonic(vector<int>& nums) {\\n       return is_sorted(nums.begin(),nums.end()) || is_sorted(nums.begin(),nums.end(),greater<int>());\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isMonotonic(vector<int>& nums) {\\n       return is_sorted(nums.begin(),nums.end()) || is_sorted(nums.begin(),nums.end(),greater<int>());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 512313,
                "title": "javascript-one-liner-solution",
                "content": "```javascript\\n/**\\n * @param {number[]} A\\n * @return {boolean}\\n */\\nvar isMonotonic = function(A) {\\n  return (\\n    A.every((v, i) => i === 0 || v <= A[i - 1]) ||\\n    A.every((v, i) => i === 0 || v >= A[i - 1])\\n  );\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} A\\n * @return {boolean}\\n */\\nvar isMonotonic = function(A) {\\n  return (\\n    A.every((v, i) => i === 0 || v <= A[i - 1]) ||\\n    A.every((v, i) => i === 0 || v >= A[i - 1])\\n  );\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4102978,
                "title": "easy-to-understand-beginner",
                "content": "# Intuition\\n- The problem asks whether a given array` nums` is monotonic. \\n- A monotonic array is one that is either entirely non-increasing or non-decreasing. \\n- In simpler terms, it means that the elements in the array are in a sorted order, either in ascending or descending order.\\n\\n# Approach\\n1. Initialize two boolean flags, `increasing` and `decreasing`, to true. These flags will help us track whether the array is `non-increasing` or `non-decreasing`, respectively.\\n\\n1. Iterate through the array `nums` starting from index 1 (comparing each element with the previous one).\\n\\n1. For each pair of adjacent elements, check whether `nums[i] `is greater than `nums[i - 1]`. If it is, set the `decreasing` flag to false because this indicates that the array is not `decreasing`.\\n\\n1. If `nums[i] `is less than `nums[i - 1]`, set the `increasing` flag to false because this indicates that the array is not `increasing`.\\n\\n1. Continue this process for the entire array.\\n\\n1. After the loop, check whether either increasing or decreasing is true. If either of them is true, it means that the array is monotonic (either non-increasing or non-decreasing), so return true. Otherwise, return false.\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nThe `time complexity of this approach is O(n)`, where n is the number of elements in the nums array. This is because we iterate through the array once, comparing each element with its previous element.\\n\\n- Space complexity:\\n- The `space complexity is O(1) `because we use a constant amount of extra space to store the boolean flags `increasing` and `decreasing`, regardless of the size of the input array.\\n\\n# PLEASE UPVOTE\\u2764\\uD83D\\uDE0D\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool increasing = true;\\n        bool decreasing = true;\\n\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                decreasing = false;\\n            } else if (nums[i] < nums[i - 1]) {\\n                increasing = false;\\n            }\\n        }\\n\\n        return increasing || decreasing;\\n    }\\n};\\n```\\n# JAVA\\n```\\npublic class Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean increasing = true;\\n        boolean decreasing = true;\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                decreasing = false;\\n            } else if (nums[i] < nums[i - 1]) {\\n                increasing = false;\\n            }\\n        }\\n\\n        return increasing || decreasing;\\n    }\\n}\\n\\n```\\n# PYTHON\\n```\\nclass Solution:\\n    def isMonotonic(self, nums):\\n        increasing = True\\n        decreasing = True\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i - 1]:\\n                decreasing = False\\n            elif nums[i] < nums[i - 1]:\\n                increasing = False\\n\\n        return increasing or decreasing\\n\\n```\\n# JAVASCRIPT\\n```\\nvar isMonotonic = function(nums) {\\n    let increasing = true;\\n    let decreasing = true;\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] > nums[i - 1]) {\\n            decreasing = false;\\n        } else if (nums[i] < nums[i - 1]) {\\n            increasing = false;\\n        }\\n    }\\n\\n    return increasing || decreasing;\\n};\\n\\n```\\n# PLEASE UPVOTE\\u2764\\uD83D\\uDE0D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool increasing = true;\\n        bool decreasing = true;\\n\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                decreasing = false;\\n            } else if (nums[i] < nums[i - 1]) {\\n                increasing = false;\\n            }\\n        }\\n\\n        return increasing || decreasing;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean increasing = true;\\n        boolean decreasing = true;\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                decreasing = false;\\n            } else if (nums[i] < nums[i - 1]) {\\n                increasing = false;\\n            }\\n        }\\n\\n        return increasing || decreasing;\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def isMonotonic(self, nums):\\n        increasing = True\\n        decreasing = True\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i - 1]:\\n                decreasing = False\\n            elif nums[i] < nums[i - 1]:\\n                increasing = False\\n\\n        return increasing or decreasing\\n\\n```\n```\\nvar isMonotonic = function(nums) {\\n    let increasing = true;\\n    let decreasing = true;\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        if (nums[i] > nums[i - 1]) {\\n            decreasing = false;\\n        } else if (nums[i] < nums[i - 1]) {\\n            increasing = false;\\n        }\\n    }\\n\\n    return increasing || decreasing;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153557,
                "title": "java-6-lines-easy-solution",
                "content": "```\\n    public boolean isMonotonic(int[] A) {\\n     boolean increasing = false, decreasing = false;\\n     for(int i = 1; i< A.length; i++){\\n         if(A[i] < A[i-1]) decreasing = true;\\n         if(A[i] > A[i-1]) increasing = true;\\n     }\\n     return increasing && decreasing ? false: true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public boolean isMonotonic(int[] A) {\\n     boolean increasing = false, decreasing = false;\\n     for(int i = 1; i< A.length; i++){\\n         if(A[i] < A[i-1]) decreasing = true;\\n         if(A[i] > A[i-1]) increasing = true;\\n     }\\n     return increasing && decreasing ? false: true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4103805,
                "title": "99-82-simple-solution-c-java-python-javascript",
                "content": "\\u270599.82% Simple Solution  || C++ | Java || Python || JavaScript \\uD83D\\uDCAF\\uD83D\\uDD25\\n\\n# Read Article for Explaination and code :https://www.nileshblog.tech/leetcode-896-monotonic-array/\\n\\n\\n[c++ \\n](https://www.nileshblog.tech/leetcode-896-monotonic-array/#C_Leetcode_898_Monotonic_Array)\\n[Python](https://www.nileshblog.tech/leetcode-896-monotonic-array/#Python_Leetcode_898_Monotonic_Array )\\n\\n[Javascript \\n](https://www.nileshblog.tech/leetcode-896-monotonic-array/#JavaScript_Leetcode_898_Monotonic_Array)\\n[Java](https://www.nileshblog.tech/leetcode-896-monotonic-array/#C_Leetcode_898_Monotonic_Array)\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/6381729e-7a65-4020-a498-3079f6ed1095_1695966928.5496523.png)\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/22236aff-2a54-4df6-9c91-8dd14a3da698_1695967237.2066336.png)\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "\\u270599.82% Simple Solution  || C++ | Java || Python || JavaScript \\uD83D\\uDCAF\\uD83D\\uDD25\\n\\n# Read Article for Explaination and code :https://www.nileshblog.tech/leetcode-896-monotonic-array/\\n\\n\\n[c++ \\n](https://www.nileshblog.tech/leetcode-896-monotonic-array/#C_Leetcode_898_Monotonic_Array)\\n[Python](https://www.nileshblog.tech/leetcode-896-monotonic-array/#Python_Leetcode_898_Monotonic_Array )\\n\\n[Javascript \\n](https://www.nileshblog.tech/leetcode-896-monotonic-array/#JavaScript_Leetcode_898_Monotonic_Array)\\n[Java](https://www.nileshblog.tech/leetcode-896-monotonic-array/#C_Leetcode_898_Monotonic_Array)\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/6381729e-7a65-4020-a498-3079f6ed1095_1695966928.5496523.png)\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/22236aff-2a54-4df6-9c91-8dd14a3da698_1695967237.2066336.png)\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1860864,
                "title": "beginner-friendly-solution-cpp-easy-to-understand",
                "content": "```\\nPls upvote if it  is helpful\\n\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        \\n        int n = nums.size() ;\\n        int count = 1 ,flag = 1;\\n        \\n        for (int i=1; i<n; i++)\\n        {\\n            if (nums[i-1]<=nums[i])\\n            {\\n                count++ ;\\n            }\\n        }\\n        \\n        for (int i=1; i<n; i++)\\n        {\\n            if (nums[i-1]>=nums[i])\\n            {\\n                flag++ ;\\n            }\\n        }\\n        \\n        \\n        if (count==n || flag==n)\\n            return true ;\\n        else \\n            return false ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nPls upvote if it  is helpful\\n\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        \\n        int n = nums.size() ;\\n        int count = 1 ,flag = 1;\\n        \\n        for (int i=1; i<n; i++)\\n        {\\n            if (nums[i-1]<=nums[i])\\n            {\\n                count++ ;\\n            }\\n        }\\n        \\n        for (int i=1; i<n; i++)\\n        {\\n            if (nums[i-1]>=nums[i])\\n            {\\n                flag++ ;\\n            }\\n        }\\n        \\n        \\n        if (count==n || flag==n)\\n            return true ;\\n        else \\n            return false ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618159,
                "title": "python-3-2-lines-using-generator",
                "content": "```python3 []\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        pattern = nums[len(nums) - 1] > nums[0]\\n        return all((nums[i] > nums[i-1]) == pattern or nums[i] == nums[i-1] for i in range(1, len(nums)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        pattern = nums[len(nums) - 1] > nums[0]\\n        return all((nums[i] > nums[i-1]) == pattern or nums[i] == nums[i-1] for i in range(1, len(nums)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 730460,
                "title": "simple-python3",
                "content": "```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        \\n        increase = True\\n        decrease = True\\n        \\n        for i in range(len(A)-1):\\n            \\n            if A[i] > A[i+1]:\\n                increase = False\\n                \\n            if A[i] < A[i+1]:\\n                decrease = False\\n                \\n        return increase or decrease\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        \\n        increase = True\\n        decrease = True\\n        \\n        for i in range(len(A)-1):\\n            \\n            if A[i] > A[i+1]:\\n                increase = False\\n                \\n            if A[i] < A[i+1]:\\n                decrease = False\\n                \\n        return increase or decrease\\n```",
                "codeTag": "Java"
            },
            {
                "id": 168322,
                "title": "simple-javascript-100-solution",
                "content": "```\\nvar isMonotonic = function(A) {\\n    let arrLength = A.length;\\n    \\n    let isIncreasing = false;\\n    let isDecreasing = false;\\n    \\n    for(let i = 1; i <arrLength; i++){\\n        if(isIncreasing && isDecreasing){\\n            return false;\\n        }\\n        \\n        if(A[i] > A[i-1]){\\n            isIncreasing = true;\\n        } else if(A[i] < A[i-1]){\\n            isDecreasing = true;\\n        }\\n    }\\n    \\n    return !(isIncreasing && isDecreasing);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isMonotonic = function(A) {\\n    let arrLength = A.length;\\n    \\n    let isIncreasing = false;\\n    let isDecreasing = false;\\n    \\n    for(let i = 1; i <arrLength; i++){\\n        if(isIncreasing && isDecreasing){\\n            return false;\\n        }\\n        \\n        if(A[i] > A[i-1]){\\n            isIncreasing = true;\\n        } else if(A[i] < A[i-1]){\\n            isDecreasing = true;\\n        }\\n    }\\n    \\n    return !(isIncreasing && isDecreasing);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 207057,
                "title": "4-lines-beats-99",
                "content": "```\\n    public boolean isMonotonic(int[] A) {\\n        int direction = (A[0] <= A[A.length - 1]) ? -1 : 1;\\n        for(int i = 0 ; i < A.length-1 ; i++)\\n            if ((A[i] - A[i + 1]) * direction < 0) return false;\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isMonotonic(int[] A) {\\n        int direction = (A[0] <= A[A.length - 1]) ? -1 : 1;\\n        for(int i = 0 ; i < A.length-1 ; i++)\\n            if ((A[i] - A[i + 1]) * direction < 0) return false;\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 165899,
                "title": "a-few-solutions",
                "content": "Return `true` if-and-only-if the input array `A` is *sorted* in **non-increasing** *inclusive-or* **non-decreasing** order.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    var isSorted = { A: IntArray -> A.withIndex().all{ (i, _) -> (0 < i && A[i - 1] <= A[i]) || (i == 0) } }\\n    var isMonotonic = { A: IntArray -> isSorted(A) || isSorted(A.reversed().toIntArray()) }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet isMonotonic = (A, isSorted = A => A.every((_, i) => 0 < i && A[i - 1] <= A[i] || !i)) => isSorted(A) || isSorted(A.reverse());\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    isSorted = lambda self, A: all(A[i - 1] <= A[i] for i in range(1, len(A)))\\n    isMonotonic = lambda self, A: self.isSorted(A) or self.isSorted(A[::-1])\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn is_monotonic(A: VI) -> bool {\\n        let is_sorted = (|A: &VI| A.iter().enumerate().all(|(i, _)| (0 < i && A[i - 1] <= A[i]) || (i == 0)));\\n        is_sorted(&A) || is_sorted(&A.into_iter().rev().collect::<VI>())\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    bool isMonotonic(VI& A) { return is_sorted(A.begin(), A.end()) || is_sorted(A.rbegin(), A.rend()); }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var isSorted = { A: IntArray -> A.withIndex().all{ (i, _) -> (0 < i && A[i - 1] <= A[i]) || (i == 0) } }\\n    var isMonotonic = { A: IntArray -> isSorted(A) || isSorted(A.reversed().toIntArray()) }\\n}\\n```\n```\\nlet isMonotonic = (A, isSorted = A => A.every((_, i) => 0 < i && A[i - 1] <= A[i] || !i)) => isSorted(A) || isSorted(A.reverse());\\n```\n```\\nclass Solution:\\n    isSorted = lambda self, A: all(A[i - 1] <= A[i] for i in range(1, len(A)))\\n    isMonotonic = lambda self, A: self.isSorted(A) or self.isSorted(A[::-1])\\n```\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn is_monotonic(A: VI) -> bool {\\n        let is_sorted = (|A: &VI| A.iter().enumerate().all(|(i, _)| (0 < i && A[i - 1] <= A[i]) || (i == 0)));\\n        is_sorted(&A) || is_sorted(&A.into_iter().rev().collect::<VI>())\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    bool isMonotonic(VI& A) { return is_sorted(A.begin(), A.end()) || is_sorted(A.rbegin(), A.rend()); }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4103376,
                "title": "c-one-loop-one-direction-indicator-approach-animation",
                "content": "# Intuition\\n![ezgif.com-video-to-gif (9).gif](https://assets.leetcode.com/users/images/ba3049dd-5d24-4e5e-8177-e6bb8ff93da7_1695965252.3622503.gif)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initializes a variable named **direction** to 0, which represents the direction of monotonicity. A positive value indicates non-decreasing order, a negative value indicates non-increasing order, and 0 indicates that the direction has not been determined yet.\\n\\n1. Enters a loop that iterates over the elements of the vector starting from the second element (i = 1).\\n\\n    Inside the loop, the function checks for violations of monotonicity based on the current direction.\\n\\n    1. If the direction is greater than 0 (indicating non-decreasing order) and the current element nums[i] is less than the previous element nums[i-1], it means the vector is not monotonic. In this case, the function immediately returns **false**.\\n\\n    1. If the direction is less than 0 (indicating non-increasing order) and the current element nums[i] is greater than the previous element nums[i-1], it means the vector is not monotonic. In this case, the function immediately returns **false**.\\n\\n    1. If neither of the above conditions is met, it means the vector is still potentially monotonic. The function then checks if the direction is still 0 (indicating that the direction has not been determined yet). The direction of monotonicity is determine by calculating the difference between the current element nums[i] and the previous element nums[i-1]. This difference is then assigned to direction.\\n\\n    The loop continues until all elements of the vector have been checked.\\n\\n1. After the loop, if no violations of monotonicity have been found, the function returns **true**, indicating that the vector is monotonic.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int direction = 0;\\n        for(int i = 1; i < nums.size(); i++){\\n            if(direction > 0 && nums[i] < nums[i-1]) return false;\\n            if(direction < 0 && nums[i] > nums[i-1]) return false;\\n            if(direction == 0) direction = nums[i] - nums[i-1];\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\nhttps://youtu.be/P44t-myQXtM",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int direction = 0;\\n        for(int i = 1; i < nums.size(); i++){\\n            if(direction > 0 && nums[i] < nums[i-1]) return false;\\n            if(direction < 0 && nums[i] > nums[i-1]) return false;\\n            if(direction == 0) direction = nums[i] - nums[i-1];\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973744,
                "title": "clean-python-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n       inc = True\\n       dec = True\\n       for i in range(1,len(nums)):\\n           inc = inc and nums[i-1] >= nums[i]\\n           dec = dec and nums[i-1] <= nums[i]\\n       return inc or dec\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n       inc = True\\n       dec = True\\n       for i in range(1,len(nums)):\\n           inc = inc and nums[i-1] >= nums[i]\\n           dec = dec and nums[i-1] <= nums[i]\\n       return inc or dec\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165865,
                "title": "java-straightforward-o-n-solution",
                "content": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] A) {\\n        if(A == null || A.length <= 1) return true;\\n        int[] dir = new int[2]; // inc, dec\\n        for(int i=1;i<A.length;i++){\\n            if(A[i] == A[i-1]) continue;\\n            if(A[i] > A[i-1]) dir[0] = 1;\\n            if(A[i] < A[i-1]) dir[1] = 1;\\n            if(dir[0] == 1 && dir[1] == 1) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] A) {\\n        if(A == null || A.length <= 1) return true;\\n        int[] dir = new int[2]; // inc, dec\\n        for(int i=1;i<A.length;i++){\\n            if(A[i] == A[i-1]) continue;\\n            if(A[i] > A[i-1]) dir[0] = 1;\\n            if(A[i] < A[i-1]) dir[1] = 1;\\n            if(dir[0] == 1 && dir[1] == 1) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4103581,
                "title": "how-to-check-if-an-array-is-monotonic-a-simple-and-efficient-approach-in-c",
                "content": "# Intuition\\nBasically The goal is to determine whether the given array is monotonic,which means it is either entirely non-decreasing or non-increasing. A key observation is that if the array is both increasing and decreasing at any point, it cannot be monotonic.\\n\\n# Approach\\nI\\'ll iterate through the array once, comparing each element with its previous one. While iterating, I\\'ll maintain two boolean variables, increasing and decreasing, to track whether the array is currently considered non-decreasing or non-increasing.\\n\\n1.If nums[i] > nums[i - 1], I\\'ll set decreasing to false because it\\'s not decreasing.\\n2.If nums[i] < nums[i - 1], I\\'ll set increasing to false because it\\'s not increasing.\\n3.If at any point both increasing and decreasing are false, I\\'ll return false since the array is not monotonic.\\n4.After the loop, if either increasing or decreasing (or both) is still true, it means the array is monotonic.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the size of the array, as we iterate through the array once.\\n\\n- Space complexity: O(1), as we use only a constant amount of extra space(two boolean variables).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool increasing = true;\\n        bool decreasing = true;\\n\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                decreasing = false;\\n            } else if (nums[i] < nums[i - 1]) {\\n                increasing = false;\\n            }\\n\\n            // If neither increasing not decreasing, array is not monotonic.\\n            if (!increasing && !decreasing) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool increasing = true;\\n        bool decreasing = true;\\n\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                decreasing = false;\\n            } else if (nums[i] < nums[i - 1]) {\\n                increasing = false;\\n            }\\n\\n            // If neither increasing not decreasing, array is not monotonic.\\n            if (!increasing && !decreasing) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4103134,
                "title": "java-easy-to-understand-two-approaches-single-pass-time-o-n-space-o-1-beats-100",
                "content": "# Approach 1 (Fastest)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can follow a straightforward approach: starting from the first element, we compare adjacent elements to check if they satisfy the required monotonic condition. If the array starts with a smaller element than the last one, we traverse the array to ensure it\\'s monotonically increasing. Otherwise, if it starts with a larger element, we traverse to check for a monotonically decreasing condition.\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        if (nums[0] < nums[nums.length-1]) {\\n            for (int i = 1; i < nums.length; i++) {\\n                if (nums[i] < nums[i-1]) {\\n                    return false;\\n                }\\n            }\\n        } else {\\n            for (int i = 1; i < nums.length; i++) {\\n                if (nums[i] > nums[i-1]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n# Approach 2 (Beats 60%)\\n<!-- Describe your approach to solving the problem. -->\\nTo check if an array is monotonic, we can use bitwise operations to compare adjacent elements. We maintain two boolean flags, increase and decrease, initially set to true. As we iterate through the array, we update these flags based on the monotonic conditions. If both flags remain true after traversing the entire array, it\\'s monotonic.\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean increase = true, decrease = true;\\n        for (int i = 1; i < nums.length; ++i) {\\n            increase = increase &&(nums[i - 1] <= nums[i]);\\n            decrease = decrease &&(nums[i - 1] >= nums[i]);\\n        }\\n        return increase || decrease;\\n    }\\n}\\n```\\n\\n# Complexity\\nFor both approaches:\\n- Time complexity: `O(n)`, where `n` is the length of the input array nums. In both approaches, we perform a single pass through the array, comparing adjacent elements or using bitwise operations.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`, as we use only a constant amount of extra space for storing boolean flags.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Remember to subscribe to my YouTube Channel:\\n\\n[https://youtu.be/iJSd5_WS24E]()\\n# Note \\n- In an interview setting, where code clarity, efficiency, and simplicity are crucial, Approach 2 has an advantage in terms of efficiency and simplicity. It avoids multiple conditional checks and reduces the code complexity, making it a more elegant solution.\\n- It  employs bitwise operations for checking monotonicity, is the preferred choice for interviews, as it not only provides a correct solution but also highlights the candidate\\'s coding skills and optimization techniques.",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        if (nums[0] < nums[nums.length-1]) {\\n            for (int i = 1; i < nums.length; i++) {\\n                if (nums[i] < nums[i-1]) {\\n                    return false;\\n                }\\n            }\\n        } else {\\n            for (int i = 1; i < nums.length; i++) {\\n                if (nums[i] > nums[i-1]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean increase = true, decrease = true;\\n        for (int i = 1; i < nums.length; ++i) {\\n            increase = increase &&(nums[i - 1] <= nums[i]);\\n            decrease = decrease &&(nums[i - 1] >= nums[i]);\\n        }\\n        return increase || decrease;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960328,
                "title": "java-simple-solution-runtime-1ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) \\n    {\\n\\n         int i = 0;\\n\\n        while (i < nums.length - 2  && nums[i] == nums[i+1])\\n            i++;\\n\\n        Boolean cond = (i <= nums.length - 2 && nums[i] <= nums[i + 1] ) ? true : false;\\n\\n        for ( i = 0; i < nums.length - 1 ; i++)\\n        {\\n            if (cond)\\n            {\\n                if ( !(nums[i] <= nums[i+1] ) )\\n                    return false;\\n\\n            }else {\\n                if (!(nums[i] >= nums[i+1]))\\n                    return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```\\n\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/7dc2a05e-73f1-45bf-aaa4-32253a407be2_1693000930.543635.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) \\n    {\\n\\n         int i = 0;\\n\\n        while (i < nums.length - 2  && nums[i] == nums[i+1])\\n            i++;\\n\\n        Boolean cond = (i <= nums.length - 2 && nums[i] <= nums[i + 1] ) ? true : false;\\n\\n        for ( i = 0; i < nums.length - 1 ; i++)\\n        {\\n            if (cond)\\n            {\\n                if ( !(nums[i] <= nums[i+1] ) )\\n                    return false;\\n\\n            }else {\\n                if (!(nums[i] >= nums[i+1]))\\n                    return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549682,
                "title": "easy-java-solution-step-by-step-explanation",
                "content": "# Approach\\nThis code is for a method called `isMonotonic` that checks whether an array of integers `nums` is monotonic. A monotonic array is one that is either entirely non-increasing or non-decreasing. Let\\'s break down the code step by step:\\n\\n1. Initialize two boolean variables `increasing` and `decreasing` to false. These variables will be used to track whether the array is increasing or decreasing.\\n\\n2. Start a loop that iterates over the elements of the array `nums`, starting from the second element (`i = 1`) and comparing it with the previous element.\\n\\n3. Inside the loop, check if the current element `nums[i]` is greater than the previous element `nums[i-1]`. If it is, it means the array is increasing at this point.\\n\\n4. If the current element is not greater than the previous element, check if it is less than the previous element. If it is, it means the array is decreasing at this point.\\n\\n5. After examining all the elements in the array, the boolean variables `increasing` and `decreasing` will indicate whether the array is increasing, decreasing, or neither.\\n\\n6. Calculate the final result by checking if both `increasing` and `decreasing` are true. If they are, it means the array has both increasing and decreasing elements, which makes it not monotonic. In this case, assign `false` to the `result` variable. Otherwise, assign `true` to `result`.\\n\\n7. Return the `result` variable, which indicates whether the array `nums` is monotonic or not.\\n\\nIn summary, the code checks each pair of adjacent elements in the array to determine whether the array is increasing or decreasing at any point. If there are elements that cause the array to both increase and decrease, the array is not monotonic. Otherwise, the array is monotonic.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean increasing = false, decreasing = false;\\n        for (int i=1; i< nums.length; i++){\\n            if (nums[i]>nums[i-1]){\\n                increasing=true;\\n            } else if (nums[i]<nums[i-1]) {\\n                decreasing=true;\\n            }\\n        }\\n        boolean result = (increasing && decreasing) ? false:true;\\n        return result;\\n    }\\n}\\n```\\n**Please upvote if you like the solution.\\nHappy Coding!** \\uD83D\\uDE0A\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean increasing = false, decreasing = false;\\n        for (int i=1; i< nums.length; i++){\\n            if (nums[i]>nums[i-1]){\\n                increasing=true;\\n            } else if (nums[i]<nums[i-1]) {\\n                decreasing=true;\\n            }\\n        }\\n        boolean result = (increasing && decreasing) ? false:true;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135435,
                "title": "simple-c-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUSED VERY SIMPLE APPROACH .\\ncount1 stores if all elements are in increasing order whereas count2 stores all elemnet in decreasing order.\\nif either count1 or count2 equals to size of vector -1 then it is monotonically increasing.\\n\\nHope You Understood.\\n\\nDo{\\n   Please Upvote !!\\n}\\nwhile(you Like the solution);\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTIME COMPLEXITY O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int count1=0,count2=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]<=nums[i+1])count1++;\\n            if(nums[i]>=nums[i+1])count2++;}\\n        if(count1==nums.size()-1 || count2==nums.size()-1)return true;\\n        else return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int count1=0,count2=0;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]<=nums[i+1])count1++;\\n            if(nums[i]>=nums[i+1])count2++;}\\n        if(count1==nums.size()-1 || count2==nums.size()-1)return true;\\n        else return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095918,
                "title": "1ms-100-java-enough-fast-solution-2023",
                "content": "\\t* class Solution {\\n\\t\\t public boolean isMonotonic(int[] nums) {\\n\\t\\t\\tif (nums.length > 2) {\\n\\t\\t\\t\\tif (nums[0] > nums[nums.length - 1]) {\\n\\t\\t\\t\\t\\treturn decreasing(nums);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn increasing(nums);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tboolean increasing(int[] nums) {\\n\\t\\t\\tint i = 1;\\n\\t\\t\\twhile (nums.length > i) {\\n\\t\\t\\t\\tif (nums[i] < nums[i - 1]) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tboolean decreasing(int[] nums) {\\n\\t\\t\\tint i = 1;\\n\\t\\t\\twhile (nums.length > i) {\\n\\t\\t\\t\\tif (nums[i] > nums[i -1]) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n\\t\\t public boolean isMonotonic(int[] nums) {\\n\\t\\t\\tif (nums.length > 2) {\\n\\t\\t\\t\\tif (nums[0] > nums[nums.length - 1]) {\\n\\t\\t\\t\\t\\treturn decreasing(nums);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3530343,
                "title": "java-xor-monotonic-array",
                "content": "\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int i = 1;\\n        int diff = 0;\\n        while (i < nums.length && nums[0] == nums[i])\\n            i++;\\n        if (i < nums.length) diff = nums[0] - nums[i];\\n        while (i < nums.length) {\\n            if (nums[i - 1] != nums[i] && ((nums[i - 1] - nums[i]) <= 0 ^ diff < 0))\\n                return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int i = 1;\\n        int diff = 0;\\n        while (i < nums.length && nums[0] == nums[i])\\n            i++;\\n        if (i < nums.length) diff = nums[0] - nums[i];\\n        while (i < nums.length) {\\n            if (nums[i - 1] != nums[i] && ((nums[i - 1] - nums[i]) <= 0 ^ diff < 0))\\n                return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465941,
                "title": "python-c-java-beginner-level-as-simple-as-u-think-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q896. Monotonic Array***\\nAn array is monotonic if it is either monotone increasing or monotone decreasing.\\n\\nAn array `nums` is monotone increasing if for all` i <= j, nums[i] <= nums[j]`. An array nums is monotone decreasing if for all `i <= j, nums[i] >= nums[j]`.\\n\\nGiven an integer array `nums`, return `true` if the given array is monotonic, or `false` otherwise.\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        inc = True\\n        dec = True\\n        for i in range(len(A)-1):\\n            if A[i] > A[i+1]:\\n                inc = False\\n                \\n            if A[i] < A[i+1]:\\n                dec = False\\n                \\n        return inc or dec\\n        \\n```\\n**Runtime:**  1099 ms\\t\\n**Memory Usage:**  23.9 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n       boolean inc=true,dec=true;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if (nums[i]>nums[i+1])\\n                inc=false;\\n            \\n            if(nums[i]<nums[i+1])\\n                dec =false;\\n            if(inc==false && dec==false) return false;   \\n        }\\n        return true;  \\n    }\\n}\\n```\\n**Runtime:**  3 ms\\t\\t\\n**Memory Usage:**  92.8 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n     bool inc=true,dec=true;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if (nums[i]>nums[i+1])\\n                inc=false;\\n            \\n            if(nums[i]<nums[i+1])\\n                dec =false;\\n            if(inc==false && dec==false) return false;   \\n        }\\n        return true;\\n        \\n    }\\n};\\n```\\n**Runtime:** 156 ms\\t\\n**Memory Usage:**  96.5 MB\\t\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        inc = True\\n        dec = True\\n        for i in range(len(A)-1):\\n            if A[i] > A[i+1]:\\n                inc = False\\n                \\n            if A[i] < A[i+1]:\\n                dec = False\\n                \\n        return inc or dec\\n        \\n```\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n       boolean inc=true,dec=true;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if (nums[i]>nums[i+1])\\n                inc=false;\\n            \\n            if(nums[i]<nums[i+1])\\n                dec =false;\\n            if(inc==false && dec==false) return false;   \\n        }\\n        return true;  \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n     bool inc=true,dec=true;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if (nums[i]>nums[i+1])\\n                inc=false;\\n            \\n            if(nums[i]<nums[i+1])\\n                dec =false;\\n            if(inc==false && dec==false) return false;   \\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165866,
                "title": "java-1-pass-7-lines-straight-forward-code",
                "content": "1. Loop through A, only consider those non-equal neighbors (strictly bigger or smaller relations), and count them. \\n2. When count >= 2, check if the bigger (smaller) relation changes; if yes, return false; otherwise, continue.\\n3. return true if no false encounterd.\\n\\n```\\n    public boolean isMonotonic(int[] A) {\\n        boolean smaller = false;\\n        for (int i = 0, count = 0; i < A.length - 1; ++i) {\\n            if (A[i] == A[i + 1]) { continue; } // ignore those equal ones.\\n            if (++count >= 2 && smaller != (A[i] < A[i + 1])) { return false; }\\n            smaller = (A[i] < A[i + 1]); \\n        }\\n        return true;\\n    }\\n``",
                "solutionTags": [],
                "code": "1. Loop through A, only consider those non-equal neighbors (strictly bigger or smaller relations), and count them. \\n2. When count >= 2, check if the bigger (smaller) relation changes; if yes, return false; otherwise, continue.\\n3. return true if no false encounterd.\\n\\n```\\n    public boolean isMonotonic(int[] A) {\\n        boolean smaller = false;\\n        for (int i = 0, count = 0; i < A.length - 1; ++i) {\\n            if (A[i] == A[i + 1]) { continue; } // ignore those equal ones.\\n            if (++count >= 2 && smaller != (A[i] < A[i + 1])) { return false; }\\n            smaller = (A[i] < A[i + 1]); \\n        }\\n        return true;\\n    }\\n``",
                "codeTag": "Unknown"
            },
            {
                "id": 4103731,
                "title": "easisiet-c-solution-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool isMonotonic=0;\\n        int f=0;\\n\\n        for(int i=1;i<nums.size();i++){    //for monotonic increasing\\n            if(nums[i]<nums[i-1]){        //if curr value is less than previous value\\n                f=1;\\n                break;\\n            }\\n        }\\n\\n        if(f==0)\\n        return 1;\\n\\n        f=0;\\n\\n        for(int i=1;i<nums.size();i++){   //for monotonic decreasing\\n            if(nums[i]>nums[i-1]){        //if curr value is greater than previous value\\n                f=1;\\n                return 0;\\n            }\\n        }\\n\\n        return 1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool isMonotonic=0;\\n        int f=0;\\n\\n        for(int i=1;i<nums.size();i++){    //for monotonic increasing\\n            if(nums[i]<nums[i-1]){        //if curr value is less than previous value\\n                f=1;\\n                break;\\n            }\\n        }\\n\\n        if(f==0)\\n        return 1;\\n\\n        f=0;\\n\\n        for(int i=1;i<nums.size();i++){   //for monotonic decreasing\\n            if(nums[i]>nums[i-1]){        //if curr value is greater than previous value\\n                f=1;\\n                return 0;\\n            }\\n        }\\n\\n        return 1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4102839,
                "title": "easy-loop-vs-c-adjacent-difference-count-if-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraverse once and compute `d=nums[i+1]-nums[i]`. Initialize boolean variables `greate=false, less=false`.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif `d>0` set `greater=true` else if `d<0` set `less=true`.\\nif both of `greater` & `less` are set, return false, because there are some i, j such that `nums[i+1]-nums[i]` & `nums[j+1]-nums[j]` have the different signs.\\n\\nWhen the loop is through, return true.\\n\\n2nd approach uses C++ adjacent_difference. So it is a 2 pass solution!\\n\\n3rd aproach uses C++ adjacent_difference & count_if which might overkill!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```python []\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        greater, less=False, False\\n        n=len(nums)\\n        for i in range(n-1):\\n            d=nums[i+1]-nums[i]\\n            if d>0: greater=True\\n            elif d<0: less=True\\n            if greater and less: return False\\n        return True\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool greater=0, less=0;\\n        int n=nums.size();\\n        for(int i=0; i<n-1; i++){\\n            int d=nums[i+1]-nums[i];\\n            if (d>0) greater=1;\\n            else if (d<0) less=1;\\n            if (greater && less) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```\\n```C []\\nbool isMonotonic(int* nums, int numsSize){\\n    bool greater=0, less=0;\\n    for(register int i=0; i<numsSize-1; i++){\\n        int d=nums[i+1]-nums[i];\\n        if (d>0) greater=1;\\n        else if (d<0) less=1;\\n        if (greater && less) return 0;\\n    }\\n    return 1;\\n}\\n```\\n```Java []\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean greater=false, less=false;\\n        int n=nums.length;\\n        for(int i=0; i<n-1; i++){\\n            int d=nums[i+1]-nums[i];\\n            if (d>0) greater=true;\\n            else if (d<0) less=true;\\n            if (greater && less) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n```C# []\\npublic class Solution {\\n    public bool IsMonotonic(int[] nums) {\\n        bool greater=false, less=false;\\n        int n=nums.Length;\\n        for(int i=0; i<n-1; i++){\\n            int d=nums[i+1]-nums[i];\\n            if (d>0) greater=true;\\n            else if (d<0) less=true;\\n            if (greater && less) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n# Code using C++ adjacent_difference Runtime 61 ms Beats 100%\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        //C++ adjacent_difference\\n        //nums[i]=nums[i]-nums[i-1] for i>0 nums[0]=nums[0]\\n        adjacent_difference(nums.begin(), nums.end(), nums.begin());\\n        nums[0]=0;//Modify nums[0]=0\\n\\n        bool greater=0, less=0;\\n        #pragma unroll\\n        for(int d: nums){\\n            if (d>0) greater=1;\\n            else if (d<0) less=1;\\n            if (greater && less) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```\\n# Code using adjacent_difference & count_if Runtime 88 ms Beats 99.18%\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        //C++ adjacent_difference\\n        //nums[i]=nums[i]-nums[i-1] for i>0 nums[0]=nums[0]\\n        adjacent_difference(nums.begin(), nums.end(), nums.begin());\\n        nums[0]=0;//Modify nums[0]=0\\n\\n        int greater0=count_if(nums.begin(), nums.end(), [](int x){return x>0;});\\n        int less0=count_if(nums.begin(), nums.end(), [](int x){return x<0;});\\n\\n        return (greater0>0&& less0>0)?0:1;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "C#",
                    "Array"
                ],
                "code": "```python []\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        greater, less=False, False\\n        n=len(nums)\\n        for i in range(n-1):\\n            d=nums[i+1]-nums[i]\\n            if d>0: greater=True\\n            elif d<0: less=True\\n            if greater and less: return False\\n        return True\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool greater=0, less=0;\\n        int n=nums.size();\\n        for(int i=0; i<n-1; i++){\\n            int d=nums[i+1]-nums[i];\\n            if (d>0) greater=1;\\n            else if (d<0) less=1;\\n            if (greater && less) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```\n```C []\\nbool isMonotonic(int* nums, int numsSize){\\n    bool greater=0, less=0;\\n    for(register int i=0; i<numsSize-1; i++){\\n        int d=nums[i+1]-nums[i];\\n        if (d>0) greater=1;\\n        else if (d<0) less=1;\\n        if (greater && less) return 0;\\n    }\\n    return 1;\\n}\\n```\n```Java []\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean greater=false, less=false;\\n        int n=nums.length;\\n        for(int i=0; i<n-1; i++){\\n            int d=nums[i+1]-nums[i];\\n            if (d>0) greater=true;\\n            else if (d<0) less=true;\\n            if (greater && less) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```C# []\\npublic class Solution {\\n    public bool IsMonotonic(int[] nums) {\\n        bool greater=false, less=false;\\n        int n=nums.Length;\\n        for(int i=0; i<n-1; i++){\\n            int d=nums[i+1]-nums[i];\\n            if (d>0) greater=true;\\n            else if (d<0) less=true;\\n            if (greater && less) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        //C++ adjacent_difference\\n        //nums[i]=nums[i]-nums[i-1] for i>0 nums[0]=nums[0]\\n        adjacent_difference(nums.begin(), nums.end(), nums.begin());\\n        nums[0]=0;//Modify nums[0]=0\\n\\n        bool greater=0, less=0;\\n        #pragma unroll\\n        for(int d: nums){\\n            if (d>0) greater=1;\\n            else if (d<0) less=1;\\n            if (greater && less) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        //C++ adjacent_difference\\n        //nums[i]=nums[i]-nums[i-1] for i>0 nums[0]=nums[0]\\n        adjacent_difference(nums.begin(), nums.end(), nums.begin());\\n        nums[0]=0;//Modify nums[0]=0\\n\\n        int greater0=count_if(nums.begin(), nums.end(), [](int x){return x>0;});\\n        int less0=count_if(nums.begin(), nums.end(), [](int x){return x<0;});\\n\\n        return (greater0>0&& less0>0)?0:1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2355132,
                "title": "python-easy-solution-beats-97-24",
                "content": "```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        a = sorted(nums)\\n        b = sorted(nums,reverse=True)\\n        if nums == a or nums == b:\\n            return True\\n        return False\\n```\\n**.\\n.\\n.\\n.\\n<<< Please Up-vote if you find it useful >>>**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        a = sorted(nums)\\n        b = sorted(nums,reverse=True)\\n        if nums == a or nums == b:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681208,
                "title": "python-one-pass",
                "content": "```\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        inc = dec = True\\n        for i in range(len(nums)-1):\\n            if nums[i] > nums[i+1]:\\n                inc = False\\n                if dec == False: return False\\n            if nums[i] < nums[i+1]:\\n                dec = False\\n                if inc == False: return False\\n\\n        return True if dec or inc else False\\n       \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        inc = dec = True\\n        for i in range(len(nums)-1):\\n            if nums[i] > nums[i+1]:\\n                inc = False\\n                if dec == False: return False\\n            if nums[i] < nums[i+1]:\\n                dec = False\\n                if inc == False: return False\\n\\n        return True if dec or inc else False\\n       \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 811494,
                "title": "javascript-one-pass-o-n-time-o-1-space",
                "content": "```\\nvar isMonotonic = function(A) {\\n    \\n    let increasing = true \\n    let decreasing = true \\n    \\n    for(let i=0; i<A.length -1; i++){\\n        if(A[i] > A[i+1]){\\n            increasing = false\\n        }\\n        if(A[i] < A[i+1]){\\n            decreasing = false\\n        }\\n        \\n    }\\n    \\n    return increasing || decreasing \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isMonotonic = function(A) {\\n    \\n    let increasing = true \\n    let decreasing = true \\n    \\n    for(let i=0; i<A.length -1; i++){\\n        if(A[i] > A[i+1]){\\n            increasing = false\\n        }\\n        if(A[i] < A[i+1]){\\n            decreasing = false\\n        }\\n        \\n    }\\n    \\n    return increasing || decreasing \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 206729,
                "title": "python-solution-beats-95",
                "content": "```\\nclass Solution:\\n    def isMonotonic(self, A):\\n        if len(A) == 1:\\n            return True\\n        increasing = True if A[-1] > A[0] else False\\n        prev = A[0]\\n        if increasing:\\n            for i in range(1, len(A)):\\n                if A[i] < prev:\\n                    return False\\n                prev = A[i]\\n        else:\\n            for i in range(1, len(A)):\\n                if A[i] > prev:\\n                    return False\\n                prev = A[i]\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, A):\\n        if len(A) == 1:\\n            return True\\n        increasing = True if A[-1] > A[0] else False\\n        prev = A[0]\\n        if increasing:\\n            for i in range(1, len(A)):\\n                if A[i] < prev:\\n                    return False\\n                prev = A[i]\\n        else:\\n            for i in range(1, len(A)):\\n                if A[i] > prev:\\n                    return False\\n                prev = A[i]\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165861,
                "title": "clean-code",
                "content": "```\\npublic boolean isMonotonic(int[] array) {\\n    return isNotDecreasing(array) || isNotIncreasing(array);\\n}\\n\\nprivate boolean isNotIncreasing(int[] array) {\\n    for (int i = 0; i < array.length - 1; i++) {\\n        if (array[i] < array[i + 1])\\n            return false;\\n    }\\n    return true;\\n}\\n\\nprivate boolean isNotDecreasing(int[] array) {\\n    for (int i = 0; i < array.length - 1; i++) {\\n        if (array[i] > array[i + 1])\\n            return false;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isMonotonic(int[] array) {\\n    return isNotDecreasing(array) || isNotIncreasing(array);\\n}\\n\\nprivate boolean isNotIncreasing(int[] array) {\\n    for (int i = 0; i < array.length - 1; i++) {\\n        if (array[i] < array[i + 1])\\n            return false;\\n    }\\n    return true;\\n}\\n\\nprivate boolean isNotDecreasing(int[] array) {\\n    for (int i = 0; i < array.length - 1; i++) {\\n        if (array[i] > array[i + 1])\\n            return false;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4103042,
                "title": "detailed-explanation-with-100-acceptance-rate-c-optimised-approach-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this code is to determine whether the given array is monotonic, i.e., either monotone increasing or monotone decreasing. To do this efficiently, the code iterates through the array while tracking the direction of monotonicity. It returns true if the array is monotonic and false if it is not.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a variable direction to 0, which will be used to track the direction of monotonicity. A value of 0 indicates that the direction is undetermined, 1 indicates increasing, and -1 indicates decreasing.\\n\\n2. Check if the size of the input array nums is less than or equal to 1. If it is, return true because a single-element array is considered monotonic.\\n\\n3. Iterate through the array nums starting from the second element (index 1) to the end.\\n\\n4. In each iteration, calculate the difference diff between the current element and the previous element (i.e., nums[i] - nums[i - 1]).\\n\\n5. Based on the value of diff, update the direction variable:\\n\\n- If diff is greater than 0, it means the array is increasing. Check if the direction was previously set to -1 (decreasing). If it was, return false because the array is not monotonic. Otherwise, update direction to 1 (increasing).\\n\\n- If diff is less than 0, it means the array is decreasing. Check if the direction was previously set to 1 (increasing). If it was, return false because the array is not monotonic. Otherwise, update direction to -1 (decreasing).\\n\\n6. If diff is equal to 0, it means the current and previous elements are equal. In this case, we continue to the next element without changing the direction.\\n\\n7. After the loop, if we have not encountered a situation where direction changed from the initial undetermined state (0), it means the array is either entirely increasing or entirely decreasing, and we return true. Otherwise, we return false.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code iterates through the input array nums once, comparing each element with the previous one. The time complexity is O(n), where n is the number of elements in the array.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe code uses a constant amount of extra space for variables (direction, n). Therefore, the space complexity is O(1), indicating constant space usage regardless of the input array\\'s size.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        if (n <= 1) {\\n            return true; // A single element array is considered monotonic.\\n        }\\n        \\n        int direction = 0; // 0: undetermined, 1: increasing, -1: decreasing\\n        \\n        for (int i = 1; i < n; i++) {\\n            int diff = nums[i] - nums[i - 1];\\n            \\n            if (diff > 0) {\\n                if (direction == -1) {\\n                    return false; // Not monotonic if it was decreasing before.\\n                }\\n                direction = 1;\\n            } else if (diff < 0) {\\n                if (direction == 1) {\\n                    return false; // Not monotonic if it was increasing before.\\n                }\\n                direction = -1;\\n            }\\n            // If diff == 0, continue to the next element.\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Array",
                    "Two Pointers",
                    "Tree",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        if (n <= 1) {\\n            return true; // A single element array is considered monotonic.\\n        }\\n        \\n        int direction = 0; // 0: undetermined, 1: increasing, -1: decreasing\\n        \\n        for (int i = 1; i < n; i++) {\\n            int diff = nums[i] - nums[i - 1];\\n            \\n            if (diff > 0) {\\n                if (direction == -1) {\\n                    return false; // Not monotonic if it was decreasing before.\\n                }\\n                direction = 1;\\n            } else if (diff < 0) {\\n                if (direction == 1) {\\n                    return false; // Not monotonic if it was increasing before.\\n                }\\n                direction = -1;\\n            }\\n            // If diff == 0, continue to the next element.\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4102998,
                "title": "easy-c-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool flag=true,flag1=true;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]>nums[i+1])\\n            flag=false; \\n        }\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]<nums[i+1])\\n            flag1=false; \\n        }\\n        if(flag==true)\\n            return flag;\\n        else if(flag1==true)\\n            return flag1;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool flag=true,flag1=true;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]>nums[i+1])\\n            flag=false; \\n        }\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]<nums[i+1])\\n            flag1=false; \\n        }\\n        if(flag==true)\\n            return flag;\\n        else if(flag1==true)\\n            return flag1;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4102818,
                "title": "daily-leetcoding-challenge-september-day-29",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/monotonic-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Pass\n\n  \n**Approach 2:** One Pass\n\n  \n**Approach 3:** One Pass (Simple Variant)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/monotonic-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n**Approach 3:** One Pass (Simple Variant)\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3741853,
                "title": "simplest-o-n-6-line-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nTime Complexity is O(N)\\n\\n- Space complexity:\\nSpace Complexity is O(N) since we are not using any extra space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int n = nums.size();\\n        int cntp=0,cntn=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(nums[i]<=nums[i+1])cntp++;\\n            if(nums[i]>=nums[i+1])cntn++;\\n        }\\n        return cntn==n-1 || cntp==n-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int n = nums.size();\\n        int cntp=0,cntn=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(nums[i]<=nums[i+1])cntp++;\\n            if(nums[i]>=nums[i+1])cntn++;\\n        }\\n        return cntn==n-1 || cntp==n-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666524,
                "title": "java-simple-and-easy-to-understand-solution",
                "content": "class Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int c=0;int k=0;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i+1]>=nums[i])\\n                c++;\\n             if(nums[i]>=nums[i+1])\\n                k++;\\n        }\\n        if(c==nums.length-1||k==nums.length-1)\\n            return true;\\n        else\\n            return false;\\n       \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int c=0;int k=0;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i+1]>=nums[i])\\n                c++;\\n             if(nums[i]>=nums[i+1])\\n                k++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3638306,
                "title": "c-using-bitwise-operator-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int n = nums.size();\\n        bool isIncreasing = false, isDecreasing = false;\\n        for(int i = 0; i < n-1; i++) {\\n            if(nums[i] < nums[i+1])\\n                isIncreasing = true;\\n            else if(nums[i] > nums[i+1])\\n                isDecreasing = true;\\n            if(isIncreasing & isDecreasing) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int n = nums.size();\\n        bool isIncreasing = false, isDecreasing = false;\\n        for(int i = 0; i < n-1; i++) {\\n            if(nums[i] < nums[i+1])\\n                isIncreasing = true;\\n            else if(nums[i] > nums[i+1])\\n                isDecreasing = true;\\n            if(isIncreasing & isDecreasing) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2343378,
                "title": "beginner-friendly-java-javascript-python-soluton",
                "content": "**Time Complexity : O(n)**\\n**Java**\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean monotone_increasing = true, monotone_decreasing = true;\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i] > nums[i-1]) monotone_decreasing = false;\\n            if(nums[i] < nums[i-1]) monotone_increasing = false;\\n        }\\n        return monotone_increasing || monotone_decreasing;\\n    }\\n}\\n```\\n**JavaScrpit**\\n```\\nvar isMonotonic = function(nums) {\\n    let monotone_increasing = true, monotone_decreasing = true\\n    for(let i=1; i<nums.length; i++){\\n        if(nums[i] > nums[i-1]) monotone_decreasing = false\\n        if(nums[i] < nums[i-1]) monotone_increasing = false\\n    }\\n    return monotone_increasing || monotone_decreasing\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def isMonotonic(self, nums):\\n        monotone_increasing = monotone_decreasing = True\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                monotone_decreasing = False\\n            if nums[i] < nums[i-1] :\\n                monotone_increasing = False\\n        return monotone_increasing or monotone_decreasing\\n```",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean monotone_increasing = true, monotone_decreasing = true;\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i] > nums[i-1]) monotone_decreasing = false;\\n            if(nums[i] < nums[i-1]) monotone_increasing = false;\\n        }\\n        return monotone_increasing || monotone_decreasing;\\n    }\\n}\\n```\n```\\nvar isMonotonic = function(nums) {\\n    let monotone_increasing = true, monotone_decreasing = true\\n    for(let i=1; i<nums.length; i++){\\n        if(nums[i] > nums[i-1]) monotone_decreasing = false\\n        if(nums[i] < nums[i-1]) monotone_increasing = false\\n    }\\n    return monotone_increasing || monotone_decreasing\\n};\\n```\n```\\nclass Solution(object):\\n    def isMonotonic(self, nums):\\n        monotone_increasing = monotone_decreasing = True\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                monotone_decreasing = False\\n            if nums[i] < nums[i-1] :\\n                monotone_increasing = False\\n        return monotone_increasing or monotone_decreasing\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234155,
                "title": "python-simple-one-pass-solution",
                "content": "This solution in a **single** **pass** is able to compare the current element and the previous element and just sets the boolean values of our flags as we go ahead. \\n\\n**Time Complexity = O(n)** as we traverse through each element of the array **nums** only once.\\n**Space Complexity = O(1)** as we don\\'t use extra memory.\\n\\n```\\n\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        # Time Complexity = O(n) and Space Complexity = O(1)\\n        isNonDecreasing = True\\n        isNonIncreasing = True\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                isNonDecreasing = False\\n            if nums[i] < nums[i-1]:\\n                isNonIncreasing = False\\n                \\n        return isNonDecreasing or isNonIncreasing\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        # Time Complexity = O(n) and Space Complexity = O(1)\\n        isNonDecreasing = True\\n        isNonIncreasing = True\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                isNonDecreasing = False\\n            if nums[i] < nums[i-1]:\\n                isNonIncreasing = False\\n                \\n        return isNonDecreasing or isNonIncreasing\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2145287,
                "title": "java-simple-and-easy-to-understand-solution",
                "content": "```\\npublic boolean isMonotonic(int[] nums) {\\n    if (nums.length <= 1) return true;\\n    int m = 0, n = 0;\\n    for (int i = 1; i < nums.length; i++) {\\n        if (nums[i] >= nums[i-1]) m++;\\n        if (nums[i] <= nums[i-1]) n++;\\n    }\\n    if (m == nums.length - 1) return true;\\n    else if (n == nums.length - 1) return true;\\n    else return false;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean isMonotonic(int[] nums) {\\n    if (nums.length <= 1) return true;\\n    int m = 0, n = 0;\\n    for (int i = 1; i < nums.length; i++) {\\n        if (nums[i] >= nums[i-1]) m++;\\n        if (nums[i] <= nums[i-1]) n++;\\n    }\\n    if (m == nums.length - 1) return true;\\n    else if (n == nums.length - 1) return true;\\n    else return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2070573,
                "title": "java-easy-o-n-faster-solution",
                "content": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int n = nums.length;\\n        boolean ans1 = true;\\n        boolean ans2 = true;\\n        \\n        for(int i=0;i<n-1;i++){\\n            if(nums[i]<nums[i+1]) ans1 = false;\\n            if(nums[i]>nums[i+1]) ans2 = false;\\n        }\\n        \\n        return ans1 || ans2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int n = nums.length;\\n        boolean ans1 = true;\\n        boolean ans2 = true;\\n        \\n        for(int i=0;i<n-1;i++){\\n            if(nums[i]<nums[i+1]) ans1 = false;\\n            if(nums[i]>nums[i+1]) ans2 = false;\\n        }\\n        \\n        return ans1 || ans2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820839,
                "title": "c-super-simple-solution",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& A) {\\n        if (A.size() <= 2) return true; // two numbers are always monotonous\\n        int i=0;\\n        while ((i < A.size()-1) && (A[i] == A[i+1]))\\n            i++;\\n        if (i == A.size()-1) return true; // reached end of array with only equal numbers\\n        bool is_increase = A[i] < A[i+1] ? true : false; // is array increasing or decreasing?\\n        while (i < A.size()-1)\\n        {\\n            if ((is_increase == false) && (A[i] < A[i+1])) return false;\\n            if ((is_increase == true) && (A[i] > A[i+1])) return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& A) {\\n        if (A.size() <= 2) return true; // two numbers are always monotonous\\n        int i=0;\\n        while ((i < A.size()-1) && (A[i] == A[i+1]))\\n            i++;\\n        if (i == A.size()-1) return true; // reached end of array with only equal numbers\\n        bool is_increase = A[i] < A[i+1] ? true : false; // is array increasing or decreasing?\\n        while (i < A.size()-1)\\n        {\\n            if ((is_increase == false) && (A[i] < A[i+1])) return false;\\n            if ((is_increase == true) && (A[i] > A[i+1])) return false;\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4103623,
                "title": "c-easy-solution",
                "content": "# Intuition\\nWe will tarverse through array and will store the value if it is increasing or decreasing.\\n\\n# Approach\\nWe will declare two variable inc and dec and intialise them with false ...if array is increasing we will set inc to true and if decreasing we will set dec to true..Then after full iteration if both are true this mean that array is not monotonic else array is monotonic.\\n\\n# Complexity\\n- Time complexity:\\n0(n) , where n is size of array\\n\\n- Space complexity:\\n0(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool inc = false;\\n        bool dec = false;\\n        int n = nums.size();\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i]>nums[i+1]){\\n                dec=true;  // array decreasing\\n            } else if(nums[i]<nums[i+1]){\\n                inc = true;   // array increasing\\n            }\\n        }\\n\\n        if(dec && inc) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool inc = false;\\n        bool dec = false;\\n        int n = nums.size();\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i]>nums[i+1]){\\n                dec=true;  // array decreasing\\n            } else if(nums[i]<nums[i+1]){\\n                inc = true;   // array increasing\\n            }\\n        }\\n\\n        if(dec && inc) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4103381,
                "title": "noob-code-easy-to-understand",
                "content": "\\n# Approach\\n1. `o` is initialized to `False`. This variable will be used to store the result indicating whether the list is monotonic.\\n\\n2. An empty list `k` is initialized.\\n\\n3. A loop is used to iterate through each element `i` in the input list `nums`. Inside the loop, each element `i` is appended to the list `k`.\\n\\n4. The list `k` is sorted in ascending order using `k.sort()`. This sorting operation doesn\\'t modify the original `nums` list.\\n\\n5. The code checks if the first element of the sorted list `k` is equal to the last element of the input `nums`. This comparison is used to determine whether the list is non-increasing or non-decreasing. If they are equal, it suggests that the list is non-increasing, and if they are not equal, it suggests that the list is non-decreasing.\\n\\n6. Two separate loops are used based on the comparison result:\\n   - If `k[0] == nums[-1]`, it means the list is non-increasing. In this case, a loop iterates through the `nums` list from the first element to the second-to-last element. If it finds any element that is greater than or equal to the next element, it sets `o` to `True`, indicating that the list is non-increasing. If any element is less than the next element, it sets `o` to `False` and breaks the loop.\\n   - If `k[0] != nums[-1]`, it means the list is non-decreasing. In this case, a loop iterates through the `nums` list from the first element to the second-to-last element. If it finds any element that is less than or equal to the next element, it sets `o` to `True`, indicating that the list is non-decreasing. If any element is greater than the next element, it sets `o` to `False` and breaks the loop.\\n\\n7. There\\'s a special case check for lists with only one element (`len(nums) == 1`). In this case, the list is considered monotonic by default, so `o` is set to `True`.\\n\\n8. Finally, the function returns the value of `o`, which indicates whether the input list `nums` is monotonic or not.\\n\\n\\n# Complexity\\n- Time complexity: ***O(n x log(n))*** \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ***o(n)***\\n\\n# Code\\n```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        o=False\\n        k=[]\\n        for i in nums:\\n            k.append(i)\\n        k.sort()\\n        if(k[0]==nums[-1]):\\n            for i in range(len(nums)-1):\\n                print(1)\\n                if nums[i]>=nums[i+1]:\\n                    o=True\\n                else:\\n                    o=False\\n                    break\\n        else:\\n            for i in range(len(nums)-1):\\n                print(nums[i])\\n                if nums[i]<=nums[i+1]:\\n                    o=True\\n                else:\\n                    o=False\\n                    break\\n        if(len(nums)==1):\\n            o=True\\n        return(o)\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        o=False\\n        k=[]\\n        for i in nums:\\n            k.append(i)\\n        k.sort()\\n        if(k[0]==nums[-1]):\\n            for i in range(len(nums)-1):\\n                print(1)\\n                if nums[i]>=nums[i+1]:\\n                    o=True\\n                else:\\n                    o=False\\n                    break\\n        else:\\n            for i in range(len(nums)-1):\\n                print(nums[i])\\n                if nums[i]<=nums[i+1]:\\n                    o=True\\n                else:\\n                    o=False\\n                    break\\n        if(len(nums)==1):\\n            o=True\\n        return(o)\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4103044,
                "title": "detailed-explanation-with-solution-using-two-pointer-approach-o-n-with-100-acceptance-rate",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this code is to determine whether the given array is monotonic, i.e., either monotone increasing or monotone decreasing. It uses a two-pointer approach to skip identical elements at the beginning and end of the array and then checks if the remaining elements are consistent with either a monotone increasing or decreasing pattern.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check if the size of the input array nums is less than or equal to 1. If it is, return true because a single-element array is considered monotonic.\\n\\n2. Initialize two pointers, left and right, initially pointing to the first and last elements of the array, respectively.\\n\\n3. Use the left pointer to skip identical elements at the beginning of the array. Increment left while the current element is equal to the next element.\\n\\n4. Use the right pointer to skip identical elements at the end of the array. Decrement right while the current element is equal to the previous element.\\n\\n5. Check if left is greater than or equal to right. If it is, it means all elements in the array are identical, and the array is considered monotonic. Return true.\\n\\n6. Determine whether the array is increasing or decreasing based on the values at left and left + 1.\\n\\n7. Iterate from left to right - 1 and compare each element with its next element:\\n\\n- If the array is increasing and the current element is greater than the next element, return false (not monotonic).\\n\\n- If the array is decreasing and the current element is less than the next element, return false (not monotonic).\\n8. If the loop completes without returning false, return true because the array is monotonic.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code iterates through the input array nums once, either from left to right or from right to left, depending on the direction of monotonicity. The time complexity is O(n), where n is the number of elements in the array.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe code uses a constant amount of extra space for variables (left, right, n). Therefore, the space complexity is O(1), indicating constant space usage regardless of the input array\\'s size.\\n\\n# Do Upvote if you liked the explanation \\uD83E\\uDD1E\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        if (n <= 1) {\\n            return true; // A single element array is considered monotonic.\\n        }\\n        \\n        int left = 0;\\n        int right = n - 1;\\n        \\n        while (left < n - 1 && nums[left] == nums[left + 1]) {\\n            left++; // Skip identical elements at the beginning.\\n        }\\n        \\n        while (right > 0 && nums[right] == nums[right - 1]) {\\n            right--; // Skip identical elements at the end.\\n        }\\n        \\n        if (left >= right) {\\n            return true; // All elements are identical; the array is monotonic.\\n        }\\n        \\n        bool increasing = nums[left] < nums[left + 1];\\n        \\n        for (int i = left; i < right; i++) {\\n            if (increasing && nums[i] > nums[i + 1]) {\\n                return false; // Not monotonic if it decreases.\\n            } else if (!increasing && nums[i] < nums[i + 1]) {\\n                return false; // Not monotonic if it increases.\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Array",
                    "Math",
                    "Two Pointers",
                    "String",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        if (n <= 1) {\\n            return true; // A single element array is considered monotonic.\\n        }\\n        \\n        int left = 0;\\n        int right = n - 1;\\n        \\n        while (left < n - 1 && nums[left] == nums[left + 1]) {\\n            left++; // Skip identical elements at the beginning.\\n        }\\n        \\n        while (right > 0 && nums[right] == nums[right - 1]) {\\n            right--; // Skip identical elements at the end.\\n        }\\n        \\n        if (left >= right) {\\n            return true; // All elements are identical; the array is monotonic.\\n        }\\n        \\n        bool increasing = nums[left] < nums[left + 1];\\n        \\n        for (int i = left; i < right; i++) {\\n            if (increasing && nums[i] > nums[i + 1]) {\\n                return false; // Not monotonic if it decreases.\\n            } else if (!increasing && nums[i] < nums[i + 1]) {\\n                return false; // Not monotonic if it increases.\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4102922,
                "title": "straightforward-algorithm-easy-approach-o-n-time-complexity",
                "content": "# Intuition\\n<--The intuition behind this code is to check whether the given array is monotonic, which means it is either strictly increasing or strictly decreasing. \\n# Approach\\n<-- The approach iterates through the array while maintaining two flags, one for increasing and one for decreasing trends.\\nIf both flags are set to true at any point, it returns false, indicating a violation of monotonicity(i.e the array is not strictly increasing nor strictly decreasing). \\nIf neither flag is set to true throughout the iteration, it returns true, indicating that the array is monotonic.\\n\\n# Complexity\\n- Time complexity:\\n<-- O(n)\\n\\n- Space complexity:\\n<-- o(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n    bool flag=false;\\n    bool flag1=false;\\n    for (int i = 1; i < nums.size(); ++i) {\\n            if (nums[i] > nums[i - 1]) {\\n                flag = true;\\n            } else if (nums[i] < nums[i - 1]) {\\n                flag1 = true;\\n            }\\n            if (flag && flag1) {\\n                return false; \\n            }\\n        }\\n        return true; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n    bool flag=false;\\n    bool flag1=false;\\n    for (int i = 1; i < nums.size(); ++i) {\\n            if (nums[i] > nums[i - 1]) {\\n                flag = true;\\n            } else if (nums[i] < nums[i - 1]) {\\n                flag1 = true;\\n            }\\n            if (flag && flag1) {\\n                return false; \\n            }\\n        }\\n        return true; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779578,
                "title": "100-beats-fastest-solution-java",
                "content": "# Intuition \\nJust check both type of monotonicity.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution{\\n    public boolean isMonotonic(int[] nums){\\n        return isInc(nums) || isDec(nums);\\n    }\\n\\n    public boolean isInc(int[] nums){\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i]>nums[i-1]) return false;\\n        }\\n        return true;\\n    }\\n\\n    public boolean isDec(int[] nums){\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i]<nums[i-1]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\n    public boolean isMonotonic(int[] nums){\\n        return isInc(nums) || isDec(nums);\\n    }\\n\\n    public boolean isInc(int[] nums){\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i]>nums[i-1]) return false;\\n        }\\n        return true;\\n    }\\n\\n    public boolean isDec(int[] nums){\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i]<nums[i-1]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763009,
                "title": "monotonic-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar isMonotonic = function(nums) {\\n    let increasing =  true;\\n    let decreasing = true;\\n\\n    for(let i = 1; i < nums.length; i++){\\n        if(nums[i-1] < nums[i]){\\n            decreasing = false;\\n        }\\n        else if(nums[i - 1] > nums[i]){\\n            increasing = false;\\n        }\\n    }\\n    return increasing || decreasing\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar isMonotonic = function(nums) {\\n    let increasing =  true;\\n    let decreasing = true;\\n\\n    for(let i = 1; i < nums.length; i++){\\n        if(nums[i-1] < nums[i]){\\n            decreasing = false;\\n        }\\n        else if(nums[i - 1] > nums[i]){\\n            increasing = false;\\n        }\\n    }\\n    return increasing || decreasing\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3669154,
                "title": "easy-c-solution-beats-84-in-run-time",
                "content": "class Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n       int c=0,k=0;\\n        int n = nums.size()-1;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]<=nums[i+1]){\\n                c=c+1;\\n            }\\n           if(nums[i]>=nums[i+1]) \\n            {\\n                k=k+1;\\n            }\\n        }\\n      \\n        if(c==nums.size()-1 || k==nums.size()-1)\\n            return true;\\n        else{\\n            return false;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n       int c=0,k=0;\\n        int n = nums.size()-1;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]<=nums[i+1]){\\n                c=c+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3607947,
                "title": "absolute-beginner-friendly-one-pass-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        vector<int>tmp;\\n        copy(nums.begin(), nums.end(), back_inserter(tmp));\\n        sort(tmp.begin(),tmp.end());\\n        if(tmp==nums) return 1;\\n        reverse(tmp.begin(),tmp.end());\\n        if(tmp==nums) return 1;\\n        return 0;\\n     }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        vector<int>tmp;\\n        copy(nums.begin(), nums.end(), back_inserter(tmp));\\n        sort(tmp.begin(),tmp.end());\\n        if(tmp==nums) return 1;\\n        reverse(tmp.begin(),tmp.end());\\n        if(tmp==nums) return 1;\\n        return 0;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453068,
                "title": "python-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        if nums[-1]> nums[0]:\\n            for i in range(len(nums)-1):\\n                if nums[i+1] < nums[i]:\\n                    return False\\n            return True\\n        elif nums[-1]<nums[0]:\\n            for i in range(len(nums)-1):\\n                if nums[i+1] > nums[i]:\\n                    return False\\n            return True\\n        else:\\n            for i in range(len(nums)-1):\\n                if nums[i+1] != nums[i]:\\n                    return False\\n            return True\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        if nums[-1]> nums[0]:\\n            for i in range(len(nums)-1):\\n                if nums[i+1] < nums[i]:\\n                    return False\\n            return True\\n        elif nums[-1]<nums[0]:\\n            for i in range(len(nums)-1):\\n                if nums[i+1] > nums[i]:\\n                    return False\\n            return True\\n        else:\\n            for i in range(len(nums)-1):\\n                if nums[i+1] != nums[i]:\\n                    return False\\n            return True\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412778,
                "title": "monotonic-array-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int i, flag=0;\\n        for(i=1 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]-nums[i-1]>0 && flag==0)\\n            {\\n                flag = 1;\\n            }\\n            else if(nums[i]-nums[i-1]<0 && flag==0)\\n            {\\n                flag = 2;\\n            }\\n            else if(nums[i]-nums[i-1]>0 && flag==2 || nums[i]-nums[i-1]<0 && flag==1)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int i, flag=0;\\n        for(i=1 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]-nums[i-1]>0 && flag==0)\\n            {\\n                flag = 1;\\n            }\\n            else if(nums[i]-nums[i-1]<0 && flag==0)\\n            {\\n                flag = 2;\\n            }\\n            else if(nums[i]-nums[i-1]>0 && flag==2 || nums[i]-nums[i-1]<0 && flag==1)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120025,
                "title": "java-896-monotonic-array",
                "content": "\\n# Java Code.  \\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n         int n = nums.length;\\n            boolean up=true, down=true;\\n\\n            for (int i = 0; i < n-1; i++) {\\n                if (nums[i] > nums[i + 1]) {\\n                    up = false;\\n                    break;\\n                }\\n            }\\n\\n            for (int i = 0; i < n-1; i++) {\\n                if (nums[i] < nums[i + 1]) {\\n                    down = false;\\n                    break;\\n                }\\n            }\\n            return up || down;\\n    }\\n}\\n```\\n# Good Luck\\uD83D\\uDE09",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n         int n = nums.length;\\n            boolean up=true, down=true;\\n\\n            for (int i = 0; i < n-1; i++) {\\n                if (nums[i] > nums[i + 1]) {\\n                    up = false;\\n                    break;\\n                }\\n            }\\n\\n            for (int i = 0; i < n-1; i++) {\\n                if (nums[i] < nums[i + 1]) {\\n                    down = false;\\n                    break;\\n                }\\n            }\\n            return up || down;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054468,
                "title": "easy-c-solution-two-line-code-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst click i get that order is manipulated by sorting. See the APPROACH.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is so simple, the question said that this must be in increasing or in decreasing order (monotone). We can change the order by doing sorting.\\n1. Create two copies of input vector.\\n2. Sort first copy vector (in increasing order) using simple sort method.\\n3. Sort second copy vector (in decreasing order) using the function (written in code).\\n4. Now use if else condition to check whether any of these two vector is equal or not to the input vector (original vector).\\n5. So use or operator if any of them is equal, it return true else false.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this code is O(nlogn) due to the use of the sort function, which has a time complexity of O(nlogn) for the average and worst case.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) as it creates two copies of the input vector, v1 and v2, each of which takes up n space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        vector <int> v1 = nums,v2 = nums;\\n        sort(v1.begin(),v1.end()); //sort in increasing order\\n        sort(v2.begin(), v2.end(), greater<int>()); //sort in decreasing order\\n        if(v1==nums || v2==nums) return 1;\\n        else return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        vector <int> v1 = nums,v2 = nums;\\n        sort(v1.begin(),v1.end()); //sort in increasing order\\n        sort(v2.begin(), v2.end(), greater<int>()); //sort in decreasing order\\n        if(v1==nums || v2==nums) return 1;\\n        else return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016062,
                "title": "c-brute-force-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        if(nums[0]>nums[nums.size()-1]){\\n            for(int i=0; i<nums.size()-1; i++){\\n                if(nums[i]<nums[i+1]){\\n                    return false;\\n                }\\n            }\\n        }\\n        else if(nums[0]<nums[nums.size()-1]){\\n            for(int i=0; i<nums.size()-1; i++){\\n                if(nums[i]>nums[i+1]){\\n                    return false;\\n                }\\n            }\\n        }\\n        else{\\n            for(int i=0; i<nums.size()-1; i++){\\n                if(nums[i]!=nums[i+1]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        if(nums[0]>nums[nums.size()-1]){\\n            for(int i=0; i<nums.size()-1; i++){\\n                if(nums[i]<nums[i+1]){\\n                    return false;\\n                }\\n            }\\n        }\\n        else if(nums[0]<nums[nums.size()-1]){\\n            for(int i=0; i<nums.size()-1; i++){\\n                if(nums[i]>nums[i+1]){\\n                    return false;\\n                }\\n            }\\n        }\\n        else{\\n            for(int i=0; i<nums.size()-1; i++){\\n                if(nums[i]!=nums[i+1]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944650,
                "title": "java-1ms-o-n-time-complexity",
                "content": "\\n# Complexity\\n- Time complexity:\\nO ( N )\\n\\n- Space complexity:\\nO ( 1 )\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int count=0;\\n        int count1=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]<=nums[i+1]){\\n                count++;\\n            }\\n        }\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]>=nums[i+1]) {\\n                count1++;\\n            }\\n        }\\n        return count==nums.length-1 || count1==nums.length-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int count=0;\\n        int count1=0;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]<=nums[i+1]){\\n                count++;\\n            }\\n        }\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]>=nums[i+1]) {\\n                count1++;\\n            }\\n        }\\n        return count==nums.length-1 || count1==nums.length-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919469,
                "title": "java-1ms-100-easy",
                "content": "# Please Upvote :D\\n---\\n![image.png](https://assets.leetcode.com/users/images/5aea1073-69b3-4182-92f9-1d25fb2e2605_1671227782.435388.png)\\n\\n``` java []\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int n = nums.length;\\n        if (n < 3) {\\n            return true;\\n        }\\n\\n        boolean isIncreasing = nums[n - 1] > nums[0];\\n        for (int i = 1; i < n; i++) {\\n            if (isIncreasing) {\\n                if (nums[i - 1] > nums[i]) {\\n                    return false;\\n                }\\n            }\\n            else {\\n                if (nums[i - 1] < nums[i]) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\nTime complexity: `O(n)`\\nSpace complexity: `O(1)`",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "``` java []\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int n = nums.length;\\n        if (n < 3) {\\n            return true;\\n        }\\n\\n        boolean isIncreasing = nums[n - 1] > nums[0];\\n        for (int i = 1; i < n; i++) {\\n            if (isIncreasing) {\\n                if (nums[i - 1] > nums[i]) {\\n                    return false;\\n                }\\n            }\\n            else {\\n                if (nums[i - 1] < nums[i]) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611352,
                "title": "java-fast-solution",
                "content": "class Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int c=1,d=1;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]<=nums[i+1])\\n            {\\n            c++;\\n            }\\n            if(nums[i+1]<=nums[i])\\n            {\\n             d++;\\n            }\\n        }\\n        System.out.println(c+\" \"+d);\\n        if(c==nums.length || d==nums.length)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int c=1,d=1;\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]<=nums[i+1])\\n            {\\n            c++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2209802,
                "title": "easy-code-with-line-by-line-explanation",
                "content": "class Solution {\\npublic:\\n\\n    bool isMonotonic(vector<int>& v) {\\n        int flag;\\n        //if flag=1 then increaseing, if flag==-1 the decreasing\\n\\t\\t\\n        int n=v.size();\\n\\t\\t\\n\\t\\t//if number of element is 1 or 2 the array is always monotonic\\n        if(n<=2)\\n            return true;\\n\\t\\t\\t\\n\\t\\t//steps to remove duplicate elements\\n        vector<int>::iterator ip;\\n        ip = std::unique(v.begin(), v.begin() + n);\\n        v.resize(std::distance(v.begin(), ip));\\n\\t\\t\\n\\t\\t//setting the flag value wrt the first 2 elements\\n        if(v[0]<v[1])\\n            flag=1;\\n        else\\n            flag=-1;\\n        int p;\\n        for(int i=1;i<v.size()-1;i++){\\n            if(v[i]<v[i+1])\\n                p=1;\\n            else\\n                p=-1;\\n            if(p!=flag)\\n                return false;       \\n        }\\n        return true;\\n    }\\n};\\n\\nHope the solution was pretty easy. If you like the solution then kindly do upvote it!!",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    bool isMonotonic(vector<int>& v) {\\n        int flag;\\n        //if flag=1 then increaseing, if flag==-1 the decreasing\\n\\t\\t\\n        int n=v.size();\\n\\t\\t\\n\\t\\t//if number of element is 1 or 2 the array is always monotonic\\n        if(n<=2)\\n            return true;\\n\\t\\t\\t\\n\\t\\t//steps to remove duplicate elements\\n        vector<int>::iterator ip;\\n        ip = std::unique(v.begin(), v.begin() + n);\\n        v.resize(std::distance(v.begin(), ip));\\n\\t\\t\\n\\t\\t//setting the flag value wrt the first 2 elements\\n        if(v[0]<v[1])\\n            flag=1;\\n        else\\n            flag=-1;\\n        int p;\\n        for(int i=1;i<v.size()-1;i++){\\n            if(v[i]<v[i+1])\\n                p=1;\\n            else\\n                p=-1;\\n            if(p!=flag)\\n                return false;       \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1572649,
                "title": "rust-solution-16-ms",
                "content": "```\\nimpl Solution {\\n    pub fn is_monotonic(nums: Vec<i32>) -> bool {\\n        use std::cmp::Ordering;\\n        let mut dir = 0;\\n        for (a, b) in nums.iter().zip(nums[1..].iter()) {\\n            dir |= match a.cmp(b) {\\n                Ordering::Equal => 0,\\n                Ordering::Less => 1,\\n                Ordering::Greater => 2,\\n            };\\n            if dir == 3 {\\n                return false;\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_monotonic(nums: Vec<i32>) -> bool {\\n        use std::cmp::Ordering;\\n        let mut dir = 0;\\n        for (a, b) in nums.iter().zip(nums[1..].iter()) {\\n            dir |= match a.cmp(b) {\\n                Ordering::Equal => 0,\\n                Ordering::Less => 1,\\n                Ordering::Greater => 2,\\n            };\\n            if dir == 3 {\\n                return false;\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1569739,
                "title": "my-simple-understandable-solution-java-c-c",
                "content": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean increasing=true;\\n        boolean decreasing=true;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]>nums[i+1]){\\n                increasing=false;\\n            }\\n            if(nums[i]<nums[i+1]){\\n                decreasing=false;\\n            }\\n        }\\n        return increasing || decreasing;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean increasing=true;\\n        boolean decreasing=true;\\n        for(int i=0; i<nums.length-1; i++){\\n            if(nums[i]>nums[i+1]){\\n                increasing=false;\\n            }\\n            if(nums[i]<nums[i+1]){\\n                decreasing=false;\\n            }\\n        }\\n        return increasing || decreasing;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541605,
                "title": "java-easy-solution-100-fast-with-one-loop",
                "content": "```\\n\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n\\tint i=0; \\n        int  j= nums.length-1;\\n        if(nums.length==1) return true;\\n        while(i<j){\\n          // checking if order is increasing or decreasing //\\n\\t\\t  if(nums[0]<nums[nums.length-1]){\\n                if(nums[i]<=nums[i+1]){\\n                    i++;\\n                }else break;\\n            } else if(nums[0]>nums[nums.length-1] ){\\n                if(nums[j]<=nums[j-1] ) j--;\\n                else break;\\n            }\\n\\t\\t\\telse{\\n                if(nums[i]==nums[j]) {\\n                    i++;\\n                    \\n                }else break;\\n            }\\n        }\\n        if(i==nums.length-1|| j<=0) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n\\tint i=0; \\n        int  j= nums.length-1;\\n        if(nums.length==1) return true;\\n        while(i<j){\\n          // checking if order is increasing or decreasing //\\n\\t\\t  if(nums[0]<nums[nums.length-1]){\\n                if(nums[i]<=nums[i+1]){\\n                    i++;\\n                }else break;\\n            } else if(nums[0]>nums[nums.length-1] ){\\n                if(nums[j]<=nums[j-1] ) j--;\\n                else break;\\n            }\\n\\t\\t\\telse{\\n                if(nums[i]==nums[j]) {\\n                    i++;\\n                    \\n                }else break;\\n            }\\n        }\\n        if(i==nums.length-1|| j<=0) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536608,
                "title": "c-simplest-solution",
                "content": "class Solution {\\npublic:\\n\\n    bool isMonotonic(vector<int>& nums) {\\n        int n = nums.size();\\n        int inc=1,dec=1;\\n        \\n        for(int i=0 ; i<n-1 ; ++i)\\n        {\\n            if(nums[i]<=nums[i+1])\\n                inc++;\\n            if(nums[i]>=nums[i+1])\\n                dec++;\\n        }\\n        if(inc==n || dec==n)\\n            return true;\\n        return false;\\n    }\\n};\\n**leave a like.**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool isMonotonic(vector<int>& nums) {\\n        int n = nums.size();\\n        int inc=1,dec=1;\\n        \\n        for(int i=0 ; i<n-1 ; ++i)\\n        {\\n            if(nums[i]<=nums[i+1])\\n                inc++;\\n            if(nums[i]>=nums[i+1])\\n                dec++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1358055,
                "title": "c-easy-to-understand-stl-99-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n         ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\\n        if(is_sorted(nums.begin(),nums.end()))\\n            return true;\\n        if(is_sorted(nums.begin(),nums.end(),greater<int>()))\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n         ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\\n        if(is_sorted(nums.begin(),nums.end()))\\n            return true;\\n        if(is_sorted(nums.begin(),nums.end(),greater<int>()))\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1199418,
                "title": "rust-one-pass-4ms-beats-100",
                "content": "```rust\\nimpl Solution {\\n    pub fn is_monotonic(a: Vec<i32>) -> bool {\\n        let mut direction = 0;\\n\\n        for i in 1..a.len() {\\n            let s = (a[i] - a[i-1]).signum();\\n            if s == 0 {\\n                continue;\\n            } else if direction == 0 {\\n                direction = s;\\n            } else if s != direction {\\n                return false;\\n            }\\n        }\\n\\n        true\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn is_monotonic(a: Vec<i32>) -> bool {\\n        let mut direction = 0;\\n\\n        for i in 1..a.len() {\\n            let s = (a[i] - a[i-1]).signum();\\n            if s == 0 {\\n                continue;\\n            } else if direction == 0 {\\n                direction = s;\\n            } else if s != direction {\\n                return false;\\n            }\\n        }\\n\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1018290,
                "title": "simple-solution-in-c",
                "content": "class Solution {\\npublic:\\n    bool isMonotonic(vector<int>& A) {\\n        int c=0,d=0;\\n        for(int i=1;i<A.size();i++){\\n            if(A[i]<A[i-1]){\\n                c++;\\n                break;\\n            }\\n        }\\n        for(int i=1;i<A.size();i++){\\n            if(A[i]>A[i-1]){\\n                d++;\\n                break;\\n            }\\n        }\\n        if(d>0&&c>0){\\n            return false;\\n            \\n        }\\n        \\n        else{\\n            return true;\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isMonotonic(vector<int>& A) {\\n        int c=0,d=0;\\n        for(int i=1;i<A.size();i++){\\n            if(A[i]<A[i-1]){\\n                c++;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 659378,
                "title": "java-one-pass-o-n",
                "content": "It is first time for me to post my answer. If you have any suggestion, I am willing to learn and improve my code. \\u266A(\\uFF3E\\u2200\\uFF3E\\u25CF)\\uFF89\\n```\\npublic boolean isMonotonic(int[] A) {\\n        int n = A.length;\\n        if (n == 1) {\\n            return true;\\n        }\\n        \\n        int direction = Integer.compare(A[0], A[n - 1]);\\n        \\n        for (int i = 1; i < n; i++) {\\n            int compare = Integer.compare(A[i - 1], A[i]);\\n            if (compare != 0 && compare != direction) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean isMonotonic(int[] A) {\\n        int n = A.length;\\n        if (n == 1) {\\n            return true;\\n        }\\n        \\n        int direction = Integer.compare(A[0], A[n - 1]);\\n        \\n        for (int i = 1; i < n; i++) {\\n            int compare = Integer.compare(A[i - 1], A[i]);\\n            if (compare != 0 && compare != direction) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 632571,
                "title": "java-one-pass-o-n-100-w-r-t-time",
                "content": "class Solution {\\n\\n    public boolean isMonotonic(int[] A) {\\n        \\n        boolean increasing = true;\\n        boolean decreasing = true;\\n        \\n        for (int i = 0; i < A.length - 1; i ++) {\\n            if (A[i] < A[i + 1]) {\\n                decreasing = false;\\n            } \\n            \\n            if (A[i + 1] < A[i]) {\\n                increasing = false;\\n            }\\n        }\\n        \\n        return increasing || decreasing;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public boolean isMonotonic(int[] A) {\\n        \\n        boolean increasing = true;\\n        boolean decreasing = true;\\n        \\n        for (int i = 0; i < A.length - 1; i ++) {\\n            if (A[i] < A[i + 1]) {\\n                decreasing = false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 490963,
                "title": "straightforward-solution",
                "content": "```\\nbool isMonotonic(vector<int>& a)\\n{\\n\\tauto inc{a.front()<=a.back()};\\n\\tfor(auto i{1}; i<size(a); ++i)\\n\\t\\tif(a[i]<a[i-1] and inc or a[i]>a[i-1] and !inc)\\treturn false;    \\n\\treturn true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isMonotonic(vector<int>& a)\\n{\\n\\tauto inc{a.front()<=a.back()};\\n\\tfor(auto i{1}; i<size(a); ++i)\\n\\t\\tif(a[i]<a[i-1] and inc or a[i]>a[i-1] and !inc)\\treturn false;    \\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 378503,
                "title": "java-solution-100-runtime-and-memory",
                "content": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] A) {\\n        if (A.length == 1) return true;\\n        if (A[0] < A[1]) return isIncreasing(A);\\n        else if (A[0] > A[1]) return isDecreasing(A);\\n        else {\\n            if (isIncreasing(A)) return true;\\n            return isDecreasing(A);\\n        }\\n    }\\n    \\n    public boolean isIncreasing(int[] A){\\n        for (int i = 0; i < A.length-1; i++){\\n            if (!(A[i] <= A[i+1])) return false;\\n        }\\n        return true;\\n    }\\n    \\n    public boolean isDecreasing(int[] A){\\n        for (int i = 0; i < A.length-1; i++){\\n            if (!(A[i] >= A[i+1])) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] A) {\\n        if (A.length == 1) return true;\\n        if (A[0] < A[1]) return isIncreasing(A);\\n        else if (A[0] > A[1]) return isDecreasing(A);\\n        else {\\n            if (isIncreasing(A)) return true;\\n            return isDecreasing(A);\\n        }\\n    }\\n    \\n    public boolean isIncreasing(int[] A){\\n        for (int i = 0; i < A.length-1; i++){\\n            if (!(A[i] <= A[i+1])) return false;\\n        }\\n        return true;\\n    }\\n    \\n    public boolean isDecreasing(int[] A){\\n        for (int i = 0; i < A.length-1; i++){\\n            if (!(A[i] >= A[i+1])) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295733,
                "title": "java-one-pass-solution-with-two-boolean-variables",
                "content": "* Create two boolean variables to keep track of whether the array is increasing or decreasing.\\n* If the array is increasing, mark decreasing as false and if the array is decreasing, mark increasing as false.\\n* If both variables are false, then the array is neither increasing nor decreasing.\\n* At the end return whichever is true, increasing or decreasing.\\n```\\npublic boolean isMonotonic(int[] A) {\\n        boolean increasing = true, decreasing = true;\\n        for(int i = 1; i < A.length; i++) {\\n            if(A[i] > A[i - 1]) {\\n                decreasing = false;\\n            }\\n            else if(A[i] < A[i - 1]) {\\n                increasing = false;\\n            }\\n            if(!increasing && !decreasing)\\n                return false;\\n        }\\n        return increasing || decreasing;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic boolean isMonotonic(int[] A) {\\n        boolean increasing = true, decreasing = true;\\n        for(int i = 1; i < A.length; i++) {\\n            if(A[i] > A[i - 1]) {\\n                decreasing = false;\\n            }\\n            else if(A[i] < A[i - 1]) {\\n                increasing = false;\\n            }\\n            if(!increasing && !decreasing)\\n                return false;\\n        }\\n        return increasing || decreasing;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 245101,
                "title": "python3-self-explanatory",
                "content": "```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        if len(A) <= 1:\\n            return True\\n        absdiff = abs(A[-1] - A[0])\\n        \\n        diffsum = 0\\n        for i in range(len(A) - 1):\\n            diffsum += abs(A[i + 1] - A[i])\\n        \\n        return diffsum == absdiff\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        if len(A) <= 1:\\n            return True\\n        absdiff = abs(A[-1] - A[0])\\n        \\n        diffsum = 0\\n        for i in range(len(A) - 1):\\n            diffsum += abs(A[i + 1] - A[i])\\n        \\n        return diffsum == absdiff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 191397,
                "title": "javascript",
                "content": "```\nvar isMonotonic = function(A) {\n    let increase = true, decrease = true;\n    for(let i = 0; i < A.length - 1; i++) {\n        if(A[i] > A[i + 1]) increase = false;\n        if(A[i] < A[i + 1]) decrease = false;\n    }\n    return increase || decrease;\n};\n```",
                "solutionTags": [],
                "code": "```\nvar isMonotonic = function(A) {\n    let increase = true, decrease = true;\n    for(let i = 0; i < A.length - 1; i++) {\n        if(A[i] > A[i + 1]) increase = false;\n        if(A[i] < A[i + 1]) decrease = false;\n    }\n    return increase || decrease;\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 172879,
                "title": "world-needs-a-better-solution-here-it-is-java-o-n-single-pass",
                "content": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] A) {\\n        //use inc flag and dec flags.\\n        int inc=0, dec=0;\\n        for(int i=1;i<A.length;i++){\\n            if(A[i]-A[i-1] < 0){\\n                dec = 1;\\n            }else if(A[i]-A[i-1] > 0){\\n                inc = 1;\\n            }\\n        }\\n        if(inc==1 && dec==1 ) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] A) {\\n        //use inc flag and dec flags.\\n        int inc=0, dec=0;\\n        for(int i=1;i<A.length;i++){\\n            if(A[i]-A[i-1] < 0){\\n                dec = 1;\\n            }else if(A[i]-A[i-1] > 0){\\n                inc = 1;\\n            }\\n        }\\n        if(inc==1 && dec==1 ) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165942,
                "title": "java-straightforward",
                "content": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] A) {\\n        boolean inc = true, dec = true;\\n        for (int i = 0; i < A.length - 1; i++) {\\n            if (A[i] > A[i + 1]) {\\n                inc = false;\\n            }\\n            if (A[i] < A[i + 1]) {\\n                dec = false;\\n            }\\n            if (!inc && !dec) {\\n                return false;\\n            }\\n        }\\n        return inc || dec;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] A) {\\n        boolean inc = true, dec = true;\\n        for (int i = 0; i < A.length - 1; i++) {\\n            if (A[i] > A[i + 1]) {\\n                inc = false;\\n            }\\n            if (A[i] < A[i + 1]) {\\n                dec = false;\\n            }\\n            if (!inc && !dec) {\\n                return false;\\n            }\\n        }\\n        return inc || dec;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4106358,
                "title": "one-pass-most-concise-and-clean",
                "content": "```c++\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool i = true;\\n        bool d = true;\\n        \\n        int index = 0;\\n        \\n        while ((i || d) && index < nums.size() - 1) {\\n            if (d && nums[index] < nums[index + 1]) {\\n                d = false;\\n            }\\n            \\n            if (i && nums[index] > nums[index + 1]) {\\n                i = false;\\n            }\\n            \\n            index++;\\n        }\\n        \\n        return i || d || false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool i = true;\\n        bool d = true;\\n        \\n        int index = 0;\\n        \\n        while ((i || d) && index < nums.size() - 1) {\\n            if (d && nums[index] < nums[index + 1]) {\\n                d = false;\\n            }\\n            \\n            if (i && nums[index] > nums[index + 1]) {\\n                i = false;\\n            }\\n            \\n            index++;\\n        }\\n        \\n        return i || d || false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4105770,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool inc=false,dec=false;\\n        int len=nums.size();\\n\\n        if(len==1)\\n            return true;\\n        for(int i=1;i<len;i++){\\n            if(inc &&dec){\\n                return false;\\n            }\\n            if(nums[i]>nums[i-1]){\\n                inc=true;\\n            }\\n            else if(nums[i]<nums[i-1]){\\n                dec=true;\\n            }\\n            \\n        }\\n        if(inc &&dec)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        bool inc=false,dec=false;\\n        int len=nums.size();\\n\\n        if(len==1)\\n            return true;\\n        for(int i=1;i<len;i++){\\n            if(inc &&dec){\\n                return false;\\n            }\\n            if(nums[i]>nums[i-1]){\\n                inc=true;\\n            }\\n            else if(nums[i]<nums[i-1]){\\n                dec=true;\\n            }\\n            \\n        }\\n        if(inc &&dec)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4105064,
                "title": "python-3-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n\\n        # If last elemnt is greater than first\\n        # Conisdeirng it as monotonically increasing\\n        if nums[-1]>nums[0]:\\n            for i in range(len(nums)-1):\\n                if nums[i+1]<nums[i]:\\n                    return False\\n            return True\\n        # Else monotonically decreasing\\n        else:\\n            for i in range(len(nums)-1):\\n                if nums[i+1]>nums[i]:\\n                    return False\\n            return True\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n\\n        # If last elemnt is greater than first\\n        # Conisdeirng it as monotonically increasing\\n        if nums[-1]>nums[0]:\\n            for i in range(len(nums)-1):\\n                if nums[i+1]<nums[i]:\\n                    return False\\n            return True\\n        # Else monotonically decreasing\\n        else:\\n            for i in range(len(nums)-1):\\n                if nums[i+1]>nums[i]:\\n                    return False\\n            return True\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4105032,
                "title": "python-3-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        rev=sorted(nums,reverse=True)\\n        so=sorted(nums)\\n\\n        return nums==so or nums==rev\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        rev=sorted(nums,reverse=True)\\n        so=sorted(nums)\\n\\n        return nums==so or nums==rev\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4104922,
                "title": "swift-easy-to-understand-and-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    func isMonotonic(_ nums: [Int]) -> Bool {\\n        var increasing = true\\n        var decreasing = true\\n        for i in 1..<nums.count {\\n            increasing = increasing && nums[i - 1] <= nums[i]\\n            decreasing = decreasing && nums[i - 1] >= nums[i]\\n        }\\n        return increasing || decreasing\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isMonotonic(_ nums: [Int]) -> Bool {\\n        var increasing = true\\n        var decreasing = true\\n        for i in 1..<nums.count {\\n            increasing = increasing && nums[i - 1] <= nums[i]\\n            decreasing = decreasing && nums[i - 1] >= nums[i]\\n        }\\n        return increasing || decreasing\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4104338,
                "title": "c-2-approaches-explained",
                "content": "# *PLEASE UPVOTE IF IT HELPED*\\n\\n---\\n\\n\\n# Approach\\n***(Also explained in the code)***\\n\\n\\n***Approach 1:***\\n\\n1. It first checks if the first element is greater than the last element.\\n    - If it is, it loops through the array to ensure each element is greater than or equal to the previous one.\\n    - If any element violates this condition, it returns **false**.\\n1. If the first element is not greater than the last (or they are equal), it checks if the array is non-decreasing.\\n    - It does this by looping through the array and ensuring each element is less than or equal to the previous one.\\n    - If any element violates this condition, it returns **false**.\\n1. If neither of the above conditions is met, the array is monotonic, and it returns **true**.\\n\\n***Approach 2:***\\n\\n1. If the input vector has less than 2 elements, it\\'s trivially monotonic, and the function returns **true**.\\n1. It uses a direction variable to keep track of the monotonic trend: 0 for undefined, -1 for decreasing, and 1 for increasing.\\n1. It iterates through the vector, comparing each element with the previous one.\\n1. If the direction is inconsistent with the established monotonicity, the function returns **false**.\\n1. If the loop completes without returning **false**, the vector is monotonic, and the function returns **true**.\\n\\n# Complexity\\n- Time complexity:\\n1.$$O(2n)$$\\n2.$$O(n)$$\\n\\n- Space complexity:\\n1.$$O(1)$$\\n2.$$O(1)$$\\n\\n# Code\\n```\\n                --------Approach 1---------\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        // Check if the first element is greater than the last element\\n        if (nums[0] > nums[nums.size() - 1]) {\\n            // If it is, loop through the array from the second element\\n            for (int i = 1; i < nums.size(); i++) {\\n                // Check if the current element is greater than or equal to the previous element\\n                if (nums[i - 1] >= nums[i]) {\\n                    continue; // Continue the loop if it\\'s greater or equal\\n                } else {\\n                    return false; // Return false if it\\'s not monotonic\\n                }\\n            }\\n        } else {\\n            // If the first element is not greater than the last element (or they are equal)\\n            for (int i = 1; i < nums.size(); i++) {\\n                // Check if the current element is less than or equal to the previous element\\n                if (nums[i - 1] <= nums[i]) {\\n                    continue; // Continue the loop if it\\'s less or equal\\n                } else {\\n                    return false; // Return false if it\\'s not monotonic\\n                }\\n            }\\n        }\\n        return true; // If the loop completes without returning false, the array is monotonic\\n    }\\n};\\n\\n                --------Approach 2---------\\n\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        // Check if the input vector has less than 2 elements (trivially monotonic)\\n        if (nums.size() < 2) {\\n            return true;\\n        }\\n\\n        // Initialize a direction variable to track the monotonicity\\n        int direction = 0;  // 0 represents undefined direction, -1 represents decreasing, 1 represents increasing\\n\\n        // Loop through the vector starting from the second element\\n        for (int i = 1; i < nums.size(); i++) {\\n\\n            // Compare the current element with the previous one\\n            if (nums[i - 1] < nums[i]) {\\n                // If it\\'s increasing and direction was previously undefined or also increasing, set direction to increasing\\n                if (direction == 0 || direction == 1) {\\n                    direction = 1;\\n                } else {\\n                    return false; // If direction was decreasing, it\\'s not monotonic\\n                }\\n            } else if (nums[i - 1] > nums[i]) {\\n                // If it\\'s decreasing and direction was previously undefined or also decreasing, set direction to decreasing\\n                if (direction == 0 || direction == -1) {\\n                    direction = -1;\\n                } else {\\n                    return false; // If direction was increasing, it\\'s not monotonic\\n                }\\n            }\\n            // If elements are equal, no change in direction\\n        }\\n        return true; // If the loop completes without returning false, the array is monotonic\\n    }\\n};\\n\\n\\n\\n```\\n\\n# *PLEASE UPVOTE IF IT HELPED*\\n\\n---\\n---\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\n                --------Approach 1---------\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        // Check if the first element is greater than the last element\\n        if (nums[0] > nums[nums.size() - 1]) {\\n            // If it is, loop through the array from the second element\\n            for (int i = 1; i < nums.size(); i++) {\\n                // Check if the current element is greater than or equal to the previous element\\n                if (nums[i - 1] >= nums[i]) {\\n                    continue; // Continue the loop if it\\'s greater or equal\\n                } else {\\n                    return false; // Return false if it\\'s not monotonic\\n                }\\n            }\\n        } else {\\n            // If the first element is not greater than the last element (or they are equal)\\n            for (int i = 1; i < nums.size(); i++) {\\n                // Check if the current element is less than or equal to the previous element\\n                if (nums[i - 1] <= nums[i]) {\\n                    continue; // Continue the loop if it\\'s less or equal\\n                } else {\\n                    return false; // Return false if it\\'s not monotonic\\n                }\\n            }\\n        }\\n        return true; // If the loop completes without returning false, the array is monotonic\\n    }\\n};\\n\\n                --------Approach 2---------\\n\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        // Check if the input vector has less than 2 elements (trivially monotonic)\\n        if (nums.size() < 2) {\\n            return true;\\n        }\\n\\n        // Initialize a direction variable to track the monotonicity\\n        int direction = 0;  // 0 represents undefined direction, -1 represents decreasing, 1 represents increasing\\n\\n        // Loop through the vector starting from the second element\\n        for (int i = 1; i < nums.size(); i++) {\\n\\n            // Compare the current element with the previous one\\n            if (nums[i - 1] < nums[i]) {\\n                // If it\\'s increasing and direction was previously undefined or also increasing, set direction to increasing\\n                if (direction == 0 || direction == 1) {\\n                    direction = 1;\\n                } else {\\n                    return false; // If direction was decreasing, it\\'s not monotonic\\n                }\\n            } else if (nums[i - 1] > nums[i]) {\\n                // If it\\'s decreasing and direction was previously undefined or also decreasing, set direction to decreasing\\n                if (direction == 0 || direction == -1) {\\n                    direction = -1;\\n                } else {\\n                    return false; // If direction was increasing, it\\'s not monotonic\\n                }\\n            }\\n            // If elements are equal, no change in direction\\n        }\\n        return true; // If the loop completes without returning false, the array is monotonic\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4104068,
                "title": "monotonic-array-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int n= nums.length;\\n        if(n<2){\\n            return true;\\n        }\\n        boolean incrDir=true;\\n        boolean decrDir=true;\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>nums[i-1]){\\n               decrDir= false;\\n            }else if(nums[i]<nums[i-1]){\\n               incrDir = false;\\n            }\\n            if(!decrDir && !incrDir){\\n                return false;\\n            }\\n           \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int n= nums.length;\\n        if(n<2){\\n            return true;\\n        }\\n        boolean incrDir=true;\\n        boolean decrDir=true;\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>nums[i-1]){\\n               decrDir= false;\\n            }else if(nums[i]<nums[i-1]){\\n               incrDir = false;\\n            }\\n            if(!decrDir && !incrDir){\\n                return false;\\n            }\\n           \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4103950,
                "title": "accepted-5-line-java-code-beats-100",
                "content": "# Complexity\\n- Time complexity : $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```JAVA []\\nclass Solution {\\npublic boolean isMonotonic(int[] A) {\\n    int i = 1;\\n    for(; i < A.length; i++)\\n        if(A[i - 1] > A[i]) break;\\n    if(i != A.length)\\n        for(i = A.length-2; i > -1; i--)\\n            if(A[i + 1] > A[i]) return false;\\n    return true;\\n}\\n}\\n```\\n>>> ## Upvote\\uD83D\\uDC4D if you find helpful\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```JAVA []\\nclass Solution {\\npublic boolean isMonotonic(int[] A) {\\n    int i = 1;\\n    for(; i < A.length; i++)\\n        if(A[i - 1] > A[i]) break;\\n    if(i != A.length)\\n        for(i = A.length-2; i > -1; i--)\\n            if(A[i + 1] > A[i]) return false;\\n    return true;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4103660,
                "title": "short-and-crisp-code-trick-to-solve-these-problems-which-can-be-utilized-in-many-hard-problems",
                "content": "# Intuition\\nMost basic intuition is - **in an increasing or decreasing array, the product of current difference and previous difference will never be negative.**\\n\\n`(Ai - Ai-1) * (Ai+1 - Ai) >= 0; Where 0 < i < n`\\n\\n**It can be utilized in mountain array questions or where we have to find the break points (the points where the array changes from increasing to decreasing or vice-versa)**\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        if(nums.size() <= 2)return true;\\n        int prev = nums[1] - nums[0];\\n        for(int i=2; i<nums.size(); ++i){\\n            int diff = nums[i] - nums[i-1];\\n            if(1LL * prev * diff < 0)return false;\\n            if(diff != 0)prev = diff;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        if(nums.size() <= 2)return true;\\n        int prev = nums[1] - nums[0];\\n        for(int i=2; i<nums.size(); ++i){\\n            int diff = nums[i] - nums[i-1];\\n            if(1LL * prev * diff < 0)return false;\\n            if(diff != 0)prev = diff;\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4103414,
                "title": "find-monotonic-array-using-count-variable",
                "content": "# Intuition\\nIf array is strictly increasing or its strictly decreasing then return true otherwise return false.\\n\\n# Approach\\nTo solve this problem two count variables are maintained if array is increasing then increasing_count is incremented if array is decreasing then decreasing_count is decremented and in the last part we are checking if count variable is matching with number of iterations then we are returning true else it will return false.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Codea\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int increasing_count =0;\\n        int decreasing_count =0;\\n\\n        if(nums.length == 1){\\n            return true;\\n        }\\n        else{\\n            for(int i=0 ; i<nums.length-1 ; i++){\\n                if(nums[i] < nums[i+1]){\\n                    increasing_count++;\\n                }\\n                else if(nums[i] > nums[i+1]){\\n                    decreasing_count++;\\n                }\\n                else if(nums[i] == nums[i+1]){\\n                    decreasing_count++;\\n                    increasing_count++;\\n                }\\n\\n            }\\n\\n        }\\n        if(decreasing_count == nums.length - 1 || increasing_count == nums.length - 1){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int increasing_count =0;\\n        int decreasing_count =0;\\n\\n        if(nums.length == 1){\\n            return true;\\n        }\\n        else{\\n            for(int i=0 ; i<nums.length-1 ; i++){\\n                if(nums[i] < nums[i+1]){\\n                    increasing_count++;\\n                }\\n                else if(nums[i] > nums[i+1]){\\n                    decreasing_count++;\\n                }\\n                else if(nums[i] == nums[i+1]){\\n                    decreasing_count++;\\n                    increasing_count++;\\n                }\\n\\n            }\\n\\n        }\\n        if(decreasing_count == nums.length - 1 || increasing_count == nums.length - 1){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4103321,
                "title": "oops-concept-easy-code-in-c",
                "content": "# Intuition\\nThe idea to solve this problem is simple, if the first 2 element is increasing then check for increasing in the array, if they are decreasing then check for decreasing in the array otherwise check for both and return the result appropriately.\\n\\n# Approach\\nIn the approach, I have used the cocept of OOPs to write the comparator for increasing and decreasing check using the concept of virtual function in C++. Now, thic code is also extensible if we want to check the array with respect to increasing or decreasing absolute values.\\n\\n# Complexity\\n- Time Complexity: O(N)\\n\\n- Space Complexity: O(1)\\n\\n# Code\\n```\\nclass Comparator {\\n    public:\\n    virtual bool compare(int a, int b) = 0;\\n};\\n\\nclass IncreasingComparator : public Comparator {\\n    public:\\n    bool compare(int a, int b) {\\n        return a <= b;\\n    }\\n};\\n\\nclass DecreasingComparator : public Comparator {\\n    public:\\n    bool compare(int a, int b) {\\n        return a >= b;\\n    }\\n};\\n\\nclass Solution {\\n\\n    bool isMonotonic(vector<int> nums, Comparator *comparator) {\\n        int N = nums.size();\\n        for(int i = 0; i < N - 1; i++) {\\n            if(!(comparator->compare(nums[i], nums[i + 1]))) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\npublic:\\n    bool isMonotonic(vector<int> &nums) {\\n        if(nums.size() == 1) return true;\\n        if(nums[0] < nums[1]) {\\n            return isMonotonic(nums, new IncreasingComparator());\\n        } else if(nums[0] < nums[1]) {\\n            return isMonotonic(nums, new DecreasingComparator());\\n        } else {\\n            return isMonotonic(nums, new IncreasingComparator()) or isMonotonic(nums, new DecreasingComparator());\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Comparator {\\n    public:\\n    virtual bool compare(int a, int b) = 0;\\n};\\n\\nclass IncreasingComparator : public Comparator {\\n    public:\\n    bool compare(int a, int b) {\\n        return a <= b;\\n    }\\n};\\n\\nclass DecreasingComparator : public Comparator {\\n    public:\\n    bool compare(int a, int b) {\\n        return a >= b;\\n    }\\n};\\n\\nclass Solution {\\n\\n    bool isMonotonic(vector<int> nums, Comparator *comparator) {\\n        int N = nums.size();\\n        for(int i = 0; i < N - 1; i++) {\\n            if(!(comparator->compare(nums[i], nums[i + 1]))) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\npublic:\\n    bool isMonotonic(vector<int> &nums) {\\n        if(nums.size() == 1) return true;\\n        if(nums[0] < nums[1]) {\\n            return isMonotonic(nums, new IncreasingComparator());\\n        } else if(nums[0] < nums[1]) {\\n            return isMonotonic(nums, new DecreasingComparator());\\n        } else {\\n            return isMonotonic(nums, new IncreasingComparator()) or isMonotonic(nums, new DecreasingComparator());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4103096,
                "title": "simple-c-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to determine whether the given array nums is monotonic, meaning it is entirely non-increasing or non-decreasing. To solve this, we can iterate through the array, keeping track of whether the array is increasing or decreasing. If at any point we encounter a violation of the chosen order, the array is not monotonic.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize Variables: We start by initializing a variable `res` to 0, which will keep track of the ordering (`0 for not determined`, `1 for increasing`, and `-1 for decreasing`). Also, we get the size of the input array nums.\\n\\n2. Iterate Through the Array: We traverse the array from index 0 to n-2 (where n is the size of the array) to compare each element with the next one.\\n\\n3. Compare Elements:\\n\\n    - If the current element is greater than the next element (`nums[i] > nums[i+1]`), it means we have a `decreasing` order. We update `res to -1` accordingly.\\n    - If the current element is less than the next element (`nums[i] < nums[i+1]`), it means we have an `increasing` order. We update `res to 1` accordingly.\\nCheck for Conflicting Orders:\\n\\nIf we encounter a conflicting order (e.g., increasing followed by decreasing or vice versa), we return false since the array is not monotonic.\\nReturn Result:\\n\\nIf we traverse the entire array without encountering any conflicts, we return true, indicating that the array is monotonic.\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int res = 0;\\n        int n = nums.size();\\n        for(int i =0;i<n-1; i++){\\n            if(nums[i] > nums[i+1]){\\n                if(res == 0) res = -1;\\n                else if(res == 1) return false;\\n            }\\n            else if(nums[i] < nums[i+1]){\\n                if(res == 0) res = 1;\\n                else if(res == -1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int res = 0;\\n        int n = nums.size();\\n        for(int i =0;i<n-1; i++){\\n            if(nums[i] > nums[i+1]){\\n                if(res == 0) res = -1;\\n                else if(res == 1) return false;\\n            }\\n            else if(nums[i] < nums[i+1]){\\n                if(res == 0) res = 1;\\n                else if(res == -1) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744092,
                "title": "monotonic-array-i",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean increasing = true;\\n        boolean decreasing = true;\\n\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] > nums[i + 1]) {\\n                increasing = false;\\n            }\\n            if (nums[i] < nums[i + 1]) {\\n                decreasing = false;\\n            }\\n        }\\n\\n        return increasing || decreasing;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        boolean increasing = true;\\n        boolean decreasing = true;\\n\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] > nums[i + 1]) {\\n                increasing = false;\\n            }\\n            if (nums[i] < nums[i + 1]) {\\n                decreasing = false;\\n            }\\n        }\\n\\n        return increasing || decreasing;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668199,
                "title": "100-beats-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n\\n        for(int i = 0; i < nums.length - 1; i++){\\n            if(nums[i] < nums[i + 1]) {\\n                \\n                for(int j = i + 1; j < nums.length - 1; j++){\\n                    if(nums[j] > nums[j + 1]) return false;\\n                }\\n\\n                return true;\\n            }\\n            else if(nums[i] > nums[i + 1]) {\\n                \\n                for(int j = i + 1; j < nums.length - 1; j++){\\n                    if(nums[j] < nums[j + 1]) return false;\\n                }\\n\\n                return true;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n\\n        for(int i = 0; i < nums.length - 1; i++){\\n            if(nums[i] < nums[i + 1]) {\\n                \\n                for(int j = i + 1; j < nums.length - 1; j++){\\n                    if(nums[j] > nums[j + 1]) return false;\\n                }\\n\\n                return true;\\n            }\\n            else if(nums[i] > nums[i + 1]) {\\n                \\n                for(int j = i + 1; j < nums.length - 1; j++){\\n                    if(nums[j] < nums[j + 1]) return false;\\n                }\\n\\n                return true;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538757,
                "title": "might-be-an-overkill",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        vector<int> a,b;\\n        a=b=nums;\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end(),greater<int>());\\n        \\n        if(a==nums || b==nums)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        vector<int> a,b;\\n        a=b=nums;\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end(),greater<int>());\\n        \\n        if(a==nums || b==nums)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531698,
                "title": "easy-c-solution",
                "content": "# Intuition\\nCheck if the array is moving in backward direction or foward direction \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1)If size=0 then return true\\n2)Use a for loop to check foward direction if yes then continue till loop end and after thaty check if i =n-1 if yes then return true\\n3)Use a for loop to check backward direction if yes then continue till loop end and after thaty check if i =n-1 if yes then return true\\n4)If none of them work return false\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) \\n    {\\n      int n=nums.size();\\n      if(n==0){return true;}\\n      int i;\\n        for(i =0;i<n-1;i++)\\n            {\\n                if(nums[i]>=nums[i+1])\\n                continue;\\n                else\\n                break; \\n            }\\n            if(i==n-1)return true;\\n             for(i =0;i<n-1;i++)\\n            {\\n                if(nums[i]<=nums[i+1])\\n                continue;\\n                else\\n                break;\\n            }     if(i==n-1)return true;       \\n    return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) \\n    {\\n      int n=nums.size();\\n      if(n==0){return true;}\\n      int i;\\n        for(i =0;i<n-1;i++)\\n            {\\n                if(nums[i]>=nums[i+1])\\n                continue;\\n                else\\n                break; \\n            }\\n            if(i==n-1)return true;\\n             for(i =0;i<n-1;i++)\\n            {\\n                if(nums[i]<=nums[i+1])\\n                continue;\\n                else\\n                break;\\n            }     if(i==n-1)return true;       \\n    return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519628,
                "title": "100-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n\\n        for(int i = 0; i < nums.length - 1; i++){\\n            if(nums[i] < nums[i + 1]) {\\n                \\n                for(int j = i + 1; j < nums.length - 1; j++){\\n                    if(nums[j] > nums[j + 1]) return false;\\n                }\\n\\n                return true;\\n            }else if(nums[i] > nums[i + 1]) {\\n                \\n                for(int j = i + 1; j < nums.length - 1; j++){\\n                    if(nums[j] < nums[j + 1]) return false;\\n                }\\n\\n                return true;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n\\n        for(int i = 0; i < nums.length - 1; i++){\\n            if(nums[i] < nums[i + 1]) {\\n                \\n                for(int j = i + 1; j < nums.length - 1; j++){\\n                    if(nums[j] > nums[j + 1]) return false;\\n                }\\n\\n                return true;\\n            }else if(nums[i] > nums[i + 1]) {\\n                \\n                for(int j = i + 1; j < nums.length - 1; j++){\\n                    if(nums[j] < nums[j + 1]) return false;\\n                }\\n\\n                return true;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396758,
                "title": "fastest-solution-with-java-as-unique-way",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        \\n        for(int a = 0; a < nums.length-1; a++){\\n            int diff1 = nums[a+1]-nums[a];// First value that representing difference\\n            \\n            while(diff1 == 0){// Control for difference without 0\\n                a++;\\n                if(a+1==nums.length){\\n                    return true;\\n                }\\n                diff1 = nums[a+1]-nums[a];\\n            }\\n            if(diff1>0){// Control for other differences\\n                for(int b = a+1; b < nums.length-1; b++){// If difference is different we will return false;\\n                    int diff2 =  nums[b+1]-nums[b];\\n                    if(diff2<0){\\n                        return false;\\n                    }\\n                }\\n                return true;\\n            }else if(diff1<0){\\n                for(int b = a+1; b < nums.length-1; b++){\\n                    int diff2 =  nums[b+1]-nums[b];\\n                    if(diff2>0){\\n                        return false;\\n                    }\\n                }\\n                return true;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        \\n        for(int a = 0; a < nums.length-1; a++){\\n            int diff1 = nums[a+1]-nums[a];// First value that representing difference\\n            \\n            while(diff1 == 0){// Control for difference without 0\\n                a++;\\n                if(a+1==nums.length){\\n                    return true;\\n                }\\n                diff1 = nums[a+1]-nums[a];\\n            }\\n            if(diff1>0){// Control for other differences\\n                for(int b = a+1; b < nums.length-1; b++){// If difference is different we will return false;\\n                    int diff2 =  nums[b+1]-nums[b];\\n                    if(diff2<0){\\n                        return false;\\n                    }\\n                }\\n                return true;\\n            }else if(diff1<0){\\n                for(int b = a+1; b < nums.length-1; b++){\\n                    int diff2 =  nums[b+1]-nums[b];\\n                    if(diff2>0){\\n                        return false;\\n                    }\\n                }\\n                return true;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277276,
                "title": "simple-process-o-n-runtime-easy-solution-java",
                "content": "- 371/371 cases passed (2 ms)\\n- Your runtime beats 68.66 % of java submissions\\n- Your memory usage beats 68.13 % of java submissions (52.5 MB)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int len=nums.length;\\n        \\n        if(len<2)\\n            return true;\\n        boolean asc=nums[0]<nums[len-1];\\n\\n        for(int i=0;i<len-1;i++)\\n            if(nums[i]==nums[i+1]) continue;\\n            else if(asc!=(nums[i]<nums[i+1]))\\n                return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int len=nums.length;\\n        \\n        if(len<2)\\n            return true;\\n        boolean asc=nums[0]<nums[len-1];\\n\\n        for(int i=0;i<len-1;i++)\\n            if(nums[i]==nums[i+1]) continue;\\n            else if(asc!=(nums[i]<nums[i+1]))\\n                return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240300,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n\\n    bool inc=true;\\n    bool dec=true;\\n\\n    if (nums.size() == 1)\\n        return true;\\n    else\\n    {\\n            for (int i = 0; i < nums.size() - 1; i++)\\n            {\\n                if (nums[i] > nums[i + 1])\\n                    inc=false;\\n            }\\n            for (int i = 0; i < nums.size() - 1; i++)\\n            {\\n                if (nums[i] < nums[i + 1])\\n                    dec=false;\\n            }\\n    }\\n    return (inc || dec);\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n\\n    bool inc=true;\\n    bool dec=true;\\n\\n    if (nums.size() == 1)\\n        return true;\\n    else\\n    {\\n            for (int i = 0; i < nums.size() - 1; i++)\\n            {\\n                if (nums[i] > nums[i + 1])\\n                    inc=false;\\n            }\\n            for (int i = 0; i < nums.size() - 1; i++)\\n            {\\n                if (nums[i] < nums[i + 1])\\n                    dec=false;\\n            }\\n    }\\n    return (inc || dec);\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038523,
                "title": "easy-to-understand-c-sollution-beats-99-95",
                "content": "```\\nUpvote if it was useful :)\\n```\\n# Approach\\nFirst Search for the increment and decrement point in the array and then from that check the remaining array if it\\'s monotone increasing or monotone decreasing.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public:\\n    Solution()//Fast IO\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n    }\\n\\n    bool isMonotonic(vector<int>& nums) \\n    {\\n        if(nums.size()==1)\\n        {\\n            return true;\\n        }\\n\\n        int i=0,j=1;\\n        while( j<nums.size() && nums[i]==nums[j])// break point is searched\\n        {\\n            // getting indexes\\n            i++;\\n            j++;\\n        }\\n\\n\\n        if(j<nums.size() && nums[i]>nums[j])//determining whether increasing or decreasing\\n        {\\n            while(j<nums.size())\\n            {\\n                if(nums[i]<nums[j])\\n                {\\n                    return false;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        else if(j<nums.size())\\n        {\\n            while(j<nums.size())\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    return false;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nUpvote if it was useful :)\\n```\n```\\nclass Solution \\n{\\n    public:\\n    Solution()//Fast IO\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n    }\\n\\n    bool isMonotonic(vector<int>& nums) \\n    {\\n        if(nums.size()==1)\\n        {\\n            return true;\\n        }\\n\\n        int i=0,j=1;\\n        while( j<nums.size() && nums[i]==nums[j])// break point is searched\\n        {\\n            // getting indexes\\n            i++;\\n            j++;\\n        }\\n\\n\\n        if(j<nums.size() && nums[i]>nums[j])//determining whether increasing or decreasing\\n        {\\n            while(j<nums.size())\\n            {\\n                if(nums[i]<nums[j])\\n                {\\n                    return false;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        else if(j<nums.size())\\n        {\\n            while(j<nums.size())\\n            {\\n                if(nums[i]>nums[j])\\n                {\\n                    return false;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925225,
                "title": "easy-c-solution",
                "content": "\\n## Code 1\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        if (nums.size()<=2) return true;\\n        bool inc= 1;\\n        int i=0;\\n        while (i+1<nums.size() && nums[i]==nums[i+1])++i;\\n        if (i== nums.size()-1)return true;\\n        if (nums[i]>nums[i+1])inc=0;\\n        for (;i+1<nums.size(); i++){\\n            if (inc==1){\\n                if (nums[i]>nums[i+1])return false;\\n            }\\n            else{\\n                if (nums[i]<nums[i+1])return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n## Code 2\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        if (nums.size()<=2) return true;\\n        bool is_increasing= 1;\\n        if (nums[0] > nums.back())is_increasing=0;\\n        for (int i=0; i<nums.size()-1; i++){\\n            if (is_increasing){\\n                if (nums[i]>nums[i+1])return false;\\n            }\\n            else{\\n                if (nums[i]<nums[i+1])return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n### Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        if (nums.size()<=2) return true;\\n        bool inc= 1;\\n        int i=0;\\n        while (i+1<nums.size() && nums[i]==nums[i+1])++i;\\n        if (i== nums.size()-1)return true;\\n        if (nums[i]>nums[i+1])inc=0;\\n        for (;i+1<nums.size(); i++){\\n            if (inc==1){\\n                if (nums[i]>nums[i+1])return false;\\n            }\\n            else{\\n                if (nums[i]<nums[i+1])return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        if (nums.size()<=2) return true;\\n        bool is_increasing= 1;\\n        if (nums[0] > nums.back())is_increasing=0;\\n        for (int i=0; i<nums.size()-1; i++){\\n            if (is_increasing){\\n                if (nums[i]>nums[i+1])return false;\\n            }\\n            else{\\n                if (nums[i]<nums[i+1])return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704501,
                "title": "solution-in-python-fastest-solution",
                "content": "```\\nclass Solution(object):\\n    def isMonotonic(self, nums):\\n        n=len(nums)\\n        p=0\\n        g=0\\n        for i in range(n-1):\\n            if(p==0): #checking for if it is in ascending or descending order\\n                if nums[i]==nums[i+1]:\\n                    continue\\n                elif nums[i]<nums[i+1]:\\n                    g=1\\n                    p=1\\n                else:\\n                    g=0\\n                    p=1\\n            else:\\n                if nums[i]<nums[i+1] and g==0:\\n                    return False\\n                if nums[i]>nums[i+1] and g==1:\\n                    return False\\n        return True        \\n                    z\\n        \\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isMonotonic(self, nums):\\n        n=len(nums)\\n        p=0\\n        g=0\\n        for i in range(n-1):\\n            if(p==0): #checking for if it is in ascending or descending order\\n                if nums[i]==nums[i+1]:\\n                    continue\\n                elif nums[i]<nums[i+1]:\\n                    g=1\\n                    p=1\\n                else:\\n                    g=0\\n                    p=1\\n            else:\\n                if nums[i]<nums[i+1] and g==0:\\n                    return False\\n                if nums[i]>nums[i+1] and g==1:\\n                    return False\\n        return True        \\n                    z\\n        \\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2677841,
                "title": "easy-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n       bool inc=true;\\n        bool dec=true;\\n        int i;\\n       for(i=0;i<nums.size()-1;i++)   \\n        {\\n            if(nums[i]>nums[i+1])\\n            \\n                inc=false;\\n            \\n            else if(nums[i]<nums[i+1])\\n            \\n                dec=false;\\n            \\n             if(inc==false && dec==false)\\n                 return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n       bool inc=true;\\n        bool dec=true;\\n        int i;\\n       for(i=0;i<nums.size()-1;i++)   \\n        {\\n            if(nums[i]>nums[i+1])\\n            \\n                inc=false;\\n            \\n            else if(nums[i]<nums[i+1])\\n            \\n                dec=false;\\n            \\n             if(inc==false && dec==false)\\n                 return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570142,
                "title": "js-simple-solution-with-o-n",
                "content": "```\\nconst CONST = {\\n    EQUAL: \\'EQUAL\\',\\n    DECREASING: \\'DECREASING\\',\\n    INCREASING: \\'INCREASING\\',\\n}\\n\\nvar isMonotonic = function(nums) {\\n    let status = CONST.EQUAL;\\n\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        if (nums[i] < nums[i + 1] && [CONST.EQUAL,CONST.INCREASING].includes(status)) {\\n            status = CONST.INCREASING;\\n        } else if (nums[i] > nums[i + 1] && [CONST.EQUAL, CONST.DECREASING].includes(status)) {\\n            status = CONST.DECREASING;\\n        } else if (nums[i] !== nums[i + 1]) {\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst CONST = {\\n    EQUAL: \\'EQUAL\\',\\n    DECREASING: \\'DECREASING\\',\\n    INCREASING: \\'INCREASING\\',\\n}\\n\\nvar isMonotonic = function(nums) {\\n    let status = CONST.EQUAL;\\n\\n    for (let i = 0; i < nums.length - 1; i++) {\\n        if (nums[i] < nums[i + 1] && [CONST.EQUAL,CONST.INCREASING].includes(status)) {\\n            status = CONST.INCREASING;\\n        } else if (nums[i] > nums[i + 1] && [CONST.EQUAL, CONST.DECREASING].includes(status)) {\\n            status = CONST.DECREASING;\\n        } else if (nums[i] !== nums[i + 1]) {\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2565016,
                "title": "with-explanation-comments-time-247-ms-60-49-space-96-4-mb-65-83",
                "content": "**Like it? ->Upvote please!** \\u30C4\\n\\n**Solution 1: Two passes**\\n\\n\\nTime: 380 ms (10.93%), Space: 104.4 MB (6.47%) \\nTC: O(n)   //iterate the array\\nSC: O(1)\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    \\n    bool decreasing(vector<int> nums){\\n        \\n        //loop over the whole array elements\\n        for(int i=0;i<nums.size()-1;i++)\\n            //check if the array elements is decresing or not\\n            if(nums[i]>nums[i+1])\\n                //if not-> false\\n                return false;\\n        \\n        //if yes-> true\\n        return true;\\n    }\\n    \\n    bool increasing(vector<int> nums){\\n        \\n        //loop over the whole array elements\\n        for(int i=0;i<nums.size()-1;i++)\\n            //check if the array elements is incresing or not\\n            if(nums[i]<nums[i+1])\\n                //if not-> false\\n                return false;\\n        \\n        //if yes-> true\\n        return true;\\n    }\\n    \\n    bool isMonotonic(vector<int>& nums) {\\n        \\n        //check if the array elements are either ALL increasing or ALL decreasing\\n        return increasing(nums) || decreasing(nums);\\n   \\n    }\\n};\\n\\'\\'\\'\\n\\n**Solution 2: One pass**\\n\\n\\nTime: 247 ms (60.49%), Space: 96.4 MB (65.83%)\\nTC: O(n)   //iterate the array\\nSC: O(1)\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        \\n        //initialize two boolean flags with initial values of true\\n        bool inc=true, dec=true;\\n        \\n        //loop over the whole array elements\\n        for(int i=0;i<nums.size()-1;i++){\\n            \\n            //check if the array elements aren\\'t in increasing order\\n            if(nums[i]>nums[i+1])\\n                inc=false;\\n            //check if the array elements aren\\'t in increasing order\\n            if(nums[i]<nums[i+1])\\n                //dec flag is off\\n                dec=false;\\n        }\\n        \\n        //retrun if there\\'s a true value of either ALL increasing or ALL decreasing\\n        return inc || dec;\\n    }\\n};\\n\\'\\'\\'\\n\\n\\n**Like it? ->Upvote please!** \\u30C4\\n**If still not understood, feel free to comment. I will help you out**\\n**Happy Coding :)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool decreasing(vector<int> nums){\\n        \\n        //loop over the whole array elements\\n        for(int i=0;i<nums.size()-1;i++)\\n            //check if the array elements is decresing or not\\n            if(nums[i]>nums[i+1])\\n                //if not-> false\\n                return false;\\n        \\n        //if yes-> true\\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2521034,
                "title": "c-simple-solution-using-is-sorted-function",
                "content": "# Simple use of is_sorted() function\\n```\\n#include <vector>  \\n#include <algorithm>  \\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        if(is_sorted(nums.begin(), nums.end()))  // check for ascending order\\n            return true;\\n        else if(is_sorted(nums.begin(),nums.end(),greater<int>()))  //check for descending\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include <vector>  \\n#include <algorithm>  \\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        if(is_sorted(nums.begin(), nums.end()))  // check for ascending order\\n            return true;\\n        else if(is_sorted(nums.begin(),nums.end(),greater<int>()))  //check for descending\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2497338,
                "title": "java-1-ms-beats-100-easy-lol",
                "content": "```\\nint count = 0 ;\\n        //we take count variable ;\\n        \\n        //first we iterate and check for monotonically increasing array ;\\n        for(int i = 0 ; i < nums.length -1 ; i++){\\n            if(nums[i]<=nums[i+1]){\\n                continue ;\\n            }else{\\n                count ++;\\n                break ;\\n            }\\n        }\\n        //then we iterate and check for monotonically decreasing array ;\\n        for(int i = 0 ; i < nums.length -1 ; i++){\\n            if(nums[i]>=nums[i+1]){\\n                continue; \\n            }else{\\n                count ++;\\n                break ;\\n            }\\n        }\\n        //if count == 2 then that means it broke out of both the loops so its not monotonic array ;else we return true ;\\n        if(count == 2){\\n           return false;\\n        }else{\\n            return true;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint count = 0 ;\\n        //we take count variable ;\\n        \\n        //first we iterate and check for monotonically increasing array ;\\n        for(int i = 0 ; i < nums.length -1 ; i++){\\n            if(nums[i]<=nums[i+1]){\\n                continue ;\\n            }else{\\n                count ++;\\n                break ;\\n            }\\n        }\\n        //then we iterate and check for monotonically decreasing array ;\\n        for(int i = 0 ; i < nums.length -1 ; i++){\\n            if(nums[i]>=nums[i+1]){\\n                continue; \\n            }else{\\n                count ++;\\n                break ;\\n            }\\n        }\\n        //if count == 2 then that means it broke out of both the loops so its not monotonic array ;else we return true ;\\n        if(count == 2){\\n           return false;\\n        }else{\\n            return true;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2495159,
                "title": "two-naughty-solutions-in-java-concise-and-easy",
                "content": "Solution 1:\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int n=nums.length,i,incr=0,decr=0,eq=0;\\n        for(i=1;i<n;i++){\\n            if(nums[i-1]<nums[i]) incr++;\\n            else if(nums[i-1]>nums[i]) decr++;\\n            if(incr > 0 && decr > 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\nSolution 2:\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        Integer num[] = new Integer[nums.length], numm[] = new Integer[nums.length];\\n        for(int i=0;i<nums.length;num[i]=numm[i]=nums[i],i++);\\n        Arrays.sort(numm); Arrays.sort(num,(a,b)->b-a);\\n        return Arrays.toString(numm).equals(Arrays.toString(nums)) || Arrays.toString(num).equals(Arrays.toString(nums));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        int n=nums.length,i,incr=0,decr=0,eq=0;\\n        for(i=1;i<n;i++){\\n            if(nums[i-1]<nums[i]) incr++;\\n            else if(nums[i-1]>nums[i]) decr++;\\n            if(incr > 0 && decr > 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        Integer num[] = new Integer[nums.length], numm[] = new Integer[nums.length];\\n        for(int i=0;i<nums.length;num[i]=numm[i]=nums[i],i++);\\n        Arrays.sort(numm); Arrays.sort(num,(a,b)->b-a);\\n        return Arrays.toString(numm).equals(Arrays.toString(nums)) || Arrays.toString(num).equals(Arrays.toString(nums));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2435863,
                "title": "c-5-line-code-without-loop-or-anything-super-easy-documented",
                "content": "There is only 2 condition: \\n1. All previous elements are less or equal than current element.\\n2. Or all previous elements are greater or equal than current element.\\n\\nThat mean the **array shoud be sorted in accending order or in decending order**.........That\\'s it.\\n\\n```\\nbool isMonotonic(vector<int>& nums) {\\n        \\n        vector<int> temp = nums;\\n        sort(temp.begin(), temp.end());\\n        \\n        if(nums == temp) return 1;\\n        reverse(temp.begin(), temp.end());\\n        if(nums == temp) return 1;\\n        \\n        return 0;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isMonotonic(vector<int>& nums) {\\n        \\n        vector<int> temp = nums;\\n        sort(temp.begin(), temp.end());\\n        \\n        if(nums == temp) return 1;\\n        reverse(temp.begin(), temp.end());\\n        if(nums == temp) return 1;\\n        \\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2151355,
                "title": "monotonic-array",
                "content": "This is done in the following way:\\n* Check for any disruption of the given condition in the first case that is for the increasing order of array. Take pointer pointing to the 1st index element and check if the condition doesn\\'t satisfy (i.e. arr[i-1]<=arr[i]) considering the previous adjacent element using a bool variable.\\n* Now take the second case i.e. for the decreasing order of the array. Follow the same method as of the increasing case. Take another bool variable that takes account of this condition (i.e. arr[i-1] > arr[i]).\\n* Now we can see that an array can\\'t be monotonically increasing or decreasing at the same time so we need to use the \\'or\\' operator to get the desired result.\\n\\nImplementation is as follows:\\n```\\nbool isMonotonic(vector<int>& nums) {\\n        bool monoInc=true, monoDec=true;\\n\\t\\t\\n\\t\\t//checking for monotonically increasing\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i-1]> nums[i]){\\n                monoInc=false;\\n            }\\n        }\\n\\t\\t\\n\\t\\t//check for monotonically decreasing\\n        for(int i=1; i<nums.size();i++){\\n            if(nums[i-1]<nums[i]){\\n                monoDec=false;\\n            }\\n        }\\n        return monoInc or monoDec;\\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isMonotonic(vector<int>& nums) {\\n        bool monoInc=true, monoDec=true;\\n\\t\\t\\n\\t\\t//checking for monotonically increasing\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i-1]> nums[i]){\\n                monoInc=false;\\n            }\\n        }\\n\\t\\t\\n\\t\\t//check for monotonically decreasing\\n        for(int i=1; i<nums.size();i++){\\n            if(nums[i-1]<nums[i]){\\n                monoDec=false;\\n            }\\n        }\\n        return monoInc or monoDec;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2150286,
                "title": "c-easy-to-understand-one-pass",
                "content": "First check if it should be increasing or decreasing by looking at the two ends.\\nChecking the first two elements is also possible, but be aware of the special case where only one element exists.\\nIf it should be increasing but you found nums[i] > nums[i + 1], it\\'s not monotonic.\\nSame goes with the decreasing case.\\n\\n**Code:**\\n```\\nclass Solution {\\n public:\\n  bool IsMonotonic(const vector<int> &nums) {\\n    const int n = nums.size();\\n    if (nums.front() <= nums.back()) {\\n      for (int i = 0; i < n - 1; i++)\\n        if (nums[i] > nums[i + 1]) return false;\\n    } else {\\n      for (int i = 0; i < n - 1; i++)\\n        if (nums[i] < nums[i + 1]) return false;\\n    }\\n    return true;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  bool IsMonotonic(const vector<int> &nums) {\\n    const int n = nums.size();\\n    if (nums.front() <= nums.back()) {\\n      for (int i = 0; i < n - 1; i++)\\n        if (nums[i] > nums[i + 1]) return false;\\n    } else {\\n      for (int i = 0; i < n - 1; i++)\\n        if (nums[i] < nums[i + 1]) return false;\\n    }\\n    return true;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130646,
                "title": "easy-java-solution-beginner-friendly",
                "content": "* class Solution {\\n*     public boolean isMonotonic(int[] nums) {\\n*         boolean inc = false;\\n*         boolean dec = false;\\n*         \\n*         for (int i = 0; i < nums.length - 1; i++) {\\n*             if (nums[i+1] > nums[i]) inc = true;\\n*             if (nums[i+1] < nums[i]) dec = true;\\n*             if (inc && dec) return false;\\n*         }\\n*         \\n*         return true;\\n*     }\\n* }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n*     public boolean isMonotonic(int[] nums) {\\n*         boolean inc = false;\\n*         boolean dec = false;\\n*         \\n*         for (int i = 0; i < nums.length - 1; i++) {\\n*             if (nums[i+1] > nums[i]) inc = true;\\n*             if (nums[i+1] < nums[i]) dec = true;\\n*             if (inc && dec) return false;\\n*         }",
                "codeTag": "Java"
            },
            {
                "id": 2067734,
                "title": "monotonic-array-t-o-n-s-o-1",
                "content": "```\\nclass Solution:\\n    #T=O(n), S=O(1)\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        #we don\\'t know if the array is monotonic increasing or decreasing\\n        #check both scenarios\\n        increasing, decreasing = True, True\\n        #iterate from index 0 to len-2 (range() excludes the last position)\\n        for i in range(len(nums)-1):\\n            #monotonic increasing should have next item greater than or equal to current item\\n            if nums[i+1] < nums[i]:\\n                increasing = False\\n            #monotonic decreasing should have next item lesser than or equal to current item\\n            if nums[i+1] > nums[i]:\\n                decreasing = False\\n        #either of condition should be Truthy for monotonicity\\n        return increasing or decreasing\\n```\\n\\n```\\nclass Solution:\\n    #T=O(n),S=O(n)\\n    #monostack\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        i_stack = []\\n        d_stack = []\\n        increasing = decreasing = True\\n        \\n        #mono increasing\\n        for n in nums:\\n            while i_stack and i_stack[-1] > n:\\n                increasing = False\\n                break\\n            if not increasing: \\n                break\\n            i_stack.append(n)\\n            \\n\\n        #mono decreasing\\n        for n in nums:\\n            while d_stack and d_stack[-1] < n:\\n                decreasing = False\\n                break\\n            if not decreasing: \\n                break\\n            d_stack.append(n)\\n        \\n        return increasing or decreasing\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    #T=O(n), S=O(1)\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        #we don\\'t know if the array is monotonic increasing or decreasing\\n        #check both scenarios\\n        increasing, decreasing = True, True\\n        #iterate from index 0 to len-2 (range() excludes the last position)\\n        for i in range(len(nums)-1):\\n            #monotonic increasing should have next item greater than or equal to current item\\n            if nums[i+1] < nums[i]:\\n                increasing = False\\n            #monotonic decreasing should have next item lesser than or equal to current item\\n            if nums[i+1] > nums[i]:\\n                decreasing = False\\n        #either of condition should be Truthy for monotonicity\\n        return increasing or decreasing\\n```\n```\\nclass Solution:\\n    #T=O(n),S=O(n)\\n    #monostack\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        i_stack = []\\n        d_stack = []\\n        increasing = decreasing = True\\n        \\n        #mono increasing\\n        for n in nums:\\n            while i_stack and i_stack[-1] > n:\\n                increasing = False\\n                break\\n            if not increasing: \\n                break\\n            i_stack.append(n)\\n            \\n\\n        #mono decreasing\\n        for n in nums:\\n            while d_stack and d_stack[-1] < n:\\n                decreasing = False\\n                break\\n            if not decreasing: \\n                break\\n            d_stack.append(n)\\n        \\n        return increasing or decreasing\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024441,
                "title": "c-easy-solution",
                "content": "\\tbool isMonotonic(vector<int>& nums) {\\n        bool isInc = false;\\n        bool isDec = false;\\n        for (int i = 0; i < nums.size()-1; i++) {\\n            if (nums[i] > nums[i+1]) isDec = true;\\n            else if (nums[i] < nums[i+1]) isInc = true;\\n        }\\n        return !(isInc && isDec);\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tbool isMonotonic(vector<int>& nums) {\\n        bool isInc = false;\\n        bool isDec = false;\\n        for (int i = 0; i < nums.size()-1; i++) {\\n            if (nums[i] > nums[i+1]) isDec = true;\\n            else if (nums[i] < nums[i+1]) isInc = true;\\n        }\\n        return !(isInc && isDec);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1970573,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Solution {\\n\\n    public boolean isMonotonic(int[] A) {\\n     boolean increasing = false, decreasing = false;\\n     for(int i = 1; i< A.length; i++){\\n         if(A[i] < A[i-1]) decreasing = true;\\n         if(A[i] > A[i-1]) increasing = true;\\n     }\\n     return increasing && decreasing ? false: true;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public boolean isMonotonic(int[] A) {\\n     boolean increasing = false, decreasing = false;\\n     for(int i = 1; i< A.length; i++){\\n         if(A[i] < A[i-1]) decreasing = true;\\n         if(A[i] > A[i-1]) increasing = true;\\n     }",
                "codeTag": "Java"
            },
            {
                "id": 1844612,
                "title": "python-o-n-easy",
                "content": "**1.** **We just need to check if there is both increasing and decreasing sequence in `nums`.**\\n**2.** **The answer is `False` iff there is both the sequence in `nums` else it is `True`.**\\n##### Code in Python:\\n```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        inc = dec = False\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                inc = True\\n            if nums[i] < nums[i-1]:\\n                dec = True\\n        return False if inc and dec else True\\n    \\n    # TC: O(N)\\n    # SC: O(1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        inc = dec = False\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i-1]:\\n                inc = True\\n            if nums[i] < nums[i-1]:\\n                dec = True\\n        return False if inc and dec else True\\n    \\n    # TC: O(N)\\n    # SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801447,
                "title": "problem-no-896-easy-solution-for-beginners-c",
                "content": "```\\nclass Solution{\\npublic:\\n    bool isMonotonic(vector<int> &nums){\\n        int len = nums.size();\\n        int increasing = 1, decreasing = 1;\\n        for(int i = 0; i < len-1; i++){\\n            if (nums[i] <= nums[i+1]){\\n                increasing++;\\n            } \\n            if (nums[i] >= nums[i+1]){\\n                decreasing++;\\n            }\\n        }\\n        if(increasing == len || decreasing == len){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n***Please upvote if it was helpful for you, thank you!***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    bool isMonotonic(vector<int> &nums){\\n        int len = nums.size();\\n        int increasing = 1, decreasing = 1;\\n        for(int i = 0; i < len-1; i++){\\n            if (nums[i] <= nums[i+1]){\\n                increasing++;\\n            } \\n            if (nums[i] >= nums[i+1]){\\n                decreasing++;\\n            }\\n        }\\n        if(increasing == len || decreasing == len){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785987,
                "title": "python-one-pass-solution",
                "content": "```\\nclass Solution:\\n    def isMonotonic(self, a: List[int]) -> bool:\\n        \\n        if len(a) < 3:\\n            return True\\n        \\n        is_monotonically_increasing = True\\n        is_monotonically_decreasing = True\\n        \\n        for i in range(1, len(a)):\\n            \\n            if a[i-1] > a[i]:\\n                is_monotonically_increasing = False\\n            \\n            if a[i-1] < a[i]:\\n                is_monotonically_decreasing = False\\n                \\n               \\n        return is_monotonically_increasing or is_monotonically_decreasing  \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, a: List[int]) -> bool:\\n        \\n        if len(a) < 3:\\n            return True\\n        \\n        is_monotonically_increasing = True\\n        is_monotonically_decreasing = True\\n        \\n        for i in range(1, len(a)):\\n            \\n            if a[i-1] > a[i]:\\n                is_monotonically_increasing = False\\n            \\n            if a[i-1] < a[i]:\\n                is_monotonically_decreasing = False\\n                \\n               \\n        return is_monotonically_increasing or is_monotonically_decreasing  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640054,
                "title": "golang-one-pass-solution",
                "content": "```\\nfunc isMonotonic(nums []int) bool {\\n    isIncreasing := true\\n    isDecreasing := true\\n    \\n    for i := 0; i < len(nums) - 1; i++ {\\n        isIncreasing = isIncreasing && nums[i] <= nums[i + 1]\\n        isDecreasing = isDecreasing && nums[i] >= nums[i + 1]\\n    }\\n    \\n    return isIncreasing || isDecreasing\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isMonotonic(nums []int) bool {\\n    isIncreasing := true\\n    isDecreasing := true\\n    \\n    for i := 0; i < len(nums) - 1; i++ {\\n        isIncreasing = isIncreasing && nums[i] <= nums[i + 1]\\n        isDecreasing = isDecreasing && nums[i] >= nums[i + 1]\\n    }\\n    \\n    return isIncreasing || isDecreasing\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1549134,
                "title": "javascript-solution-one-pass-o-n",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar isMonotonic = function(nums) {\\n    let isMonotonicallyIncreasing = null\\n    for(let i=1;i<nums.length;i++) {\\n        if(nums[i] > nums[i-1]) {\\n            if(isMonotonicallyIncreasing === false) {\\n                return false\\n            }\\n            isMonotonicallyIncreasing = true\\n        } else if (nums[i] < nums[i-1]) {\\n            if(isMonotonicallyIncreasing === true) {\\n                return false\\n            }\\n            isMonotonicallyIncreasing = false\\n        }\\n    }\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar isMonotonic = function(nums) {\\n    let isMonotonicallyIncreasing = null\\n    for(let i=1;i<nums.length;i++) {\\n        if(nums[i] > nums[i-1]) {\\n            if(isMonotonicallyIncreasing === false) {\\n                return false\\n            }\\n            isMonotonicallyIncreasing = true\\n        } else if (nums[i] < nums[i-1]) {\\n            if(isMonotonicallyIncreasing === true) {\\n                return false\\n            }\\n            isMonotonicallyIncreasing = false\\n        }\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1488559,
                "title": "java-100-faster-easy",
                "content": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n\\t    //Edge case\\n        if(nums.length == 1) return true;\\n        boolean increasing = true;\\n        boolean decreasing = true;\\n        for(int i = 0; i < nums.length - 1; i++) {\\n            if(increasing && nums[i+1] < nums[i]) {\\n                increasing = false;\\n            } else if(decreasing && nums[i+1] > nums[i]) {\\n                decreasing = false;\\n            } \\n        }\\n        return increasing || decreasing;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n\\t    //Edge case\\n        if(nums.length == 1) return true;\\n        boolean increasing = true;\\n        boolean decreasing = true;\\n        for(int i = 0; i < nums.length - 1; i++) {\\n            if(increasing && nums[i+1] < nums[i]) {\\n                increasing = false;\\n            } else if(decreasing && nums[i+1] > nums[i]) {\\n                decreasing = false;\\n            } \\n        }\\n        return increasing || decreasing;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450395,
                "title": "easy-faster-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int flag1=true,flag2=true;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i-1]>nums[i])flag1=false;//decreasing\\n            if(nums[i-1]<nums[i])flag2=false;//increasing\\n        }\\n        return flag1|| flag2;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        int flag1=true,flag2=true;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i-1]>nums[i])flag1=false;//decreasing\\n            if(nums[i-1]<nums[i])flag2=false;//increasing\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1285678,
                "title": "python-3-line-solution",
                "content": "```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        copy = nums.copy()\\n        copy.sort()\\n        return (nums == copy or nums == copy[::-1])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        copy = nums.copy()\\n        copy.sort()\\n        return (nums == copy or nums == copy[::-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213841,
                "title": "c-simple-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isMonotonic(vector<int>& nums) {\\n\\t\\t\\tbool incr = true;\\n\\t\\t\\tbool decr = true;\\n\\t\\t\\tfor(int i = 0; i < nums.size() - 1; i++){\\n\\t\\t\\t\\tif(nums[i] > nums[i + 1]){\\\\\\n\\t\\t\\t\\t\\tincr = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(nums[i] < nums[i + 1]){\\n\\t\\t\\t\\t\\tdecr = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(incr == false && decr == false){\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isMonotonic(vector<int>& nums) {\\n\\t\\t\\tbool incr = true;\\n\\t\\t\\tbool decr = true;\\n\\t\\t\\tfor(int i = 0; i < nums.size() - 1; i++){\\n\\t\\t\\t\\tif(nums[i] > nums[i + 1]){\\\\\\n\\t\\t\\t\\t\\tincr = false;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1200898,
                "title": "so-much-simple-solution",
                "content": "```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        if sorted(A)==A or sorted(A,reverse=True)==A:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        if sorted(A)==A or sorted(A,reverse=True)==A:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116137,
                "title": "python-one-liner",
                "content": "```\\ndef isMonotonic(self, A: List[int]) -> bool:\\n        return True if A == sorted(A, reverse=True) or A == sorted(A) else False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef isMonotonic(self, A: List[int]) -> bool:\\n        return True if A == sorted(A, reverse=True) or A == sorted(A) else False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 981237,
                "title": "easiest-python-solution",
                "content": "```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        if A == sorted(A) or A == sorted(A,reverse=True):\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        if A == sorted(A) or A == sorted(A,reverse=True):\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783272,
                "title": "c-1-line-answer",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& A) {\\n        return is_sorted(A.begin(),A.end()) || is_sorted(A.rbegin(),A.rend());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& A) {\\n        return is_sorted(A.begin(),A.end()) || is_sorted(A.rbegin(),A.rend());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 754271,
                "title": "javascript-solution",
                "content": "```\\nvar isMonotonic = function(A) {\\n    let increasing = true, decreasing = true;\\n    for (i = 0; i < A.length; i++) {\\n        if (A[i] < A[i+1]){\\n             decreasing = false;\\n        }\\n        else if (A[i] > A[i+1]) {\\n            increasing = false;\\n        }\\n        else if (A[i] === A[i+1]){\\n             continue;\\n        }\\n    }\\n    return increasing || decreasing;\\n};\\n```\\n\\n**Runtime: 92 ms, faster than 51.76% of JavaScript online submissions for Monotonic Array.\\nMemory Usage: 43 MB, less than 20.34% of JavaScript online submissions for Monotonic Array.**",
                "solutionTags": [],
                "code": "```\\nvar isMonotonic = function(A) {\\n    let increasing = true, decreasing = true;\\n    for (i = 0; i < A.length; i++) {\\n        if (A[i] < A[i+1]){\\n             decreasing = false;\\n        }\\n        else if (A[i] > A[i+1]) {\\n            increasing = false;\\n        }\\n        else if (A[i] === A[i+1]){\\n             continue;\\n        }\\n    }\\n    return increasing || decreasing;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 739246,
                "title": "python-easy-solution",
                "content": "Python O(n) Solution :\\n```\\ndef isMonotonic(self, A: List[int]) -> bool:\\n        \\n        increasing = decreasing = True\\n        \\n        for i in range(len(A)-1):\\n            \\n            if A[i] > A[i+1]:\\n                increasing = False\\n            if A[i] < A[i+1]:\\n                decreasing = False\\n            \\n        return increasing or decreasing\\n```\\n\\nPython O(n2) Solution:\\n```\\ndef isMonotonic(self, A: List[int]) -> bool:\\n\\t\\t\\tc = 0\\n\\t\\t\\tfor i in range(1,len(A)):\\n\\t\\t\\t\\tif A[i-1] <= A[i] :\\n\\t\\t\\t\\t\\tc += 1\\n\\n\\t\\t\\tif len(A) - 1 == c:\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\tc = 0\\n\\t\\t\\tfor i in range(1,len(A)):\\n\\t\\t\\t\\tif A[i-1] >= A[i] :\\n\\t\\t\\t\\t\\tc += 1\\n\\n\\t\\t\\tif len(A) - 1 == c:\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\treturn False\\n```",
                "solutionTags": [],
                "code": "```\\ndef isMonotonic(self, A: List[int]) -> bool:\\n        \\n        increasing = decreasing = True\\n        \\n        for i in range(len(A)-1):\\n            \\n            if A[i] > A[i+1]:\\n                increasing = False\\n            if A[i] < A[i+1]:\\n                decreasing = False\\n            \\n        return increasing or decreasing\\n```\n```\\ndef isMonotonic(self, A: List[int]) -> bool:\\n\\t\\t\\tc = 0\\n\\t\\t\\tfor i in range(1,len(A)):\\n\\t\\t\\t\\tif A[i-1] <= A[i] :\\n\\t\\t\\t\\t\\tc += 1\\n\\n\\t\\t\\tif len(A) - 1 == c:\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\tc = 0\\n\\t\\t\\tfor i in range(1,len(A)):\\n\\t\\t\\t\\tif A[i-1] >= A[i] :\\n\\t\\t\\t\\t\\tc += 1\\n\\n\\t\\t\\tif len(A) - 1 == c:\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 722989,
                "title": "simple-java",
                "content": "```\\npublic boolean isMonotonic(int[] A) {\\n        boolean increase=A[0]<=A[A.length-1];\\n        \\n        for(int i =1;i<A.length;i++){\\n            if(A[i-1]==A[i]){\\n                continue;\\n            }else if(increase && A[i-1]>A[i]){\\n                return false;\\n            }else if(!increase && A[i-1]<A[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\t\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic boolean isMonotonic(int[] A) {\\n        boolean increase=A[0]<=A[A.length-1];\\n        \\n        for(int i =1;i<A.length;i++){\\n            if(A[i-1]==A[i]){\\n                continue;\\n            }else if(increase && A[i-1]>A[i]){\\n                return false;\\n            }else if(!increase && A[i-1]<A[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 712322,
                "title": "easy-js-solution",
                "content": "```\\n/**\\n * @param {number[]} A\\n * @return {boolean}\\n */\\nvar isMonotonic = function(A) {\\n    let increasing = true, decreasing = true;\\n    for (i = 0; i < A.length; i++) {\\n        if (A[i] < A[i+1]) decreasing = false;\\n        else if (A[i] > A[i+1]) increasing = false;\\n        else if (A[i] === A[i+1]) continue;\\n    }\\n    return increasing || decreasing;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} A\\n * @return {boolean}\\n */\\nvar isMonotonic = function(A) {\\n    let increasing = true, decreasing = true;\\n    for (i = 0; i < A.length; i++) {\\n        if (A[i] < A[i+1]) decreasing = false;\\n        else if (A[i] > A[i+1]) increasing = false;\\n        else if (A[i] === A[i+1]) continue;\\n    }\\n    return increasing || decreasing;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 492848,
                "title": "c-one-liner-3-more-modern-c-solutions",
                "content": "```\\nclass Solution {\\n    public:\\n        bool isMonotonic(vector<int>& A) \\n        {\\n            return is_sorted(A.begin(), A.end(), greater<int>()) || is_sorted(A.begin(), A.end(), less<int>());\\n        }\\n};\\n```\\n\\nOr, if you prefer not to use std::is_sorted():\\n```\\nclass Solution {\\n    public:\\n        bool isMonotonic(vector<int>& A) \\n        {\\n            return isMonotonic(A, greater_equal<int>()) || isMonotonic(A, less_equal<int>());\\n        }\\n\\n    protected:\\n        bool isMonotonic(vector<int>& v, function<bool(int, int)> func)\\n        {\\n            for(int i = 1; i < v.size(); ++i)\\n                if(! func(v[i], v[i-1])) return false;\\n            return true;\\n        }\\n};\\n```\\n\\nOr, no build-in functions at all:\\n```\\nclass Solution {\\n    public:\\n        bool isMonotonic(vector<int>& A) \\n        {\\n            return isMonotonic(A, [](int a, int b){return a <= b;}) || isMonotonic(A, [](int a, int b){return a >= b;});\\n        }\\n\\n    protected:\\n        bool isMonotonic(vector<int>& v, function<bool(int, int)> func)\\n        {\\n            for(int i = 1; i < v.size(); ++i)\\n                if(! func(v[i], v[i-1])) return false;\\n            return true;\\n        }\\n};\\n```\\n\\nOr, another way without \"raw loop\":\\n```\\nclass Solution {\\n    public:\\n        bool isMonotonic(vector<int>& A) \\n        {\\n            return isMonotonic(A, greater_equal<int>()) || isMonotonic(A, less_equal<int>());\\n        }\\n\\n    protected:\\n        bool isMonotonic(vector<int>& v, function<bool(int, int)> func)\\n        {\\n            int a = *v.begin();\\n            auto it = find_if(v.begin()+1, v.end(), [&](int b){if(! func(a, b)) return true; a = b; return false;});\\n            return it == v.end();\\n        }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n        bool isMonotonic(vector<int>& A) \\n        {\\n            return is_sorted(A.begin(), A.end(), greater<int>()) || is_sorted(A.begin(), A.end(), less<int>());\\n        }\\n};\\n```\n```\\nclass Solution {\\n    public:\\n        bool isMonotonic(vector<int>& A) \\n        {\\n            return isMonotonic(A, greater_equal<int>()) || isMonotonic(A, less_equal<int>());\\n        }\\n\\n    protected:\\n        bool isMonotonic(vector<int>& v, function<bool(int, int)> func)\\n        {\\n            for(int i = 1; i < v.size(); ++i)\\n                if(! func(v[i], v[i-1])) return false;\\n            return true;\\n        }\\n};\\n```\n```\\nclass Solution {\\n    public:\\n        bool isMonotonic(vector<int>& A) \\n        {\\n            return isMonotonic(A, [](int a, int b){return a <= b;}) || isMonotonic(A, [](int a, int b){return a >= b;});\\n        }\\n\\n    protected:\\n        bool isMonotonic(vector<int>& v, function<bool(int, int)> func)\\n        {\\n            for(int i = 1; i < v.size(); ++i)\\n                if(! func(v[i], v[i-1])) return false;\\n            return true;\\n        }\\n};\\n```\n```\\nclass Solution {\\n    public:\\n        bool isMonotonic(vector<int>& A) \\n        {\\n            return isMonotonic(A, greater_equal<int>()) || isMonotonic(A, less_equal<int>());\\n        }\\n\\n    protected:\\n        bool isMonotonic(vector<int>& v, function<bool(int, int)> func)\\n        {\\n            int a = *v.begin();\\n            auto it = find_if(v.begin()+1, v.end(), [&](int b){if(! func(a, b)) return true; a = b; return false;});\\n            return it == v.end();\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439363,
                "title": "java-simplest-1-pass-solution",
                "content": "```\\npublic boolean isMonotonic(int[] A) {\\n\\tboolean isIncreasing = true, isDecreasing = true;\\n\\tfor(int i=1; i<A.length; i++) {\\n\\t\\tif(!isIncreasing && !isDecreasing) return false; //No need to see other numbers anymore\\n\\t\\tif(isIncreasing && A[i-1]>A[i]) isIncreasing = false;\\n\\t\\tif(isDecreasing && A[i-1]<A[i]) isDecreasing = false;\\n\\t}\\n\\treturn isIncreasing || isDecreasing;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isMonotonic(int[] A) {\\n\\tboolean isIncreasing = true, isDecreasing = true;\\n\\tfor(int i=1; i<A.length; i++) {\\n\\t\\tif(!isIncreasing && !isDecreasing) return false; //No need to see other numbers anymore\\n\\t\\tif(isIncreasing && A[i-1]>A[i]) isIncreasing = false;\\n\\t\\tif(isDecreasing && A[i-1]<A[i]) isDecreasing = false;\\n\\t}\\n\\treturn isIncreasing || isDecreasing;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 401155,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        inc = True\\n        for i in range(1, len(A)):\\n            if A[i]>=A[i-1]:\\n                pass\\n            else:\\n                inc = False\\n        dec = True\\n        for i in range(1, len(A)):\\n            if A[i]<=A[i-1]:\\n                pass\\n            else:\\n                dec = False\\n        return inc or dec\\n```\\n\\n```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        inc = True\\n        dec = True\\n        for i in range(1, len(A)):\\n            if A[i] >= A[i-1]:\\n                pass\\n            else:\\n                inc = False\\n                \\n            if A[i] <= A[i-1]:\\n                pass\\n            else:\\n                dec = False\\n                \\n        return inc or dec\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        inc = True\\n        for i in range(1, len(A)):\\n            if A[i]>=A[i-1]:\\n                pass\\n            else:\\n                inc = False\\n        dec = True\\n        for i in range(1, len(A)):\\n            if A[i]<=A[i-1]:\\n                pass\\n            else:\\n                dec = False\\n        return inc or dec\\n```\n```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        inc = True\\n        dec = True\\n        for i in range(1, len(A)):\\n            if A[i] >= A[i-1]:\\n                pass\\n            else:\\n                inc = False\\n                \\n            if A[i] <= A[i-1]:\\n                pass\\n            else:\\n                dec = False\\n                \\n        return inc or dec\\n```",
                "codeTag": "Java"
            },
            {
                "id": 342431,
                "title": "my-swift-solution",
                "content": "```\\n\\nfunc isMonotonic(_ A: [Int]) -> Bool {\\n    var increasing = true\\n    var decreasing = true\\n    for i in 0..<(A.count - 1) {\\n        if A[i] < A[i + 1] {\\n            decreasing = false\\n        }\\n        if A[i] > A[i + 1] {\\n            increasing = false\\n        }\\n    }\\n    return increasing || decreasing\\n}\\n\\nassert(isMonotonic([1,2,2,3]) == true, \"Failed\")\\nassert(isMonotonic( [6,5,4,4]) == true, \"Failed\")\\nassert(isMonotonic( [1,3,2]) == false, \"Failed\")\\nassert(isMonotonic([1,2,4,5]) == true, \"Failed\")\\nassert(isMonotonic([1,1,1]) == true, \"Failed\")\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nfunc isMonotonic(_ A: [Int]) -> Bool {\\n    var increasing = true\\n    var decreasing = true\\n    for i in 0..<(A.count - 1) {\\n        if A[i] < A[i + 1] {\\n            decreasing = false\\n        }\\n        if A[i] > A[i + 1] {\\n            increasing = false\\n        }\\n    }\\n    return increasing || decreasing\\n}\\n\\nassert(isMonotonic([1,2,2,3]) == true, \"Failed\")\\nassert(isMonotonic( [6,5,4,4]) == true, \"Failed\")\\nassert(isMonotonic( [1,3,2]) == false, \"Failed\")\\nassert(isMonotonic([1,2,4,5]) == true, \"Failed\")\\nassert(isMonotonic([1,1,1]) == true, \"Failed\")\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 290366,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        inc = A[0] > A[len(A)-1]\\n        \\n        for i in range(0, len(A)-1):\\n            if A[i] < A[i+1]:\\n                if inc == True:\\n                    return False\\n            if A[i] > A[i+1]:\\n                if inc == False:\\n                    return False\\n        return True",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, A: List[int]) -> bool:\\n        inc = A[0] > A[len(A)-1]\\n        \\n        for i in range(0, len(A)-1):\\n            if A[i] < A[i+1]:\\n                if inc == True:\\n                    return False\\n            if A[i] > A[i+1]:\\n                if inc == False:\\n                    return False\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 242133,
                "title": "c-95",
                "content": "Easy to understand C# code that scored faster than 95% on Feb22, 2019.\\n\\n```\\npublic class Solution\\n{\\n    public bool IsMonotonic(int[] A)\\n    {\\n        var length = A.Length;\\n        if (length < 3)\\n        {\\n            return true;\\n        }\\n\\n        if (A[0] < A[length-1])\\n        {\\n            for (int i = 1; i < length; i++)\\n            {\\n                if (A[i-1] > A[i])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for (int i = 1; i < length; i++)\\n            {\\n                if (A[i-1] < A[i])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public bool IsMonotonic(int[] A)\\n    {\\n        var length = A.Length;\\n        if (length < 3)\\n        {\\n            return true;\\n        }\\n\\n        if (A[0] < A[length-1])\\n        {\\n            for (int i = 1; i < length; i++)\\n            {\\n                if (A[i-1] > A[i])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for (int i = 1; i < length; i++)\\n            {\\n                if (A[i-1] < A[i])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 220592,
                "title": "rust-solution",
                "content": "```Rust\\nimpl Solution {\\n    pub fn is_monotonic(a: Vec<i32>) -> bool {\\n        let mut inc = true;\\n        let mut dec = true;\\n        \\n        for idx in (1..a.len()) {\\n            inc &= a[idx - 1] <= a[idx];\\n            dec &= a[idx - 1] >= a[idx];\\n        }\\n        return inc || dec;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Rust\\nimpl Solution {\\n    pub fn is_monotonic(a: Vec<i32>) -> bool {\\n        let mut inc = true;\\n        let mut dec = true;\\n        \\n        for idx in (1..a.len()) {\\n            inc &= a[idx - 1] <= a[idx];\\n            dec &= a[idx - 1] >= a[idx];\\n        }\\n        return inc || dec;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 169253,
                "title": "c-o-n-using-the-idea-of-derivative-easy-to-understand",
                "content": "```\\n bool isMonotonic(vector<int>& A) {\\n        if(A.size()<=2) return true;\\n        int trend = 0,pre = trend;\\n        for(int i = 1; i < A.size(); i++){\\n            trend = A[i]-A[i-1];\\n            if(trend == 0) continue;\\n            if(pre*trend < 0) return false; // Check the sign\\n            pre = trend;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n bool isMonotonic(vector<int>& A) {\\n        if(A.size()<=2) return true;\\n        int trend = 0,pre = trend;\\n        for(int i = 1; i < A.size(); i++){\\n            trend = A[i]-A[i-1];\\n            if(trend == 0) continue;\\n            if(pre*trend < 0) return false; // Check the sign\\n            pre = trend;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 166290,
                "title": "java-single-loop-solution",
                "content": "```\\npublic boolean isMonotonic(int[] A) {\\n\\t\\tboolean asc = true, desc = true;\\n\\t\\tfor(int i = 1; i < A.length; i++) {\\n\\t\\t\\tif(asc && A[i-1] > A[i]) asc = false;\\n\\t\\t\\tif(desc && A[i-1] < A[i]) desc = false;\\n\\t\\t}\\n\\t\\treturn asc || desc;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isMonotonic(int[] A) {\\n\\t\\tboolean asc = true, desc = true;\\n\\t\\tfor(int i = 1; i < A.length; i++) {\\n\\t\\t\\tif(asc && A[i-1] > A[i]) asc = false;\\n\\t\\t\\tif(desc && A[i-1] < A[i]) desc = false;\\n\\t\\t}\\n\\t\\treturn asc || desc;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 165884,
                "title": "c-1-liner",
                "content": "1-liner with STL:\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& A) {\\n        return is_sorted(A.begin(), A.end(), less<int>()) || is_sorted(A.begin(), A.end(), greater<int>());\\n    }\\n};\\n```\\n\\nwithout STL:\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& A) {\\n        if (A.size() == 1) return true;\\n        bool increase = false, decrease = false;\\n        for (int i = 1; i < A.size(); ++i) {\\n            if (A[i] > A[i - 1]) {\\n                increase = true;\\n            } else if (A[i] < A[i - 1]) {\\n                decrease = true;\\n            }\\n        }\\n        return !(increase & decrease);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& A) {\\n        return is_sorted(A.begin(), A.end(), less<int>()) || is_sorted(A.begin(), A.end(), greater<int>());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& A) {\\n        if (A.size() == 1) return true;\\n        bool increase = false, decrease = false;\\n        for (int i = 1; i < A.size(); ++i) {\\n            if (A[i] > A[i - 1]) {\\n                increase = true;\\n            } else if (A[i] < A[i - 1]) {\\n                decrease = true;\\n            }\\n        }\\n        return !(increase & decrease);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4107225,
                "title": "simple-map-reduce",
                "content": "# Intuition\\nCould check `nums[0]` and `nums[len(nums)-1]` to determine increasing / decreasing / constant upfront, but there is no meaningful difference.\\n\\n# Approach\\n- Create an iterator for `is_increasing` and `is_decreasing`.\\n- Use `all()` to reduce them.\\n- Return `True` if either of them reduces to `True`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n    > worst case two passes (`nums[len(nums)-2]` > `nums[len(nums)-1]`)\\n\\n- Space complexity: $$O(1)$$\\n    > iterators are nice\\n\\n# Code\\n- Using `map` and `lambda`:\\n```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        is_increasing = map(lambda a, b: a <= b, nums[:len(nums)], nums[1:])\\n        is_decreasing = map(lambda a, b: a >= b, nums[:len(nums)], nums[1:])\\n        return all(is_increasing) or all(is_decreasing)\\n```\\n- Using `generator expression`:\\n```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        is_increasing = (a <= b for (a, b) in zip(nums[:len(nums)], nums[1:]))\\n        is_decreasing = (a >= b for (a, b) in zip(nums[:len(nums)], nums[1:]))\\n        return all(is_increasing) or all(is_decreasing)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        is_increasing = map(lambda a, b: a <= b, nums[:len(nums)], nums[1:])\\n        is_decreasing = map(lambda a, b: a >= b, nums[:len(nums)], nums[1:])\\n        return all(is_increasing) or all(is_decreasing)\\n```\n```\\nclass Solution:\\n    def isMonotonic(self, nums: List[int]) -> bool:\\n        is_increasing = (a <= b for (a, b) in zip(nums[:len(nums)], nums[1:]))\\n        is_decreasing = (a >= b for (a, b) in zip(nums[:len(nums)], nums[1:]))\\n        return all(is_increasing) or all(is_decreasing)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4106989,
                "title": "very-simple-technique-only-6-7-lines-fast-100",
                "content": "# Please Upvote if you liked my Solution \\uD83E\\uDD17\\uD83E\\uDD17\\n> **Please do UpVote** it took lot of time to figure out these solutions\\n\\n# Complexity \\n- Time complexity: $$O(N)$$ where `N = nums.length`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        if( nums.size() <= 2 ) return 1;\\n        int n = nums.size(), d = 0;\\n\\n        // set value of d ( 1 or -1 ) when change occur first time \\n        for(int i=1; i<n; i++){\\n            int dt = nums[i] - nums[i-1];\\n            if( d == 0 && dt != 0 ) d = dt > 0 ? 1 : -1;\\n            else if( dt*d < 0 ) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```\\n\\n---\\n\\n# Java Code\\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        if( nums.length <= 2 ) return true;\\n        int n = nums.length, d = 0;\\n\\n        // set value of d ( 1 or -1 ) when change occur first time \\n        for(int i=1; i<n; i++){\\n            int dt = nums[i] - nums[i-1];\\n            if( d == 0 && dt != 0 ) d = dt > 0 ? 1 : -1;\\n            else if( dt*d < 0 ) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n![upvote-4.png](https://assets.leetcode.com/users/images/5af4e2a5-e8b2-4f46-be00-75247cfdf9ff_1689947516.7818904.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMonotonic(vector<int>& nums) {\\n        if( nums.size() <= 2 ) return 1;\\n        int n = nums.size(), d = 0;\\n\\n        // set value of d ( 1 or -1 ) when change occur first time \\n        for(int i=1; i<n; i++){\\n            int dt = nums[i] - nums[i-1];\\n            if( d == 0 && dt != 0 ) d = dt > 0 ? 1 : -1;\\n            else if( dt*d < 0 ) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean isMonotonic(int[] nums) {\\n        if( nums.length <= 2 ) return true;\\n        int n = nums.length, d = 0;\\n\\n        // set value of d ( 1 or -1 ) when change occur first time \\n        for(int i=1; i<n; i++){\\n            int dt = nums[i] - nums[i-1];\\n            if( d == 0 && dt != 0 ) d = dt > 0 ? 1 : -1;\\n            else if( dt*d < 0 ) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2076399,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076699,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076326,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076367,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076411,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076339,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076323,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2077034,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076490,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 1672119,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076399,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076699,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076326,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076367,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076411,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076339,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076323,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2077034,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 2076490,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 1672119,
                "content": [
                    {
                        "username": "aitachii",
                        "content": "Tomorrow is both a weekend and a month-end. Brace yourselves."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s the problem for reference: [132 Pattern](https://leetcode.com/problems/132-pattern/)"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "Oh no... Past 2 questions have been too easy, I\\'m afraid tomorrow is going to be a big bad HARD smacked on our face..."
                    },
                    {
                        "username": "user5400vw",
                        "content": "our lives are at stake "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Initialize two boolean variables: isIncreasing and isDecreasing to true\\nStarting from the second element, compare each element with its previous element.\\nIf an element is less than its previous element, set isIncreasing to false (indicating the array is not increasing).\\nIf an element is greater than its previous element, set isDecreasing to false (indicating the array is not decreasing).\\nIf both isIncreasing and isDecreasing are false, break the loop as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nReturn if either isIncreasing or isDecreasing is true since the array is considered monotonic if one of them is true and non monotonic if both are false.\\n\\nwas it helpful ... support by upvote."
                    },
                    {
                        "username": "anwendeng",
                        "content": "Have a nice day!  It\\'s again an easy question.  O(n) solution is expected, but is it possible to create a sublinear solution?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Given the variance of leetCode run times, I suspect that a sample size of 10 is inadequate (especially if all samples are taken on the same day). I\\'m not sure that picking an outlier is the best idea."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@mshoosterman](/mshoosterman) the point is, LC test case developers are well aware of this and normally would give you the worst possible scenarios for all typical implementations."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@psionl0](/psionl0) Why not? Submit 10 times at different time of the day, pick best. The usual statistic gathering routine. How to people measure non-deterministic real life processes?"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) perfect!"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "Worstcase sublinear is certainly impossible. Since the list can be sorted except for a single element, which means you necessarily have to check all elements. \\n\\nAverage case is a harder question because you need to ask what is the distribution? if we take our input to be a random list, then consider the average runtime, any failfast solution, which returns false as soon as it sees a contradiction, should actually be pretty close to O(1) average runtime, since most lists will have a contradiction in the first few elements. "
                    },
                    {
                        "username": "psionl0",
                        "content": "[@sergei99](/sergei99) Are you relying on the leetCode timer to judge your submission times?"
                    },
                    {
                        "username": "sergei99",
                        "content": "[@anwendeng](/anwendeng) well, perhaps it does not beat 100% anymore: https://leetcode.com/submissions/detail/1062141454/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@sergei99](/sergei99) One of my C++ code using  adjacent_difference has runtime 61 ms & beats 100%, that is a 2 pass code!"
                    },
                    {
                        "username": "0xcaffe17e",
                        "content": "If we were checking whether the array is *strictly* in/decreasing, we could have taken a binary search approach which we all know has a TC of $O(\\\\log n)$. But alas...  \\nMight be worth mentioning this fact if this problem ever gets asked in an actual interview though!"
                    },
                    {
                        "username": "sergei99",
                        "content": "Managed to get 55 ms and a top execution time for C++ with a simple trick.\nWhen LC gives you test cases, they usually intend to catch improper handling of edge cases.\nConsidering that, for sequences beyond certain length I first check linear ordering of elements at 1/4, 2/4, 3/4-th indexes and the last element. If it holds, then run the usual loop with early exit checking each consecutive pair.\nAlso I always start with comparing the first element with the last element regardless of the length.\nIt still has linear time of course, but in some cases it becomes constant.\nThe previous record was 61 ms with a linear loop containing excessive branch points (which CPUs don't like), but I couldn't get less than 68 ms even for better implementation - tried a dozen of submissions.\n\nP.S. Tried an exponential search (check 1-st, 2-nd, 4-th, 8-th, etc. elements) and got 53 ms after a few tries. That's about it. No ideas how to push it further, except may be tuning the degree base."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@rajan_jasani9](/rajan_jasani9) That\\'s what I did.\\nhttps://leetcode.com/submissions/detail/1061885493/"
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "[@psionl0](/psionl0) what if we just return False when the 1st violation occurs? "
                    },
                    {
                        "username": "sergei99",
                        "content": "May be if you look at Timsort merge algorithm, that would help. It detects long subsequences with natural ordering and skips entire ranges based on that. It defaults to element by element handling if the natural ordering guess turned out to be wrong - so it has to detect such cases somehow."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Aadil42](/Aadil42) Yes. I tried but not successful, 305/371 are pass! A binary search solution can solve some patterns but not all. For example if there is just 1 exception, BS works."
                    },
                    {
                        "username": "Aadil42",
                        "content": "[@anwendeng](/anwendeng) When you say sublinear, do you mean O(log(n)) time?"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@hero080](/hero080) Yes, sublinear is not possible but you can code your solution for an early exit if the first violation occurs early in the array. (Many solutions keep going to the end of the array regardless of where the first violation occurs)."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@hero080](/hero080) Yes. A sublinear solution is not possible."
                    },
                    {
                        "username": "hero080",
                        "content": "The solution has to be $\\\\Omega(n)$ because there might be only a single element in `nums` that violates the monotonic condition and we have to check every index to find it."
                    },
                    {
                        "username": "freezeen3",
                        "content": "So guys today is the Chinese Mid-Autumn Festival, it\\'s good to have a relaxing day with Leetcode\\'s support!"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "Everyone have a nice Friday! You have more time today for other stuff to do ;)"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "I wish I could know what tomorrows hard problem will be, so I can get a head start! "
                    },
                    {
                        "username": "IAmBadAtLeetcode",
                        "content": "no.. need to leetcode more. it was too easy today, need to keep going lol"
                    },
                    {
                        "username": "demaw",
                        "content": "any valid solution must run in (at least) O(n) time. consider the case [3,3,3,3, ... ,7, ... 3,3,3]. because a number like 7 could exist anywhere in a potentially monotonic array full of 3s, we must check every index of the array to be sure that it is monotonic"
                    },
                    {
                        "username": "vlde_lc",
                        "content": "Good Friday easy task. We almost made it in September, keep it up guys!"
                    },
                    {
                        "username": "shakibaenur",
                        "content": "* Initialize two boolean variables: isIncreasing and isDecreasing to false\\n* Start the loop from index 1 compare with its previous element.\\n* If an element is greater than its previous element then set isIncreasing=true(means the array is increasing)\\n* If an element is smaller than its previous element then set isDecreasing=true(means the array is decreasing)\\n* if both isIncreasing and isDecreasing are true then return false and break as the array is neither increasing nor decreasing and we don\\'t have to continue the loop.\\nWas it helpful ... support by upvote."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "Month End should be peace like this :)"
                    },
                    {
                        "username": "singlamuskan1208",
                        "content": "Do we have any solution with less than O(n) time complx?"
                    },
                    {
                        "username": "sergei99",
                        "content": "To an extent. We can use some heuristics exploiting the data structure and failing fast for non-ordered sequences (not just trivial early exit from the loop, but there are other techniques).\\nBut proving that sequence is ordered cannot be less than $$O(n)$$."
                    },
                    {
                        "username": "NagarapuNagaVenkataSivaSaiRagh",
                        "content": "I dont think so, because to compare the elements, we must iterate through the array. So to iterate through the array, we must use for loop.\\n"
                    }
                ]
            },
            {
                "id": 1572137,
                "content": [
                    {
                        "username": "knownfemme",
                        "content": "So, both the one pass solution and the double pass solution run in O(n) time. Therefore, for large inputs of data, we can expect both solutions to perform similarly. I want to argue the double pass solution is actually the better option because it should be easier to maintain in the long run. For example, it should be easier for someone unfamiliar with the code who might be tasked with updating it to look at it and determine how the code works.\\n\\nOf course, there the single pass solution is faster and arguably more clever. What are your opinions? If you had to defend a solution, which one would you defend and why? "
                    },
                    {
                        "username": "anshu22sri",
                        "content": "Can you help me with a problem??"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "You can instantly check whether or not an array is potentially monotone increasing or monotone decreasing by comparing the first and last element of said array."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@deCodeIt](/deCodeIt) It\\'s still not a great help. You are just adding a third case to the list: all elements are equal and we don\\'t have to check for this otherwise."
                    },
                    {
                        "username": "moris_7",
                        "content": "But if elements that are in the middle of 1st and last element, are greater than or less than 1st and last element then this method won\\'t work.\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "[@psionl0](/psionl0) well in that case all the elements in the array should be equal to it to be a monotone so it  still helps :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "That doesn\\'t help much if the first and last elements are the same."
                    },
                    {
                        "username": "phat_dang",
                        "content": "First we can detect the array is increasing or decreasing by comparing first and last elements\\nThen any 2 adjacent elements break that flag, considering as a false case"
                    },
                    {
                        "username": "s3stan",
                        "content": "Apparently tomorrow I\\'ll have to think carefully"
                    },
                    {
                        "username": "sk4142",
                        "content": "the calm before the storm"
                    },
                    {
                        "username": "Daksh_Makhija",
                        "content": "In constraints, it is given -10^5 <= nums[i] <= 10^5 . It should be 10^(-5) <= nums[i] <= 10^5. Pls reply if you agree on this everyone."
                    },
                    {
                        "username": "psionl0",
                        "content": "The lack of other replies suggests that nobody agrees with you. This is an array of integers and 10^(-5) is not an integer."
                    },
                    {
                        "username": "buithanh2342002",
                        "content": "An array is monotonic if it is either monotone increasing or monotone decreasing. So, it\\'s supposed to be false if an array is not increasing or decreasing. [1,1,1,1] -> false"
                    },
                    {
                        "username": "psionl0",
                        "content": "LeetCode is not defining \"monotonic\" correctly. Mathematically speaking, a function is monotonic if no two elements from the domain map to the same element in the range. This means that the array should be strictly increasing or strictly decreasing and not merely non-decreasing or non-increasing."
                    },
                    {
                        "username": "m-shazaib",
                        "content": "Exactly"
                    },
                    {
                        "username": "m-shazaib",
                        "content": "basically break down the problem.\n1. for an array to be monotonic they can't have both tendencies. \n2. keeping the above in mind, check for previous and next elements in your array. \n3. now for comparing, you might use two variables of type bool, i.e isIncreasing and isDecreasing.\n4. Assign values to them.\n5. At the end check if your variables complies with point  1 above. (isIncreasing==isDecreasing)\n\nThis is a pseudocode. You still have some work to do mate.\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "pretty quiet before the storm comes....."
                    },
                    {
                        "username": "realitant",
                        "content": "Obviously python is a comparatively slow language, but does anyone have insight as to why it\\'s so slow on this problem in particular?\\nMy python and java solutions were both about 65%. Java ran in 2ms; Python was around 850ms.\\nI\\'m used to seeing about a 10x runtime differential. 425x is unexpected."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Harsh-br0](/Harsh-br0) it does, but java measurements here are nevertheless very stable.\\nMay be they commit a System.gc() after every call, excluding its time from summary, I don\\'t know."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@sergei99](/sergei99) java also have a GC , no?\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess they measure pure execution time for Java, while Python, Scala, etc. measurements include GC and other overhead. Even C++ execution s typically slower than Java."
                    }
                ]
            },
            {
                "id": 2028130,
                "content": [
                    {
                        "username": "knownfemme",
                        "content": "So, both the one pass solution and the double pass solution run in O(n) time. Therefore, for large inputs of data, we can expect both solutions to perform similarly. I want to argue the double pass solution is actually the better option because it should be easier to maintain in the long run. For example, it should be easier for someone unfamiliar with the code who might be tasked with updating it to look at it and determine how the code works.\\n\\nOf course, there the single pass solution is faster and arguably more clever. What are your opinions? If you had to defend a solution, which one would you defend and why? "
                    },
                    {
                        "username": "anshu22sri",
                        "content": "Can you help me with a problem??"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "You can instantly check whether or not an array is potentially monotone increasing or monotone decreasing by comparing the first and last element of said array."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@deCodeIt](/deCodeIt) It\\'s still not a great help. You are just adding a third case to the list: all elements are equal and we don\\'t have to check for this otherwise."
                    },
                    {
                        "username": "moris_7",
                        "content": "But if elements that are in the middle of 1st and last element, are greater than or less than 1st and last element then this method won\\'t work.\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "[@psionl0](/psionl0) well in that case all the elements in the array should be equal to it to be a monotone so it  still helps :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "That doesn\\'t help much if the first and last elements are the same."
                    },
                    {
                        "username": "phat_dang",
                        "content": "First we can detect the array is increasing or decreasing by comparing first and last elements\\nThen any 2 adjacent elements break that flag, considering as a false case"
                    },
                    {
                        "username": "s3stan",
                        "content": "Apparently tomorrow I\\'ll have to think carefully"
                    },
                    {
                        "username": "sk4142",
                        "content": "the calm before the storm"
                    },
                    {
                        "username": "Daksh_Makhija",
                        "content": "In constraints, it is given -10^5 <= nums[i] <= 10^5 . It should be 10^(-5) <= nums[i] <= 10^5. Pls reply if you agree on this everyone."
                    },
                    {
                        "username": "psionl0",
                        "content": "The lack of other replies suggests that nobody agrees with you. This is an array of integers and 10^(-5) is not an integer."
                    },
                    {
                        "username": "buithanh2342002",
                        "content": "An array is monotonic if it is either monotone increasing or monotone decreasing. So, it\\'s supposed to be false if an array is not increasing or decreasing. [1,1,1,1] -> false"
                    },
                    {
                        "username": "psionl0",
                        "content": "LeetCode is not defining \"monotonic\" correctly. Mathematically speaking, a function is monotonic if no two elements from the domain map to the same element in the range. This means that the array should be strictly increasing or strictly decreasing and not merely non-decreasing or non-increasing."
                    },
                    {
                        "username": "m-shazaib",
                        "content": "Exactly"
                    },
                    {
                        "username": "m-shazaib",
                        "content": "basically break down the problem.\n1. for an array to be monotonic they can't have both tendencies. \n2. keeping the above in mind, check for previous and next elements in your array. \n3. now for comparing, you might use two variables of type bool, i.e isIncreasing and isDecreasing.\n4. Assign values to them.\n5. At the end check if your variables complies with point  1 above. (isIncreasing==isDecreasing)\n\nThis is a pseudocode. You still have some work to do mate.\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "pretty quiet before the storm comes....."
                    },
                    {
                        "username": "realitant",
                        "content": "Obviously python is a comparatively slow language, but does anyone have insight as to why it\\'s so slow on this problem in particular?\\nMy python and java solutions were both about 65%. Java ran in 2ms; Python was around 850ms.\\nI\\'m used to seeing about a 10x runtime differential. 425x is unexpected."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Harsh-br0](/Harsh-br0) it does, but java measurements here are nevertheless very stable.\\nMay be they commit a System.gc() after every call, excluding its time from summary, I don\\'t know."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@sergei99](/sergei99) java also have a GC , no?\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess they measure pure execution time for Java, while Python, Scala, etc. measurements include GC and other overhead. Even C++ execution s typically slower than Java."
                    }
                ]
            },
            {
                "id": 2077480,
                "content": [
                    {
                        "username": "knownfemme",
                        "content": "So, both the one pass solution and the double pass solution run in O(n) time. Therefore, for large inputs of data, we can expect both solutions to perform similarly. I want to argue the double pass solution is actually the better option because it should be easier to maintain in the long run. For example, it should be easier for someone unfamiliar with the code who might be tasked with updating it to look at it and determine how the code works.\\n\\nOf course, there the single pass solution is faster and arguably more clever. What are your opinions? If you had to defend a solution, which one would you defend and why? "
                    },
                    {
                        "username": "anshu22sri",
                        "content": "Can you help me with a problem??"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "You can instantly check whether or not an array is potentially monotone increasing or monotone decreasing by comparing the first and last element of said array."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@deCodeIt](/deCodeIt) It\\'s still not a great help. You are just adding a third case to the list: all elements are equal and we don\\'t have to check for this otherwise."
                    },
                    {
                        "username": "moris_7",
                        "content": "But if elements that are in the middle of 1st and last element, are greater than or less than 1st and last element then this method won\\'t work.\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "[@psionl0](/psionl0) well in that case all the elements in the array should be equal to it to be a monotone so it  still helps :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "That doesn\\'t help much if the first and last elements are the same."
                    },
                    {
                        "username": "phat_dang",
                        "content": "First we can detect the array is increasing or decreasing by comparing first and last elements\\nThen any 2 adjacent elements break that flag, considering as a false case"
                    },
                    {
                        "username": "s3stan",
                        "content": "Apparently tomorrow I\\'ll have to think carefully"
                    },
                    {
                        "username": "sk4142",
                        "content": "the calm before the storm"
                    },
                    {
                        "username": "Daksh_Makhija",
                        "content": "In constraints, it is given -10^5 <= nums[i] <= 10^5 . It should be 10^(-5) <= nums[i] <= 10^5. Pls reply if you agree on this everyone."
                    },
                    {
                        "username": "psionl0",
                        "content": "The lack of other replies suggests that nobody agrees with you. This is an array of integers and 10^(-5) is not an integer."
                    },
                    {
                        "username": "buithanh2342002",
                        "content": "An array is monotonic if it is either monotone increasing or monotone decreasing. So, it\\'s supposed to be false if an array is not increasing or decreasing. [1,1,1,1] -> false"
                    },
                    {
                        "username": "psionl0",
                        "content": "LeetCode is not defining \"monotonic\" correctly. Mathematically speaking, a function is monotonic if no two elements from the domain map to the same element in the range. This means that the array should be strictly increasing or strictly decreasing and not merely non-decreasing or non-increasing."
                    },
                    {
                        "username": "m-shazaib",
                        "content": "Exactly"
                    },
                    {
                        "username": "m-shazaib",
                        "content": "basically break down the problem.\n1. for an array to be monotonic they can't have both tendencies. \n2. keeping the above in mind, check for previous and next elements in your array. \n3. now for comparing, you might use two variables of type bool, i.e isIncreasing and isDecreasing.\n4. Assign values to them.\n5. At the end check if your variables complies with point  1 above. (isIncreasing==isDecreasing)\n\nThis is a pseudocode. You still have some work to do mate.\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "pretty quiet before the storm comes....."
                    },
                    {
                        "username": "realitant",
                        "content": "Obviously python is a comparatively slow language, but does anyone have insight as to why it\\'s so slow on this problem in particular?\\nMy python and java solutions were both about 65%. Java ran in 2ms; Python was around 850ms.\\nI\\'m used to seeing about a 10x runtime differential. 425x is unexpected."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Harsh-br0](/Harsh-br0) it does, but java measurements here are nevertheless very stable.\\nMay be they commit a System.gc() after every call, excluding its time from summary, I don\\'t know."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@sergei99](/sergei99) java also have a GC , no?\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess they measure pure execution time for Java, while Python, Scala, etc. measurements include GC and other overhead. Even C++ execution s typically slower than Java."
                    }
                ]
            },
            {
                "id": 2077471,
                "content": [
                    {
                        "username": "knownfemme",
                        "content": "So, both the one pass solution and the double pass solution run in O(n) time. Therefore, for large inputs of data, we can expect both solutions to perform similarly. I want to argue the double pass solution is actually the better option because it should be easier to maintain in the long run. For example, it should be easier for someone unfamiliar with the code who might be tasked with updating it to look at it and determine how the code works.\\n\\nOf course, there the single pass solution is faster and arguably more clever. What are your opinions? If you had to defend a solution, which one would you defend and why? "
                    },
                    {
                        "username": "anshu22sri",
                        "content": "Can you help me with a problem??"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "You can instantly check whether or not an array is potentially monotone increasing or monotone decreasing by comparing the first and last element of said array."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@deCodeIt](/deCodeIt) It\\'s still not a great help. You are just adding a third case to the list: all elements are equal and we don\\'t have to check for this otherwise."
                    },
                    {
                        "username": "moris_7",
                        "content": "But if elements that are in the middle of 1st and last element, are greater than or less than 1st and last element then this method won\\'t work.\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "[@psionl0](/psionl0) well in that case all the elements in the array should be equal to it to be a monotone so it  still helps :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "That doesn\\'t help much if the first and last elements are the same."
                    },
                    {
                        "username": "phat_dang",
                        "content": "First we can detect the array is increasing or decreasing by comparing first and last elements\\nThen any 2 adjacent elements break that flag, considering as a false case"
                    },
                    {
                        "username": "s3stan",
                        "content": "Apparently tomorrow I\\'ll have to think carefully"
                    },
                    {
                        "username": "sk4142",
                        "content": "the calm before the storm"
                    },
                    {
                        "username": "Daksh_Makhija",
                        "content": "In constraints, it is given -10^5 <= nums[i] <= 10^5 . It should be 10^(-5) <= nums[i] <= 10^5. Pls reply if you agree on this everyone."
                    },
                    {
                        "username": "psionl0",
                        "content": "The lack of other replies suggests that nobody agrees with you. This is an array of integers and 10^(-5) is not an integer."
                    },
                    {
                        "username": "buithanh2342002",
                        "content": "An array is monotonic if it is either monotone increasing or monotone decreasing. So, it\\'s supposed to be false if an array is not increasing or decreasing. [1,1,1,1] -> false"
                    },
                    {
                        "username": "psionl0",
                        "content": "LeetCode is not defining \"monotonic\" correctly. Mathematically speaking, a function is monotonic if no two elements from the domain map to the same element in the range. This means that the array should be strictly increasing or strictly decreasing and not merely non-decreasing or non-increasing."
                    },
                    {
                        "username": "m-shazaib",
                        "content": "Exactly"
                    },
                    {
                        "username": "m-shazaib",
                        "content": "basically break down the problem.\n1. for an array to be monotonic they can't have both tendencies. \n2. keeping the above in mind, check for previous and next elements in your array. \n3. now for comparing, you might use two variables of type bool, i.e isIncreasing and isDecreasing.\n4. Assign values to them.\n5. At the end check if your variables complies with point  1 above. (isIncreasing==isDecreasing)\n\nThis is a pseudocode. You still have some work to do mate.\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "pretty quiet before the storm comes....."
                    },
                    {
                        "username": "realitant",
                        "content": "Obviously python is a comparatively slow language, but does anyone have insight as to why it\\'s so slow on this problem in particular?\\nMy python and java solutions were both about 65%. Java ran in 2ms; Python was around 850ms.\\nI\\'m used to seeing about a 10x runtime differential. 425x is unexpected."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Harsh-br0](/Harsh-br0) it does, but java measurements here are nevertheless very stable.\\nMay be they commit a System.gc() after every call, excluding its time from summary, I don\\'t know."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@sergei99](/sergei99) java also have a GC , no?\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess they measure pure execution time for Java, while Python, Scala, etc. measurements include GC and other overhead. Even C++ execution s typically slower than Java."
                    }
                ]
            },
            {
                "id": 2077467,
                "content": [
                    {
                        "username": "knownfemme",
                        "content": "So, both the one pass solution and the double pass solution run in O(n) time. Therefore, for large inputs of data, we can expect both solutions to perform similarly. I want to argue the double pass solution is actually the better option because it should be easier to maintain in the long run. For example, it should be easier for someone unfamiliar with the code who might be tasked with updating it to look at it and determine how the code works.\\n\\nOf course, there the single pass solution is faster and arguably more clever. What are your opinions? If you had to defend a solution, which one would you defend and why? "
                    },
                    {
                        "username": "anshu22sri",
                        "content": "Can you help me with a problem??"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "You can instantly check whether or not an array is potentially monotone increasing or monotone decreasing by comparing the first and last element of said array."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@deCodeIt](/deCodeIt) It\\'s still not a great help. You are just adding a third case to the list: all elements are equal and we don\\'t have to check for this otherwise."
                    },
                    {
                        "username": "moris_7",
                        "content": "But if elements that are in the middle of 1st and last element, are greater than or less than 1st and last element then this method won\\'t work.\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "[@psionl0](/psionl0) well in that case all the elements in the array should be equal to it to be a monotone so it  still helps :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "That doesn\\'t help much if the first and last elements are the same."
                    },
                    {
                        "username": "phat_dang",
                        "content": "First we can detect the array is increasing or decreasing by comparing first and last elements\\nThen any 2 adjacent elements break that flag, considering as a false case"
                    },
                    {
                        "username": "s3stan",
                        "content": "Apparently tomorrow I\\'ll have to think carefully"
                    },
                    {
                        "username": "sk4142",
                        "content": "the calm before the storm"
                    },
                    {
                        "username": "Daksh_Makhija",
                        "content": "In constraints, it is given -10^5 <= nums[i] <= 10^5 . It should be 10^(-5) <= nums[i] <= 10^5. Pls reply if you agree on this everyone."
                    },
                    {
                        "username": "psionl0",
                        "content": "The lack of other replies suggests that nobody agrees with you. This is an array of integers and 10^(-5) is not an integer."
                    },
                    {
                        "username": "buithanh2342002",
                        "content": "An array is monotonic if it is either monotone increasing or monotone decreasing. So, it\\'s supposed to be false if an array is not increasing or decreasing. [1,1,1,1] -> false"
                    },
                    {
                        "username": "psionl0",
                        "content": "LeetCode is not defining \"monotonic\" correctly. Mathematically speaking, a function is monotonic if no two elements from the domain map to the same element in the range. This means that the array should be strictly increasing or strictly decreasing and not merely non-decreasing or non-increasing."
                    },
                    {
                        "username": "m-shazaib",
                        "content": "Exactly"
                    },
                    {
                        "username": "m-shazaib",
                        "content": "basically break down the problem.\n1. for an array to be monotonic they can't have both tendencies. \n2. keeping the above in mind, check for previous and next elements in your array. \n3. now for comparing, you might use two variables of type bool, i.e isIncreasing and isDecreasing.\n4. Assign values to them.\n5. At the end check if your variables complies with point  1 above. (isIncreasing==isDecreasing)\n\nThis is a pseudocode. You still have some work to do mate.\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "pretty quiet before the storm comes....."
                    },
                    {
                        "username": "realitant",
                        "content": "Obviously python is a comparatively slow language, but does anyone have insight as to why it\\'s so slow on this problem in particular?\\nMy python and java solutions were both about 65%. Java ran in 2ms; Python was around 850ms.\\nI\\'m used to seeing about a 10x runtime differential. 425x is unexpected."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Harsh-br0](/Harsh-br0) it does, but java measurements here are nevertheless very stable.\\nMay be they commit a System.gc() after every call, excluding its time from summary, I don\\'t know."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@sergei99](/sergei99) java also have a GC , no?\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess they measure pure execution time for Java, while Python, Scala, etc. measurements include GC and other overhead. Even C++ execution s typically slower than Java."
                    }
                ]
            },
            {
                "id": 2077457,
                "content": [
                    {
                        "username": "knownfemme",
                        "content": "So, both the one pass solution and the double pass solution run in O(n) time. Therefore, for large inputs of data, we can expect both solutions to perform similarly. I want to argue the double pass solution is actually the better option because it should be easier to maintain in the long run. For example, it should be easier for someone unfamiliar with the code who might be tasked with updating it to look at it and determine how the code works.\\n\\nOf course, there the single pass solution is faster and arguably more clever. What are your opinions? If you had to defend a solution, which one would you defend and why? "
                    },
                    {
                        "username": "anshu22sri",
                        "content": "Can you help me with a problem??"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "You can instantly check whether or not an array is potentially monotone increasing or monotone decreasing by comparing the first and last element of said array."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@deCodeIt](/deCodeIt) It\\'s still not a great help. You are just adding a third case to the list: all elements are equal and we don\\'t have to check for this otherwise."
                    },
                    {
                        "username": "moris_7",
                        "content": "But if elements that are in the middle of 1st and last element, are greater than or less than 1st and last element then this method won\\'t work.\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "[@psionl0](/psionl0) well in that case all the elements in the array should be equal to it to be a monotone so it  still helps :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "That doesn\\'t help much if the first and last elements are the same."
                    },
                    {
                        "username": "phat_dang",
                        "content": "First we can detect the array is increasing or decreasing by comparing first and last elements\\nThen any 2 adjacent elements break that flag, considering as a false case"
                    },
                    {
                        "username": "s3stan",
                        "content": "Apparently tomorrow I\\'ll have to think carefully"
                    },
                    {
                        "username": "sk4142",
                        "content": "the calm before the storm"
                    },
                    {
                        "username": "Daksh_Makhija",
                        "content": "In constraints, it is given -10^5 <= nums[i] <= 10^5 . It should be 10^(-5) <= nums[i] <= 10^5. Pls reply if you agree on this everyone."
                    },
                    {
                        "username": "psionl0",
                        "content": "The lack of other replies suggests that nobody agrees with you. This is an array of integers and 10^(-5) is not an integer."
                    },
                    {
                        "username": "buithanh2342002",
                        "content": "An array is monotonic if it is either monotone increasing or monotone decreasing. So, it\\'s supposed to be false if an array is not increasing or decreasing. [1,1,1,1] -> false"
                    },
                    {
                        "username": "psionl0",
                        "content": "LeetCode is not defining \"monotonic\" correctly. Mathematically speaking, a function is monotonic if no two elements from the domain map to the same element in the range. This means that the array should be strictly increasing or strictly decreasing and not merely non-decreasing or non-increasing."
                    },
                    {
                        "username": "m-shazaib",
                        "content": "Exactly"
                    },
                    {
                        "username": "m-shazaib",
                        "content": "basically break down the problem.\n1. for an array to be monotonic they can't have both tendencies. \n2. keeping the above in mind, check for previous and next elements in your array. \n3. now for comparing, you might use two variables of type bool, i.e isIncreasing and isDecreasing.\n4. Assign values to them.\n5. At the end check if your variables complies with point  1 above. (isIncreasing==isDecreasing)\n\nThis is a pseudocode. You still have some work to do mate.\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "pretty quiet before the storm comes....."
                    },
                    {
                        "username": "realitant",
                        "content": "Obviously python is a comparatively slow language, but does anyone have insight as to why it\\'s so slow on this problem in particular?\\nMy python and java solutions were both about 65%. Java ran in 2ms; Python was around 850ms.\\nI\\'m used to seeing about a 10x runtime differential. 425x is unexpected."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Harsh-br0](/Harsh-br0) it does, but java measurements here are nevertheless very stable.\\nMay be they commit a System.gc() after every call, excluding its time from summary, I don\\'t know."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@sergei99](/sergei99) java also have a GC , no?\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess they measure pure execution time for Java, while Python, Scala, etc. measurements include GC and other overhead. Even C++ execution s typically slower than Java."
                    }
                ]
            },
            {
                "id": 2077416,
                "content": [
                    {
                        "username": "knownfemme",
                        "content": "So, both the one pass solution and the double pass solution run in O(n) time. Therefore, for large inputs of data, we can expect both solutions to perform similarly. I want to argue the double pass solution is actually the better option because it should be easier to maintain in the long run. For example, it should be easier for someone unfamiliar with the code who might be tasked with updating it to look at it and determine how the code works.\\n\\nOf course, there the single pass solution is faster and arguably more clever. What are your opinions? If you had to defend a solution, which one would you defend and why? "
                    },
                    {
                        "username": "anshu22sri",
                        "content": "Can you help me with a problem??"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "You can instantly check whether or not an array is potentially monotone increasing or monotone decreasing by comparing the first and last element of said array."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@deCodeIt](/deCodeIt) It\\'s still not a great help. You are just adding a third case to the list: all elements are equal and we don\\'t have to check for this otherwise."
                    },
                    {
                        "username": "moris_7",
                        "content": "But if elements that are in the middle of 1st and last element, are greater than or less than 1st and last element then this method won\\'t work.\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "[@psionl0](/psionl0) well in that case all the elements in the array should be equal to it to be a monotone so it  still helps :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "That doesn\\'t help much if the first and last elements are the same."
                    },
                    {
                        "username": "phat_dang",
                        "content": "First we can detect the array is increasing or decreasing by comparing first and last elements\\nThen any 2 adjacent elements break that flag, considering as a false case"
                    },
                    {
                        "username": "s3stan",
                        "content": "Apparently tomorrow I\\'ll have to think carefully"
                    },
                    {
                        "username": "sk4142",
                        "content": "the calm before the storm"
                    },
                    {
                        "username": "Daksh_Makhija",
                        "content": "In constraints, it is given -10^5 <= nums[i] <= 10^5 . It should be 10^(-5) <= nums[i] <= 10^5. Pls reply if you agree on this everyone."
                    },
                    {
                        "username": "psionl0",
                        "content": "The lack of other replies suggests that nobody agrees with you. This is an array of integers and 10^(-5) is not an integer."
                    },
                    {
                        "username": "buithanh2342002",
                        "content": "An array is monotonic if it is either monotone increasing or monotone decreasing. So, it\\'s supposed to be false if an array is not increasing or decreasing. [1,1,1,1] -> false"
                    },
                    {
                        "username": "psionl0",
                        "content": "LeetCode is not defining \"monotonic\" correctly. Mathematically speaking, a function is monotonic if no two elements from the domain map to the same element in the range. This means that the array should be strictly increasing or strictly decreasing and not merely non-decreasing or non-increasing."
                    },
                    {
                        "username": "m-shazaib",
                        "content": "Exactly"
                    },
                    {
                        "username": "m-shazaib",
                        "content": "basically break down the problem.\n1. for an array to be monotonic they can't have both tendencies. \n2. keeping the above in mind, check for previous and next elements in your array. \n3. now for comparing, you might use two variables of type bool, i.e isIncreasing and isDecreasing.\n4. Assign values to them.\n5. At the end check if your variables complies with point  1 above. (isIncreasing==isDecreasing)\n\nThis is a pseudocode. You still have some work to do mate.\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "pretty quiet before the storm comes....."
                    },
                    {
                        "username": "realitant",
                        "content": "Obviously python is a comparatively slow language, but does anyone have insight as to why it\\'s so slow on this problem in particular?\\nMy python and java solutions were both about 65%. Java ran in 2ms; Python was around 850ms.\\nI\\'m used to seeing about a 10x runtime differential. 425x is unexpected."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Harsh-br0](/Harsh-br0) it does, but java measurements here are nevertheless very stable.\\nMay be they commit a System.gc() after every call, excluding its time from summary, I don\\'t know."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@sergei99](/sergei99) java also have a GC , no?\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess they measure pure execution time for Java, while Python, Scala, etc. measurements include GC and other overhead. Even C++ execution s typically slower than Java."
                    }
                ]
            },
            {
                "id": 2077411,
                "content": [
                    {
                        "username": "knownfemme",
                        "content": "So, both the one pass solution and the double pass solution run in O(n) time. Therefore, for large inputs of data, we can expect both solutions to perform similarly. I want to argue the double pass solution is actually the better option because it should be easier to maintain in the long run. For example, it should be easier for someone unfamiliar with the code who might be tasked with updating it to look at it and determine how the code works.\\n\\nOf course, there the single pass solution is faster and arguably more clever. What are your opinions? If you had to defend a solution, which one would you defend and why? "
                    },
                    {
                        "username": "anshu22sri",
                        "content": "Can you help me with a problem??"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "You can instantly check whether or not an array is potentially monotone increasing or monotone decreasing by comparing the first and last element of said array."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@deCodeIt](/deCodeIt) It\\'s still not a great help. You are just adding a third case to the list: all elements are equal and we don\\'t have to check for this otherwise."
                    },
                    {
                        "username": "moris_7",
                        "content": "But if elements that are in the middle of 1st and last element, are greater than or less than 1st and last element then this method won\\'t work.\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "[@psionl0](/psionl0) well in that case all the elements in the array should be equal to it to be a monotone so it  still helps :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "That doesn\\'t help much if the first and last elements are the same."
                    },
                    {
                        "username": "phat_dang",
                        "content": "First we can detect the array is increasing or decreasing by comparing first and last elements\\nThen any 2 adjacent elements break that flag, considering as a false case"
                    },
                    {
                        "username": "s3stan",
                        "content": "Apparently tomorrow I\\'ll have to think carefully"
                    },
                    {
                        "username": "sk4142",
                        "content": "the calm before the storm"
                    },
                    {
                        "username": "Daksh_Makhija",
                        "content": "In constraints, it is given -10^5 <= nums[i] <= 10^5 . It should be 10^(-5) <= nums[i] <= 10^5. Pls reply if you agree on this everyone."
                    },
                    {
                        "username": "psionl0",
                        "content": "The lack of other replies suggests that nobody agrees with you. This is an array of integers and 10^(-5) is not an integer."
                    },
                    {
                        "username": "buithanh2342002",
                        "content": "An array is monotonic if it is either monotone increasing or monotone decreasing. So, it\\'s supposed to be false if an array is not increasing or decreasing. [1,1,1,1] -> false"
                    },
                    {
                        "username": "psionl0",
                        "content": "LeetCode is not defining \"monotonic\" correctly. Mathematically speaking, a function is monotonic if no two elements from the domain map to the same element in the range. This means that the array should be strictly increasing or strictly decreasing and not merely non-decreasing or non-increasing."
                    },
                    {
                        "username": "m-shazaib",
                        "content": "Exactly"
                    },
                    {
                        "username": "m-shazaib",
                        "content": "basically break down the problem.\n1. for an array to be monotonic they can't have both tendencies. \n2. keeping the above in mind, check for previous and next elements in your array. \n3. now for comparing, you might use two variables of type bool, i.e isIncreasing and isDecreasing.\n4. Assign values to them.\n5. At the end check if your variables complies with point  1 above. (isIncreasing==isDecreasing)\n\nThis is a pseudocode. You still have some work to do mate.\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "pretty quiet before the storm comes....."
                    },
                    {
                        "username": "realitant",
                        "content": "Obviously python is a comparatively slow language, but does anyone have insight as to why it\\'s so slow on this problem in particular?\\nMy python and java solutions were both about 65%. Java ran in 2ms; Python was around 850ms.\\nI\\'m used to seeing about a 10x runtime differential. 425x is unexpected."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Harsh-br0](/Harsh-br0) it does, but java measurements here are nevertheless very stable.\\nMay be they commit a System.gc() after every call, excluding its time from summary, I don\\'t know."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@sergei99](/sergei99) java also have a GC , no?\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess they measure pure execution time for Java, while Python, Scala, etc. measurements include GC and other overhead. Even C++ execution s typically slower than Java."
                    }
                ]
            },
            {
                "id": 2077095,
                "content": [
                    {
                        "username": "knownfemme",
                        "content": "So, both the one pass solution and the double pass solution run in O(n) time. Therefore, for large inputs of data, we can expect both solutions to perform similarly. I want to argue the double pass solution is actually the better option because it should be easier to maintain in the long run. For example, it should be easier for someone unfamiliar with the code who might be tasked with updating it to look at it and determine how the code works.\\n\\nOf course, there the single pass solution is faster and arguably more clever. What are your opinions? If you had to defend a solution, which one would you defend and why? "
                    },
                    {
                        "username": "anshu22sri",
                        "content": "Can you help me with a problem??"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "You can instantly check whether or not an array is potentially monotone increasing or monotone decreasing by comparing the first and last element of said array."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@deCodeIt](/deCodeIt) It\\'s still not a great help. You are just adding a third case to the list: all elements are equal and we don\\'t have to check for this otherwise."
                    },
                    {
                        "username": "moris_7",
                        "content": "But if elements that are in the middle of 1st and last element, are greater than or less than 1st and last element then this method won\\'t work.\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "[@psionl0](/psionl0) well in that case all the elements in the array should be equal to it to be a monotone so it  still helps :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "That doesn\\'t help much if the first and last elements are the same."
                    },
                    {
                        "username": "phat_dang",
                        "content": "First we can detect the array is increasing or decreasing by comparing first and last elements\\nThen any 2 adjacent elements break that flag, considering as a false case"
                    },
                    {
                        "username": "s3stan",
                        "content": "Apparently tomorrow I\\'ll have to think carefully"
                    },
                    {
                        "username": "sk4142",
                        "content": "the calm before the storm"
                    },
                    {
                        "username": "Daksh_Makhija",
                        "content": "In constraints, it is given -10^5 <= nums[i] <= 10^5 . It should be 10^(-5) <= nums[i] <= 10^5. Pls reply if you agree on this everyone."
                    },
                    {
                        "username": "psionl0",
                        "content": "The lack of other replies suggests that nobody agrees with you. This is an array of integers and 10^(-5) is not an integer."
                    },
                    {
                        "username": "buithanh2342002",
                        "content": "An array is monotonic if it is either monotone increasing or monotone decreasing. So, it\\'s supposed to be false if an array is not increasing or decreasing. [1,1,1,1] -> false"
                    },
                    {
                        "username": "psionl0",
                        "content": "LeetCode is not defining \"monotonic\" correctly. Mathematically speaking, a function is monotonic if no two elements from the domain map to the same element in the range. This means that the array should be strictly increasing or strictly decreasing and not merely non-decreasing or non-increasing."
                    },
                    {
                        "username": "m-shazaib",
                        "content": "Exactly"
                    },
                    {
                        "username": "m-shazaib",
                        "content": "basically break down the problem.\n1. for an array to be monotonic they can't have both tendencies. \n2. keeping the above in mind, check for previous and next elements in your array. \n3. now for comparing, you might use two variables of type bool, i.e isIncreasing and isDecreasing.\n4. Assign values to them.\n5. At the end check if your variables complies with point  1 above. (isIncreasing==isDecreasing)\n\nThis is a pseudocode. You still have some work to do mate.\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "pretty quiet before the storm comes....."
                    },
                    {
                        "username": "realitant",
                        "content": "Obviously python is a comparatively slow language, but does anyone have insight as to why it\\'s so slow on this problem in particular?\\nMy python and java solutions were both about 65%. Java ran in 2ms; Python was around 850ms.\\nI\\'m used to seeing about a 10x runtime differential. 425x is unexpected."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Harsh-br0](/Harsh-br0) it does, but java measurements here are nevertheless very stable.\\nMay be they commit a System.gc() after every call, excluding its time from summary, I don\\'t know."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@sergei99](/sergei99) java also have a GC , no?\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess they measure pure execution time for Java, while Python, Scala, etc. measurements include GC and other overhead. Even C++ execution s typically slower than Java."
                    }
                ]
            },
            {
                "id": 2077058,
                "content": [
                    {
                        "username": "knownfemme",
                        "content": "So, both the one pass solution and the double pass solution run in O(n) time. Therefore, for large inputs of data, we can expect both solutions to perform similarly. I want to argue the double pass solution is actually the better option because it should be easier to maintain in the long run. For example, it should be easier for someone unfamiliar with the code who might be tasked with updating it to look at it and determine how the code works.\\n\\nOf course, there the single pass solution is faster and arguably more clever. What are your opinions? If you had to defend a solution, which one would you defend and why? "
                    },
                    {
                        "username": "anshu22sri",
                        "content": "Can you help me with a problem??"
                    },
                    {
                        "username": "jenkunsen",
                        "content": "You can instantly check whether or not an array is potentially monotone increasing or monotone decreasing by comparing the first and last element of said array."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@deCodeIt](/deCodeIt) It\\'s still not a great help. You are just adding a third case to the list: all elements are equal and we don\\'t have to check for this otherwise."
                    },
                    {
                        "username": "moris_7",
                        "content": "But if elements that are in the middle of 1st and last element, are greater than or less than 1st and last element then this method won\\'t work.\\n"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "[@psionl0](/psionl0) well in that case all the elements in the array should be equal to it to be a monotone so it  still helps :)"
                    },
                    {
                        "username": "psionl0",
                        "content": "That doesn\\'t help much if the first and last elements are the same."
                    },
                    {
                        "username": "phat_dang",
                        "content": "First we can detect the array is increasing or decreasing by comparing first and last elements\\nThen any 2 adjacent elements break that flag, considering as a false case"
                    },
                    {
                        "username": "s3stan",
                        "content": "Apparently tomorrow I\\'ll have to think carefully"
                    },
                    {
                        "username": "sk4142",
                        "content": "the calm before the storm"
                    },
                    {
                        "username": "Daksh_Makhija",
                        "content": "In constraints, it is given -10^5 <= nums[i] <= 10^5 . It should be 10^(-5) <= nums[i] <= 10^5. Pls reply if you agree on this everyone."
                    },
                    {
                        "username": "psionl0",
                        "content": "The lack of other replies suggests that nobody agrees with you. This is an array of integers and 10^(-5) is not an integer."
                    },
                    {
                        "username": "buithanh2342002",
                        "content": "An array is monotonic if it is either monotone increasing or monotone decreasing. So, it\\'s supposed to be false if an array is not increasing or decreasing. [1,1,1,1] -> false"
                    },
                    {
                        "username": "psionl0",
                        "content": "LeetCode is not defining \"monotonic\" correctly. Mathematically speaking, a function is monotonic if no two elements from the domain map to the same element in the range. This means that the array should be strictly increasing or strictly decreasing and not merely non-decreasing or non-increasing."
                    },
                    {
                        "username": "m-shazaib",
                        "content": "Exactly"
                    },
                    {
                        "username": "m-shazaib",
                        "content": "basically break down the problem.\n1. for an array to be monotonic they can't have both tendencies. \n2. keeping the above in mind, check for previous and next elements in your array. \n3. now for comparing, you might use two variables of type bool, i.e isIncreasing and isDecreasing.\n4. Assign values to them.\n5. At the end check if your variables complies with point  1 above. (isIncreasing==isDecreasing)\n\nThis is a pseudocode. You still have some work to do mate.\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "pretty quiet before the storm comes....."
                    },
                    {
                        "username": "realitant",
                        "content": "Obviously python is a comparatively slow language, but does anyone have insight as to why it\\'s so slow on this problem in particular?\\nMy python and java solutions were both about 65%. Java ran in 2ms; Python was around 850ms.\\nI\\'m used to seeing about a 10x runtime differential. 425x is unexpected."
                    },
                    {
                        "username": "sergei99",
                        "content": "[@Harsh-br0](/Harsh-br0) it does, but java measurements here are nevertheless very stable.\\nMay be they commit a System.gc() after every call, excluding its time from summary, I don\\'t know."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "[@sergei99](/sergei99) java also have a GC , no?\\n"
                    },
                    {
                        "username": "sergei99",
                        "content": "I guess they measure pure execution time for Java, while Python, Scala, etc. measurements include GC and other overhead. Even C++ execution s typically slower than Java."
                    }
                ]
            },
            {
                "id": 2077057,
                "content": [
                    {
                        "username": "ajaystealths",
                        "content": "check for increasing and decreasing of array in single loop and return false if it\\'s follow both the conditions, else return true.\\nAgain an easy question on the LC.\\nHave a nice day ahead!!!"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "This is the calm before the storm. "
                    },
                    {
                        "username": "SG-C",
                        "content": "LeetCode end of month surprise \\uD83D\\uDE00 .\\nHappy LeetCoding !"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Good Friday , enjoy your friday\\n"
                    },
                    {
                        "username": "bughunter1712",
                        "content": "Today i got to know y spacing is important . The problem was pretty easy.:)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Lucky Friday**"
                    },
                    {
                        "username": "user0463au",
                        "content": "Happy Mid-Autumn Festival!\\n1 day left in Sep., almost there!"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "questions are easy in month last."
                    },
                    {
                        "username": "pankajkr_110",
                        "content": "leetcode hard is coming tommorow :)"
                    },
                    {
                        "username": "RuslanVdovychenko",
                        "content": "Java / Python3 / C++ solution (One-Pass, Summation)\\nhttps://leetcode.com/problems/monotonic-array/solutions/4104450/java-python3-c-solution-one-pass-summation/"
                    }
                ]
            },
            {
                "id": 2077046,
                "content": [
                    {
                        "username": "ajaystealths",
                        "content": "check for increasing and decreasing of array in single loop and return false if it\\'s follow both the conditions, else return true.\\nAgain an easy question on the LC.\\nHave a nice day ahead!!!"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "This is the calm before the storm. "
                    },
                    {
                        "username": "SG-C",
                        "content": "LeetCode end of month surprise \\uD83D\\uDE00 .\\nHappy LeetCoding !"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Good Friday , enjoy your friday\\n"
                    },
                    {
                        "username": "bughunter1712",
                        "content": "Today i got to know y spacing is important . The problem was pretty easy.:)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Lucky Friday**"
                    },
                    {
                        "username": "user0463au",
                        "content": "Happy Mid-Autumn Festival!\\n1 day left in Sep., almost there!"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "questions are easy in month last."
                    },
                    {
                        "username": "pankajkr_110",
                        "content": "leetcode hard is coming tommorow :)"
                    },
                    {
                        "username": "RuslanVdovychenko",
                        "content": "Java / Python3 / C++ solution (One-Pass, Summation)\\nhttps://leetcode.com/problems/monotonic-array/solutions/4104450/java-python3-c-solution-one-pass-summation/"
                    }
                ]
            },
            {
                "id": 2076996,
                "content": [
                    {
                        "username": "ajaystealths",
                        "content": "check for increasing and decreasing of array in single loop and return false if it\\'s follow both the conditions, else return true.\\nAgain an easy question on the LC.\\nHave a nice day ahead!!!"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "This is the calm before the storm. "
                    },
                    {
                        "username": "SG-C",
                        "content": "LeetCode end of month surprise \\uD83D\\uDE00 .\\nHappy LeetCoding !"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Good Friday , enjoy your friday\\n"
                    },
                    {
                        "username": "bughunter1712",
                        "content": "Today i got to know y spacing is important . The problem was pretty easy.:)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Lucky Friday**"
                    },
                    {
                        "username": "user0463au",
                        "content": "Happy Mid-Autumn Festival!\\n1 day left in Sep., almost there!"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "questions are easy in month last."
                    },
                    {
                        "username": "pankajkr_110",
                        "content": "leetcode hard is coming tommorow :)"
                    },
                    {
                        "username": "RuslanVdovychenko",
                        "content": "Java / Python3 / C++ solution (One-Pass, Summation)\\nhttps://leetcode.com/problems/monotonic-array/solutions/4104450/java-python3-c-solution-one-pass-summation/"
                    }
                ]
            },
            {
                "id": 2076986,
                "content": [
                    {
                        "username": "ajaystealths",
                        "content": "check for increasing and decreasing of array in single loop and return false if it\\'s follow both the conditions, else return true.\\nAgain an easy question on the LC.\\nHave a nice day ahead!!!"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "This is the calm before the storm. "
                    },
                    {
                        "username": "SG-C",
                        "content": "LeetCode end of month surprise \\uD83D\\uDE00 .\\nHappy LeetCoding !"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Good Friday , enjoy your friday\\n"
                    },
                    {
                        "username": "bughunter1712",
                        "content": "Today i got to know y spacing is important . The problem was pretty easy.:)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Lucky Friday**"
                    },
                    {
                        "username": "user0463au",
                        "content": "Happy Mid-Autumn Festival!\\n1 day left in Sep., almost there!"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "questions are easy in month last."
                    },
                    {
                        "username": "pankajkr_110",
                        "content": "leetcode hard is coming tommorow :)"
                    },
                    {
                        "username": "RuslanVdovychenko",
                        "content": "Java / Python3 / C++ solution (One-Pass, Summation)\\nhttps://leetcode.com/problems/monotonic-array/solutions/4104450/java-python3-c-solution-one-pass-summation/"
                    }
                ]
            },
            {
                "id": 2076898,
                "content": [
                    {
                        "username": "ajaystealths",
                        "content": "check for increasing and decreasing of array in single loop and return false if it\\'s follow both the conditions, else return true.\\nAgain an easy question on the LC.\\nHave a nice day ahead!!!"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "This is the calm before the storm. "
                    },
                    {
                        "username": "SG-C",
                        "content": "LeetCode end of month surprise \\uD83D\\uDE00 .\\nHappy LeetCoding !"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Good Friday , enjoy your friday\\n"
                    },
                    {
                        "username": "bughunter1712",
                        "content": "Today i got to know y spacing is important . The problem was pretty easy.:)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Lucky Friday**"
                    },
                    {
                        "username": "user0463au",
                        "content": "Happy Mid-Autumn Festival!\\n1 day left in Sep., almost there!"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "questions are easy in month last."
                    },
                    {
                        "username": "pankajkr_110",
                        "content": "leetcode hard is coming tommorow :)"
                    },
                    {
                        "username": "RuslanVdovychenko",
                        "content": "Java / Python3 / C++ solution (One-Pass, Summation)\\nhttps://leetcode.com/problems/monotonic-array/solutions/4104450/java-python3-c-solution-one-pass-summation/"
                    }
                ]
            },
            {
                "id": 2076860,
                "content": [
                    {
                        "username": "ajaystealths",
                        "content": "check for increasing and decreasing of array in single loop and return false if it\\'s follow both the conditions, else return true.\\nAgain an easy question on the LC.\\nHave a nice day ahead!!!"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "This is the calm before the storm. "
                    },
                    {
                        "username": "SG-C",
                        "content": "LeetCode end of month surprise \\uD83D\\uDE00 .\\nHappy LeetCoding !"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Good Friday , enjoy your friday\\n"
                    },
                    {
                        "username": "bughunter1712",
                        "content": "Today i got to know y spacing is important . The problem was pretty easy.:)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Lucky Friday**"
                    },
                    {
                        "username": "user0463au",
                        "content": "Happy Mid-Autumn Festival!\\n1 day left in Sep., almost there!"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "questions are easy in month last."
                    },
                    {
                        "username": "pankajkr_110",
                        "content": "leetcode hard is coming tommorow :)"
                    },
                    {
                        "username": "RuslanVdovychenko",
                        "content": "Java / Python3 / C++ solution (One-Pass, Summation)\\nhttps://leetcode.com/problems/monotonic-array/solutions/4104450/java-python3-c-solution-one-pass-summation/"
                    }
                ]
            },
            {
                "id": 2076828,
                "content": [
                    {
                        "username": "ajaystealths",
                        "content": "check for increasing and decreasing of array in single loop and return false if it\\'s follow both the conditions, else return true.\\nAgain an easy question on the LC.\\nHave a nice day ahead!!!"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "This is the calm before the storm. "
                    },
                    {
                        "username": "SG-C",
                        "content": "LeetCode end of month surprise \\uD83D\\uDE00 .\\nHappy LeetCoding !"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Good Friday , enjoy your friday\\n"
                    },
                    {
                        "username": "bughunter1712",
                        "content": "Today i got to know y spacing is important . The problem was pretty easy.:)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Lucky Friday**"
                    },
                    {
                        "username": "user0463au",
                        "content": "Happy Mid-Autumn Festival!\\n1 day left in Sep., almost there!"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "questions are easy in month last."
                    },
                    {
                        "username": "pankajkr_110",
                        "content": "leetcode hard is coming tommorow :)"
                    },
                    {
                        "username": "RuslanVdovychenko",
                        "content": "Java / Python3 / C++ solution (One-Pass, Summation)\\nhttps://leetcode.com/problems/monotonic-array/solutions/4104450/java-python3-c-solution-one-pass-summation/"
                    }
                ]
            },
            {
                "id": 2076794,
                "content": [
                    {
                        "username": "ajaystealths",
                        "content": "check for increasing and decreasing of array in single loop and return false if it\\'s follow both the conditions, else return true.\\nAgain an easy question on the LC.\\nHave a nice day ahead!!!"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "This is the calm before the storm. "
                    },
                    {
                        "username": "SG-C",
                        "content": "LeetCode end of month surprise \\uD83D\\uDE00 .\\nHappy LeetCoding !"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Good Friday , enjoy your friday\\n"
                    },
                    {
                        "username": "bughunter1712",
                        "content": "Today i got to know y spacing is important . The problem was pretty easy.:)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Lucky Friday**"
                    },
                    {
                        "username": "user0463au",
                        "content": "Happy Mid-Autumn Festival!\\n1 day left in Sep., almost there!"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "questions are easy in month last."
                    },
                    {
                        "username": "pankajkr_110",
                        "content": "leetcode hard is coming tommorow :)"
                    },
                    {
                        "username": "RuslanVdovychenko",
                        "content": "Java / Python3 / C++ solution (One-Pass, Summation)\\nhttps://leetcode.com/problems/monotonic-array/solutions/4104450/java-python3-c-solution-one-pass-summation/"
                    }
                ]
            },
            {
                "id": 2076787,
                "content": [
                    {
                        "username": "ajaystealths",
                        "content": "check for increasing and decreasing of array in single loop and return false if it\\'s follow both the conditions, else return true.\\nAgain an easy question on the LC.\\nHave a nice day ahead!!!"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "This is the calm before the storm. "
                    },
                    {
                        "username": "SG-C",
                        "content": "LeetCode end of month surprise \\uD83D\\uDE00 .\\nHappy LeetCoding !"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Good Friday , enjoy your friday\\n"
                    },
                    {
                        "username": "bughunter1712",
                        "content": "Today i got to know y spacing is important . The problem was pretty easy.:)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Lucky Friday**"
                    },
                    {
                        "username": "user0463au",
                        "content": "Happy Mid-Autumn Festival!\\n1 day left in Sep., almost there!"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "questions are easy in month last."
                    },
                    {
                        "username": "pankajkr_110",
                        "content": "leetcode hard is coming tommorow :)"
                    },
                    {
                        "username": "RuslanVdovychenko",
                        "content": "Java / Python3 / C++ solution (One-Pass, Summation)\\nhttps://leetcode.com/problems/monotonic-array/solutions/4104450/java-python3-c-solution-one-pass-summation/"
                    }
                ]
            },
            {
                "id": 2076770,
                "content": [
                    {
                        "username": "ajaystealths",
                        "content": "check for increasing and decreasing of array in single loop and return false if it\\'s follow both the conditions, else return true.\\nAgain an easy question on the LC.\\nHave a nice day ahead!!!"
                    },
                    {
                        "username": "rhugvedbhojane10",
                        "content": "This is the calm before the storm. "
                    },
                    {
                        "username": "SG-C",
                        "content": "LeetCode end of month surprise \\uD83D\\uDE00 .\\nHappy LeetCoding !"
                    },
                    {
                        "username": "mannchandarana",
                        "content": "Good Friday , enjoy your friday\\n"
                    },
                    {
                        "username": "bughunter1712",
                        "content": "Today i got to know y spacing is important . The problem was pretty easy.:)"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Lucky Friday**"
                    },
                    {
                        "username": "user0463au",
                        "content": "Happy Mid-Autumn Festival!\\n1 day left in Sep., almost there!"
                    },
                    {
                        "username": "iamkuldeep",
                        "content": "questions are easy in month last."
                    },
                    {
                        "username": "pankajkr_110",
                        "content": "leetcode hard is coming tommorow :)"
                    },
                    {
                        "username": "RuslanVdovychenko",
                        "content": "Java / Python3 / C++ solution (One-Pass, Summation)\\nhttps://leetcode.com/problems/monotonic-array/solutions/4104450/java-python3-c-solution-one-pass-summation/"
                    }
                ]
            },
            {
                "id": 2076747,
                "content": [
                    {
                        "username": "swnsma",
                        "content": "Thank you Leet Code for nice Friday!\\nThat\\'s what we all need after last few exhausting weeks of not-ordinary Medium questions.\\nStay tuned for weekend + End of the Month challenge!"
                    },
                    {
                        "username": "reassurance",
                        "content": "Wish our life would be this monotonically easy"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "Have a good day!"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Again easy-peasy."
                    },
                    {
                        "username": "Musfik41",
                        "content": "is monotonic means we have to check duplicate elements?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Duplicate elements will be together if the array is monotonic. No need to check for that - just move on."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Monotonic means the elements in the array are either consistently increasing or consistently decreasing. \n\n[1,1,1,2,2,2,3,3,34,4,4,4,4] at this time you have to consider dupicates also."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Sort method is enough to solve the problem but time comlexity will be high. \\nThe array contains either increasing or decreasing order ."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Easy \\uD83D\\uDE0C"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Sort the array, reverse sort it then enjoy the weekend !"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "No need to sort just iterate!"
                    },
                    {
                        "username": "verma1vedansh1",
                        "content": "Didn\\'t have anything to enjoy weekend hell for me doing House hold work of mom"
                    },
                    {
                        "username": "halfengineer",
                        "content": "That\\'s Suspicious\\uD83D\\uDE12\\uD83D\\uDE12,Something coming on weekend."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good easy days, enjoy as they last"
                    }
                ]
            },
            {
                "id": 2076676,
                "content": [
                    {
                        "username": "swnsma",
                        "content": "Thank you Leet Code for nice Friday!\\nThat\\'s what we all need after last few exhausting weeks of not-ordinary Medium questions.\\nStay tuned for weekend + End of the Month challenge!"
                    },
                    {
                        "username": "reassurance",
                        "content": "Wish our life would be this monotonically easy"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "Have a good day!"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Again easy-peasy."
                    },
                    {
                        "username": "Musfik41",
                        "content": "is monotonic means we have to check duplicate elements?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Duplicate elements will be together if the array is monotonic. No need to check for that - just move on."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Monotonic means the elements in the array are either consistently increasing or consistently decreasing. \n\n[1,1,1,2,2,2,3,3,34,4,4,4,4] at this time you have to consider dupicates also."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Sort method is enough to solve the problem but time comlexity will be high. \\nThe array contains either increasing or decreasing order ."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Easy \\uD83D\\uDE0C"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Sort the array, reverse sort it then enjoy the weekend !"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "No need to sort just iterate!"
                    },
                    {
                        "username": "verma1vedansh1",
                        "content": "Didn\\'t have anything to enjoy weekend hell for me doing House hold work of mom"
                    },
                    {
                        "username": "halfengineer",
                        "content": "That\\'s Suspicious\\uD83D\\uDE12\\uD83D\\uDE12,Something coming on weekend."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good easy days, enjoy as they last"
                    }
                ]
            },
            {
                "id": 2076657,
                "content": [
                    {
                        "username": "swnsma",
                        "content": "Thank you Leet Code for nice Friday!\\nThat\\'s what we all need after last few exhausting weeks of not-ordinary Medium questions.\\nStay tuned for weekend + End of the Month challenge!"
                    },
                    {
                        "username": "reassurance",
                        "content": "Wish our life would be this monotonically easy"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "Have a good day!"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Again easy-peasy."
                    },
                    {
                        "username": "Musfik41",
                        "content": "is monotonic means we have to check duplicate elements?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Duplicate elements will be together if the array is monotonic. No need to check for that - just move on."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Monotonic means the elements in the array are either consistently increasing or consistently decreasing. \n\n[1,1,1,2,2,2,3,3,34,4,4,4,4] at this time you have to consider dupicates also."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Sort method is enough to solve the problem but time comlexity will be high. \\nThe array contains either increasing or decreasing order ."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Easy \\uD83D\\uDE0C"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Sort the array, reverse sort it then enjoy the weekend !"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "No need to sort just iterate!"
                    },
                    {
                        "username": "verma1vedansh1",
                        "content": "Didn\\'t have anything to enjoy weekend hell for me doing House hold work of mom"
                    },
                    {
                        "username": "halfengineer",
                        "content": "That\\'s Suspicious\\uD83D\\uDE12\\uD83D\\uDE12,Something coming on weekend."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good easy days, enjoy as they last"
                    }
                ]
            },
            {
                "id": 2076640,
                "content": [
                    {
                        "username": "swnsma",
                        "content": "Thank you Leet Code for nice Friday!\\nThat\\'s what we all need after last few exhausting weeks of not-ordinary Medium questions.\\nStay tuned for weekend + End of the Month challenge!"
                    },
                    {
                        "username": "reassurance",
                        "content": "Wish our life would be this monotonically easy"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "Have a good day!"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Again easy-peasy."
                    },
                    {
                        "username": "Musfik41",
                        "content": "is monotonic means we have to check duplicate elements?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Duplicate elements will be together if the array is monotonic. No need to check for that - just move on."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Monotonic means the elements in the array are either consistently increasing or consistently decreasing. \n\n[1,1,1,2,2,2,3,3,34,4,4,4,4] at this time you have to consider dupicates also."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Sort method is enough to solve the problem but time comlexity will be high. \\nThe array contains either increasing or decreasing order ."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Easy \\uD83D\\uDE0C"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Sort the array, reverse sort it then enjoy the weekend !"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "No need to sort just iterate!"
                    },
                    {
                        "username": "verma1vedansh1",
                        "content": "Didn\\'t have anything to enjoy weekend hell for me doing House hold work of mom"
                    },
                    {
                        "username": "halfengineer",
                        "content": "That\\'s Suspicious\\uD83D\\uDE12\\uD83D\\uDE12,Something coming on weekend."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good easy days, enjoy as they last"
                    }
                ]
            },
            {
                "id": 2076556,
                "content": [
                    {
                        "username": "swnsma",
                        "content": "Thank you Leet Code for nice Friday!\\nThat\\'s what we all need after last few exhausting weeks of not-ordinary Medium questions.\\nStay tuned for weekend + End of the Month challenge!"
                    },
                    {
                        "username": "reassurance",
                        "content": "Wish our life would be this monotonically easy"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "Have a good day!"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Again easy-peasy."
                    },
                    {
                        "username": "Musfik41",
                        "content": "is monotonic means we have to check duplicate elements?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Duplicate elements will be together if the array is monotonic. No need to check for that - just move on."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Monotonic means the elements in the array are either consistently increasing or consistently decreasing. \n\n[1,1,1,2,2,2,3,3,34,4,4,4,4] at this time you have to consider dupicates also."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Sort method is enough to solve the problem but time comlexity will be high. \\nThe array contains either increasing or decreasing order ."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Easy \\uD83D\\uDE0C"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Sort the array, reverse sort it then enjoy the weekend !"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "No need to sort just iterate!"
                    },
                    {
                        "username": "verma1vedansh1",
                        "content": "Didn\\'t have anything to enjoy weekend hell for me doing House hold work of mom"
                    },
                    {
                        "username": "halfengineer",
                        "content": "That\\'s Suspicious\\uD83D\\uDE12\\uD83D\\uDE12,Something coming on weekend."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good easy days, enjoy as they last"
                    }
                ]
            },
            {
                "id": 2076545,
                "content": [
                    {
                        "username": "swnsma",
                        "content": "Thank you Leet Code for nice Friday!\\nThat\\'s what we all need after last few exhausting weeks of not-ordinary Medium questions.\\nStay tuned for weekend + End of the Month challenge!"
                    },
                    {
                        "username": "reassurance",
                        "content": "Wish our life would be this monotonically easy"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "Have a good day!"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Again easy-peasy."
                    },
                    {
                        "username": "Musfik41",
                        "content": "is monotonic means we have to check duplicate elements?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Duplicate elements will be together if the array is monotonic. No need to check for that - just move on."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Monotonic means the elements in the array are either consistently increasing or consistently decreasing. \n\n[1,1,1,2,2,2,3,3,34,4,4,4,4] at this time you have to consider dupicates also."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Sort method is enough to solve the problem but time comlexity will be high. \\nThe array contains either increasing or decreasing order ."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Easy \\uD83D\\uDE0C"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Sort the array, reverse sort it then enjoy the weekend !"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "No need to sort just iterate!"
                    },
                    {
                        "username": "verma1vedansh1",
                        "content": "Didn\\'t have anything to enjoy weekend hell for me doing House hold work of mom"
                    },
                    {
                        "username": "halfengineer",
                        "content": "That\\'s Suspicious\\uD83D\\uDE12\\uD83D\\uDE12,Something coming on weekend."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good easy days, enjoy as they last"
                    }
                ]
            },
            {
                "id": 2076489,
                "content": [
                    {
                        "username": "swnsma",
                        "content": "Thank you Leet Code for nice Friday!\\nThat\\'s what we all need after last few exhausting weeks of not-ordinary Medium questions.\\nStay tuned for weekend + End of the Month challenge!"
                    },
                    {
                        "username": "reassurance",
                        "content": "Wish our life would be this monotonically easy"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "Have a good day!"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Again easy-peasy."
                    },
                    {
                        "username": "Musfik41",
                        "content": "is monotonic means we have to check duplicate elements?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Duplicate elements will be together if the array is monotonic. No need to check for that - just move on."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Monotonic means the elements in the array are either consistently increasing or consistently decreasing. \n\n[1,1,1,2,2,2,3,3,34,4,4,4,4] at this time you have to consider dupicates also."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Sort method is enough to solve the problem but time comlexity will be high. \\nThe array contains either increasing or decreasing order ."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Easy \\uD83D\\uDE0C"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Sort the array, reverse sort it then enjoy the weekend !"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "No need to sort just iterate!"
                    },
                    {
                        "username": "verma1vedansh1",
                        "content": "Didn\\'t have anything to enjoy weekend hell for me doing House hold work of mom"
                    },
                    {
                        "username": "halfengineer",
                        "content": "That\\'s Suspicious\\uD83D\\uDE12\\uD83D\\uDE12,Something coming on weekend."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good easy days, enjoy as they last"
                    }
                ]
            },
            {
                "id": 2076485,
                "content": [
                    {
                        "username": "swnsma",
                        "content": "Thank you Leet Code for nice Friday!\\nThat\\'s what we all need after last few exhausting weeks of not-ordinary Medium questions.\\nStay tuned for weekend + End of the Month challenge!"
                    },
                    {
                        "username": "reassurance",
                        "content": "Wish our life would be this monotonically easy"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "Have a good day!"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Again easy-peasy."
                    },
                    {
                        "username": "Musfik41",
                        "content": "is monotonic means we have to check duplicate elements?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Duplicate elements will be together if the array is monotonic. No need to check for that - just move on."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Monotonic means the elements in the array are either consistently increasing or consistently decreasing. \n\n[1,1,1,2,2,2,3,3,34,4,4,4,4] at this time you have to consider dupicates also."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Sort method is enough to solve the problem but time comlexity will be high. \\nThe array contains either increasing or decreasing order ."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Easy \\uD83D\\uDE0C"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Sort the array, reverse sort it then enjoy the weekend !"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "No need to sort just iterate!"
                    },
                    {
                        "username": "verma1vedansh1",
                        "content": "Didn\\'t have anything to enjoy weekend hell for me doing House hold work of mom"
                    },
                    {
                        "username": "halfengineer",
                        "content": "That\\'s Suspicious\\uD83D\\uDE12\\uD83D\\uDE12,Something coming on weekend."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good easy days, enjoy as they last"
                    }
                ]
            },
            {
                "id": 2076478,
                "content": [
                    {
                        "username": "swnsma",
                        "content": "Thank you Leet Code for nice Friday!\\nThat\\'s what we all need after last few exhausting weeks of not-ordinary Medium questions.\\nStay tuned for weekend + End of the Month challenge!"
                    },
                    {
                        "username": "reassurance",
                        "content": "Wish our life would be this monotonically easy"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "Have a good day!"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Again easy-peasy."
                    },
                    {
                        "username": "Musfik41",
                        "content": "is monotonic means we have to check duplicate elements?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Duplicate elements will be together if the array is monotonic. No need to check for that - just move on."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Monotonic means the elements in the array are either consistently increasing or consistently decreasing. \n\n[1,1,1,2,2,2,3,3,34,4,4,4,4] at this time you have to consider dupicates also."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Sort method is enough to solve the problem but time comlexity will be high. \\nThe array contains either increasing or decreasing order ."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Easy \\uD83D\\uDE0C"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Sort the array, reverse sort it then enjoy the weekend !"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "No need to sort just iterate!"
                    },
                    {
                        "username": "verma1vedansh1",
                        "content": "Didn\\'t have anything to enjoy weekend hell for me doing House hold work of mom"
                    },
                    {
                        "username": "halfengineer",
                        "content": "That\\'s Suspicious\\uD83D\\uDE12\\uD83D\\uDE12,Something coming on weekend."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good easy days, enjoy as they last"
                    }
                ]
            },
            {
                "id": 2076462,
                "content": [
                    {
                        "username": "swnsma",
                        "content": "Thank you Leet Code for nice Friday!\\nThat\\'s what we all need after last few exhausting weeks of not-ordinary Medium questions.\\nStay tuned for weekend + End of the Month challenge!"
                    },
                    {
                        "username": "reassurance",
                        "content": "Wish our life would be this monotonically easy"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "Have a good day!"
                    },
                    {
                        "username": "SaiTarun2502",
                        "content": "Again easy-peasy."
                    },
                    {
                        "username": "Musfik41",
                        "content": "is monotonic means we have to check duplicate elements?"
                    },
                    {
                        "username": "psionl0",
                        "content": "Duplicate elements will be together if the array is monotonic. No need to check for that - just move on."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Monotonic means the elements in the array are either consistently increasing or consistently decreasing. \n\n[1,1,1,2,2,2,3,3,34,4,4,4,4] at this time you have to consider dupicates also."
                    },
                    {
                        "username": "adish_ct",
                        "content": "Sort method is enough to solve the problem but time comlexity will be high. \\nThe array contains either increasing or decreasing order ."
                    },
                    {
                        "username": "Rahul_108",
                        "content": "Easy \\uD83D\\uDE0C"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Sort the array, reverse sort it then enjoy the weekend !"
                    },
                    {
                        "username": "Rahul_108",
                        "content": "No need to sort just iterate!"
                    },
                    {
                        "username": "verma1vedansh1",
                        "content": "Didn\\'t have anything to enjoy weekend hell for me doing House hold work of mom"
                    },
                    {
                        "username": "halfengineer",
                        "content": "That\\'s Suspicious\\uD83D\\uDE12\\uD83D\\uDE12,Something coming on weekend."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good easy days, enjoy as they last"
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Paths with Max Score",
        "question_content": "<p>You are given a square <code>board</code>&nbsp;of characters. You can move on the board starting at the bottom right square marked with the character&nbsp;<code>&#39;S&#39;</code>.</p>\r\n\r\n<p>You need&nbsp;to reach the top left square marked with the character <code>&#39;E&#39;</code>. The rest of the squares are labeled either with a numeric character&nbsp;<code>1, 2, ..., 9</code> or with an obstacle <code>&#39;X&#39;</code>. In one move you can go up, left or up-left (diagonally) only if there is no obstacle there.</p>\r\n\r\n<p>Return a list of two integers: the first integer is the maximum sum of numeric characters you can collect, and the second is the number of such paths that you can take to get that maximum sum, <strong>taken modulo <code>10^9 + 7</code></strong>.</p>\r\n\r\n<p>In case there is no path, return&nbsp;<code>[0, 0]</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong class=\"example\">Example 1:</strong></p>\r\n<pre><strong>Input:</strong> board = [\"E23\",\"2X2\",\"12S\"]\r\n<strong>Output:</strong> [7,1]\r\n</pre><p><strong class=\"example\">Example 2:</strong></p>\r\n<pre><strong>Input:</strong> board = [\"E12\",\"1X1\",\"21S\"]\r\n<strong>Output:</strong> [4,2]\r\n</pre><p><strong class=\"example\">Example 3:</strong></p>\r\n<pre><strong>Input:</strong> board = [\"E11\",\"XXX\",\"11S\"]\r\n<strong>Output:</strong> [0,0]\r\n</pre>\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>2 &lt;= board.length == board[i].length &lt;= 100</code></li>\r\n</ul>",
        "solutions": [
            {
                "id": 463252,
                "title": "python-dp-solution",
                "content": "## **Explanation**\\nWe create 3D `dp[x][y]`, where\\n`dp[x][y][0]` is the maximum value to this cell,\\n`dp[x][y][1]` is the number of paths.\\n<br>\\n\\n## **Complexity**\\nTime `O(N^2)`\\nSpace `O(N^2)`\\n<br>\\n\\n\\n**Python:**\\n```python\\n    def pathsWithMaxScore(self, A):\\n        n, mod = len(A), 10**9 + 7\\n        dp = [[[-10**5, 0] for j in xrange(n + 1)] for i in xrange(n + 1)]\\n        dp[n - 1][n - 1] = [0, 1]\\n        for x in range(n)[::-1]:\\n            for y in range(n)[::-1]:\\n                if A[x][y] in \\'XS\\': continue\\n                for i, j in [[0, 1], [1, 0], [1, 1]]:\\n                    if dp[x][y][0] < dp[x + i][y + j][0]:\\n                        dp[x][y] = [dp[x + i][y + j][0], 0]\\n                    if dp[x][y][0] == dp[x + i][y + j][0]:\\n                        dp[x][y][1] += dp[x + i][y + j][1]\\n                dp[x][y][0] += int(A[x][y]) if x or y else 0\\n        return [dp[0][0][0] if dp[0][0][1] else 0, dp[0][0][1] % mod]\\n```\\n",
                "solutionTags": [],
                "code": "```python\\n    def pathsWithMaxScore(self, A):\\n        n, mod = len(A), 10**9 + 7\\n        dp = [[[-10**5, 0] for j in xrange(n + 1)] for i in xrange(n + 1)]\\n        dp[n - 1][n - 1] = [0, 1]\\n        for x in range(n)[::-1]:\\n            for y in range(n)[::-1]:\\n                if A[x][y] in \\'XS\\': continue\\n                for i, j in [[0, 1], [1, 0], [1, 1]]:\\n                    if dp[x][y][0] < dp[x + i][y + j][0]:\\n                        dp[x][y] = [dp[x + i][y + j][0], 0]\\n                    if dp[x][y][0] == dp[x + i][y + j][0]:\\n                        dp[x][y][1] += dp[x + i][y + j][1]\\n                dp[x][y][0] += int(A[x][y]) if x or y else 0\\n        return [dp[0][0][0] if dp[0][0][1] else 0, dp[0][0][1] % mod]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 463196,
                "title": "java-dp-solution-clean-code-o-m-n",
                "content": "**Complexity**\\n- Time: `O(m*n)`, `m` is the number of rows, `n` is the number of columns of the `board`, (m, n <= 100)\\n- Space: `O(m*n)`\\n\\n**Java**\\n```java\\nclass Solution {\\n    private static final int[][] DIRS = new int[][]{{0, -1}, {-1, 0}, {-1, -1}};\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int m = board.size(), n = board.get(0).length();\\n        int[][] dpSum = new int[m][n];\\n        int[][] dpCnt = new int[m][n];\\n        dpCnt[m - 1][n - 1] = 1; // start at the bottom right square\\n        for (int r = m - 1; r >= 0; r--) {\\n            for (int c = n - 1; c >= 0; c--) {\\n                if (dpCnt[r][c] == 0) continue; // can\\'t reach to this square\\n                for (int[] dir : DIRS) {\\n                    int nr = r + dir[0], nc = c + dir[1];\\n                    if (nr >= 0 && nc >= 0 && board.get(nr).charAt(nc) != \\'X\\') {\\n                        int nsum = dpSum[r][c];\\n                        if (board.get(nr).charAt(nc) != \\'E\\')\\n                            nsum += board.get(nr).charAt(nc) - \\'0\\';\\n                        if (nsum > dpSum[nr][nc]) {\\n                            dpCnt[nr][nc] = dpCnt[r][c];\\n                            dpSum[nr][nc] = nsum;\\n                        } else if (nsum == dpSum[nr][nc]) {\\n                            dpCnt[nr][nc] = (dpCnt[nr][nc] + dpCnt[r][c]) % 1000000007;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return new int[]{dpSum[0][0], dpCnt[0][0]};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    private static final int[][] DIRS = new int[][]{{0, -1}, {-1, 0}, {-1, -1}};\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int m = board.size(), n = board.get(0).length();\\n        int[][] dpSum = new int[m][n];\\n        int[][] dpCnt = new int[m][n];\\n        dpCnt[m - 1][n - 1] = 1; // start at the bottom right square\\n        for (int r = m - 1; r >= 0; r--) {\\n            for (int c = n - 1; c >= 0; c--) {\\n                if (dpCnt[r][c] == 0) continue; // can\\'t reach to this square\\n                for (int[] dir : DIRS) {\\n                    int nr = r + dir[0], nc = c + dir[1];\\n                    if (nr >= 0 && nc >= 0 && board.get(nr).charAt(nc) != \\'X\\') {\\n                        int nsum = dpSum[r][c];\\n                        if (board.get(nr).charAt(nc) != \\'E\\')\\n                            nsum += board.get(nr).charAt(nc) - \\'0\\';\\n                        if (nsum > dpSum[nr][nc]) {\\n                            dpCnt[nr][nc] = dpCnt[r][c];\\n                            dpSum[nr][nc] = nsum;\\n                        } else if (nsum == dpSum[nr][nc]) {\\n                            dpCnt[nr][nc] = (dpCnt[nr][nc] + dpCnt[r][c]) % 1000000007;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return new int[]{dpSum[0][0], dpCnt[0][0]};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463539,
                "title": "c-dp",
                "content": "Track the maximum score and paths for each cell from 3 directions:\\n- The starting cell has score `0` and `1` paths.\\n- If the current score for a cell is smaller, update it and **overwrite** the number of paths. \\n- If the score in the same, **add** the number of paths.\\n```CPP\\nvector<vector<int>> dirs {{1, 0}, {0, 1}, {1, 1}};\\nvector<int> pathsWithMaxScore(vector<string>& board) {\\n    auto sz = board.size();\\n    vector<vector<int>> score(sz + 1, vector<int>(sz + 1)), paths(sz + 1, vector<int>(sz + 1));\\n    board[0][0] = board[sz - 1][sz - 1] = \\'0\\';\\n    paths[0][0] = 1;\\n    for (int i = 1; i <= sz; ++i) {\\n        for (int j = 1; j <= sz; ++j) {\\n            if (board[i - 1][j - 1] == \\'X\\') \\n                continue;\\n            for (auto d : dirs) {\\n                auto i1 = i - d[0], j1 = j - d[1];\\n                auto val = score[i1][j1] + (board[i - 1][j - 1] - \\'0\\');\\n                if (score[i][j] <= val && paths[i1][j1] > 0) {\\n                    paths[i][j] = ((score[i][j] == val ? paths[i][j] : 0) + paths[i1][j1]) % 1000000007; \\n                    score[i][j] = val;\\n                }\\n            }\\n        }\\n    }\\n    return {paths[sz][sz] ? score[sz][sz] : 0, paths[sz][sz]};\\n} \\n```",
                "solutionTags": [],
                "code": "```CPP\\nvector<vector<int>> dirs {{1, 0}, {0, 1}, {1, 1}};\\nvector<int> pathsWithMaxScore(vector<string>& board) {\\n    auto sz = board.size();\\n    vector<vector<int>> score(sz + 1, vector<int>(sz + 1)), paths(sz + 1, vector<int>(sz + 1));\\n    board[0][0] = board[sz - 1][sz - 1] = \\'0\\';\\n    paths[0][0] = 1;\\n    for (int i = 1; i <= sz; ++i) {\\n        for (int j = 1; j <= sz; ++j) {\\n            if (board[i - 1][j - 1] == \\'X\\') \\n                continue;\\n            for (auto d : dirs) {\\n                auto i1 = i - d[0], j1 = j - d[1];\\n                auto val = score[i1][j1] + (board[i - 1][j - 1] - \\'0\\');\\n                if (score[i][j] <= val && paths[i1][j1] > 0) {\\n                    paths[i][j] = ((score[i][j] == val ? paths[i][j] : 0) + paths[i1][j1]) % 1000000007; \\n                    score[i][j] = val;\\n                }\\n            }\\n        }\\n    }\\n    return {paths[sz][sz] ? score[sz][sz] : 0, paths[sz][sz]};\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 463181,
                "title": "c-easy-to-understand-recursion-with-memoization-o-mn",
                "content": "```\\nclass Solution {\\npublic:\\n    long MOD;\\n    pair<int, long> dp[101][101];\\n    pair<int, long> f(vector<string>& A, int i, int j) {\\n        int n = A.size(), m = A[0].size();\\n        if(i >= n || j >= m || A[i][j] == \\'X\\')\\n            return { -1e5, 0 };\\n        int val = A[i][j] - \\'0\\';\\n        if(A[i][j] == \\'E\\')\\n            val = 0;\\n        if(i == n - 1 && j == m - 1)\\n            return { 0, 1 };\\n        pair<int, long> p1 = { -1, -1ll };\\n        if(dp[i][j] != p1)\\n            return dp[i][j];\\n        auto op1 = f(A, i + 1, j);\\n        auto op2 = f(A, i, j + 1);\\n        auto op3 = f(A, i + 1, j + 1);\\n        int cnt = 0;\\n        int ans = val + max(op1.first, max(op2.first, op3.first));\\n        if(val + op1.first == ans) cnt += op1.second; cnt %= MOD;\\n        if(val + op2.first == ans) cnt += op2.second; cnt %= MOD;\\n        if(val + op3.first == ans) cnt += op3.second; cnt %= MOD;\\n        return dp[i][j] = { ans, cnt % MOD };\\n    }\\n    \\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        MOD = 1e9 + 7;\\n        pair<int, int> p1 = { -1, -1ll };\\n        for(int i = 0; i <= 100; i++)\\n            for(int j = 0; j <= 100; j++)\\n                dp[i][j] = p1;\\n        auto p = f(board, 0, 0);\\n        if(p.first <= 0)\\n            p.first = 0;\\n        return { p.first, (int)p.second };\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long MOD;\\n    pair<int, long> dp[101][101];\\n    pair<int, long> f(vector<string>& A, int i, int j) {\\n        int n = A.size(), m = A[0].size();\\n        if(i >= n || j >= m || A[i][j] == \\'X\\')\\n            return { -1e5, 0 };\\n        int val = A[i][j] - \\'0\\';\\n        if(A[i][j] == \\'E\\')\\n            val = 0;\\n        if(i == n - 1 && j == m - 1)\\n            return { 0, 1 };\\n        pair<int, long> p1 = { -1, -1ll };\\n        if(dp[i][j] != p1)\\n            return dp[i][j];\\n        auto op1 = f(A, i + 1, j);\\n        auto op2 = f(A, i, j + 1);\\n        auto op3 = f(A, i + 1, j + 1);\\n        int cnt = 0;\\n        int ans = val + max(op1.first, max(op2.first, op3.first));\\n        if(val + op1.first == ans) cnt += op1.second; cnt %= MOD;\\n        if(val + op2.first == ans) cnt += op2.second; cnt %= MOD;\\n        if(val + op3.first == ans) cnt += op3.second; cnt %= MOD;\\n        return dp[i][j] = { ans, cnt % MOD };\\n    }\\n    \\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        MOD = 1e9 + 7;\\n        pair<int, int> p1 = { -1, -1ll };\\n        for(int i = 0; i <= 100; i++)\\n            for(int j = 0; j <= 100; j++)\\n                dp[i][j] = p1;\\n        auto p = f(board, 0, 0);\\n        if(p.first <= 0)\\n            p.first = 0;\\n        return { p.first, (int)p.second };\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463207,
                "title": "java-dp-easy-to-understand-o-n-2",
                "content": "```\\npublic int[] pathsWithMaxScore(List<String> board) {\\n        int len = board.size();\\n        int mod = 1000000007;\\n        char[][] map = new char[len][len];\\n        int[][] score = new int[len][len];\\n        int[][] paths = new int[len][len];\\n        for(int i = 0; i < len; i++)map[i] = board.get(i).toCharArray();\\n\\t\\t// just go from top left to bottom right, and set topLeft and bottomRight to \\'0\\' to avoid calculation of \\'E\\',\\'S\\'\\n        map[len-1][len-1] = \\'0\\';\\n        map[0][0] = \\'0\\';\\n        paths[0][0] = 1;\\n        for(int i = 1; i < len; i++){\\n            if(map[0][i] == \\'X\\')break;\\n            score[0][i] = score[0][i-1] + (map[0][i] - \\'0\\');\\n            paths[0][i] = 1;\\n        }\\n        for(int i = 1; i < len; i++){\\n            if(map[i][0] == \\'X\\')break;\\n            score[i][0] = score[i-1][0] + (map[i][0] - \\'0\\');\\n            paths[i][0] = 1;\\n        }\\n        if(len == 2 && map[0][1] == \\'X\\' && map[1][0] == \\'X\\')return new int[]{0, 1};\\n        for(int i = 1; i < len; i++){\\n            for(int j = 1; j < len; j++){\\n                if(map[i][j] == \\'X\\')continue;\\n                int tmpScore = Math.max(score[i-1][j-1], Math.max(score[i-1][j], score[i][j-1]));\\n                if(tmpScore == 0)continue;\\n                int tmpPaths = 0;\\n                if(tmpScore == score[i-1][j-1])tmpPaths += paths[i-1][j-1];\\n                if(tmpScore == score[i-1][j])tmpPaths += paths[i-1][j];\\n                if(tmpScore == score[i][j-1])tmpPaths += paths[i][j-1];\\n                paths[i][j] = tmpPaths % mod;\\n                score[i][j] = tmpScore + (map[i][j] - \\'0\\');\\n            }\\n        }\\n        return new int[]{score[len-1][len-1], paths[len-1][len-1]};\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] pathsWithMaxScore(List<String> board) {\\n        int len = board.size();\\n        int mod = 1000000007;\\n        char[][] map = new char[len][len];\\n        int[][] score = new int[len][len];\\n        int[][] paths = new int[len][len];\\n        for(int i = 0; i < len; i++)map[i] = board.get(i).toCharArray();\\n\\t\\t// just go from top left to bottom right, and set topLeft and bottomRight to \\'0\\' to avoid calculation of \\'E\\',\\'S\\'\\n        map[len-1][len-1] = \\'0\\';\\n        map[0][0] = \\'0\\';\\n        paths[0][0] = 1;\\n        for(int i = 1; i < len; i++){\\n            if(map[0][i] == \\'X\\')break;\\n            score[0][i] = score[0][i-1] + (map[0][i] - \\'0\\');\\n            paths[0][i] = 1;\\n        }\\n        for(int i = 1; i < len; i++){\\n            if(map[i][0] == \\'X\\')break;\\n            score[i][0] = score[i-1][0] + (map[i][0] - \\'0\\');\\n            paths[i][0] = 1;\\n        }\\n        if(len == 2 && map[0][1] == \\'X\\' && map[1][0] == \\'X\\')return new int[]{0, 1};\\n        for(int i = 1; i < len; i++){\\n            for(int j = 1; j < len; j++){\\n                if(map[i][j] == \\'X\\')continue;\\n                int tmpScore = Math.max(score[i-1][j-1], Math.max(score[i-1][j], score[i][j-1]));\\n                if(tmpScore == 0)continue;\\n                int tmpPaths = 0;\\n                if(tmpScore == score[i-1][j-1])tmpPaths += paths[i-1][j-1];\\n                if(tmpScore == score[i-1][j])tmpPaths += paths[i-1][j];\\n                if(tmpScore == score[i][j-1])tmpPaths += paths[i][j-1];\\n                paths[i][j] = tmpPaths % mod;\\n                score[i][j] = tmpScore + (map[i][j] - \\'0\\');\\n            }\\n        }\\n        return new int[]{score[len-1][len-1], paths[len-1][len-1]};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 464141,
                "title": "python-simplest-dfs-memo-solution",
                "content": "```\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        m = len(board)\\n        n = len(board[0])\\n        \\n        from functools import lru_cache\\n        @lru_cache(maxsize = None)\\n        def dfs(i,j,count):\\n            if i == 0 and j == 0:\\n                return 0, 1\\n            if i < 0 or j < 0 or board[i][j] == \"X\":\\n                return -float(\"inf\"), -float(\"inf\")\\n            \\n            count = 0\\n            \\n            temp = int(board[i][j]) if board[i][j] != \"S\" else 0\\n            \\n            c1, r1 = dfs(i-1,j,count+1)\\n            c2, r2 = dfs(i,j-1,count+1)\\n            c3, r3 = dfs(i-1,j-1,count+1)\\n            \\n            max_path = max(c1,c2,c3)\\n            \\n            for x,y in ((c1,r1),(c2,r2),(c3,r3)):\\n                if x == max_path:\\n                    count += y\\n            \\n            return temp+max_path, count\\n        \\n        \\n        a, b = dfs(m-1,n-1,0)\\n        \\n        return [a%(10**9+7), b%(10**9+7)] if a!= -float(\"inf\") or b != -float(\"inf\") else [0, 0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        m = len(board)\\n        n = len(board[0])\\n        \\n        from functools import lru_cache\\n        @lru_cache(maxsize = None)\\n        def dfs(i,j,count):\\n            if i == 0 and j == 0:\\n                return 0, 1\\n            if i < 0 or j < 0 or board[i][j] == \"X\":\\n                return -float(\"inf\"), -float(\"inf\")\\n            \\n            count = 0\\n            \\n            temp = int(board[i][j]) if board[i][j] != \"S\" else 0\\n            \\n            c1, r1 = dfs(i-1,j,count+1)\\n            c2, r2 = dfs(i,j-1,count+1)\\n            c3, r3 = dfs(i-1,j-1,count+1)\\n            \\n            max_path = max(c1,c2,c3)\\n            \\n            for x,y in ((c1,r1),(c2,r2),(c3,r3)):\\n                if x == max_path:\\n                    count += y\\n            \\n            return temp+max_path, count\\n        \\n        \\n        a, b = dfs(m-1,n-1,0)\\n        \\n        return [a%(10**9+7), b%(10**9+7)] if a!= -float(\"inf\") or b != -float(\"inf\") else [0, 0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463183,
                "title": "java-recursion-memoization",
                "content": "```\\nclass Pair{\\n    int val;\\n    long paths;\\n    Pair(int val, long paths){\\n        this.val = val;\\n        this.paths = paths;\\n    }\\n}\\nclass Solution {\\n    static int mod = (int)Math.pow(10, 9) + 7;\\n    public static Pair func(List<String> arr, int i, int j, Pair[][] dp){\\n        if(i == 0 && j == 0) return new Pair(0, 1);\\n        if(i < 0 || j < 0 || arr.get(i).charAt(j) == \\'X\\') return new Pair(Integer.MIN_VALUE, 0);\\n        if(dp[i][j] != null) return dp[i][j];\\n        int curr = 0;\\n        if(arr.get(i).charAt(j) != \\'S\\') curr = (arr.get(i).charAt(j)) - \\'0\\';\\n        Pair x1 = func(arr,i - 1, j, dp);\\n        Pair x2 = func(arr, i, j - 1, dp);\\n        Pair x3 = func(arr, i - 1, j - 1, dp);\\n        Pair max = new Pair(Integer.MIN_VALUE, 0);\\n        if(x1.val != Integer.MIN_VALUE) max = new Pair(x1.val, x1.paths); \\n        if(x2.val != Integer.MIN_VALUE){\\n            if(x2.val > max.val) max = new Pair(x2.val, x2.paths);\\n            else if(x2.val == max.val) max = new Pair(max.val, (max.paths + x2.paths) % mod);\\n        }\\n        if(x3.val != Integer.MIN_VALUE){\\n            if(x3.val > max.val) max = new Pair(x3.val, x3.paths);\\n            else if(x3.val == max.val) max = new Pair(max.val, (max.paths + x3.paths) % mod);\\n        } \\n        if(max.val != Integer.MIN_VALUE) max.val += curr;\\n        return dp[i][j] = max;\\n    }\\n    \\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int n = board.size();\\n        Pair[][] dp = new Pair[n][n];\\n        Pair ans = func(board, n - 1, n - 1, dp);\\n        if(ans.val == Integer.MIN_VALUE) return new int[2];\\n        int[] a = new int[2];\\n        a[0] = ans.val;\\n        a[1] = (int)ans.paths;\\n        return a;\\n    }\\n}",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    static int mod = (int)Math.pow(10, 9) + 7;\\n    public static Pair func(List<String> arr, int i, int j, Pair[][] dp){\\n        if(i == 0 && j == 0) return new Pair(0, 1);\\n        if(i < 0 || j < 0 || arr.get(i).charAt(j) == \\'X\\') return new Pair(Integer.MIN_VALUE, 0);\\n        if(dp[i][j] != null) return dp[i][j];\\n        int curr = 0;\\n        if(arr.get(i).charAt(j) != \\'S\\') curr = (arr.get(i).charAt(j)) - \\'0\\';\\n        Pair x1 = func(arr,i - 1, j, dp);\\n        Pair x2 = func(arr, i, j - 1, dp);\\n        Pair x3 = func(arr, i - 1, j - 1, dp);\\n        Pair max = new Pair(Integer.MIN_VALUE, 0);\\n        if(x1.val != Integer.MIN_VALUE) max = new Pair(x1.val, x1.paths); \\n        if(x2.val != Integer.MIN_VALUE){\\n            if(x2.val > max.val) max = new Pair(x2.val, x2.paths);\\n            else if(x2.val == max.val) max = new Pair(max.val, (max.paths + x2.paths) % mod);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 789950,
                "title": "c-dp-intuitive-easy-solution-o-mn",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int mod = 1000000007, n = board.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1)), cnt(n+1,vector<int>(n+1));\\n        board[n-1][n-1] = board[0][0] = \\'0\\';\\n        cnt[n-1][n-1] = 1;\\n        for(int i=n-1;i>=0;--i){\\n            for(int j=n-1;j>=0;--j){\\n                if(board[i][j] != \\'X\\'){\\n                    int m = max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\\n                    dp[i][j] = (board[i][j]-\\'0\\')+m;\\n                    if(dp[i+1][j] == m)\\n                        cnt[i][j] = (cnt[i][j]+cnt[i+1][j]) % mod;\\n                    if(dp[i][j+1] == m)\\n                        cnt[i][j] = (cnt[i][j]+cnt[i][j+1]) % mod;\\n                    if(dp[i+1][j+1] == m)\\n                        cnt[i][j] = (cnt[i][j]+cnt[i+1][j+1]) % mod;\\n                }\\n            }\\n        }\\n        return {cnt[0][0]?dp[0][0]:0,cnt[0][0]};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int mod = 1000000007, n = board.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1)), cnt(n+1,vector<int>(n+1));\\n        board[n-1][n-1] = board[0][0] = \\'0\\';\\n        cnt[n-1][n-1] = 1;\\n        for(int i=n-1;i>=0;--i){\\n            for(int j=n-1;j>=0;--j){\\n                if(board[i][j] != \\'X\\'){\\n                    int m = max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\\n                    dp[i][j] = (board[i][j]-\\'0\\')+m;\\n                    if(dp[i+1][j] == m)\\n                        cnt[i][j] = (cnt[i][j]+cnt[i+1][j]) % mod;\\n                    if(dp[i][j+1] == m)\\n                        cnt[i][j] = (cnt[i][j]+cnt[i][j+1]) % mod;\\n                    if(dp[i+1][j+1] == m)\\n                        cnt[i][j] = (cnt[i][j]+cnt[i+1][j+1]) % mod;\\n                }\\n            }\\n        }\\n        return {cnt[0][0]?dp[0][0]:0,cnt[0][0]};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 469098,
                "title": "java-clean-dp-solution-with-explanation",
                "content": "Based on @huahualeetcode\\'s version \\ndp[i][j] := max score when reach (j, i)\\ncount[i][j] := path to reach (j, i) with max score\\n\\nm = max(dp[i + 1][j], dp[i][j+1], dp[i+1][j+1])\\ndp[i][j] = board[i][j] + m\\ncount[i][j] += count[i+1][j] if dp[i+1][j] == m\\ncount[i][j] += count[i][j+1] if dp[i][j+1] == m\\ncount[i][j] += count[i+1][j+1] if dp[i+1][j+1] == m\\n\\n\\n```\\nclass Solution {\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int MOD = (int)(1e9 + 7);\\n        int m = board.size(), n = board.get(0).length();\\n        int[][] dp = new int[m+1][n+1];\\n        int[][] cc = new int[n+1][n+1];\\n        cc[n-1][n-1] = 1;\\n        for(int i = m-1;i>=0;i--)\\n            for(int j = n-1; j>=0;j--){\\n                char c= board.get(i).charAt(j);\\n                if(c!=\\'X\\'){\\n                    int max = Math.max(Math.max(dp[i+1][j], dp[i][j+1]), dp[i+1][j+1]);\\n                    int num = c-\\'0\\';\\n                    if(c==\\'S\\' || c==\\'E\\') num = 0;\\n                    dp[i][j] = num + max;\\n                    if(dp[i+1][j] == max) cc[i][j] = (cc[i][j] + cc[i+1][j]) % MOD;\\n                    if(dp[i+1][j+1] == max) cc[i][j] = (cc[i][j] + cc[i+1][j+1]) % MOD;\\n                    if(dp[i][j+1] == max) cc[i][j] = (cc[i][j] + cc[i][j+1]) % MOD;\\n                }\\n            }\\n        \\n        return cc[0][0] > 0 ? new int[]{dp[0][0], cc[0][0]} : new int[]{0, 0};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int MOD = (int)(1e9 + 7);\\n        int m = board.size(), n = board.get(0).length();\\n        int[][] dp = new int[m+1][n+1];\\n        int[][] cc = new int[n+1][n+1];\\n        cc[n-1][n-1] = 1;\\n        for(int i = m-1;i>=0;i--)\\n            for(int j = n-1; j>=0;j--){\\n                char c= board.get(i).charAt(j);\\n                if(c!=\\'X\\'){\\n                    int max = Math.max(Math.max(dp[i+1][j], dp[i][j+1]), dp[i+1][j+1]);\\n                    int num = c-\\'0\\';\\n                    if(c==\\'S\\' || c==\\'E\\') num = 0;\\n                    dp[i][j] = num + max;\\n                    if(dp[i+1][j] == max) cc[i][j] = (cc[i][j] + cc[i+1][j]) % MOD;\\n                    if(dp[i+1][j+1] == max) cc[i][j] = (cc[i][j] + cc[i+1][j+1]) % MOD;\\n                    if(dp[i][j+1] == max) cc[i][j] = (cc[i][j] + cc[i][j+1]) % MOD;\\n                }\\n            }\\n        \\n        return cc[0][0] > 0 ? new int[]{dp[0][0], cc[0][0]} : new int[]{0, 0};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2239849,
                "title": "c-super-fast-easysolution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    map<pair<int,int>,pair<int,int>>h;\\n    pair<int,int>solve(vector<string>&board,int i,int j,int n,int m)\\n    {\\n\\t\\t//base case if you reach top left then 1 path hence return 1\\n        if(i==0 && j==0)return {0,1};\\n\\t\\t//return 0 as no path is detected\\n        if(i<0 || j<0 || i>=n || j>=m || board[i][j]==\\'X\\')return {INT_MIN,0};\\n\\t\\t//check if it is stored or not\\n        if(h.find({i,j})!=h.end())return h[{i,j}];\\n        int no=0,cnt=0;\\n        if(board[i][j]!=\\'S\\')no=board[i][j]-\\'0\\';\\n\\t\\t//top ,left ,top left\\n        auto a=solve(board,i-1,j,n,m);\\n        auto b=solve(board,i,j-1,n,m);\\n        auto c=solve(board,i-1,j-1,n,m);\\n\\t\\t//maxi ans\\n        int curr=(max(a.first,max(b.first,c.first)))%mod;\\n\\t\\t//if maxi ans == a , b , c then increament count of a ,b,c\\n        if(curr==a.first)cnt+=a.second;\\n        if(curr==b.first)cnt+=b.second;\\n        if(curr==c.first)cnt+=c.second;\\n        return h[{i,j}]={(curr+no)%mod,cnt%mod};\\n    }\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        auto ans=solve(board,board.size()-1,board[0].size()-1,board.size(),board[0].size());\\n        if(ans.first<0)return {0,0};\\n        return {ans.first%mod,ans.second%mod};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    map<pair<int,int>,pair<int,int>>h;\\n    pair<int,int>solve(vector<string>&board,int i,int j,int n,int m)\\n    {\\n\\t\\t//base case if you reach top left then 1 path hence return 1\\n        if(i==0 && j==0)return {0,1};\\n\\t\\t//return 0 as no path is detected\\n        if(i<0 || j<0 || i>=n || j>=m || board[i][j]==\\'X\\')return {INT_MIN,0};\\n\\t\\t//check if it is stored or not\\n        if(h.find({i,j})!=h.end())return h[{i,j}];\\n        int no=0,cnt=0;\\n        if(board[i][j]!=\\'S\\')no=board[i][j]-\\'0\\';\\n\\t\\t//top ,left ,top left\\n        auto a=solve(board,i-1,j,n,m);\\n        auto b=solve(board,i,j-1,n,m);\\n        auto c=solve(board,i-1,j-1,n,m);\\n\\t\\t//maxi ans\\n        int curr=(max(a.first,max(b.first,c.first)))%mod;\\n\\t\\t//if maxi ans == a , b , c then increament count of a ,b,c\\n        if(curr==a.first)cnt+=a.second;\\n        if(curr==b.first)cnt+=b.second;\\n        if(curr==c.first)cnt+=c.second;\\n        return h[{i,j}]={(curr+no)%mod,cnt%mod};\\n    }\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        auto ans=solve(board,board.size()-1,board[0].size()-1,board.size(),board[0].size());\\n        if(ans.first<0)return {0,0};\\n        return {ans.first%mod,ans.second%mod};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231315,
                "title": "c-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dir[3][2]={{0,-1},{-1,0},{-1,-1}};\\n    int mod=1000000007;\\n    int n;\\n    pair<int,int> dp[101][101];\\n    pair<int,int> max_sum(int i,int j,vector<string>& board)\\n    {\\n        if(i<0 || j<0 || board[i][j]==\\'X\\')\\n            return {INT_MIN,0};\\n        if(i==0 && j==0)\\n            return {0,1};\\n        if(dp[i][j].first!=-1)\\n            return dp[i][j];\\n        int val=board[i][j]==\\'S\\'?0:board[i][j]-\\'0\\';\\n        int res=INT_MIN,count=0;\\n        for(int k=0;k<3;k++)\\n        {\\n            pair<int,int> p=max_sum(i+dir[k][0],j+dir[k][1],board);\\n            if(p.first+val>res)\\n            {\\n                res=p.first+val;\\n                count=p.second;\\n            }\\n            else if(p.first+val==res)\\n                count=(count+p.second)%mod;\\n        }\\n        return dp[i][j]={res,count};\\n    }\\n    vector<int> pathsWithMaxScore(vector<string>& board) \\n    {\\n        n=board.size();\\n        for(int i=0;i<=100;i++)\\n            for(int j=0;j<=100;j++)\\n                dp[i][j]={-1,0};\\n        pair<int,int> p=max_sum(n-1,n-1,board);\\n        int sum=p.first;\\n        int paths=p.second;\\n        if(sum<0)\\n            return {0,0};\\n        return {sum,paths};\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dir[3][2]={{0,-1},{-1,0},{-1,-1}};\\n    int mod=1000000007;\\n    int n;\\n    pair<int,int> dp[101][101];\\n    pair<int,int> max_sum(int i,int j,vector<string>& board)\\n    {\\n        if(i<0 || j<0 || board[i][j]==\\'X\\')\\n            return {INT_MIN,0};\\n        if(i==0 && j==0)\\n            return {0,1};\\n        if(dp[i][j].first!=-1)\\n            return dp[i][j];\\n        int val=board[i][j]==\\'S\\'?0:board[i][j]-\\'0\\';\\n        int res=INT_MIN,count=0;\\n        for(int k=0;k<3;k++)\\n        {\\n            pair<int,int> p=max_sum(i+dir[k][0],j+dir[k][1],board);\\n            if(p.first+val>res)\\n            {\\n                res=p.first+val;\\n                count=p.second;\\n            }\\n            else if(p.first+val==res)\\n                count=(count+p.second)%mod;\\n        }\\n        return dp[i][j]={res,count};\\n    }\\n    vector<int> pathsWithMaxScore(vector<string>& board) \\n    {\\n        n=board.size();\\n        for(int i=0;i<=100;i++)\\n            for(int j=0;j<=100;j++)\\n                dp[i][j]={-1,0};\\n        pair<int,int> p=max_sum(n-1,n-1,board);\\n        int sum=p.first;\\n        int paths=p.second;\\n        if(sum<0)\\n            return {0,0};\\n        return {sum,paths};\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2353111,
                "title": "beats-100-other-s-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp_max[101][101],dp_way[101][101];\\n    int mod=1000000007;\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int n=board.size();\\n        \\n        dp_max[n-1][n-1]=0;\\n        dp_way[n-1][n-1]=1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(board[n-1][i]==\\'X\\') break;\\n            else\\n            {\\n                dp_max[n-1][i]=board[n-1][i]-\\'0\\'+dp_max[n-1][i+1];\\n                dp_way[n-1][i]=1;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(board[i][n-1]==\\'X\\') break;\\n            else\\n            {    \\n               dp_max[i][n-1]=board[i][n-1]-\\'0\\'+dp_max[i+1][n-1];\\n                dp_way[i][n-1]=1;        \\n            }       \\n        }\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=n-2;j>=0;j--)\\n            {\\n                if(board[i][j]==\\'X\\') dp_max[i][j]=0,dp_way[i][j]=0;\\n                \\n                else\\n                {\\n                    int mx=max(dp_max[i][j+1],dp_max[i+1][j]);\\n                    mx=max(mx,dp_max[i+1][j+1]);\\n                    dp_max[i][j]=board[i][j]+mx-\\'0\\';\\n                    dp_way[i][j]=(dp_way[i][j]+((mx==dp_max[i+1][j])?dp_way[i+1][j]:0))%mod;\\n                    dp_way[i][j]=(dp_way[i][j]+((mx==dp_max[i+1][j+1])?dp_way[i+1][j+1]:0))%mod;\\n                    dp_way[i][j]=(dp_way[i][j]+((mx==dp_max[i][j+1])?dp_way[i][j+1]:0))%mod;\\n                }\\n            }\\n        }\\n        // for(int i=0;i<n;i++)\\n        // {\\n        //     for(int j=0;j<n;j++)\\n        //         cout<<dp_way[i][j]<<\" \";\\n        //     cout<<endl;\\n        // }\\n        // return {dp[0].first,dp[0].second};\\n        if(dp_way[0][0]==0) dp_max[0][0]=\\'E\\'-\\'0\\';\\n        return {dp_max[0][0]-\\'E\\'+\\'0\\',dp_way[0][0]};\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp_max[101][101],dp_way[101][101];\\n    int mod=1000000007;\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int n=board.size();\\n        \\n        dp_max[n-1][n-1]=0;\\n        dp_way[n-1][n-1]=1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(board[n-1][i]==\\'X\\') break;\\n            else\\n            {\\n                dp_max[n-1][i]=board[n-1][i]-\\'0\\'+dp_max[n-1][i+1];\\n                dp_way[n-1][i]=1;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(board[i][n-1]==\\'X\\') break;\\n            else\\n            {    \\n               dp_max[i][n-1]=board[i][n-1]-\\'0\\'+dp_max[i+1][n-1];\\n                dp_way[i][n-1]=1;        \\n            }       \\n        }\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=n-2;j>=0;j--)\\n            {\\n                if(board[i][j]==\\'X\\') dp_max[i][j]=0,dp_way[i][j]=0;\\n                \\n                else\\n                {\\n                    int mx=max(dp_max[i][j+1],dp_max[i+1][j]);\\n                    mx=max(mx,dp_max[i+1][j+1]);\\n                    dp_max[i][j]=board[i][j]+mx-\\'0\\';\\n                    dp_way[i][j]=(dp_way[i][j]+((mx==dp_max[i+1][j])?dp_way[i+1][j]:0))%mod;\\n                    dp_way[i][j]=(dp_way[i][j]+((mx==dp_max[i+1][j+1])?dp_way[i+1][j+1]:0))%mod;\\n                    dp_way[i][j]=(dp_way[i][j]+((mx==dp_max[i][j+1])?dp_way[i][j+1]:0))%mod;\\n                }\\n            }\\n        }\\n        // for(int i=0;i<n;i++)\\n        // {\\n        //     for(int j=0;j<n;j++)\\n        //         cout<<dp_way[i][j]<<\" \";\\n        //     cout<<endl;\\n        // }\\n        // return {dp[0].first,dp[0].second};\\n        if(dp_way[0][0]==0) dp_max[0][0]=\\'E\\'-\\'0\\';\\n        return {dp_max[0][0]-\\'E\\'+\\'0\\',dp_way[0][0]};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 692293,
                "title": "java-simple-dp",
                "content": "```\\n    public int[] pathsWithMaxScore(List<String> bd) {\\n        int m = bd.size(), n = bd.get(0).length(), dp[][][] = new int[m][n][2], mod = 1_000_000_007, dir[][] = new int[][]{{0, 1}, {1, 0}, {1, 1}};\\n        char[][] arr = new char[m][n];\\n        for (int i = 0; i < m; i++) arr[i] = bd.get(i).toCharArray();\\n        arr[0][0] = \\'0\\';\\n        dp[m - 1][n - 1] = new int[]{1, 1};\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                if ((i == m - 1 && j == n - 1) || arr[i][j] == \\'X\\') continue;\\n                int add = arr[i][j] - \\'0\\';\\n                for (int[] d : dir) {\\n                    int r = i + d[0], c = j + d[1];\\n                    if (r < m && c < n && dp[r][c][0] > 0) dp[i][j][0] = Math.max(dp[i][j][0], dp[r][c][0] + add);\\n                }\\n                for (int[] d : dir) {\\n                    int r = i + d[0], c = j + d[1];\\n                    if (r < m && c < n && dp[r][c][0] > 0 && dp[i][j][0] == dp[r][c][0] + add) dp[i][j][1] = (dp[i][j][1] + dp[r][c][1]) % mod;\\n                }\\n            }\\n        }\\n        return new int[]{dp[0][0][0] > 0 ? dp[0][0][0] - 1 : 0, dp[0][0][1]};\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] pathsWithMaxScore(List<String> bd) {\\n        int m = bd.size(), n = bd.get(0).length(), dp[][][] = new int[m][n][2], mod = 1_000_000_007, dir[][] = new int[][]{{0, 1}, {1, 0}, {1, 1}};\\n        char[][] arr = new char[m][n];\\n        for (int i = 0; i < m; i++) arr[i] = bd.get(i).toCharArray();\\n        arr[0][0] = \\'0\\';\\n        dp[m - 1][n - 1] = new int[]{1, 1};\\n        for (int i = m - 1; i >= 0; i--) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                if ((i == m - 1 && j == n - 1) || arr[i][j] == \\'X\\') continue;\\n                int add = arr[i][j] - \\'0\\';\\n                for (int[] d : dir) {\\n                    int r = i + d[0], c = j + d[1];\\n                    if (r < m && c < n && dp[r][c][0] > 0) dp[i][j][0] = Math.max(dp[i][j][0], dp[r][c][0] + add);\\n                }\\n                for (int[] d : dir) {\\n                    int r = i + d[0], c = j + d[1];\\n                    if (r < m && c < n && dp[r][c][0] > 0 && dp[i][j][0] == dp[r][c][0] + add) dp[i][j][1] = (dp[i][j][1] + dp[r][c][1]) % mod;\\n                }\\n            }\\n        }\\n        return new int[]{dp[0][0][0] > 0 ? dp[0][0][0] - 1 : 0, dp[0][0][1]};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 509678,
                "title": "java-dfs-memoization-just-use-the-concept-of-tree-structure-array-dp",
                "content": "```Java\\n    class Data {\\n\\n      int sum;\\n      int count;\\n\\n      Data(int sum, int count) {\\n        this.sum = sum;\\n        this.count = count;\\n      }\\n    }\\n\\n    private char[][] mat;\\n    private int m;\\n    private int n;\\n    private final double mod = Math.pow(10, 9) + 7;\\n    private int[][] dx = {{0, -1}, {-1, 0}, {-1, -1}};\\n    private Map<String, Data> cache = new HashMap<>();\\n\\n    public int[] pathsWithMaxScore(List<String> board) {\\n      m = board.size();\\n      n = board.get(0).length();\\n      mat = new char[m][n];\\n      for (int i = 0; i < m; i++) {\\n        String s = board.get(i);\\n        for (int j = 0; j < n; j++) {\\n          mat[i][j] = s.charAt(j);\\n        }\\n      }\\n\\n      Data data = f(m - 1, n - 1);\\n      return data.sum < 0 ? new int[]{0, 0}\\n          : new int[]{data.sum, data.count};\\n    }\\n\\n    private Data f(int i, int j) {\\n\\n      if (mat[i][j] == \\'X\\') {\\n        return new Data(Integer.MIN_VALUE, 0);\\n      }\\n      if (i == 0 && j == 0) {\\n        return new Data(0, 1);\\n      }\\n      String key = i + \"~\" + j;\\n      if (cache.containsKey(key)) {\\n        return cache.get(key);\\n      }\\n      int cv = Character.isDigit(mat[i][j]) ? (mat[i][j] - \\'0\\') : 0;\\n      double res = Integer.MIN_VALUE;\\n      double count = 0;\\n      for (int[] d : dx) {\\n        int x = i + d[0];\\n        int y = j + d[1];\\n        if (x >= 0 && y >= 0 && x < m && y < n && mat[x][y] != \\'X\\') {\\n          Data next = f(x, y);\\n          if (next.sum == Integer.MIN_VALUE || next.count == 0) {\\n            continue;\\n          }\\n          if (res < cv + next.sum) {\\n            res = cv + next.sum;\\n            count = next.count;\\n          } else if (res == cv + next.sum) {\\n            count += next.count;\\n          }\\n        }\\n      }\\n      cache.put(key, new Data((int) (res % mod), (int) (count % mod)));\\n      return cache.get(key);\\n    }\\n\\n  }\\n```",
                "solutionTags": [],
                "code": "```Java\\n    class Data {\\n\\n      int sum;\\n      int count;\\n\\n      Data(int sum, int count) {\\n        this.sum = sum;\\n        this.count = count;\\n      }\\n    }\\n\\n    private char[][] mat;\\n    private int m;\\n    private int n;\\n    private final double mod = Math.pow(10, 9) + 7;\\n    private int[][] dx = {{0, -1}, {-1, 0}, {-1, -1}};\\n    private Map<String, Data> cache = new HashMap<>();\\n\\n    public int[] pathsWithMaxScore(List<String> board) {\\n      m = board.size();\\n      n = board.get(0).length();\\n      mat = new char[m][n];\\n      for (int i = 0; i < m; i++) {\\n        String s = board.get(i);\\n        for (int j = 0; j < n; j++) {\\n          mat[i][j] = s.charAt(j);\\n        }\\n      }\\n\\n      Data data = f(m - 1, n - 1);\\n      return data.sum < 0 ? new int[]{0, 0}\\n          : new int[]{data.sum, data.count};\\n    }\\n\\n    private Data f(int i, int j) {\\n\\n      if (mat[i][j] == \\'X\\') {\\n        return new Data(Integer.MIN_VALUE, 0);\\n      }\\n      if (i == 0 && j == 0) {\\n        return new Data(0, 1);\\n      }\\n      String key = i + \"~\" + j;\\n      if (cache.containsKey(key)) {\\n        return cache.get(key);\\n      }\\n      int cv = Character.isDigit(mat[i][j]) ? (mat[i][j] - \\'0\\') : 0;\\n      double res = Integer.MIN_VALUE;\\n      double count = 0;\\n      for (int[] d : dx) {\\n        int x = i + d[0];\\n        int y = j + d[1];\\n        if (x >= 0 && y >= 0 && x < m && y < n && mat[x][y] != \\'X\\') {\\n          Data next = f(x, y);\\n          if (next.sum == Integer.MIN_VALUE || next.count == 0) {\\n            continue;\\n          }\\n          if (res < cv + next.sum) {\\n            res = cv + next.sum;\\n            count = next.count;\\n          } else if (res == cv + next.sum) {\\n            count += next.count;\\n          }\\n        }\\n      }\\n      cache.put(key, new Data((int) (res % mod), (int) (count % mod)));\\n      return cache.get(key);\\n    }\\n\\n  }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 464709,
                "title": "java-3d-array",
                "content": "```\\n    private int mod = (int)(Math.pow(10,9))+7;\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int[][][] result = new int[101][101][2];\\n        result[0][0][0] = 0; // Maximum Sum\\n        result[0][0][1] = 1; // Maximum Path count.\\n        for (int j=1;j<board.get(0).length();j++) { // First Column\\n            char c = board.get(0).charAt(j);\\n            if(c!=\\'X\\') {\\n                result[0][j][0]=((c-\\'0\\')%mod+result[0][j-1][0]%mod)%mod;\\n                result[0][j][1]=1;\\n            } else {\\n                break;\\n            }\\n        }\\n        for (int i=1;i<board.size();i++) { // First Row\\n            char c = board.get(i).charAt(0);\\n            if(c!=\\'X\\') {\\n                result[i][0][0]=((c-\\'0\\')%mod+result[i-1][0][0]%mod)%mod;\\n                result[i][0][1]=1;\\n            } else {\\n                break;\\n            }\\n        }\\n        for (int i=1;i<board.size();i++) {\\n            for (int j=1;j<board.get(0).length();j++) {\\n                char c = board.get(i).charAt(j);\\n                int sum=0;\\n                int[] maxTillNow = util(result,i,j);\\n                if((maxTillNow[0]==0 && maxTillNow[1]==0) || c==\\'X\\') {\\n                    continue;\\n                }\\n                sum = maxTillNow[0];\\n                if(c>=\\'0\\' && c<=\\'9\\') {\\n                    sum += (c-\\'0\\');\\n                }\\n                result[i][j][0] = sum;\\n                result[i][j][1] = maxTillNow[1]%mod;\\n            }\\n        }\\n        return new int[]{result[board.size()-1][board.get(0).length()-1][0],result[board.size()-1][board.get(0).length()-1][1]};\\n    }\\n\\n    private int[] util(int[][][] result,int i,int j) {\\n        int sum =  Math.max(result[i-1][j-1][0],Math.max(result[i-1][j][0],result[i][j-1][0]));\\n        int path=0;\\n        if(result[i-1][j][0]==sum) {\\n            path = (path%mod+result[i-1][j][1]%mod)%mod;\\n        }\\n        if(result[i][j-1][0]==sum) {\\n            path = (path%mod+result[i][j-1][1]%mod)%mod;\\n        }\\n        if(result[i-1][j-1][0]==sum) {\\n            path = (path%mod+result[i-1][j-1][1]%mod)%mod;\\n        }\\n        return new int[]{sum,path};\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private int mod = (int)(Math.pow(10,9))+7;\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int[][][] result = new int[101][101][2];\\n        result[0][0][0] = 0; // Maximum Sum\\n        result[0][0][1] = 1; // Maximum Path count.\\n        for (int j=1;j<board.get(0).length();j++) { // First Column\\n            char c = board.get(0).charAt(j);\\n            if(c!=\\'X\\') {\\n                result[0][j][0]=((c-\\'0\\')%mod+result[0][j-1][0]%mod)%mod;\\n                result[0][j][1]=1;\\n            } else {\\n                break;\\n            }\\n        }\\n        for (int i=1;i<board.size();i++) { // First Row\\n            char c = board.get(i).charAt(0);\\n            if(c!=\\'X\\') {\\n                result[i][0][0]=((c-\\'0\\')%mod+result[i-1][0][0]%mod)%mod;\\n                result[i][0][1]=1;\\n            } else {\\n                break;\\n            }\\n        }\\n        for (int i=1;i<board.size();i++) {\\n            for (int j=1;j<board.get(0).length();j++) {\\n                char c = board.get(i).charAt(j);\\n                int sum=0;\\n                int[] maxTillNow = util(result,i,j);\\n                if((maxTillNow[0]==0 && maxTillNow[1]==0) || c==\\'X\\') {\\n                    continue;\\n                }\\n                sum = maxTillNow[0];\\n                if(c>=\\'0\\' && c<=\\'9\\') {\\n                    sum += (c-\\'0\\');\\n                }\\n                result[i][j][0] = sum;\\n                result[i][j][1] = maxTillNow[1]%mod;\\n            }\\n        }\\n        return new int[]{result[board.size()-1][board.get(0).length()-1][0],result[board.size()-1][board.get(0).length()-1][1]};\\n    }\\n\\n    private int[] util(int[][][] result,int i,int j) {\\n        int sum =  Math.max(result[i-1][j-1][0],Math.max(result[i-1][j][0],result[i][j-1][0]));\\n        int path=0;\\n        if(result[i-1][j][0]==sum) {\\n            path = (path%mod+result[i-1][j][1]%mod)%mod;\\n        }\\n        if(result[i][j-1][0]==sum) {\\n            path = (path%mod+result[i][j-1][1]%mod)%mod;\\n        }\\n        if(result[i-1][j-1][0]==sum) {\\n            path = (path%mod+result[i-1][j-1][1]%mod)%mod;\\n        }\\n        return new int[]{sum,path};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1744123,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<int> pathsWithMaxScore(vector<string>&mat) \\n    {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        vector<vector<int>>path(n,vector<int>(m,0));\\n        path[n-1][m-1]=1;\\n        dp[n-1][m-1]=0;\\n        vector<pair<int,int>>dir={{-1,0},{0,-1},{-1,-1}};\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                \\n                for(auto it:dir)\\n                {\\n                    int nx=i+it.first;\\n                    int ny=j+it.second;\\n                    int val=dp[i][j];\\n                    if(nx>=0&&nx<n&&ny>=0&&ny<m&&mat[nx][ny]!=\\'X\\')\\n                    {\\n                        val+=(mat[nx][ny]!=\\'E\\')?mat[nx][ny]-\\'0\\':0;\\n                        if(val>dp[nx][ny])\\n                        {\\n                            dp[nx][ny]=val;\\n                            path[nx][ny]=path[i][j];\\n                        }\\n                        else if(val==dp[nx][ny])\\n                        {\\n                            path[nx][ny]=(path[nx][ny]+path[i][j])%mod;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return {path[0][0]==0?0:dp[0][0],path[0][0]};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<int> pathsWithMaxScore(vector<string>&mat) \\n    {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        vector<vector<int>>path(n,vector<int>(m,0));\\n        path[n-1][m-1]=1;\\n        dp[n-1][m-1]=0;\\n        vector<pair<int,int>>dir={{-1,0},{0,-1},{-1,-1}};\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                \\n                for(auto it:dir)\\n                {\\n                    int nx=i+it.first;\\n                    int ny=j+it.second;\\n                    int val=dp[i][j];\\n                    if(nx>=0&&nx<n&&ny>=0&&ny<m&&mat[nx][ny]!=\\'X\\')\\n                    {\\n                        val+=(mat[nx][ny]!=\\'E\\')?mat[nx][ny]-\\'0\\':0;\\n                        if(val>dp[nx][ny])\\n                        {\\n                            dp[nx][ny]=val;\\n                            path[nx][ny]=path[i][j];\\n                        }\\n                        else if(val==dp[nx][ny])\\n                        {\\n                            path[nx][ny]=(path[nx][ny]+path[i][j])%mod;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return {path[0][0]==0?0:dp[0][0],path[0][0]};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135213,
                "title": "c-recursion-bottomup-with-explanation",
                "content": "```\\n    /*\\n     * Solution is to find the max sum of numeric characters that can be collected and no of\\n     * such paths that yield to max sum when we move from bottom right(\"S\") to top left(\"E\").\\n     *\\n     * There are 3 ways to move from a point either left, upl, up-left. If there is an\\n     * obstacle (\\'X) at any square, then there is no way to move in that path.\\n     *\\n     * For Eg: [E, 2].[2, S]\\n     * We move from 1, 1 we have 3 ways to go \\n     *\\n     *                  (1,1)\\n     *                   2|\\n     *           ----------------------\\n     *         2 |      0 |         2 |\\n     *       0+(0,1)    0+(0,0)     0+(1,0)\\n     *          2 |        |            2|\\n     *         2+(0,0)     0          2+(0,0)\\n     *             |                     |\\n     *             0                     0\\n     *\\n     * From above it is seen that there are 2 paths with the max same sum 2. So, the result will\\n     * be [2,2]\\n     * If we reached the first column, then there will be only one way to traverse ie., up\\n     * If we reached the first row, then there will be only way traverse is left\\n     * If we reached the destination, then return 0\\n     * If there is any obstacle, then there is no way to traverse return 0\\n    */\\n    int pathsWithMaxScore(vector<string>& board, int row, int col, int& numMaxPaths) {\\n        if (row == 0 && col == 0) {\\n            // Reached the starting point\\n            // Increment the maxpath\\n            numMaxPaths += 1;\\n            return 0;\\n        }\\n        \\n        if (board[row][col] == \\'X\\') {\\n            // There is an obstacles in the current square, no need to proceed further\\n            return 0;\\n        }\\n        \\n        int current = (board[row][col] == \\'S\\' ? 0 : board[row][col] - \\'0\\');        \\n        if (row == 0) {\\n            // reached the first row, we can traverse only on left\\n            return current + pathsWithMaxScore(board, row, col - 1, numMaxPaths);\\n        }\\n        \\n        if (col == 0) {\\n            // reached the first col, we can traverse only upwards\\n            return current + pathsWithMaxScore(board, row - 1, col, numMaxPaths);\\n        }\\n\\n        // Move in upward direction\\n        int uppath = 0;\\n        int up = pathsWithMaxScore(board, row - 1, col, uppath);\\n\\n        // Move in left direction\\n        int leftpath = 0;\\n        int left = pathsWithMaxScore(board, row, col - 1, leftpath);\\n\\n        // Move in diagnol\\n        int diagpath = 0;\\n        int diag = pathsWithMaxScore(board, row - 1, col - 1, diagpath);\\n\\n        // Calculate the maximum sum\\n        int res = max(max(up, left), diag);\\n\\n        // Check and add the noOfMaxPaths\\n        numMaxPaths +=  res == up ? uppath : 0;\\n        numMaxPaths += res == left ? leftpath : 0;\\n        numMaxPaths += res == diag ? diagpath : 0;\\n\\n        return current + res;\\n    }\\n\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int numMaxPaths = 0;\\n\\n        int maxSum = pathsWithMaxScore(board, board.size()-1, board[0].size()-1, numMaxPaths);\\n\\n        // Check to see if we reached the starting point. If not then discard the sum as there\\n        // is an obstacle in between\\n        maxSum = numMaxPaths == 0 ? 0 : maxSum;\\n        return vector<int>{maxSum, numMaxPaths};\\n    }\\n\\t\\n\\t    /*\\n     * PathWithMaxScore BottomUp solution\\n     * Since there are many overlapping subproblems in Recursive solution, and the Solution for the\\n     * main problem can ba attained if we have solutions of suproblems, Dynamic Programming can be\\n     * applied.\\n     *\\n     * Dynamic Programming Bottom up solution, conditions are similar to recursive but the intemediate\\n     * results are stored in a dp table. Bottom up is to find bottom solutions first to yield the top\\n     * solution i.e.., solution of the problem\\n     *\\n     * dp table will be of length [row+1][col+1], +1 is to store when the strings are empty\\n     * dp[row][col] holds the current sum that is needed to traverse till row and col\\n     *\\n     * As there are only 3 ways to traverse, left, up, upleft, as we are traversing from bottom, the\\n     * dp consider will be right, bottom, right-bottom\\n     *\\n     *    dp[row][col] = board[row][col] + max(dp[row][col+1], dp[row+1][col], dp[row+1][col+1])\\n     *                                when board[row][col] != \\'X\\'\\n     *\\n     * In order to calculate num of paths with max amount, at each point in the square, Calculate the\\n     * max value and increment the value\\n     */\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int n = board[0].size();\\n\\n        int mod = 1e9 + 7;\\n\\n        // Create dp array length+1 to stoere the empty string\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\\n        vector<vector<int>> count(n + 1, vector<int>(n + 1, 0));\\n\\n        // Fill the end and start of the board with 0\\n        board[0][0] = board[n - 1][n - 1] = \\'0\\';\\n\\n        // Fill the count of end to 1\\n        count[n - 1][n - 1] = 1;\\n\\n        // Start filling the dp array\\n        for (int row = n - 1; row >= 0; row--) {\\n            for (int col = n - 1; col >= 0; col--) {\\n                if (board[row][col] != \\'X\\') {\\n                    // Current square is not obstacle, need to calculate the max sum\\n                    int mx = max(dp[row][col + 1], max(dp[row + 1][col], dp[row + 1][col + 1]));\\n\\n                    dp[row][col] = board[row][col] - \\'0\\' + mx;\\n\\n                    if (dp[row][col + 1] == mx) {\\n                        count[row][col] = (count[row][col] + count[row][col + 1]) % mod;\\n                    }\\n                    if (dp[row + 1][col] == mx) {\\n                        count[row][col] = (count[row][col] + count[row + 1][col]) % mod;\\n                    }\\n                    if (dp[row + 1][col + 1] == mx) {\\n                        count[row][col] = (count[row][col] + count[row + 1][col + 1]) % mod;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return vector<int>{count[0][0] == 0 ? 0 : dp[0][0], count[0][0]};\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    /*\\n     * Solution is to find the max sum of numeric characters that can be collected and no of\\n     * such paths that yield to max sum when we move from bottom right(\"S\") to top left(\"E\").\\n     *\\n     * There are 3 ways to move from a point either left, upl, up-left. If there is an\\n     * obstacle (\\'X) at any square, then there is no way to move in that path.\\n     *\\n     * For Eg: [E, 2].[2, S]\\n     * We move from 1, 1 we have 3 ways to go \\n     *\\n     *                  (1,1)\\n     *                   2|\\n     *           ----------------------\\n     *         2 |      0 |         2 |\\n     *       0+(0,1)    0+(0,0)     0+(1,0)\\n     *          2 |        |            2|\\n     *         2+(0,0)     0          2+(0,0)\\n     *             |                     |\\n     *             0                     0\\n     *\\n     * From above it is seen that there are 2 paths with the max same sum 2. So, the result will\\n     * be [2,2]\\n     * If we reached the first column, then there will be only one way to traverse ie., up\\n     * If we reached the first row, then there will be only way traverse is left\\n     * If we reached the destination, then return 0\\n     * If there is any obstacle, then there is no way to traverse return 0\\n    */\\n    int pathsWithMaxScore(vector<string>& board, int row, int col, int& numMaxPaths) {\\n        if (row == 0 && col == 0) {\\n            // Reached the starting point\\n            // Increment the maxpath\\n            numMaxPaths += 1;\\n            return 0;\\n        }\\n        \\n        if (board[row][col] == \\'X\\') {\\n            // There is an obstacles in the current square, no need to proceed further\\n            return 0;\\n        }\\n        \\n        int current = (board[row][col] == \\'S\\' ? 0 : board[row][col] - \\'0\\');        \\n        if (row == 0) {\\n            // reached the first row, we can traverse only on left\\n            return current + pathsWithMaxScore(board, row, col - 1, numMaxPaths);\\n        }\\n        \\n        if (col == 0) {\\n            // reached the first col, we can traverse only upwards\\n            return current + pathsWithMaxScore(board, row - 1, col, numMaxPaths);\\n        }\\n\\n        // Move in upward direction\\n        int uppath = 0;\\n        int up = pathsWithMaxScore(board, row - 1, col, uppath);\\n\\n        // Move in left direction\\n        int leftpath = 0;\\n        int left = pathsWithMaxScore(board, row, col - 1, leftpath);\\n\\n        // Move in diagnol\\n        int diagpath = 0;\\n        int diag = pathsWithMaxScore(board, row - 1, col - 1, diagpath);\\n\\n        // Calculate the maximum sum\\n        int res = max(max(up, left), diag);\\n\\n        // Check and add the noOfMaxPaths\\n        numMaxPaths +=  res == up ? uppath : 0;\\n        numMaxPaths += res == left ? leftpath : 0;\\n        numMaxPaths += res == diag ? diagpath : 0;\\n\\n        return current + res;\\n    }\\n\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int numMaxPaths = 0;\\n\\n        int maxSum = pathsWithMaxScore(board, board.size()-1, board[0].size()-1, numMaxPaths);\\n\\n        // Check to see if we reached the starting point. If not then discard the sum as there\\n        // is an obstacle in between\\n        maxSum = numMaxPaths == 0 ? 0 : maxSum;\\n        return vector<int>{maxSum, numMaxPaths};\\n    }\\n\\t\\n\\t    /*\\n     * PathWithMaxScore BottomUp solution\\n     * Since there are many overlapping subproblems in Recursive solution, and the Solution for the\\n     * main problem can ba attained if we have solutions of suproblems, Dynamic Programming can be\\n     * applied.\\n     *\\n     * Dynamic Programming Bottom up solution, conditions are similar to recursive but the intemediate\\n     * results are stored in a dp table. Bottom up is to find bottom solutions first to yield the top\\n     * solution i.e.., solution of the problem\\n     *\\n     * dp table will be of length [row+1][col+1], +1 is to store when the strings are empty\\n     * dp[row][col] holds the current sum that is needed to traverse till row and col\\n     *\\n     * As there are only 3 ways to traverse, left, up, upleft, as we are traversing from bottom, the\\n     * dp consider will be right, bottom, right-bottom\\n     *\\n     *    dp[row][col] = board[row][col] + max(dp[row][col+1], dp[row+1][col], dp[row+1][col+1])\\n     *                                when board[row][col] != \\'X\\'\\n     *\\n     * In order to calculate num of paths with max amount, at each point in the square, Calculate the\\n     * max value and increment the value\\n     */\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int n = board[0].size();\\n\\n        int mod = 1e9 + 7;\\n\\n        // Create dp array length+1 to stoere the empty string\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\\n        vector<vector<int>> count(n + 1, vector<int>(n + 1, 0));\\n\\n        // Fill the end and start of the board with 0\\n        board[0][0] = board[n - 1][n - 1] = \\'0\\';\\n\\n        // Fill the count of end to 1\\n        count[n - 1][n - 1] = 1;\\n\\n        // Start filling the dp array\\n        for (int row = n - 1; row >= 0; row--) {\\n            for (int col = n - 1; col >= 0; col--) {\\n                if (board[row][col] != \\'X\\') {\\n                    // Current square is not obstacle, need to calculate the max sum\\n                    int mx = max(dp[row][col + 1], max(dp[row + 1][col], dp[row + 1][col + 1]));\\n\\n                    dp[row][col] = board[row][col] - \\'0\\' + mx;\\n\\n                    if (dp[row][col + 1] == mx) {\\n                        count[row][col] = (count[row][col] + count[row][col + 1]) % mod;\\n                    }\\n                    if (dp[row + 1][col] == mx) {\\n                        count[row][col] = (count[row][col] + count[row + 1][col]) % mod;\\n                    }\\n                    if (dp[row + 1][col + 1] == mx) {\\n                        count[row][col] = (count[row][col] + count[row + 1][col + 1]) % mod;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return vector<int>{count[0][0] == 0 ? 0 : dp[0][0], count[0][0]};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 579155,
                "title": "python-memoization",
                "content": "```\\ndef pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        n,coord=len(board)-1,[(0,-1),(-1,0),(-1,-1)]\\n        \\n        @lru_cache(None)\\n        def get_max(i,j):\\n            if i<0 or j<0: return -float(\\'inf\\')\\n            if board[i][j]==\\'X\\': return -float(\\'inf\\')\\n            if board[i][j]==\\'E\\': return 0\\n            if board[i][j]==\\'S\\': return max(get_max(i+x,j+y) for x,y in coord)\\n            return max(get_max(i+x,j+y) for x,y in coord)+int(board[i][j])\\n        \\n        total=(get_max(n,n))\\n        \\n        if total<0: return (0,0)\\n        \\n        @lru_cache(None)\\n        def get_path(total,i,j):\\n            if i<0 or j<0: return 0\\n            if board[i][j]==\\'X\\': return 0\\n            if board[i][j]==\\'E\\': return 1 if total==0 else 0\\n            if board[i][j]==\\'S\\': return sum(get_path(total,i+x,j+y) for x,y in coord)\\n            if total==get_max(i,j): return sum(get_path(total-int(board[i][j]),i+x,j+y)  for x,y in coord)\\n            return 0\\n        \\n        paths=get_path(total,n,n)%(10**9+7)\\n        \\n        return [total,paths]\\n```",
                "solutionTags": [],
                "code": "```\\ndef pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        n,coord=len(board)-1,[(0,-1),(-1,0),(-1,-1)]\\n        \\n        @lru_cache(None)\\n        def get_max(i,j):\\n            if i<0 or j<0: return -float(\\'inf\\')\\n            if board[i][j]==\\'X\\': return -float(\\'inf\\')\\n            if board[i][j]==\\'E\\': return 0\\n            if board[i][j]==\\'S\\': return max(get_max(i+x,j+y) for x,y in coord)\\n            return max(get_max(i+x,j+y) for x,y in coord)+int(board[i][j])\\n        \\n        total=(get_max(n,n))\\n        \\n        if total<0: return (0,0)\\n        \\n        @lru_cache(None)\\n        def get_path(total,i,j):\\n            if i<0 or j<0: return 0\\n            if board[i][j]==\\'X\\': return 0\\n            if board[i][j]==\\'E\\': return 1 if total==0 else 0\\n            if board[i][j]==\\'S\\': return sum(get_path(total,i+x,j+y) for x,y in coord)\\n            if total==get_max(i,j): return sum(get_path(total-int(board[i][j]),i+x,j+y)  for x,y in coord)\\n            return 0\\n        \\n        paths=get_path(total,n,n)%(10**9+7)\\n        \\n        return [total,paths]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 463342,
                "title": "c-dp-solution-simple-and-clean-code-o-n-m-time-and-space",
                "content": "In this problem we need path with maximum cost, as well as number of such paths.\\nSo I store, the maximum cost in `dp[i][j][0]` and number of such paths in `dp[i][j][1]`.\\n\\nWhenever, we reach an obstacle, I put `dp[i][j][0]` as `INT_MIN` to denote, no path from this cell.\\n\\nRest the max cost is `dp[i][j][0] = max( dp[i + 1][j][0], dp[i][j + 1][0], dp[i + 1][j + 1][0] )  + cellvalue` and the number of paths is sum of paths of all neighbors with same max cost.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int mod = 1000000007;\\n        int n = board.size();\\n        vector<int> v;\\n        if(n == 0)\\n            return v;\\n        int m = board[0].size();\\n        vector<vector< vector<int> >> dp(n, vector<vector<int>>(m, vector<int>(2)));\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            for(int j = m - 1; j >= 0; j--)\\n            {\\n                if(i == n - 1 && j == m - 1)\\n                    dp[i][j] = {0, 1};\\n                else if(board[i][j] == \\'X\\')\\n                    dp[i][j] = {INT_MIN, 0};\\n                else\\n                {\\n                    long val = INT_MIN, count = 0;\\n                    if(j + 1 < m && dp[i][j + 1][0] != INT_MIN)\\n                    {\\n                        val = dp[i][j + 1][0];\\n                        count = dp[i][j + 1][1];\\n                    }\\n                    \\n                    if(i + 1 < n && dp[i + 1][j][0] != INT_MIN && val <= dp[i + 1][j][0])\\n                    {\\n                        if(val < dp[i + 1][j][0])\\n                        {\\n                            val = dp[i + 1][j][0];\\n                            count = dp[i + 1][j][1];\\n                        }\\n                        else\\n                        {\\n                            count = (count + dp[i + 1][j][1]) % mod;\\n                        }\\n                    }\\n                    \\n                    if(i + 1 < n && j + 1 < m && dp[i + 1][j + 1][0] != INT_MIN && val <= dp[i + 1][j + 1][0])\\n                    {\\n                        if(val < dp[i + 1][j + 1][0])\\n                        {\\n                            val = dp[i + 1][j + 1][0];\\n                            count = dp[i + 1][j + 1][1];\\n                        }\\n                        else\\n                            count = (count + dp[i + 1][j + 1][1]) % mod;   \\n                    }\\n                    \\n                    if(val == INT_MIN)\\n                        dp[i][j] = {INT_MIN, 0};\\n                    else if(i == 0 && j == 0)\\n                        dp[i][j] = {val, count % mod};\\n                    else\\n                        dp[i][j] = {val + (board[i][j] - \\'0\\'), count % mod};\\n                }\\n            }\\n        }\\n        \\n        if(dp[0][0][0] == INT_MIN)\\n        {\\n            v.push_back(0);\\n            v.push_back(0);\\n            return v;\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int mod = 1000000007;\\n        int n = board.size();\\n        vector<int> v;\\n        if(n == 0)\\n            return v;\\n        int m = board[0].size();\\n        vector<vector< vector<int> >> dp(n, vector<vector<int>>(m, vector<int>(2)));\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            for(int j = m - 1; j >= 0; j--)\\n            {\\n                if(i == n - 1 && j == m - 1)\\n                    dp[i][j] = {0, 1};\\n                else if(board[i][j] == \\'X\\')\\n                    dp[i][j] = {INT_MIN, 0};\\n                else\\n                {\\n                    long val = INT_MIN, count = 0;\\n                    if(j + 1 < m && dp[i][j + 1][0] != INT_MIN)\\n                    {\\n                        val = dp[i][j + 1][0];\\n                        count = dp[i][j + 1][1];\\n                    }\\n                    \\n                    if(i + 1 < n && dp[i + 1][j][0] != INT_MIN && val <= dp[i + 1][j][0])\\n                    {\\n                        if(val < dp[i + 1][j][0])\\n                        {\\n                            val = dp[i + 1][j][0];\\n                            count = dp[i + 1][j][1];\\n                        }\\n                        else\\n                        {\\n                            count = (count + dp[i + 1][j][1]) % mod;\\n                        }\\n                    }\\n                    \\n                    if(i + 1 < n && j + 1 < m && dp[i + 1][j + 1][0] != INT_MIN && val <= dp[i + 1][j + 1][0])\\n                    {\\n                        if(val < dp[i + 1][j + 1][0])\\n                        {\\n                            val = dp[i + 1][j + 1][0];\\n                            count = dp[i + 1][j + 1][1];\\n                        }\\n                        else\\n                            count = (count + dp[i + 1][j + 1][1]) % mod;   \\n                    }\\n                    \\n                    if(val == INT_MIN)\\n                        dp[i][j] = {INT_MIN, 0};\\n                    else if(i == 0 && j == 0)\\n                        dp[i][j] = {val, count % mod};\\n                    else\\n                        dp[i][j] = {val + (board[i][j] - \\'0\\'), count % mod};\\n                }\\n            }\\n        }\\n        \\n        if(dp[0][0][0] == INT_MIN)\\n        {\\n            v.push_back(0);\\n            v.push_back(0);\\n            return v;\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281924,
                "title": "simple-java-memoization-solution-o-m-n-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsimilar to other standard DP on Grid problems (min cost path)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmaintain two 2D DP array of size M*N one for keeping the max score and another for keeping the multiple paths for getting the max score.\\n\\nfirst try out the question for finding only the max score. \\n after that now think about maintaining the path dp.\\n\\ndry run for [[E12],[121],[21S]]  maintaining the paths DP as well as score DP, if more than one of the left , up , diagonal path has the same max then add those paths . \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(M*N)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(M*N)$$\\n\\n# Code\\n```\\nclass Solution {\\n    // TC : O(M*N) SC: O(M*N)\\n    int M=(int)1e9+7;\\n    public int solve (List<String> board , int i, int j,int[][] sdp,int[][] pdp){\\n     if(i==0 && j==0 ){\\n         pdp[i][j]=1; //base case \\n         return sdp[i][j]= 0; \\n     }\\n    if(sdp[i][j]!= -1){\\n        return sdp[i][j];\\n    }\\n    int val=0;\\n    if(board.get(i).charAt(j)!=\\'S\\') val= board.get(i).charAt(j) - \\'0\\';\\n    int ans=0, l=-(int)1e9, u=-(int)1e9, d=-(int)1e9;\\n\\n     if(i-1 >=0 && board.get(i-1).charAt(j)!= \\'X\\'){\\n         u = solve(board,i-1,j,sdp,pdp);\\n     }\\n     if(i-1 >=0 && j-1>=0  && board.get(i-1).charAt(j-1)!= \\'X\\'){\\n         d = solve(board,i-1,j-1,sdp,pdp);\\n     }\\n     if(j-1 >=0 && board.get(i).charAt(j-1)!= \\'X\\'){\\n         l = solve(board,i,j-1,sdp,pdp);\\n     }\\n\\n    \\n     ans=Math.max(l,Math.max(u,d));\\n\\n     // blocked path no ans possible\\n     if(ans == -(int)1e9){\\n         val=0; ans=0;\\n         \\n         if(board.get(i).charAt(j)==\\'S\\')return sdp[i][j]=0;\\n\\n         return sdp[i][j]=-(int)1e9;\\n     }\\n     \\n     // after finding max score checking for the path (u,l,d) with same max \\n     \\n     if(l==ans){ pdp[i][j]=(pdp[i][j]+pdp[i][j-1])%M; }\\n     if(u==ans){ pdp[i][j]=(pdp[i][j]+pdp[i-1][j])%M; }\\n     if(d==ans){ pdp[i][j]=(pdp[i][j]+pdp[i-1][j-1])%M; }\\n     \\n    return sdp[i][j]= ( ans + val ) % M;\\n    }\\n    \\n    public int[] pathsWithMaxScore(List<String> board) {\\n    int[] ans =new int[2];\\n    int r=board.size() , c= board.get(0).length();\\n    int[][] sdp=new int[r][c]; // for storing max score\\n     int[][] pdp=new int[r][c];  // for storing path\\n    for(int[] d:sdp)Arrays.fill(d,-1);\\n    solve(board,r-1,c-1,sdp,pdp);\\n\\n    ans[0]=sdp[r-1][c-1]; \\n    ans[1]=pdp[r-1][c-1];\\n\\n    return ans;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    // TC : O(M*N) SC: O(M*N)\\n    int M=(int)1e9+7;\\n    public int solve (List<String> board , int i, int j,int[][] sdp,int[][] pdp){\\n     if(i==0 && j==0 ){\\n         pdp[i][j]=1; //base case \\n         return sdp[i][j]= 0; \\n     }\\n    if(sdp[i][j]!= -1){\\n        return sdp[i][j];\\n    }\\n    int val=0;\\n    if(board.get(i).charAt(j)!=\\'S\\') val= board.get(i).charAt(j) - \\'0\\';\\n    int ans=0, l=-(int)1e9, u=-(int)1e9, d=-(int)1e9;\\n\\n     if(i-1 >=0 && board.get(i-1).charAt(j)!= \\'X\\'){\\n         u = solve(board,i-1,j,sdp,pdp);\\n     }\\n     if(i-1 >=0 && j-1>=0  && board.get(i-1).charAt(j-1)!= \\'X\\'){\\n         d = solve(board,i-1,j-1,sdp,pdp);\\n     }\\n     if(j-1 >=0 && board.get(i).charAt(j-1)!= \\'X\\'){\\n         l = solve(board,i,j-1,sdp,pdp);\\n     }\\n\\n    \\n     ans=Math.max(l,Math.max(u,d));\\n\\n     // blocked path no ans possible\\n     if(ans == -(int)1e9){\\n         val=0; ans=0;\\n         \\n         if(board.get(i).charAt(j)==\\'S\\')return sdp[i][j]=0;\\n\\n         return sdp[i][j]=-(int)1e9;\\n     }\\n     \\n     // after finding max score checking for the path (u,l,d) with same max \\n     \\n     if(l==ans){ pdp[i][j]=(pdp[i][j]+pdp[i][j-1])%M; }\\n     if(u==ans){ pdp[i][j]=(pdp[i][j]+pdp[i-1][j])%M; }\\n     if(d==ans){ pdp[i][j]=(pdp[i][j]+pdp[i-1][j-1])%M; }\\n     \\n    return sdp[i][j]= ( ans + val ) % M;\\n    }\\n    \\n    public int[] pathsWithMaxScore(List<String> board) {\\n    int[] ans =new int[2];\\n    int r=board.size() , c= board.get(0).length();\\n    int[][] sdp=new int[r][c]; // for storing max score\\n     int[][] pdp=new int[r][c];  // for storing path\\n    for(int[] d:sdp)Arrays.fill(d,-1);\\n    solve(board,r-1,c-1,sdp,pdp);\\n\\n    ans[0]=sdp[r-1][c-1]; \\n    ans[1]=pdp[r-1][c-1];\\n\\n    return ans;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959439,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def pathsWithMaxScore(self, board):\\n        matrix = []\\n\\n        for i in board:\\n            matrix += [list(i)]\\n\\n        m, n, mod = len(matrix), len(matrix[0]), 10**9+7\\n\\n        @lru_cache(None)\\n        def dfs(i,j):\\n            if i >= m or j >= n or matrix[i][j] == \"X\":\\n                return (float(\"-inf\"),0)\\n\\n            if i == m-1 and j == n-1:\\n                return (0,1)\\n\\n            op1 = dfs(i+1,j)\\n            op2 = dfs(i,j+1)\\n            op3 = dfs(i+1,j+1)\\n\\n            score = int(matrix[i][j]) if matrix[i][j] != \"E\" else 0\\n\\n            count, prev_score = 0, max(op1[0],op2[0],op3[0])\\n\\n            if op1[0] == prev_score:\\n                count += op1[1]\\n            if op2[0] == prev_score:\\n                count += op2[1]\\n            if op3[0] == prev_score:\\n                count += op3[1]\\n\\n            return (score + prev_score,count%mod)\\n\\n        \\n        res = dfs(0,0)\\n\\n        return [max(res[0],0),res[1]]\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pathsWithMaxScore(self, board):\\n        matrix = []\\n\\n        for i in board:\\n            matrix += [list(i)]\\n\\n        m, n, mod = len(matrix), len(matrix[0]), 10**9+7\\n\\n        @lru_cache(None)\\n        def dfs(i,j):\\n            if i >= m or j >= n or matrix[i][j] == \"X\":\\n                return (float(\"-inf\"),0)\\n\\n            if i == m-1 and j == n-1:\\n                return (0,1)\\n\\n            op1 = dfs(i+1,j)\\n            op2 = dfs(i,j+1)\\n            op3 = dfs(i+1,j+1)\\n\\n            score = int(matrix[i][j]) if matrix[i][j] != \"E\" else 0\\n\\n            count, prev_score = 0, max(op1[0],op2[0],op3[0])\\n\\n            if op1[0] == prev_score:\\n                count += op1[1]\\n            if op2[0] == prev_score:\\n                count += op2[1]\\n            if op3[0] == prev_score:\\n                count += op3[1]\\n\\n            return (score + prev_score,count%mod)\\n\\n        \\n        res = dfs(0,0)\\n\\n        return [max(res[0],0),res[1]]\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347022,
                "title": "can-anyone-tell-me-what-is-the-problem-in-my-approach-dijkstra",
                "content": "```\\nclass Solution {\\n\\n   [\"E11345\",\"X452XX\",\"3X43X4\",\"422812\",\"284522\",\"13422S\"]\\n for this input \\n \\n \\n    public int[] pathsWithMaxScore(List<String> board) {\\n        //maximum sum with count of paths\\n        //Dijkstra Algo\\n        \\n        int n=board.size();\\n        int m=board.get(0).length();\\n        \\n        int[][]cost=new int[n][m];\\n        int mod=(int)Math.pow(10,9)+7;\\n        \\n        \\n        \\n        int[][]path=new int[n][m];\\n        path[n-1][m-1]=1;\\n        \\n        PriorityQueue<int[]>pq=new PriorityQueue<>((a,b)->b[2]-a[2]);\\n        pq.add(new int[]{n-1,m-1,0});\\n        \\n        \\n        while(pq.size()>0){\\n            int[]tmp=pq.remove();\\n            \\n            \\n           \\n            int[]dx={-1,-1,0};\\n            int[]dy={-1,0,-1};\\n            \\n            int x=tmp[0];int y=tmp[1];\\n           \\n            \\n            for(int k=0;k<3;k++){\\n                if(x+dx[k]>=0 && y+dy[k]>=0 && board.get(x+dx[k]).charAt(y+dy[k]) !=\\'X\\'){\\n                   int X=x+dx[k];\\n                   int Y=y+dy[k];\\n                     \\n                int c=board.get(X).charAt(Y)==\\'E\\'?0:board.get(X).charAt(Y)-\\'0\\';\\n                \\n                if(cost[X][Y] < tmp[2]+c){\\n                    cost[X][Y]=tmp[2]+c;\\n                    path[X][Y]=path[x][y];\\n                    pq.add(new int[]{X,Y,cost[X][Y]});\\n                    \\n                }else if(cost[X][Y] == tmp[2]+c)\\n                    path[X][Y] = (path[X][Y]+path[x][y])%mod;\\n                       \\n                }\\n            }\\n            \\n            \\n        }\\n        \\n    \\n        return new int[]{cost[0][0],(path[0][0])%mod};\\n        \\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n   [\"E11345\",\"X452XX\",\"3X43X4\",\"422812\",\"284522\",\"13422S\"]\\n for this input \\n \\n \\n    public int[] pathsWithMaxScore(List<String> board) {\\n        //maximum sum with count of paths\\n        //Dijkstra Algo\\n        \\n        int n=board.size();\\n        int m=board.get(0).length();\\n        \\n        int[][]cost=new int[n][m];\\n        int mod=(int)Math.pow(10,9)+7;\\n        \\n        \\n        \\n        int[][]path=new int[n][m];\\n        path[n-1][m-1]=1;\\n        \\n        PriorityQueue<int[]>pq=new PriorityQueue<>((a,b)->b[2]-a[2]);\\n        pq.add(new int[]{n-1,m-1,0});\\n        \\n        \\n        while(pq.size()>0){\\n            int[]tmp=pq.remove();\\n            \\n            \\n           \\n            int[]dx={-1,-1,0};\\n            int[]dy={-1,0,-1};\\n            \\n            int x=tmp[0];int y=tmp[1];\\n           \\n            \\n            for(int k=0;k<3;k++){\\n                if(x+dx[k]>=0 && y+dy[k]>=0 && board.get(x+dx[k]).charAt(y+dy[k]) !=\\'X\\'){\\n                   int X=x+dx[k];\\n                   int Y=y+dy[k];\\n                     \\n                int c=board.get(X).charAt(Y)==\\'E\\'?0:board.get(X).charAt(Y)-\\'0\\';\\n                \\n                if(cost[X][Y] < tmp[2]+c){\\n                    cost[X][Y]=tmp[2]+c;\\n                    path[X][Y]=path[x][y];\\n                    pq.add(new int[]{X,Y,cost[X][Y]});\\n                    \\n                }else if(cost[X][Y] == tmp[2]+c)\\n                    path[X][Y] = (path[X][Y]+path[x][y])%mod;\\n                       \\n                }\\n            }\\n            \\n            \\n        }\\n        \\n    \\n        return new int[]{cost[0][0],(path[0][0])%mod};\\n        \\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663138,
                "title": "python-dp-in-clear-recursion-iteration",
                "content": "for every position on board, `(x, y)`, find max sum `s` of its predecessors `(x+1, y), (x, y+1), (x+1, y+1)`, new max sum is `s + board[x][y]`, new count is total count of previous max sum `s` of its predecessors. Base case `S` is `sum=0, count=1`, block case `X` is `sum=-1, count=0`.  \\n\\n1. recursion\\n```python\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        @cache\\n        def search(x, y):\\n            if x == n - 1 and y == n - 1:  # base case\\n                return (0, 1)\\n            if board[x][y] == \\'X\\':  # block case\\n                return (-1, 0)\\n            memo = Counter()\\n            for prex, prey in ((x+1, y), (x, y+1), (x+1, y+1)):\\n                if prex <= n - 1 and prey <= n - 1:\\n                    s, c = search(prex, prey)\\n                    memo[s] += c\\n            best = max(memo)\\n            if best < 0:\\n                return -1, 0\\n            if x == 0 and y == 0:  # final case\\n                return [best, memo[best]]\\n            return [best + int(board[x][y]), memo[best]]\\n        \\n        n = len(board)\\n        res = search(0, 0)\\n        if res[0] < 0:\\n            return [0, 0]\\n        return [res[0], res[1] % 1_000_000_007]\\n```\\n2. iterative\\n```python\\n        n = len(board)\\n        dp = [[(0, 0)] * n for _ in range(n)]\\n        for x in range(n):\\n            for y in range(n):\\n                if x == 0 and y == 0:\\n                    dp[0][0] = (0, 1)  # base case\\n                    continue\\n                if board[x][y] == \\'X\\':  # block case\\n                    dp[x][y] = (-1, 0)\\n                    continue\\n                memo = Counter()\\n                for prex, prey in ((x-1, y), (x, y-1), (x-1, y-1)):\\n                    if prex >= 0 and prey >= 0:\\n                        s, c = dp[prex][prey]\\n                        memo[s] += c\\n                best = max(memo)\\n                if best < 0:\\n                    dp[x][y] = (-1, 0)\\n                    continue\\n                if x == n - 1 and y == n - 1:  # final case\\n                    dp[x][y] = (best, memo[best] % 1_000_000_007)\\n                    continue\\n                dp[x][y] = (best + int(board[x][y]), memo[best] % 1_000_000_007)\\n                \\n        if dp[-1][-1][0] < 0:\\n            return [0, 0]\\n        return dp[-1][-1]\\n```",
                "solutionTags": [],
                "code": "```python\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        @cache\\n        def search(x, y):\\n            if x == n - 1 and y == n - 1:  # base case\\n                return (0, 1)\\n            if board[x][y] == \\'X\\':  # block case\\n                return (-1, 0)\\n            memo = Counter()\\n            for prex, prey in ((x+1, y), (x, y+1), (x+1, y+1)):\\n                if prex <= n - 1 and prey <= n - 1:\\n                    s, c = search(prex, prey)\\n                    memo[s] += c\\n            best = max(memo)\\n            if best < 0:\\n                return -1, 0\\n            if x == 0 and y == 0:  # final case\\n                return [best, memo[best]]\\n            return [best + int(board[x][y]), memo[best]]\\n        \\n        n = len(board)\\n        res = search(0, 0)\\n        if res[0] < 0:\\n            return [0, 0]\\n        return [res[0], res[1] % 1_000_000_007]\\n```\n```python\\n        n = len(board)\\n        dp = [[(0, 0)] * n for _ in range(n)]\\n        for x in range(n):\\n            for y in range(n):\\n                if x == 0 and y == 0:\\n                    dp[0][0] = (0, 1)  # base case\\n                    continue\\n                if board[x][y] == \\'X\\':  # block case\\n                    dp[x][y] = (-1, 0)\\n                    continue\\n                memo = Counter()\\n                for prex, prey in ((x-1, y), (x, y-1), (x-1, y-1)):\\n                    if prex >= 0 and prey >= 0:\\n                        s, c = dp[prex][prey]\\n                        memo[s] += c\\n                best = max(memo)\\n                if best < 0:\\n                    dp[x][y] = (-1, 0)\\n                    continue\\n                if x == n - 1 and y == n - 1:  # final case\\n                    dp[x][y] = (best, memo[best] % 1_000_000_007)\\n                    continue\\n                dp[x][y] = (best + int(board[x][y]), memo[best] % 1_000_000_007)\\n                \\n        if dp[-1][-1][0] < 0:\\n            return [0, 0]\\n        return dp[-1][-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1553289,
                "title": "python3-implementation-recursion-memoisation",
                "content": "```\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.board = None\\n        self.table = {}\\n        self.n = 0\\n        self.m = 0\\n        self.mod = 1000000007\\n    \\n    def helper_func(self, position):\\n        x, y = position\\n        if x == 0 and y == 0:\\n            return 0, 1\\n        elif x >= self.n or y >= self.m or x < 0 or y < 0 or self.board[x][y] not in \\'0123456789\\':\\n            return -sys.maxsize, 0\\n        elif position in self.table:\\n            return self.table[position]\\n        else:\\n            left_sum, left_count = self.helper_func((x, y-1))\\n            up_sum, up_count = self.helper_func((x-1, y))\\n            diagonal_sum, diagonal_count = self.helper_func((x-1, y-1))\\n            max_sum = max(left_sum, up_sum, diagonal_sum)\\n            curr_sum = int(self.board[x][y]) + max_sum\\n            curr_count = 0\\n            if left_sum == max_sum: curr_count += left_count\\n            if up_sum == max_sum: curr_count += up_count\\n            if diagonal_sum == max_sum: curr_count += diagonal_count\\n            self.table[(x,y)] = curr_sum, curr_count % self.mod\\n            return self.table[(x,y)]    \\n        \\n            \\n    \\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n    \\n        \\n        self.board = board\\n        self.n = len(board)\\n        self.m = len(board[0])\\n        self.board[self.n-1] = self.board[self.n-1][:self.m-1] + \\'0\\'\\n        res, count = self.helper_func((self.n-1, self.m-1))\\n        if res < -10000001: res = 0\\n        return res,count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.board = None\\n        self.table = {}\\n        self.n = 0\\n        self.m = 0\\n        self.mod = 1000000007\\n    \\n    def helper_func(self, position):\\n        x, y = position\\n        if x == 0 and y == 0:\\n            return 0, 1\\n        elif x >= self.n or y >= self.m or x < 0 or y < 0 or self.board[x][y] not in \\'0123456789\\':\\n            return -sys.maxsize, 0\\n        elif position in self.table:\\n            return self.table[position]\\n        else:\\n            left_sum, left_count = self.helper_func((x, y-1))\\n            up_sum, up_count = self.helper_func((x-1, y))\\n            diagonal_sum, diagonal_count = self.helper_func((x-1, y-1))\\n            max_sum = max(left_sum, up_sum, diagonal_sum)\\n            curr_sum = int(self.board[x][y]) + max_sum\\n            curr_count = 0\\n            if left_sum == max_sum: curr_count += left_count\\n            if up_sum == max_sum: curr_count += up_count\\n            if diagonal_sum == max_sum: curr_count += diagonal_count\\n            self.table[(x,y)] = curr_sum, curr_count % self.mod\\n            return self.table[(x,y)]    \\n        \\n            \\n    \\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n    \\n        \\n        self.board = board\\n        self.n = len(board)\\n        self.m = len(board[0])\\n        self.board[self.n-1] = self.board[self.n-1][:self.m-1] + \\'0\\'\\n        res, count = self.helper_func((self.n-1, self.m-1))\\n        if res < -10000001: res = 0\\n        return res,count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532324,
                "title": "kotlin-dp",
                "content": "\\n    fun pathsWithMaxScore(board: List<String>): IntArray {\\n        val n = board.size\\n        val score = Array(n, { i -> Array(n, { j -> intArrayOf(0, 0) }) }) \\n        for (i in n - 1 downTo 0) {\\n            columeLoop@ for (j in n - 1 downTo 0) {\\n                when (board[i][j]) {\\n                    \\'X\\' -> continue@columeLoop\\n                    \\'S\\' -> score[i][j][1] = 1\\n                    else -> {\\n                        val lower = score.elementAtOrNull(i + 1)?.elementAtOrNull(j) ?: intArrayOf(0, 0)\\n                        val right = score.elementAtOrNull(i)?.elementAtOrNull(j + 1) ?: intArrayOf(0, 0)\\n                        val lowerRight = score.elementAtOrNull(i + 1)?.elementAtOrNull(j + 1) ?: intArrayOf(0, 0)\\n                        val sum = calculateScore(arrayOf(lower, right, lowerRight))\\n                        if (sum[1] != 0) {\\n                            val self = if (board[i][j] == \\'E\\') 0 else board[i][j] - \\'0\\'\\n                            score[i][j] = intArrayOf(sum[0] + self, sum[1])\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return score[0][0]\\n    }\\n    \\n    private fun calculateScore(arrays: Array<IntArray>): IntArray {\\n        val mod = (Math.pow(10.0, 9.0) + 7).toInt()\\n        return arrays.reduce { acc, score -> if (score[0] > acc[0]) score else if (score[0] == acc[0]) intArrayOf(acc[0], (acc[1] + score[1])%mod) else acc }\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    fun pathsWithMaxScore(board: List<String>): IntArray {\\n        val n = board.size\\n        val score = Array(n, { i -> Array(n, { j -> intArrayOf(0, 0) }) }) \\n        for (i in n - 1 downTo 0) {\\n            columeLoop@ for (j in n - 1 downTo 0) {\\n                when (board[i][j]) {\\n                    \\'X\\' -> continue@columeLoop\\n                    \\'S\\' -> score[i][j][1] = 1\\n                    else -> {\\n                        val lower = score.elementAtOrNull(i + 1)?.elementAtOrNull(j) ?: intArrayOf(0, 0)\\n                        val right = score.elementAtOrNull(i)?.elementAtOrNull(j + 1) ?: intArrayOf(0, 0)\\n                        val lowerRight = score.elementAtOrNull(i + 1)?.elementAtOrNull(j + 1) ?: intArrayOf(0, 0)\\n                        val sum = calculateScore(arrayOf(lower, right, lowerRight))\\n                        if (sum[1] != 0) {\\n                            val self = if (board[i][j] == \\'E\\') 0 else board[i][j] - \\'0\\'\\n                            score[i][j] = intArrayOf(sum[0] + self, sum[1])\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return score[0][0]\\n    }\\n    \\n    private fun calculateScore(arrays: Array<IntArray>): IntArray {\\n        val mod = (Math.pow(10.0, 9.0) + 7).toInt()\\n        return arrays.reduce { acc, score -> if (score[0] > acc[0]) score else if (score[0] == acc[0]) intArrayOf(acc[0], (acc[1] + score[1])%mod) else acc }\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1250536,
                "title": "python-3-solution-faster-than-70-of-solutions-2d-dynamic-programming",
                "content": "```\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        n = len(board)-1\\n        self.board = [[int(_) if _.isdigit() else _ for _ in x] for x in board]\\n        self.board[n][n] = 0\\n        self.board[0][0] = 0\\n        self.scores = [[0 for _ in range(n+2)] for x in range(n+2)]\\n        self.counts = [[0 for _ in range(n+2)] for x in range(n+2)]\\n        self.counts[n][n] = 1\\n        for i in range(n, -1, -1):\\n            for j in range(n, -1, -1):\\n                if self.board[i][j] == \\'X\\':\\n                    continue\\n                highest_score = max(self.scores[i+1][j],\\n                            self.scores[i+1][j+1],\\n                            self.scores[i][j+1])\\n                score = highest_score + self.board[i][j]\\n                self.scores[i][j] = score\\n                \\n                for i_x, j_x in [[i+1, j], [i+1, j+1], [i, j+1]]:\\n                    if self.scores[i_x][j_x] == highest_score:\\n                        self.counts[i][j] += self.counts[i_x][j_x]\\n        \\n        if self.counts[0][0] == 0:\\n            return [0, 0]\\n        else:\\n            return [self.scores[0][0], self.counts[0][0] % (10**9+7)]\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        n = len(board)-1\\n        self.board = [[int(_) if _.isdigit() else _ for _ in x] for x in board]\\n        self.board[n][n] = 0\\n        self.board[0][0] = 0\\n        self.scores = [[0 for _ in range(n+2)] for x in range(n+2)]\\n        self.counts = [[0 for _ in range(n+2)] for x in range(n+2)]\\n        self.counts[n][n] = 1\\n        for i in range(n, -1, -1):\\n            for j in range(n, -1, -1):\\n                if self.board[i][j] == \\'X\\':\\n                    continue\\n                highest_score = max(self.scores[i+1][j],\\n                            self.scores[i+1][j+1],\\n                            self.scores[i][j+1])\\n                score = highest_score + self.board[i][j]\\n                self.scores[i][j] = score\\n                \\n                for i_x, j_x in [[i+1, j], [i+1, j+1], [i, j+1]]:\\n                    if self.scores[i_x][j_x] == highest_score:\\n                        self.counts[i][j] += self.counts[i_x][j_x]\\n        \\n        if self.counts[0][0] == 0:\\n            return [0, 0]\\n        else:\\n            return [self.scores[0][0], self.counts[0][0] % (10**9+7)]\\n",
                "codeTag": "Java"
            },
            {
                "id": 1227401,
                "title": "java-dp-solution",
                "content": "java code is:\\n# \\n```\\nclass Solution { \\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int traverse[][]=new int[][]{{-1,0},{0,-1},{-1,-1}};\\n        int n=board.size(),m=board.get(0).length(),mod=(int)1e9+7;\\n         board.set(n-1,board.get(n-1).substring(0,m-1)+\"0\");\\n        int dp[][][]=new int[n][m][2];\\n        dp[0][0][1]=1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board.get(i).charAt(j)==\\'X\\')continue;\\n                for(int t[] : traverse){\\n                    if(i+t[0]<0||i+t[0]>=n||j+t[1]<0||j+t[1]>=m)continue;\\n                    if(dp[i+t[0]][j+t[1]][0]+(board.get(i).charAt(j)-\\'0\\')==dp[i][j][0])\\n                        dp[i][j][1]=(dp[i][j][1]+dp[i+t[0]][j+t[1]][1])%mod;\\n                else if(dp[i+t[0]][j+t[1]][0]+(board.get(i).charAt(j)-\\'0\\')>dp[i][j][0]){\\n                    dp[i][j][0]=dp[i+t[0]][j+t[1]][0]+(board.get(i).charAt(j)-\\'0\\');\\n                    dp[i][j][1]=dp[i+t[0]][j+t[1]][1];\\n                }\\n                }\\n            }\\n        }\\n        return new int[]{dp[n-1][m-1][1]==0 ? 0 : dp[n-1][m-1][0],dp[n-1][m-1][1]};\\n    }\\n}\\n```\\n***Please,Upvote if this is helpful***",
                "solutionTags": [],
                "code": "```\\nclass Solution { \\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int traverse[][]=new int[][]{{-1,0},{0,-1},{-1,-1}};\\n        int n=board.size(),m=board.get(0).length(),mod=(int)1e9+7;\\n         board.set(n-1,board.get(n-1).substring(0,m-1)+\"0\");\\n        int dp[][][]=new int[n][m][2];\\n        dp[0][0][1]=1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board.get(i).charAt(j)==\\'X\\')continue;\\n                for(int t[] : traverse){\\n                    if(i+t[0]<0||i+t[0]>=n||j+t[1]<0||j+t[1]>=m)continue;\\n                    if(dp[i+t[0]][j+t[1]][0]+(board.get(i).charAt(j)-\\'0\\')==dp[i][j][0])\\n                        dp[i][j][1]=(dp[i][j][1]+dp[i+t[0]][j+t[1]][1])%mod;\\n                else if(dp[i+t[0]][j+t[1]][0]+(board.get(i).charAt(j)-\\'0\\')>dp[i][j][0]){\\n                    dp[i][j][0]=dp[i+t[0]][j+t[1]][0]+(board.get(i).charAt(j)-\\'0\\');\\n                    dp[i][j][1]=dp[i+t[0]][j+t[1]][1];\\n                }\\n                }\\n            }\\n        }\\n        return new int[]{dp[n-1][m-1][1]==0 ? 0 : dp[n-1][m-1][0],dp[n-1][m-1][1]};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169473,
                "title": "c-top-down",
                "content": "```\\n#define ll long long\\nint M=1000000007;\\nclass Solution {\\npublic:\\n    ll int dp[105][105][2];\\n    //ll int dp1[105][105];\\n    pair<ll int,ll int> fun(int i,int j,vector<string>&mat,int n)\\n    {\\n        if(i==n-1 && j==n-1)\\n            return {0,1};\\n        if(i>=n || j>=n)\\n            return {INT_MIN,0};\\n        if(mat[i][j]==\\'X\\')\\n            return {INT_MIN,0};\\n        if(dp[i][j][0]!=-1)\\n            {          \\n            pair<ll int,ll int>p={dp[i][j][0],dp[i][j][1]};\\n            return p;\\n            }\\n        pair<ll int,ll int>p={INT_MIN,0};\\n        auto p1=fun(i+1,j+1,mat,n);\\n        p=p1;\\n        auto p2=fun(i,j+1,mat,n);\\n        if(p2.first>p.first)\\n        {\\n            p.first=p2.first;\\n            p.second=p2.second;\\n        }\\n        else if(p2.first==p.first)\\n            p.second+=p2.second;\\n        auto p3=fun(i+1,j,mat,n);\\n        if(p3.first>p.first)\\n        {\\n            p.first=p3.first;\\n            p.second=p3.second;\\n        }\\n        else if(p3.first==p.first)\\n            p.second+=p3.second;\\n        if(p.first!=INT_MIN && mat[i][j]>=\\'1\\' && mat[i][j]<=\\'9\\')\\n            p.first+=mat[i][j]-\\'0\\';\\n        dp[i][j][0]=p.first;\\n        dp[i][j][1]=p.second;\\n        p.second%=M;\\n        return p;\\n            \\n        \\n    }\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int n=board.size();\\n        vector<int>v={0,0};\\n        memset(dp,-1,sizeof(dp));\\n        auto ans=fun(0,0,board,n);\\n        if(ans.first==INT_MIN)\\n            return v;\\n        v[0]=ans.first;\\n        v[1]=ans.second;\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nint M=1000000007;\\nclass Solution {\\npublic:\\n    ll int dp[105][105][2];\\n    //ll int dp1[105][105];\\n    pair<ll int,ll int> fun(int i,int j,vector<string>&mat,int n)\\n    {\\n        if(i==n-1 && j==n-1)\\n            return {0,1};\\n        if(i>=n || j>=n)\\n            return {INT_MIN,0};\\n        if(mat[i][j]==\\'X\\')\\n            return {INT_MIN,0};\\n        if(dp[i][j][0]!=-1)\\n            {          \\n            pair<ll int,ll int>p={dp[i][j][0],dp[i][j][1]};\\n            return p;\\n            }\\n        pair<ll int,ll int>p={INT_MIN,0};\\n        auto p1=fun(i+1,j+1,mat,n);\\n        p=p1;\\n        auto p2=fun(i,j+1,mat,n);\\n        if(p2.first>p.first)\\n        {\\n            p.first=p2.first;\\n            p.second=p2.second;\\n        }\\n        else if(p2.first==p.first)\\n            p.second+=p2.second;\\n        auto p3=fun(i+1,j,mat,n);\\n        if(p3.first>p.first)\\n        {\\n            p.first=p3.first;\\n            p.second=p3.second;\\n        }\\n        else if(p3.first==p.first)\\n            p.second+=p3.second;\\n        if(p.first!=INT_MIN && mat[i][j]>=\\'1\\' && mat[i][j]<=\\'9\\')\\n            p.first+=mat[i][j]-\\'0\\';\\n        dp[i][j][0]=p.first;\\n        dp[i][j][1]=p.second;\\n        p.second%=M;\\n        return p;\\n            \\n        \\n    }\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int n=board.size();\\n        vector<int>v={0,0};\\n        memset(dp,-1,sizeof(dp));\\n        auto ans=fun(0,0,board,n);\\n        if(ans.first==INT_MIN)\\n            return v;\\n        v[0]=ans.first;\\n        v[1]=ans.second;\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1061031,
                "title": "dp-o-n-memory",
                "content": "```\\nclass Solution {\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int n = board.size(), dpVal[] = new int[n+1], dpPath[] = new int[n+1], mod = (int)1e9+7;\\n        for(int j = n-1; j >= 0; --j){\\n            var r = board.get(j);\\n            var diag = new int[2];\\n            for(int i = n-1; i >= 0; --i){\\n                var c = r.charAt(i);\\n                if (c == \\'S\\'){\\n                    dpPath[n-1] = 1;\\n                    continue;\\n                }\\n                c = c == \\'E\\' ? \\'0\\' : c;\\n                var nDiag = new int[]{dpVal[i],dpPath[i]};\\n                dpVal[i] = dpPath[i] = 0;\\n                if (c != \\'X\\'){ \\n                    for(var d : new int[][]{new int[]{dpVal[i+1],dpPath[i+1]},nDiag,diag}){\\n                        if (d[1] == 0) continue;\\n                        int v = (c-\\'0\\')+d[0];\\n                        if (v > dpVal[i]){\\n                            dpVal[i] = v;\\n                            dpPath[i] = d[1];\\n                        } else if (v == dpVal[i]){\\n                            long paths = ((long)dpPath[i]+(long)d[1])%mod;\\n                            dpPath[i] = (int)paths;\\n                        }\\n                    }\\n                }\\n                diag = nDiag;\\n            }\\n        }\\n        return new int[]{dpVal[0],dpPath[0]};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int n = board.size(), dpVal[] = new int[n+1], dpPath[] = new int[n+1], mod = (int)1e9+7;\\n        for(int j = n-1; j >= 0; --j){\\n            var r = board.get(j);\\n            var diag = new int[2];\\n            for(int i = n-1; i >= 0; --i){\\n                var c = r.charAt(i);\\n                if (c == \\'S\\'){\\n                    dpPath[n-1] = 1;\\n                    continue;\\n                }\\n                c = c == \\'E\\' ? \\'0\\' : c;\\n                var nDiag = new int[]{dpVal[i],dpPath[i]};\\n                dpVal[i] = dpPath[i] = 0;\\n                if (c != \\'X\\'){ \\n                    for(var d : new int[][]{new int[]{dpVal[i+1],dpPath[i+1]},nDiag,diag}){\\n                        if (d[1] == 0) continue;\\n                        int v = (c-\\'0\\')+d[0];\\n                        if (v > dpVal[i]){\\n                            dpVal[i] = v;\\n                            dpPath[i] = d[1];\\n                        } else if (v == dpVal[i]){\\n                            long paths = ((long)dpPath[i]+(long)d[1])%mod;\\n                            dpPath[i] = (int)paths;\\n                        }\\n                    }\\n                }\\n                diag = nDiag;\\n            }\\n        }\\n        return new int[]{dpVal[0],dpPath[0]};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 897031,
                "title": "c-dfs-memoization",
                "content": "```\\n#define ll long long int\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n  \\n    vector<vector<pair<ll,ll>>>dp;\\n    pair<ll,ll> dfs(int i,int j,vector<string>&board)\\n    {\\n        if(i<0 or j<0 or board[i][j]==\\'X\\') return {0,0};\\n        if(board[i][j]==\\'E\\') return {0,1};\\n        if(dp[i][j].first!=-1) return dp[i][j];\\n        ll res;\\n        pair<ll,ll> a = dfs(i-1,j,board);\\n        pair<ll,ll> b = dfs(i,j-1,board);\\n        pair<ll,ll> c = dfs(i-1,j-1,board);\\n        res = max(a.first,max(b.first,c.first));\\n        ll cnt=0;\\n        if(res==a.first) cnt=(cnt+a.second)%mod;\\n        if(res==b.first) cnt =(cnt+b.second)%mod;\\n        if(res==c.first) cnt =(cnt+c.second)%mod;\\n        if(board[i][j] != \\'S\\')\\n            res= (res+(board[i][j]-\\'0\\'))%mod;\\n        dp[i][j]={res,cnt};\\n        return {res,cnt};\\n        \\n    }\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        dp.resize(board.size(),vector<pair<ll,ll>>(board.size(),{-1,-1}));\\n        pair<ll,ll> ans = dfs(board.size()-1,board.size()-1,board);\\n        if(ans.second==0) return {0,0};\\n        return {(int)(ans.first%mod),(int)(ans.second%mod)};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\n#define mod 1000000007\\nclass Solution {\\npublic:\\n  \\n    vector<vector<pair<ll,ll>>>dp;\\n    pair<ll,ll> dfs(int i,int j,vector<string>&board)\\n    {\\n        if(i<0 or j<0 or board[i][j]==\\'X\\') return {0,0};\\n        if(board[i][j]==\\'E\\') return {0,1};\\n        if(dp[i][j].first!=-1) return dp[i][j];\\n        ll res;\\n        pair<ll,ll> a = dfs(i-1,j,board);\\n        pair<ll,ll> b = dfs(i,j-1,board);\\n        pair<ll,ll> c = dfs(i-1,j-1,board);\\n        res = max(a.first,max(b.first,c.first));\\n        ll cnt=0;\\n        if(res==a.first) cnt=(cnt+a.second)%mod;\\n        if(res==b.first) cnt =(cnt+b.second)%mod;\\n        if(res==c.first) cnt =(cnt+c.second)%mod;\\n        if(board[i][j] != \\'S\\')\\n            res= (res+(board[i][j]-\\'0\\'))%mod;\\n        dp[i][j]={res,cnt};\\n        return {res,cnt};\\n        \\n    }\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        dp.resize(board.size(),vector<pair<ll,ll>>(board.size(),{-1,-1}));\\n        pair<ll,ll> ans = dfs(board.size()-1,board.size()-1,board);\\n        if(ans.second==0) return {0,0};\\n        return {(int)(ans.first%mod),(int)(ans.second%mod)};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 701453,
                "title": "two-pass-top-down-dp-solution-o-n-2-time-o-n-2-space",
                "content": "```\\nclass Solution {\\n    int MOD = 1000000007;\\n    \\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int[] result = new int[2];\\n        int rows = board.size();\\n        int cols = board.get(0).length();\\n        Integer[][] m1 = new Integer[rows][cols];\\n        int score = maxScore(board, rows - 1, cols - 1, m1);\\n        if(score < -1000000) {\\n            return result;\\n        }\\n        result[0] = score;\\n        Integer[][] m2 = new Integer[rows][cols];\\n        result[1] = pathsWithMaxScore(board, rows - 1, cols - 1, m1, m2) + 1;\\n        return result;\\n    }\\n    \\n    public int maxScore(List<String> board, int i, int j, Integer[][] m) {\\n        if(i == 0 && j == 0) {\\n            return 0;\\n        }\\n        if(m[i][j] != null) {\\n            return m[i][j];\\n        }\\n        int val = 0;\\n        if(board.get(i).charAt(j) != \\'S\\') {\\n            val = Character.getNumericValue(board.get(i).charAt(j));\\n        }\\n        int up = Integer.MIN_VALUE;\\n        if(i > 0 && board.get(i - 1).charAt(j) != \\'X\\') {\\n            up = maxScore(board, i - 1, j, m) + val;\\n        }\\n        int left = Integer.MIN_VALUE;\\n        if(j > 0 && board.get(i).charAt(j - 1) != \\'X\\') {\\n            left = maxScore(board, i, j - 1, m) + val;\\n        }\\n        int leftUp = Integer.MIN_VALUE;\\n        if(i > 0 && j > 0 && board.get(i - 1).charAt(j - 1) != \\'X\\') {\\n            leftUp = maxScore(board, i - 1, j - 1, m) + val;\\n        }\\n        int result = Math.max(up, Math.max(left, leftUp));\\n        return m[i][j] = result;\\n    }\\n\\t\\n    public int pathsWithMaxScore(List<String> board, int i, int j, Integer[][] m1, Integer[][] m2) {\\n        if(i == 0 && j == 0) {\\n            return 0;\\n        }\\n        \\n        if(m2[i][j] != null)\\n            return m2[i][j];\\n        \\n        int up = Integer.MIN_VALUE;\\n        if(i > 0 && board.get(i - 1).charAt(j) != \\'X\\') {\\n            if(m1[i - 1][j] != null)\\n                up = m1[i - 1][j];\\n        }\\n        int left = Integer.MIN_VALUE;\\n        if(j > 0 && board.get(i).charAt(j - 1) != \\'X\\') {\\n            if(m1[i][j - 1] != null)\\n                left = m1[i][j - 1];\\n        }\\n        int leftUp = Integer.MIN_VALUE;\\n        if(i > 0 && j > 0 && board.get(i - 1).charAt(j - 1) != \\'X\\') {\\n            if(m1[i - 1][j - 1] != null)\\n                leftUp = m1[i - 1][j - 1];\\n        }\\n        int result = Math.max(up, Math.max(left, leftUp));\\n        int count = -1;\\n        if(up == result && i > 0 && board.get(i - 1).charAt(j) != \\'X\\') {\\n            count += pathsWithMaxScore(board, i - 1, j, m1, m2) + 1;\\n            count %= MOD;\\n        }\\n        if(left == result && j > 0 && board.get(i).charAt(j - 1) != \\'X\\') {\\n            count += pathsWithMaxScore(board, i, j - 1, m1, m2) + 1;\\n            count %= MOD;\\n        }\\n        if(leftUp == result && i > 0 && j > 0 && board.get(i - 1).charAt(j - 1) != \\'X\\') {\\n            count += pathsWithMaxScore(board, i - 1, j - 1, m1, m2) + 1;\\n            count %= MOD;\\n        }\\n        m2[i][j] = count;\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    int MOD = 1000000007;\\n    \\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int[] result = new int[2];\\n        int rows = board.size();\\n        int cols = board.get(0).length();\\n        Integer[][] m1 = new Integer[rows][cols];\\n        int score = maxScore(board, rows - 1, cols - 1, m1);\\n        if(score < -1000000) {\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 572293,
                "title": "c-100-dfs-memoization",
                "content": "```\\n\\n\\n\\n/// Do DFS keeping in mind the no of max paths\\nint **dp_score;\\nint **dp_path_cnt;\\n\\n#define MOD (1000000007ULL)\\n\\nint GetMaxScore(char ** board, int row, int col, int *max_path_cnt, int brd_sz)\\n{\\n    if((row >= brd_sz) || (col >= brd_sz))\\n    {\\n        *max_path_cnt = 0;\\n        return 0;   \\n    }\\n    if(board[row][col] == \\'X\\')\\n    {        \\n        *max_path_cnt = 0;\\n        return 0;  \\n    }\\n    if(board[row][col] == \\'S\\')\\n    {\\n        *max_path_cnt = 1;\\n        return 0;   \\n    }\\n    if(dp_path_cnt[row][col] != INT_MAX)\\n    {\\n        *max_path_cnt = dp_path_cnt[row][col];\\n        return dp_score[row][col];\\n    }\\n    int max_score;\\n    int max_cnt = 0;\\n    int bottom_score;\\n    int bot_right_score;\\n    int right_score;\\n    int bottom_path;\\n    int bot_right_path;\\n    int right_path;\\n    \\n    bottom_score = GetMaxScore(board, row+1, col, &bottom_path, brd_sz);\\n    bot_right_score = GetMaxScore(board, row+1, col+1, &bot_right_path, brd_sz);\\n    right_score = GetMaxScore(board, row, col+1, &right_path, brd_sz);\\n    \\n    max_score = bottom_score;\\n    if(max_score < bot_right_score)\\n        max_score = bot_right_score;\\n    \\n    if(max_score < right_score)\\n        max_score = right_score;\\n    \\n    if(max_score == bottom_score)\\n        max_cnt+=bottom_path;\\n    if(max_score == bot_right_score)\\n        max_cnt+=bot_right_path;\\n    if(max_score == right_score)\\n        max_cnt+=right_path;\\n    \\n    *max_path_cnt = max_cnt%MOD;\\n    if(board[row][col] != \\'E\\')\\n        max_score = max_score + board[row][col] - \\'0\\';\\n    if(0 == max_cnt)\\n        max_score = 0;\\n    dp_path_cnt[row][col] = max_cnt%MOD;\\n    dp_score[row][col]    = max_score%MOD;\\n    return max_score%MOD;\\n}\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* pathsWithMaxScore(char ** board, int boardSize, int* returnSize){\\n\\n    \\n    /// Create DP storage and initialize\\n    dp_score = malloc(boardSize*sizeof(int*));\\n    dp_path_cnt = malloc(boardSize*sizeof(int*));\\n    for(int k=0; k<boardSize;k++)\\n    {\\n        dp_score[k]    = malloc(boardSize*sizeof(int));\\n        dp_path_cnt[k] = malloc(boardSize*sizeof(int));\\n        for(int j=0;j<boardSize;j++)\\n        {   \\n            dp_score[k][j] = INT_MAX;\\n            dp_path_cnt[k][j] = INT_MAX;\\n        }\\n    }\\n    \\n    int *res = malloc(10*sizeof(int));\\n    res[0] = GetMaxScore(board, 0, 0, &res[1], boardSize);\\n    *returnSize = 2;\\n    return res;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\n\\n/// Do DFS keeping in mind the no of max paths\\nint **dp_score;\\nint **dp_path_cnt;\\n\\n#define MOD (1000000007ULL)\\n\\nint GetMaxScore(char ** board, int row, int col, int *max_path_cnt, int brd_sz)\\n{\\n    if((row >= brd_sz) || (col >= brd_sz))\\n    {\\n        *max_path_cnt = 0;\\n        return 0;   \\n    }\\n    if(board[row][col] == \\'X\\')\\n    {        \\n        *max_path_cnt = 0;\\n        return 0;  \\n    }\\n    if(board[row][col] == \\'S\\')\\n    {\\n        *max_path_cnt = 1;\\n        return 0;   \\n    }\\n    if(dp_path_cnt[row][col] != INT_MAX)\\n    {\\n        *max_path_cnt = dp_path_cnt[row][col];\\n        return dp_score[row][col];\\n    }\\n    int max_score;\\n    int max_cnt = 0;\\n    int bottom_score;\\n    int bot_right_score;\\n    int right_score;\\n    int bottom_path;\\n    int bot_right_path;\\n    int right_path;\\n    \\n    bottom_score = GetMaxScore(board, row+1, col, &bottom_path, brd_sz);\\n    bot_right_score = GetMaxScore(board, row+1, col+1, &bot_right_path, brd_sz);\\n    right_score = GetMaxScore(board, row, col+1, &right_path, brd_sz);\\n    \\n    max_score = bottom_score;\\n    if(max_score < bot_right_score)\\n        max_score = bot_right_score;\\n    \\n    if(max_score < right_score)\\n        max_score = right_score;\\n    \\n    if(max_score == bottom_score)\\n        max_cnt+=bottom_path;\\n    if(max_score == bot_right_score)\\n        max_cnt+=bot_right_path;\\n    if(max_score == right_score)\\n        max_cnt+=right_path;\\n    \\n    *max_path_cnt = max_cnt%MOD;\\n    if(board[row][col] != \\'E\\')\\n        max_score = max_score + board[row][col] - \\'0\\';\\n    if(0 == max_cnt)\\n        max_score = 0;\\n    dp_path_cnt[row][col] = max_cnt%MOD;\\n    dp_score[row][col]    = max_score%MOD;\\n    return max_score%MOD;\\n}\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* pathsWithMaxScore(char ** board, int boardSize, int* returnSize){\\n\\n    \\n    /// Create DP storage and initialize\\n    dp_score = malloc(boardSize*sizeof(int*));\\n    dp_path_cnt = malloc(boardSize*sizeof(int*));\\n    for(int k=0; k<boardSize;k++)\\n    {\\n        dp_score[k]    = malloc(boardSize*sizeof(int));\\n        dp_path_cnt[k] = malloc(boardSize*sizeof(int));\\n        for(int j=0;j<boardSize;j++)\\n        {   \\n            dp_score[k][j] = INT_MAX;\\n            dp_path_cnt[k][j] = INT_MAX;\\n        }\\n    }\\n    \\n    int *res = malloc(10*sizeof(int));\\n    res[0] = GetMaxScore(board, 0, 0, &res[1], boardSize);\\n    *returnSize = 2;\\n    return res;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 493298,
                "title": "java-dp-solution",
                "content": "```\\npublic int[] pathsWithMaxScore(List<String> board) {\\n\\tint mod = (int)1e9 + 7;\\n\\tint[][] dirs = { { -1, -1 }, { -1, 0 }, { 0, -1 } };\\n\\tint n = board.size();\\n\\tint[][][] dp = new int[n][n][2];\\n\\tdp[0][0] = new int[] { 0, 1 };\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tchar c = board.get(i).charAt(j);\\n\\t\\t\\tif (c == \\'X\\') continue;\\n\\t\\t\\tint num = c == \\'S\\' ? 0 : c - \\'0\\';\\n\\t\\t\\tfor (int[] dir : dirs) {\\n\\t\\t\\t\\tint ii = i + dir[0], jj = j + dir[1];\\n\\t\\t\\t\\tif (ii < 0 || jj < 0) continue;\\n\\t\\t\\t\\tif ((ii == 0 && jj == 0) || dp[ii][jj][0] > 0) {\\n\\t\\t\\t\\t\\tif (dp[ii][jj][0] + num > dp[i][j][0]) {\\n\\t\\t\\t\\t\\t\\tdp[i][j][0] = dp[ii][jj][0] + num;\\n\\t\\t\\t\\t\\t\\tdp[i][j][1] = dp[ii][jj][1];\\n\\t\\t\\t\\t\\t} else if (dp[ii][jj][0] + num == dp[i][j][0]) {\\n\\t\\t\\t\\t\\t\\tdp[i][j][1] = (dp[i][j][1] + dp[ii][jj][1]) % mod;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[n - 1][n - 1];\\n}",
                "solutionTags": [],
                "code": "```\\npublic int[] pathsWithMaxScore(List<String> board) {\\n\\tint mod = (int)1e9 + 7;\\n\\tint[][] dirs = { { -1, -1 }, { -1, 0 }, { 0, -1 } };\\n\\tint n = board.size();\\n\\tint[][][] dp = new int[n][n][2];\\n\\tdp[0][0] = new int[] { 0, 1 };\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tchar c = board.get(i).charAt(j);\\n\\t\\t\\tif (c == \\'X\\') continue;\\n\\t\\t\\tint num = c == \\'S\\' ? 0 : c - \\'0\\';\\n\\t\\t\\tfor (int[] dir : dirs) {\\n\\t\\t\\t\\tint ii = i + dir[0], jj = j + dir[1];\\n\\t\\t\\t\\tif (ii < 0 || jj < 0) continue;\\n\\t\\t\\t\\tif ((ii == 0 && jj == 0) || dp[ii][jj][0] > 0) {\\n\\t\\t\\t\\t\\tif (dp[ii][jj][0] + num > dp[i][j][0]) {\\n\\t\\t\\t\\t\\t\\tdp[i][j][0] = dp[ii][jj][0] + num;\\n\\t\\t\\t\\t\\t\\tdp[i][j][1] = dp[ii][jj][1];\\n\\t\\t\\t\\t\\t} else if (dp[ii][jj][0] + num == dp[i][j][0]) {\\n\\t\\t\\t\\t\\t\\tdp[i][j][1] = (dp[i][j][1] + dp[ii][jj][1]) % mod;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[n - 1][n - 1];\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 476480,
                "title": "java-dp",
                "content": "```\\nclass Solution {\\n    int mod = 1_000_000_007;\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int n = board.size();\\n        int m = board.get(0).length();\\n        int[][] max = new int[n][m];\\n        long[][] nums = new long[n][m];\\n        for (int[] x : max) {\\n            Arrays.fill(x, -1);\\n        }\\n        max[n - 1][m - 1] = 0;\\n        nums[n - 1][m - 1] = 1;\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = m - 1; j >= 0; j--) {\\n                if (i == n - 1 && j == m - 1) {\\n                    continue;\\n                }\\n                char c = board.get(i).charAt(j);\\n                if (c != \\'X\\') {\\n                    int tmp = i == 0 && j == 0 ? 0 : c - \\'0\\';\\n                    if (i == n - 1) {\\n                        if (max[i][j + 1] != -1) {\\n                            max[i][j] = Math.max(max[i][j], max[i][j + 1] + tmp);\\n                            nums[i][j] = (nums[i][j] + nums[i][j + 1]) % mod;\\n                        }\\n                        continue;\\n                    }\\n                    if (j == m - 1) {\\n                        if (max[i + 1][j] != -1) {\\n                            max[i][j] = Math.max(max[i][j], max[i + 1][j] + tmp);\\n                            nums[i][j] = (nums[i][j] + nums[i + 1][j]) % mod;\\n                        }\\n                        continue;\\n                    }\\n                    if (max[i][j + 1] != -1) {\\n                        max[i][j] = Math.max(max[i][j], max[i][j + 1] + tmp);\\n                    }\\n                    if (max[i + 1][j] != -1) {\\n                        max[i][j] = Math.max(max[i][j], max[i + 1][j] + tmp);\\n                    }\\n                    if (max[i + 1][j + 1] != -1) {\\n                        max[i][j] = Math.max(max[i][j], max[i + 1][j + 1] + tmp);\\n                    }\\n                    if (max[i][j + 1] != -1 && max[i][j] == max[i][j + 1] + tmp) {\\n                        nums[i][j] = (nums[i][j] + nums[i][j + 1]) % mod;\\n                    }\\n                    if (max[i + 1][j] != -1 && max[i][j] == max[i + 1][j] + tmp) {\\n                        nums[i][j] = (nums[i + 1][j] + nums[i][j]) % mod;\\n                    }\\n                    if (max[i + 1][j + 1] != -1 && max[i][j] == max[i + 1][j + 1] + tmp) {\\n                        nums[i][j] = (nums[i + 1][j + 1] + nums[i][j]) % mod;\\n                    }\\n                }\\n            }\\n        }\\n        int[] res = new int[2];\\n        if (max[0][0] == -1) {\\n            return res;\\n        }\\n        res[0] = max[0][0];\\n        res[1] = (int)nums[0][0];\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int mod = 1_000_000_007;\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int n = board.size();\\n        int m = board.get(0).length();\\n        int[][] max = new int[n][m];\\n        long[][] nums = new long[n][m];\\n        for (int[] x : max) {\\n            Arrays.fill(x, -1);\\n        }\\n        max[n - 1][m - 1] = 0;\\n        nums[n - 1][m - 1] = 1;\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = m - 1; j >= 0; j--) {\\n                if (i == n - 1 && j == m - 1) {\\n                    continue;\\n                }\\n                char c = board.get(i).charAt(j);\\n                if (c != \\'X\\') {\\n                    int tmp = i == 0 && j == 0 ? 0 : c - \\'0\\';\\n                    if (i == n - 1) {\\n                        if (max[i][j + 1] != -1) {\\n                            max[i][j] = Math.max(max[i][j], max[i][j + 1] + tmp);\\n                            nums[i][j] = (nums[i][j] + nums[i][j + 1]) % mod;\\n                        }\\n                        continue;\\n                    }\\n                    if (j == m - 1) {\\n                        if (max[i + 1][j] != -1) {\\n                            max[i][j] = Math.max(max[i][j], max[i + 1][j] + tmp);\\n                            nums[i][j] = (nums[i][j] + nums[i + 1][j]) % mod;\\n                        }\\n                        continue;\\n                    }\\n                    if (max[i][j + 1] != -1) {\\n                        max[i][j] = Math.max(max[i][j], max[i][j + 1] + tmp);\\n                    }\\n                    if (max[i + 1][j] != -1) {\\n                        max[i][j] = Math.max(max[i][j], max[i + 1][j] + tmp);\\n                    }\\n                    if (max[i + 1][j + 1] != -1) {\\n                        max[i][j] = Math.max(max[i][j], max[i + 1][j + 1] + tmp);\\n                    }\\n                    if (max[i][j + 1] != -1 && max[i][j] == max[i][j + 1] + tmp) {\\n                        nums[i][j] = (nums[i][j] + nums[i][j + 1]) % mod;\\n                    }\\n                    if (max[i + 1][j] != -1 && max[i][j] == max[i + 1][j] + tmp) {\\n                        nums[i][j] = (nums[i + 1][j] + nums[i][j]) % mod;\\n                    }\\n                    if (max[i + 1][j + 1] != -1 && max[i][j] == max[i + 1][j + 1] + tmp) {\\n                        nums[i][j] = (nums[i + 1][j + 1] + nums[i][j]) % mod;\\n                    }\\n                }\\n            }\\n        }\\n        int[] res = new int[2];\\n        if (max[0][0] == -1) {\\n            return res;\\n        }\\n        res[0] = max[0][0];\\n        res[1] = (int)nums[0][0];\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 475589,
                "title": "c-dp-with-explaination",
                "content": "\\tvector<int> pathsWithMaxScore(vector<string>& board) {\\n        /* dp[i][j] = maximum sum get when reaching at (i, j)\\n         * dp[i][j] = max{dp[i+1][j], dp[i][j+1], dp[i+1][j+1]} + board[i][j];\\n         * dp[M][j] = dp[M][j+1] + board[M][j];\\n         * dp[i][N] = dp[i+1][N] + board[i][N];\\n         * board size = M x N.\\n         */\\n        int bigM = 1e9 + 7;\\n        \\n        int M = board.size(), N = (M == 0) ? (0) : (board[0].size());\\n        if ((M == 0) || (N == 0)){return vector<int>({0, 0});}\\n        \\n        vector<vector<int>> dp(M + 1, vector<int>(N + 1, 0));\\n        vector<vector<int>> np(M + 1, vector<int>(N + 1, 0));\\n        \\n\\t\\t/* initialize DP\\'s value (bottom row & most right column)*/\\n        np[M-1][N-1] = 1; dp[M-1][N-1] = 0;\\n        for (int j = N-2; j >= 0; --j){\\n            dp[M-1][j] = (board[M-1][j] == \\'X\\') ? (-1) : ((dp[M-1][j+1] == (-1)) ? (-1) : (dp[M-1][j+1] + (board[M-1][j] - \\'0\\')));\\n            np[M-1][j] = (dp[M-1][j] == (-1)) ? (0) : (1);\\n        }\\n\\n        for (int i = M-2; i >= 0; --i){\\n            dp[i][N-1] = (board[i][N-1] == \\'X\\') ? (-1) : ((dp[i+1][N-1] == (-1)) ? (-1) : (dp[i+1][N-1] + (board[i][N-1] - \\'0\\')));\\n            np[i][N-1] = (np[i][N-1] == (-1)) ? (0) : (1);\\n        }\\n        \\n\\t\\t/* update DP, row from bootom --> up, column from right --> left */\\n        for (int i = M - 2; i >= 0; --i){\\n            for (int j = N - 2; j >= 0; --j){\\n\\t\\t\\t\\t/* current cell is \\'X\\' */\\n                if (board[i][j] == \\'X\\'){\\n                    dp[i][j] = (-1);\\n                    np[i][j] = ( 0);\\n                    continue;\\n                }\\n                \\n                int maxs = (-1);\\n                maxs = max(maxs, dp[i+1][j+1]);\\n                maxs = max(maxs, dp[i+1][j+0]);\\n                maxs = max(maxs, dp[i+0][j+1]);\\n                \\n\\t\\t\\t\\t/* no path from any of 3 precedent cells */\\n                if (maxs == (-1)){\\n                    dp[i][j] = (-1);\\n                    np[i][j] = ( 0);\\n                    continue;\\n                }\\n                \\n\\t\\t\\t\\t/* collect # of paths */\\n                int64_t nps = 0;\\n                if (maxs == dp[i+1][j+1]){\\n                    nps += np[i+1][j+1];\\n                }\\n                if (maxs == dp[i+1][j+0]){\\n                    nps += np[i+1][j+0];\\n                }\\n                if (maxs == dp[i+0][j+1]){\\n                    nps += np[i+0][j+1];\\n                }\\n                \\n                dp[i][j] = maxs + (((i | j) == 0) ? (0) : (board[i][j] - \\'0\\'));\\n                np[i][j] = (nps % bigM); \\n            }\\n        }\\n        \\n        dp[0][0] = (dp[0][0] == (-1)) ? (0) : (dp[0][0]);\\n        return vector<int>({dp[0][0], np[0][0]});\\n    }",
                "solutionTags": [],
                "code": "\\tvector<int> pathsWithMaxScore(vector<string>& board) {\\n        /* dp[i][j] = maximum sum get when reaching at (i, j)\\n         * dp[i][j] = max{dp[i+1][j], dp[i][j+1], dp[i+1][j+1]} + board[i][j];\\n         * dp[M][j] = dp[M][j+1] + board[M][j];\\n         * dp[i][N] = dp[i+1][N] + board[i][N];\\n         * board size = M x N.\\n         */\\n        int bigM = 1e9 + 7;\\n        \\n        int M = board.size(), N = (M == 0) ? (0) : (board[0].size());\\n        if ((M == 0) || (N == 0)){return vector<int>({0, 0});}\\n        \\n        vector<vector<int>> dp(M + 1, vector<int>(N + 1, 0));\\n        vector<vector<int>> np(M + 1, vector<int>(N + 1, 0));\\n        \\n\\t\\t/* initialize DP\\'s value (bottom row & most right column)*/\\n        np[M-1][N-1] = 1; dp[M-1][N-1] = 0;\\n        for (int j = N-2; j >= 0; --j){\\n            dp[M-1][j] = (board[M-1][j] == \\'X\\') ? (-1) : ((dp[M-1][j+1] == (-1)) ? (-1) : (dp[M-1][j+1] + (board[M-1][j] - \\'0\\')));\\n            np[M-1][j] = (dp[M-1][j] == (-1)) ? (0) : (1);\\n        }\\n\\n        for (int i = M-2; i >= 0; --i){\\n            dp[i][N-1] = (board[i][N-1] == \\'X\\') ? (-1) : ((dp[i+1][N-1] == (-1)) ? (-1) : (dp[i+1][N-1] + (board[i][N-1] - \\'0\\')));\\n            np[i][N-1] = (np[i][N-1] == (-1)) ? (0) : (1);\\n        }\\n        \\n\\t\\t/* update DP, row from bootom --> up, column from right --> left */\\n        for (int i = M - 2; i >= 0; --i){\\n            for (int j = N - 2; j >= 0; --j){\\n\\t\\t\\t\\t/* current cell is \\'X\\' */\\n                if (board[i][j] == \\'X\\'){\\n                    dp[i][j] = (-1);\\n                    np[i][j] = ( 0);\\n                    continue;\\n                }\\n                \\n                int maxs = (-1);\\n                maxs = max(maxs, dp[i+1][j+1]);\\n                maxs = max(maxs, dp[i+1][j+0]);\\n                maxs = max(maxs, dp[i+0][j+1]);\\n                \\n\\t\\t\\t\\t/* no path from any of 3 precedent cells */\\n                if (maxs == (-1)){\\n                    dp[i][j] = (-1);\\n                    np[i][j] = ( 0);\\n                    continue;\\n                }\\n                \\n\\t\\t\\t\\t/* collect # of paths */\\n                int64_t nps = 0;\\n                if (maxs == dp[i+1][j+1]){\\n                    nps += np[i+1][j+1];\\n                }\\n                if (maxs == dp[i+1][j+0]){\\n                    nps += np[i+1][j+0];\\n                }\\n                if (maxs == dp[i+0][j+1]){\\n                    nps += np[i+0][j+1];\\n                }\\n                \\n                dp[i][j] = maxs + (((i | j) == 0) ? (0) : (board[i][j] - \\'0\\'));\\n                np[i][j] = (nps % bigM); \\n            }\\n        }\\n        \\n        dp[0][0] = (dp[0][0] == (-1)) ? (0) : (dp[0][0]);\\n        return vector<int>({dp[0][0], np[0][0]});\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 467057,
                "title": "python-dp",
                "content": "```python\\nclass Solution(object):\\n    def pathsWithMaxScore(self, board):\\n        \"\"\"\\n        :type board: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        h = len(board)\\n        w = len(board[0])\\n        \\n        mod = 10 ** 9 + 7\\n        \\n        stable =[[0 for _ in range(w)] for _ in range(h)] # sum table\\n        ptable =[[0 for _ in range(w)] for _ in range(h)] # path count table\\n        \\n        for i in range(h - 1, -1, -1):\\n            for j in range(w - 1, -1, -1):\\n                if i == h - 1 and j == w - 1: # init the [h - 1, w - 1] cell\\n                    ptable[i][j] = 1\\n                    stable[i][j] = 0\\n                    continue\\n                if i == h - 1: # init the last row\\n                    if board[i][j] == \\'X\\' or ptable[i][j + 1] == 0:\\n                        ptable[i][j] = 0\\n                        stable[i][j] = 0\\n                    else:\\n                        ptable[i][j] = ptable[i][j + 1]\\n                        stable[i][j] = stable[i][j + 1] + int(board[i][j])\\n                    continue\\n                if j == w - 1: # init the last column\\n                    if board[i][j] == \\'X\\' or ptable[i + 1][j] == 0:\\n                        ptable[i][j] = 0\\n                        stable[i][j] = 0\\n                    else:\\n                        ptable[i][j] = ptable[i + 1][j]\\n                        stable[i][j] = stable[i + 1][j] + int(board[i][j])\\n                    continue\\n                   \\n\\t\\t\\t\\t# cells not available\\n                if board[i][j] == \\'X\\' or (ptable[i + 1][j] == 0 and ptable[i][j + 1] == 0 and ptable[i + 1][j + 1] == 0):\\n                    ptable[i][j] = 0\\n                    stable[i][j] = 0\\n                    continue\\n                \\n                imax_sum = 0\\n                ipath = 0\\n\\t\\t\\t\\t# get current max sum and path number\\n                for s, p in [[stable[i + 1][j], ptable[i + 1][j]],[stable[i][j + 1], ptable[i][j + 1]],[stable[i + 1][j + 1], ptable[i + 1][j + 1]]]:\\n\\t\\t\\t\\t\\t#if p == 0: # if  `0` is contained in the square\\n\\t\\t\\t\\t\\t#\\tcontinue\\n                    if s < imax_sum:\\n                        continue\\n                    if s == imax_sum:\\n                        ipath += p\\n                        continue\\n                    imax_sum = s\\n                    ipath = p\\n                if i == 0 and j == 0:\\n                    stable[i][j] = imax_sum % mod\\n                else:\\n                    stable[i][j] = (imax_sum + int(board[i][j])) % mod\\n                ptable[i][j] = ipath % mod\\n\\n        return [stable[0][0], ptable[0][0]]\\n                \\n                \\n                \\n\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def pathsWithMaxScore(self, board):\\n        \"\"\"\\n        :type board: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        h = len(board)\\n        w = len(board[0])\\n        \\n        mod = 10 ** 9 + 7\\n        \\n        stable =[[0 for _ in range(w)] for _ in range(h)] # sum table\\n        ptable =[[0 for _ in range(w)] for _ in range(h)] # path count table\\n        \\n        for i in range(h - 1, -1, -1):\\n            for j in range(w - 1, -1, -1):\\n                if i == h - 1 and j == w - 1: # init the [h - 1, w - 1] cell\\n                    ptable[i][j] = 1\\n                    stable[i][j] = 0\\n                    continue\\n                if i == h - 1: # init the last row\\n                    if board[i][j] == \\'X\\' or ptable[i][j + 1] == 0:\\n                        ptable[i][j] = 0\\n                        stable[i][j] = 0\\n                    else:\\n                        ptable[i][j] = ptable[i][j + 1]\\n                        stable[i][j] = stable[i][j + 1] + int(board[i][j])\\n                    continue\\n                if j == w - 1: # init the last column\\n                    if board[i][j] == \\'X\\' or ptable[i + 1][j] == 0:\\n                        ptable[i][j] = 0\\n                        stable[i][j] = 0\\n                    else:\\n                        ptable[i][j] = ptable[i + 1][j]\\n                        stable[i][j] = stable[i + 1][j] + int(board[i][j])\\n                    continue\\n                   \\n\\t\\t\\t\\t# cells not available\\n                if board[i][j] == \\'X\\' or (ptable[i + 1][j] == 0 and ptable[i][j + 1] == 0 and ptable[i + 1][j + 1] == 0):\\n                    ptable[i][j] = 0\\n                    stable[i][j] = 0\\n                    continue\\n                \\n                imax_sum = 0\\n                ipath = 0\\n\\t\\t\\t\\t# get current max sum and path number\\n                for s, p in [[stable[i + 1][j], ptable[i + 1][j]],[stable[i][j + 1], ptable[i][j + 1]],[stable[i + 1][j + 1], ptable[i + 1][j + 1]]]:\\n\\t\\t\\t\\t\\t#if p == 0: # if  `0` is contained in the square\\n\\t\\t\\t\\t\\t#\\tcontinue\\n                    if s < imax_sum:\\n                        continue\\n                    if s == imax_sum:\\n                        ipath += p\\n                        continue\\n                    imax_sum = s\\n                    ipath = p\\n                if i == 0 and j == 0:\\n                    stable[i][j] = imax_sum % mod\\n                else:\\n                    stable[i][j] = (imax_sum + int(board[i][j])) % mod\\n                ptable[i][j] = ipath % mod\\n\\n        return [stable[0][0], ptable[0][0]]\\n                \\n                \\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 465498,
                "title": "c-two-dp-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> pathsWithMaxScore(vector<string>& board) {\\n\\t\\t\\tint tomod=(1e9+7);\\n\\t\\t\\tint n=board.size();\\n\\t\\t\\tvector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n\\t\\t\\tvector<vector<int>> path(n+1,vector<int>(n+1,0));\\n\\t\\t\\tpath[n-1][n-1]=1;\\n\\t\\t\\tboard[0][0]=\\'0\\';\\n\\t\\t\\tboard[n-1][n-1]=\\'0\\';\\n\\t\\t\\tint cur;\\n\\t\\t\\tfor(int i=n-1;i>=0;i--)\\n\\t\\t\\t\\tfor(int j=n-1;j>=0;j--){\\n\\t\\t\\t\\t\\tif(board[i][j]!=\\'X\\'){\\n\\t\\t\\t\\t\\t\\tcur=max(max(dp[i+1][j],dp[i][j+1]),dp[i+1][j+1]);\\n\\t\\t\\t\\t\\t\\t//cout<<cur<<endl;\\n\\t\\t\\t\\t\\t\\tdp[i][j]=cur+(board[i][j]-\\'0\\');\\n\\t\\t\\t\\t\\tif(dp[i+1][j]==cur){\\n\\t\\t\\t\\t\\t\\t//cout<<path[i][j]<<endl;\\n\\t\\t\\t\\t\\t\\tpath[i][j]=(path[i][j]+path[i+1][j])%tomod;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(dp[i][j+1]==cur){\\n\\t\\t\\t\\t\\t\\t//cout<<path[i][j]<<endl;\\n\\t\\t\\t\\t\\t\\tpath[i][j]=(path[i][j]+path[i][j+1])%tomod;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(dp[i+1][j+1]==cur){\\n\\t\\t\\t\\t\\t\\t//cout<<path[i][j]<<endl;\\n\\t\\t\\t\\t\\t\\tpath[i][j]=(path[i][j]+path[i+1][j+1])%tomod;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\treturn {path[0][0] ? dp[0][0]:0 , path[0][0]};\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> pathsWithMaxScore(vector<string>& board) {\\n\\t\\t\\tint tomod=(1e9+7);\\n\\t\\t\\tint n=board.size();\\n\\t\\t\\tvector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n\\t\\t\\tvector<vector<int>> path(n+1,vector<int>(n+1,0));\\n\\t\\t\\tpath[n-1][n-1]=1;\\n\\t\\t\\tboard[0][0]=\\'0\\';\\n\\t\\t\\tboard[n-1][n-1]=\\'0\\';\\n\\t\\t\\tint cur;\\n\\t\\t\\tfor(int i=n-1;i>=0;i--)\\n\\t\\t\\t\\tfor(int j=n-1;j>=0;j--){\\n\\t\\t\\t\\t\\tif(board[i][j]!=\\'X\\'){\\n\\t\\t\\t\\t\\t\\tcur=max(max(dp[i+1][j],dp[i][j+1]),dp[i+1][j+1]);\\n\\t\\t\\t\\t\\t\\t//cout<<cur<<endl;\\n\\t\\t\\t\\t\\t\\tdp[i][j]=cur+(board[i][j]-\\'0\\');\\n\\t\\t\\t\\t\\tif(dp[i+1][j]==cur){\\n\\t\\t\\t\\t\\t\\t//cout<<path[i][j]<<endl;\\n\\t\\t\\t\\t\\t\\tpath[i][j]=(path[i][j]+path[i+1][j])%tomod;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "C++"
            },
            {
                "id": 464463,
                "title": "java-dp-beats-100",
                "content": "```\\nclass Solution {\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int m = board.size();\\n        int n = board.get(0).length();\\n        long[][] countDP = new long[m+1][n+1];\\n        long[][] sumDP = new long[m+1][n+1];\\n        int mod = 1000000007;\\n        countDP[m][n] = 1;\\n        for(int i = m-1; i >= 0; i--) {\\n            for(int j = n-1; j>=0; j--) {\\n                if (board.get(i).charAt(j) != \\'X\\') {\\n                    long max = Math.max(sumDP[i][j+1],Math.max(sumDP[i+1][j],sumDP[i+1][j+1]));\\n                    sumDP[i][j] = getValue(i,j,board) + max;\\n                    countDP[i][j]  = sumDP[i][j+1]   == max ? countDP[i][j+1]   : 0;\\n                    countDP[i][j]  = (countDP[i][j] + (sumDP[i+1][j]   == max ? countDP[i+1][j]   : 0))%mod;\\n                    countDP[i][j] =  (countDP[i][j] + (sumDP[i+1][j+1] == max ? countDP[i+1][j+1] : 0))%mod;\\n                }\\n            }\\n        }\\n\\n        int maxSum = (int)sumDP[0][0];\\n        int maxPathCount = (int)countDP[0][0];\\n        return new int[]{maxPathCount!=0?maxSum:0,maxPathCount};\\n    }\\n    private long getValue(int x, int y, List<String> board) {\\n        char c = board.get(x).charAt(y);\\n        if (c >= \\'1\\' && c <= \\'9\\') return c-\\'1\\'+1L;\\n        else return 0L;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int m = board.size();\\n        int n = board.get(0).length();\\n        long[][] countDP = new long[m+1][n+1];\\n        long[][] sumDP = new long[m+1][n+1];\\n        int mod = 1000000007;\\n        countDP[m][n] = 1;\\n        for(int i = m-1; i >= 0; i--) {\\n            for(int j = n-1; j>=0; j--) {\\n                if (board.get(i).charAt(j) != \\'X\\') {\\n                    long max = Math.max(sumDP[i][j+1],Math.max(sumDP[i+1][j],sumDP[i+1][j+1]));\\n                    sumDP[i][j] = getValue(i,j,board) + max;\\n                    countDP[i][j]  = sumDP[i][j+1]   == max ? countDP[i][j+1]   : 0;\\n                    countDP[i][j]  = (countDP[i][j] + (sumDP[i+1][j]   == max ? countDP[i+1][j]   : 0))%mod;\\n                    countDP[i][j] =  (countDP[i][j] + (sumDP[i+1][j+1] == max ? countDP[i+1][j+1] : 0))%mod;\\n                }\\n            }\\n        }\\n\\n        int maxSum = (int)sumDP[0][0];\\n        int maxPathCount = (int)countDP[0][0];\\n        return new int[]{maxPathCount!=0?maxSum:0,maxPathCount};\\n    }\\n    private long getValue(int x, int y, List<String> board) {\\n        char c = board.get(x).charAt(y);\\n        if (c >= \\'1\\' && c <= \\'9\\') return c-\\'1\\'+1L;\\n        else return 0L;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463997,
                "title": "python-dp-and-dfs-solution",
                "content": "DFS with memoization\\n```\\ndef pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        n=len(board)\\n        cache={}\\n        cache[(0,0)]=(0,1)\\n        def dfs(i,j):\\n            if (i,j) in cache:\\n                return cache[(i,j)]\\n\\t\\t\\t\\n\\t\\t\\t\\'use -1 to determine whether this state is connected to the 0,0,\\'\\n\\t\\t\\t\\'a means max score from its neighbor, b means corresponding ways to achive that score\\'\\n\\t\\t\\t\\n            a,b=-1,0\\n            for x,y in ((i-1,j-1),(i-1,j),(i,j-1)):\\n                if 0<=x<n and 0<=y<n and board[x][y]!=\\'X\\':\\n                    k=dfs(x,y)\\n                    if k[0]==a:\\n                        b+=k[1]\\n                    elif k[0]>a:\\n                        a=k[0]\\n                        b=k[1]\\n            res=(-1,0)\\n            if a>-1:\\n\\t\\t\\t   \\'\\'\\'avoid calculate last state score which is a str\\'\\'\\'\\n                if (i,j)!=(n-1,n-1):\\n                    res= (a+int(board[i][j]),b)\\n                else:\\n                    res=(a,b)\\n           \\n            cache[(i,j)]=res\\n            return res\\n        res=dfs(n-1,n-1)\\n        \\n        if res[0]==-1:\\n            return [0,0]\\n        else:\\n            return [res[0]%(10**9+7),res[1]%(10**9+7)]\\n    \\n```\\n\\n\\t\\nDP \\nsame idea as dfs\\n\\t\\n```\\t\\n\\tdef pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        n=len(board)\\n       \\n        dp = [[[0, 0] for j in range(n )] for i in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                if i==0 and j==0:\\n                    dp[i][j]=[0,1]\\n                    continue\\n                if board[i][j] ==\\'X\\':\\n                    dp[i][j]=[-1,0]\\n                    continue\\n                a,b=-1,0\\n                for x,y in ((i-1,j),(i,j-1),(i-1,j-1)):\\n                    if 0<=x<n and 0<=y<n:\\n                        if dp[x][y][0]==a:\\n                            b+=dp[x][y][1]\\n                        elif dp[x][y][0]>a:\\n                            a=dp[x][y][0]\\n                            b=dp[x][y][1]\\n                if a==-1:\\n                    dp[i][j]=[-1,0]\\n                else:\\n                    if (i,j)!=(n-1,n-1):\\n                        dp[i][j]=[a+int(board[i][j]),b]\\n                    else:\\n                        dp[i][j]=[a,b]\\n        if dp[-1][-1][0]==-1:\\n            res=[0,0]\\n        else:\\n            res=[dp[-1][-1][0]%(10**9+7),dp[-1][-1][1]%(10**9+7)]\\n        return res\\n                    \\n",
                "solutionTags": [],
                "code": "```\\ndef pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        n=len(board)\\n        cache={}\\n        cache[(0,0)]=(0,1)\\n        def dfs(i,j):\\n            if (i,j) in cache:\\n                return cache[(i,j)]\\n\\t\\t\\t\\n\\t\\t\\t\\'use -1 to determine whether this state is connected to the 0,0,\\'\\n\\t\\t\\t\\'a means max score from its neighbor, b means corresponding ways to achive that score\\'\\n\\t\\t\\t\\n            a,b=-1,0\\n            for x,y in ((i-1,j-1),(i-1,j),(i,j-1)):\\n                if 0<=x<n and 0<=y<n and board[x][y]!=\\'X\\':\\n                    k=dfs(x,y)\\n                    if k[0]==a:\\n                        b+=k[1]\\n                    elif k[0]>a:\\n                        a=k[0]\\n                        b=k[1]\\n            res=(-1,0)\\n            if a>-1:\\n\\t\\t\\t   \\'\\'\\'avoid calculate last state score which is a str\\'\\'\\'\\n                if (i,j)!=(n-1,n-1):\\n                    res= (a+int(board[i][j]),b)\\n                else:\\n                    res=(a,b)\\n           \\n            cache[(i,j)]=res\\n            return res\\n        res=dfs(n-1,n-1)\\n        \\n        if res[0]==-1:\\n            return [0,0]\\n        else:\\n            return [res[0]%(10**9+7),res[1]%(10**9+7)]\\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 463670,
                "title": "java-dp-follow-the-hint-long-tedious-but-easy-to-understand",
                "content": "```\\nclass Solution {\\n    final int mod=1000000007;\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        char grid[][]=new char[board.size()][board.get(0).length()];\\n        for(int r=0;r<grid.length;r++){\\n            for(int c=0;c<grid[0].length;c++){\\n                grid[r][c]=board.get(r).charAt(c);\\n            }\\n        }\\n        \\n        int score[][]=new int[grid.length][grid[0].length];\\n        int path[][]=new int[grid.length][grid[0].length];\\n        path[path.length-1][path[0].length-1]=1;\\n        for(int row=grid.length-1;row>=0;row--){\\n            for(int col=grid[0].length-1;col>=0;col--){\\n                if(row==grid.length-1&&col==grid[0].length-1){\\n                    continue;\\n                }\\n                if(grid[row][col]==\\'X\\'){\\n                    score[row][col]=Integer.MIN_VALUE;\\n                    continue;\\n                }\\n                 if(grid[row][col]==\\'E\\'){\\n                    if(check(grid,row+1,col+1)){\\n                        score[0][0]=Math.max(score[0][0],score[1][1])%mod;\\n                        \\n                    }\\n                    if(check(grid,row+1,col)){\\n                        score[0][0]=Math.max(score[0][0],score[1][0])%mod;\\n                        \\n                    }\\n                    if(check(grid,row,col+1)){\\n                        score[0][0]=Math.max(score[0][0],score[0][1])%mod;\\n                       \\n                    }\\n                    //path\\n                     int counter=0;\\n                   if(check(grid,row+1,col+1)){\\n                        if(score[0][0]==score[row+1][col+1]){\\n                            counter+=path[row+1][col+1];\\n                        }\\n                    }\\n                    if(check(grid,row+1,col)){\\n                       if(score[0][0]==score[1][0]){\\n                           counter+=path[1][0];\\n                       }\\n                    }\\n                    if(check(grid,row,col+1)){\\n                        if(score[0][0]==score[0][1]){\\n                            counter+=path[0][1];\\n                        }\\n                    }\\n                    path[0][0]=counter%mod;\\n                    continue;\\n                }\\n                \\n                int max=Integer.MIN_VALUE;\\n                int counter=0;\\n                if(check(grid,row+1,col+1)){\\n                    if(grid[row+1][col+1]!=\\'X\\'&&score[row+1][col+1]!=Integer.MIN_VALUE){\\n                        max=Math.max(max,Integer.parseInt(grid[row][col]+\"\")+score[row+1][col+1]);\\n                    }\\n                }\\n                if(check(grid,row+1,col)){\\n                    if(grid[row+1][col]!=\\'X\\'&&score[row+1][col]!=Integer.MIN_VALUE){\\n                         max=Math.max(max,Integer.parseInt(grid[row][col]+\"\")+score[row+1][col]);\\n                    }\\n                }\\n                if(check(grid,row,col+1)&&score[row][col+1]!=Integer.MIN_VALUE){\\n                    if(grid[row][col+1]!=\\'X\\'){\\n                        max=Math.max(max,Integer.parseInt(grid[row][col]+\"\")+score[row][col+1]);\\n                    }\\n                }\\n                //for path\\n                if(check(grid,row+1,col+1)){\\n                    if(grid[row+1][col+1]!=\\'X\\'&&score[row+1][col+1]!=Integer.MIN_VALUE){\\n                        if(Integer.parseInt(grid[row][col]+\"\")+score[row+1][col+1]==max){\\n                            //System.out.println(1);\\n                            counter+=path[row+1][col+1];\\n                        }\\n                    }\\n                }\\n                if(check(grid,row+1,col)){\\n                    if(grid[row+1][col]!=\\'X\\'&&score[row+1][col]!=Integer.MIN_VALUE){\\n                         if(Integer.parseInt(grid[row][col]+\"\")+score[row+1][col]==max){\\n                             //System.out.println(2);\\n                            counter+=path[row+1][col];\\n                        }\\n                    }\\n                }\\n                if(check(grid,row,col+1)){\\n                    if(grid[row][col+1]!=\\'X\\'&&score[row][col+1]!=Integer.MIN_VALUE){\\n                         if(Integer.parseInt(grid[row][col]+\"\")+score[row][col+1]==max){\\n                            // System.out.println(3);\\n                            counter+=path[row][col+1];\\n                        }\\n                    }\\n                }\\n                path[row][col]=counter%mod;\\n                score[row][col]=max%mod;\\n            }\\n        }\\n        //print(score);\\n        //print(path);\\n        int ans[]=new int[2];\\n        if(score[0][0]!=Integer.MIN_VALUE){\\n            ans[0]=score[0][0]%mod;\\n            ans[1]=path[0][0]%mod;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public boolean check(char grid[][],int row,int col){\\n        if(row<0||row>=grid.length||col<0||col>=grid[0].length){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    final int mod=1000000007;\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        char grid[][]=new char[board.size()][board.get(0).length()];\\n        for(int r=0;r<grid.length;r++){\\n            for(int c=0;c<grid[0].length;c++){\\n                grid[r][c]=board.get(r).charAt(c);\\n            }\\n        }\\n        \\n        int score[][]=new int[grid.length][grid[0].length];\\n        int path[][]=new int[grid.length][grid[0].length];\\n        path[path.length-1][path[0].length-1]=1;\\n        for(int row=grid.length-1;row>=0;row--){\\n            for(int col=grid[0].length-1;col>=0;col--){\\n                if(row==grid.length-1&&col==grid[0].length-1){\\n                    continue;\\n                }\\n                if(grid[row][col]==\\'X\\'){\\n                    score[row][col]=Integer.MIN_VALUE;\\n                    continue;\\n                }\\n                 if(grid[row][col]==\\'E\\'){\\n                    if(check(grid,row+1,col+1)){\\n                        score[0][0]=Math.max(score[0][0],score[1][1])%mod;\\n                        \\n                    }\\n                    if(check(grid,row+1,col)){\\n                        score[0][0]=Math.max(score[0][0],score[1][0])%mod;\\n                        \\n                    }\\n                    if(check(grid,row,col+1)){\\n                        score[0][0]=Math.max(score[0][0],score[0][1])%mod;\\n                       \\n                    }\\n                    //path\\n                     int counter=0;\\n                   if(check(grid,row+1,col+1)){\\n                        if(score[0][0]==score[row+1][col+1]){\\n                            counter+=path[row+1][col+1];\\n                        }\\n                    }\\n                    if(check(grid,row+1,col)){\\n                       if(score[0][0]==score[1][0]){\\n                           counter+=path[1][0];\\n                       }\\n                    }\\n                    if(check(grid,row,col+1)){\\n                        if(score[0][0]==score[0][1]){\\n                            counter+=path[0][1];\\n                        }\\n                    }\\n                    path[0][0]=counter%mod;\\n                    continue;\\n                }\\n                \\n                int max=Integer.MIN_VALUE;\\n                int counter=0;\\n                if(check(grid,row+1,col+1)){\\n                    if(grid[row+1][col+1]!=\\'X\\'&&score[row+1][col+1]!=Integer.MIN_VALUE){\\n                        max=Math.max(max,Integer.parseInt(grid[row][col]+\"\")+score[row+1][col+1]);\\n                    }\\n                }\\n                if(check(grid,row+1,col)){\\n                    if(grid[row+1][col]!=\\'X\\'&&score[row+1][col]!=Integer.MIN_VALUE){\\n                         max=Math.max(max,Integer.parseInt(grid[row][col]+\"\")+score[row+1][col]);\\n                    }\\n                }\\n                if(check(grid,row,col+1)&&score[row][col+1]!=Integer.MIN_VALUE){\\n                    if(grid[row][col+1]!=\\'X\\'){\\n                        max=Math.max(max,Integer.parseInt(grid[row][col]+\"\")+score[row][col+1]);\\n                    }\\n                }\\n                //for path\\n                if(check(grid,row+1,col+1)){\\n                    if(grid[row+1][col+1]!=\\'X\\'&&score[row+1][col+1]!=Integer.MIN_VALUE){\\n                        if(Integer.parseInt(grid[row][col]+\"\")+score[row+1][col+1]==max){\\n                            //System.out.println(1);\\n                            counter+=path[row+1][col+1];\\n                        }\\n                    }\\n                }\\n                if(check(grid,row+1,col)){\\n                    if(grid[row+1][col]!=\\'X\\'&&score[row+1][col]!=Integer.MIN_VALUE){\\n                         if(Integer.parseInt(grid[row][col]+\"\")+score[row+1][col]==max){\\n                             //System.out.println(2);\\n                            counter+=path[row+1][col];\\n                        }\\n                    }\\n                }\\n                if(check(grid,row,col+1)){\\n                    if(grid[row][col+1]!=\\'X\\'&&score[row][col+1]!=Integer.MIN_VALUE){\\n                         if(Integer.parseInt(grid[row][col]+\"\")+score[row][col+1]==max){\\n                            // System.out.println(3);\\n                            counter+=path[row][col+1];\\n                        }\\n                    }\\n                }\\n                path[row][col]=counter%mod;\\n                score[row][col]=max%mod;\\n            }\\n        }\\n        //print(score);\\n        //print(path);\\n        int ans[]=new int[2];\\n        if(score[0][0]!=Integer.MIN_VALUE){\\n            ans[0]=score[0][0]%mod;\\n            ans[1]=path[0][0]%mod;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public boolean check(char grid[][],int row,int col){\\n        if(row<0||row>=grid.length||col<0||col>=grid[0].length){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463581,
                "title": "python3-bottom-up-dp",
                "content": "Algorithm:\\nKeep track of score-count pair at each node and update values at `i, j` from its neighbors at `i+1, j`, `i, j+1`, `i+1, j+1`. \\n\\nImplementation (136ms, 100%): \\n```\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        \"\"\"bottom-up dp\"\"\"\\n        n = len(board) #dimension\\n\\n        #count > 0 also indicates state is reachable\\n        dp = [[0, 0] for _ in range(n+1)] #score-count (augment by 1 for convenience)\\n        \\n        for i in reversed(range(n)):\\n            #not assuming reachability while updating state\\n            copy = [[0, 0] for _ in range(n+1)] #to be updated to new dp\\n            for j in reversed(range(n)): \\n                if board[i][j] == \"X\": continue #skip obstacle\\n                if board[i][j] == \"S\": #initialize \"S\"\\n                    copy[j] = [0, 1]\\n                    continue \\n                #find max score from neighbors\\n                for candidate in (copy[j+1], dp[j], dp[j+1]): #right/below/right-below\\n                    if not candidate[1]: continue #not reachable\\n                    if copy[j][0] < candidate[0]: copy[j] = candidate[:]\\n                    elif copy[j][0] == candidate[0]: copy[j][1] = (copy[j][1] + candidate[1])%(10**9+7)\\n                #update with board number \\n                if board[i][j] != \"E\": copy[j][0] += int(board[i][j])\\n            dp = copy\\n        return dp[0]\\n```\\nAnalysis:\\nTime complexity `O(N^2)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        \"\"\"bottom-up dp\"\"\"\\n        n = len(board) #dimension\\n\\n        #count > 0 also indicates state is reachable\\n        dp = [[0, 0] for _ in range(n+1)] #score-count (augment by 1 for convenience)\\n        \\n        for i in reversed(range(n)):\\n            #not assuming reachability while updating state\\n            copy = [[0, 0] for _ in range(n+1)] #to be updated to new dp\\n            for j in reversed(range(n)): \\n                if board[i][j] == \"X\": continue #skip obstacle\\n                if board[i][j] == \"S\": #initialize \"S\"\\n                    copy[j] = [0, 1]\\n                    continue \\n                #find max score from neighbors\\n                for candidate in (copy[j+1], dp[j], dp[j+1]): #right/below/right-below\\n                    if not candidate[1]: continue #not reachable\\n                    if copy[j][0] < candidate[0]: copy[j] = candidate[:]\\n                    elif copy[j][0] == candidate[0]: copy[j][1] = (copy[j][1] + candidate[1])%(10**9+7)\\n                #update with board number \\n                if board[i][j] != \"E\": copy[j][0] += int(board[i][j])\\n            dp = copy\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463379,
                "title": "python3-dp-with-clear-code",
                "content": "dp[i][j][0] means the maximum score ending at grid[i][j], and dp[i][j][1] means the number of paths ending at grid[i][j] with scores equal to dp[i][j][0]\\n```python\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        M = 10**9 + 7\\n        n = len(board)\\n        dp = [[[0, 0] for _ in range(n)] for _ in range(n)]\\n        dp[-1][-1] = [0, 1]\\n        \\n        for i in range(n - 1, -1 , -1):\\n            for j in range(n - 1, -1, -1):\\n                if dp[i][j][1] == 0: # if we don\\'t have avalible path at this stage, no need for next step\\n                    continue\\n                \\n                if i > 0 and board[i - 1][j] != \\'X\\': \\n                    cur = dp[i][j][0] \\n                    if board[i - 1][j] != \\'E\\':  #if path doesn\\'t end, keep adding next value to cur\\n                        cur += int(board[i - 1][j]) \\n                        \\n                    if cur > dp[i - 1][j][0]: # if new path score is bigger than previous one, we update it with new maximum score and path number inherited from last step\\n                        dp[i - 1][j] = [cur, dp[i][j][1]]\\n                    elif cur == dp[i - 1][j][0]: #if new path score equlas to previous one, adding new path number to previous path number\\n                        dp[i - 1][j][1] += dp[i][j][1] \\n                \\n                if j > 0 and board[i][j - 1] != \\'X\\': \\n                    cur = dp[i][j][0] \\n                    if board[i][j - 1] != \\'E\\': \\n                        cur += int(board[i][j - 1])\\n                        \\n                    if cur > dp[i][j - 1][0]: \\n                        dp[i][j - 1] = [cur, dp[i][j][1]]\\n                    elif cur == dp[i][j - 1][0]: \\n                        dp[i][j - 1][1] += dp[i][j][1] \\n                \\n                if i > 0 and j > 0 and board[i - 1][j - 1] != \\'X\\': \\n                    cur = dp[i][j][0] \\n                    if board[i - 1][j - 1] != \\'E\\':\\n                        cur += int(board[i - 1][j - 1])\\n                        \\n                    if cur > dp[i - 1][j - 1][0]: \\n                        dp[i - 1][j - 1] = [cur, dp[i][j][1]]\\n                    elif cur == dp[i - 1][j - 1][0]: \\n                        dp[i - 1][j - 1][1] += dp[i][j][1] \\n        \\n        return [dp[0][0][0],dp[0][0][1] % M]\\n\\t\\t\\n # I really appreciate it if u vote up! \\uFF08\\uFFE3\\uFE36\\uFFE3\\uFF09\\u2197                       \\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        M = 10**9 + 7\\n        n = len(board)\\n        dp = [[[0, 0] for _ in range(n)] for _ in range(n)]\\n        dp[-1][-1] = [0, 1]\\n        \\n        for i in range(n - 1, -1 , -1):\\n            for j in range(n - 1, -1, -1):\\n                if dp[i][j][1] == 0: # if we don\\'t have avalible path at this stage, no need for next step\\n                    continue\\n                \\n                if i > 0 and board[i - 1][j] != \\'X\\': \\n                    cur = dp[i][j][0] \\n                    if board[i - 1][j] != \\'E\\':  #if path doesn\\'t end, keep adding next value to cur\\n                        cur += int(board[i - 1][j]) \\n                        \\n                    if cur > dp[i - 1][j][0]: # if new path score is bigger than previous one, we update it with new maximum score and path number inherited from last step\\n                        dp[i - 1][j] = [cur, dp[i][j][1]]\\n                    elif cur == dp[i - 1][j][0]: #if new path score equlas to previous one, adding new path number to previous path number\\n                        dp[i - 1][j][1] += dp[i][j][1] \\n                \\n                if j > 0 and board[i][j - 1] != \\'X\\': \\n                    cur = dp[i][j][0] \\n                    if board[i][j - 1] != \\'E\\': \\n                        cur += int(board[i][j - 1])\\n                        \\n                    if cur > dp[i][j - 1][0]: \\n                        dp[i][j - 1] = [cur, dp[i][j][1]]\\n                    elif cur == dp[i][j - 1][0]: \\n                        dp[i][j - 1][1] += dp[i][j][1] \\n                \\n                if i > 0 and j > 0 and board[i - 1][j - 1] != \\'X\\': \\n                    cur = dp[i][j][0] \\n                    if board[i - 1][j - 1] != \\'E\\':\\n                        cur += int(board[i - 1][j - 1])\\n                        \\n                    if cur > dp[i - 1][j - 1][0]: \\n                        dp[i - 1][j - 1] = [cur, dp[i][j][1]]\\n                    elif cur == dp[i - 1][j - 1][0]: \\n                        dp[i - 1][j - 1][1] += dp[i][j][1] \\n        \\n        return [dp[0][0][0],dp[0][0][1] % M]\\n\\t\\t\\n # I really appreciate it if u vote up! \\uFF08\\uFFE3\\uFE36\\uFFE3\\uFF09\\u2197                       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 463337,
                "title": "python-top-down-bottom-up-dp-clean-code-with-picture-explaination",
                "content": "Top down DP. \\nIf we have four cells like this:\\nO A\\nB C\\nThen,\\nDP(O) = maximum pathsum from {DP(A), DP(B), DP(C)} + int(grid[O])\\n\\nIf we have a figure to show the high level layer by layer exploration process, the figure will be something like this. Then it is clear from this vis that the complexity of this algorithm is O(RC) or O(mn). In the real exploration process, it will not explore exactly this way, instead it will follow a DFS approach as shown later.\\n![image](https://assets.leetcode.com/users/liketheflower/image_1577568020.png)\\n\\n\\nWe can have maximum sum from more than one substate, please combine them to guarantee correctness.\\n\\nIf we can reach (R-1, C-1) when R is total number of rows, C is total number of columns, it is reachable. \\n**Top Down DP (332ms)**\\n```python\\nfrom functools import lru_cache\\nclass Solution:\\n    def pathsWithMaxScore(self, grid: List[str]) -> List[int]:\\n        grid[0] = \"0\"+grid[0][1:]\\n        R, C = len(grid), len(grid[0])\\n        self.reachable = False\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i==R-1 and j==C-1:\\n                self.reachable=True\\n                return [0, 1]\\n            substates = [(i+1,j), (i,j+1),(i+1,j+1)]\\n            valid_substates = [[r,c] for r, c in substates if 0<=r<R and 0<=c<C and grid[r][c]!=\\'X\\']\\n            if not valid_substates:return [0, 0]\\n            results = [dp(r, c) for r,c in valid_substates]\\n            max_path_sum, _ = max(results)\\n            path_cnt = sum(this_path_cnt for this_path_sum, this_path_cnt in results if this_path_sum==max_path_sum)\\n            return [max_path_sum+int(grid[i][j]), path_cnt%(10**9+7)]\\n        \\n        res = dp(0, 0)\\n        return res if self.reachable else [0,0]\\n```\\n\\nFrom the figure, we can easily figure out the bottom up order to generate correct results. The order is:\\xA0\\nbegin from the (N-1, N-1), solve each layer which contains whole column grid[N-1,:] and whole row grid[:,N-1]\\nWe should do this in a diagonal order: (k, k),  where k is from N-1 to 0.\\n**Bottom UP DP 1 (232ms)**\\n```python\\nclass Solution:\\n    def pathsWithMaxScore(self, grid: List[str]) -> List[int]:\\n        grid[0] = \"0\"+grid[0][1:]\\n        N = len(grid)\\n        \\n        def get_this_res(i, j):\\n            if grid[i][j] == \\'X\\':return [-float(\\'inf\\'), 0]\\n            if i==N-1 and j==N-1:return [0, 1]\\n            results = [dp[i+di][j+dj] for di, dj in [(1,0),(0,1),(1,1)]]\\n            max_path_sum, _ = max(results)\\n\\t\\t\\t# combine the path_cnt, think about this case results = [[2,1], [2,1], [1,1]], the path_cnt shoule be 1+1 not 1.\\n            max_path_sum_cnt = sum(this_path_cnt for this_path_sum, this_path_cnt in results if this_path_sum==max_path_sum)\\n            return [max_path_sum+int(grid[i][j]), max_path_sum_cnt%(10**9+7)]\\n        \\n        # use N+1 by N+1 to get rid of out of boundary issue\\n        dp = [[[-float(\\'inf\\'), 0] for j in range(N+1)] for i in range(N+1)]\\n        # in diagonal direction from bottom right to top left\\n        for k in range(N-1, -1, -1):\\n            # for this row\\n            for i in range(k, -1, -1):\\n                dp[i][k] = get_this_res(i, k)\\n            # for this column\\n            for j in range(k, -1, -1):\\n                dp[k][j] = get_this_res(k, j)\\n        return dp[0][0] if dp[0][0][0]!=-float(\\'inf\\') else [0, 0]\\n```\\nWe can also do it column by column. The order is from last column to first column. For each column, we should do it from last row to first row.\\n**Bottom UP DP 2 (280ms)**\\n```python\\nclass Solution:\\n    def pathsWithMaxScore(self, grid: List[str]) -> List[int]:\\n        grid[0] = \"0\"+grid[0][1:]\\n        N = len(grid)\\n        \\n        def get_this_res(i, j):\\n            if grid[i][j] == \\'X\\':return [-float(\\'inf\\'), 0]\\n            if i==N-1 and j==N-1:return [0, 1]\\n            results = [dp[i+di][j+dj] for di, dj in [(1,0),(0,1),(1,1)]]\\n            max_path_sum, _ = max(results)\\n\\t\\t\\t# combine the path_cnt, think about this case results = [[2,1], [2,1], [1,1]], the path_cnt shoule be 1+1 not 1.\\n            max_path_sum_cnt = sum(this_path_cnt for this_path_sum, this_path_cnt in results if this_path_sum==max_path_sum)\\n            return [max_path_sum+int(grid[i][j]), max_path_sum_cnt%(10**9+7)]\\n        \\n        # use N+1 by N+1 to get rid of out of boundary issue\\n        dp = [[[-float(\\'inf\\'), 0] for j in range(N+1)] for i in range(N+1)]\\n        for j in range(N-1, -1, -1):\\n            for i in range(N-1, -1, -1):\\n                dp[i][j] = get_this_res(i, j)\\n        return dp[0][0] if dp[0][0][0]!=-float(\\'inf\\') else [0, 0]\\n```\\nIf we want to explore the bottom up DP process, we can print out i, j based on above code by using this test case:\\n[\"E111\",\"1111\",\"1111\",\"111S\"]\\nWe will have the following output:\\n```python\\nstep  0 :  0 0\\nstep  1 :  1 0\\nstep  2 :  2 0\\nstep  3 :  3 0\\nstep  4 :  3 1\\nstep  5 :  3 2\\nstep  6 :  3 3\\nstep  7 :  2 1\\nstep  8 :  2 2\\nstep  9 :  2 3\\nstep 10 :  1 1\\nstep 11 :  1 2\\nstep 12 :  1 3\\nstep 13 :  0 1\\nstep 14 :  0 2\\nstep 15 :  0 3\\n```\\nThe exploration order can be explained by the following:\\nIn order to solve dp(**0, 0**), we need dp(**1,0**), dp(0,1) and dp(1, 1).\\nin order to get dp(**1,0**), we need dp(**2,0**), dp(1,1) and dp(2,1)\\nin order to get dp(**2,0**), we need dp(**3,0**), dp(2,1) and dp(3,1)\\nin order to get dp(**3,0**), we need dp(**3,1**) \\nin order to get dp(**3,1**), we need dp(**3,2**) \\nin order to get dp(**3,2**), we need dp(**3,3**)\\nsince we touch the bottom, we go back to solve dp(2,1)\\nin order to get dp(**2,1**), we need dp(3,1), dp(2,2), dp(3,2). As only dp(2,2) is not done, we need solve\\ndp(**2,2**) based on dp(3,2), dp(2,3), dp(3,3).  As only dp(2,3) is not done, we need solve\\ndp(**2,3**) based on dp(3,3). dp(3,3) is already solved, we went back to \\ndp(**1,1**)\\n...\\nFrom this example, I hope that we can have a deeper understanding about:\\n1. relationship between recursion and DP\\n2. relationship between recursion and DFS\\n\\nHope it helps. Thanks.\\n\\nP.S.\\n1. code output i and j\\n```python\\nfrom functools import lru_cache\\nclass Solution:\\n    def pathsWithMaxScore(self, grid: List[str]) -> List[int]:\\n        grid[0] = \"0\"+grid[0][1:]\\n        R, C = len(grid), len(grid[0])\\n        self.reachable = False\\n        self.step = 0\\n        @lru_cache(None)\\n        def dp(i, j):\\n            print(\"step {:2d}\".format(self.step),\": \", i, j)\\n            self.step += 1\\n            if i==R-1 and j==C-1:\\n                self.reachable=True\\n                return [0, 1]\\n            candidates = [(i+1,j), (i,j+1),(i+1,j+1)]\\n            valids = [[r,c] for r, c in candidates if 0<=r<R and 0<=c<C and grid[r][c]!=\\'X\\']\\n            if not valids:return [0, 0]\\n            results = [dp(r, c) for r,c in valids]\\n            max_sum, _ = max(results)\\n            cnt = sum(this_cnt for this_sum, this_cnt in results if this_sum==max_sum)\\n            this_res= [max_sum+int(grid[i][j]), cnt%(10**9+7)]\\n            return this_res\\n        \\n        res = dp(0, 0)\\n        return res if self.reachable else [0,0]\\n```\\n\\n2. Naive BFS will get TLE.\\n```python\\nclass Solution:\\n    def pathsWithMaxScore(self, grid: List[str]) -> List[int]:\\n        grid[0] = \"0\"+grid[0][1:]\\n        R, C = len(grid), len(grid[0])\\n        dp = [[collections.defaultdict(int) for j in range(C)] for i in range(R)]\\n        def bfs():\\n            from collections import deque\\n            Q = deque([(R-1, C-1, 0, 1)])\\n            while Q:\\n                i, j, path_sum, path_cnt = Q.popleft()\\n                for di, dj in [(-1,0),(0,-1),(-1,-1)]:\\n                    r,c  = i+di, j+dj\\n                    if 0<=r<R and 0<=c<C and grid[r][c]!=\\'X\\':\\n                        this_path_sum, this_path_cnt = path_sum+int(grid[r][c]), path_cnt\\n                        dp[r][c][this_path_sum] += this_path_cnt\\n                        Q.append((r,c,this_path_sum, this_path_cnt))\\n            values = sum(dp[0][0][key] for key in dp[0][0])\\n            if values==0:return [0,0]\\n            max_k = max(dp[0][0].keys())\\n            return [max_k, dp[0][0][max_k]%(10**9+7)]\\n        return bfs()\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom functools import lru_cache\\nclass Solution:\\n    def pathsWithMaxScore(self, grid: List[str]) -> List[int]:\\n        grid[0] = \"0\"+grid[0][1:]\\n        R, C = len(grid), len(grid[0])\\n        self.reachable = False\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if i==R-1 and j==C-1:\\n                self.reachable=True\\n                return [0, 1]\\n            substates = [(i+1,j), (i,j+1),(i+1,j+1)]\\n            valid_substates = [[r,c] for r, c in substates if 0<=r<R and 0<=c<C and grid[r][c]!=\\'X\\']\\n            if not valid_substates:return [0, 0]\\n            results = [dp(r, c) for r,c in valid_substates]\\n            max_path_sum, _ = max(results)\\n            path_cnt = sum(this_path_cnt for this_path_sum, this_path_cnt in results if this_path_sum==max_path_sum)\\n            return [max_path_sum+int(grid[i][j]), path_cnt%(10**9+7)]\\n        \\n        res = dp(0, 0)\\n        return res if self.reachable else [0,0]\\n```\n```python\\nclass Solution:\\n    def pathsWithMaxScore(self, grid: List[str]) -> List[int]:\\n        grid[0] = \"0\"+grid[0][1:]\\n        N = len(grid)\\n        \\n        def get_this_res(i, j):\\n            if grid[i][j] == \\'X\\':return [-float(\\'inf\\'), 0]\\n            if i==N-1 and j==N-1:return [0, 1]\\n            results = [dp[i+di][j+dj] for di, dj in [(1,0),(0,1),(1,1)]]\\n            max_path_sum, _ = max(results)\\n\\t\\t\\t# combine the path_cnt, think about this case results = [[2,1], [2,1], [1,1]], the path_cnt shoule be 1+1 not 1.\\n            max_path_sum_cnt = sum(this_path_cnt for this_path_sum, this_path_cnt in results if this_path_sum==max_path_sum)\\n            return [max_path_sum+int(grid[i][j]), max_path_sum_cnt%(10**9+7)]\\n        \\n        # use N+1 by N+1 to get rid of out of boundary issue\\n        dp = [[[-float(\\'inf\\'), 0] for j in range(N+1)] for i in range(N+1)]\\n        # in diagonal direction from bottom right to top left\\n        for k in range(N-1, -1, -1):\\n            # for this row\\n            for i in range(k, -1, -1):\\n                dp[i][k] = get_this_res(i, k)\\n            # for this column\\n            for j in range(k, -1, -1):\\n                dp[k][j] = get_this_res(k, j)\\n        return dp[0][0] if dp[0][0][0]!=-float(\\'inf\\') else [0, 0]\\n```\n```python\\nclass Solution:\\n    def pathsWithMaxScore(self, grid: List[str]) -> List[int]:\\n        grid[0] = \"0\"+grid[0][1:]\\n        N = len(grid)\\n        \\n        def get_this_res(i, j):\\n            if grid[i][j] == \\'X\\':return [-float(\\'inf\\'), 0]\\n            if i==N-1 and j==N-1:return [0, 1]\\n            results = [dp[i+di][j+dj] for di, dj in [(1,0),(0,1),(1,1)]]\\n            max_path_sum, _ = max(results)\\n\\t\\t\\t# combine the path_cnt, think about this case results = [[2,1], [2,1], [1,1]], the path_cnt shoule be 1+1 not 1.\\n            max_path_sum_cnt = sum(this_path_cnt for this_path_sum, this_path_cnt in results if this_path_sum==max_path_sum)\\n            return [max_path_sum+int(grid[i][j]), max_path_sum_cnt%(10**9+7)]\\n        \\n        # use N+1 by N+1 to get rid of out of boundary issue\\n        dp = [[[-float(\\'inf\\'), 0] for j in range(N+1)] for i in range(N+1)]\\n        for j in range(N-1, -1, -1):\\n            for i in range(N-1, -1, -1):\\n                dp[i][j] = get_this_res(i, j)\\n        return dp[0][0] if dp[0][0][0]!=-float(\\'inf\\') else [0, 0]\\n```\n```python\\nstep  0 :  0 0\\nstep  1 :  1 0\\nstep  2 :  2 0\\nstep  3 :  3 0\\nstep  4 :  3 1\\nstep  5 :  3 2\\nstep  6 :  3 3\\nstep  7 :  2 1\\nstep  8 :  2 2\\nstep  9 :  2 3\\nstep 10 :  1 1\\nstep 11 :  1 2\\nstep 12 :  1 3\\nstep 13 :  0 1\\nstep 14 :  0 2\\nstep 15 :  0 3\\n```\n```python\\nfrom functools import lru_cache\\nclass Solution:\\n    def pathsWithMaxScore(self, grid: List[str]) -> List[int]:\\n        grid[0] = \"0\"+grid[0][1:]\\n        R, C = len(grid), len(grid[0])\\n        self.reachable = False\\n        self.step = 0\\n        @lru_cache(None)\\n        def dp(i, j):\\n            print(\"step {:2d}\".format(self.step),\": \", i, j)\\n            self.step += 1\\n            if i==R-1 and j==C-1:\\n                self.reachable=True\\n                return [0, 1]\\n            candidates = [(i+1,j), (i,j+1),(i+1,j+1)]\\n            valids = [[r,c] for r, c in candidates if 0<=r<R and 0<=c<C and grid[r][c]!=\\'X\\']\\n            if not valids:return [0, 0]\\n            results = [dp(r, c) for r,c in valids]\\n            max_sum, _ = max(results)\\n            cnt = sum(this_cnt for this_sum, this_cnt in results if this_sum==max_sum)\\n            this_res= [max_sum+int(grid[i][j]), cnt%(10**9+7)]\\n            return this_res\\n        \\n        res = dp(0, 0)\\n        return res if self.reachable else [0,0]\\n```\n```python\\nclass Solution:\\n    def pathsWithMaxScore(self, grid: List[str]) -> List[int]:\\n        grid[0] = \"0\"+grid[0][1:]\\n        R, C = len(grid), len(grid[0])\\n        dp = [[collections.defaultdict(int) for j in range(C)] for i in range(R)]\\n        def bfs():\\n            from collections import deque\\n            Q = deque([(R-1, C-1, 0, 1)])\\n            while Q:\\n                i, j, path_sum, path_cnt = Q.popleft()\\n                for di, dj in [(-1,0),(0,-1),(-1,-1)]:\\n                    r,c  = i+di, j+dj\\n                    if 0<=r<R and 0<=c<C and grid[r][c]!=\\'X\\':\\n                        this_path_sum, this_path_cnt = path_sum+int(grid[r][c]), path_cnt\\n                        dp[r][c][this_path_sum] += this_path_cnt\\n                        Q.append((r,c,this_path_sum, this_path_cnt))\\n            values = sum(dp[0][0][key] for key in dp[0][0])\\n            if values==0:return [0,0]\\n            max_k = max(dp[0][0].keys())\\n            return [max_k, dp[0][0][max_k]%(10**9+7)]\\n        return bfs()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463294,
                "title": "python-solution-using-dp",
                "content": "We can solve this problem using dynamic programming.\\n- ```max_score[y][x]``` is the maximum score that can be obtained reaching field ```(y, x)```\\n- ```max_paths[y][x]``` is the sum of paths with ```max_score[y][x]``` leading to ```(y, x)```\\n\\nFor every field from bottom-right to top-left:\\n- skip the start field (```S```) and pre-assign it as reachable (```max_paths[-1][-1] = 1```)\\n- skip blocked fields (```X```)\\n- check the neighborhood (bottom, right and bottom-right)\\n\\t- skip blocked neighbors (```X```) and those that are not reachable (```max_paths[y2][x2] == 0```)\\n\\t- calculate the score obtainable for each valid neighbor and update ```max_score``` and ```max_paths``` if the score is higher than the maximum score\\n\\t- sum up the number of paths if multiple neighbors have the same score\\n\\nTime and space complexity: ```O(n\\xB2)```\\n\\nA solution with a space complexity of ```O(n)``` is also possible since we only need access to the current and the previous row.\\n\\n```python\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        MOD = 10**9 + 7\\n        n = len(board)\\n        \\n        max_score = [[0] * n for _ in range(n)]\\n        max_paths = [[0] * n for _ in range(n)]\\n        max_paths[-1][-1] = 1\\n            \\n        for y in range(n - 1, -1, -1):\\n            for x in range(n - 1, -1, -1):\\n                if board[y][x] in \\'SX\\':\\n                    continue\\n                \\n                num = int(board[y][x]) if board[y][x] not in \\'SEX\\' else 0\\n                \\n                for y2, x2 in [(y + 1, x), (y, x + 1), (y + 1, x + 1)]:\\n                    if y2 < n and x2 < n:\\n                        if board[y2][x2] == \\'X\\' or max_paths[y2][x2] == 0:\\n                            continue\\n                            \\n                        score = (max_score[y2][x2] + num) % MOD\\n                        \\n                        if score > max_score[y][x]:\\n                            max_score[y][x] = score\\n                            max_paths[y][x] = max_paths[y2][x2]\\n                        elif score == max_score[y][x]:\\n                            max_paths[y][x] = (max_paths[y][x] + max_paths[y2][x2]) % MOD\\n        \\n        return [max_score[0][0], max_paths[0][0]]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```max_score[y][x]```\n```(y, x)```\n```max_paths[y][x]```\n```max_score[y][x]```\n```(y, x)```\n```S```\n```max_paths[-1][-1] = 1```\n```X```\n```X```\n```max_paths[y2][x2] == 0```\n```max_score```\n```max_paths```\n```O(n\\xB2)```\n```O(n)```\n```python\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        MOD = 10**9 + 7\\n        n = len(board)\\n        \\n        max_score = [[0] * n for _ in range(n)]\\n        max_paths = [[0] * n for _ in range(n)]\\n        max_paths[-1][-1] = 1\\n            \\n        for y in range(n - 1, -1, -1):\\n            for x in range(n - 1, -1, -1):\\n                if board[y][x] in \\'SX\\':\\n                    continue\\n                \\n                num = int(board[y][x]) if board[y][x] not in \\'SEX\\' else 0\\n                \\n                for y2, x2 in [(y + 1, x), (y, x + 1), (y + 1, x + 1)]:\\n                    if y2 < n and x2 < n:\\n                        if board[y2][x2] == \\'X\\' or max_paths[y2][x2] == 0:\\n                            continue\\n                            \\n                        score = (max_score[y2][x2] + num) % MOD\\n                        \\n                        if score > max_score[y][x]:\\n                            max_score[y][x] = score\\n                            max_paths[y][x] = max_paths[y2][x2]\\n                        elif score == max_score[y][x]:\\n                            max_paths[y][x] = (max_paths[y][x] + max_paths[y2][x2]) % MOD\\n        \\n        return [max_score[0][0], max_paths[0][0]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463286,
                "title": "dp-python",
                "content": "dp is the intuitive thought that came up\\n\\ndp[i][j] = [m,v]\\nwhere m is the max cumulated integer sum to get to (i,j)\\nv is the number of paths with that cumulated sums to get to (i,j)\\n\\n1. number of subproblems: O(mn)\\n2. time per subproblems: O(1) **3 neighbouring cells at most**\\n3. bottom up \\n5.  final answer dp[0][0]\\n6.  recurrence relation (the pain in the A** in this problem), build a hashmap h in **3 steps** where\\n\\t* the key is a possible cumulated integer sum to get to the cell (i,j)\\n\\t* the value is the number of paths to get to this cell (i,j) with key as maxcumulated integer sum\\n\\t* **step 1** populate it\\n\\t* **step 2** filter it, once populated , removing the zeros paths possibles\\n```h = {key:(h[key] % MOD) for key in h if h[key] != 0}```\\n\\t* **step 3** compute the result for (i,j),  (I want the max cumulated sum not the max number of paths)\\n\\n\\t\\t```\\n\\t\\tmk = max(h.keys()) \\n\\t\\tmv = h[mk]\\n\\t\\tmk += int(board[i][j])\\n\\t\\t```\\n\\n\\n\\ncode\\n\\n```\\nclass Solution(object):\\n    def pathsWithMaxScore(self, board):\\n        MOD = 10 ** 9 + 7   \\n        dp = [[[0,0]] * len(board[0]) for _ in range(len(board))]\\n        for i in range(len(board) - 1, -1, -1):\\n            for j in range(len(board[0]) - 1,-1, -1 ):\\n                if board[i][j] != \\'X\\':\\n                    if i == len(board) -1 and j == len(board[0]) -1: dp[-1][-1] = (0, 1)\\n                    else:\\n                        \"\"\"\\n                        h is a hashmap where,  key:value\\n                        the key is a possible cumulated integer sum to get to the cell (i,j)\\n                        the value is the number of paths to get to this cell (i,j) with key as maxcumulated integer sum\\n                        \"\"\"\\n                        h = collections.Counter()\\n                        if i + 1 < len(board) and j+1 < len(board[0]): h[dp[i + 1][j + 1][0]] += dp[i + 1][j + 1][1] \\n                        if j + 1 < len(board[0]): h[dp[i][j + 1][0]] += dp[i][j + 1][1]\\n                        if i + 1 < len(board): h[dp[i + 1][j][0]] += dp[i + 1][j][1]\\n                        h = {key:(h[key] % MOD) for key in h if h[key] != 0}\\n                        if h: \\n                            mk = max(h.keys()) \\n                            mv = h[mk]\\n                            dp[i][j] = [mk + (int(board[i][j]) if board[i][j] != \\'E\\' else 0) ,mv]\\n        return dp[0][0]\\n```",
                "solutionTags": [],
                "code": "```h = {key:(h[key] % MOD) for key in h if h[key] != 0}```\n```\\n\\t\\tmk = max(h.keys()) \\n\\t\\tmv = h[mk]\\n\\t\\tmk += int(board[i][j])\\n\\t\\t```\n```\\nclass Solution(object):\\n    def pathsWithMaxScore(self, board):\\n        MOD = 10 ** 9 + 7   \\n        dp = [[[0,0]] * len(board[0]) for _ in range(len(board))]\\n        for i in range(len(board) - 1, -1, -1):\\n            for j in range(len(board[0]) - 1,-1, -1 ):\\n                if board[i][j] != \\'X\\':\\n                    if i == len(board) -1 and j == len(board[0]) -1: dp[-1][-1] = (0, 1)\\n                    else:\\n                        \"\"\"\\n                        h is a hashmap where,  key:value\\n                        the key is a possible cumulated integer sum to get to the cell (i,j)\\n                        the value is the number of paths to get to this cell (i,j) with key as maxcumulated integer sum\\n                        \"\"\"\\n                        h = collections.Counter()\\n                        if i + 1 < len(board) and j+1 < len(board[0]): h[dp[i + 1][j + 1][0]] += dp[i + 1][j + 1][1] \\n                        if j + 1 < len(board[0]): h[dp[i][j + 1][0]] += dp[i][j + 1][1]\\n                        if i + 1 < len(board): h[dp[i + 1][j][0]] += dp[i + 1][j][1]\\n                        h = {key:(h[key] % MOD) for key in h if h[key] != 0}\\n                        if h: \\n                            mk = max(h.keys()) \\n                            mv = h[mk]\\n                            dp[i][j] = [mk + (int(board[i][j]) if board[i][j] != \\'E\\' else 0) ,mv]\\n        return dp[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463274,
                "title": "java-dfs-brute-force-tle",
                "content": "I am not sure how to improve my DFS code to solve **Time exceed limit**\\n\\nMy first thought was to DFS all the directions and find the max sum.\\n\\nAnd then use hashmap to calculate the sum and its frequency.\\n\\nCan someone help me solve? Many thanks\\n\\n```\\nclass Solution {\\n    int maxSum;\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        maxSum = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        String last = board.get(board.size() - 1);\\n        int m = board.size();\\n        int sx = m - 1;\\n        int sy = m - 1;\\n        int ex = 0;\\n        int ey = 0;\\n        char [][]chess = new char[m][m];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < m; j++){\\n                chess[i][j] = board.get(i).charAt(j);\\n                if(i == m - 1 && j == m - 1){\\n                  chess[i][j] = \\'0\\';\\n                }\\n            }\\n        }\\n        dfs(chess, sx, sy, ex, ey, map, 0);\\n        return new int[]{maxSum, map.getOrDefault(maxSum, 0)};\\n    }\\n    public void dfs(char [][]chess, int sx, int sy, int ex, int ey, Map<Integer, Integer> map, int sum){\\n        if(sx < 0 || sx >= chess.length || sy < 0 || sy >= chess.length || chess[sy][sx] == \\'X\\'){\\n            return;\\n        }\\n        \\n        if(sx == ex && sy == ey){\\n            map.put(sum, map.getOrDefault(sum, 0) + 1);\\n            maxSum = Math.max(maxSum, sum);\\n            return;\\n        }\\n        sum += Integer.valueOf(chess[sy][sx] - \\'0\\');\\n        dfs(chess, sx - 1, sy    , ex, ey, map, sum);\\n        dfs(chess, sx    , sy - 1, ex, ey, map, sum);\\n        dfs(chess, sx - 1, sy - 1, ex, ey, map, sum);\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int maxSum;\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        maxSum = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        String last = board.get(board.size() - 1);\\n        int m = board.size();\\n        int sx = m - 1;\\n        int sy = m - 1;\\n        int ex = 0;\\n        int ey = 0;\\n        char [][]chess = new char[m][m];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < m; j++){\\n                chess[i][j] = board.get(i).charAt(j);\\n                if(i == m - 1 && j == m - 1){\\n                  chess[i][j] = \\'0\\';\\n                }\\n            }\\n        }\\n        dfs(chess, sx, sy, ex, ey, map, 0);\\n        return new int[]{maxSum, map.getOrDefault(maxSum, 0)};\\n    }\\n    public void dfs(char [][]chess, int sx, int sy, int ex, int ey, Map<Integer, Integer> map, int sum){\\n        if(sx < 0 || sx >= chess.length || sy < 0 || sy >= chess.length || chess[sy][sx] == \\'X\\'){\\n            return;\\n        }\\n        \\n        if(sx == ex && sy == ey){\\n            map.put(sum, map.getOrDefault(sum, 0) + 1);\\n            maxSum = Math.max(maxSum, sum);\\n            return;\\n        }\\n        sum += Integer.valueOf(chess[sy][sx] - \\'0\\');\\n        dfs(chess, sx - 1, sy    , ex, ey, map, sum);\\n        dfs(chess, sx    , sy - 1, ex, ey, map, sum);\\n        dfs(chess, sx - 1, sy - 1, ex, ey, map, sum);\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 463201,
                "title": "java-o-mn-dp-solution",
                "content": "``` java\\nclass Solution {\\n    int MOD = 1000000007;\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        //dp[i][j][0] means score = Max among dp[i+1][j][0], dp[i+1][j+1][0], dp[i][j+1][0] + board[i][j]\\n        //dp[i][j][1] means paths = sum among dp[i+1][j][1], dp[i+1][j+1][1], dp[i][j+1][1] if value of each equals to max\\n        int m = board.size();\\n        int n = board.get(0).length();\\n        int[][][] dp = new int[m][n][2];\\n        dp[m-1][n-1][1] = 1;\\n        \\n        for(int j = n - 2, i = m - 1; j >= 0; j--){\\n            char c = getBoard(board, i,  j);\\n            if(c == \\'X\\'){\\n                break;\\n            }\\n            else{\\n                int v = Character.isDigit(c) ? Integer.parseInt(String.valueOf(c)) : 0;\\n                dp[i][j][0] = (dp[i][j+1][0] + v) % MOD;\\n                dp[i][j][1] = dp[i][j+1][1] % MOD;\\n            }\\n        }\\n        for(int j = n - 1, i = m - 2; i >= 0; i--){\\n            char c = getBoard(board, i,  j);\\n            if(c == \\'X\\'){\\n                break;\\n            }\\n            else{\\n                int v = Character.isDigit(c) ? Integer.parseInt(String.valueOf(c)) : 0;\\n                dp[i][j][0] = (dp[i + 1][j][0] + v) % MOD;\\n                dp[i][j][1] = dp[i + 1][j][1] % MOD;\\n            }\\n        }\\n        \\n        for(int i = m - 2; i >= 0; i--){\\n            for(int j = n - 2; j >= 0; j--){\\n                char c = getBoard(board, i, j);\\n                if(c != \\'X\\'){\\n                    int v = Character.isDigit(c) ? Integer.parseInt(String.valueOf(c)) : 0;\\n                    int max = Math.max(dp[i+1][j][0], Math.max(dp[i+1][j+1][0], dp[i][j+1][0]));\\n                    int way = 0;\\n                    if(max == dp[i+1][j][0] && dp[i+1][j][1] != 0){\\n                        way += dp[i+1][j][1] % MOD;\\n                    }\\n                    if(max == dp[i+1][j+1][0] && dp[i+1][j+1][1] != 0){\\n                        way += dp[i+1][j+1][1] % MOD;\\n                    }\\n                    if(max == dp[i][j+1][0] && dp[i][j+1][1] != 0){\\n                        way += dp[i][j+1][1] % MOD;\\n                    }\\n\\t\\t\\t\\t\\t//way == 0 means all block\\n                    dp[i][j][0] = way == 0 ? 0 : (max + v) % MOD;\\n                    dp[i][j][1] = way % MOD;\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n    \\n    private char getBoard(List<String> board, int i,  int j){\\n        return board.get(i).charAt(j);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    int MOD = 1000000007;\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        //dp[i][j][0] means score = Max among dp[i+1][j][0], dp[i+1][j+1][0], dp[i][j+1][0] + board[i][j]\\n        //dp[i][j][1] means paths = sum among dp[i+1][j][1], dp[i+1][j+1][1], dp[i][j+1][1] if value of each equals to max\\n        int m = board.size();\\n        int n = board.get(0).length();\\n        int[][][] dp = new int[m][n][2];\\n        dp[m-1][n-1][1] = 1;\\n        \\n        for(int j = n - 2, i = m - 1; j >= 0; j--){\\n            char c = getBoard(board, i,  j);\\n            if(c == \\'X\\'){\\n                break;\\n            }\\n            else{\\n                int v = Character.isDigit(c) ? Integer.parseInt(String.valueOf(c)) : 0;\\n                dp[i][j][0] = (dp[i][j+1][0] + v) % MOD;\\n                dp[i][j][1] = dp[i][j+1][1] % MOD;\\n            }\\n        }\\n        for(int j = n - 1, i = m - 2; i >= 0; i--){\\n            char c = getBoard(board, i,  j);\\n            if(c == \\'X\\'){\\n                break;\\n            }\\n            else{\\n                int v = Character.isDigit(c) ? Integer.parseInt(String.valueOf(c)) : 0;\\n                dp[i][j][0] = (dp[i + 1][j][0] + v) % MOD;\\n                dp[i][j][1] = dp[i + 1][j][1] % MOD;\\n            }\\n        }\\n        \\n        for(int i = m - 2; i >= 0; i--){\\n            for(int j = n - 2; j >= 0; j--){\\n                char c = getBoard(board, i, j);\\n                if(c != \\'X\\'){\\n                    int v = Character.isDigit(c) ? Integer.parseInt(String.valueOf(c)) : 0;\\n                    int max = Math.max(dp[i+1][j][0], Math.max(dp[i+1][j+1][0], dp[i][j+1][0]));\\n                    int way = 0;\\n                    if(max == dp[i+1][j][0] && dp[i+1][j][1] != 0){\\n                        way += dp[i+1][j][1] % MOD;\\n                    }\\n                    if(max == dp[i+1][j+1][0] && dp[i+1][j+1][1] != 0){\\n                        way += dp[i+1][j+1][1] % MOD;\\n                    }\\n                    if(max == dp[i][j+1][0] && dp[i][j+1][1] != 0){\\n                        way += dp[i][j+1][1] % MOD;\\n                    }\\n\\t\\t\\t\\t\\t//way == 0 means all block\\n                    dp[i][j][0] = way == 0 ? 0 : (max + v) % MOD;\\n                    dp[i][j][1] = way % MOD;\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n    \\n    private char getBoard(List<String> board, int i,  int j){\\n        return board.get(i).charAt(j);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036373,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) \\n    {\\n        int mod=1e9+7;\\n        int n=board.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,0));\\n        vector<vector<int>>cnt(n+1,vector<int>(n+1,0));\\n        board[n-1][n-1]=board[0][0]=\\'0\\';\\n        cnt[n-1][n-1]=1;\\n        for (int i=n-1;i>=0 ;i--)\\n        {\\n            for (int j=n-1;j>=0;j--)\\n            {\\n                if (board[i][j]!=\\'X\\')\\n                {\\n                    int m=max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\\n                    dp[i][j]=(board[i][j]-\\'0\\')+m;\\n                    if(dp[i+1][j] == m)\\n                        cnt[i][j] = (cnt[i][j]+cnt[i+1][j]) % mod;\\n                    if(dp[i][j+1] == m)\\n                        cnt[i][j] = (cnt[i][j]+cnt[i][j+1]) % mod;\\n                    if(dp[i+1][j+1] == m)\\n                        cnt[i][j] = (cnt[i][j]+cnt[i+1][j+1]) % mod; \\n\\n                }\\n            }\\n        }\\n        return {cnt[0][0]?dp[0][0]:0,cnt[0][0]};\\n\\n    }\\n};\\n\\n// class Solution {\\n// public:\\n// long long mod;\\n// bool valid(long long &x,long long &y,long long &n)\\n// {\\n//     return x>=0 && y>=0 && x<n && y<n;\\n// }\\n// long long maxPath(long long x,long long y,vector<string>& board,vector<vector<vector<long long>>>&dp,long long sum,long long &target)\\n// {\\n//     if (x==0 && y==0) \\n//     {\\n//         if (sum==target) return 1;\\n//         return 0;\\n//     }\\n//     if (dp[x][y][sum]!=-1) return dp[x][y][sum];\\n//     long long n=board.size();\\n//     long long deli[]={0,-1,-1};\\n//     long long delj[]={-1,-1,0};\\n//     long long ans=0;\\n//     for (long long i=0;i<3;i++)\\n//        {\\n//            long long newx=x+deli[i];\\n//            long long newy=y+delj[i];\\n//            if (valid(newx,newy,n) && board[newx][newy]!=\\'X\\')\\n//            {\\n//                if (x==n-1 && y==n-1)\\n//                {\\n//                    ans=(ans+maxPath(newx,newy,board,dp,sum,target))%mod;\\n//                }\\n//                else ans=(ans+maxPath(newx,newy,board,dp,sum+(board[x][y]-\\'0\\'),target))%mod;\\n//            }\\n//        }\\n//        return dp[x][y][sum]=ans;\\n// }\\n//    long long rec(long long x,long long y,vector<string>& board,vector<vector<long long>>&dp)\\n//    {\\n//        if (x==0 && y==0)\\n//        {\\n//          return 0;\\n//        }\\n//        if (dp[x][y]!=-1) return dp[x][y];\\n//         long long n=board.size();\\n//        long long deli[]={0,-1,-1};\\n//        long long delj[]={-1,-1,0};\\n//        long long ans=-1e7;\\n//        for (long long i=0;i<3;i++)\\n//        {\\n//            long long newx=x+deli[i];\\n//            long long newy=y+delj[i];\\n//            if (valid(newx,newy,n) && board[newx][newy]!=\\'X\\')\\n//            {\\n//                if (x==n-1 && y==n-1)\\n//                {\\n//                    ans=max(ans,rec(newx,newy,board,dp));\\n//                }\\n//                else ans=max(ans, board[x][y]-\\'0\\' + rec(newx,newy,board,dp));\\n//            }\\n//        }\\n//        return dp[x][y]=ans;\\n//    }\\n//     vector<int> pathsWithMaxScore(vector<string>& board) {\\n//         long long n=board.size();\\n//         mod=1e9+7;\\n//         vector<vector<long long>>dp(n,vector<long long>(n,-1));\\n//          vector<vector<vector<long long >>>dp2(n,vector<vector<long long>>(n,vector<long long>(2000,-1)));\\n//         long long freq=0;\\n        \\n//         long long ans=rec(n-1,n-1,board,dp);\\n//         if (ans<0) return {0,0};\\n//         long long num=maxPath(n-1,n-1,board,dp2,0,ans);\\n//         int ans1=(int)ans;\\n//         int num1=(int)num;\\n//         return {ans1,num1};\\n\\n\\n//     }\\n// };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) \\n    {\\n        int mod=1e9+7;\\n        int n=board.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,0));\\n        vector<vector<int>>cnt(n+1,vector<int>(n+1,0));\\n        board[n-1][n-1]=board[0][0]=\\'0\\';\\n        cnt[n-1][n-1]=1;\\n        for (int i=n-1;i>=0 ;i--)\\n        {\\n            for (int j=n-1;j>=0;j--)\\n            {\\n                if (board[i][j]!=\\'X\\')\\n                {\\n                    int m=max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]});\\n                    dp[i][j]=(board[i][j]-\\'0\\')+m;\\n                    if(dp[i+1][j] == m)\\n                        cnt[i][j] = (cnt[i][j]+cnt[i+1][j]) % mod;\\n                    if(dp[i][j+1] == m)\\n                        cnt[i][j] = (cnt[i][j]+cnt[i][j+1]) % mod;\\n                    if(dp[i+1][j+1] == m)\\n                        cnt[i][j] = (cnt[i][j]+cnt[i+1][j+1]) % mod; \\n\\n                }\\n            }\\n        }\\n        return {cnt[0][0]?dp[0][0]:0,cnt[0][0]};\\n\\n    }\\n};\\n\\n// class Solution {\\n// public:\\n// long long mod;\\n// bool valid(long long &x,long long &y,long long &n)\\n// {\\n//     return x>=0 && y>=0 && x<n && y<n;\\n// }\\n// long long maxPath(long long x,long long y,vector<string>& board,vector<vector<vector<long long>>>&dp,long long sum,long long &target)\\n// {\\n//     if (x==0 && y==0) \\n//     {\\n//         if (sum==target) return 1;\\n//         return 0;\\n//     }\\n//     if (dp[x][y][sum]!=-1) return dp[x][y][sum];\\n//     long long n=board.size();\\n//     long long deli[]={0,-1,-1};\\n//     long long delj[]={-1,-1,0};\\n//     long long ans=0;\\n//     for (long long i=0;i<3;i++)\\n//        {\\n//            long long newx=x+deli[i];\\n//            long long newy=y+delj[i];\\n//            if (valid(newx,newy,n) && board[newx][newy]!=\\'X\\')\\n//            {\\n//                if (x==n-1 && y==n-1)\\n//                {\\n//                    ans=(ans+maxPath(newx,newy,board,dp,sum,target))%mod;\\n//                }\\n//                else ans=(ans+maxPath(newx,newy,board,dp,sum+(board[x][y]-\\'0\\'),target))%mod;\\n//            }\\n//        }\\n//        return dp[x][y][sum]=ans;\\n// }\\n//    long long rec(long long x,long long y,vector<string>& board,vector<vector<long long>>&dp)\\n//    {\\n//        if (x==0 && y==0)\\n//        {\\n//          return 0;\\n//        }\\n//        if (dp[x][y]!=-1) return dp[x][y];\\n//         long long n=board.size();\\n//        long long deli[]={0,-1,-1};\\n//        long long delj[]={-1,-1,0};\\n//        long long ans=-1e7;\\n//        for (long long i=0;i<3;i++)\\n//        {\\n//            long long newx=x+deli[i];\\n//            long long newy=y+delj[i];\\n//            if (valid(newx,newy,n) && board[newx][newy]!=\\'X\\')\\n//            {\\n//                if (x==n-1 && y==n-1)\\n//                {\\n//                    ans=max(ans,rec(newx,newy,board,dp));\\n//                }\\n//                else ans=max(ans, board[x][y]-\\'0\\' + rec(newx,newy,board,dp));\\n//            }\\n//        }\\n//        return dp[x][y]=ans;\\n//    }\\n//     vector<int> pathsWithMaxScore(vector<string>& board) {\\n//         long long n=board.size();\\n//         mod=1e9+7;\\n//         vector<vector<long long>>dp(n,vector<long long>(n,-1));\\n//          vector<vector<vector<long long >>>dp2(n,vector<vector<long long>>(n,vector<long long>(2000,-1)));\\n//         long long freq=0;\\n        \\n//         long long ans=rec(n-1,n-1,board,dp);\\n//         if (ans<0) return {0,0};\\n//         long long num=maxPath(n-1,n-1,board,dp2,0,ans);\\n//         int ans1=(int)ans;\\n//         int num1=(int)num;\\n//         return {ans1,num1};\\n\\n\\n//     }\\n// };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006819,
                "title": "python-dp",
                "content": "# Complexity\\n- Time complexity: O(n^2)\\n- Space complexity: O(n^2)\\n\\n# Code\\n```\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        n, m = len(board), len(board[0])\\n\\n        dp = [[(float(\\'-inf\\'), 0)] * m for _ in range(n)]\\n        dp[0][0] = (0, 1)\\n\\n        for i in range(n):\\n            for j in range(m):\\n                v = board[i][j]\\n\\n                if v == \\'X\\' or v == \\'E\\':\\n                    continue\\n                \\n                tp, tp_c = dp[i-1][j] if i > 0 else (float(\\'-inf\\'), 1)\\n                tl, tl_c = dp[i-1][j-1] if i > 0 and j > 0 else (float(\\'-inf\\'), 1)\\n                lf, lf_c = dp[i][j-1] if j > 0 else (float(\\'-inf\\'), 1)\\n\\n                mx = max(tp, tl, lf)\\n                weight = (int(v) if v != \"S\" else 0)\\n                frq = 0\\n                for num, cnt in [(tp, tp_c), (tl, tl_c), (lf, lf_c)]:\\n                    if num == mx:\\n                        frq += cnt\\n            \\n                dp[i][j] = (mx+weight, frq)\\n        return [dp[-1][-1][0], dp[-1][-1][1] % (10**9 + 7)] if dp[-1][-1][0] != float(\\'-inf\\') else [0, 0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        n, m = len(board), len(board[0])\\n\\n        dp = [[(float(\\'-inf\\'), 0)] * m for _ in range(n)]\\n        dp[0][0] = (0, 1)\\n\\n        for i in range(n):\\n            for j in range(m):\\n                v = board[i][j]\\n\\n                if v == \\'X\\' or v == \\'E\\':\\n                    continue\\n                \\n                tp, tp_c = dp[i-1][j] if i > 0 else (float(\\'-inf\\'), 1)\\n                tl, tl_c = dp[i-1][j-1] if i > 0 and j > 0 else (float(\\'-inf\\'), 1)\\n                lf, lf_c = dp[i][j-1] if j > 0 else (float(\\'-inf\\'), 1)\\n\\n                mx = max(tp, tl, lf)\\n                weight = (int(v) if v != \"S\" else 0)\\n                frq = 0\\n                for num, cnt in [(tp, tp_c), (tl, tl_c), (lf, lf_c)]:\\n                    if num == mx:\\n                        frq += cnt\\n            \\n                dp[i][j] = (mx+weight, frq)\\n        return [dp[-1][-1][0], dp[-1][-1][1] % (10**9 + 7)] if dp[-1][-1][0] != float(\\'-inf\\') else [0, 0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950887,
                "title": "straightforward-dp",
                "content": "# Intuition\\nCan be solved with DP. Can\\'t be solved with Dijkstra, we need to maximize the result, will lead to an infinite loop\\n\\n# Approach\\nIt is equivalent to move from `E` to `S`, so we will be doing that.\\n- `dp[i][j]` represents the maximum score that we can obtain.\\n- `ways[i][j]` represent the number of ways that we can move to this location following the paths of maximum score.\\n![image.png](https://assets.leetcode.com/users/images/49789060-9849-4756-aa76-414cfa46fe7c_1692808783.6313245.png)\\n\\nWe take the max `dp[][]` not equal to -1, and allot `dp[i][j]` to the max of all three.\\nWe add all the `ways[][]` at which the `dp[][]` is maximum, to get the number of ways to reach `{i, j}`\\n\\n\\n# Complexity\\n- Time complexity:$O(n^2)$\\n- Space complexity:$O(n^2)$\\n# Code\\n```cpp\\nconst int INF = 2e9;\\nconst int NINF = -INF;\\nconst int MOD = 1e9 + 7;\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& grid) {\\n        int n = grid.size();\\n        vector<vector<int>> dp(n, vector<int>(n));\\n        vector<vector<int>> ways(n, vector<int>(n));\\n\\n        grid[n-1][n-1] = \\'0\\';\\n        ways[0][0] = 1;\\n\\n        bool found = false;\\n        for(int i = 1;i<n;i++) {\\n            if(grid[i][0] == \\'X\\') {\\n                found = true;\\n            }\\n            if(found) {\\n                dp[i][0] = -1;\\n                ways[i][0] = 0;\\n            } else {\\n                dp[i][0] += dp[i-1][0] + (grid[i][0] - \\'0\\');\\n                ways[i][0] = 1;\\n            }\\n        }\\n        \\n        found = false;\\n        for(int j = 1;j<n;j++) {\\n            if(grid[0][j] == \\'X\\') {\\n                found = true;\\n            }\\n            if(found) {\\n                dp[0][j] = -1;\\n                ways[0][j] = 0;\\n            } else {\\n                dp[0][j] += dp[0][j-1] + (grid[0][j] - \\'0\\');\\n                ways[0][j] = 1;\\n            }\\n        }\\n\\n        for (int i = 1;i<n;i++) {\\n            for (int j = 1;j<n;j++) {\\n                if(grid[i][j] == \\'X\\') {\\n                    dp[i][j] = -1;\\n                    ways[i][j] = 0;\\n                } else {\\n                    int mx = NINF;\\n                    mx = max({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]});\\n                    if(mx == -1) {\\n                        dp[i][j] = -1;\\n                        ways[i][j] = 0;\\n                    } else {\\n                        dp[i][j] = mx + (grid[i][j] - \\'0\\');\\n\\n                        if(dp[i-1][j] == mx) (ways[i][j] += ways[i-1][j]) %= MOD;\\n                        if(dp[i][j-1] == mx) (ways[i][j] += ways[i][j-1]) %= MOD;\\n                        if(dp[i-1][j-1] == mx) (ways[i][j] += ways[i-1][j-1]) %= MOD;\\n                    }\\n                }\\n            }\\n        }\\n        return vector<int>{dp[n-1][n-1] == -1?0:dp[n-1][n-1], ways[n-1][n-1]};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nconst int INF = 2e9;\\nconst int NINF = -INF;\\nconst int MOD = 1e9 + 7;\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& grid) {\\n        int n = grid.size();\\n        vector<vector<int>> dp(n, vector<int>(n));\\n        vector<vector<int>> ways(n, vector<int>(n));\\n\\n        grid[n-1][n-1] = \\'0\\';\\n        ways[0][0] = 1;\\n\\n        bool found = false;\\n        for(int i = 1;i<n;i++) {\\n            if(grid[i][0] == \\'X\\') {\\n                found = true;\\n            }\\n            if(found) {\\n                dp[i][0] = -1;\\n                ways[i][0] = 0;\\n            } else {\\n                dp[i][0] += dp[i-1][0] + (grid[i][0] - \\'0\\');\\n                ways[i][0] = 1;\\n            }\\n        }\\n        \\n        found = false;\\n        for(int j = 1;j<n;j++) {\\n            if(grid[0][j] == \\'X\\') {\\n                found = true;\\n            }\\n            if(found) {\\n                dp[0][j] = -1;\\n                ways[0][j] = 0;\\n            } else {\\n                dp[0][j] += dp[0][j-1] + (grid[0][j] - \\'0\\');\\n                ways[0][j] = 1;\\n            }\\n        }\\n\\n        for (int i = 1;i<n;i++) {\\n            for (int j = 1;j<n;j++) {\\n                if(grid[i][j] == \\'X\\') {\\n                    dp[i][j] = -1;\\n                    ways[i][j] = 0;\\n                } else {\\n                    int mx = NINF;\\n                    mx = max({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]});\\n                    if(mx == -1) {\\n                        dp[i][j] = -1;\\n                        ways[i][j] = 0;\\n                    } else {\\n                        dp[i][j] = mx + (grid[i][j] - \\'0\\');\\n\\n                        if(dp[i-1][j] == mx) (ways[i][j] += ways[i-1][j]) %= MOD;\\n                        if(dp[i][j-1] == mx) (ways[i][j] += ways[i][j-1]) %= MOD;\\n                        if(dp[i-1][j-1] == mx) (ways[i][j] += ways[i-1][j-1]) %= MOD;\\n                    }\\n                }\\n            }\\n        }\\n        return vector<int>{dp[n-1][n-1] == -1?0:dp[n-1][n-1], ways[n-1][n-1]};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947368,
                "title": "c-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    pair<long long,long long> helper(int i,int j,int n,int m,vector<string>&arr,vector<vector<pair<long long,long long>>>&dp){\\n        \\n        if(i<0 || j<0 || i>=n || j>=m || arr[i][j]==\\'X\\'){\\n           return {-1e9,-1e9}; \\n        }\\n        if(i==0 && j==0){\\n            return {0,1};\\n        }\\n        if(dp[i][j].first!=-1 && dp[i][j].second!=-1){\\n            return dp[i][j];\\n        }\\n        pair<long long,long long> ans1=helper(i-1,j,n,m,arr,dp);\\n        pair<long long,long long> ans2=helper(i,j-1,n,m,arr,dp);\\n        pair<long long,long long> ans3=helper(i-1,j-1,n,m,arr,dp);\\n        long long score;\\n        score=max(ans1.first%mod,max(ans2.first%mod,ans3.first%mod));\\n        pair<long long,long long> ans={0,0};\\n        ans.first=score%mod;\\n        long long paths=0;\\n        if(ans1.first==score){\\n            paths=paths%mod+ans1.second%mod;\\n        }\\n        if(ans2.first==score){\\n            paths=paths%mod+ans2.second%mod;\\n        }\\n        if(ans3.first==score){\\n            paths=paths%mod+ans3.second%mod;\\n        }\\n        char ch=arr[i][j];\\n        if(ch!=\\'E\\' && ch!=\\'S\\'){\\n            ans.first=ans.first+(ch-\\'0\\');\\n        }\\n        ans.second=paths%mod;\\n        return dp[i][j]=ans;\\n    }\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        \\n        int n=board.size();\\n        int m=board[0].size();\\n        vector<vector<pair<long long,long long>>> dp(n,vector<pair<long long,long long>>(m,{-1,-1}));\\n        pair<long long,long long> p=helper(n-1,m-1,n,m,board,dp);\\n        vector<int> ans;\\n        if(p.first<0 || p.second<0){\\n            return {0,0};\\n        }\\n        ans.push_back(p.first);\\n        ans.push_back(p.second);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    #define mod 1000000007\\n    pair<long long,long long> helper(int i,int j,int n,int m,vector<string>&arr,vector<vector<pair<long long,long long>>>&dp){\\n        \\n        if(i<0 || j<0 || i>=n || j>=m || arr[i][j]==\\'X\\'){\\n           return {-1e9,-1e9}",
                "codeTag": "Java"
            },
            {
                "id": 3939577,
                "title": "heavily-commented-tabulation-start-from-back",
                "content": "maintain two vector\\n1) for getting the maximum value (say maxi) upto this cell\\n2) no. of path to reach  that cell cell where we are getting the value, maxi\\n3) set the base conditions like\\n\\n       // Convert the start and end cells to \\'0\\'\\n        board[n - 1][n - 1] = board[0][0] = \\'0\\';\\n        \\n        // Set the count of paths for the destination cell to 1\\n        cnt[n - 1][n - 1] = 1;\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int mod = 1000000007;\\n        int n = board.size();\\n        \\n        // Initialize dp array and cnt array\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1));\\n        vector<vector<int>> cnt(n + 1, vector<int>(n + 1));\\n        \\n        // Convert the start and end cells to \\'0\\'\\n        board[n - 1][n - 1] = board[0][0] = \\'0\\';\\n        \\n        // Set the count of paths for the destination cell to 1\\n        cnt[n - 1][n - 1] = 1;\\n        \\n        // Iterate through the board in reverse order\\n        for (int i = n - 1; i >= 0; --i) {\\n            for (int j = n - 1; j >= 0; --j) {\\n                if (board[i][j] != \\'X\\') {\\n                    // Find the maximum value among the three possible moves\\n                    int m = max({dp[i + 1][j], dp[i][j + 1], dp[i + 1][j + 1]});\\n                    \\n                    // Calculate the new dp value for the current cell\\n                    dp[i][j] = (board[i][j] - \\'0\\') + m;\\n                    \\n                    // Update the count of paths for the current cell based on the moves that contribute to the maximum value\\n                     // If the cell below has the same maximum value\\n            if (dp[i + 1][j] == m)\\n                cnt[i][j] = (cnt[i][j] + cnt[i + 1][j]) % mod;\\n            \\n            // If the cell to the right has the same maximum value\\n            if (dp[i][j + 1] == m)\\n                cnt[i][j] = (cnt[i][j] + cnt[i][j + 1]) % mod;\\n            \\n            // If the diagonal cell has the same maximum value\\n            if (dp[i + 1][j + 1] == m)\\n                cnt[i][j] = (cnt[i][j] + cnt[i + 1][j + 1]) % mod;\\n                }\\n            }\\n        }\\n        \\n        // Return the result as a vector\\n       // Return a pair containing two values:\\n// 1. If cnt[0][0] is non-zero (paths are possible), return dp[0][0], otherwise return 0\\n// 2. Return the value of cnt[0][0] as the second value of the pair\\nreturn {cnt[0][0] ? dp[0][0] : 0, cnt[0][0]};\\n\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int mod = 1000000007;\\n        int n = board.size();\\n        \\n        // Initialize dp array and cnt array\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1));\\n        vector<vector<int>> cnt(n + 1, vector<int>(n + 1));\\n        \\n        // Convert the start and end cells to \\'0\\'\\n        board[n - 1][n - 1] = board[0][0] = \\'0\\';\\n        \\n        // Set the count of paths for the destination cell to 1\\n        cnt[n - 1][n - 1] = 1;\\n        \\n        // Iterate through the board in reverse order\\n        for (int i = n - 1; i >= 0; --i) {\\n            for (int j = n - 1; j >= 0; --j) {\\n                if (board[i][j] != \\'X\\') {\\n                    // Find the maximum value among the three possible moves\\n                    int m = max({dp[i + 1][j], dp[i][j + 1], dp[i + 1][j + 1]});\\n                    \\n                    // Calculate the new dp value for the current cell\\n                    dp[i][j] = (board[i][j] - \\'0\\') + m;\\n                    \\n                    // Update the count of paths for the current cell based on the moves that contribute to the maximum value\\n                     // If the cell below has the same maximum value\\n            if (dp[i + 1][j] == m)\\n                cnt[i][j] = (cnt[i][j] + cnt[i + 1][j]) % mod;\\n            \\n            // If the cell to the right has the same maximum value\\n            if (dp[i][j + 1] == m)\\n                cnt[i][j] = (cnt[i][j] + cnt[i][j + 1]) % mod;\\n            \\n            // If the diagonal cell has the same maximum value\\n            if (dp[i + 1][j + 1] == m)\\n                cnt[i][j] = (cnt[i][j] + cnt[i + 1][j + 1]) % mod;\\n                }\\n            }\\n        }\\n        \\n        // Return the result as a vector\\n       // Return a pair containing two values:\\n// 1. If cnt[0][0] is non-zero (paths are possible), return dp[0][0], otherwise return 0\\n// 2. Return the value of cnt[0][0] as the second value of the pair\\nreturn {cnt[0][0] ? dp[0][0] : 0, cnt[0][0]};\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930150,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  vector<int> pathsWithMaxScore(vector<string>& board) {\\n    constexpr int kMod = 1\\'000\\'000\\'007;\\n    const int n = board.size();\\n    const vector<pair<int, int>> dirs{{0, 1}, {1, 0}, {1, 1}};\\n    // dp[i][j] := max sum from (n - 1, n - 1) -> (i, j)\\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));\\n    // count[i][j] := # of paths to get dp[i][j] from (n - 1, n - 1) -> (i, j)\\n    vector<vector<int>> count(n + 1, vector<int>(n + 1));\\n\\n    dp[0][0] = 0;\\n    dp[n - 1][n - 1] = 0;\\n    count[n - 1][n - 1] = 1;\\n\\n    for (int i = n - 1; i >= 0; --i)\\n      for (int j = n - 1; j >= 0; --j) {\\n        if (board[i][j] == \\'S\\' || board[i][j] == \\'X\\')\\n          continue;\\n        for (const auto& [dx, dy] : dirs) {\\n          const int x = i + dx;\\n          const int y = j + dy;\\n          if (dp[i][j] < dp[x][y]) {\\n            dp[i][j] = dp[x][y];\\n            count[i][j] = count[x][y];\\n          } else if (dp[i][j] == dp[x][y]) {\\n            count[i][j] += count[x][y];\\n            count[i][j] %= kMod;\\n          }\\n        }\\n        // If there\\'s path(s) from \\'S\\' to (i, j)\\n        // And the cell is not \\'E\\'\\n        if (dp[i][j] != -1 && board[i][j] != \\'E\\') {\\n          dp[i][j] += board[i][j] - \\'0\\';\\n          dp[i][j] %= kMod;\\n        }\\n      }\\n\\n    return {dp[0][0], count[0][0]};\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  vector<int> pathsWithMaxScore(vector<string>& board) {\\n    constexpr int kMod = 1\\'000\\'000\\'007;\\n    const int n = board.size();\\n    const vector<pair<int, int>> dirs{{0, 1}, {1, 0}, {1, 1}};\\n    // dp[i][j] := max sum from (n - 1, n - 1) -> (i, j)\\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, -1));\\n    // count[i][j] := # of paths to get dp[i][j] from (n - 1, n - 1) -> (i, j)\\n    vector<vector<int>> count(n + 1, vector<int>(n + 1));\\n\\n    dp[0][0] = 0;\\n    dp[n - 1][n - 1] = 0;\\n    count[n - 1][n - 1] = 1;\\n\\n    for (int i = n - 1; i >= 0; --i)\\n      for (int j = n - 1; j >= 0; --j) {\\n        if (board[i][j] == \\'S\\' || board[i][j] == \\'X\\')\\n          continue;\\n        for (const auto& [dx, dy] : dirs) {\\n          const int x = i + dx;\\n          const int y = j + dy;\\n          if (dp[i][j] < dp[x][y]) {\\n            dp[i][j] = dp[x][y];\\n            count[i][j] = count[x][y];\\n          } else if (dp[i][j] == dp[x][y]) {\\n            count[i][j] += count[x][y];\\n            count[i][j] %= kMod;\\n          }\\n        }\\n        // If there\\'s path(s) from \\'S\\' to (i, j)\\n        // And the cell is not \\'E\\'\\n        if (dp[i][j] != -1 && board[i][j] != \\'E\\') {\\n          dp[i][j] += board[i][j] - \\'0\\';\\n          dp[i][j] %= kMod;\\n        }\\n      }\\n\\n    return {dp[0][0], count[0][0]};\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893686,
                "title": "javascript-dynamic-programming-time-o-n-n-space-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nvar pathsWithMaxScore = function(board) {\\n    const n = board.length, m = board[0].length, mod = 1_000_000_007;\\n    let prev = Array.from({ length: m + 1 }, () => [0, 0]);\\n\\n    prev[0][1] = 1;\\n\\n    for (let i = 0; i < n; i < i++) {\\n        const cur = Array.from({ length: m + 1 }, () => [0, 0]);\\n\\n        for (let j = 0; j < m; j++) {\\n            if (board[i][j] == \"X\") continue;\\n\\n            const prevPositions = [prev[j], prev[j + 1], cur[j]];\\n            const maxPrevSum = Math.max(...prevPositions.map(([sum]) => sum));            \\n            cur[j + 1] = prevPositions.reduce((acc, [sum, ways]) => \\n                    (sum === maxPrevSum ? [sum, (acc[1] + ways) % mod] : acc), [0, 0]);\\n            if (cur[j + 1][1] > 0)\\n                cur[j + 1][0] += isNaN(board[i][j]) ? 0 : +board[i][j];\\n        }\\n\\n        prev = cur;\\n    }\\n\\n    return prev.at(-1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar pathsWithMaxScore = function(board) {\\n    const n = board.length, m = board[0].length, mod = 1_000_000_007;\\n    let prev = Array.from({ length: m + 1 }, () => [0, 0]);\\n\\n    prev[0][1] = 1;\\n\\n    for (let i = 0; i < n; i < i++) {\\n        const cur = Array.from({ length: m + 1 }, () => [0, 0]);\\n\\n        for (let j = 0; j < m; j++) {\\n            if (board[i][j] == \"X\") continue;\\n\\n            const prevPositions = [prev[j], prev[j + 1], cur[j]];\\n            const maxPrevSum = Math.max(...prevPositions.map(([sum]) => sum));            \\n            cur[j + 1] = prevPositions.reduce((acc, [sum, ways]) => \\n                    (sum === maxPrevSum ? [sum, (acc[1] + ways) % mod] : acc), [0, 0]);\\n            if (cur[j + 1][1] > 0)\\n                cur[j + 1][0] += isNaN(board[i][j]) ? 0 : +board[i][j];\\n        }\\n\\n        prev = cur;\\n    }\\n\\n    return prev.at(-1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3892578,
                "title": "top-down-approach-using-c",
                "content": "# Complexity\\n- Time complexity:\\n O(NxM)\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    private int mod = (int)1e9+7;\\n    private int rl;\\n    private int cl;\\n\\n    private Dictionary<(int,int), int[]> cache = new Dictionary<(int,int), int[]>();\\n    public int[] PathsWithMaxScore(IList<string> board) {\\n        rl = board.Count;\\n        cl = board[0].Length;\\n        int[] ans = f(board,0,0);\\n        if(ans[1] == 0) return new int[]{0,0};\\n        return ans;\\n    }\\n\\n    //get the maximum sum\\n    private int[] f(IList<string> b, int r, int c){\\n        if(r >= rl || c >= cl) return new int[]{0,0};\\n        if(cache.ContainsKey((r,c))) return cache[(r,c)];\\n        int temp = 0;\\n        if(b[r][c] == \\'S\\'){\\n            return new int[]{0,1};\\n        }\\n        int[] p1 = new int[2];\\n        int[] p2 = new int[2];\\n        int[] p3 = new int[2];\\n        if( Char.IsDigit(b[r][c]) || (b[r][c] == \\'E\\')){\\n            p1 = f(b,r+1,c); \\n            p2 = f(b,r,c+1);\\n            p3 = f(b,r+1,c+1);\\n        }\\n        temp = max(p1[0],p2[0],p3[0]);\\n        int val = 0;\\n        if(Char.IsDigit(b[r][c])){\\n            val = b[r][c] - \\'0\\';\\n        }\\n        int count = 0;\\n        if(p1[0] == temp){\\n            count += p1[1];\\n        }\\n        if(p2[0] == temp){\\n             count += p2[1];\\n        }\\n        if(p3[0] == temp){\\n             count += p3[1];\\n        }\\n        int[] x = new int[]{temp+val,count%mod};\\n        cache[(r,c)] =x;\\n        return x;\\n    }\\n    private int max(int a, int b ,int c) => Math.Max(a, Math.Max(b,c));\\n\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Memoization"
                ],
                "code": "```\\npublic class Solution {\\n    private int mod = (int)1e9+7;\\n    private int rl;\\n    private int cl;\\n\\n    private Dictionary<(int,int), int[]> cache = new Dictionary<(int,int), int[]>();\\n    public int[] PathsWithMaxScore(IList<string> board) {\\n        rl = board.Count;\\n        cl = board[0].Length;\\n        int[] ans = f(board,0,0);\\n        if(ans[1] == 0) return new int[]{0,0};\\n        return ans;\\n    }\\n\\n    //get the maximum sum\\n    private int[] f(IList<string> b, int r, int c){\\n        if(r >= rl || c >= cl) return new int[]{0,0};\\n        if(cache.ContainsKey((r,c))) return cache[(r,c)];\\n        int temp = 0;\\n        if(b[r][c] == \\'S\\'){\\n            return new int[]{0,1};\\n        }\\n        int[] p1 = new int[2];\\n        int[] p2 = new int[2];\\n        int[] p3 = new int[2];\\n        if( Char.IsDigit(b[r][c]) || (b[r][c] == \\'E\\')){\\n            p1 = f(b,r+1,c); \\n            p2 = f(b,r,c+1);\\n            p3 = f(b,r+1,c+1);\\n        }\\n        temp = max(p1[0],p2[0],p3[0]);\\n        int val = 0;\\n        if(Char.IsDigit(b[r][c])){\\n            val = b[r][c] - \\'0\\';\\n        }\\n        int count = 0;\\n        if(p1[0] == temp){\\n            count += p1[1];\\n        }\\n        if(p2[0] == temp){\\n             count += p2[1];\\n        }\\n        if(p3[0] == temp){\\n             count += p3[1];\\n        }\\n        int[] x = new int[]{temp+val,count%mod};\\n        cache[(r,c)] =x;\\n        return x;\\n    }\\n    private int max(int a, int b ,int c) => Math.Max(a, Math.Max(b,c));\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825896,
                "title": "i-have-won-but-at-what-cost-o-n-space-complexity-solution-beat-100-js-both-time-and-memory",
                "content": "![image.png](https://assets.leetcode.com/users/images/3f1c1480-c33e-41fc-b799-f0f508b57921_1690491317.1034803.png)\\n\\n# Intuition\\nJust a classic DP problem...\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```jsx\\n// The code below wasn\\'t writen to be readable, it is for runtime optimization.\\n\\n/**\\n * @param {string[]} board\\n * @return {number[]}\\n */\\nvar pathsWithMaxScore = function (board) {\\n  const MOD = 1000000007;\\n  const n = board.length;\\n\\n  const maxRow = Array(n).fill(0);\\n  maxRow[-1] = 0;\\n  const cntRow = Array(n).fill(0);\\n  cntRow[-1] = 0;\\n\\n  function getVal(r, c) {\\n    const char = board[r][c];\\n    if (char >= \"0\" && char <= \"9\") return char.charCodeAt() - 48;\\n    return 0;\\n  }\\n\\n  let maxBak, cntBak, maxCur, cntCur;\\n  for (let r = 0; r < n; r++) {\\n    maxCur = 0;\\n    cntCur = 0;\\n\\n    for (let c = 0; c < n; c++) {\\n      maxBak = maxCur;\\n      cntBak = cntCur;\\n      maxCur = maxRow[c];\\n      cntCur = cntRow[c];\\n      const v = getVal(r, c);\\n\\n      if (board[r][c] === \"E\") {\\n        cntRow[c] = 1;\\n        maxRow[c] = v;\\n        continue;\\n      }\\n      if (board[r][c] === \"X\" || !(cntRow[c] || cntRow[c-1] || cntBak)) {\\n        cntRow[c] = 0;\\n        maxRow[c] = 0;\\n        continue;\\n      }\\n\\n      if (maxRow[c] < maxRow[c-1]) {\\n        cntRow[c] = cntRow[c-1];\\n        maxRow[c] = maxRow[c-1];\\n      } else if (maxRow[c] === maxRow[c-1]) {\\n        cntRow[c] = (cntRow[c] + cntRow[c-1]) % MOD;\\n      }\\n\\n      if (maxRow[c] < maxBak) {\\n        cntRow[c] = cntBak;\\n        maxRow[c] = maxBak;\\n      } else if (maxRow[c] === maxBak) {\\n        cntRow[c] = (cntRow[c] + cntBak) % MOD;\\n      }\\n\\n      maxRow[c] += v;\\n    }\\n  }\\n\\n  return [maxRow[n - 1], cntRow[n - 1]];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```jsx\\n// The code below wasn\\'t writen to be readable, it is for runtime optimization.\\n\\n/**\\n * @param {string[]} board\\n * @return {number[]}\\n */\\nvar pathsWithMaxScore = function (board) {\\n  const MOD = 1000000007;\\n  const n = board.length;\\n\\n  const maxRow = Array(n).fill(0);\\n  maxRow[-1] = 0;\\n  const cntRow = Array(n).fill(0);\\n  cntRow[-1] = 0;\\n\\n  function getVal(r, c) {\\n    const char = board[r][c];\\n    if (char >= \"0\" && char <= \"9\") return char.charCodeAt() - 48;\\n    return 0;\\n  }\\n\\n  let maxBak, cntBak, maxCur, cntCur;\\n  for (let r = 0; r < n; r++) {\\n    maxCur = 0;\\n    cntCur = 0;\\n\\n    for (let c = 0; c < n; c++) {\\n      maxBak = maxCur;\\n      cntBak = cntCur;\\n      maxCur = maxRow[c];\\n      cntCur = cntRow[c];\\n      const v = getVal(r, c);\\n\\n      if (board[r][c] === \"E\") {\\n        cntRow[c] = 1;\\n        maxRow[c] = v;\\n        continue;\\n      }\\n      if (board[r][c] === \"X\" || !(cntRow[c] || cntRow[c-1] || cntBak)) {\\n        cntRow[c] = 0;\\n        maxRow[c] = 0;\\n        continue;\\n      }\\n\\n      if (maxRow[c] < maxRow[c-1]) {\\n        cntRow[c] = cntRow[c-1];\\n        maxRow[c] = maxRow[c-1];\\n      } else if (maxRow[c] === maxRow[c-1]) {\\n        cntRow[c] = (cntRow[c] + cntRow[c-1]) % MOD;\\n      }\\n\\n      if (maxRow[c] < maxBak) {\\n        cntRow[c] = cntBak;\\n        maxRow[c] = maxBak;\\n      } else if (maxRow[c] === maxBak) {\\n        cntRow[c] = (cntRow[c] + cntBak) % MOD;\\n      }\\n\\n      maxRow[c] += v;\\n    }\\n  }\\n\\n  return [maxRow[n - 1], cntRow[n - 1]];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3808419,
                "title": "swift-bottom-up-approach-100-beating-tc-o-n-2-sc-o-n",
                "content": "# Intuition\\nSounded similar to https://leetcode.com/problems/minimum-path-sum/description/ but with diagonal move and obstacles\\n\\n# Approach\\nCount maximum sum and number of repeats in parallel.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    private let values: [Character: Int] = [\\n        \"1\": 1,\\n        \"2\": 2,\\n        \"3\": 3,\\n        \"4\": 4,\\n        \"5\": 5,\\n        \"6\": 6,\\n        \"7\": 7,\\n        \"8\": 8,\\n        \"9\": 9,\\n        \"E\": 0,\\n        \"S\": 0\\n    ]\\n\\n    func pathsWithMaxScore(_ board: [String]) -> [Int] {\\n        let characters = board.map { Array($0) }\\n        let size = board.count\\n        var sums = Array(repeating: Int.min, count: size)\\n        sums[0] = 0\\n        for i in 1..<size {\\n            guard let value = values[characters[0][i]] else { break }\\n            sums[i] = sums[i-1] + value\\n        }\\n\\n        var nextSums = Array(repeating: Int.min, count: size)\\n\\n        var repeats = Array(repeating: 1, count: size)\\n        var nextRepeats = Array(repeating: 1, count: size)\\n        \\n        for i in 1..<size {\\n            if let value = values[characters[i][0]] {\\n                nextSums[0] = sums[0] == .min ? .min : (sums[0] + value)\\n            }\\n\\n            for j in 1..<size {\\n                guard let value = values[characters[i][j]] else {\\n                    continue\\n                }\\n                if sums[j] == nextSums[j-1] {\\n                    if nextSums[j-1] == .min {\\n                        nextSums[j] = sums[j-1] == .min ? .min : (sums[j-1] + value)\\n                        nextRepeats[j] = repeats[j-1]\\n                    } else {\\n                        nextSums[j] = sums[j] + value\\n                        nextRepeats[j] = (repeats[j] + nextRepeats[j-1]) % 1000000007\\n                    }\\n                    continue\\n                }\\n                \\n                if sums[j] > nextSums[j-1] {\\n                    nextSums[j] = sums[j] + value\\n                    nextRepeats[j] = repeats[j]\\n                } else {\\n                    nextSums[j] = nextSums[j-1] + value\\n                    nextRepeats[j] = nextRepeats[j-1]\\n                }\\n            }\\n\\n            sums = nextSums\\n            repeats = nextRepeats\\n            nextSums = Array(repeating: .min, count: size)\\n            nextRepeats = Array(repeating: 1, count: size)\\n        }\\n        \\n        if sums[size-1] == .min { return [0,0] }\\n        return [sums[size-1], repeats[size-1]]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    private let values: [Character: Int] = [\\n        \"1\": 1,\\n        \"2\": 2,\\n        \"3\": 3,\\n        \"4\": 4,\\n        \"5\": 5,\\n        \"6\": 6,\\n        \"7\": 7,\\n        \"8\": 8,\\n        \"9\": 9,\\n        \"E\": 0,\\n        \"S\": 0\\n    ]\\n\\n    func pathsWithMaxScore(_ board: [String]) -> [Int] {\\n        let characters = board.map { Array($0) }\\n        let size = board.count\\n        var sums = Array(repeating: Int.min, count: size)\\n        sums[0] = 0\\n        for i in 1..<size {\\n            guard let value = values[characters[0][i]] else { break }\\n            sums[i] = sums[i-1] + value\\n        }\\n\\n        var nextSums = Array(repeating: Int.min, count: size)\\n\\n        var repeats = Array(repeating: 1, count: size)\\n        var nextRepeats = Array(repeating: 1, count: size)\\n        \\n        for i in 1..<size {\\n            if let value = values[characters[i][0]] {\\n                nextSums[0] = sums[0] == .min ? .min : (sums[0] + value)\\n            }\\n\\n            for j in 1..<size {\\n                guard let value = values[characters[i][j]] else {\\n                    continue\\n                }\\n                if sums[j] == nextSums[j-1] {\\n                    if nextSums[j-1] == .min {\\n                        nextSums[j] = sums[j-1] == .min ? .min : (sums[j-1] + value)\\n                        nextRepeats[j] = repeats[j-1]\\n                    } else {\\n                        nextSums[j] = sums[j] + value\\n                        nextRepeats[j] = (repeats[j] + nextRepeats[j-1]) % 1000000007\\n                    }\\n                    continue\\n                }\\n                \\n                if sums[j] > nextSums[j-1] {\\n                    nextSums[j] = sums[j] + value\\n                    nextRepeats[j] = repeats[j]\\n                } else {\\n                    nextSums[j] = nextSums[j-1] + value\\n                    nextRepeats[j] = nextRepeats[j-1]\\n                }\\n            }\\n\\n            sums = nextSums\\n            repeats = nextRepeats\\n            nextSums = Array(repeating: .min, count: size)\\n            nextRepeats = Array(repeating: 1, count: size)\\n        }\\n        \\n        if sums[size-1] == .min { return [0,0] }\\n        return [sums[size-1], repeats[size-1]]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784194,
                "title": "1732-ms-bfs-java-dp",
                "content": "```\\nclass Solution {\\n    private static int[][] DIR = {{0, -1}, {-1, 0}, {-1, -1}};\\n    private static final int mod = (int) 1e9 + 7;\\n\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int m = board.size();\\n        int n = board.get(0).length();\\n        Queue<int[]> q = new ArrayDeque<>();\\n        int[][] sumDP = new int[m][n];\\n        int[][] countDP = new int[m][n];\\n        countDP[m - 1][n - 1] = 1;\\n        // {row, col}\\n        int[] ans = {0, 0};\\n        q.offer(new int[]{m - 1, n - 1, 0});\\n        while(!q.isEmpty()) {\\n            int[] node = q.poll();\\n            int x = node[0], y = node[1], sum = node[2];\\n            for(int[] dr : DIR) {\\n                int i = x + dr[0];\\n                int j = y + dr[1];\\n                if(i < 0 || j < 0) continue;\\n                char ch = board.get(i).charAt(j);\\n                if(ch == \\'X\\') continue;\\n                int newSum = ch == \\'E\\' ? sum : sum + ch - \\'0\\';\\n                if(newSum > sumDP[i][j]) {\\n                    sumDP[i][j] = newSum;\\n                    countDP[i][j] = countDP[x][y];\\n                    q.offer(new int[]{i, j, newSum});\\n                }\\n                else if(newSum == sumDP[i][j]) {\\n                    countDP[i][j] += countDP[x][y];\\n                    countDP[i][j] %= mod;\\n                }\\n            }\\n        }\\n        ans[0] = sumDP[0][0];\\n        ans[1] = countDP[0][0];\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private static int[][] DIR = {{0, -1}, {-1, 0}, {-1, -1}};\\n    private static final int mod = (int) 1e9 + 7;\\n\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int m = board.size();\\n        int n = board.get(0).length();\\n        Queue<int[]> q = new ArrayDeque<>();\\n        int[][] sumDP = new int[m][n];\\n        int[][] countDP = new int[m][n];\\n        countDP[m - 1][n - 1] = 1;\\n        // {row, col}\\n        int[] ans = {0, 0};\\n        q.offer(new int[]{m - 1, n - 1, 0});\\n        while(!q.isEmpty()) {\\n            int[] node = q.poll();\\n            int x = node[0], y = node[1], sum = node[2];\\n            for(int[] dr : DIR) {\\n                int i = x + dr[0];\\n                int j = y + dr[1];\\n                if(i < 0 || j < 0) continue;\\n                char ch = board.get(i).charAt(j);\\n                if(ch == \\'X\\') continue;\\n                int newSum = ch == \\'E\\' ? sum : sum + ch - \\'0\\';\\n                if(newSum > sumDP[i][j]) {\\n                    sumDP[i][j] = newSum;\\n                    countDP[i][j] = countDP[x][y];\\n                    q.offer(new int[]{i, j, newSum});\\n                }\\n                else if(newSum == sumDP[i][j]) {\\n                    countDP[i][j] += countDP[x][y];\\n                    countDP[i][j] %= mod;\\n                }\\n            }\\n        }\\n        ans[0] = sumDP[0][0];\\n        ans[1] = countDP[0][0];\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747141,
                "title": "java-memo-search-4ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraverse back from end point to start point.\\n\\nA point [x, y] can be reached from 3 previous points: right: [x, y+1], down: [x+1, y] or diagonal: [x+1, y+1].\\n\\nThe number on point[x, y] is fixed, so the previous point with max score forms the path with max score.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBoth the max score and count of paths need be recorded. The class `State` is created to record them. The memo array remains to be a 2D array.\\n\\nNote the diagonal point always has smaller score, it\\'s searched only when right/down points are blocked. Though with memoization this doesn\\'t make much difference since data are cached.\\n\\nThe paths count of current point is same as the count from right/down/diagonal point. Only when right & down points have same max score, the paths count is summed from both. This also means the modulo calculation is only needed when count summed, it would save some time.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n\\n# Runtime\\n4ms\\n\\n# Code\\n```\\nclass Solution {\\n    static int MOD = 1_000_000_000 + 7;\\n    static int[] NUMS = new int[100];\\n    static {\\n        for (int i = 0; i < 9; i++) {\\n            NUMS[i + \\'1\\'] = i + 1;\\n        }\\n        NUMS[\\'E\\'] = 0;\\n    }\\n\\n    int border;\\n    byte[][] chars;\\n\\n    State[][] memo;\\n\\n    static class State {\\n        // The max score\\n        int score = 0;\\n\\n        // The count of paths to get max score\\n        int count = 0;\\n\\n        public State() {}\\n        public State(int score, int count) {\\n            this.score = score;\\n            this.count = count;\\n        }\\n    }\\n\\n    private State search(int row, int column) {\\n        if (memo[row][column] != null) {\\n            return memo[row][column];\\n        }\\n        if (chars[row][column] == \\'X\\') {\\n            return memo[row][column] = new State();\\n        }\\n\\n        State result = new State();\\n\\n        if (row < border && column < border) {\\n            // Search down\\n            State down = search(row + 1, column);\\n            // Search right\\n            State right = search(row, column + 1);\\n\\n            // When down/right path exists, it always has bigger score than diagonal path\\n            if (down.count > 0 || right.count > 0) {\\n                if (down.score > right.score) {\\n                    result.score = down.score + NUMS[chars[row][column]];\\n                    result.count = down.count;\\n                } else if (down.score < right.score) {\\n                    result.score = right.score + NUMS[chars[row][column]];\\n                    result.count = right.count;\\n                } else {\\n                    result.score = down.score + NUMS[chars[row][column]];\\n                    result.count = down.count + right.count;\\n                    // MOD is only needed when count is summed\\n                    if (result.count > MOD) {\\n                        result.count %= MOD;\\n                    }\\n                }\\n            } else {\\n                // Only search diagonal path if down & right path not avaiable\\n                State diagonal = search(row + 1, column + 1);\\n                if (diagonal.count > 0) {\\n                    result.score = diagonal.score + NUMS[chars[row][column]];\\n                    result.count = diagonal.count;\\n                }\\n            }\\n        } else if (row < border) {\\n            // At right border, can only search down\\n            State state = search(row + 1, column);\\n            if (state.count > 0) {\\n                result.score = state.score + NUMS[chars[row][column]];\\n                result.count = state.count;\\n            }\\n        } else if (column < border) {\\n            // At bottom border, can only search right\\n            State state = search(row, column + 1);\\n            if (state.count > 0) {\\n                result.score = state.score + NUMS[chars[row][column]];\\n                result.count = state.count;\\n            }\\n        }\\n\\n        return memo[row][column] = result;\\n    }\\n\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int len = board.size();\\n        border = len - 1;\\n\\n        // Get board chars\\n        chars = new byte[len][len];\\n        for (int i = 0; i < len; i++) {\\n            chars[i] = board.get(i).getBytes();\\n        }\\n\\n        // Create state memo\\n        memo = new State[len][len];\\n\\n        // Initially the start point has 0 score, and 1 path count\\n        memo[border][border] = new State(0, 1);\\n\\n        // Traverse back from end point [0, 0]\\n        State result = search(0, 0);\\n\\n        return new int[]{result.score, result.count};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    static int MOD = 1_000_000_000 + 7;\\n    static int[] NUMS = new int[100];\\n    static {\\n        for (int i = 0; i < 9; i++) {\\n            NUMS[i + \\'1\\'] = i + 1;\\n        }\\n        NUMS[\\'E\\'] = 0;\\n    }\\n\\n    int border;\\n    byte[][] chars;\\n\\n    State[][] memo;\\n\\n    static class State {\\n        // The max score\\n        int score = 0;\\n\\n        // The count of paths to get max score\\n        int count = 0;\\n\\n        public State() {}\\n        public State(int score, int count) {\\n            this.score = score;\\n            this.count = count;\\n        }\\n    }\\n\\n    private State search(int row, int column) {\\n        if (memo[row][column] != null) {\\n            return memo[row][column];\\n        }\\n        if (chars[row][column] == \\'X\\') {\\n            return memo[row][column] = new State();\\n        }\\n\\n        State result = new State();\\n\\n        if (row < border && column < border) {\\n            // Search down\\n            State down = search(row + 1, column);\\n            // Search right\\n            State right = search(row, column + 1);\\n\\n            // When down/right path exists, it always has bigger score than diagonal path\\n            if (down.count > 0 || right.count > 0) {\\n                if (down.score > right.score) {\\n                    result.score = down.score + NUMS[chars[row][column]];\\n                    result.count = down.count;\\n                } else if (down.score < right.score) {\\n                    result.score = right.score + NUMS[chars[row][column]];\\n                    result.count = right.count;\\n                } else {\\n                    result.score = down.score + NUMS[chars[row][column]];\\n                    result.count = down.count + right.count;\\n                    // MOD is only needed when count is summed\\n                    if (result.count > MOD) {\\n                        result.count %= MOD;\\n                    }\\n                }\\n            } else {\\n                // Only search diagonal path if down & right path not avaiable\\n                State diagonal = search(row + 1, column + 1);\\n                if (diagonal.count > 0) {\\n                    result.score = diagonal.score + NUMS[chars[row][column]];\\n                    result.count = diagonal.count;\\n                }\\n            }\\n        } else if (row < border) {\\n            // At right border, can only search down\\n            State state = search(row + 1, column);\\n            if (state.count > 0) {\\n                result.score = state.score + NUMS[chars[row][column]];\\n                result.count = state.count;\\n            }\\n        } else if (column < border) {\\n            // At bottom border, can only search right\\n            State state = search(row, column + 1);\\n            if (state.count > 0) {\\n                result.score = state.score + NUMS[chars[row][column]];\\n                result.count = state.count;\\n            }\\n        }\\n\\n        return memo[row][column] = result;\\n    }\\n\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int len = board.size();\\n        border = len - 1;\\n\\n        // Get board chars\\n        chars = new byte[len][len];\\n        for (int i = 0; i < len; i++) {\\n            chars[i] = board.get(i).getBytes();\\n        }\\n\\n        // Create state memo\\n        memo = new State[len][len];\\n\\n        // Initially the start point has 0 score, and 1 path count\\n        memo[border][border] = new State(0, 1);\\n\\n        // Traverse back from end point [0, 0]\\n        State result = search(0, 0);\\n\\n        return new int[]{result.score, result.count};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691633,
                "title": "c-tabulation",
                "content": "# Intuition\\nA 3-D matrix can be used to store the max value and total path with max sum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(N^2)$$\\n- Space complexity:\\n$$O(N^2)$$\\n# Code\\n```\\nint mod=1e9+7;\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int n=board.size(),m=board[0].length();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(2, 0)));\\n        dp[n-1][m-1][1]=1;\\n        for(int i=m-2;i>=0;i--){\\n            if(board[n-1][i]==\\'X\\' || dp[n-1][i+1][0]==-1) dp[n-1][i][0]=-1;\\n            else{\\n                dp[n-1][i][0]=dp[n-1][i+1][0]+board[n-1][i]-\\'0\\';\\n                dp[n-1][i][1]=1;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(board[i][m-1]==\\'X\\' || dp[i+1][m-1][0]==-1) dp[i][m-1][0]=-1;\\n            else{\\n                dp[i][m-1][0]=dp[i+1][m-1][0]+board[i][m-1]-\\'0\\';\\n                dp[i][m-1][1]=1;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=m-2;j>=0;j--){\\n                if( board[i][j]==\\'X\\' ) dp[i][j][0]=-1;\\n                else if(board[i][j]==\\'E\\') {\\n                    int mx=max(dp[i+1][j][0], max(dp[i+1][j+1][0],dp[i][j+1][0]));\\n                    if(mx==-1) dp[i][j][0]=-1;\\n                    else{\\n                        dp[i][j][0]=mx;\\n                        if(dp[i+1][j][0]==mx) dp[i][j][1]=(dp[i][j][1]+dp[i+1][j][1])%mod;\\n                        if(dp[i+1][j+1][0]==mx) dp[i][j][1]=(dp[i][j][1]+dp[i+1][j+1][1])%mod;\\n                        if(dp[i][j+1][0]==mx) dp[i][j][1]=(dp[i][j][1]+dp[i][j+1][1])%mod;\\n                    } \\n                    return {max(mx,0), dp[0][0][1]};\\n                }\\n                else{\\n                    int mx=max(dp[i+1][j][0], max(dp[i+1][j+1][0],dp[i][j+1][0]));\\n                    if(mx==-1) dp[i][j][0]=-1;\\n                    else{\\n                        dp[i][j][0]=board[i][j]-\\'0\\'+mx;\\n                        if(dp[i+1][j][0]==mx) dp[i][j][1]=(dp[i][j][1]+dp[i+1][j][1])%mod;\\n                        if(dp[i+1][j+1][0]==mx) dp[i][j][1]=(dp[i][j][1]+dp[i+1][j+1][1])%mod;\\n                        if(dp[i][j+1][0]==mx) dp[i][j][1]=(dp[i][j][1]+dp[i][j+1][1])%mod;\\n                    } \\n                }\\n            }\\n        }\\n        return {};\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nint mod=1e9+7;\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int n=board.size(),m=board[0].length();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(2, 0)));\\n        dp[n-1][m-1][1]=1;\\n        for(int i=m-2;i>=0;i--){\\n            if(board[n-1][i]==\\'X\\' || dp[n-1][i+1][0]==-1) dp[n-1][i][0]=-1;\\n            else{\\n                dp[n-1][i][0]=dp[n-1][i+1][0]+board[n-1][i]-\\'0\\';\\n                dp[n-1][i][1]=1;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(board[i][m-1]==\\'X\\' || dp[i+1][m-1][0]==-1) dp[i][m-1][0]=-1;\\n            else{\\n                dp[i][m-1][0]=dp[i+1][m-1][0]+board[i][m-1]-\\'0\\';\\n                dp[i][m-1][1]=1;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=m-2;j>=0;j--){\\n                if( board[i][j]==\\'X\\' ) dp[i][j][0]=-1;\\n                else if(board[i][j]==\\'E\\') {\\n                    int mx=max(dp[i+1][j][0], max(dp[i+1][j+1][0],dp[i][j+1][0]));\\n                    if(mx==-1) dp[i][j][0]=-1;\\n                    else{\\n                        dp[i][j][0]=mx;\\n                        if(dp[i+1][j][0]==mx) dp[i][j][1]=(dp[i][j][1]+dp[i+1][j][1])%mod;\\n                        if(dp[i+1][j+1][0]==mx) dp[i][j][1]=(dp[i][j][1]+dp[i+1][j+1][1])%mod;\\n                        if(dp[i][j+1][0]==mx) dp[i][j][1]=(dp[i][j][1]+dp[i][j+1][1])%mod;\\n                    } \\n                    return {max(mx,0), dp[0][0][1]};\\n                }\\n                else{\\n                    int mx=max(dp[i+1][j][0], max(dp[i+1][j+1][0],dp[i][j+1][0]));\\n                    if(mx==-1) dp[i][j][0]=-1;\\n                    else{\\n                        dp[i][j][0]=board[i][j]-\\'0\\'+mx;\\n                        if(dp[i+1][j][0]==mx) dp[i][j][1]=(dp[i][j][1]+dp[i+1][j][1])%mod;\\n                        if(dp[i+1][j+1][0]==mx) dp[i][j][1]=(dp[i][j][1]+dp[i+1][j+1][1])%mod;\\n                        if(dp[i][j+1][0]==mx) dp[i][j][1]=(dp[i][j][1]+dp[i][j+1][1])%mod;\\n                    } \\n                }\\n            }\\n        }\\n        return {};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656738,
                "title": "simple-bottom-up-approach-c",
                "content": "# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& b) {\\n        int mx = 0, n = b.size();\\n        int M = 1000000007;\\n        vector<vector<pair<int,int>>> dp(n,vector<pair<int,int>>(n,{0,0}));\\n        dp[n-1][n-1] = {0,1};\\n        for(int i=n-2;i>=0;--i){\\n            // last col can only take from just below\\n            if(b[i][n-1] != \\'X\\') dp[i][n-1] = {(b[i][n-1]-\\'0\\')+dp[i+1][n-1].first,1};\\n            else break;\\n        }\\n        for(int i=n-2;i>=0;--i){\\n            // last row can only take from just below\\n            if(b[n-1][i] != \\'X\\') dp[n-1][i] = {(b[n-1][i]-\\'0\\')+dp[n-1][i+1].first,1}; \\n            else break;\\n        }\\n        // No for the middle part\\n        for(int i=n-2;i>=0;--i){\\n            for(int j=n-2;j>=0;--j){\\n                if(b[i][j] != \\'X\\'){\\n                    int ri = dp[i][j+1].first, dn = dp[i+1][j].first, dr = dp[i+1][j+1].first;\\n                    int mx = max({ri,dn,dr});\\n                    if(ri == mx && dp[i][j+1].second > 0) dp[i][j].second = (1ll*dp[i][j].second + dp[i][j+1].second)%M;\\n                    if(dr == mx && dp[i+1][j+1].second > 0) dp[i][j].second = (1ll*dp[i][j].second + dp[i+1][j+1].second)%M; \\n                    if(dn == mx && dp[i+1][j].second > 0) dp[i][j].second = (1ll*dp[i][j].second + dp[i+1][j].second)%M;\\n                    dp[i][j].first = (dp[i][j].first + (b[i][j]-\\'0\\')+mx)%M;\\n                }\\n            }\\n        }\\n        if(dp[0][0].second == 0) return {0,0};\\n        return {dp[0][0].first-\\'E\\'+\\'0\\', dp[0][0].second};\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& b) {\\n        int mx = 0, n = b.size();\\n        int M = 1000000007;\\n        vector<vector<pair<int,int>>> dp(n,vector<pair<int,int>>(n,{0,0}));\\n        dp[n-1][n-1] = {0,1};\\n        for(int i=n-2;i>=0;--i){\\n            // last col can only take from just below\\n            if(b[i][n-1] != \\'X\\') dp[i][n-1] = {(b[i][n-1]-\\'0\\')+dp[i+1][n-1].first,1};\\n            else break;\\n        }\\n        for(int i=n-2;i>=0;--i){\\n            // last row can only take from just below\\n            if(b[n-1][i] != \\'X\\') dp[n-1][i] = {(b[n-1][i]-\\'0\\')+dp[n-1][i+1].first,1}; \\n            else break;\\n        }\\n        // No for the middle part\\n        for(int i=n-2;i>=0;--i){\\n            for(int j=n-2;j>=0;--j){\\n                if(b[i][j] != \\'X\\'){\\n                    int ri = dp[i][j+1].first, dn = dp[i+1][j].first, dr = dp[i+1][j+1].first;\\n                    int mx = max({ri,dn,dr});\\n                    if(ri == mx && dp[i][j+1].second > 0) dp[i][j].second = (1ll*dp[i][j].second + dp[i][j+1].second)%M;\\n                    if(dr == mx && dp[i+1][j+1].second > 0) dp[i][j].second = (1ll*dp[i][j].second + dp[i+1][j+1].second)%M; \\n                    if(dn == mx && dp[i+1][j].second > 0) dp[i][j].second = (1ll*dp[i][j].second + dp[i+1][j].second)%M;\\n                    dp[i][j].first = (dp[i][j].first + (b[i][j]-\\'0\\')+mx)%M;\\n                }\\n            }\\n        }\\n        if(dp[0][0].second == 0) return {0,0};\\n        return {dp[0][0].first-\\'E\\'+\\'0\\', dp[0][0].second};\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572273,
                "title": "c-dp-solution-w-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& grid) {\\n        using pii = pair<int, int>;\\n        int m = grid.size(), n = grid[0].size(), mod = 1e9 + 7;\\n        grid[0][0] = grid[m - 1][n - 1] = \\'0\\';\\n        vector<pii> dp(n + 1);\\n        \\n        for (int i = m - 1; i >= 0; i--) {\\n            pii pre = {0, 0};\\n            for (int j = n - 1; j >= 0; j--) {\\n                pii temp = dp[j];\\n                if (i == m - 1 and j == n - 1)  dp[j].second = 1;\\n                \\n                if (grid[i][j] == \\'X\\') {\\n                    dp[j].first = dp[j].second = 0;\\n                } else {\\n                    int val = grid[i][j] - \\'0\\', dist = 0;\\n                    int curMax = val + max({dp[j].first, dp[j + 1].first, pre.first});\\n                    if (val + dp[j].first == curMax) dist = (dist + dp[j].second) % mod;\\n                    if (val + dp[j + 1].first == curMax) dist = (dist + dp[j + 1].second) % mod;\\n                    if (val + pre.first == curMax) dist = (dist + pre.second) % mod;\\n                    dp[j] = {curMax, dist};\\n                }\\n                pre = temp;\\n            }\\n        }\\n        if (dp[0].second == 0) dp[0].first = 0;\\n        return vector<int>({dp[0].first, dp[0].second});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& grid) {\\n        using pii = pair<int, int>;\\n        int m = grid.size(), n = grid[0].size(), mod = 1e9 + 7;\\n        grid[0][0] = grid[m - 1][n - 1] = \\'0\\';\\n        vector<pii> dp(n + 1);\\n        \\n        for (int i = m - 1; i >= 0; i--) {\\n            pii pre = {0, 0};\\n            for (int j = n - 1; j >= 0; j--) {\\n                pii temp = dp[j];\\n                if (i == m - 1 and j == n - 1)  dp[j].second = 1;\\n                \\n                if (grid[i][j] == \\'X\\') {\\n                    dp[j].first = dp[j].second = 0;\\n                } else {\\n                    int val = grid[i][j] - \\'0\\', dist = 0;\\n                    int curMax = val + max({dp[j].first, dp[j + 1].first, pre.first});\\n                    if (val + dp[j].first == curMax) dist = (dist + dp[j].second) % mod;\\n                    if (val + dp[j + 1].first == curMax) dist = (dist + dp[j + 1].second) % mod;\\n                    if (val + pre.first == curMax) dist = (dist + pre.second) % mod;\\n                    dp[j] = {curMax, dist};\\n                }\\n                pre = temp;\\n            }\\n        }\\n        if (dp[0].second == 0) dp[0].first = 0;\\n        return vector<int>({dp[0].first, dp[0].second});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561536,
                "title": "using-simple-tabulation-approach",
                "content": "tab\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n int mod=1000000007;\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        \\n        int n=board.size();\\n        vector<vector<int>>dp(n,vector<int>(n,0));\\n        vector<vector<int>>way(n,vector<int>(n,0));\\n        way[n-1][n-1]=1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(board[n-1][i]==\\'X\\') break;\\n            else\\n            {\\n                dp[n-1][i]=board[n-1][i]-\\'0\\'+dp[n-1][i+1];\\n                way[n-1][i]=1;\\n            }\\n        }\\n         for(int i=n-2;i>=0;i--)\\n        {\\n            if(board[i][n-1]==\\'X\\') break;\\n            else\\n            {\\n                dp[i][n-1]=dp[i+1][n-1]+board[i][n-1]-\\'0\\';\\n                way[i][n-1]=1;\\n            }\\n        }\\n\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=n-2;j>=0;j--)\\n            {\\n                if(i==0 && j==0)\\n                {\\n                    int mx=max(dp[i][j+1],dp[i+1][j]);\\n                    mx=max(mx,dp[i+1][j+1]);\\n                    dp[i][j]=mx;\\n                    way[i][j]=(way[i][j]+((dp[i+1][j+1]==mx)?way[i+1][j+1]:0))%mod;\\n                    way[i][j]=(way[i][j]+((dp[i+1][j]==mx)?way[i+1][j]:0))%mod;\\n                    way[i][j]=(way[i][j]+((dp[i][j+1]==mx)?way[i][j+1]:0))%mod;\\n                    if(way[i][j]==0)\\n                    dp[i][j]=0;\\n                    return {dp[i][j],way[i][j]};\\n                }\\n                else if(board[i][j]==\\'X\\')\\n                {\\n                    dp[i][j]=0;\\n                    way[i][j]=0;\\n                }\\n                else \\n                {\\n                    int mx=max(dp[i][j+1],dp[i+1][j]);\\n                    mx=max(mx,dp[i+1][j+1]);\\n                    dp[i][j]=board[i][j]+mx-\\'0\\';\\n                    way[i][j]=(way[i][j]+((dp[i+1][j+1]==mx)?way[i+1][j+1]:0))%mod;\\n                    way[i][j]=(way[i][j]+((dp[i+1][j]==mx)?way[i+1][j]:0))%mod;\\n                    way[i][j]=(way[i][j]+((dp[i][j+1]==mx)?way[i][j+1]:0))%mod;\\n                    \\n                }\\n\\n\\n            }\\n        }\\n       \\n           <!-- for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n                cout<<dp[i][j]<<\" \";\\n            cout<<endl;\\n        }\\n        \\n  return {dp[0][0],way[0][0]}; -->\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n int mod=1000000007;\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        \\n        int n=board.size();\\n        vector<vector<int>>dp(n,vector<int>(n,0));\\n        vector<vector<int>>way(n,vector<int>(n,0));\\n        way[n-1][n-1]=1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(board[n-1][i]==\\'X\\') break;\\n            else\\n            {\\n                dp[n-1][i]=board[n-1][i]-\\'0\\'+dp[n-1][i+1];\\n                way[n-1][i]=1;\\n            }\\n        }\\n         for(int i=n-2;i>=0;i--)\\n        {\\n            if(board[i][n-1]==\\'X\\') break;\\n            else\\n            {\\n                dp[i][n-1]=dp[i+1][n-1]+board[i][n-1]-\\'0\\';\\n                way[i][n-1]=1;\\n            }\\n        }\\n\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=n-2;j>=0;j--)\\n            {\\n                if(i==0 && j==0)\\n                {\\n                    int mx=max(dp[i][j+1],dp[i+1][j]);\\n                    mx=max(mx,dp[i+1][j+1]);\\n                    dp[i][j]=mx;\\n                    way[i][j]=(way[i][j]+((dp[i+1][j+1]==mx)?way[i+1][j+1]:0))%mod;\\n                    way[i][j]=(way[i][j]+((dp[i+1][j]==mx)?way[i+1][j]:0))%mod;\\n                    way[i][j]=(way[i][j]+((dp[i][j+1]==mx)?way[i][j+1]:0))%mod;\\n                    if(way[i][j]==0)\\n                    dp[i][j]=0;\\n                    return {dp[i][j],way[i][j]};\\n                }\\n                else if(board[i][j]==\\'X\\')\\n                {\\n                    dp[i][j]=0;\\n                    way[i][j]=0;\\n                }\\n                else \\n                {\\n                    int mx=max(dp[i][j+1],dp[i+1][j]);\\n                    mx=max(mx,dp[i+1][j+1]);\\n                    dp[i][j]=board[i][j]+mx-\\'0\\';\\n                    way[i][j]=(way[i][j]+((dp[i+1][j+1]==mx)?way[i+1][j+1]:0))%mod;\\n                    way[i][j]=(way[i][j]+((dp[i+1][j]==mx)?way[i+1][j]:0))%mod;\\n                    way[i][j]=(way[i][j]+((dp[i][j+1]==mx)?way[i][j+1]:0))%mod;\\n                    \\n                }\\n\\n\\n            }\\n        }\\n       \\n           <!-- for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n                cout<<dp[i][j]<<\" \";\\n            cout<<endl;\\n        }\\n        \\n  return {dp[0][0],way[0][0]}; -->\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3560355,
                "title": "python-dp-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nstill studying, should be O(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfrom functools import cache\\nmod = 1000000007\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        @cache\\n        def DP(i,j):\\n            if board[i][j]==\"X\":\\n                return [0,0]\\n            if i==0 and j==0:\\n                return [0,1]\\n            \\n            if i==0:\\n                previous = DP(0, j-1)\\n                return [previous[0]+int(board[i][j]), previous[1]]\\n            if j==0:\\n                previous = DP(i-1, 0)\\n                return [previous[0]+int(board[i][j]), previous[1]]\\n\\n            left = DP(i-1,j)\\n            up   = DP(i,j-1)\\n            upleft=DP(i-1,j-1)\\n\\n            val = max(left[0], up[0], upleft[0])\\n            count = 0\\n            if left[0]==val:\\n                count +=left[1]\\n            if up[0]==val:\\n                count +=up[1]   \\n            if upleft[0]==val:\\n                count +=upleft[1]   \\n\\n            if i==len(board)-1 and j==len(board)-1 :\\n                if count ==0:\\n                    val =0\\n                return [val, count%mod] \\n            return [val+int(board[i][j]), count%mod] \\n\\n        return DP( len(board)-1,len(board)-1 )\\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom functools import cache\\nmod = 1000000007\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        @cache\\n        def DP(i,j):\\n            if board[i][j]==\"X\":\\n                return [0,0]\\n            if i==0 and j==0:\\n                return [0,1]\\n            \\n            if i==0:\\n                previous = DP(0, j-1)\\n                return [previous[0]+int(board[i][j]), previous[1]]\\n            if j==0:\\n                previous = DP(i-1, 0)\\n                return [previous[0]+int(board[i][j]), previous[1]]\\n\\n            left = DP(i-1,j)\\n            up   = DP(i,j-1)\\n            upleft=DP(i-1,j-1)\\n\\n            val = max(left[0], up[0], upleft[0])\\n            count = 0\\n            if left[0]==val:\\n                count +=left[1]\\n            if up[0]==val:\\n                count +=up[1]   \\n            if upleft[0]==val:\\n                count +=upleft[1]   \\n\\n            if i==len(board)-1 and j==len(board)-1 :\\n                if count ==0:\\n                    val =0\\n                return [val, count%mod] \\n            return [val+int(board[i][j]), count%mod] \\n\\n        return DP( len(board)-1,len(board)-1 )\\n        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560211,
                "title": "dp-10-liner-simple-fast-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def pathsWithMaxScore(self, A):\\n        n, mod = len(A), 10**9 + 7\\n        dp = [[[-10**5, 0] for j in range(n + 1)] for i in range(n + 1)]\\n        dp[n - 1][n - 1] = [0, 1]\\n        for x in range(n)[::-1]:\\n            for y in range(n)[::-1]:\\n                if A[x][y] in \\'XS\\': continue\\n                for i, j in [[0, 1], [1, 0], [1, 1]]:\\n                    if dp[x][y][0] < dp[x + i][y + j][0]: dp[x][y] = [dp[x + i][y + j][0], 0]\\n                    if dp[x][y][0] == dp[x + i][y + j][0]: dp[x][y][1] += dp[x + i][y + j][1]\\n                dp[x][y][0] += int(A[x][y]) if x or y else 0\\n        return [dp[0][0][0] if dp[0][0][1] else 0, dp[0][0][1] % mod]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def pathsWithMaxScore(self, A):\\n        n, mod = len(A), 10**9 + 7\\n        dp = [[[-10**5, 0] for j in range(n + 1)] for i in range(n + 1)]\\n        dp[n - 1][n - 1] = [0, 1]\\n        for x in range(n)[::-1]:\\n            for y in range(n)[::-1]:\\n                if A[x][y] in \\'XS\\': continue\\n                for i, j in [[0, 1], [1, 0], [1, 1]]:\\n                    if dp[x][y][0] < dp[x + i][y + j][0]: dp[x][y] = [dp[x + i][y + j][0], 0]\\n                    if dp[x][y][0] == dp[x + i][y + j][0]: dp[x][y][1] += dp[x + i][y + j][1]\\n                dp[x][y][0] += int(A[x][y]) if x or y else 0\\n        return [dp[0][0][0] if dp[0][0][1] else 0, dp[0][0][1] % mod]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172202,
                "title": "c-1d-dp-time-o-m-n-space-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        \\n        int n = board.size();\\n        vector<pair<int,int>> dp(n, {0,0});\\n        const int MOD = 1000000007;\\n        dp[0] = {0,1};\\n\\n        for(int j = 1; j < n; j++)\\n        {\\n            if(board[0][j] != \\'X\\')\\n                dp[j] = { dp[j - 1].first + board[0][j] - \\'0\\', 1};\\n        }\\n\\n        for(int i = 1; i < n; i++)\\n        {\\n            vector<pair<int,int>> _dp(n, {0,0});\\n            if(board[i][0] != \\'X\\' && dp[0].second != 0)\\n                _dp[0] = {dp[0].first + board[i][0] - \\'0\\', dp[0].second};\\n            \\n            for(int j = 1; j < n; j++)\\n            {   \\n                if(board[i][j] == \\'X\\')\\n                    continue;\\n                int maxSum = max( {_dp[j - 1].first, dp[j - 1].first, dp[j].first} );\\n                long long int ways = 0;\\n                ways += maxSum == _dp[j - 1].first ? _dp[j - 1].second : 0;\\n                ways += maxSum == dp[j - 1].first ? dp[j - 1].second : 0;\\n                ways += maxSum == dp[j].first ? dp[j].second : 0;\\n                if(ways == 0)\\n                    continue;\\n                int cellValue = board[i][j] == \\'S\\' ? 0 : (board[i][j] - \\'0\\');\\n                _dp[j] = {maxSum + cellValue, ways % MOD};\\n            }\\n            dp.swap(_dp);\\n        }\\n        \\n        return {dp[n - 1].first, dp[n - 1].second};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        \\n        int n = board.size();\\n        vector<pair<int,int>> dp(n, {0,0});\\n        const int MOD = 1000000007;\\n        dp[0] = {0,1};\\n\\n        for(int j = 1; j < n; j++)\\n        {\\n            if(board[0][j] != \\'X\\')\\n                dp[j] = { dp[j - 1].first + board[0][j] - \\'0\\', 1};\\n        }\\n\\n        for(int i = 1; i < n; i++)\\n        {\\n            vector<pair<int,int>> _dp(n, {0,0});\\n            if(board[i][0] != \\'X\\' && dp[0].second != 0)\\n                _dp[0] = {dp[0].first + board[i][0] - \\'0\\', dp[0].second};\\n            \\n            for(int j = 1; j < n; j++)\\n            {   \\n                if(board[i][j] == \\'X\\')\\n                    continue;\\n                int maxSum = max( {_dp[j - 1].first, dp[j - 1].first, dp[j].first} );\\n                long long int ways = 0;\\n                ways += maxSum == _dp[j - 1].first ? _dp[j - 1].second : 0;\\n                ways += maxSum == dp[j - 1].first ? dp[j - 1].second : 0;\\n                ways += maxSum == dp[j].first ? dp[j].second : 0;\\n                if(ways == 0)\\n                    continue;\\n                int cellValue = board[i][j] == \\'S\\' ? 0 : (board[i][j] - \\'0\\');\\n                _dp[j] = {maxSum + cellValue, ways % MOD};\\n            }\\n            dp.swap(_dp);\\n        }\\n        \\n        return {dp[n - 1].first, dp[n - 1].second};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130536,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    typedef pair<int, int> pr;\\n    \\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        \\n        char n = board.size();\\n        \\n        board[0][0] = \\'0\\';\\n        \\n        pr tb[n][n], p = {0, 0};\\n        int mod = 1e9 + 7;\\n        \\n        tb[n - 1][n - 1] = {1, 1};\\n        \\n        for(char i = n - 2; i != -1; --i) {\\n            tb[i][n - 1] = (board[i][n - 1] == \\'X\\' || board[i + 1][n - 1] == \\'X\\') ? p : pr{tb[i + 1][n - 1].first + board[i][n - 1] - \\'0\\', tb[i + 1][n - 1].second};\\n            tb[n - 1][i] = (board[n - 1][i] == \\'X\\' || board[n - 1][i + 1] == \\'X\\') ? p : pr{tb[n - 1][i + 1].first + board[n - 1][i] - \\'0\\', tb[n - 1][i + 1].second};\\n        }\\n        \\n        pr R, D, RD;\\n        int M, sum;\\n        for(char i = n - 2; i != -1; --i) {\\n            auto &b = board[i];\\n            auto &t0 = tb[i];\\n            auto &t1 = tb[i + 1];\\n            for(char j = n - 2; j != -1; --j) {\\n                if(b[j] == \\'X\\')\\n                    t0[j] = p;\\n                else {\\n                    R = t0[j + 1];\\n                    D = t1[j];\\n                    RD = t1[j + 1];\\n                    M = max(max(R.first, D.first), RD.first);\\n                    \\n                    sum = 0;\\n                    if(R.first == M)  sum = (sum + R.second) % mod;\\n                    if(D.first == M)  sum = (sum + D.second) % mod;\\n                    if(RD.first == M) sum = (sum + RD.second) % mod;\\n                    \\n                    t0[j] = M ? pr{M + b[j] - \\'0\\', sum} : pr{0, 0};\\n                }\\n            }\\n        }\\n        \\n        return {max(0, tb[0][0].first - 1), tb[0][0].second};\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        n = len(board)\\n        dp = [[-math.inf]*n for _ in range(n)]\\n        count = [[0]*n for _ in range(n)]\\n\\n        dp[-1][-1] = 0\\n        count[-1][-1] = 1\\n        for i in range(n-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if i == (n-1) and j == (n-1):\\n                    continue\\n                \\n                if board[i][j] == \\'X\\':\\n                    continue\\n                \\n                dp[i][j] = dp[i][j+1] if j+1 < n else -math.inf\\n                count[i][j] = count[i][j+1] if j+1 < n else 0\\n\\n                tmp = dp[i+1][j] if i+1 < n else -math.inf\\n                if tmp > dp[i][j]:\\n                    dp[i][j] = tmp\\n                    count[i][j] = count[i+1][j] if i+1 < n else 0\\n                elif tmp == dp[i][j]:\\n                    count[i][j] += count[i+1][j] if i+1 < n else 0\\n                \\n                tmp = dp[i+1][j+1] if i+1 < n and j+1 < n else -math.inf\\n                if tmp > dp[i][j]:\\n                    dp[i][j] = tmp\\n                    count[i][j] = count[i+1][j+1] if i+1 < n and j+1 < n else 0\\n                elif tmp == dp[i][j]:\\n                     count[i][j] += count[i+1][j+1] if i+1 < n and j+1 < n else 0\\n                \\n                if i != 0 or j != 0:\\n                    dp[i][j] += int(board[i][j])\\n                \\n        if dp[0][0] == -math.inf:\\n            return [0, 0]\\n        else:\\n            return [dp[0][0], count[0][0]%(10**9+7)]\\n\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int MOD = (int)(1e9 + 7);\\n        int n = board.size();\\n        int[][] sum = new int[n][n];\\n        int[][] cnt = new int[n][n];\\n        cnt[n-1][n-1] = 1;\\n        int[][] m = {{-1, 0}, {0, -1}, {-1, -1}};\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            for(int j = n - 1; j >= 0; j--){\\n                char val = board.get(i).charAt(j);\\n                if(val == \\'X\\' || val == \\'S\\'){\\n                    continue; // sum, cnt = 0\\n                }\\n                \\n                int v = val - \\'0\\';\\n                int maxSum = 0;\\n                int maxCnt = 0;\\n                for(int k = 0; k < 3; k++){\\n                    int r = i - m[k][0];\\n                    int c = j - m[k][1];\\n                    if(r >= n || c >= n)\\n                        continue;\\n                    if(sum[r][c] > maxSum){\\n                        maxSum = sum[r][c];\\n                        maxCnt = cnt[r][c];\\n                    }\\n                    else if(sum[r][c] == maxSum){\\n                        maxCnt += cnt[r][c];\\n                    }\\n                }\\n                if(val == \\'E\\')\\n                    sum[i][j] = maxSum;\\n                else\\n                    sum[i][j] = v + maxSum;\\n                cnt[i][j] = maxCnt % MOD;\\n            }\\n        }\\n        \\n        int[] ans = new int[2];\\n        ans[0] = sum[0][0];\\n        ans[1] = cnt[0][0];\\n        if(cnt[0][0] == 0)\\n            ans[0] = 0;\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    typedef pair<int, int> pr;\\n    \\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        \\n        char n = board.size();\\n        \\n        board[0][0] = \\'0\\';\\n        \\n        pr tb[n][n], p = {0, 0};\\n        int mod = 1e9 + 7;\\n        \\n        tb[n - 1][n - 1] = {1, 1};\\n        \\n        for(char i = n - 2; i != -1; --i) {\\n            tb[i][n - 1] = (board[i][n - 1] == \\'X\\' || board[i + 1][n - 1] == \\'X\\') ? p : pr{tb[i + 1][n - 1].first + board[i][n - 1] - \\'0\\', tb[i + 1][n - 1].second};\\n            tb[n - 1][i] = (board[n - 1][i] == \\'X\\' || board[n - 1][i + 1] == \\'X\\') ? p : pr{tb[n - 1][i + 1].first + board[n - 1][i] - \\'0\\', tb[n - 1][i + 1].second};\\n        }\\n        \\n        pr R, D, RD;\\n        int M, sum;\\n        for(char i = n - 2; i != -1; --i) {\\n            auto &b = board[i];\\n            auto &t0 = tb[i];\\n            auto &t1 = tb[i + 1];\\n            for(char j = n - 2; j != -1; --j) {\\n                if(b[j] == \\'X\\')\\n                    t0[j] = p;\\n                else {\\n                    R = t0[j + 1];\\n                    D = t1[j];\\n                    RD = t1[j + 1];\\n                    M = max(max(R.first, D.first), RD.first);\\n                    \\n                    sum = 0;\\n                    if(R.first == M)  sum = (sum + R.second) % mod;\\n                    if(D.first == M)  sum = (sum + D.second) % mod;\\n                    if(RD.first == M) sum = (sum + RD.second) % mod;\\n                    \\n                    t0[j] = M ? pr{M + b[j] - \\'0\\', sum} : pr{0, 0};\\n                }\\n            }\\n        }\\n        \\n        return {max(0, tb[0][0].first - 1), tb[0][0].second};\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        n = len(board)\\n        dp = [[-math.inf]*n for _ in range(n)]\\n        count = [[0]*n for _ in range(n)]\\n\\n        dp[-1][-1] = 0\\n        count[-1][-1] = 1\\n        for i in range(n-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if i == (n-1) and j == (n-1):\\n                    continue\\n                \\n                if board[i][j] == \\'X\\':\\n                    continue\\n                \\n                dp[i][j] = dp[i][j+1] if j+1 < n else -math.inf\\n                count[i][j] = count[i][j+1] if j+1 < n else 0\\n\\n                tmp = dp[i+1][j] if i+1 < n else -math.inf\\n                if tmp > dp[i][j]:\\n                    dp[i][j] = tmp\\n                    count[i][j] = count[i+1][j] if i+1 < n else 0\\n                elif tmp == dp[i][j]:\\n                    count[i][j] += count[i+1][j] if i+1 < n else 0\\n                \\n                tmp = dp[i+1][j+1] if i+1 < n and j+1 < n else -math.inf\\n                if tmp > dp[i][j]:\\n                    dp[i][j] = tmp\\n                    count[i][j] = count[i+1][j+1] if i+1 < n and j+1 < n else 0\\n                elif tmp == dp[i][j]:\\n                     count[i][j] += count[i+1][j+1] if i+1 < n and j+1 < n else 0\\n                \\n                if i != 0 or j != 0:\\n                    dp[i][j] += int(board[i][j])\\n                \\n        if dp[0][0] == -math.inf:\\n            return [0, 0]\\n        else:\\n            return [dp[0][0], count[0][0]%(10**9+7)]\\n\\n```\n```Java []\\nclass Solution {\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int MOD = (int)(1e9 + 7);\\n        int n = board.size();\\n        int[][] sum = new int[n][n];\\n        int[][] cnt = new int[n][n];\\n        cnt[n-1][n-1] = 1;\\n        int[][] m = {{-1, 0}, {0, -1}, {-1, -1}};\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            for(int j = n - 1; j >= 0; j--){\\n                char val = board.get(i).charAt(j);\\n                if(val == \\'X\\' || val == \\'S\\'){\\n                    continue; // sum, cnt = 0\\n                }\\n                \\n                int v = val - \\'0\\';\\n                int maxSum = 0;\\n                int maxCnt = 0;\\n                for(int k = 0; k < 3; k++){\\n                    int r = i - m[k][0];\\n                    int c = j - m[k][1];\\n                    if(r >= n || c >= n)\\n                        continue;\\n                    if(sum[r][c] > maxSum){\\n                        maxSum = sum[r][c];\\n                        maxCnt = cnt[r][c];\\n                    }\\n                    else if(sum[r][c] == maxSum){\\n                        maxCnt += cnt[r][c];\\n                    }\\n                }\\n                if(val == \\'E\\')\\n                    sum[i][j] = maxSum;\\n                else\\n                    sum[i][j] = v + maxSum;\\n                cnt[i][j] = maxCnt % MOD;\\n            }\\n        }\\n        \\n        int[] ans = new int[2];\\n        ans[0] = sum[0][0];\\n        ans[1] = cnt[0][0];\\n        if(cnt[0][0] == 0)\\n            ans[0] = 0;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3129024,
                "title": "python-bottom-up-dp-87-time-51-space",
                "content": "```python []\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        MOD = 10 ** 9 + 7\\n        m = len(board)\\n        n = len(board[0])\\n\\n        dp = [[[0, 0]] * (n + 1) for _ in range(m + 1)]\\n        dp[1][1] = [0, 1]\\n        for i in range(m + 1): dp[i][0] = [-math.inf, 0]\\n\\n        for r in range(1, m + 1):\\n            for c in range(1, n + 1):\\n                if r == 1 and c == 1: continue\\n\\n                val = board[r - 1][c - 1]\\n                if val == \\'X\\': \\n                    dp[r][c] = [-math.inf, 0]\\n                    continue\\n                val = 0 if val == \\'S\\' else int(val)\\n\\n                maxi, paths = -math.inf, 0\\n                for rr, cc in [[-1, 0], [0, -1], [-1, -1]]:\\n                    new_r = r + rr\\n                    new_c = c + cc\\n                    _sum = val + dp[new_r][new_c][0]\\n                    if _sum == maxi: paths += dp[new_r][new_c][1]\\n                    elif _sum > maxi:\\n                        maxi = _sum\\n                        paths = dp[new_r][new_c][1]\\n                dp[r][c] = [maxi, paths % MOD]\\n\\n        return [0, 0] if dp[m][n][0] == -math.inf else dp[m][n]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        MOD = 10 ** 9 + 7\\n        m = len(board)\\n        n = len(board[0])\\n\\n        dp = [[[0, 0]] * (n + 1) for _ in range(m + 1)]\\n        dp[1][1] = [0, 1]\\n        for i in range(m + 1): dp[i][0] = [-math.inf, 0]\\n\\n        for r in range(1, m + 1):\\n            for c in range(1, n + 1):\\n                if r == 1 and c == 1: continue\\n\\n                val = board[r - 1][c - 1]\\n                if val == \\'X\\': \\n                    dp[r][c] = [-math.inf, 0]\\n                    continue\\n                val = 0 if val == \\'S\\' else int(val)\\n\\n                maxi, paths = -math.inf, 0\\n                for rr, cc in [[-1, 0], [0, -1], [-1, -1]]:\\n                    new_r = r + rr\\n                    new_c = c + cc\\n                    _sum = val + dp[new_r][new_c][0]\\n                    if _sum == maxi: paths += dp[new_r][new_c][1]\\n                    elif _sum > maxi:\\n                        maxi = _sum\\n                        paths = dp[new_r][new_c][1]\\n                dp[r][c] = [maxi, paths % MOD]\\n\\n        return [0, 0] if dp[m][n][0] == -math.inf else dp[m][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096223,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn paths_with_max_score(board: Vec<String>) -> Vec<i32> {\\n        let dirs = vec![vec![1, 0], vec![0, 1], vec![1, 1]];\\n        let sz = board.len();\\n        let mut score = vec![vec![0; sz + 1]; sz + 1];\\n        let mut paths = vec![vec![0; sz + 1]; sz + 1];\\n        let mut board = board;\\n        board[0].replace_range(..1, \"0\");\\n        board[sz - 1].replace_range(sz - 1.., \"0\");\\n        paths[0][0] = 1;\\n        for i in 1..=sz {\\n            for j in 1..=sz {\\n                let board_ij = board[i - 1].chars().nth(j - 1).unwrap();\\n                if board_ij == \\'X\\' {\\n                    continue;\\n                }\\n                for d in &dirs {\\n                    let i1 = i - d[0];\\n                    let j1 = j - d[1];\\n                    let val = score[i1][j1] + (board_ij as i32 - \\'0\\' as i32);\\n                    if score[i][j] <= val && paths[i1][j1] > 0 {\\n                        paths[i][j] = (if score[i][j] == val { paths[i][j] } else { 0 } + paths[i1][j1]) % 1000000007;\\n                        score[i][j] = val;\\n                    }\\n                }\\n            }\\n        }\\n        let val = paths[sz][sz];\\n        vec![if val != 0 { score[sz][sz] } else { 0 }, val]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn paths_with_max_score(board: Vec<String>) -> Vec<i32> {\\n        let dirs = vec![vec![1, 0], vec![0, 1], vec![1, 1]];\\n        let sz = board.len();\\n        let mut score = vec![vec![0; sz + 1]; sz + 1];\\n        let mut paths = vec![vec![0; sz + 1]; sz + 1];\\n        let mut board = board;\\n        board[0].replace_range(..1, \"0\");\\n        board[sz - 1].replace_range(sz - 1.., \"0\");\\n        paths[0][0] = 1;\\n        for i in 1..=sz {\\n            for j in 1..=sz {\\n                let board_ij = board[i - 1].chars().nth(j - 1).unwrap();\\n                if board_ij == \\'X\\' {\\n                    continue;\\n                }\\n                for d in &dirs {\\n                    let i1 = i - d[0];\\n                    let j1 = j - d[1];\\n                    let val = score[i1][j1] + (board_ij as i32 - \\'0\\' as i32);\\n                    if score[i][j] <= val && paths[i1][j1] > 0 {\\n                        paths[i][j] = (if score[i][j] == val { paths[i][j] } else { 0 } + paths[i1][j1]) % 1000000007;\\n                        score[i][j] = val;\\n                    }\\n                }\\n            }\\n        }\\n        let val = paths[sz][sz];\\n        vec![if val != 0 { score[sz][sz] } else { 0 }, val]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2981985,
                "title": "python-dp-faster-than-100-tc-o-n-m-sc-o-m",
                "content": "Create *\\'sums\\'* dp array to keep track of the previous maximum path sums computed from the previous row and a *\\'paths\\'* dp array to keep track of how many paths from each of the previous cells to `board[n-1][m-1]`, sum to *max(sums[j], sums[j + 1], next_sums[j + 1])*. \\n\\n`sums[j]` -> same as `dp[i + 1][j] `(gets the maximum sum from directly below)\\n`sums[j + 1]` -> same as `dp[i + 1][j + 1`] (gets the maximum sum from diagonal position)\\n`next_sums[j + 1]` -> same as `dp[i][j + 1]` (gets the maximum sum from the right position)\\n\\nGet the maximum sum from each direction ->  *best = max(sums[j], sums[j + 1], next_sums[j + 1])*. Check how many directions have the same max sum as *best* and add `next_paths[j + 1]` to `count_paths` if the right has max_sum = `best`, `paths[j + 1]` if the diagonal has maximum sum = *best*, and` paths[j]` if the cell below has maximum sum = `best`. \\n\\nAfter *\\'next_sums\\'* and *\\'path_sums\\'* are filled, *\\'sums\\'* and *\\'paths\\'* are replaced and we continue this process until we get our answer *[sums[0], paths[0]]*. \\n\\nTime Complexity -> O(n*m)\\nSpace Complexity -> O(m)\\n\\n```\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        n = len(board)\\n        sums = [-1] * (n + 1)\\n        paths = [1] * (n + 1)\\n        \\n        for i in range(n - 1, -1, -1):\\n            next_sums = [-1] * (n + 1)\\n            next_paths = [1] * (n + 1)\\n            next_sums[n - 1] = 0 if i == n - 1 else -1\\n            \\n            for j in range(n - 1, -1, -1):\\n                if board[i][j] == \\'X\\' or board[i][j] == \\'S\\':\\n                    continue\\n\\n                best = max(sums[j], sums[j + 1], next_sums[j + 1])\\n                count_paths = 0\\n                \\n                if best != -1:\\n                    if next_sums[j + 1] == best: count_paths = (count_paths + next_paths[j + 1]) % 1000000007\\n                    if sums[j + 1] == best: count_paths = (count_paths + paths[j + 1]) % 1000000007\\n                    if sums[j] == best: count_paths = (count_paths + paths[j]) % 1000000007\\n                \\n                next_sums[j] = int(board[i][j]) + best if board[i][j] != \\'E\\' and best != -1 else best\\n                next_paths[j] = max(1, count_paths)\\n         \\n            sums = next_sums\\n            paths = next_paths\\n        \\n        return [0, 0] if sums[0] == -1 else [sums[0], paths[0]]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        n = len(board)\\n        sums = [-1] * (n + 1)\\n        paths = [1] * (n + 1)\\n        \\n        for i in range(n - 1, -1, -1):\\n            next_sums = [-1] * (n + 1)\\n            next_paths = [1] * (n + 1)\\n            next_sums[n - 1] = 0 if i == n - 1 else -1\\n            \\n            for j in range(n - 1, -1, -1):\\n                if board[i][j] == \\'X\\' or board[i][j] == \\'S\\':\\n                    continue\\n\\n                best = max(sums[j], sums[j + 1], next_sums[j + 1])\\n                count_paths = 0\\n                \\n                if best != -1:\\n                    if next_sums[j + 1] == best: count_paths = (count_paths + next_paths[j + 1]) % 1000000007\\n                    if sums[j + 1] == best: count_paths = (count_paths + paths[j + 1]) % 1000000007\\n                    if sums[j] == best: count_paths = (count_paths + paths[j]) % 1000000007\\n                \\n                next_sums[j] = int(board[i][j]) + best if board[i][j] != \\'E\\' and best != -1 else best\\n                next_paths[j] = max(1, count_paths)\\n         \\n            sums = next_sums\\n            paths = next_paths\\n        \\n        return [0, 0] if sums[0] == -1 else [sums[0], paths[0]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965295,
                "title": "java-dp",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n ^ 2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n ^ 2)$$ \\n$$ n ^ 2 $$ - Space for `Pair[n][n]` and $$ 2n $$ - for stack of recursion, So $$ n ^ 2 + 2n$$ will be $$O(n ^ 2)$$, since $$2n <<< n ^ 2$$ in case of large numbers.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private static int mod = 1000000007;\\n    private class Pair{\\n        int val;\\n        long paths;\\n        Pair(int val, long paths){\\n            this.val = val;\\n            this.paths = paths;\\n        }\\n        public void compare(Pair p1, Pair p2){\\n            int max = Math.max(p1.val, p2.val);\\n            if(max == -1 || this.val > max){\\n                return;\\n            }\\n            if(this.val < max){\\n                this.val = max;\\n                this.paths = 0;\\n            }\\n            if(this.val == p1.val){\\n                this.paths = (this.paths + p1.paths) % mod;\\n            }\\n            if(this.val == p2.val){\\n                this.paths = (this.paths + p2.paths) % mod;\\n            }\\n        }\\n    }\\n    private Pair func(List<String> board, int r, int c, int n, Pair[][] dp){\\n        if(r == n-1 && c == n-1){\\n            return new Pair(0, 1);\\n        }\\n        if(r == n || c == n || board.get(r).charAt(c) == \\'X\\'){\\n            return new Pair(-1, 0);\\n        }\\n        if(dp[r][c] != null){\\n            return dp[r][c];\\n        }\\n        \\n        Pair pair = func(board, r + 1, c + 1, n, dp);\\n        Pair pair1 = func(board, r + 1, c, n, dp);\\n        Pair pair2 = func(board, r, c + 1, n, dp);\\n        \\n        pair.compare(pair1, pair2);\\n        \\n        if(pair.val != -1){\\n            pair.val += board.get(r).charAt(c) - \\'0\\';\\n        }\\n        \\n        return dp[r][c] = pair;\\n    }\\n    \\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int n = board.size();\\n        board.set(0, \\'0\\' + board.get(0).substring(1)); // replace \\'E\\' with \\'0\\'\\n        \\n        Pair[][] dp = new Pair[n][n];\\n        \\n        Pair pair = func(board, 0, 0, n, dp);\\n        \\n        int[] ans = new int[2];\\n        if(pair.val != -1){\\n            ans[0] = pair.val;\\n            ans[1] = (int)pair.paths;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    private static int mod = 1000000007;\\n    private class Pair{\\n        int val;\\n        long paths;\\n        Pair(int val, long paths){\\n            this.val = val;\\n            this.paths = paths;\\n        }\\n        public void compare(Pair p1, Pair p2){\\n            int max = Math.max(p1.val, p2.val);\\n            if(max == -1 || this.val > max){\\n                return;\\n            }\\n            if(this.val < max){\\n                this.val = max;\\n                this.paths = 0;\\n            }\\n            if(this.val == p1.val){\\n                this.paths = (this.paths + p1.paths) % mod;\\n            }\\n            if(this.val == p2.val){\\n                this.paths = (this.paths + p2.paths) % mod;\\n            }\\n        }\\n    }\\n    private Pair func(List<String> board, int r, int c, int n, Pair[][] dp){\\n        if(r == n-1 && c == n-1){\\n            return new Pair(0, 1);\\n        }\\n        if(r == n || c == n || board.get(r).charAt(c) == \\'X\\'){\\n            return new Pair(-1, 0);\\n        }\\n        if(dp[r][c] != null){\\n            return dp[r][c];\\n        }\\n        \\n        Pair pair = func(board, r + 1, c + 1, n, dp);\\n        Pair pair1 = func(board, r + 1, c, n, dp);\\n        Pair pair2 = func(board, r, c + 1, n, dp);\\n        \\n        pair.compare(pair1, pair2);\\n        \\n        if(pair.val != -1){\\n            pair.val += board.get(r).charAt(c) - \\'0\\';\\n        }\\n        \\n        return dp[r][c] = pair;\\n    }\\n    \\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int n = board.size();\\n        board.set(0, \\'0\\' + board.get(0).substring(1)); // replace \\'E\\' with \\'0\\'\\n        \\n        Pair[][] dp = new Pair[n][n];\\n        \\n        Pair pair = func(board, 0, 0, n, dp);\\n        \\n        int[] ans = new int[2];\\n        if(pair.val != -1){\\n            ans[0] = pair.val;\\n            ans[1] = (int)pair.paths;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948707,
                "title": "easy-recursion-memoization-python-solution-faster-than-97",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintain 2 separate states in the DP: Max Score and number of paths with max score\\n\\n# Complexity\\n- Time complexity: $$O(n * m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n * m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        MOD = 1000000007\\n        \\n        @cache\\n        def dp(row: int, col: int) -> Tuple[int]:\\n            numRows, numCols = len(board), len(board[0])\\n            if row >= numRows or col >= numCols or board[row][col] == \\'X\\':\\n                return(-inf, 0)\\n            score = ord(board[row][col]) - ord(\\'0\\')\\n            if board[row][col] == \\'E\\':\\n                score = 0\\n            if row == numRows - 1 and col == numCols - 1:\\n                return (0, 1)\\n            option1 = dp(row + 1, col)\\n            option2 = dp(row, col + 1)\\n            option3 = dp(row + 1, col + 1)\\n            count, ans = 0, score + max(option1[0], option2[0], option3[0])\\n            if score + option1[0] == ans: \\n                count = (count + option1[1]) % MOD\\n            if score + option2[0] == ans: \\n                count = (count + option2[1]) % MOD\\n            if score + option3[0] == ans:\\n                count = (count + option3[1]) % MOD\\n            return (ans, count % MOD)\\n\\n        ans = dp(0, 0)\\n        return [max(ans[0], 0), ans[1]]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```python []\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        MOD = 1000000007\\n        \\n        @cache\\n        def dp(row: int, col: int) -> Tuple[int]:\\n            numRows, numCols = len(board), len(board[0])\\n            if row >= numRows or col >= numCols or board[row][col] == \\'X\\':\\n                return(-inf, 0)\\n            score = ord(board[row][col]) - ord(\\'0\\')\\n            if board[row][col] == \\'E\\':\\n                score = 0\\n            if row == numRows - 1 and col == numCols - 1:\\n                return (0, 1)\\n            option1 = dp(row + 1, col)\\n            option2 = dp(row, col + 1)\\n            option3 = dp(row + 1, col + 1)\\n            count, ans = 0, score + max(option1[0], option2[0], option3[0])\\n            if score + option1[0] == ans: \\n                count = (count + option1[1]) % MOD\\n            if score + option2[0] == ans: \\n                count = (count + option2[1]) % MOD\\n            if score + option3[0] == ans:\\n                count = (count + option3[1]) % MOD\\n            return (ans, count % MOD)\\n\\n        ans = dp(0, 0)\\n        return [max(ans[0], 0), ans[1]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929453,
                "title": "cpp-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    pair<int,int>dp[101][101];\\n    pair<int,int>helper(int i , int j, vector<string>&nums){\\n        if(i==nums.size()||j==nums[0].size()||nums[i][j]==\\'X\\') return {INT_MIN,0};\\n        if(i==nums.size()-1&&j==nums[0].size()-1) return {0,1};\\n        int x=0;\\n        pair<int,int>p={-1,-1};\\n        if(dp[i][j]!=p){\\n            return dp[i][j];\\n        }\\n        if(nums[i][j]==\\'E\\') x=0 ;\\n        else{x=nums[i][j]-\\'0\\';}\\n        auto p1=helper(i+1,j,nums);\\n        auto p2=helper(i,j+1,nums);\\n        auto p3=helper(i+1,j+1,nums);\\n        int maxi=x+max(p1.first,max(p2.first,p3.first));\\n        int count=0;\\n        if(maxi==x+p1.first) count+=p1.second;\\n        if(maxi==x+p2.first) count+=p2.second;\\n        if(maxi==x+p3.first) count+=p3.second;\\n        return dp[i][j]={maxi,count%mod};\\n    }\\n    vector<int> pathsWithMaxScore(vector<string>& nums) {\\n        pair<int,int>p1={-1,-1};\\n        for(int i=0;i<=100;i++){\\n            for(int j=0;j<=100;j++){\\n                dp[i][j]=p1;\\n            }\\n        }\\n        auto ans=helper(0,0,nums);\\n        if(ans.first<0) return {0,0};\\n        return {ans.first,ans.second};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    pair<int,int>dp[101][101];\\n    pair<int,int>helper(int i , int j, vector<string>&nums){\\n        if(i==nums.size()||j==nums[0].size()||nums[i][j]==\\'X\\') return {INT_MIN,0};\\n        if(i==nums.size()-1&&j==nums[0].size()-1) return {0,1};\\n        int x=0;\\n        pair<int,int>p={-1,-1};\\n        if(dp[i][j]!=p){\\n            return dp[i][j];\\n        }\\n        if(nums[i][j]==\\'E\\') x=0 ;\\n        else{x=nums[i][j]-\\'0\\';}\\n        auto p1=helper(i+1,j,nums);\\n        auto p2=helper(i,j+1,nums);\\n        auto p3=helper(i+1,j+1,nums);\\n        int maxi=x+max(p1.first,max(p2.first,p3.first));\\n        int count=0;\\n        if(maxi==x+p1.first) count+=p1.second;\\n        if(maxi==x+p2.first) count+=p2.second;\\n        if(maxi==x+p3.first) count+=p3.second;\\n        return dp[i][j]={maxi,count%mod};\\n    }\\n    vector<int> pathsWithMaxScore(vector<string>& nums) {\\n        pair<int,int>p1={-1,-1};\\n        for(int i=0;i<=100;i++){\\n            for(int j=0;j<=100;j++){\\n                dp[i][j]=p1;\\n            }\\n        }\\n        auto ans=helper(0,0,nums);\\n        if(ans.first<0) return {0,0};\\n        return {ans.first,ans.second};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802020,
                "title": "c-dp-o-n-2-tc-o-n-sc",
                "content": "# Complexity\\n- Time complexity:\\n$O(n^2)$ -> `n` is the height and width of matrix `board`.\\n\\n- Space complexity:\\n$O(n)$ -> `n` is the height and width of matrix `board`.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static vector<int> pathsWithMaxScore(const vector<string>& board) {\\n        const int n = size(board);\\n        vector<pair<int, int>> dp(n), dp2(n);\\n        dp[0] = {0, 1};\\n        for (int i = 1; i < n; ++i)\\n            if (\\'X\\' == board[0][i])\\n                break;\\n            else\\n                dp[i] = {dp[i - 1].first + board[0][i] - \\'0\\', 1};\\n        for (int j = 1; j < n; ++j) {\\n            if (\\'X\\' != board[j][0] && dp[0].second)\\n                dp2[0] = {dp[0].first + board[j][0] - \\'0\\', 1};\\n            else\\n                dp2[0] = {0, 0};\\n            for (int i = 1; i < n; ++i) {\\n                auto& [dist, cnt] = dp2[i] = {0, 0};\\n                if (\\'X\\' == board[j][i])\\n                    continue;\\n               dist = max({dp2[i - 1].first, dp[i].first, dp[i - 1].first});\\n                if (dist == dp2[i - 1].first)\\n                    cnt = (cnt + dp2[i - 1].second) % 1000000007;;\\n                if (dist == dp[i].first)\\n                    cnt = (cnt + dp[i].second) % 1000000007;\\n                if (dist == dp[i - 1].first)\\n                    cnt = (cnt + dp[i - 1].second) % 1000000007;\\n                dist += board[j][i] - \\'0\\';\\n            }\\n            swap(dp, dp2);\\n        }\\n        if (dp.back().second)\\n            return {dp.back().first - \\'S\\' + \\'0\\', dp.back().second};\\n        return {0, 0};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static vector<int> pathsWithMaxScore(const vector<string>& board) {\\n        const int n = size(board);\\n        vector<pair<int, int>> dp(n), dp2(n);\\n        dp[0] = {0, 1};\\n        for (int i = 1; i < n; ++i)\\n            if (\\'X\\' == board[0][i])\\n                break;\\n            else\\n                dp[i] = {dp[i - 1].first + board[0][i] - \\'0\\', 1};\\n        for (int j = 1; j < n; ++j) {\\n            if (\\'X\\' != board[j][0] && dp[0].second)\\n                dp2[0] = {dp[0].first + board[j][0] - \\'0\\', 1};\\n            else\\n                dp2[0] = {0, 0};\\n            for (int i = 1; i < n; ++i) {\\n                auto& [dist, cnt] = dp2[i] = {0, 0};\\n                if (\\'X\\' == board[j][i])\\n                    continue;\\n               dist = max({dp2[i - 1].first, dp[i].first, dp[i - 1].first});\\n                if (dist == dp2[i - 1].first)\\n                    cnt = (cnt + dp2[i - 1].second) % 1000000007;;\\n                if (dist == dp[i].first)\\n                    cnt = (cnt + dp[i].second) % 1000000007;\\n                if (dist == dp[i - 1].first)\\n                    cnt = (cnt + dp[i - 1].second) % 1000000007;\\n                dist += board[j][i] - \\'0\\';\\n            }\\n            swap(dp, dp2);\\n        }\\n        if (dp.back().second)\\n            return {dp.back().first - \\'S\\' + \\'0\\', dp.back().second};\\n        return {0, 0};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710694,
                "title": "python-3-space-optimized-dp-o-n-2-o-n",
                "content": "```\\nclass Solution:\\n    MOD = 1000000007\\n    DIRECTIONS = (-1, 0), (0, -1), (-1, -1)\\n    \\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        n = len(board)\\n        firstCol = [[0, 1]] + [[0, 0] for _ in range(n - 1)]\\n        for i in range(1, n):\\n            if board[i][0] == \\'X\\':\\n                break\\n            firstCol[i] = [firstCol[i - 1][0] + int(board[i][0]), 1]\\n\\n        prevRow = [[0, 1]] + [[0, 0] for _ in range(n - 1)]\\n        for j in range(1, n):\\n            if board[0][j] == \\'X\\':\\n                break\\n            prevRow[j] = [prevRow[j - 1][0] + int(board[0][j]), 1]\\n        \\n        for i in range(1, n):\\n            curRow = [firstCol[i]] + [[0, 0] for _ in range(n - 1)]\\n            for j in range(1, n):\\n                if board[i][j] == \\'X\\':\\n                    continue    \\n                maxScore = maxPaths = 0\\n                for di, dj in Solution.DIRECTIONS:\\n                    row = prevRow if di else curRow\\n                    score, paths = row[j + dj]\\n                    if score > maxScore:\\n                        maxScore, maxPaths = score, paths\\n                    elif score == maxScore:\\n                        maxPaths = (maxPaths + paths) % Solution.MOD\\n\\n                if board[i][j] != \\'S\\':\\n                    maxScore += int(board[i][j])\\n                curRow[j] = [maxScore, maxPaths]\\n                \\n            prevRow = curRow\\n\\n        res = prevRow[-1]\\n        if res[1] == 0:\\n            res[0] = 0\\n        return res",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    MOD = 1000000007\\n    DIRECTIONS = (-1, 0), (0, -1), (-1, -1)\\n    \\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        n = len(board)\\n        firstCol = [[0, 1]] + [[0, 0] for _ in range(n - 1)]\\n        for i in range(1, n):\\n            if board[i][0] == \\'X\\':\\n                break\\n            firstCol[i] = [firstCol[i - 1][0] + int(board[i][0]), 1]\\n\\n        prevRow = [[0, 1]] + [[0, 0] for _ in range(n - 1)]\\n        for j in range(1, n):\\n            if board[0][j] == \\'X\\':\\n                break\\n            prevRow[j] = [prevRow[j - 1][0] + int(board[0][j]), 1]\\n        \\n        for i in range(1, n):\\n            curRow = [firstCol[i]] + [[0, 0] for _ in range(n - 1)]\\n            for j in range(1, n):\\n                if board[i][j] == \\'X\\':\\n                    continue    \\n                maxScore = maxPaths = 0\\n                for di, dj in Solution.DIRECTIONS:\\n                    row = prevRow if di else curRow\\n                    score, paths = row[j + dj]\\n                    if score > maxScore:\\n                        maxScore, maxPaths = score, paths\\n                    elif score == maxScore:\\n                        maxPaths = (maxPaths + paths) % Solution.MOD\\n\\n                if board[i][j] != \\'S\\':\\n                    maxScore += int(board[i][j])\\n                curRow[j] = [maxScore, maxPaths]\\n                \\n            prevRow = curRow\\n\\n        res = prevRow[-1]\\n        if res[1] == 0:\\n            res[0] = 0\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2700954,
                "title": "1301-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    vector<vector<vector<int>>> dp1;\\n    int fun(vector<string> &board,int i,int j,int &m){\\n        if(i>=m || j>=m || board[i][j]==\\'X\\')\\n            return INT_MIN;\\n        if(i==(m-1) && j==(m-1))\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int p=0,a,b,c;\\n        if(board[i][j]!=\\'E\\')\\n            p=int(board[i][j]-\\'0\\');\\n        a=p+fun(board,i,j+1,m);\\n        b=p+fun(board,i+1,j,m);\\n        c=p+fun(board,i+1,j+1,m);\\n        a=max(a,b);\\n        return dp[i][j]=max(a,c);\\n    }\\n    int fun1(vector<string> &board,int i,int j,int sum,int &m){\\n        if(i==(m-1) && j==(m-1))\\n            return sum==0;\\n        //if(sum==0)\\n            //return 0;\\n        if(i>=m || j>=m || board[i][j]==\\'X\\')\\n            return 0;\\n        if(sum>dp[i][j])\\n            return 0;\\n        if(dp1[i][j][sum]!=-1)\\n            return dp1[i][j][sum];\\n        int p=0;\\n        if(board[i][j]!=\\'E\\')\\n            p=int(board[i][j]-\\'0\\');\\n        long int ans;\\n        ans=fun1(board,i,j+1,max(0,sum-p),m)+fun1(board,i+1,j,max(0,sum-p),m)+fun1(board,i+1,j+1,max(0,sum-p),m);\\n        return dp1[i][j][sum]=ans%1000000007;\\n    }\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int m=board.size();\\n        dp.resize(m+1,vector<int>(m+1,-1));\\n        int a,b=0;\\n        a=fun(board,0,0,m);\\n        a=max(0,a);\\n       dp1.resize(m,vector<vector<int>>(m,vector<int>(a+1,-1)));\\n        b=fun1(board,0,0,a,m);\\n        vector<int> res;\\n        res.push_back(a);\\n        res.push_back(b);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    vector<vector<vector<int>>> dp1;\\n    int fun(vector<string> &board,int i,int j,int &m){\\n        if(i>=m || j>=m || board[i][j]==\\'X\\')\\n            return INT_MIN;\\n        if(i==(m-1) && j==(m-1))\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int p=0,a,b,c;\\n        if(board[i][j]!=\\'E\\')\\n            p=int(board[i][j]-\\'0\\');\\n        a=p+fun(board,i,j+1,m);\\n        b=p+fun(board,i+1,j,m);\\n        c=p+fun(board,i+1,j+1,m);\\n        a=max(a,b);\\n        return dp[i][j]=max(a,c);\\n    }\\n    int fun1(vector<string> &board,int i,int j,int sum,int &m){\\n        if(i==(m-1) && j==(m-1))\\n            return sum==0;\\n        //if(sum==0)\\n            //return 0;\\n        if(i>=m || j>=m || board[i][j]==\\'X\\')\\n            return 0;\\n        if(sum>dp[i][j])\\n            return 0;\\n        if(dp1[i][j][sum]!=-1)\\n            return dp1[i][j][sum];\\n        int p=0;\\n        if(board[i][j]!=\\'E\\')\\n            p=int(board[i][j]-\\'0\\');\\n        long int ans;\\n        ans=fun1(board,i,j+1,max(0,sum-p),m)+fun1(board,i+1,j,max(0,sum-p),m)+fun1(board,i+1,j+1,max(0,sum-p),m);\\n        return dp1[i][j][sum]=ans%1000000007;\\n    }\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int m=board.size();\\n        dp.resize(m+1,vector<int>(m+1,-1));\\n        int a,b=0;\\n        a=fun(board,0,0,m);\\n        a=max(0,a);\\n       dp1.resize(m,vector<vector<int>>(m,vector<int>(a+1,-1)));\\n        b=fun1(board,0,0,a,m);\\n        vector<int> res;\\n        res.push_back(a);\\n        res.push_back(b);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659998,
                "title": "top-down",
                "content": "```\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        \\n        \\n        n = len(board)\\n        @lru_cache(None)\\n        def dfs(i,j):\\n            if i == 0 and j == 0:\\n                return 0, 1\\n            \\n            if i < 0 or j < 0 or board[i][j] == \\'X\\':\\n                return 0, 0\\n            \\n            \\n            upper_res, upper_count = dfs(i-1,j)\\n            dia_res, dia_count = dfs(i-1,j-1)\\n            left_res, left_count = dfs(i,j-1)\\n            \\n            val = int(board[i][j]) if board[i][j] not in \\'ES\\' else 0\\n            \\n            res = max(upper_res, dia_res, left_res)\\n            count = 0\\n            if upper_res == res:\\n                count += upper_count\\n            if dia_res == res:\\n                count += dia_count\\n            if left_res == res:\\n                count += left_count\\n            \\n            return res + val, count%(10**9+7)\\n        \\n        \\n        res=  dfs(n-1,n-1)\\n        if res[1] == 0:\\n            return [0,0]\\n        return res\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        \\n        \\n        n = len(board)\\n        @lru_cache(None)\\n        def dfs(i,j):\\n            if i == 0 and j == 0:\\n                return 0, 1\\n            \\n            if i < 0 or j < 0 or board[i][j] == \\'X\\':\\n                return 0, 0\\n            \\n            \\n            upper_res, upper_count = dfs(i-1,j)\\n            dia_res, dia_count = dfs(i-1,j-1)\\n            left_res, left_count = dfs(i,j-1)\\n            \\n            val = int(board[i][j]) if board[i][j] not in \\'ES\\' else 0\\n            \\n            res = max(upper_res, dia_res, left_res)\\n            count = 0\\n            if upper_res == res:\\n                count += upper_count\\n            if dia_res == res:\\n                count += dia_count\\n            if left_res == res:\\n                count += left_count\\n            \\n            return res + val, count%(10**9+7)\\n        \\n        \\n        res=  dfs(n-1,n-1)\\n        if res[1] == 0:\\n            return [0,0]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628931,
                "title": "python-solution-dp-solution",
                "content": "Initialize with [0,0] at [0,0], [0,1] at [n-1,n-1]. Whether there is path to a point is indicated by the len of dp entry\\n\\n```\\nclass Solution:\\n    # Solve by DP\\n    # dp[i][j] = [max_score, path_count]\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        n, MOD = len(board), pow(10,9) + 7\\n        dp = [[[] for i in range(n)] for j in range(n)]\\n        dp[0][0], dp[n-1][n-1] = [0,0], [0,1]\\n        for i in range(n-2,-1,-1):\\n            if board[i][n-1] != \"X\" and len(dp[i+1][n-1]) == 2:\\n                dp[i][n-1] = [dp[i+1][n-1][0] + int(board[i][n-1]),1]\\n        for i in range(n-2,-1,-1):\\n            if board[n-1][i] != \"X\" and len(dp[n-1][i+1]) == 2:\\n                dp[n-1][i] = [dp[n-1][i+1][0] + int(board[n-1][i]),1]\\n                \\n        for i in range(n-2,-1,-1):\\n            for j in range(n-2,-1,-1):\\n                if board[i][j] != \"X\":\\n                    candidates = []\\n                    if i == 0 and j == 0:\\n                        cur_score = 0\\n                    else:\\n                        cur_score = int(board[i][j])\\n                    if len(dp[i+1][j]) == 2:\\n                        candidates.append(dp[i+1][j])\\n                    if len(dp[i+1][j+1]) == 2:\\n                        candidates.append(dp[i+1][j+1])\\n                    if len(dp[i][j+1]) == 2:\\n                        candidates.append(dp[i][j+1])\\n                    if candidates:\\n                        candidates.sort(key = lambda x:[-x[0]])\\n                        max_score = candidates[0][0]\\n                        dp[i][j] = [max_score + cur_score, 0]\\n                        for score, count in candidates:\\n                            if score == max_score:\\n                                dp[i][j][1] += count\\n                                dp[i][j][1] %= MOD\\n        return dp[0][0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # Solve by DP\\n    # dp[i][j] = [max_score, path_count]\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        n, MOD = len(board), pow(10,9) + 7\\n        dp = [[[] for i in range(n)] for j in range(n)]\\n        dp[0][0], dp[n-1][n-1] = [0,0], [0,1]\\n        for i in range(n-2,-1,-1):\\n            if board[i][n-1] != \"X\" and len(dp[i+1][n-1]) == 2:\\n                dp[i][n-1] = [dp[i+1][n-1][0] + int(board[i][n-1]),1]\\n        for i in range(n-2,-1,-1):\\n            if board[n-1][i] != \"X\" and len(dp[n-1][i+1]) == 2:\\n                dp[n-1][i] = [dp[n-1][i+1][0] + int(board[n-1][i]),1]\\n                \\n        for i in range(n-2,-1,-1):\\n            for j in range(n-2,-1,-1):\\n                if board[i][j] != \"X\":\\n                    candidates = []\\n                    if i == 0 and j == 0:\\n                        cur_score = 0\\n                    else:\\n                        cur_score = int(board[i][j])\\n                    if len(dp[i+1][j]) == 2:\\n                        candidates.append(dp[i+1][j])\\n                    if len(dp[i+1][j+1]) == 2:\\n                        candidates.append(dp[i+1][j+1])\\n                    if len(dp[i][j+1]) == 2:\\n                        candidates.append(dp[i][j+1])\\n                    if candidates:\\n                        candidates.sort(key = lambda x:[-x[0]])\\n                        max_score = candidates[0][0]\\n                        dp[i][j] = [max_score + cur_score, 0]\\n                        for score, count in candidates:\\n                            if score == max_score:\\n                                dp[i][j][1] += count\\n                                dp[i][j][1] %= MOD\\n        return dp[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614521,
                "title": "dp-on-dag-problem",
                "content": "First of all, you need to notice that the given graph is **DAG**. \\n\\nThanks to this fact, for all nodes, you can determine the longest path costs  from bottom-right to top-left by dynamic programming. \\n\\n(If graph is not **DAG**, this problem will be classified as NP-Hard.)\\n\\nHere\\'s my implemention in C++.\\n\\nTime complexity : O(N ^ 2), Space complexity : O(N ^ 2)\\n\\n```\\ntypedef pair<int, int> pii;\\nconst int modulo = 1e9 + 7;\\nconst int inf = 1e9;\\nconst vector<pii>dxy = {{0, -1}, {-1, -1}, {-1, 0}};\\n\\nclass Solution {\\npublic:\\n    inline bool inside(int x, int y, int n){\\n        if (x < 0 || n <= x){return false;}\\n        if (y < 0 || n <= y){return false;}\\n        return true;\\n    }\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        const int n = board.size();\\n        vector<vector<int>> dist(n, vector<int>(n, -inf));\\n        vector<vector<int>> ways(n, vector<int>(n));\\n        dist[n - 1][n - 1] = 0;\\n        ways[n - 1][n - 1] = 1;\\n\\n        for (int i = n - 1; i >= 0; i--){\\n            for (int j = n - 1; j >= 0; j--){\\n                for (auto & [dx, dy] : dxy){\\n                    int nx = i + dx, ny = j + dy;\\n                    if (!inside(nx, ny, n) || board[nx][ny] == \\'X\\'){continue;}\\n                    int cost = (board[nx][ny] == \\'E\\' ? 0 : board[nx][ny] - \\'0\\');\\n                    int new_d = dist[i][j] + cost;\\n                    if (dist[nx][ny] < new_d){\\n                        dist[nx][ny] = new_d;\\n                        ways[nx][ny] = ways[i][j];\\n                    }else if (dist[nx][ny] == new_d){\\n                        ways[nx][ny] += ways[i][j];\\n                        ways[nx][ny] %= modulo;\\n                    }\\n                }\\n            }\\n        }\\n        if (ways[0][0] == 0){\\n            return {0, 0};\\n        }else{\\n            return {dist[0][0], ways[0][0]};\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\ntypedef pair<int, int> pii;\\nconst int modulo = 1e9 + 7;\\nconst int inf = 1e9;\\nconst vector<pii>dxy = {{0, -1}, {-1, -1}, {-1, 0}};\\n\\nclass Solution {\\npublic:\\n    inline bool inside(int x, int y, int n){\\n        if (x < 0 || n <= x){return false;}\\n        if (y < 0 || n <= y){return false;}\\n        return true;\\n    }\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        const int n = board.size();\\n        vector<vector<int>> dist(n, vector<int>(n, -inf));\\n        vector<vector<int>> ways(n, vector<int>(n));\\n        dist[n - 1][n - 1] = 0;\\n        ways[n - 1][n - 1] = 1;\\n\\n        for (int i = n - 1; i >= 0; i--){\\n            for (int j = n - 1; j >= 0; j--){\\n                for (auto & [dx, dy] : dxy){\\n                    int nx = i + dx, ny = j + dy;\\n                    if (!inside(nx, ny, n) || board[nx][ny] == \\'X\\'){continue;}\\n                    int cost = (board[nx][ny] == \\'E\\' ? 0 : board[nx][ny] - \\'0\\');\\n                    int new_d = dist[i][j] + cost;\\n                    if (dist[nx][ny] < new_d){\\n                        dist[nx][ny] = new_d;\\n                        ways[nx][ny] = ways[i][j];\\n                    }else if (dist[nx][ny] == new_d){\\n                        ways[nx][ny] += ways[i][j];\\n                        ways[nx][ny] %= modulo;\\n                    }\\n                }\\n            }\\n        }\\n        if (ways[0][0] == 0){\\n            return {0, 0};\\n        }else{\\n            return {dist[0][0], ways[0][0]};\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586566,
                "title": "c-memoization-approach-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<pair<int,int>>> dp;\\n    bool ok;\\n    const int M = 1e9 + 7;\\n    \\n    bool inRange(int i, int j){\\n        return i >= 0 && j >= 0;\\n    }\\n    \\n    pair<int,int> func(vector<string>& board, int i, int j){\\n        if(i == 0 && j == 0){\\n            ok = true;\\n            return {0,1};\\n        }\\n        \\n        if(dp[i][j] != make_pair(-1,-1)) return dp[i][j];\\n        \\n        int score1 = 0, score2 = 0, score3 = 0, max_score = 0, cnt = 0, cnt1 = 0, cnt2 = 0, cnt3 = 0;\\n        \\n        if(inRange(i-1,j) && (isdigit(board[i-1][j]) || (i-1 == 0 && j == 0))){\\n            int val = (i-1 == 0 && j == 0 ? 0 : board[i-1][j]-\\'0\\');\\n            pair<int,int> p = func(board, i-1, j);\\n            score1 = val + p.first;\\n            cnt1 += p.second;\\n        }\\n        \\n        if(inRange(i,j-1) && (isdigit(board[i][j-1]) || (i == 0 && j-1 == 0))){\\n            int val = (i == 0 && j-1 == 0 ? 0 : board[i][j-1]-\\'0\\');\\n            pair<int,int> p = func(board, i, j-1);\\n            score2 = val + p.first;\\n            cnt2 += p.second;\\n        }\\n        \\n        if(inRange(i-1,j-1) && (isdigit(board[i-1][j-1]) || (i-1 == 0 && j-1 == 0))){\\n            int val = (i-1 == 0 && j-1 == 0 ? 0 : board[i-1][j-1]-\\'0\\');\\n            pair<int,int> p = func(board, i-1, j-1);\\n            score3 = val + p.first;\\n            cnt3 += p.second;\\n        }\\n        \\n        max_score = max(score1, max(score2, score3));\\n        \\n        if(max_score == score1) cnt = (cnt + cnt1) % M;\\n        if(max_score == score2) cnt = (cnt + cnt2) % M;\\n        if(max_score == score3) cnt = (cnt + cnt3) % M;\\n\\n        \\n        return dp[i][j] = {max_score,cnt};\\n    }\\n    \\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        n = board.size();\\n        ok = false;\\n        dp.assign(n,vector<pair<int,int>>(n,{-1,-1}));\\n        pair<int,int> p = func(board, n-1, n-1);\\n        int max_score = p.first;\\n        int cnt = p.second;\\n        \\n        if(ok) return {max_score, cnt};\\n        return {0,0};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<pair<int,int>>> dp;\\n    bool ok;\\n    const int M = 1e9 + 7;\\n    \\n    bool inRange(int i, int j){\\n        return i >= 0 && j >= 0;\\n    }\\n    \\n    pair<int,int> func(vector<string>& board, int i, int j){\\n        if(i == 0 && j == 0){\\n            ok = true;\\n            return {0,1};\\n        }\\n        \\n        if(dp[i][j] != make_pair(-1,-1)) return dp[i][j];\\n        \\n        int score1 = 0, score2 = 0, score3 = 0, max_score = 0, cnt = 0, cnt1 = 0, cnt2 = 0, cnt3 = 0;\\n        \\n        if(inRange(i-1,j) && (isdigit(board[i-1][j]) || (i-1 == 0 && j == 0))){\\n            int val = (i-1 == 0 && j == 0 ? 0 : board[i-1][j]-\\'0\\');\\n            pair<int,int> p = func(board, i-1, j);\\n            score1 = val + p.first;\\n            cnt1 += p.second;\\n        }\\n        \\n        if(inRange(i,j-1) && (isdigit(board[i][j-1]) || (i == 0 && j-1 == 0))){\\n            int val = (i == 0 && j-1 == 0 ? 0 : board[i][j-1]-\\'0\\');\\n            pair<int,int> p = func(board, i, j-1);\\n            score2 = val + p.first;\\n            cnt2 += p.second;\\n        }\\n        \\n        if(inRange(i-1,j-1) && (isdigit(board[i-1][j-1]) || (i-1 == 0 && j-1 == 0))){\\n            int val = (i-1 == 0 && j-1 == 0 ? 0 : board[i-1][j-1]-\\'0\\');\\n            pair<int,int> p = func(board, i-1, j-1);\\n            score3 = val + p.first;\\n            cnt3 += p.second;\\n        }\\n        \\n        max_score = max(score1, max(score2, score3));\\n        \\n        if(max_score == score1) cnt = (cnt + cnt1) % M;\\n        if(max_score == score2) cnt = (cnt + cnt2) % M;\\n        if(max_score == score3) cnt = (cnt + cnt3) % M;\\n\\n        \\n        return dp[i][j] = {max_score,cnt};\\n    }\\n    \\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        n = board.size();\\n        ok = false;\\n        dp.assign(n,vector<pair<int,int>>(n,{-1,-1}));\\n        pair<int,int> p = func(board, n-1, n-1);\\n        int max_score = p.first;\\n        int cnt = p.second;\\n        \\n        if(ok) return {max_score, cnt};\\n        return {0,0};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2577229,
                "title": "pyhton-beats-100",
                "content": "```\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        \\n        @lru_cache(None)\\n        def maxScore(row, col):\\n            if row == 0 and col == 0:\\n                return 0, 1\\n            \\n            best = -float(\"inf\")\\n            cur = int(board[row][col]) if board[row][col] != \"S\" else 0\\n            paths = 0\\n            \\n            if row != 0 and board[row-1][col] != \"X\":\\n                best, paths = maxScore(row-1, col)\\n            if col != 0 and board[row][col-1] != \"X\":\\n                tmpScore, tmpPaths = maxScore(row, col-1)\\n                if tmpScore > best:\\n                    best = tmpScore\\n                    paths = tmpPaths\\n                elif tmpScore == best:\\n                    paths += tmpPaths\\n            if row != 0 and col != 0 and board[row-1][col-1] != \"X\":\\n                tmpScore, tmpPaths = maxScore(row-1, col-1)\\n                if tmpScore > best:\\n                    best = tmpScore\\n                    paths = tmpPaths\\n                elif tmpScore == best:\\n                    paths += tmpPaths\\n            return best + cur, paths\\n        \\n        score, paths = maxScore(len(board)-1, len(board[0])-1)\\n        \\n        if score == -inf:\\n            return [0, 0]\\n        \\n        return score, paths % (10**9+7)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        \\n        @lru_cache(None)\\n        def maxScore(row, col):\\n            if row == 0 and col == 0:\\n                return 0, 1\\n            \\n            best = -float(\"inf\")\\n            cur = int(board[row][col]) if board[row][col] != \"S\" else 0\\n            paths = 0\\n            \\n            if row != 0 and board[row-1][col] != \"X\":\\n                best, paths = maxScore(row-1, col)\\n            if col != 0 and board[row][col-1] != \"X\":\\n                tmpScore, tmpPaths = maxScore(row, col-1)\\n                if tmpScore > best:\\n                    best = tmpScore\\n                    paths = tmpPaths\\n                elif tmpScore == best:\\n                    paths += tmpPaths\\n            if row != 0 and col != 0 and board[row-1][col-1] != \"X\":\\n                tmpScore, tmpPaths = maxScore(row-1, col-1)\\n                if tmpScore > best:\\n                    best = tmpScore\\n                    paths = tmpPaths\\n                elif tmpScore == best:\\n                    paths += tmpPaths\\n            return best + cur, paths\\n        \\n        score, paths = maxScore(len(board)-1, len(board[0])-1)\\n        \\n        if score == -inf:\\n            return [0, 0]\\n        \\n        return score, paths % (10**9+7)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522606,
                "title": "recursion-memo",
                "content": "#define mod 1000000007\\n\\nint check(int i,int j,vector<string>& grid,vector<vector<int>>&dp){\\n  if(i==0 and j==0)return 0;\\n  if(i<0 or j<0 or grid[i][j]==\\'X\\')return -1e9;\\n  if(dp[i][j]!=-1)return dp[i][j];\\n  \\n  int curr=0;\\n  if(grid[i][j]!=\\'S\\')curr = grid[i][j]-\\'0\\';\\n  \\n  int ans = curr + max( check(i-1,j-1,grid,dp), max(check(i-1,j,grid,dp),check(i,j-1,grid,dp))); \\n  return dp[i][j] =  ans;\\n  \\n}\\n\\nint check(int i,int j,vector<string>& grid,int p,map<pair<pair<int,int>,int>,int>&mp,vector<vector<int>>&dp){\\n  if(i==0 and j==0)return p==0;\\n  if(i<0 or j<0 or grid[i][j]==\\'X\\')return 0;\\n  if(p>dp[i][j])return 0;\\n  \\n  if(mp.find({{i,j},p})!=mp.end()) return mp[{{i,j},p}];\\n  \\n  \\n  long long int curr=0;\\n  if(grid[i][j]!=\\'S\\')curr = grid[i][j]-\\'0\\';\\n  \\n  long long int ans = check(i-1,j-1,grid,p-curr,mp,dp) + check(i-1,j,grid,p-curr,mp,dp)+ check(i,j-1,grid,p-curr,mp,dp); \\n  ans=ans%mod;\\n  return  mp[{{i,j},p}] =  ans;\\n  \\n  \\n  \\n  \\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& grid) {\\n      int n = grid.size();\\n      vector<vector<int>> dp(101,vector<int>(101,-1));\\n      int p = check(n-1,n-1,grid,dp);\\n      \\n      map<pair<pair<int,int>,int>,int> mp;\\n      int ways = check(n-1,n-1,grid,p,mp,dp)%mod;\\n      if(ways==0)p=0;\\n      return {p,ways};\\n      \\n    }\\n};``",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& grid) {\\n      int n = grid.size();\\n      vector<vector<int>> dp(101,vector<int>(101,-1));\\n      int p = check(n-1,n-1,grid,dp);\\n      \\n      map<pair<pair<int,int>,int>,int> mp;\\n      int ways = check(n-1,n-1,grid,p,mp,dp)%mod;\\n      if(ways==0)p=0;\\n      return {p,ways}",
                "codeTag": "Java"
            },
            {
                "id": 2472790,
                "title": "c-clean-solution-bottom-up-single-dp-array",
                "content": "#define ll long long int\\n\\nclass Solution {\\npublic:\\n    \\n    \\n    int n;\\n    const int mod = 1e9 + 7;\\n    \\n    bool check(int x, int y)\\n    {\\n         if((x >= 0) and (x < n) and (y >= 0) and (y < n))\\n             return 1;\\n        else return 0;\\n    }\\n    \\n    \\n    vector<int> pathsWithMaxScore(vector<string>& arr) {\\n        \\n        n = arr.size();\\n        \\n        pair<ll, ll> x = {0, 0};\\n        vector< vector< pair<ll,ll> > > dp(n, vector< pair<ll,ll> >(n, x));\\n        \\n        dp[0][0] = {0, 1};\\n        \\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++)\\n          if(arr[i][j] != \\'X\\') \\n            {\\n                if((i == j) and (j == 0))\\n                    continue;\\n              \\n                auto p1  = check(i-1, j) ? dp[i-1][j]: x;\\n                auto p2 = check(i, j-1)? dp[i][j-1]: x;\\n                auto p3 = check(i-1, j-1)? dp[i-1][j-1]: x;\\n                ll add = 0;\\n              \\n                dp[i][j] = {p1.first, p1.second % mod};\\n              \\n                if(dp[i][j].first == p2.first)\\n                    dp[i][j].second = (dp[i][j].second + p2.second) % mod;\\n              else if(dp[i][j].first < p2.first)\\n                    dp[i][j] = {p2.first, p2.second % mod};\\n              \\n                if(dp[i][j].first == p3.first)\\n                    dp[i][j].second = (dp[i][j].second + p3.second) % mod;\\n                else if(dp[i][j].first < p3.first)\\n                    dp[i][j] = {p3.first, p3.second % mod};\\n\\n                if((arr[i][j] >= \\'1\\') and (arr[i][j] <= \\'9\\'))\\n                    add = arr[i][j] - \\'0\\';\\n              \\n                dp[i][j].first = dp[i][j].first + add;\\n              \\n            }\\n        \\n        \\n      if(dp[n-1][n-1].second == 0)\\n          return {0, 0};\\n        \\n        \\n        ll k = dp[n-1][n-1].second % mod;\\n        \\n        int p1 = (int)dp[n-1][n-1].first;\\n        int p2 = (int) k;\\n        \\n        return {p1, p2};\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    int n;\\n    const int mod = 1e9 + 7;\\n    \\n    bool check(int x, int y)\\n    {\\n         if((x >= 0) and (x < n) and (y >= 0) and (y < n))\\n             return 1;\\n        else return 0;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2414221,
                "title": "c-using-class-and-dynamic-programming-easy-solution",
                "content": "class Solution {\\npublic:\\n    int mod=1e9+7;\\n    class ds{\\n        public:\\n        int sum=0;\\n        int path=0;\\n        public:\\n        ds(int sum,int path)\\n        {\\n            this->sum=sum;\\n            this->path=path;\\n        }\\n    };\\n    ds rec(vector<string> &nums,int i,int j,vector<vector<ds>> &dp)\\n    {\\n        if(i<0 or j<0 or i>=nums.size() or j>=nums[i].size() or nums[i][j]==\\'X\\')\\n        {\\n            return ds(-1e9,0);\\n        }\\n        if(i==0 and j==0)\\n        {\\n            return ds(0,1);\\n        }\\n        if(dp[i][j].sum!=-1 or dp[i][j].path!=-1)\\n            return dp[i][j];\\n        auto l=rec(nums,i-1,j,dp);\\n        auto r=rec(nums,i,j-1,dp);\\n        auto u=rec(nums,i-1,j-1,dp);\\n        int ma=max(l.sum,max(r.sum,u.sum));\\n        int pa=0;\\n        if(ma==l.sum)\\n            pa=(pa+l.path)%mod;\\n        if(ma==r.sum)\\n            pa=(pa+r.path)%mod;\\n        if(ma==u.sum)\\n            pa=(pa+u.path)%mod;\\n        ma=(ma+(int)nums[i][j]-\\'0\\')%mod;\\n        return dp[i][j]=ds(ma,pa);\\n    }\\n    vector<int> pathsWithMaxScore(vector<string>& nums) {\\n        int n=nums.size();\\n        vector<vector<ds>> dp(n+1,vector<ds>(n+1,ds(-1,-1)));\\n        auto ans=rec(nums,n-2,n-1,dp);\\n        auto ans1=rec(nums,n-2,n-2,dp);\\n        auto ans2=rec(nums,n-1,n-2,dp);\\n        int ma=max(ans.sum,max(ans1.sum,ans2.sum))%mod;\\n        int pa=0;\\n        if(ma==ans.sum)\\n            pa=(pa+ans.path)%mod;\\n        if(ma==ans1.sum)\\n            pa=(pa+ans1.path)%mod;\\n        if(ma==ans2.sum)\\n            pa=(pa+ans2.path)%mod;\\n        if(ma<0)\\n        {\\n            ma=0;\\n            pa=0;\\n        }\\n        vector<int> an;\\n        an.push_back(ma);\\n        an.push_back(pa);\\n        return an;\\n        \\n    }\\n};[](http://)};[](http://)};[](http://)};[](http://)",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int mod=1e9+7;\\n    class ds{\\n        public:\\n        int sum=0;\\n        int path=0;\\n        public:\\n        ds(int sum,int path)\\n        {\\n            this->sum=sum;\\n            this->path=path;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2402523,
                "title": "dp-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint N = 1e9 + 7;\\n\\t\\tpair<int,int> dp[101][101];\\n\\t\\tvector<int> pathsWithMaxScore(vector<string>& board) {\\n\\t\\t\\tint n = board.size();\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tfor(int j=0;j<n;j++){\\n\\t\\t\\t\\t\\tdp[i][j] = {INT16_MIN,1};\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tdp[n-1][n-1].first = 0;\\n\\t\\t\\tdp[0][0].first = 0;\\n\\t\\t\\tfor(int i=n-1;i>=0;i--){\\n\\t\\t\\t\\tfor(int j=n-1;j>=0;j--){\\n\\t\\t\\t\\t\\tif(board[i][j]==\\'X\\') continue;\\n\\t\\t\\t\\t\\t\\tif(i+1<n){\\n\\t\\t\\t\\t\\t\\t\\tif((dp[i+1][j].first+board[i][j]-\\'0\\')%N > dp[i][j].first){\\n\\t\\t\\t\\t\\t\\t\\t\\tdp[i][j] = {(dp[i+1][j].first + board[i][j]-\\'0\\')%N,dp[i+1][j].second};\\n\\t\\t\\t\\t\\t\\t\\t}else if((dp[i+1][j].first + board[i][j]-\\'0\\')%N == dp[i][j].first){\\n\\t\\t\\t\\t\\t\\t\\t\\tdp[i][j].second = (dp[i][j].second + dp[i+1][j].second)%N;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(j+1<n){\\n\\t\\t\\t\\t\\t\\t\\tif((dp[i][j+1].first+board[i][j]-\\'0\\')%N > dp[i][j].first){\\n\\t\\t\\t\\t\\t\\t\\t\\tdp[i][j] = {(dp[i][j+1].first + board[i][j]-\\'0\\')%N,dp[i][j+1].second};\\n\\t\\t\\t\\t\\t\\t\\t}else if((dp[i][j+1].first + board[i][j]-\\'0\\')%N == dp[i][j].first){\\n\\t\\t\\t\\t\\t\\t\\t\\tdp[i][j].second = (dp[i][j].second + dp[i][j+1].second)%N;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(i+1<n && j+1<n){\\n\\t\\t\\t\\t\\t\\t\\tif((dp[i+1][j+1].first+board[i][j]-\\'0\\')%N > dp[i][j].first){\\n\\t\\t\\t\\t\\t\\t\\t\\tdp[i][j] = {(dp[i+1][j+1].first + board[i][j]-\\'0\\')%N,dp[i+1][j+1].second};\\n\\t\\t\\t\\t\\t\\t\\t}else if((dp[i+1][j+1].first + board[i][j]-\\'0\\')%N == dp[i][j].first){\\n\\t\\t\\t\\t\\t\\t\\t\\tdp[i][j].second = (dp[i][j].second + dp[i+1][j+1].second)%N;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(dp[0][0].first == 0) return {0,0}; \\n\\t\\t\\tdp[0][0].first -= board[0][0] - \\'0\\';\\n\\t\\t\\treturn {dp[0][0].first,dp[0][0].second};\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint N = 1e9 + 7;\\n\\t\\tpair<int,int> dp[101][101];\\n\\t\\tvector<int> pathsWithMaxScore(vector<string>& board) {\\n\\t\\t\\tint n = board.size();\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tfor(int j=0;j<n;j++){\\n\\t\\t\\t\\t\\tdp[i][j] = {INT16_MIN,1}",
                "codeTag": "Java"
            },
            {
                "id": 2377763,
                "title": "javascript-two-approaches-dp-recursion-w-memoization",
                "content": "**Solution 1: DP - Tabulation**\\n\\nKeep track of the max score and number of paths.\\nStart from the bottom right corner and traverse the three possible paths from each position: right, bottom right, bottom\\n\\nIf the score is bigger than the current max score, update it to the new score and number of paths from that path.\\nIf the score is equal to the current max score, add to the number of paths.\\n\\nThings to keep in mind:\\n*   There is no path for `\\'X\\'`.\\n*   Only calculate the score for the current square if it\\'s a number (not `\\'S\\'` or `\\'E\\'`).\\n\\nTime Complexity: `O(n^2)` 246ms\\nSpace Complexity: `O(n^2)` 61.8MB\\n```\\nvar pathsWithMaxScore = function(board) {\\n  let n = board.length, dp = Array(n + 1).fill(0).map(() => Array(n + 1).fill(0).map(() => [-Infinity, 0]));\\n  let mod = 10 ** 9 + 7;\\n  dp[n - 1][n - 1] = [0, 1]; // [max score, number of paths]\\n  \\n  for (let i = n - 1; i >= 0; i--) {\\n    for (let j = n - 1; j >= 0; j--) {\\n      if (board[i][j] === \\'X\\' || board[i][j] === \\'S\\') continue;\\n      \\n      let paths = [dp[i][j + 1], dp[i + 1][j + 1], dp[i + 1][j]];\\n      for (let [maxScore, numPaths] of paths) {\\n        if (dp[i][j][0] < maxScore) {\\n          dp[i][j] = [maxScore, numPaths];\\n        } else if (dp[i][j][0] === maxScore) {\\n          dp[i][j][1] = (dp[i][j][1] + numPaths) % mod;\\n        }\\n      }\\n      let score = board[i][j] === \\'E\\' ? 0 : Number(board[i][j]);\\n      dp[i][j][0] += score;\\n    }\\n  }\\n  return dp[0][0][1] === 0 ? [0, 0] : dp[0][0];\\n};\\n```\\n\\n\\n**Solution 2: DP - Recursion w/ Memoization**\\n\\nThe same idea as solution 1, but a different approach using recursion and memoization.\\n\\nTime Complexity: `O(n^2)` 167ms\\nSpace Complexity: `O(n^2)` 59.4MB\\n```\\nvar pathsWithMaxScore = function(board) {\\n  let n = board.length, memo = Array(n).fill(0).map(() => Array(n).fill(0).map(() => null));\\n  let mod = 10 ** 9 + 7;\\n  let res = dp(n - 1, n - 1);\\n  return res[1] === 0 ? [0, 0] : res;\\n  \\n  function dp(i, j) {\\n    if (i < 0 || j < 0 || board[i][j] === \\'X\\') return [-Infinity, 0];\\n    if (i === 0 && j === 0) return [0, 1];\\n    if (memo[i][j] !== null) return memo[i][j];\\n    \\n    let ans = [-Infinity, 0];\\n    let paths = [dp(i, j - 1), dp(i - 1, j - 1), dp(i - 1, j)];\\n    for (let [maxScore, numPaths] of paths) {\\n      if (maxScore > ans[0]) {\\n        ans = [maxScore, numPaths];\\n      } else if (maxScore === ans[0]) {\\n        ans[1] = (ans[1] + numPaths) % mod;\\n      }\\n    }\\n    if (ans[0] !== -Infinity && board[i][j] !== \\'S\\') ans[0] += Number(board[i][j]);\\n    return memo[i][j] = ans;\\n  }\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar pathsWithMaxScore = function(board) {\\n  let n = board.length, dp = Array(n + 1).fill(0).map(() => Array(n + 1).fill(0).map(() => [-Infinity, 0]));\\n  let mod = 10 ** 9 + 7;\\n  dp[n - 1][n - 1] = [0, 1]; // [max score, number of paths]\\n  \\n  for (let i = n - 1; i >= 0; i--) {\\n    for (let j = n - 1; j >= 0; j--) {\\n      if (board[i][j] === \\'X\\' || board[i][j] === \\'S\\') continue;\\n      \\n      let paths = [dp[i][j + 1], dp[i + 1][j + 1], dp[i + 1][j]];\\n      for (let [maxScore, numPaths] of paths) {\\n        if (dp[i][j][0] < maxScore) {\\n          dp[i][j] = [maxScore, numPaths];\\n        } else if (dp[i][j][0] === maxScore) {\\n          dp[i][j][1] = (dp[i][j][1] + numPaths) % mod;\\n        }\\n      }\\n      let score = board[i][j] === \\'E\\' ? 0 : Number(board[i][j]);\\n      dp[i][j][0] += score;\\n    }\\n  }\\n  return dp[0][0][1] === 0 ? [0, 0] : dp[0][0];\\n};\\n```\n```\\nvar pathsWithMaxScore = function(board) {\\n  let n = board.length, memo = Array(n).fill(0).map(() => Array(n).fill(0).map(() => null));\\n  let mod = 10 ** 9 + 7;\\n  let res = dp(n - 1, n - 1);\\n  return res[1] === 0 ? [0, 0] : res;\\n  \\n  function dp(i, j) {\\n    if (i < 0 || j < 0 || board[i][j] === \\'X\\') return [-Infinity, 0];\\n    if (i === 0 && j === 0) return [0, 1];\\n    if (memo[i][j] !== null) return memo[i][j];\\n    \\n    let ans = [-Infinity, 0];\\n    let paths = [dp(i, j - 1), dp(i - 1, j - 1), dp(i - 1, j)];\\n    for (let [maxScore, numPaths] of paths) {\\n      if (maxScore > ans[0]) {\\n        ans = [maxScore, numPaths];\\n      } else if (maxScore === ans[0]) {\\n        ans[1] = (ans[1] + numPaths) % mod;\\n      }\\n    }\\n    if (ans[0] !== -Infinity && board[i][j] !== \\'S\\') ans[0] += Number(board[i][j]);\\n    return memo[i][j] = ans;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2253048,
                "title": "java-dp-start-from-top-left",
                "content": "It is weird to traverse from the bottom right to top left. There is no reason we can\\'t just reverse that, so that\\'s what I did.\\n\\nAlso, we don\\'t really have to check for each conditions. Just define a dirs array in the beginning and do the boundary check on that.\\n\\nAnother thing that may be worth pointing out is that any path is strictly increasing.\\n\\nThere is only 1 base case. `ways[0][0]=1`.\\n\\n```Java\\nclass Solution {\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int M = (int)1e9+7;\\n        int m = board.size();\\n        int n = board.get(0).length();\\n        int[][] dp = new int[m][n];\\n        int[][] ways = new int[m][n];\\n        ways[0][0]=1; // base case.\\n        int[][] dirs = {{-1, 0}, {0, -1}, {-1, -1}}; // all 3 ways where we can travel.\\n        for (int i=0;i<m;i++){\\n            for (int j=0;j<n;j++){\\n                if (board.get(i).charAt(j)==\\'X\\'){\\n                    continue;\\n                }\\n                int cur = Character.isDigit(board.get(i).charAt(j))?board.get(i).charAt(j)-\\'0\\':0;\\n                for (int[] d : dirs){\\n                    int x = d[0]+i;\\n                    int y = d[1]+j;\\n                    if (x < 0 || y < 0 || ways[x][y] == 0){\\n                        continue;\\n                    }\\n                    if (cur+dp[x][y]>dp[i][j]){\\n                        dp[i][j]=cur+dp[x][y];\\n                        ways[i][j]=0;\\n                    }\\n                    if (cur+dp[x][y]==dp[i][j]){\\n                        ways[i][j]+=ways[x][y];\\n                        ways[i][j]%=M;\\n                    }\\n                }\\n            }\\n        }\\n        return new int[]{dp[m-1][n-1], ways[m-1][n-1]};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```Java\\nclass Solution {\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int M = (int)1e9+7;\\n        int m = board.size();\\n        int n = board.get(0).length();\\n        int[][] dp = new int[m][n];\\n        int[][] ways = new int[m][n];\\n        ways[0][0]=1; // base case.\\n        int[][] dirs = {{-1, 0}, {0, -1}, {-1, -1}}; // all 3 ways where we can travel.\\n        for (int i=0;i<m;i++){\\n            for (int j=0;j<n;j++){\\n                if (board.get(i).charAt(j)==\\'X\\'){\\n                    continue;\\n                }\\n                int cur = Character.isDigit(board.get(i).charAt(j))?board.get(i).charAt(j)-\\'0\\':0;\\n                for (int[] d : dirs){\\n                    int x = d[0]+i;\\n                    int y = d[1]+j;\\n                    if (x < 0 || y < 0 || ways[x][y] == 0){\\n                        continue;\\n                    }\\n                    if (cur+dp[x][y]>dp[i][j]){\\n                        dp[i][j]=cur+dp[x][y];\\n                        ways[i][j]=0;\\n                    }\\n                    if (cur+dp[x][y]==dp[i][j]){\\n                        ways[i][j]+=ways[x][y];\\n                        ways[i][j]%=M;\\n                    }\\n                }\\n            }\\n        }\\n        return new int[]{dp[m-1][n-1], ways[m-1][n-1]};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2237733,
                "title": "need-help-in-c-memoization-dp-recursion",
                "content": "how can i convert my solution into a memo or dp solution.\\ncan we convert void recursive into dp solution?\\n\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int count=0;\\n    \\n    void traverse(vector<string> b,int i,int j,int sum,int m,int n){\\n        \\n        \\n        if(i>=m || j>=n || b[i][j]==\\'X\\'){\\n            return;\\n        }\\n        //checking for max path sum\\n        if(i==m-1 && j==n-1){\\n\\n            if(sum>ans){\\n\\n                count=0;\\n\\n                ans=sum;\\n\\n    \\n\\n            }\\n            if(sum==ans){\\n  count++;\\n            }\\nreturn ;\\n\\n        }\\n//adding path cost\\n        sum=sum+((b[i][j]!=\\'E\\')?b[i][j]-\\'0\\':0);\\n      \\n//bottom\\n        traverse(b,i+1,j,sum,m,n);\\n        //right\\n        traverse(b,i,j+1,sum,m,n);\\n        //digonal\\n        traverse(b,i+1,j+1,sum,m,n);\\n        \\n       \\n        \\n    }\\n    \\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int m=board.size();\\n        int n=board[0].size();\\n      \\n  \\n        traverse(board,0,0,0,m,n);\\n        \\n        vector<int> res;\\n        res.push_back(ans);\\n        res.push_back(count);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int count=0;\\n    \\n    void traverse(vector<string> b,int i,int j,int sum,int m,int n){\\n        \\n        \\n        if(i>=m || j>=n || b[i][j]==\\'X\\'){\\n            return;\\n        }\\n        //checking for max path sum\\n        if(i==m-1 && j==n-1){\\n\\n            if(sum>ans){\\n\\n                count=0;\\n\\n                ans=sum;\\n\\n    \\n\\n            }\\n            if(sum==ans){\\n  count++;\\n            }\\nreturn ;\\n\\n        }\\n//adding path cost\\n        sum=sum+((b[i][j]!=\\'E\\')?b[i][j]-\\'0\\':0);\\n      \\n//bottom\\n        traverse(b,i+1,j,sum,m,n);\\n        //right\\n        traverse(b,i,j+1,sum,m,n);\\n        //digonal\\n        traverse(b,i+1,j+1,sum,m,n);\\n        \\n       \\n        \\n    }\\n    \\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int m=board.size();\\n        int n=board[0].size();\\n      \\n  \\n        traverse(board,0,0,0,m,n);\\n        \\n        vector<int> res;\\n        res.push_back(ans);\\n        res.push_back(count);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222499,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int[][] dp = new int[board.size()][board.get(0).length()];\\n        int[][] solution = new int[dp.length][dp[0].length];\\n        // initialize\\n        solution[0][0] = 1;\\n        for (int i = 1; i < board.get(0).length(); i++) {\\n            char c = board.get(0).charAt(i);\\n            if (c == \\'X\\') {\\n               break;\\n            } \\n            dp[0][i] = dp[0][i - 1] + (c - \\'0\\');\\n            solution[0][i] = 1;\\n        }\\n        for (int i = 1; i < board.size(); i++) {\\n            char c = board.get(i).charAt(0);\\n            if (c == \\'X\\') {\\n                break;\\n            }\\n            dp[i][0] = dp[i - 1][0] + (c - \\'0\\');\\n            solution[i][0] = 1;\\n        }\\n        \\n        for (int i = 1; i < board.size(); i++) {\\n            for (int j = 1; j < board.get(0).length(); j++) {\\n                char c = board.get(i).charAt(j);\\n                if (c == \\'X\\') {\\n                  continue;\\n                }\\n                int t = Math.max(Math.max(dp[i - 1][j], dp[i - 1][j - 1]), dp[i][j - 1]);\\n                dp[i][j] = t > 0 ? t + (c == \\'S\\' ? 0 : (c - \\'0\\')) : 0;\\n                if (dp[i - 1][j] == t) {\\n                    solution[i][j] += solution[i - 1][j];\\n                }\\n                if (dp[i - 1][j - 1] == t) {\\n                    solution[i][j] += solution[i - 1][j - 1];\\n                }\\n                if (dp[i][j - 1] == t) {\\n                    solution[i][j] += solution[i][j - 1];\\n                }\\n                // I dont really know why\\n                solution[i][j] = solution[i][j] % 1000000007;\\n            }\\n        }\\n        int k = dp[dp.length - 1][dp[0].length - 1];\\n        int p = solution[dp.length - 1][dp[0].length - 1];\\n        return new int[]{k,p};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int[][] dp = new int[board.size()][board.get(0).length()];\\n        int[][] solution = new int[dp.length][dp[0].length];\\n        // initialize\\n        solution[0][0] = 1;\\n        for (int i = 1; i < board.get(0).length(); i++) {\\n            char c = board.get(0).charAt(i);\\n            if (c == \\'X\\') {\\n               break;\\n            } \\n            dp[0][i] = dp[0][i - 1] + (c - \\'0\\');\\n            solution[0][i] = 1;\\n        }\\n        for (int i = 1; i < board.size(); i++) {\\n            char c = board.get(i).charAt(0);\\n            if (c == \\'X\\') {\\n                break;\\n            }\\n            dp[i][0] = dp[i - 1][0] + (c - \\'0\\');\\n            solution[i][0] = 1;\\n        }\\n        \\n        for (int i = 1; i < board.size(); i++) {\\n            for (int j = 1; j < board.get(0).length(); j++) {\\n                char c = board.get(i).charAt(j);\\n                if (c == \\'X\\') {\\n                  continue;\\n                }\\n                int t = Math.max(Math.max(dp[i - 1][j], dp[i - 1][j - 1]), dp[i][j - 1]);\\n                dp[i][j] = t > 0 ? t + (c == \\'S\\' ? 0 : (c - \\'0\\')) : 0;\\n                if (dp[i - 1][j] == t) {\\n                    solution[i][j] += solution[i - 1][j];\\n                }\\n                if (dp[i - 1][j - 1] == t) {\\n                    solution[i][j] += solution[i - 1][j - 1];\\n                }\\n                if (dp[i][j - 1] == t) {\\n                    solution[i][j] += solution[i][j - 1];\\n                }\\n                // I dont really know why\\n                solution[i][j] = solution[i][j] % 1000000007;\\n            }\\n        }\\n        int k = dp[dp.length - 1][dp[0].length - 1];\\n        int p = solution[dp.length - 1][dp[0].length - 1];\\n        return new int[]{k,p};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106243,
                "title": "javascript-solution-dp",
                "content": "> I\\'m tired ~\\n\\n```\\nfunction pathsWithMaxScore(board) {\\n\\tconst m = board.length, n = board[0].length;\\n\\n\\tfor (let i = 0; i < m; i++) {\\n\\t\\tboard[i] = board[i].split(\\'\\')\\n\\t}\\n\\n\\tconst dp = Array.from(Array(m)).map(() => Array(n).fill([0,0]))\\n\\n\\tdp[m-1][n-1] = [0,1]\\n\\n    // D1\\n    loop(m, i => {\\n        check(board[i][n - 1], v => {\\n            process(\\n                board[i + 1][n - 1],\\n                t => {\\n                    board[i][n - 1] = \\'X\\'\\n                    dp[i][n - 1] = [0, 0]\\n                },\\n                t => {\\n                    dp[i][n - 1] = [(check(t) ? 0 : dp[i + 1][n - 1][0]) + parseInt(v), 1]\\n                })\\n        })\\n    })\\n\\n    // D2\\n    loop(n, i => {\\n        check(board[m-1][i], v => {\\n            process(\\n                board[m - 1][i + 1],\\n                t => {\\n                    board[m - 1][i] = \\'X\\'\\n                    dp[m - 1][i] = [0, 0]\\n                },\\n                t => {\\n                    dp[m - 1][i] = [(check(t) ? 0 : dp[m - 1][i + 1][0]) + parseInt(v), 1]\\n                }\\n            )\\n        })\\n    })\\n\\n    // DP\\n    loop(m, i => {\\n        loop(n, j => {\\n            process(\\n                board[i][j],\\n                t => {\\n                    dp[i][j] = [0, 0]\\n                },\\n                t => {\\n                    process(\\n                        [board[i + 1][j], board[i][j + 1], board[i + 1][j + 1]],\\n                        x => {\\n                            board[i][j] = \\'X\\'\\n                            dp[i][j] = [0, 0]\\n                        },\\n                        x => {\\n                            let [v, c] = getMax([dp[i + 1][j], dp[i][j + 1], dp[i + 1][j + 1]])\\n                            dp[i][j] = [(t >= 0 && t <= 9 ? parseInt(t) : 0) + v, c]\\n                        }\\n                    )\\n                }\\n            )\\n        })\\n    })\\n\\n    // result\\n\\treturn dp[0][0]\\n    \\n    // process x\\n    function process(v, resolve, reject) {\\n        if ([].concat(v).filter(v => v === `X`).length === v.length) {\\n            return resolve(v)\\n        }\\n        \\n        return reject(v)\\n    }\\n    \\n    // calculate after check numeric\\n    function check(n, callback) {\\n        if (n < 0 || n > 9) {\\n            return false\\n        }\\n\\n        return callback ? callback(n) : null\\n    }\\n    \\n    // loop reverse\\n    function loop(a, callback) {\\n        for (let i = a - 2; i >= 0; i--) {\\n            if ( callback(i) === false ) {\\n                continue\\n            }\\n        }\\n    }\\n\\n    // get max from array 2D\\n\\tfunction getMax(A) {\\n\\t\\tlet m = 0, t = 0\\n\\n\\t\\tfor (let [v, c] of A) {\\n\\t\\t\\tif (m === v) {\\n\\t\\t\\t\\tt = (t + c) % (1e9 + 7)\\n\\t\\t\\t}\\n\\t\\t\\tif (m < v) {\\n\\t\\t\\t\\tm = v\\n\\t\\t\\t\\tt = c\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn [m, t]\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction pathsWithMaxScore(board) {\\n\\tconst m = board.length, n = board[0].length;\\n\\n\\tfor (let i = 0; i < m; i++) {\\n\\t\\tboard[i] = board[i].split(\\'\\')\\n\\t}\\n\\n\\tconst dp = Array.from(Array(m)).map(() => Array(n).fill([0,0]))\\n\\n\\tdp[m-1][n-1] = [0,1]\\n\\n    // D1\\n    loop(m, i => {\\n        check(board[i][n - 1], v => {\\n            process(\\n                board[i + 1][n - 1],\\n                t => {\\n                    board[i][n - 1] = \\'X\\'\\n                    dp[i][n - 1] = [0, 0]\\n                },\\n                t => {\\n                    dp[i][n - 1] = [(check(t) ? 0 : dp[i + 1][n - 1][0]) + parseInt(v), 1]\\n                })\\n        })\\n    })\\n\\n    // D2\\n    loop(n, i => {\\n        check(board[m-1][i], v => {\\n            process(\\n                board[m - 1][i + 1],\\n                t => {\\n                    board[m - 1][i] = \\'X\\'\\n                    dp[m - 1][i] = [0, 0]\\n                },\\n                t => {\\n                    dp[m - 1][i] = [(check(t) ? 0 : dp[m - 1][i + 1][0]) + parseInt(v), 1]\\n                }\\n            )\\n        })\\n    })\\n\\n    // DP\\n    loop(m, i => {\\n        loop(n, j => {\\n            process(\\n                board[i][j],\\n                t => {\\n                    dp[i][j] = [0, 0]\\n                },\\n                t => {\\n                    process(\\n                        [board[i + 1][j], board[i][j + 1], board[i + 1][j + 1]],\\n                        x => {\\n                            board[i][j] = \\'X\\'\\n                            dp[i][j] = [0, 0]\\n                        },\\n                        x => {\\n                            let [v, c] = getMax([dp[i + 1][j], dp[i][j + 1], dp[i + 1][j + 1]])\\n                            dp[i][j] = [(t >= 0 && t <= 9 ? parseInt(t) : 0) + v, c]\\n                        }\\n                    )\\n                }\\n            )\\n        })\\n    })\\n\\n    // result\\n\\treturn dp[0][0]\\n    \\n    // process x\\n    function process(v, resolve, reject) {\\n        if ([].concat(v).filter(v => v === `X`).length === v.length) {\\n            return resolve(v)\\n        }\\n        \\n        return reject(v)\\n    }\\n    \\n    // calculate after check numeric\\n    function check(n, callback) {\\n        if (n < 0 || n > 9) {\\n            return false\\n        }\\n\\n        return callback ? callback(n) : null\\n    }\\n    \\n    // loop reverse\\n    function loop(a, callback) {\\n        for (let i = a - 2; i >= 0; i--) {\\n            if ( callback(i) === false ) {\\n                continue\\n            }\\n        }\\n    }\\n\\n    // get max from array 2D\\n\\tfunction getMax(A) {\\n\\t\\tlet m = 0, t = 0\\n\\n\\t\\tfor (let [v, c] of A) {\\n\\t\\t\\tif (m === v) {\\n\\t\\t\\t\\tt = (t + c) % (1e9 + 7)\\n\\t\\t\\t}\\n\\t\\t\\tif (m < v) {\\n\\t\\t\\t\\tm = v\\n\\t\\t\\t\\tt = c\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn [m, t]\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2082707,
                "title": "easy-to-understand-dp-of-o-mn",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m,inf=1e9,mod=1e9+7;\\n    \\n    inline bool is(int i,int j)\\n    {\\n        return (i>=0 && j>=0 && i<n && j<m);\\n    }\\n    \\n    vector<int> pathsWithMaxScore(vector<string>& a) \\n    {\\n        n=a.size(),m=a[0].length();\\n        a[0][0]=\\'0\\';\\n        int dp[n][m]; memset(dp,0,sizeof(dp));\\n        for(int i=n-1;i>=0;i--)\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                if(a[i][j]==\\'S\\') continue;\\n                if(a[i][j]==\\'X\\')\\n                {\\n                    dp[i][j]=-inf;\\n                    continue;\\n                }\\n                \\n                int mx=-inf;\\n                if(is(i+1,j) && dp[i+1][j]!=-inf) mx=max(mx,dp[i+1][j]);\\n                if(is(i,j+1) && dp[i][j+1]!=-inf) mx=max(mx,dp[i][j+1]);\\n                if(is(i+1,j+1) && dp[i+1][j+1]!=-inf) mx=max(mx,dp[i+1][j+1]);\\n                \\n                if(mx!=-inf) dp[i][j]=mx+(a[i][j]-\\'0\\');\\n                else dp[i][j]=-inf;\\n            }\\n        \\n        long cnt[n][m]; memset(cnt,0,sizeof(cnt));\\n        cnt[0][0]=1;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n            {\\n                if(dp[i][j]==-inf) continue;\\n                int need=dp[i][j]-(a[i][j]-\\'0\\');\\n                cnt[i][j]%=mod;\\n                if(is(i+1,j) && dp[i+1][j]==need) cnt[i+1][j]+=cnt[i][j],cnt[i+1][j]%=mod;;\\n                if(is(i,j+1) && dp[i][j+1]==need) cnt[i][j+1]+=cnt[i][j],cnt[i][j+1]%=mod;;\\n                if(is(i+1,j+1) && dp[i+1][j+1]==need) cnt[i+1][j+1]+=cnt[i][j],cnt[i+1][j+1]%=mod;\\n            }\\n        \\n        if(dp[0][0]<=-inf) dp[0][0]=0;\\n        vector<int> ans={dp[0][0],(int)cnt[n-1][m-1]};\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m,inf=1e9,mod=1e9+7;\\n    \\n    inline bool is(int i,int j)\\n    {\\n        return (i>=0 && j>=0 && i<n && j<m);\\n    }\\n    \\n    vector<int> pathsWithMaxScore(vector<string>& a) \\n    {\\n        n=a.size(),m=a[0].length();\\n        a[0][0]=\\'0\\';\\n        int dp[n][m]; memset(dp,0,sizeof(dp));\\n        for(int i=n-1;i>=0;i--)\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                if(a[i][j]==\\'S\\') continue;\\n                if(a[i][j]==\\'X\\')\\n                {\\n                    dp[i][j]=-inf;\\n                    continue;\\n                }\\n                \\n                int mx=-inf;\\n                if(is(i+1,j) && dp[i+1][j]!=-inf) mx=max(mx,dp[i+1][j]);\\n                if(is(i,j+1) && dp[i][j+1]!=-inf) mx=max(mx,dp[i][j+1]);\\n                if(is(i+1,j+1) && dp[i+1][j+1]!=-inf) mx=max(mx,dp[i+1][j+1]);\\n                \\n                if(mx!=-inf) dp[i][j]=mx+(a[i][j]-\\'0\\');\\n                else dp[i][j]=-inf;\\n            }\\n        \\n        long cnt[n][m]; memset(cnt,0,sizeof(cnt));\\n        cnt[0][0]=1;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n            {\\n                if(dp[i][j]==-inf) continue;\\n                int need=dp[i][j]-(a[i][j]-\\'0\\');\\n                cnt[i][j]%=mod;\\n                if(is(i+1,j) && dp[i+1][j]==need) cnt[i+1][j]+=cnt[i][j],cnt[i+1][j]%=mod;;\\n                if(is(i,j+1) && dp[i][j+1]==need) cnt[i][j+1]+=cnt[i][j],cnt[i][j+1]%=mod;;\\n                if(is(i+1,j+1) && dp[i+1][j+1]==need) cnt[i+1][j+1]+=cnt[i][j],cnt[i+1][j+1]%=mod;\\n            }\\n        \\n        if(dp[0][0]<=-inf) dp[0][0]=0;\\n        vector<int> ans={dp[0][0],(int)cnt[n-1][m-1]};\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081506,
                "title": "python-bottom-up-dp",
                "content": "`dp(i,j) = maxsum, numpaths`\\nAll cells are initialized with `0, 0`, except `dp(0,0) = 0, 1` since there is a 0-length path to itself with zero sum\\nWe start with the `E` cell and keep updating neighbors. There are two cases\\n- Case 1: current path to neighbor is the best path for it\\n- Case 2: current path leads to previously seen best sum, we sum up the paths\\n\\n```\\ndef pathsWithMaxScore(self, board):\\n        n = len(board)\\n        mod = 1000000007\\n        dp = [[[0, 0] for _ in range(n)] for _ in range(n)]\\n        dp[0][0] = [0, 1]\\n        for i in range(n):\\n            for j in range(n):\\n                if board[i][j] == \\'X\\': continue\\n                if not dp[i][j][1]: continue # this cell is not reachable from `E`\\n                for x, y in [(i, j + 1), (i + 1, j), (i + 1, j + 1)]:\\n                    if x < n and y < n and board[x][y] != \\'X\\':\\n                        val = int(board[x][y]) if board[x][y] != \\'S\\' else 0\\n                        tot = dp[i][j][0] + val\\n                        if tot == dp[x][y][0]: \\n                            dp[x][y][1] = (dp[x][y][1] + dp[i][j][1]) % mod\\n                        elif tot > dp[x][y][0]:\\n                            dp[x][y][0] = tot\\n                            dp[x][y][1] = dp[i][j][1]\\n        return dp[n - 1][n - 1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef pathsWithMaxScore(self, board):\\n        n = len(board)\\n        mod = 1000000007\\n        dp = [[[0, 0] for _ in range(n)] for _ in range(n)]\\n        dp[0][0] = [0, 1]\\n        for i in range(n):\\n            for j in range(n):\\n                if board[i][j] == \\'X\\': continue\\n                if not dp[i][j][1]: continue # this cell is not reachable from `E`\\n                for x, y in [(i, j + 1), (i + 1, j), (i + 1, j + 1)]:\\n                    if x < n and y < n and board[x][y] != \\'X\\':\\n                        val = int(board[x][y]) if board[x][y] != \\'S\\' else 0\\n                        tot = dp[i][j][0] + val\\n                        if tot == dp[x][y][0]: \\n                            dp[x][y][1] = (dp[x][y][1] + dp[i][j][1]) % mod\\n                        elif tot > dp[x][y][0]:\\n                            dp[x][y][0] = tot\\n                            dp[x][y][1] = dp[i][j][1]\\n        return dp[n - 1][n - 1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2068600,
                "title": "c-17-dp-o-mn",
                "content": "\\n\\n```\\n// 1301. Number of Paths with Max Score\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        constexpr int ModBase = 1\\'000\\'000\\'007;\\n        const int m = board.size(), n = board.size();\\n        // let fij represent the value of the max-score path from \\'E\\' to ij.\\n        vector<vector<int>> f(m, vector<int>(n));\\n        // let gij represent the count of the max-score paths from \\'E\\' to ij.\\n        vector<vector<int>> g(m, vector<int>(n));\\n        // initialize the first row\\n        g[0][0] = 1;\\n        for (int j = 1; j < n; ++j) {\\n            if (board[0][j] == \\'X\\') {\\n                f[0][j] = -1;\\n                g[0][j] = 0;\\n            } else {\\n                f[0][j] = g[0][j - 1] > 0 // has valid path?\\n                        ? f[0][j - 1] + toInteger(board[0][j])\\n                        : -1;\\n                g[0][j] = g[0][j - 1];\\n            }\\n        }\\n        // general case\\n        for (int i = 1; i < m; ++i) {\\n            // first cell in the current row i\\n            if (board[i][0] == \\'X\\') {\\n                f[i][0] = -1;\\n                g[i][0] = 0;\\n            } else {\\n                f[i][0] = g[i - 1][0] > 0 // has valid path?\\n                        ? f[i - 1][0] + toInteger(board[i][0])\\n                        : -1;\\n                g[i][0] = g[i - 1][0];\\n            }\\n            // other cells\\n            for (int j = 1; j < n; ++j) {\\n                if (board[i][j] == \\'X\\') {\\n                    f[i][j] = -1;\\n                    g[i][j] = 0;\\n                } else {\\n                    int maxOf3 =\\n                            max(f[i - 1][j - 1], // diagonal\\n                                max(f[i - 1][j], f[i][j - 1])); // left and top\\n                    f[i][j] = (maxOf3 == -1) ? -1 : toInteger(board[i][j]) + maxOf3;\\n                    if (maxOf3 == -1) {\\n                        g[i][j] = 0;\\n                    } else {\\n                        int64_t cnt = (f[i - 1][j] == maxOf3 ? g[i - 1][j] : 0)\\n                                + (f[i - 1][j - 1] == maxOf3 ? g[i - 1][j - 1] : 0)\\n                                + (f[i][j - 1] == maxOf3 ? g[i][j - 1] : 0);\\n                        g[i][j] = int(cnt % ModBase);\\n                    }\\n                }\\n            }\\n        }\\n        if (g[m - 1][n - 1] == 0) {\\n            return {0, 0};\\n        } else {\\n            return {f[m - 1][n - 1], g[m - 1][n - 1]};\\n        }\\n    }\\n\\n    static inline int toInteger(char c) {\\n        if (\\'0\\' <= c && c <= \\'9\\') {\\n            return c - \\'0\\';\\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n// 1301. Number of Paths with Max Score\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        constexpr int ModBase = 1\\'000\\'000\\'007;\\n        const int m = board.size(), n = board.size();\\n        // let fij represent the value of the max-score path from \\'E\\' to ij.\\n        vector<vector<int>> f(m, vector<int>(n));\\n        // let gij represent the count of the max-score paths from \\'E\\' to ij.\\n        vector<vector<int>> g(m, vector<int>(n));\\n        // initialize the first row\\n        g[0][0] = 1;\\n        for (int j = 1; j < n; ++j) {\\n            if (board[0][j] == \\'X\\') {\\n                f[0][j] = -1;\\n                g[0][j] = 0;\\n            } else {\\n                f[0][j] = g[0][j - 1] > 0 // has valid path?\\n                        ? f[0][j - 1] + toInteger(board[0][j])\\n                        : -1;\\n                g[0][j] = g[0][j - 1];\\n            }\\n        }\\n        // general case\\n        for (int i = 1; i < m; ++i) {\\n            // first cell in the current row i\\n            if (board[i][0] == \\'X\\') {\\n                f[i][0] = -1;\\n                g[i][0] = 0;\\n            } else {\\n                f[i][0] = g[i - 1][0] > 0 // has valid path?\\n                        ? f[i - 1][0] + toInteger(board[i][0])\\n                        : -1;\\n                g[i][0] = g[i - 1][0];\\n            }\\n            // other cells\\n            for (int j = 1; j < n; ++j) {\\n                if (board[i][j] == \\'X\\') {\\n                    f[i][j] = -1;\\n                    g[i][j] = 0;\\n                } else {\\n                    int maxOf3 =\\n                            max(f[i - 1][j - 1], // diagonal\\n                                max(f[i - 1][j], f[i][j - 1])); // left and top\\n                    f[i][j] = (maxOf3 == -1) ? -1 : toInteger(board[i][j]) + maxOf3;\\n                    if (maxOf3 == -1) {\\n                        g[i][j] = 0;\\n                    } else {\\n                        int64_t cnt = (f[i - 1][j] == maxOf3 ? g[i - 1][j] : 0)\\n                                + (f[i - 1][j - 1] == maxOf3 ? g[i - 1][j - 1] : 0)\\n                                + (f[i][j - 1] == maxOf3 ? g[i][j - 1] : 0);\\n                        g[i][j] = int(cnt % ModBase);\\n                    }\\n                }\\n            }\\n        }\\n        if (g[m - 1][n - 1] == 0) {\\n            return {0, 0};\\n        } else {\\n            return {f[m - 1][n - 1], g[m - 1][n - 1]};\\n        }\\n    }\\n\\n    static inline int toInteger(char c) {\\n        if (\\'0\\' <= c && c <= \\'9\\') {\\n            return c - \\'0\\';\\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029491,
                "title": "heavily-commented-c-memorization-tabulation",
                "content": "note: this isnt my code, i found it in discuss section. i only commented it. thats all. \\n```\\nclass Solution {\\npublic:\\n    int dir[3][2]={{0,-1},{-1,0},{-1,-1}};\\n    int mod=1000000007;\\n    int n;\\n    pair<int,int> dp[101][101];\\n    pair<int,int> max_sum(int i,int j,vector<string>& board)\\n    {\\n        if(i<0 || j<0 || board[i][j]==\\'X\\')  // out of bound or cant reach x marked cell, hence no way from here. hence return -inf\\n            return {INT_MIN,0}; // no path from such cells to end cell( board[0][0])\\n        if(i==0 && j==0)  // reached target cell. path from this cell to itself is 1. and max path value is 0\\n            return {0,1};\\n        if(dp[i][j].first!=-1) // caching\\n            return dp[i][j];\\n        int val=board[i][j]==\\'S\\'?0:board[i][j]-\\'0\\'; // the value of current cell\\n        \\n        int res=INT_MIN,count=0; // to choose best path of three choices from current cell\\n        \\n        for(int k=0;k<3;k++) // three directions to move from here. left, up, or upper left\\n        {\\n            pair<int,int> p=max_sum(i+dir[k][0],j+dir[k][1],board); \\n            if(p.first+val>res) // if this path is better than out prev path of 3 choices\\n            {\\n                res=p.first+val;\\n                count=p.second; // if this is the best till now then copy the count\\n            }\\n            else if(p.first+val==res)  // if this path\\'s value is same as max value of other choices, then we got more paths choices \\n                count=(count+p.second)%mod;\\n        }\\n        return dp[i][j]={res,count};\\n    }\\n    vector<int> pathsWithMaxScore(vector<string>& board) \\n    {\\n        n=board.size();\\n        for(int i=0;i<=100;i++)\\n            for(int j=0;j<=100;j++)\\n                dp[i][j]={-1,0}; // initially max value for every cell -1 and 0 path to reach the target cell\\n        pair<int,int> p=max_sum(n-1,n-1,board); // start cell\\n        int sum=p.first;\\n        int paths=p.second;\\n        if(sum<0) // if max value is less than 0 that means no path to reach the target cell hence 0 path \\n            return {0,0};\\n        return {sum,paths}; // else return what we got\\n    }\\n};\\n\\n\\n```\\n**tabulation**: *not my code copied from discuss section, just explaining, too tired at this point to write everything. Suggestion keep the following code in ur template code directory. for 90% grid dp ques its the same code with minor changes*.\\n\\nbest path from end to start or start to end is same doesnt matter,\\nin code moving from end to start. from top left to bottom right.\\ndp matrix : 0 to n cells, square grid.\\nall are 0 initially. except cnt[n-1][n-1] i.e start cell ( target cell), its value is 1. \\nthe three neighbouring cells are marked as n. t depicts extra cells added in dp matrix( terminating cells/ couldnt find better name). all values of t are zero.  cnt values also 0. depicting 0 path from these cell to target cells.\\nthe each 3 n cells have three choices( if its not marked as \\'x\\'), down , right or down right.\\nit chooses the max value of three choices. and  whichever path have max value it adds the count. at first all 3 choices have max value = 0 but only count from start is 1 , hence only that is added.\\n*the last line logic is used a lot to find paths from source to end in graphs by topological sort. many ques in CSES list *\\n\\ne . . .  t\\n. . n n t\\n. . n s  t\\nt t t t t\\n```\\n// find pahts from src to target, some are blocked, return max value paths and no of paths possible paths which have max value\\n\\nclass Solution  // moving from source to end or end to source doesnt matter. \\n{\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int mod = 1000000007, n = board.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1)); // stores max value path \\n        vector<vector<int>> cnt(n+1,vector<int>(n+1));  // store no of paths from this cell to tarhet cell\\n        board[n-1][n-1] = board[0][0] = \\'0\\'; // board[n-1][n-1] is start cell and board[0][0] is source. marked as S and E, initialise them with 0 value\\n        cnt[n-1][n-1] = 1; // one path to move from target to target. same as no of paths from src to target using topo sort. only start cell has 1 value,\\n        for(int i=n-1;i>=0;--i){\\n            for(int j=n-1;j>=0;--j)\\n            {\\n                if(board[i][j] != \\'X\\') // if this cell is restricted the max value and cnt of paths from this cell remains 0\\n                {\\n                    int m = max({dp[i+1][j],dp[i][j+1],dp[i+1][j+1]}); // find the max value from three options, down, right, and down right\\n                    dp[i][j] = (board[i][j]-\\'0\\')+m; // add the current cells value to max of three path choices\\n                    if(dp[i+1][j] == m) // check how many paths from the options contains max value. and increment the no of possible paths\\n                        cnt[i][j] = (cnt[i][j]+cnt[i+1][j]) % mod; \\n                    if(dp[i][j+1] == m)\\n                        cnt[i][j] = (cnt[i][j]+cnt[i][j+1]) % mod; // dont worry if any of choice cell is \\'X\\' its cnt is 0. hence it doesnt contribut to ans\\n                    if(dp[i+1][j+1] == m)\\n                        cnt[i][j] = (cnt[i][j]+cnt[i+1][j+1]) % mod;\\n                }\\n            }\\n        }\\n        return {cnt[0][0]?dp[0][0]:0,cnt[0][0]}; // if the cnt of src cell isnt 0 return, max  value and path , else return 0 as max value path \\n    }\\n};",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dir[3][2]={{0,-1},{-1,0},{-1,-1}};\\n    int mod=1000000007;\\n    int n;\\n    pair<int,int> dp[101][101];\\n    pair<int,int> max_sum(int i,int j,vector<string>& board)\\n    {\\n        if(i<0 || j<0 || board[i][j]==\\'X\\')  // out of bound or cant reach x marked cell, hence no way from here. hence return -inf\\n            return {INT_MIN,0}; // no path from such cells to end cell( board[0][0])\\n        if(i==0 && j==0)  // reached target cell. path from this cell to itself is 1. and max path value is 0\\n            return {0,1};\\n        if(dp[i][j].first!=-1) // caching\\n            return dp[i][j];\\n        int val=board[i][j]==\\'S\\'?0:board[i][j]-\\'0\\'; // the value of current cell\\n        \\n        int res=INT_MIN,count=0; // to choose best path of three choices from current cell\\n        \\n        for(int k=0;k<3;k++) // three directions to move from here. left, up, or upper left\\n        {\\n            pair<int,int> p=max_sum(i+dir[k][0],j+dir[k][1],board); \\n            if(p.first+val>res) // if this path is better than out prev path of 3 choices\\n            {\\n                res=p.first+val;\\n                count=p.second; // if this is the best till now then copy the count\\n            }\\n            else if(p.first+val==res)  // if this path\\'s value is same as max value of other choices, then we got more paths choices \\n                count=(count+p.second)%mod;\\n        }\\n        return dp[i][j]={res,count};\\n    }\\n    vector<int> pathsWithMaxScore(vector<string>& board) \\n    {\\n        n=board.size();\\n        for(int i=0;i<=100;i++)\\n            for(int j=0;j<=100;j++)\\n                dp[i][j]={-1,0}; // initially max value for every cell -1 and 0 path to reach the target cell\\n        pair<int,int> p=max_sum(n-1,n-1,board); // start cell\\n        int sum=p.first;\\n        int paths=p.second;\\n        if(sum<0) // if max value is less than 0 that means no path to reach the target cell hence 0 path \\n            return {0,0};\\n        return {sum,paths}; // else return what we got\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005494,
                "title": "dp-with-hashmap-o-n-2",
                "content": "```\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.hashmap = {}\\n    \\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        return self.path(board, 0, 0)\\n        \\n    def path(self, board, row, col) -> List[int]:\\n        if row * 1000 + col in self.hashmap:\\n            return self.hashmap[row * 1000 + col]\\n        result = path1 = path2 = path3 = [0, 0]\\n        n = len(board)\\n        \\n        if row == 0 and col == 1:\\n            print(1)\\n            print(board[row][col])\\n        if board[row][col] != \\'X\\':\\n            if board[row][col] == \\'S\\':\\n                result = [0, 1]\\n            else:\\n                if board[row][col] != \\'E\\':\\n                    result = [int(board[row][col]), 0]\\n                if row + 1 < n:\\n                    path1 = self.path(board, row + 1, col)\\n                if col + 1 < n:\\n                    path2 = self.path(board, row, col + 1)\\n                if row + 1 < n and col + 1 < n:\\n                    path3 = self.path(board, row + 1, col + 1)\\n                maxPath = max(path1[0], path2[0], path3[0])\\n                result[0] += maxPath\\n                if path1[0] == maxPath:\\n                    result[1] += path1[1]\\n                if path2[0] == maxPath:\\n                    result[1] += path2[1]\\n                if path3[0] == maxPath:\\n                    result[1] += path3[1]\\n                if result[1] == 0:\\n                    result[0] = 0\\n                result[1] = result[1] % 1000000007\\n        self.hashmap[row * 1000 + col] = result\\n        return result\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.hashmap = {}\\n    \\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        return self.path(board, 0, 0)\\n        \\n    def path(self, board, row, col) -> List[int]:\\n        if row * 1000 + col in self.hashmap:\\n            return self.hashmap[row * 1000 + col]\\n        result = path1 = path2 = path3 = [0, 0]\\n        n = len(board)\\n        \\n        if row == 0 and col == 1:\\n            print(1)\\n            print(board[row][col])\\n        if board[row][col] != \\'X\\':\\n            if board[row][col] == \\'S\\':\\n                result = [0, 1]\\n            else:\\n                if board[row][col] != \\'E\\':\\n                    result = [int(board[row][col]), 0]\\n                if row + 1 < n:\\n                    path1 = self.path(board, row + 1, col)\\n                if col + 1 < n:\\n                    path2 = self.path(board, row, col + 1)\\n                if row + 1 < n and col + 1 < n:\\n                    path3 = self.path(board, row + 1, col + 1)\\n                maxPath = max(path1[0], path2[0], path3[0])\\n                result[0] += maxPath\\n                if path1[0] == maxPath:\\n                    result[1] += path1[1]\\n                if path2[0] == maxPath:\\n                    result[1] += path2[1]\\n                if path3[0] == maxPath:\\n                    result[1] += path3[1]\\n                if result[1] == 0:\\n                    result[0] = 0\\n                result[1] = result[1] % 1000000007\\n        self.hashmap[row * 1000 + col] = result\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841197,
                "title": "golang-simple-dp-solution",
                "content": "```go\\nfunc pathsWithMaxScore(board []string) []int {\\n\\tdp := make([][][2]int, len(board))\\n\\tfor i := range dp {\\n\\t\\tdp[i] = make([][2]int, len(board))\\n\\t}\\n\\t// initial source\\n\\tdp[len(board)-1][len(board)-1] = [2]int{0, 1}\\n\\tcalculate := func(row, col, preRow, preCol, score int, dp [][][2]int) {\\n\\t\\tif dp[preRow][preCol][1] == 0 {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tif newScore := dp[preRow][preCol][0] + score; newScore > dp[row][col][0] {\\n\\t\\t\\tdp[row][col][0] = newScore\\n\\t\\t\\tdp[row][col][1] = dp[preRow][preCol][1]\\n\\t\\t} else if newScore == dp[row][col][0] {\\n\\t\\t\\tdp[row][col][1] += dp[preRow][preCol][1]\\n\\t\\t}\\n\\t}\\n\\tfor row := len(board) - 1; row >= 0; row-- {\\n\\t\\tfor col := len(board) - 1; col >= 0; col-- {\\n\\t\\t\\tif board[row][col] == \\'X\\' {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tscore := 0\\n\\t\\t\\tif board[row][col] >= \\'1\\' && board[row][col] <= \\'9\\' {\\n\\t\\t\\t\\tscore = int(board[row][col] - \\'0\\')\\n\\t\\t\\t}\\n\\t\\t\\t// right\\n\\t\\t\\tif prevRow, prevCol := row, col+1; prevRow < len(board) && prevCol < len(board) {\\n\\t\\t\\t\\tcalculate(row, col, prevRow, prevCol, score, dp)\\n\\t\\t\\t}\\n\\t\\t\\t// down\\n\\t\\t\\tif prevRow, prevCol := row+1, col; prevRow < len(board) && prevCol < len(board) {\\n\\t\\t\\t\\tcalculate(row, col, prevRow, prevCol, score, dp)\\n\\t\\t\\t}\\n\\t\\t\\t// down-right\\n\\t\\t\\tif prevRow, prevCol := row+1, col+1; prevRow < len(board) && prevCol < len(board) {\\n\\t\\t\\t\\tcalculate(row, col, prevRow, prevCol, score, dp)\\n\\t\\t\\t}\\n\\t\\t\\tdp[row][col][1] %= 1000000007\\n\\t\\t}\\n\\t}\\n\\treturn []int{dp[0][0][0], dp[0][0][1]}\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```go\\nfunc pathsWithMaxScore(board []string) []int {\\n\\tdp := make([][][2]int, len(board))\\n\\tfor i := range dp {\\n\\t\\tdp[i] = make([][2]int, len(board))\\n\\t}\\n\\t// initial source\\n\\tdp[len(board)-1][len(board)-1] = [2]int{0, 1}\\n\\tcalculate := func(row, col, preRow, preCol, score int, dp [][][2]int) {\\n\\t\\tif dp[preRow][preCol][1] == 0 {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\tif newScore := dp[preRow][preCol][0] + score; newScore > dp[row][col][0] {\\n\\t\\t\\tdp[row][col][0] = newScore\\n\\t\\t\\tdp[row][col][1] = dp[preRow][preCol][1]\\n\\t\\t} else if newScore == dp[row][col][0] {\\n\\t\\t\\tdp[row][col][1] += dp[preRow][preCol][1]\\n\\t\\t}\\n\\t}\\n\\tfor row := len(board) - 1; row >= 0; row-- {\\n\\t\\tfor col := len(board) - 1; col >= 0; col-- {\\n\\t\\t\\tif board[row][col] == \\'X\\' {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tscore := 0\\n\\t\\t\\tif board[row][col] >= \\'1\\' && board[row][col] <= \\'9\\' {\\n\\t\\t\\t\\tscore = int(board[row][col] - \\'0\\')\\n\\t\\t\\t}\\n\\t\\t\\t// right\\n\\t\\t\\tif prevRow, prevCol := row, col+1; prevRow < len(board) && prevCol < len(board) {\\n\\t\\t\\t\\tcalculate(row, col, prevRow, prevCol, score, dp)\\n\\t\\t\\t}\\n\\t\\t\\t// down\\n\\t\\t\\tif prevRow, prevCol := row+1, col; prevRow < len(board) && prevCol < len(board) {\\n\\t\\t\\t\\tcalculate(row, col, prevRow, prevCol, score, dp)\\n\\t\\t\\t}\\n\\t\\t\\t// down-right\\n\\t\\t\\tif prevRow, prevCol := row+1, col+1; prevRow < len(board) && prevCol < len(board) {\\n\\t\\t\\t\\tcalculate(row, col, prevRow, prevCol, score, dp)\\n\\t\\t\\t}\\n\\t\\t\\tdp[row][col][1] %= 1000000007\\n\\t\\t}\\n\\t}\\n\\treturn []int{dp[0][0][0], dp[0][0][1]}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1839817,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    long long arr[101][101][2];\\n    long long md=1e9+7;\\n  \\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        \\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board.size();j++){\\n                \\n                if(board[i][j]==\\'E\\' or board[i][j]==\\'S\\')\\n                    arr[i][j][0]=0;\\n                else if(board[i][j]==\\'X\\')\\n                    arr[i][j][0]=-1;\\n                else\\n                    arr[i][j][0]=board[i][j]-48;\\n            }\\n        }\\n        \\n        \\n        n=board.size();\\n        \\n        int r=n-1;\\n        arr[n-1][n-1][1]=1;\\n        while(r--){\\n            if(arr[r][n-1][0]==-1)\\n                break;\\n            arr[r][n-1][0]+=arr[r+1][n-1][0];\\n            arr[r][n-1][1]=1;\\n        }\\n        while(r>=0)\\n            arr[r--][n-1][0]=-1;\\n        \\n        r=n-1;\\n        \\n        while(r--){\\n            if(arr[n-1][r][0]==-1)\\n                break;\\n            arr[n-1][r][0]+=arr[n-1][r+1][0];\\n            arr[n-1][r][1]=1;\\n        }\\n        while(r>=0)\\n            arr[n-1][r--][0]=-1;\\n        \\n        \\n        for(int c=n-2;c>=0;c--){\\n            for(int r=n-2;r>=0;r--){\\n                if(arr[r][c][0]!=-1){\\n                    int mx=max({arr[r+1][c][0],arr[r][c+1][0],arr[r+1][c+1][0]});\\n                    \\n                    if(mx==-1)\\n                        arr[r][c][0]=-1;\\n                    else{\\n                        arr[r][c][0]+=mx;\\n                        int count=0;\\n                        if(arr[r+1][c][0]==mx) count+=arr[r+1][c][1];\\n                        if(arr[r][c+1][0]==mx) count+=arr[r][c+1][1];\\n                        if(arr[r+1][c+1][0]==mx) count+=arr[r+1][c+1][1];\\n                        \\n                        arr[r][c][1]=count%md;\\n                    } \\n                }\\n            }\\n        }\\n        \\n        if(arr[0][0][0]==-1) return {0,0};\\n        \\n        return {(int)arr[0][0][0],(int)arr[0][0][1]};\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    long long arr[101][101][2];\\n    long long md=1e9+7;\\n  \\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        \\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board.size();j++){\\n                \\n                if(board[i][j]==\\'E\\' or board[i][j]==\\'S\\')\\n                    arr[i][j][0]=0;\\n                else if(board[i][j]==\\'X\\')\\n                    arr[i][j][0]=-1;\\n                else\\n                    arr[i][j][0]=board[i][j]-48;\\n            }\\n        }\\n        \\n        \\n        n=board.size();\\n        \\n        int r=n-1;\\n        arr[n-1][n-1][1]=1;\\n        while(r--){\\n            if(arr[r][n-1][0]==-1)\\n                break;\\n            arr[r][n-1][0]+=arr[r+1][n-1][0];\\n            arr[r][n-1][1]=1;\\n        }\\n        while(r>=0)\\n            arr[r--][n-1][0]=-1;\\n        \\n        r=n-1;\\n        \\n        while(r--){\\n            if(arr[n-1][r][0]==-1)\\n                break;\\n            arr[n-1][r][0]+=arr[n-1][r+1][0];\\n            arr[n-1][r][1]=1;\\n        }\\n        while(r>=0)\\n            arr[n-1][r--][0]=-1;\\n        \\n        \\n        for(int c=n-2;c>=0;c--){\\n            for(int r=n-2;r>=0;r--){\\n                if(arr[r][c][0]!=-1){\\n                    int mx=max({arr[r+1][c][0],arr[r][c+1][0],arr[r+1][c+1][0]});\\n                    \\n                    if(mx==-1)\\n                        arr[r][c][0]=-1;\\n                    else{\\n                        arr[r][c][0]+=mx;\\n                        int count=0;\\n                        if(arr[r+1][c][0]==mx) count+=arr[r+1][c][1];\\n                        if(arr[r][c+1][0]==mx) count+=arr[r][c+1][1];\\n                        if(arr[r+1][c+1][0]==mx) count+=arr[r+1][c+1][1];\\n                        \\n                        arr[r][c][1]=count%md;\\n                    } \\n                }\\n            }\\n        }\\n        \\n        if(arr[0][0][0]==-1) return {0,0};\\n        \\n        return {(int)arr[0][0][0],(int)arr[0][0][1]};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1809163,
                "title": "97-fast-2-d-array-path-tracking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[101][101];\\n    int dp1[101][101];\\n    long long mod=1e9+7;\\n    int sum(vector<string>&b,int i,int j){\\n        \\n        int n=b.size(),m=b[0].size();\\n        \\n        if(i<0 || j<0 || b[i][j]==\\'X\\')return INT_MIN;        \\n        \\n        if(i==0 && j==0)return 0;\\n        \\n        if(dp[i][j]!=-1)return dp[i][j];\\n        \\n        int v=b[i][j]-\\'0\\';\\n        int f=sum(b,i-1,j-1);\\n        int s=sum(b,i-1,j);\\n        int t=sum(b,i,j-1);\\n        \\n        return dp[i][j]=v+max({f,s,t});\\n        \\n    }\\n    \\n    \\n    int solve(vector<string>&b,int i,int j){\\n        \\n        int n=b.size(),m=b[0].size();\\n        \\n        if(i<0 || j<0)return 0;        \\n        \\n        if(i==0 && j==0)return 1;\\n        \\n        if(dp1[i][j]!=-1)return dp1[i][j];\\n        \\n        int f=INT_MIN,s=INT_MIN,t=INT_MIN;\\n        \\n        if(i-1>=0)f=dp[i-1][j];\\n        \\n        if(j-1>=0)s=dp[i][j-1];\\n        \\n        if(i-1>=0 && j-1>=0)t=dp[i-1][j-1];\\n        \\n        int mx=max({f,s,t});\\n        \\n        int c=0;\\n        \\n        if(mx==f){\\n            c=(c+solve(b,i-1,j))%mod;\\n        }\\n        \\n        if(mx==s)c=(c+solve(b,i,j-1))%mod;\\n        \\n        if(t==mx)c=(c+solve(b,i-1,j-1))%mod;\\n        \\n        return dp1[i][j]=c;\\n        \\n    }\\n    \\n    vector<int> pathsWithMaxScore(vector<string>& b) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n        int n=b.size(),m=b[0].size();\\n        b[0][0]=\\'0\\';\\n        b[n-1][m-1]=\\'0\\';\\n        dp[0][0]=0;\\n        // dp[n-1][m-1]=0;\\n        int mx=sum(b,n-1,m-1);\\n        \\n        if(mx<0)return {0,0};\\n        memset(dp1,-1,sizeof(dp1));\\n        \\n        int c=solve(b,n-1,m-1);\\n        return {mx,c};\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[101][101];\\n    int dp1[101][101];\\n    long long mod=1e9+7;\\n    int sum(vector<string>&b,int i,int j){\\n        \\n        int n=b.size(),m=b[0].size();\\n        \\n        if(i<0 || j<0 || b[i][j]==\\'X\\')return INT_MIN;        \\n        \\n        if(i==0 && j==0)return 0;\\n        \\n        if(dp[i][j]!=-1)return dp[i][j];\\n        \\n        int v=b[i][j]-\\'0\\';\\n        int f=sum(b,i-1,j-1);\\n        int s=sum(b,i-1,j);\\n        int t=sum(b,i,j-1);\\n        \\n        return dp[i][j]=v+max({f,s,t});\\n        \\n    }\\n    \\n    \\n    int solve(vector<string>&b,int i,int j){\\n        \\n        int n=b.size(),m=b[0].size();\\n        \\n        if(i<0 || j<0)return 0;        \\n        \\n        if(i==0 && j==0)return 1;\\n        \\n        if(dp1[i][j]!=-1)return dp1[i][j];\\n        \\n        int f=INT_MIN,s=INT_MIN,t=INT_MIN;\\n        \\n        if(i-1>=0)f=dp[i-1][j];\\n        \\n        if(j-1>=0)s=dp[i][j-1];\\n        \\n        if(i-1>=0 && j-1>=0)t=dp[i-1][j-1];\\n        \\n        int mx=max({f,s,t});\\n        \\n        int c=0;\\n        \\n        if(mx==f){\\n            c=(c+solve(b,i-1,j))%mod;\\n        }\\n        \\n        if(mx==s)c=(c+solve(b,i,j-1))%mod;\\n        \\n        if(t==mx)c=(c+solve(b,i-1,j-1))%mod;\\n        \\n        return dp1[i][j]=c;\\n        \\n    }\\n    \\n    vector<int> pathsWithMaxScore(vector<string>& b) {\\n        \\n        memset(dp,-1,sizeof(dp));\\n        int n=b.size(),m=b[0].size();\\n        b[0][0]=\\'0\\';\\n        b[n-1][m-1]=\\'0\\';\\n        dp[0][0]=0;\\n        // dp[n-1][m-1]=0;\\n        int mx=sum(b,n-1,m-1);\\n        \\n        if(mx<0)return {0,0};\\n        memset(dp1,-1,sizeof(dp1));\\n        \\n        int c=solve(b,n-1,m-1);\\n        return {mx,c};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734797,
                "title": "easy-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n            int mod=1e9+7;\\n      int n=board.size();\\n      int m=board[0].length();\\n      vector<vector<pair<unsigned int,unsigned int>>>v(n,vector<pair<unsigned int , unsigned int>>(m,{0,0}));\\n         for(int i=n-1;i>=0;i--){\\n         for(int j=m-1;j>=0;j--){\\n           if(board[i][j]==\\'X\\'){\\n                   v[i][j]={0,0};\\n                   continue;\\n           }\\n          if(j==m-1 and i==n-1){\\n                  v[i][j]={0,1};\\n         }else if(j==m-1){\\n                 int pr=v[i+1][j].first;\\n                 int path=v[i+1][j].second;\\n                 v[i][j]={(pr+board[i][j]-\\'0\\')%mod,path};\\n         }else if(i==n-1){\\n                 int pr=v[i][j+1].first;\\n                 int path=v[i][j+1].second;\\n                 v[i][j]={(pr+board[i][j]-\\'0\\')%mod, path};\\n         }else{\\n                  if(board[i][j]==\\'E\\')board[i][j]=\\'0\\';\\n                 int pr1=(v[i][j+1].first+(board[i][j]-\\'0\\'))%mod;\\n                 int path1=v[i][j+1].second;\\n                 int pr2=(v[i+1][j].first+(board[i][j]-\\'0\\'))%mod;\\n                 int path2=v[i+1][j].second;\\n                 int pr3=(v[i+1][j+1].first+(board[i][j]-\\'0\\'))%mod;\\n                 int path3=v[i+1][j+1].second;\\n                 if(pr1==pr2  and pr1>=pr3){\\n                         if(pr1==pr3 )\\n                         {\\n                                  v[i][j]={pr1,(path1+path2+path3)%mod};\\n                         }\\n                         else\\n                        v[i][j]={pr1,(path1+path2)%mod};\\n                         \\n                         continue;\\n                 }\\n                 if(pr2==pr3  and pr2>=pr1){\\n                         v[i][j]={pr2,(path2+path3)%mod};\\n                            continue;\\n                 }\\n                 if(pr3==pr1 and pr3>=pr2){\\n                            v[i][j]={pr3,(path1+path3)%mod};\\n                            continue;\\n                 }\\n                 if(pr1>pr2 and pr1>pr3){\\n                          v[i][j]={pr1,path1};\\n                           continue;\\n                 }\\n                 if(pr2>pr1 and pr2>pr3){\\n                          v[i][j]={pr2,path2};\\n                           continue;\\n                 }\\n                 if(pr3>pr2 and pr3>pr1){\\n                          v[i][j]={pr3,path3};\\n                           continue;\\n                 }\\n                 \\n         }\\n         }\\n    }\\n    //         for(auto it:v){\\n    //                 for(auto i:it)cout<<i.first<<\"-\"<<i.second<<\"  \";\\n    //                 cout<<\"\\\\n\";\\n    //         }\\n             if(v[0][0].second>0)\\n            return {(int)v[0][0].first,(int) v[0][0].second};\\n            return {0,0};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n            int mod=1e9+7;\\n      int n=board.size();\\n      int m=board[0].length();\\n      vector<vector<pair<unsigned int,unsigned int>>>v(n,vector<pair<unsigned int , unsigned int>>(m,{0,0}));\\n         for(int i=n-1;i>=0;i--){\\n         for(int j=m-1;j>=0;j--){\\n           if(board[i][j]==\\'X\\'){\\n                   v[i][j]={0,0};\\n                   continue;\\n           }\\n          if(j==m-1 and i==n-1){\\n                  v[i][j]={0,1};\\n         }else if(j==m-1){\\n                 int pr=v[i+1][j].first;\\n                 int path=v[i+1][j].second;\\n                 v[i][j]={(pr+board[i][j]-\\'0\\')%mod,path};\\n         }else if(i==n-1){\\n                 int pr=v[i][j+1].first;\\n                 int path=v[i][j+1].second;\\n                 v[i][j]={(pr+board[i][j]-\\'0\\')%mod, path};\\n         }else{\\n                  if(board[i][j]==\\'E\\')board[i][j]=\\'0\\';\\n                 int pr1=(v[i][j+1].first+(board[i][j]-\\'0\\'))%mod;\\n                 int path1=v[i][j+1].second;\\n                 int pr2=(v[i+1][j].first+(board[i][j]-\\'0\\'))%mod;\\n                 int path2=v[i+1][j].second;\\n                 int pr3=(v[i+1][j+1].first+(board[i][j]-\\'0\\'))%mod;\\n                 int path3=v[i+1][j+1].second;\\n                 if(pr1==pr2  and pr1>=pr3){\\n                         if(pr1==pr3 )\\n                         {\\n                                  v[i][j]={pr1,(path1+path2+path3)%mod};\\n                         }\\n                         else\\n                        v[i][j]={pr1,(path1+path2)%mod};\\n                         \\n                         continue;\\n                 }\\n                 if(pr2==pr3  and pr2>=pr1){\\n                         v[i][j]={pr2,(path2+path3)%mod};\\n                            continue;\\n                 }\\n                 if(pr3==pr1 and pr3>=pr2){\\n                            v[i][j]={pr3,(path1+path3)%mod};\\n                            continue;\\n                 }\\n                 if(pr1>pr2 and pr1>pr3){\\n                          v[i][j]={pr1,path1};\\n                           continue;\\n                 }\\n                 if(pr2>pr1 and pr2>pr3){\\n                          v[i][j]={pr2,path2};\\n                           continue;\\n                 }\\n                 if(pr3>pr2 and pr3>pr1){\\n                          v[i][j]={pr3,path3};\\n                           continue;\\n                 }\\n                 \\n         }\\n         }\\n    }\\n    //         for(auto it:v){\\n    //                 for(auto i:it)cout<<i.first<<\"-\"<<i.second<<\"  \";\\n    //                 cout<<\"\\\\n\";\\n    //         }\\n             if(v[0][0].second>0)\\n            return {(int)v[0][0].first,(int) v[0][0].second};\\n            return {0,0};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1656167,
                "title": "python-o-mn-2d-dp-w-hint",
                "content": "**Hint**:\\n\\nWhen it comes to **path counting with finite grids**, think of **Dynamic Programming** with **recurrence relation on path**.\\n\\nThis is a variant of [Leetcode #63 Unique Path II](https://leetcode.com/problems/unique-paths-ii/), basic solving framework is quite similar.\\n\\n---\\n\\n**State transfer function** for DP:\\n\\n**DP[ i ][ j ] \\n= Current value + Optimize { possible previous moves }**....this is the key point of DP thinking process on path counting problems\\n= Current value + Optimize from (  **right**,  **bottom**,  **bottom-right**)\\n= Current value + Optimize from ( DP[ **i** ][ **j+1** ], DP[ **i+1** ][ **j** ], DP[ **i+1** ][ **j+1** ] )\\n\\nAlso, remeber to take care of **obstacle** as well as **dead-end path** (which is never reaching destination from start point) in the grids.\\n\\nFinally, we have to take modulo by 10^9 + 7 as answer, this is defined by description.\\n\\n---\\n\\n**Implementation** by top-down 2D DP with memoization\\n\\n```\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        \\n        ## Basic information: height and width of board\\n        h, w = len(board), len(board[0])    \\n        \\n        # ----------------------------------------------------------------------------\\n        \\n        # Use pathon native cahce as memoization for DP\\n        @cache\\n        def visit(i, j):\\n            \\n            if i == h-1 and j == w-1:\\n                ## Base case:\\n                \\n                # score for start coordinate = 0\\n                # paht count for start coordinate = 1\\n                return 0, 1\\n            \\n            elif i >= w or j >= h or board[i][j] == \\'X\\':\\n                \\n                ## Base case:\\n                # Out-of-boundary, or meet obstacle\\n                return 0, 0\\n            \\n            \\n            ## General case:\\n            # update from three possible preivous moves from right, down, and diagonal\\n            \\n            right_score, right_path_count = visit(i, j+1)\\n            down_score, down_path_count = visit(i+1, j)\\n            diag_score, diag_path_count = visit(i+1, j+1)\\n            \\n            max_prevScore = max(right_score, down_score, diag_score)\\n            \\n            cur_path_count = 0\\n            cur_score = int(board[i][j]) if board[i][j] != \"E\" else 0\\n            \\n            if right_score == max_prevScore : cur_path_count += right_path_count\\n            if down_score == max_prevScore : cur_path_count += down_path_count\\n            if diag_score == max_prevScore : cur_path_count += diag_path_count\\n            \\n            return max_prevScore + cur_score, cur_path_count\\n        # ----------------------------------------------------------------------------\\n        \\n        ## Remark: Remember to take modulo by constant, this is defined by description\\n        CONST = 10**9 + 7\\n        maxScore, validPathCount = visit(0, 0)\\n        \\n        return [maxScore % CONST, validPathCount % CONST] if validPathCount else [0, 0]\\n```\\n\\n---\\n\\n**Related leetcode challnge**:\\n\\na basic entry-level warm-up for DP on path counting\\n [Leetcode #62 Unique Path I](https://leetcode.com/problems/unique-paths/)\\n\\nadvanced variant, based on Unique Path I\\n [Leetcode #63 Unique Path II](https://leetcode.com/problems/unique-paths-ii/)\\n \\n---\\n\\nReference:\\n\\n[1] [Python offical docs about @cahce for function memoization](https://docs.python.org/3/library/functools.html#functools.cache)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        \\n        ## Basic information: height and width of board\\n        h, w = len(board), len(board[0])    \\n        \\n        # ----------------------------------------------------------------------------\\n        \\n        # Use pathon native cahce as memoization for DP\\n        @cache\\n        def visit(i, j):\\n            \\n            if i == h-1 and j == w-1:\\n                ## Base case:\\n                \\n                # score for start coordinate = 0\\n                # paht count for start coordinate = 1\\n                return 0, 1\\n            \\n            elif i >= w or j >= h or board[i][j] == \\'X\\':\\n                \\n                ## Base case:\\n                # Out-of-boundary, or meet obstacle\\n                return 0, 0\\n            \\n            \\n            ## General case:\\n            # update from three possible preivous moves from right, down, and diagonal\\n            \\n            right_score, right_path_count = visit(i, j+1)\\n            down_score, down_path_count = visit(i+1, j)\\n            diag_score, diag_path_count = visit(i+1, j+1)\\n            \\n            max_prevScore = max(right_score, down_score, diag_score)\\n            \\n            cur_path_count = 0\\n            cur_score = int(board[i][j]) if board[i][j] != \"E\" else 0\\n            \\n            if right_score == max_prevScore : cur_path_count += right_path_count\\n            if down_score == max_prevScore : cur_path_count += down_path_count\\n            if diag_score == max_prevScore : cur_path_count += diag_path_count\\n            \\n            return max_prevScore + cur_score, cur_path_count\\n        # ----------------------------------------------------------------------------\\n        \\n        ## Remark: Remember to take modulo by constant, this is defined by description\\n        CONST = 10**9 + 7\\n        maxScore, validPathCount = visit(0, 0)\\n        \\n        return [maxScore % CONST, validPathCount % CONST] if validPathCount else [0, 0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1655406,
                "title": "js-100-100",
                "content": "```\\n/**\\n * @param {string[]} board\\n * @return {number[]}\\n */\\nvar pathsWithMaxScore = function(board) {\\n    const height = board.length; // x\\n    const width = board[0].length; // y\\n    const modulo = 10 ** 9 + 7;\\n    \\n    const remainingValueMemoMap = new Map();\\n    const cumScoreMemoMap = new Map();\\n    \\n    function dfs(x, y, cumScore) {\\n        // look up subproblem solution if it exists\\n        const memoizedRemainingValueAndFrequency = remainingValueMemoMap.get(`${x}_${y}`);\\n        if (memoizedRemainingValueAndFrequency != null) {\\n            cumScore += memoizedRemainingValueAndFrequency[0];\\n            return [cumScore, memoizedRemainingValueAndFrequency[1]];\\n        }\\n        \\n        // if we\\'ve gotten here before with a better cumScore, we can stop traversing.\\n        const memoizedCumScore = cumScoreMemoMap.get(`${x}_${y}`);\\n        if (memoizedCumScore != null && memoizedCumScore > cumScore) {\\n            return [0, 0];\\n        }\\n        // set cumScore as new best\\n        cumScoreMemoMap.set(`${x}_${y}`, cumScore);\\n        \\n        const currentSpaceVal = board[x][y];\\n        \\n        if (currentSpaceVal === \\'E\\') {\\n            // we\\'ve reached the end, nothing to add\\n            return [cumScore, 1];\\n        } else if (currentSpaceVal !== \\'S\\') {\\n            cumScore += parseInt(currentSpaceVal)\\n        }\\n\\n        // instantiate array with valid options\\n        const options = [[x-1, y], [x, y-1], [x-1, y-1]].filter(option => option[0] >= 0 && option[1] >= 0 && board[option[0]][option[1]] !== \\'X\\');\\n        \\n        let result = [0, 0]; // track the maxScore and frequency\\n        \\n        // dfs the options\\n        for (const option of options) {\\n            let dfsResult = dfs(option[0], option[1], cumScore);\\n            \\n            if (dfsResult[0] > result[0]) {\\n                result = dfsResult; // replace max\\n            } else if (dfsResult[0] === result[0]) {\\n                result[1] += dfsResult[1]; // increment freq\\n            }\\n        }\\n        \\n        result[1] %= modulo; // take the modulo here\\n        \\n        // memoize upon return from recursion the \"max remaining value\" \\n        const maxRemainingValueAndFrequency = [result[0] - cumScore + parseInt(currentSpaceVal), result[1]];\\n        \\n        if (result[1] !== 0) { // dead end\\n            remainingValueMemoMap.set(`${x}_${y}`, maxRemainingValueAndFrequency);    \\n        }\\n        \\n        return result;\\n    }\\n\\n    return dfs(height - 1, width - 1, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} board\\n * @return {number[]}\\n */\\nvar pathsWithMaxScore = function(board) {\\n    const height = board.length; // x\\n    const width = board[0].length; // y\\n    const modulo = 10 ** 9 + 7;\\n    \\n    const remainingValueMemoMap = new Map();\\n    const cumScoreMemoMap = new Map();\\n    \\n    function dfs(x, y, cumScore) {\\n        // look up subproblem solution if it exists\\n        const memoizedRemainingValueAndFrequency = remainingValueMemoMap.get(`${x}_${y}`);\\n        if (memoizedRemainingValueAndFrequency != null) {\\n            cumScore += memoizedRemainingValueAndFrequency[0];\\n            return [cumScore, memoizedRemainingValueAndFrequency[1]];\\n        }\\n        \\n        // if we\\'ve gotten here before with a better cumScore, we can stop traversing.\\n        const memoizedCumScore = cumScoreMemoMap.get(`${x}_${y}`);\\n        if (memoizedCumScore != null && memoizedCumScore > cumScore) {\\n            return [0, 0];\\n        }\\n        // set cumScore as new best\\n        cumScoreMemoMap.set(`${x}_${y}`, cumScore);\\n        \\n        const currentSpaceVal = board[x][y];\\n        \\n        if (currentSpaceVal === \\'E\\') {\\n            // we\\'ve reached the end, nothing to add\\n            return [cumScore, 1];\\n        } else if (currentSpaceVal !== \\'S\\') {\\n            cumScore += parseInt(currentSpaceVal)\\n        }\\n\\n        // instantiate array with valid options\\n        const options = [[x-1, y], [x, y-1], [x-1, y-1]].filter(option => option[0] >= 0 && option[1] >= 0 && board[option[0]][option[1]] !== \\'X\\');\\n        \\n        let result = [0, 0]; // track the maxScore and frequency\\n        \\n        // dfs the options\\n        for (const option of options) {\\n            let dfsResult = dfs(option[0], option[1], cumScore);\\n            \\n            if (dfsResult[0] > result[0]) {\\n                result = dfsResult; // replace max\\n            } else if (dfsResult[0] === result[0]) {\\n                result[1] += dfsResult[1]; // increment freq\\n            }\\n        }\\n        \\n        result[1] %= modulo; // take the modulo here\\n        \\n        // memoize upon return from recursion the \"max remaining value\" \\n        const maxRemainingValueAndFrequency = [result[0] - cumScore + parseInt(currentSpaceVal), result[1]];\\n        \\n        if (result[1] !== 0) { // dead end\\n            remainingValueMemoMap.set(`${x}_${y}`, maxRemainingValueAndFrequency);    \\n        }\\n        \\n        return result;\\n    }\\n\\n    return dfs(height - 1, width - 1, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1591226,
                "title": "c-dp-solution",
                "content": "```\\n\\tpublic class Solution {\\n        const int Mod = 1000_000_007;\\n\\t\\tpublic int[] PathsWithMaxScore(IList<string> board) {\\n\\t\\t\\tint len = board.Count;\\n\\n            Item[][] dp = new Item[len + 1][];\\n\\n            for (int i = 0; i < dp.Length; i++)\\n            {\\n                dp[i] = new Item[len + 1];\\n            }\\n\\n            dp[len - 1][len - 1] = new Item\\n            {\\n                Pass = true,\\n                Paths = 1\\n            };\\n\\n            for (int i = len - 1; i >= 0; i--)\\n            {\\n                for (int j = len - 1; j >= 0; j--)\\n                {\\n                    var curr = board[i][j];\\n\\n                    ref var item = ref dp[i][j];\\n\\n                    if (curr == \\'X\\' || curr == \\'S\\')\\n                    {\\n                        continue;\\n                    }\\n\\n                    var score = curr == \\'E\\' ? 0 : curr - \\'0\\';\\n\\n                    var right = dp[i][j + 1];\\n                    var bottom = dp[i + 1][j];\\n                    var rb = dp[i + 1][j + 1];\\n\\n                    item.Pass = right.Pass || bottom.Pass || rb.Pass;\\n\\n                    if (item.Pass)\\n                    {\\n                        int maxScore = Math.Max(right.Score, Math.Max(bottom.Score, rb.Score));\\n\\n                        if (right.Pass && right.Score == maxScore)\\n                        {\\n                            item.Paths += right.Paths;\\n                            item.Paths %= Mod;\\n                        }\\n\\n                        if (bottom.Pass && bottom.Score == maxScore)\\n                        {\\n                            item.Paths += bottom.Paths;\\n                            item.Paths %= Mod;\\n                        }\\n\\n                        if (rb.Pass && rb.Score == maxScore)\\n                        {\\n                            item.Paths += rb.Paths;\\n                            item.Paths %= Mod;\\n                        }\\n\\n                        item.Score = maxScore + score;\\n                    }\\n\\n                }\\n            }\\n\\n            var first = dp[0][0];\\n\\n            return new[] { first.Score, first.Paths };\\n\\n        }\\n\\n        struct Item\\n        {\\n            public bool Pass { get; set; }\\n\\n            public int Score { get; set; }\\n\\n            public int Paths { get; set; }\\n\\n            public override string ToString()\\n            {\\n                return Pass ? $\"[{Score}, {Paths}]\" : \"X\";\\n            }\\n        }\\n\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic class Solution {\\n        const int Mod = 1000_000_007;\\n\\t\\tpublic int[] PathsWithMaxScore(IList<string> board) {\\n\\t\\t\\tint len = board.Count;\\n\\n            Item[][] dp = new Item[len + 1][];\\n\\n            for (int i = 0; i < dp.Length; i++)\\n            {\\n                dp[i] = new Item[len + 1];\\n            }\\n\\n            dp[len - 1][len - 1] = new Item\\n            {\\n                Pass = true,\\n                Paths = 1\\n            };\\n\\n            for (int i = len - 1; i >= 0; i--)\\n            {\\n                for (int j = len - 1; j >= 0; j--)\\n                {\\n                    var curr = board[i][j];\\n\\n                    ref var item = ref dp[i][j];\\n\\n                    if (curr == \\'X\\' || curr == \\'S\\')\\n                    {\\n                        continue;\\n                    }\\n\\n                    var score = curr == \\'E\\' ? 0 : curr - \\'0\\';\\n\\n                    var right = dp[i][j + 1];\\n                    var bottom = dp[i + 1][j];\\n                    var rb = dp[i + 1][j + 1];\\n\\n                    item.Pass = right.Pass || bottom.Pass || rb.Pass;\\n\\n                    if (item.Pass)\\n                    {\\n                        int maxScore = Math.Max(right.Score, Math.Max(bottom.Score, rb.Score));\\n\\n                        if (right.Pass && right.Score == maxScore)\\n                        {\\n                            item.Paths += right.Paths;\\n                            item.Paths %= Mod;\\n                        }\\n\\n                        if (bottom.Pass && bottom.Score == maxScore)\\n                        {\\n                            item.Paths += bottom.Paths;\\n                            item.Paths %= Mod;\\n                        }\\n\\n                        if (rb.Pass && rb.Score == maxScore)\\n                        {\\n                            item.Paths += rb.Paths;\\n                            item.Paths %= Mod;\\n                        }\\n\\n                        item.Score = maxScore + score;\\n                    }\\n\\n                }\\n            }\\n\\n            var first = dp[0][0];\\n\\n            return new[] { first.Score, first.Paths };\\n\\n        }\\n\\n        struct Item\\n        {\\n            public bool Pass { get; set; }\\n\\n            public int Score { get; set; }\\n\\n            public int Paths { get; set; }\\n\\n            public override string ToString()\\n            {\\n                return Pass ? $\"[{Score}, {Paths}]\" : \"X\";\\n            }\\n        }\\n\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1572820,
                "title": "swift-3d-array-dp",
                "content": "Inspried from @lee215 post.\\nhttps://leetcode.com/problems/number-of-paths-with-max-score/discuss/463252/Python-DP-Solution\\n\\nUnlike the python has no limit of integer, Swift Int is restricted in 64 bit (2^64) so instead take modulo of 1000000007 in the result, do it right after the occurence value changed.\\n\\n```\\nclass Solution {\\n    // Time: O(n^2)\\n    // Space: O(n^2)\\n    func pathsWithMaxScore(_ board: [String]) -> [Int] {\\n        let m = board.count\\n        let n = board[0].count\\n        let chars = board.map { Array($0) }\\n        let intMap: [Character:Int] = [\"0\":0,\"1\":1,\"2\":2,\"3\":3,\"4\":4,\"5\":5,\"6\":6,\"7\":7,\"8\":8,\"9\":9,\"S\":0,\"E\":0]\\n        var dp = Array(repeating: Array(repeating: [Int.min,0], count: n), count: m)\\n        var count: [Int: Int] = [:]\\n        dp[m-1][n-1] = [0,1]\\n        \\n        for i in (0..<m).reversed() {\\n            for j in (0..<n).reversed() {\\n                if chars[i][j] == \"X\" || chars[i][j] == \"S\"  { continue }\\n                \\n                for c in [[i+1,j],[i+1,j+1],[i,j+1]] {\\n                    if c[0] >= m || c[1] >= n || dp[c[0]][c[1]] == [Int.min,0] { continue }\\n                    let newSum = dp[c[0]][c[1]][0] + intMap[chars[i][j]]!\\n\\t\\t\\t\\t\\t// if found a new sum in current cell, let say have 3 cell around, so the first time, it will be reset to 0\\n                    if dp[i][j][0] < newSum {\\n                        dp[i][j][0] = newSum\\n                        dp[i][j][1] = 0\\n                    }  \\n\\t\\t\\t\\t\\t// then sum up 3 cell around\\'s occurence value\\n                    if dp[i][j][0] == newSum {\\n                        dp[i][j][1] += dp[c[0]][c[1]][1]\\n                        dp[i][j][1] = dp[i][j][1] % 1000000007\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if dp[0][0][0] == Int.min { return [0,0] }\\n        return [dp[0][0][0], dp[0][0][1]]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    // Time: O(n^2)\\n    // Space: O(n^2)\\n    func pathsWithMaxScore(_ board: [String]) -> [Int] {\\n        let m = board.count\\n        let n = board[0].count\\n        let chars = board.map { Array($0) }\\n        let intMap: [Character:Int] = [\"0\":0,\"1\":1,\"2\":2,\"3\":3,\"4\":4,\"5\":5,\"6\":6,\"7\":7,\"8\":8,\"9\":9,\"S\":0,\"E\":0]\\n        var dp = Array(repeating: Array(repeating: [Int.min,0], count: n), count: m)\\n        var count: [Int: Int] = [:]\\n        dp[m-1][n-1] = [0,1]\\n        \\n        for i in (0..<m).reversed() {\\n            for j in (0..<n).reversed() {\\n                if chars[i][j] == \"X\" || chars[i][j] == \"S\"  { continue }\\n                \\n                for c in [[i+1,j],[i+1,j+1],[i,j+1]] {\\n                    if c[0] >= m || c[1] >= n || dp[c[0]][c[1]] == [Int.min,0] { continue }\\n                    let newSum = dp[c[0]][c[1]][0] + intMap[chars[i][j]]!\\n\\t\\t\\t\\t\\t// if found a new sum in current cell, let say have 3 cell around, so the first time, it will be reset to 0\\n                    if dp[i][j][0] < newSum {\\n                        dp[i][j][0] = newSum\\n                        dp[i][j][1] = 0\\n                    }  \\n\\t\\t\\t\\t\\t// then sum up 3 cell around\\'s occurence value\\n                    if dp[i][j][0] == newSum {\\n                        dp[i][j][1] += dp[c[0]][c[1]][1]\\n                        dp[i][j][1] = dp[i][j][1] % 1000000007\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if dp[0][0][0] == Int.min { return [0,0] }\\n        return [dp[0][0][0], dp[0][0][1]]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1562670,
                "title": "golang-bottom-up-dp",
                "content": "```\\nfunc pathsWithMaxScore(bb []string) []int {\\n\\tmem := make([][][2]int, len(bb))\\n\\tfor i := range mem {\\n\\t\\tmem[i] = make([][2]int, len(bb[0]))\\n\\t}\\n\\tn := len(bb) - 1\\n\\tm := len(bb[0]) - 1\\n\\n\\tfor i := 0; i <= n; i++ {\\n\\t\\tfor j := 0; j <= m; j++ {\\n\\t\\t\\tif i == 0 && j == 0 {\\n\\t\\t\\t\\tmem[0][0][1] = 1\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif bb[i][j] == 88 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\tu := [2]int{-2, -2}\\n\\t\\t\\tif i > 0 && bb[i-1][j] != 88 {\\n\\t\\t\\t\\tu = mem[i-1][j]\\n\\t\\t\\t}\\n\\t\\t\\tl := [2]int{-2, -2}\\n\\t\\t\\tif j > 0 && bb[i][j-1] != 88 {\\n\\t\\t\\t\\tl = mem[i][j-1]\\n\\t\\t\\t}\\n\\t\\t\\tul := [2]int{-2, -2}\\n\\t\\t\\tif j > 0 && i > 0 && bb[i-1][j-1] != 88 {\\n\\t\\t\\t\\tul = mem[i-1][j-1]\\n\\t\\t\\t}\\n\\n\\t\\t\\tv, _ := strconv.Atoi(string(bb[i][j]))\\n\\t\\t\\tm := 0\\n\\t\\t\\tc := 0\\n\\t\\t\\tif u[0] > m {\\n\\t\\t\\t\\tm = u[0]\\n\\t\\t\\t}\\n\\t\\t\\tif l[0] > m {\\n\\t\\t\\t\\tm = l[0]\\n\\t\\t\\t}\\n\\t\\t\\tif ul[0] > m {\\n\\t\\t\\t\\tm = ul[0]\\n\\t\\t\\t}\\n\\n\\t\\t\\tif u[0] == m {\\n\\t\\t\\t\\tc += u[1]\\n\\n\\t\\t\\t}\\n\\t\\t\\tif l[0] == m {\\n\\t\\t\\t\\tc += l[1]\\n\\t\\t\\t}\\n\\t\\t\\tif ul[0] == m {\\n\\t\\t\\t\\tc += ul[1]\\n\\t\\t\\t}\\n\\n\\t\\t\\tmem[i][j][0] = v + m\\n\\t\\t\\tmem[i][j][1] = c % 1000000007\\n\\t\\t}\\n\\t}\\n\\tif mem[n][m][1] == 0 {\\n\\t\\treturn []int{0, 0}\\n\\t}\\n\\treturn []int{mem[n][m][0], mem[n][m][1]}\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfunc pathsWithMaxScore(bb []string) []int {\\n\\tmem := make([][][2]int, len(bb))\\n\\tfor i := range mem {\\n\\t\\tmem[i] = make([][2]int, len(bb[0]))\\n\\t}\\n\\tn := len(bb) - 1\\n\\tm := len(bb[0]) - 1\\n\\n\\tfor i := 0; i <= n; i++ {\\n\\t\\tfor j := 0; j <= m; j++ {\\n\\t\\t\\tif i == 0 && j == 0 {\\n\\t\\t\\t\\tmem[0][0][1] = 1\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif bb[i][j] == 88 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\tu := [2]int{-2, -2}\\n\\t\\t\\tif i > 0 && bb[i-1][j] != 88 {\\n\\t\\t\\t\\tu = mem[i-1][j]\\n\\t\\t\\t}\\n\\t\\t\\tl := [2]int{-2, -2}\\n\\t\\t\\tif j > 0 && bb[i][j-1] != 88 {\\n\\t\\t\\t\\tl = mem[i][j-1]\\n\\t\\t\\t}\\n\\t\\t\\tul := [2]int{-2, -2}\\n\\t\\t\\tif j > 0 && i > 0 && bb[i-1][j-1] != 88 {\\n\\t\\t\\t\\tul = mem[i-1][j-1]\\n\\t\\t\\t}\\n\\n\\t\\t\\tv, _ := strconv.Atoi(string(bb[i][j]))\\n\\t\\t\\tm := 0\\n\\t\\t\\tc := 0\\n\\t\\t\\tif u[0] > m {\\n\\t\\t\\t\\tm = u[0]\\n\\t\\t\\t}\\n\\t\\t\\tif l[0] > m {\\n\\t\\t\\t\\tm = l[0]\\n\\t\\t\\t}\\n\\t\\t\\tif ul[0] > m {\\n\\t\\t\\t\\tm = ul[0]\\n\\t\\t\\t}\\n\\n\\t\\t\\tif u[0] == m {\\n\\t\\t\\t\\tc += u[1]\\n\\n\\t\\t\\t}\\n\\t\\t\\tif l[0] == m {\\n\\t\\t\\t\\tc += l[1]\\n\\t\\t\\t}\\n\\t\\t\\tif ul[0] == m {\\n\\t\\t\\t\\tc += ul[1]\\n\\t\\t\\t}\\n\\n\\t\\t\\tmem[i][j][0] = v + m\\n\\t\\t\\tmem[i][j][1] = c % 1000000007\\n\\t\\t}\\n\\t}\\n\\tif mem[n][m][1] == 0 {\\n\\t\\treturn []int{0, 0}\\n\\t}\\n\\treturn []int{mem[n][m][0], mem[n][m][1]}\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1539067,
                "title": "first-try-shot-need-to-be-improved",
                "content": "\\tvector<int> pathsWithMaxScore(const vector<string>& g) {// tried top down with pos opt, not fast. 1st try for bottom up (not fast, but should be intuitive). T: O(m*n), S: O(n)\\n        int m = g.size(), n = g[0].size(), M = 1e9+7;\\n        vector<vector<vector<int> > > dp(2, vector<vector<int> > (n, vector<int>(2)));\\n        vector<int> dir = {0,-1,-1,0};\\n        for(int i=0; i<m; ++i)\\n            for(int j=0; j<n; ++j){\\n                dp[i%2][j] = {0,0};\\n                if(!i&&!j) {dp[0][0] = {0,1}; continue;}\\n                for(int k=0; k<3; ++k){ // can be replaced by: for(const auto& [x, y] : vector<pair<int,int>>{{i-1,j}, {i,j-1}, {i-1,j-1}}){\\n                    int x = i+dir[k], y = j+dir[k+1];\\n                    if(x<0 || y<0 || g[x][y] == \\'X\\') continue;\\n                    if(dp[i%2][j][0] < dp[x%2][y][0]) dp[i%2][j] = {dp[x%2][y][0], dp[x%2][y][1]};\\n                    else if(dp[i%2][j][0] == dp[x%2][y][0]) dp[i%2][j][1] = (dp[i%2][j][1]%M+dp[x%2][y][1])%M;\\n                }\\n                dp[i%2][j][0] += isdigit(g[i][j])*(g[i][j]-\\'0\\');\\n            }\\n        return !dp[(m-1)%2][n-1][1] ? vector<int>{0,0} : dp[(m-1)%2][n-1];\\n    }",
                "solutionTags": [],
                "code": "\\tvector<int> pathsWithMaxScore(const vector<string>& g) {// tried top down with pos opt, not fast. 1st try for bottom up (not fast, but should be intuitive). T: O(m*n), S: O(n)\\n        int m = g.size(), n = g[0].size(), M = 1e9+7;\\n        vector<vector<vector<int> > > dp(2, vector<vector<int> > (n, vector<int>(2)));\\n        vector<int> dir = {0,-1,-1,0};\\n        for(int i=0; i<m; ++i)\\n            for(int j=0; j<n; ++j){\\n                dp[i%2][j] = {0,0};\\n                if(!i&&!j) {dp[0][0] = {0,1}; continue;}\\n                for(int k=0; k<3; ++k){ // can be replaced by: for(const auto& [x, y] : vector<pair<int,int>>{{i-1,j}, {i,j-1}, {i-1,j-1}}){\\n                    int x = i+dir[k], y = j+dir[k+1];\\n                    if(x<0 || y<0 || g[x][y] == \\'X\\') continue;\\n                    if(dp[i%2][j][0] < dp[x%2][y][0]) dp[i%2][j] = {dp[x%2][y][0], dp[x%2][y][1]};\\n                    else if(dp[i%2][j][0] == dp[x%2][y][0]) dp[i%2][j][1] = (dp[i%2][j][1]%M+dp[x%2][y][1])%M;\\n                }\\n                dp[i%2][j][0] += isdigit(g[i][j])*(g[i][j]-\\'0\\');\\n            }\\n        return !dp[(m-1)%2][n-1][1] ? vector<int>{0,0} : dp[(m-1)%2][n-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1495439,
                "title": "c-dp-solution-tabulation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int arr[3][2]={{1,0},{1,1},{0,1}};\\n        board[0][0]=\\'0\\';\\n        // board[board.size()-1][board[board.size()-1].size()-1]=\\'0\\';\\n        \\n        vector<vector<pair<int,int>>>dp(board.size(),vector<pair<int,int>>(board[0].size()));\\n        int mod=1e9+7;\\n        for(int i=dp.size()-1;i>=0;i--){\\n            for(int j=dp[0].size()-1;j>=0;j--){\\n                if(i==dp.size()-1&&j==dp[0].size()-1)\\n                {\\n                    dp[dp.size()-1][dp[0].size()-1]=make_pair(0,1);\\n                }\\n                else if(board[i][j]==\\'X\\'){\\n                    continue;\\n                }\\n                else if(i==dp.size()-1){\\n                    if(board[i][j+1]==\\'X\\'){\\n                        continue;\\n                    }else{\\n                    dp[i][j]=make_pair((dp[i][j+1].first+board[i][j]-\\'0\\')%mod,1);\\n                    }\\n                }\\n                else if(j==dp[0].size()-1){\\n                                        if(board[i+1][j]==\\'X\\'){\\n                        continue;\\n                    }else{\\n                    dp[i][j]=make_pair((dp[i+1][j].first+board[i][j]-\\'0\\')%mod,1);}\\n                }else{\\n                    int m=0;\\n                    int cnt=0;\\n                    for(int l=0;l<3;l++){\\n                        int xdash=i+arr[l][0];\\n                        int ydash=j+arr[l][1];\\n                        if(board[xdash][ydash]!=\\'X\\'){\\n                            m=max(m,dp[xdash][ydash].first);\\n                        }\\n                    }\\n                    \\n                    for(int l=0;l<3;l++){\\n                        int xdash=i+arr[l][0];\\n                        int ydash=j+arr[l][1];\\n                        if(board[xdash][ydash]!=\\'X\\'){\\n                            if(dp[xdash][ydash].first==m){\\n                                \\n                                cnt=(cnt+dp[xdash][ydash].second)%mod;\\n                            }\\n                           \\n                        }\\n                    }\\n\\n                    dp[i][j]=make_pair((m+board[i][j]-\\'0\\')%mod,cnt);\\n                }\\n            }\\n        }\\n        vector<int> v1;\\n        if(dp[0][0].second==0){\\n            dp[0][0].first=0;\\n        }\\n        v1.push_back(dp[0][0].first);        v1.push_back(dp[0][0].second);\\n\\n        return v1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int arr[3][2]={{1,0},{1,1},{0,1}};\\n        board[0][0]=\\'0\\';\\n        // board[board.size()-1][board[board.size()-1].size()-1]=\\'0\\';\\n        \\n        vector<vector<pair<int,int>>>dp(board.size(),vector<pair<int,int>>(board[0].size()));\\n        int mod=1e9+7;\\n        for(int i=dp.size()-1;i>=0;i--){\\n            for(int j=dp[0].size()-1;j>=0;j--){\\n                if(i==dp.size()-1&&j==dp[0].size()-1)\\n                {\\n                    dp[dp.size()-1][dp[0].size()-1]=make_pair(0,1);\\n                }\\n                else if(board[i][j]==\\'X\\'){\\n                    continue;\\n                }\\n                else if(i==dp.size()-1){\\n                    if(board[i][j+1]==\\'X\\'){\\n                        continue;\\n                    }else{\\n                    dp[i][j]=make_pair((dp[i][j+1].first+board[i][j]-\\'0\\')%mod,1);\\n                    }\\n                }\\n                else if(j==dp[0].size()-1){\\n                                        if(board[i+1][j]==\\'X\\'){\\n                        continue;\\n                    }else{\\n                    dp[i][j]=make_pair((dp[i+1][j].first+board[i][j]-\\'0\\')%mod,1);}\\n                }else{\\n                    int m=0;\\n                    int cnt=0;\\n                    for(int l=0;l<3;l++){\\n                        int xdash=i+arr[l][0];\\n                        int ydash=j+arr[l][1];\\n                        if(board[xdash][ydash]!=\\'X\\'){\\n                            m=max(m,dp[xdash][ydash].first);\\n                        }\\n                    }\\n                    \\n                    for(int l=0;l<3;l++){\\n                        int xdash=i+arr[l][0];\\n                        int ydash=j+arr[l][1];\\n                        if(board[xdash][ydash]!=\\'X\\'){\\n                            if(dp[xdash][ydash].first==m){\\n                                \\n                                cnt=(cnt+dp[xdash][ydash].second)%mod;\\n                            }\\n                           \\n                        }\\n                    }\\n\\n                    dp[i][j]=make_pair((m+board[i][j]-\\'0\\')%mod,cnt);\\n                }\\n            }\\n        }\\n        vector<int> v1;\\n        if(dp[0][0].second==0){\\n            dp[0][0].first=0;\\n        }\\n        v1.push_back(dp[0][0].first);        v1.push_back(dp[0][0].second);\\n\\n        return v1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1479467,
                "title": "c-100-faster-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        const int N = 1000000007;\\n        int m=board.size();\\n        int n=board[0].size();\\n        vector<vector<pair<int,int>>>dp(m,vector<pair<int,int>>(n,{0,0}));\\n        dp[0][0]={0,1};\\n        for(int i=0;i<n;i++)\\n        {\\n            if(board[0][i]==\\'E\\')\\n            dp[0][i]={0,1};\\n            else if(board[0][i]==\\'X\\')\\n                dp[0][i]={-1,0};\\n            else\\n            {\\n                if(dp[0][i-1].first==-1)\\n                    dp[0][i]={-1,0};\\n                else\\n            dp[0][i] = {(board[0][i]-\\'0\\'+ dp[0][i-1].first),1};\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            if(board[i][0]==\\'E\\')\\n                continue;\\n            if(board[i][0]==\\'X\\')\\n                dp[i][0]={-1,0};\\n            else\\n            {\\n                if(dp[i-1][0].first==-1)\\n                    dp[i][0]={-1,0};\\n                else\\n                {\\n    dp[i][0]= {(dp[i-1][0].first + board[i][0]-\\'0\\'),1};\\n                }\\n            }            \\n        }\\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                if(board[i][j]==\\'X\\')\\n                    dp[i][j]={-1,0};\\n                else {\\n                        long long count=0;\\n    int maxi = max(dp[i][j-1].first,max(dp[i-1][j].first,dp[i-1][j-1].first));\\n                        if(dp[i][j-1].first==maxi)\\n                            count+=dp[i][j-1].second%N;\\n                        if(dp[i-1][j].first==maxi)\\n                            count+=dp[i-1][j].second%N;\\n                        if(dp[i-1][j-1].first==maxi)\\n                            count+=dp[i-1][j-1].second%N;\\n                        if(board[i][j]==\\'S\\')\\n                            dp[i][j] = {maxi,count%N};\\n                        else\\n                        dp[i][j]= {maxi+(board[i][j]-\\'0\\'),count%N};\\n                    }\\n            }\\n        }\\n        if(dp[m-1][n-1].first==-1)\\n            dp[m-1][n-1].first=0;\\n        return {dp[m-1][n-1].first,dp[m-1][n-1].second};\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        const int N = 1000000007;\\n        int m=board.size();\\n        int n=board[0].size();\\n        vector<vector<pair<int,int>>>dp(m,vector<pair<int,int>>(n,{0,0}));\\n        dp[0][0]={0,1};\\n        for(int i=0;i<n;i++)\\n        {\\n            if(board[0][i]==\\'E\\')\\n            dp[0][i]={0,1};\\n            else if(board[0][i]==\\'X\\')\\n                dp[0][i]={-1,0};\\n            else\\n            {\\n                if(dp[0][i-1].first==-1)\\n                    dp[0][i]={-1,0};\\n                else\\n            dp[0][i] = {(board[0][i]-\\'0\\'+ dp[0][i-1].first),1};\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            if(board[i][0]==\\'E\\')\\n                continue;\\n            if(board[i][0]==\\'X\\')\\n                dp[i][0]={-1,0};\\n            else\\n            {\\n                if(dp[i-1][0].first==-1)\\n                    dp[i][0]={-1,0};\\n                else\\n                {\\n    dp[i][0]= {(dp[i-1][0].first + board[i][0]-\\'0\\'),1};\\n                }\\n            }            \\n        }\\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=1;j<n;j++)\\n            {\\n                if(board[i][j]==\\'X\\')\\n                    dp[i][j]={-1,0};\\n                else {\\n                        long long count=0;\\n    int maxi = max(dp[i][j-1].first,max(dp[i-1][j].first,dp[i-1][j-1].first));\\n                        if(dp[i][j-1].first==maxi)\\n                            count+=dp[i][j-1].second%N;\\n                        if(dp[i-1][j].first==maxi)\\n                            count+=dp[i-1][j].second%N;\\n                        if(dp[i-1][j-1].first==maxi)\\n                            count+=dp[i-1][j-1].second%N;\\n                        if(board[i][j]==\\'S\\')\\n                            dp[i][j] = {maxi,count%N};\\n                        else\\n                        dp[i][j]= {maxi+(board[i][j]-\\'0\\'),count%N};\\n                    }\\n            }\\n        }\\n        if(dp[m-1][n-1].first==-1)\\n            dp[m-1][n-1].first=0;\\n        return {dp[m-1][n-1].first,dp[m-1][n-1].second};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461795,
                "title": "an-easy-understanding-code-with-dfs-and-memo-using-java",
                "content": "```\\nclass Solution {\\n    int[][] dirs = {{0, -1}, {-1, 0}, {-1, -1}};\\n    long mod = 1000000007;\\n    Map<String, int[]> memo;\\n    int m, n;\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        memo = new HashMap<>();\\n        m = board.size();\\n        n = board.get(0).length();\\n        char[][] b = new char[m][n];\\n        for(int i=0; i<m; i++)\\n            b[i] = board.get(i).toCharArray();\\n        \\n        int[] res = dfs(b, m-1, n-1);\\n        return res[0] < 0 ? new int[]{0, 0}: res;\\n    }\\n    public int[] dfs(char[][] board, int x, int y){\\n        if(x < 0 || y < 0 || board[x][y] == \\'X\\')\\n            return new int[]{Integer.MIN_VALUE, 0};\\n        if(x == 0 && y == 0){\\n            return new int[]{0, 1};\\n        }\\n        if(memo.containsKey(x+\"/\"+y))\\n            return memo.get(x+\"/\"+y);\\n        int curValue = board[x][y] == \\'S\\'? 0 : board[x][y]-\\'0\\';\\n        \\n        int res = Integer.MIN_VALUE, count = 0;\\n        for(int[] dir : dirs){\\n            int nx = x+dir[0], ny = y+dir[1];\\n            int[] tmp = dfs(board, nx, ny);\\n            if(res < curValue+tmp[0]){\\n                res = curValue+tmp[0];\\n                count = tmp[1];\\n            }else if(res == curValue+tmp[0])\\n                count += tmp[1];\\n        }\\n        memo.put(x+\"/\"+y, new int[]{(int)(res%mod), (int)(count%mod)});\\n        return memo.get(x+\"/\"+y);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] dirs = {{0, -1}, {-1, 0}, {-1, -1}};\\n    long mod = 1000000007;\\n    Map<String, int[]> memo;\\n    int m, n;\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        memo = new HashMap<>();\\n        m = board.size();\\n        n = board.get(0).length();\\n        char[][] b = new char[m][n];\\n        for(int i=0; i<m; i++)\\n            b[i] = board.get(i).toCharArray();\\n        \\n        int[] res = dfs(b, m-1, n-1);\\n        return res[0] < 0 ? new int[]{0, 0}: res;\\n    }\\n    public int[] dfs(char[][] board, int x, int y){\\n        if(x < 0 || y < 0 || board[x][y] == \\'X\\')\\n            return new int[]{Integer.MIN_VALUE, 0};\\n        if(x == 0 && y == 0){\\n            return new int[]{0, 1};\\n        }\\n        if(memo.containsKey(x+\"/\"+y))\\n            return memo.get(x+\"/\"+y);\\n        int curValue = board[x][y] == \\'S\\'? 0 : board[x][y]-\\'0\\';\\n        \\n        int res = Integer.MIN_VALUE, count = 0;\\n        for(int[] dir : dirs){\\n            int nx = x+dir[0], ny = y+dir[1];\\n            int[] tmp = dfs(board, nx, ny);\\n            if(res < curValue+tmp[0]){\\n                res = curValue+tmp[0];\\n                count = tmp[1];\\n            }else if(res == curValue+tmp[0])\\n                count += tmp[1];\\n        }\\n        memo.put(x+\"/\"+y, new int[]{(int)(res%mod), (int)(count%mod)});\\n        return memo.get(x+\"/\"+y);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430531,
                "title": "c-easy-dp",
                "content": "`dp[i][j]` stores {`max_score_possible_to_reach_this_cell`,`no_of_ways_to_reach_this_cell`}\\n```\\n#define pii pair<int, int>\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\nvector<int> pathsWithMaxScore(vector<string>& ar){\\n    ar[0][0]=\\'0\\';\\n    int n=ar.size();\\n    pii **dp=new pii*[101];\\n    for(int i=0;i<=100;i++) dp[i]=new pii[101];\\n    dp[n-1][n-1]={0,1};             //  {scr,no_of_ways}\\n    //  initial conditions\\n    bool gotX=false;\\n    for(int i=n-2;i>=0;i--){\\n        gotX=(gotX || (ar[i][n-1]==\\'X\\'));\\n        if(gotX) dp[i][n-1]={-1,0};\\n        else dp[i][n-1]={(ar[i][n-1]-\\'0\\')+dp[i+1][n-1].first,1};\\n    }\\n    gotX=false;\\n    for(int j=n-2;j>=0;j--){\\n        gotX=(gotX || (ar[n-1][j]==\\'X\\'));\\n        if(gotX) dp[n-1][j]={-1,0};\\n        else dp[n-1][j]={(ar[n-1][j]-\\'0\\')+dp[n-1][j+1].first,1};\\n    }\\n    for(int i=n-2;i>=0;i--){\\n        for(int j=n-2;j>=0;j--){\\n            if(ar[i][j]==\\'X\\'){\\n                dp[i][j]={-1,0};\\n                continue;\\n            }\\n            dp[i][j]=dp[i][j+1],dp[i][j].first+=(ar[i][j]-\\'0\\');\\n            // if(i==0 && j==0) cout<<dp[0][0].first<<\" \"<<dp[i][j].second<<endl;\\n            if(dp[i+1][j].first+(ar[i][j]-\\'0\\')>dp[i][j].first && dp[i+1][j].second){\\n                dp[i][j]=dp[i+1][j],dp[i][j].first+=(ar[i][j]-\\'0\\');\\n            }else if(dp[i+1][j].first+(ar[i][j]-\\'0\\')==dp[i][j].first && dp[i+1][j].second) {\\n                dp[i][j].second=(dp[i+1][j].second+dp[i][j].second)%mod;\\n            }\\n            if(dp[i+1][j+1].first+(ar[i][j]-\\'0\\')>dp[i][j].first && dp[i+1][j+1].second){\\n                dp[i][j]=dp[i+1][j+1],dp[i][j].first+=(ar[i][j]-\\'0\\');\\n            }else if(dp[i+1][j+1].first+(ar[i][j]-\\'0\\')==dp[i][j].first && dp[i+1][j+1].second){\\n                dp[i][j].second=(dp[i+1][j+1].second+dp[i][j].second)%mod;\\n            }\\n        }\\n    }\\n    if(dp[0][0].second==0) return {0,0};\\n    return {dp[0][0].first,dp[0][0].second};\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define pii pair<int, int>\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\nvector<int> pathsWithMaxScore(vector<string>& ar){\\n    ar[0][0]=\\'0\\';\\n    int n=ar.size();\\n    pii **dp=new pii*[101];\\n    for(int i=0;i<=100;i++) dp[i]=new pii[101];\\n    dp[n-1][n-1]={0,1};             //  {scr,no_of_ways}\\n    //  initial conditions\\n    bool gotX=false;\\n    for(int i=n-2;i>=0;i--){\\n        gotX=(gotX || (ar[i][n-1]==\\'X\\'));\\n        if(gotX) dp[i][n-1]={-1,0};\\n        else dp[i][n-1]={(ar[i][n-1]-\\'0\\')+dp[i+1][n-1].first,1};\\n    }\\n    gotX=false;\\n    for(int j=n-2;j>=0;j--){\\n        gotX=(gotX || (ar[n-1][j]==\\'X\\'));\\n        if(gotX) dp[n-1][j]={-1,0};\\n        else dp[n-1][j]={(ar[n-1][j]-\\'0\\')+dp[n-1][j+1].first,1};\\n    }\\n    for(int i=n-2;i>=0;i--){\\n        for(int j=n-2;j>=0;j--){\\n            if(ar[i][j]==\\'X\\'){\\n                dp[i][j]={-1,0};\\n                continue;\\n            }\\n            dp[i][j]=dp[i][j+1],dp[i][j].first+=(ar[i][j]-\\'0\\');\\n            // if(i==0 && j==0) cout<<dp[0][0].first<<\" \"<<dp[i][j].second<<endl;\\n            if(dp[i+1][j].first+(ar[i][j]-\\'0\\')>dp[i][j].first && dp[i+1][j].second){\\n                dp[i][j]=dp[i+1][j],dp[i][j].first+=(ar[i][j]-\\'0\\');\\n            }else if(dp[i+1][j].first+(ar[i][j]-\\'0\\')==dp[i][j].first && dp[i+1][j].second) {\\n                dp[i][j].second=(dp[i+1][j].second+dp[i][j].second)%mod;\\n            }\\n            if(dp[i+1][j+1].first+(ar[i][j]-\\'0\\')>dp[i][j].first && dp[i+1][j+1].second){\\n                dp[i][j]=dp[i+1][j+1],dp[i][j].first+=(ar[i][j]-\\'0\\');\\n            }else if(dp[i+1][j+1].first+(ar[i][j]-\\'0\\')==dp[i][j].first && dp[i+1][j+1].second){\\n                dp[i][j].second=(dp[i+1][j+1].second+dp[i][j].second)%mod;\\n            }\\n        }\\n    }\\n    if(dp[0][0].second==0) return {0,0};\\n    return {dp[0][0].first,dp[0][0].second};\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1394006,
                "title": "java-9ms-with-easy-to-understand-explanation",
                "content": "I guess some may wonder why we could use DP to solve this problem.\\nThe problem is essentially a single-source longest path problem. The edge can be defined as follows:\\nnode u has an edge to node v ONLY WHEN neither u nor v is \\'X\\' and u can reach v by going 1 step leftward, upward or diagonally.\\nA single-source longest path problem usually doesn\\'t have an easy solution. But because we can only go upward, leftward and diagonally, the graph becomes a DAG. And the longest/shortest path problem in a DAG can be solved efficiently using DP.\\n\\n```\\nclass Solution {\\n    private static final int[][] directions = new int[][]{{1, 0}, {0, 1}, {1, 1}};\\n    \\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int rows = board.size();\\n        int columns = board.get(0).length();\\n        int[][][] dp = new int[rows][columns][2];\\n        \\n        for (int r = rows - 1; r >= 0; r--) {\\n            for (int c = columns - 1; c >= 0; c--) {\\n                char current = board.get(r).charAt(c);\\n                \\n                if (current == \\'S\\') {\\n                    dp[r][c][0] = 0;\\n                    dp[r][c][1] = 1;\\n                } else if (current != \\'X\\') {\\n                    int maxScore = 0;\\n                    int paths = 0;\\n                    int currentScore = current == \\'E\\' ? 0 : current - \\'0\\';\\n                    \\n                    for (int[] dir : directions) {\\n                        int nextR = r + dir[0];\\n                        int nextC = c + dir[1];\\n                        \\n                        if (nextR < rows && nextC < columns && dp[nextR][nextC][1] > 0) {\\n                            if (dp[nextR][nextC][0] + currentScore > maxScore) {\\n                                maxScore = dp[nextR][nextC][0] + currentScore;\\n                                paths = dp[nextR][nextC][1];\\n                            } else if (dp[nextR][nextC][0] + currentScore == maxScore) {\\n                                paths = (paths + dp[nextR][nextC][1]) % 1000000007;\\n                            }\\n                        }\\n                    }\\n                    \\n                    dp[r][c][0] = maxScore;\\n                    dp[r][c][1] = paths;\\n                }\\n            }\\n        }\\n        \\n        return new int[]{dp[0][0][0], dp[0][0][1]};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int[][] directions = new int[][]{{1, 0}, {0, 1}, {1, 1}};\\n    \\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int rows = board.size();\\n        int columns = board.get(0).length();\\n        int[][][] dp = new int[rows][columns][2];\\n        \\n        for (int r = rows - 1; r >= 0; r--) {\\n            for (int c = columns - 1; c >= 0; c--) {\\n                char current = board.get(r).charAt(c);\\n                \\n                if (current == \\'S\\') {\\n                    dp[r][c][0] = 0;\\n                    dp[r][c][1] = 1;\\n                } else if (current != \\'X\\') {\\n                    int maxScore = 0;\\n                    int paths = 0;\\n                    int currentScore = current == \\'E\\' ? 0 : current - \\'0\\';\\n                    \\n                    for (int[] dir : directions) {\\n                        int nextR = r + dir[0];\\n                        int nextC = c + dir[1];\\n                        \\n                        if (nextR < rows && nextC < columns && dp[nextR][nextC][1] > 0) {\\n                            if (dp[nextR][nextC][0] + currentScore > maxScore) {\\n                                maxScore = dp[nextR][nextC][0] + currentScore;\\n                                paths = dp[nextR][nextC][1];\\n                            } else if (dp[nextR][nextC][0] + currentScore == maxScore) {\\n                                paths = (paths + dp[nextR][nextC][1]) % 1000000007;\\n                            }\\n                        }\\n                    }\\n                    \\n                    dp[r][c][0] = maxScore;\\n                    dp[r][c][1] = paths;\\n                }\\n            }\\n        }\\n        \\n        return new int[]{dp[0][0][0], dp[0][0][1]};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388961,
                "title": "c-dp-solution-with-pair-class",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\t// first in pair is total sum and second is number of ways\\n\\t\\tvector<int> pathsWithMaxScore(vector<string>& board) {\\n\\t\\t\\tint n=board.size();\\n\\t\\t\\tint m=board[0].size();\\n\\t\\t\\t// i have created extra size dp array so the first row and first column is empty \\n\\t\\t\\tvector<vector<pair<int,int>>> dp(n+1,vector<pair<int,int>>(m+1,{0,0}));\\n\\n\\t\\t\\tdp[n][m]={0,1}; // the second pair is 1 because it is the base condition as we are starting from last and this is the one path \\n\\n\\t\\t\\t// below code we just make our dp arry in int form\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tfor(int j=0;j<m;j++){\\n\\t\\t\\t\\t\\tif(board[i][j]==\\'E\\' || board[i][j]==\\'S\\')\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\telse if(board[i][j]==\\'X\\')\\n\\t\\t\\t\\t\\t\\tdp[i+1][j+1]={-1,-1};\\n\\t\\t\\t\\t\\telse dp[i+1][j+1]={ board[i][j]-\\'0\\',0 };\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// this is base condition \\n\\t\\t\\tfor(int i=n-1 ; i>0 ; i--){\\n\\t\\t\\t\\tif(dp[i][m].first == -1 || dp[i+1][m].first == -1) // we check because we can not go if the below one is x or the one in which we are standing is x \\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tdp[i][m] = { dp[i][m].first + dp[i+1][m].first , 1 };\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int j=m-1 ; j>0 ; j--){\\n\\t\\t\\t// we check because we can not go if the below one is x or the one in which we are standing is x \\n\\t\\t\\t\\tif(dp[n][j].first == -1||dp[n][j+1].first==-1)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tdp[n][j] = {dp[n][j].first+dp[n][j+1].first,1};\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\tfor(int i=n-1;i>0;i--){\\n\\t\\t\\t\\tfor(int j=m-1;j>0;j--){\\n\\n\\t\\t\\t\\t\\tif(dp[i][j].first == -1 && dp[i][j].second == -1)\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t// below three conditions are possible  1   1             1   x        1    4\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  //\\t    1   4             4   5        4    x\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tpair<int,int> p = {-1,0};\\n\\t\\t\\t\\t\\tif(dp[i+1][j].first == dp[i][j+1].first && dp[i][j+1].first > -1 ) {\\n\\t\\t\\t\\t\\t\\tp.first = dp[i+1][j].first;\\n\\t\\t\\t\\t\\t\\tp.second = dp[i+1][j].second + dp[i][j+1].second;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(p.first < dp[i+1][j].first){\\n\\t\\t\\t\\t\\t\\tp.first = dp[i+1][j].first;\\n\\t\\t\\t\\t\\t\\tp.second = dp[i+1][j].second;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(p.first < dp[i][j+1].first){\\n\\t\\t\\t\\t\\t\\tp.first = dp[i][j+1].first;\\n\\t\\t\\t\\t\\t\\tp.second=dp[i][j+1].second;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif(p.first < dp[i+1][j+1].first){\\n\\t\\t\\t\\t\\t\\tp.first = dp[i+1][j+1].first;\\n\\t\\t\\t\\t\\t\\tp.second=dp[i+1][j+1].second;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tdp[i][j].first= (dp[i][j].first+p.first)%1000000007;\\n\\t\\t\\t\\t\\tdp[i][j].second= (dp[i][j].second + p.second)%1000000007;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tvector<int> ans;\\n\\t\\t\\tans.push_back(dp[1][1].first);\\n\\t\\t\\tans.push_back(dp[1][1].second);\\n\\n\\t\\t\\tif(ans[1]==0)\\n\\t\\t\\t\\tans[0]=0;\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t// first in pair is total sum and second is number of ways\\n\\t\\tvector<int> pathsWithMaxScore(vector<string>& board) {\\n\\t\\t\\tint n=board.size();\\n\\t\\t\\tint m=board[0].size();\\n\\t\\t\\t// i have created extra size dp array so the first row and first column is empty \\n\\t\\t\\tvector<vector<pair<int,int>>> dp(n+1,vector<pair<int,int>>(m+1,{0,0}",
                "codeTag": "Java"
            },
            {
                "id": 1371791,
                "title": "easy-c-backtracking-dp-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    //to move left and top and top left cells\\n    vector<int> offsets={0,-1,-1,0};\\n    vector<int> pathsWithMaxScore(vector<string>& b) {\\n        \\n        //a backtracking solution with memoization\\n        \\n        //start from the bottom right and for every board[i][j] store the \\n        //max path to end and also the number of ways with maximum sum  path\\n        \\n        int n=b.size();\\n        \\n        vector<vector<pair<int,int>>> dp(n,vector<pair<int,int>>(n,{-1,-1}));\\n        \\n         solve(b,n-1,n-1,dp,n);\\n        \\n        return{dp[n-1][n-1].first,dp[n-1][n-1].second};\\n    }\\n    \\n    pair<int,int> solve(vector<string>& b,int i,int j,vector<vector<pair<int,int>>>& dp,int& n)\\n    {\\n        //we have reached the end\\n        if(b[i][j]==\\'E\\')\\n            return {0,1};\\n        \\n        //if the sub problem is already calculated\\n        if(dp[i][j].first!=-1)\\n            return dp[i][j];\\n        \\n        //try 3 possible directions\\n        \\n        \\n        long currSum=0;\\n        int num=0;\\n        for(int k=0;k<3;k++)\\n        {\\n            int x=i+offsets[k];\\n            int y=j+offsets[k+1];\\n            if(x<0 || y<0 || x>=n || y>=n || b[x][y]==\\'X\\')\\n                continue;\\n            auto [returnSum,returnPaths]=solve(b,x,y,dp,n);\\n            if(returnSum> currSum)\\n            {\\n                currSum=returnSum;\\n                num=returnPaths;\\n            }\\n            else if(returnSum==currSum){\\n                num+=returnPaths;\\n                num%=mod;\\n            }\\n        }\\n        //no path exists to reach the end from b[i][j]\\n        if(currSum==0 && num==0)\\n            return dp[i][j]={0,0};\\n        \\n        //there exists a path\\n        if(isdigit(b[i][j]))\\n            currSum+=(b[i][j]-\\'0\\');\\n        currSum%=mod;\\n        return dp[i][j]={  currSum ,num%(mod)};\\n        \\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    //to move left and top and top left cells\\n    vector<int> offsets={0,-1,-1,0};\\n    vector<int> pathsWithMaxScore(vector<string>& b) {\\n        \\n        //a backtracking solution with memoization\\n        \\n        //start from the bottom right and for every board[i][j] store the \\n        //max path to end and also the number of ways with maximum sum  path\\n        \\n        int n=b.size();\\n        \\n        vector<vector<pair<int,int>>> dp(n,vector<pair<int,int>>(n,{-1,-1}));\\n        \\n         solve(b,n-1,n-1,dp,n);\\n        \\n        return{dp[n-1][n-1].first,dp[n-1][n-1].second};\\n    }\\n    \\n    pair<int,int> solve(vector<string>& b,int i,int j,vector<vector<pair<int,int>>>& dp,int& n)\\n    {\\n        //we have reached the end\\n        if(b[i][j]==\\'E\\')\\n            return {0,1};\\n        \\n        //if the sub problem is already calculated\\n        if(dp[i][j].first!=-1)\\n            return dp[i][j];\\n        \\n        //try 3 possible directions\\n        \\n        \\n        long currSum=0;\\n        int num=0;\\n        for(int k=0;k<3;k++)\\n        {\\n            int x=i+offsets[k];\\n            int y=j+offsets[k+1];\\n            if(x<0 || y<0 || x>=n || y>=n || b[x][y]==\\'X\\')\\n                continue;\\n            auto [returnSum,returnPaths]=solve(b,x,y,dp,n);\\n            if(returnSum> currSum)\\n            {\\n                currSum=returnSum;\\n                num=returnPaths;\\n            }\\n            else if(returnSum==currSum){\\n                num+=returnPaths;\\n                num%=mod;\\n            }\\n        }\\n        //no path exists to reach the end from b[i][j]\\n        if(currSum==0 && num==0)\\n            return dp[i][j]={0,0};\\n        \\n        //there exists a path\\n        if(isdigit(b[i][j]))\\n            currSum+=(b[i][j]-\\'0\\');\\n        currSum%=mod;\\n        return dp[i][j]={  currSum ,num%(mod)};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371310,
                "title": "python-dp-93-runtime-and-97-memory",
                "content": "Using dp, for every place in the board, we have two dp arrays storing the max number so far (`dp` array in the code) and the number of paths that makes this max value (`numOfPaths` array in the code). \\n\\nInstead of using two 2D-matrix, I applied a simple compression strategy here, which is using a 1D matrix and keep updating it. So in this code, `newDp` stands for `max val for each cell at current row R` and `dp` stands for `max val for each cell at the row R + 1`.\\n\\nFor each cell, there are at most 3 possible incoming paths (bottom, right, bottom-right). When two or three paths end up with the same value at this cell, we need to add their numOfPaths together.\\n\\n```python\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n\\t\\t# Initialize variables and dp arrays\\n        rows = cols = len(board)\\n        MOD = 10 ** 9 + 7\\n        dp = [0] * cols # max val at board[R][C]\\n        numOfPaths = [0] * cols # num of paths that makes max for board[R][C]\\n        numOfPaths[-1] = 1\\n\\t\\t for c in range(cols - 2, -1, -1): # initialize dp and numOfPaths\\n            dp[c] = dp[c + 1] + mapVal(board[-1][c])\\n            if board[-1][c] != \\'X\\' and numOfPaths[c + 1] != 0:\\n                numOfPaths[c] = 1\\n\\t\\t\\n\\t\\t# function that translates str to int\\n        def mapVal(s): \\n            if s == \\'S\\' or s == \\'E\\': return 0\\n            elif s == \\'X\\': return float(\\'-inf\\') # \\'X\\' is obstacle, so we return negative inf\\n            else: return int(s)\\n\\t\\t\\t\\n        for r in range(rows - 2, -1, -1):\\n            newDp = [float(\\'-inf\\')] * cols\\n            newNumOfPaths = [0] * cols\\n            for c in range(cols - 1, -1, -1):\\n                option = float(\\'-inf\\')\\n                if board[r][c] == \\'X\\': continue\\n                chosenPaths = 0\\n                if c < cols - 1: # check the option of coming from right\\n                    if newDp[c+1] > option:\\n                        option = newDp[c+1]\\n                        chosenPaths = 0 # if strictly greater, reset the path count to 0. Otherwise, we keep the existing value and add to it\\n                    if newDp[c+1] >= option: \\n\\t\\t\\t\\t\\t\\t# here we check greaters and equals to\\n\\t\\t\\t\\t\\t\\t# as if multiple paths have the same outcome\\n\\t\\t\\t\\t\\t\\t# we need to sum their numOfPaths together \\n                        chosenPaths += newNumOfPaths[c+1] % MOD\\n                if r < rows - 1: # check coming from bottom\\n                    if dp[c] > option:\\n                        option = dp[c]\\n                        chosenPaths = 0\\n                    if dp[c] >= option:\\n                        chosenPaths += numOfPaths[c] % MOD\\n                if r < rows - 1 and c < cols - 1: # check diagnal\\n                    if dp[c+1] > option:\\n                        option = dp[c+1]\\n                        chosenPaths = 0\\n                    if dp[c+1] >= option:\\n                        chosenPaths += numOfPaths[c+1] % MOD\\n                newDp[c] = mapVal(board[r][c]) + option\\n                newNumOfPaths[c] = chosenPaths % MOD\\n            dp, numOfPaths = newDp, newNumOfPaths\\n        if dp[0] == float(\\'-inf\\'): return [0, 0]\\n        return (dp[0], numOfPaths[0])\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n\\t\\t# Initialize variables and dp arrays\\n        rows = cols = len(board)\\n        MOD = 10 ** 9 + 7\\n        dp = [0] * cols # max val at board[R][C]\\n        numOfPaths = [0] * cols # num of paths that makes max for board[R][C]\\n        numOfPaths[-1] = 1\\n\\t\\t for c in range(cols - 2, -1, -1): # initialize dp and numOfPaths\\n            dp[c] = dp[c + 1] + mapVal(board[-1][c])\\n            if board[-1][c] != \\'X\\' and numOfPaths[c + 1] != 0:\\n                numOfPaths[c] = 1\\n\\t\\t\\n\\t\\t# function that translates str to int\\n        def mapVal(s): \\n            if s == \\'S\\' or s == \\'E\\': return 0\\n            elif s == \\'X\\': return float(\\'-inf\\') # \\'X\\' is obstacle, so we return negative inf\\n            else: return int(s)\\n\\t\\t\\t\\n        for r in range(rows - 2, -1, -1):\\n            newDp = [float(\\'-inf\\')] * cols\\n            newNumOfPaths = [0] * cols\\n            for c in range(cols - 1, -1, -1):\\n                option = float(\\'-inf\\')\\n                if board[r][c] == \\'X\\': continue\\n                chosenPaths = 0\\n                if c < cols - 1: # check the option of coming from right\\n                    if newDp[c+1] > option:\\n                        option = newDp[c+1]\\n                        chosenPaths = 0 # if strictly greater, reset the path count to 0. Otherwise, we keep the existing value and add to it\\n                    if newDp[c+1] >= option: \\n\\t\\t\\t\\t\\t\\t# here we check greaters and equals to\\n\\t\\t\\t\\t\\t\\t# as if multiple paths have the same outcome\\n\\t\\t\\t\\t\\t\\t# we need to sum their numOfPaths together \\n                        chosenPaths += newNumOfPaths[c+1] % MOD\\n                if r < rows - 1: # check coming from bottom\\n                    if dp[c] > option:\\n                        option = dp[c]\\n                        chosenPaths = 0\\n                    if dp[c] >= option:\\n                        chosenPaths += numOfPaths[c] % MOD\\n                if r < rows - 1 and c < cols - 1: # check diagnal\\n                    if dp[c+1] > option:\\n                        option = dp[c+1]\\n                        chosenPaths = 0\\n                    if dp[c+1] >= option:\\n                        chosenPaths += numOfPaths[c+1] % MOD\\n                newDp[c] = mapVal(board[r][c]) + option\\n                newNumOfPaths[c] = chosenPaths % MOD\\n            dp, numOfPaths = newDp, newNumOfPaths\\n        if dp[0] == float(\\'-inf\\'): return [0, 0]\\n        return (dp[0], numOfPaths[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1358010,
                "title": "python3-dp",
                "content": "Let `max_val[i][j]` be the maximum sum of digits one can collect for path from bottom right corner to `board[i][j]`. Let `count[i][j]` be the number of path that sum to `max_val[i][j]`.\\n\\nBase case: `max_val[m - 1][n - 1] = 0, count[m - 1][n - 1] = 1`.\\n\\nInduction rule: \\n\\n- If `board[i][j] == \"X\", max_val[i][j] = -inf, count[i][j] = 0`.\\n- Otherwise, `max_val[i][j] = max(max_val[i\\'][j\\'], max_val[i\\'][j\\'], max_val[i\\'][j\\']) + int(board[i][j])`; `count[i][j] = sum(count[i\\'][j\\']) such that max_val[i\\'][j\\'] == max_val[i][j] - board[i][j]`. `(i\\', j\\') = (i + 1, j) or (i, j + 1) or (i + 1, j + 1)`.\\n\\nReturn `[max(max_val[0][0], 0), count[0][0]]`.\\n\\nTime complexity: $O(mn)$\\n\\nSpace complexity: $O(mn)$\\n\\n```\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        if not board or not board[0]:\\n            return [0, 0]\\n        M = 10 ** 9 + 7\\n        m, n = len(board), len(board[0])\\n        max_val = [[float(\"-inf\")] * n for _ in range(m)]\\n        count = [[0] * n for _ in range(m)]\\n        count[m - 1][n - 1] = 1\\n        max_val[m - 1][n - 1] = 0\\n        for i in range(m - 1, -1, -1):\\n            for j in range(n - 1, -1, -1):\\n                if board[i][j] == \"X\" or board[i][j] == \"S\":\\n                    continue\\n                else:\\n                    for i_prev, j_prev in [(i + 1, j), (i, j + 1), (i + 1, j + 1)]:\\n                        if 0 <= i_prev < m and 0 <= j_prev < n:\\n                            if max_val[i_prev][j_prev] > max_val[i][j]:\\n                                max_val[i][j], count[i][j] = max_val[i_prev][j_prev], count[i_prev][j_prev]\\n                            elif max_val[i_prev][j_prev] == max_val[i][j]:\\n                                count[i][j] += count[i_prev][j_prev]\\n                    if board[i][j] != \\'E\\':\\n                        max_val[i][j] += int(board[i][j])\\n                        max_val[i][j] %= M\\n                    count[i][j] %= M\\n        return [max(max_val[0][0], 0) % M, count[0][0] % M]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        if not board or not board[0]:\\n            return [0, 0]\\n        M = 10 ** 9 + 7\\n        m, n = len(board), len(board[0])\\n        max_val = [[float(\"-inf\")] * n for _ in range(m)]\\n        count = [[0] * n for _ in range(m)]\\n        count[m - 1][n - 1] = 1\\n        max_val[m - 1][n - 1] = 0\\n        for i in range(m - 1, -1, -1):\\n            for j in range(n - 1, -1, -1):\\n                if board[i][j] == \"X\" or board[i][j] == \"S\":\\n                    continue\\n                else:\\n                    for i_prev, j_prev in [(i + 1, j), (i, j + 1), (i + 1, j + 1)]:\\n                        if 0 <= i_prev < m and 0 <= j_prev < n:\\n                            if max_val[i_prev][j_prev] > max_val[i][j]:\\n                                max_val[i][j], count[i][j] = max_val[i_prev][j_prev], count[i_prev][j_prev]\\n                            elif max_val[i_prev][j_prev] == max_val[i][j]:\\n                                count[i][j] += count[i_prev][j_prev]\\n                    if board[i][j] != \\'E\\':\\n                        max_val[i][j] += int(board[i][j])\\n                        max_val[i][j] %= M\\n                    count[i][j] %= M\\n        return [max(max_val[0][0], 0) % M, count[0][0] % M]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325622,
                "title": "java-easy-to-understand-dp-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int m = board.size(), n = board.get(0).length(); // length and width of board\\n        \\n        int[][] dp = new int[m][n]; // initialize dp array to store maximum sum\\n        dp[m - 1][n- 1] = 0;\\n        \\n        long[][] count = new long[m][n]; // initialize path array to store maximum path count\\n        count[m - 1][n- 1] = 1L;\\n        \\n        for(int i = n - 2; i >= 0; i--) { // traverse and fill the bottom array from matrix\\n            char c = board.get(m - 1).charAt(i);\\n            if(c == \\'X\\') {\\n                for(int j = 0; j <= i; j++) { // fill the remaining with -1 when \\'X\\' encountered\\n                    dp[m - 1][j] = -1;\\n                }\\n                break;\\n            }\\n            dp[m - 1][i] = dp[m - 1][i + 1] + (c - \\'0\\'); // update the dp array as current value + previous value to left\\n            count[m - 1][i] += count[m - 1][i + 1]; // update the path count array as previous value to left + 1\\n        }\\n        for(int i = m - 2; i >= 0; i--) { // traverse and fill the rightmost array from matrix\\n            char c = board.get(i).charAt(n - 1);\\n            if(c == \\'X\\') {\\n                for(int j = 0; j <= i; j++) { // fill the remaining with -1 when \\'X\\' encountered\\n                    dp[j][n - 1] = -1;\\n                }\\n                break;\\n            }\\n            dp[i][n - 1] = dp[i + 1][n - 1] + (c - \\'0\\'); // update the dp array as current value + previous value at bottom\\n            count[i][n - 1] += count[i + 1][n - 1]; // update the path count array as previous value at bottom + 1\\n        }\\n        \\n        for(int i = m - 2; i >= 0; i--) { // traverse the remaning dp array\\n            for(int j = n - 2; j >= 0; j--) {\\n                char c = board.get(i).charAt(j);                \\n                if(c == \\'X\\') { // if \\'X\\' update the dp value to -1 to mark as unreachable\\n                    dp[i][j] = -1;\\n                    continue;\\n                }\\n                int max = Math.max(dp[i + 1][j + 1], Math.max(dp[i + 1][j], dp[i][j + 1])); //find the max value from the 3 paths avaiable i.e diagonal, right and below\\n                if(dp[i + 1][j + 1] == max) { //update the path count array if the max value came from diagonal\\n                    count[i][j] = (count[i][j] + count[i + 1][j + 1]) % 1000000007;\\n                }\\n                if(dp[i + 1][j] == max) { //update the path count array if the max value came from below\\n                    count[i][j] = (count[i][j] + count[i + 1][j]) % 1000000007;\\n                }\\n                if(dp[i][j + 1] == max) { //update the path count array if the max value came from right\\n                    count[i][j] = (count[i][j] + count[i][j + 1]) % 1000000007;\\n                }\\n                if(max == -1) { //if blocked then update to -1 or 0 if we reach (0,0)\\n                    dp[i][j] = (i == 0 && j == 0) ? 0 : -1;\\n                } else {\\n                    dp[i][j] = max + ((c == \\'E\\') ? 0 : c - \\'0\\'); // else update max + current value \\n                }\\n            }\\n        }\\n        return new int[]{dp[0][0], (int) count[0][0]}; // return (0,0) from dp and count path array\\n    }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int m = board.size(), n = board.get(0).length(); // length and width of board\\n        \\n        int[][] dp = new int[m][n]; // initialize dp array to store maximum sum\\n        dp[m - 1][n- 1] = 0;\\n        \\n        long[][] count = new long[m][n]; // initialize path array to store maximum path count\\n        count[m - 1][n- 1] = 1L;\\n        \\n        for(int i = n - 2; i >= 0; i--) { // traverse and fill the bottom array from matrix\\n            char c = board.get(m - 1).charAt(i);\\n            if(c == \\'X\\') {\\n                for(int j = 0; j <= i; j++) { // fill the remaining with -1 when \\'X\\' encountered\\n                    dp[m - 1][j] = -1;\\n                }\\n                break;\\n            }\\n            dp[m - 1][i] = dp[m - 1][i + 1] + (c - \\'0\\'); // update the dp array as current value + previous value to left\\n            count[m - 1][i] += count[m - 1][i + 1]; // update the path count array as previous value to left + 1\\n        }\\n        for(int i = m - 2; i >= 0; i--) { // traverse and fill the rightmost array from matrix\\n            char c = board.get(i).charAt(n - 1);\\n            if(c == \\'X\\') {\\n                for(int j = 0; j <= i; j++) { // fill the remaining with -1 when \\'X\\' encountered\\n                    dp[j][n - 1] = -1;\\n                }\\n                break;\\n            }\\n            dp[i][n - 1] = dp[i + 1][n - 1] + (c - \\'0\\'); // update the dp array as current value + previous value at bottom\\n            count[i][n - 1] += count[i + 1][n - 1]; // update the path count array as previous value at bottom + 1\\n        }\\n        \\n        for(int i = m - 2; i >= 0; i--) { // traverse the remaning dp array\\n            for(int j = n - 2; j >= 0; j--) {\\n                char c = board.get(i).charAt(j);                \\n                if(c == \\'X\\') { // if \\'X\\' update the dp value to -1 to mark as unreachable\\n                    dp[i][j] = -1;\\n                    continue;\\n                }\\n                int max = Math.max(dp[i + 1][j + 1], Math.max(dp[i + 1][j], dp[i][j + 1])); //find the max value from the 3 paths avaiable i.e diagonal, right and below\\n                if(dp[i + 1][j + 1] == max) { //update the path count array if the max value came from diagonal\\n                    count[i][j] = (count[i][j] + count[i + 1][j + 1]) % 1000000007;\\n                }\\n                if(dp[i + 1][j] == max) { //update the path count array if the max value came from below\\n                    count[i][j] = (count[i][j] + count[i + 1][j]) % 1000000007;\\n                }\\n                if(dp[i][j + 1] == max) { //update the path count array if the max value came from right\\n                    count[i][j] = (count[i][j] + count[i][j + 1]) % 1000000007;\\n                }\\n                if(max == -1) { //if blocked then update to -1 or 0 if we reach (0,0)\\n                    dp[i][j] = (i == 0 && j == 0) ? 0 : -1;\\n                } else {\\n                    dp[i][j] = max + ((c == \\'E\\') ? 0 : c - \\'0\\'); // else update max + current value \\n                }\\n            }\\n        }\\n        return new int[]{dp[0][0], (int) count[0][0]}; // return (0,0) from dp and count path array\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266853,
                "title": "faster-than-100-iterative-dp",
                "content": "Easy to implement not to many if else.\\n```\\nclass Solution {\\n    #define mod 1000000007\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& mat) {\\n        int n = mat.size();\\n        \\n        int m = mat[0].size();\\n        \\n        int dp[n+1][m+1], count[n+1][m+1];\\n        \\n        memset(dp, 0, sizeof(dp));\\n        \\n        memset(count, 0, sizeof(count));\\n        \\n        dp[0][0] = 0;\\n        \\n        count[0][0] = 1;\\n        \\n        //fill rows first upto obstacle not found \\n        for(int i=1;i<n;i++){\\n            \\n            if(mat[0][i]==\\'X\\'){\\n                \\n                break;\\n            }\\n            \\n            dp[0][i] = dp[0][i-1] + (mat[0][i] - \\'0\\');\\n            \\n            count[0][i] = 1;\\n        }\\n        //fill colums first upto obstacle not found \\n        for(int i=1;i<m;i++){\\n            \\n            if(mat[i][0]==\\'X\\'){\\n                \\n                break;\\n            }\\n            \\n            dp[i][0] = dp[i-1][0] + (mat[i][0] - \\'0\\');\\n            \\n            count[i][0] = 1;\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            for(int j=1;j<m;j++){\\n                \\n                if(mat[i][j]==\\'X\\') {\\n                    continue;\\n                }\\n                \\n                int value = mat[i][j]==\\'S\\' ? 0 : mat[i][j]-\\'0\\';\\n                \\n                int val = max(dp[i-1][j-1], max(dp[i-1][j], dp[i][j-1])) ;\\n                \\n                if(val == 0){\\n                    \\n                    continue;\\n                }\\n                \\n                dp[i][j] = val + value;\\n                \\n                if(val == dp[i-1][j-1]){\\n                    \\n                    count[i][j] = (count[i][j] + count[i-1][j-1])%mod;\\n                } \\n                \\n                if(val == dp[i-1][j]){\\n                    \\n                    count[i][j] = (count[i][j] + count[i-1][j])%mod;\\n                }\\n                \\n                if(val == dp[i][j-1]){\\n                    \\n                    count[i][j] = (count[i][j] + count[i][j-1])%mod;\\n                } \\n            }\\n        }\\n        \\n        if(n == 2 && m == 2 && dp[n-1][m-1] == 0 && count[n-1][m-1] == 0) {\\n            \\n            return {0,1};\\n        } \\n        \\n        return {dp[n-1][m-1],count[n-1][m-1]};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    #define mod 1000000007\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& mat) {\\n        int n = mat.size();\\n        \\n        int m = mat[0].size();\\n        \\n        int dp[n+1][m+1], count[n+1][m+1];\\n        \\n        memset(dp, 0, sizeof(dp));\\n        \\n        memset(count, 0, sizeof(count));\\n        \\n        dp[0][0] = 0;\\n        \\n        count[0][0] = 1;\\n        \\n        //fill rows first upto obstacle not found \\n        for(int i=1;i<n;i++){\\n            \\n            if(mat[0][i]==\\'X\\'){\\n                \\n                break;\\n            }\\n            \\n            dp[0][i] = dp[0][i-1] + (mat[0][i] - \\'0\\');\\n            \\n            count[0][i] = 1;\\n        }\\n        //fill colums first upto obstacle not found \\n        for(int i=1;i<m;i++){\\n            \\n            if(mat[i][0]==\\'X\\'){\\n                \\n                break;\\n            }\\n            \\n            dp[i][0] = dp[i-1][0] + (mat[i][0] - \\'0\\');\\n            \\n            count[i][0] = 1;\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            for(int j=1;j<m;j++){\\n                \\n                if(mat[i][j]==\\'X\\') {\\n                    continue;\\n                }\\n                \\n                int value = mat[i][j]==\\'S\\' ? 0 : mat[i][j]-\\'0\\';\\n                \\n                int val = max(dp[i-1][j-1], max(dp[i-1][j], dp[i][j-1])) ;\\n                \\n                if(val == 0){\\n                    \\n                    continue;\\n                }\\n                \\n                dp[i][j] = val + value;\\n                \\n                if(val == dp[i-1][j-1]){\\n                    \\n                    count[i][j] = (count[i][j] + count[i-1][j-1])%mod;\\n                } \\n                \\n                if(val == dp[i-1][j]){\\n                    \\n                    count[i][j] = (count[i][j] + count[i-1][j])%mod;\\n                }\\n                \\n                if(val == dp[i][j-1]){\\n                    \\n                    count[i][j] = (count[i][j] + count[i][j-1])%mod;\\n                } \\n            }\\n        }\\n        \\n        if(n == 2 && m == 2 && dp[n-1][m-1] == 0 && count[n-1][m-1] == 0) {\\n            \\n            return {0,1};\\n        } \\n        \\n        return {dp[n-1][m-1],count[n-1][m-1]};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1172521,
                "title": "c-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int n = board.size();\\n        vector<vector<pair<int,int>>> dp(n,vector<pair<int,int>>(n,{0,0}));\\n        dp[n-1][n-1] = {0,1};\\n        if(board[n-2][n-1]!=\\'X\\')\\n            dp[n-2][n-1] = {board[n-2][n-1]-\\'0\\',1};\\n        if(board[n-1][n-2]!=\\'X\\')\\n            dp[n-1][n-2] = {board[n-1][n-2]-\\'0\\',1};\\n        for(int i=n-3;i>=0;i--)\\n        {\\n            if(board[i][n-1]==\\'X\\')\\n                continue;\\n            if(dp[i+1][n-1].first!=0)\\n                dp[i][n-1] = {(dp[i+1][n-1].first+board[i][n-1]-\\'0\\')%1000000007,1};\\n        }\\n        for(int i=n-3;i>=0;i--)\\n        {\\n            if(board[n-1][i]==\\'X\\')\\n                continue;\\n            if(dp[n-1][i+1].first!=0)\\n                dp[n-1][i] = {(dp[n-1][i+1].first+board[n-1][i]-\\'0\\')%1000000007,1};\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=n-2;j>=0;j--)\\n            {\\n                if(board[i][j]!=\\'X\\')\\n                {\\n                    if(dp[i+1][j].first!=0)\\n                    {\\n                        dp[i][j] = dp[i+1][j];\\n                    }\\n                    if(dp[i][j+1].first!=0)\\n                    {\\n                        if(dp[i][j].first==dp[i][j+1].first)\\n                        {\\n                            dp[i][j] = {dp[i][j].first,(dp[i][j].second+dp[i][j+1].second)%1000000007};\\n                        }\\n                        else\\n                        {\\n                            if(dp[i][j].first<dp[i][j+1].first)\\n                            {\\n                                dp[i][j] = dp[i][j+1];\\n                            }\\n                        }\\n                    }\\n                    if(board[i+1][j+1]==\\'S\\' || dp[i+1][j+1].first!=0)\\n                    {\\n                        if(dp[i][j].first==dp[i+1][j+1].first)\\n                        {\\n                            dp[i][j] = {dp[i][j].first,(dp[i][j].second+dp[i+1][j+1].second)%1000000007};\\n                        }\\n                        else\\n                        {\\n                            if(dp[i][j].first<dp[i+1][j+1].first)\\n                            {\\n                                dp[i][j] = dp[i+1][j+1];\\n                            }\\n                        }\\n                    }\\n                    if(board[i][j]!=\\'E\\' && (board[i+1][j+1]==\\'S\\' || dp[i][j].first!=0))\\n                        dp[i][j].first= (dp[i][j].first+(board[i][j]-\\'0\\'))%1000000007;\\n                }\\n            }\\n        }\\n        return {dp[0][0].first%1000000007,dp[0][0].second%1000000007};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int n = board.size();\\n        vector<vector<pair<int,int>>> dp(n,vector<pair<int,int>>(n,{0,0}));\\n        dp[n-1][n-1] = {0,1};\\n        if(board[n-2][n-1]!=\\'X\\')\\n            dp[n-2][n-1] = {board[n-2][n-1]-\\'0\\',1};\\n        if(board[n-1][n-2]!=\\'X\\')\\n            dp[n-1][n-2] = {board[n-1][n-2]-\\'0\\',1};\\n        for(int i=n-3;i>=0;i--)\\n        {\\n            if(board[i][n-1]==\\'X\\')\\n                continue;\\n            if(dp[i+1][n-1].first!=0)\\n                dp[i][n-1] = {(dp[i+1][n-1].first+board[i][n-1]-\\'0\\')%1000000007,1};\\n        }\\n        for(int i=n-3;i>=0;i--)\\n        {\\n            if(board[n-1][i]==\\'X\\')\\n                continue;\\n            if(dp[n-1][i+1].first!=0)\\n                dp[n-1][i] = {(dp[n-1][i+1].first+board[n-1][i]-\\'0\\')%1000000007,1};\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=n-2;j>=0;j--)\\n            {\\n                if(board[i][j]!=\\'X\\')\\n                {\\n                    if(dp[i+1][j].first!=0)\\n                    {\\n                        dp[i][j] = dp[i+1][j];\\n                    }\\n                    if(dp[i][j+1].first!=0)\\n                    {\\n                        if(dp[i][j].first==dp[i][j+1].first)\\n                        {\\n                            dp[i][j] = {dp[i][j].first,(dp[i][j].second+dp[i][j+1].second)%1000000007};\\n                        }\\n                        else\\n                        {\\n                            if(dp[i][j].first<dp[i][j+1].first)\\n                            {\\n                                dp[i][j] = dp[i][j+1];\\n                            }\\n                        }\\n                    }\\n                    if(board[i+1][j+1]==\\'S\\' || dp[i+1][j+1].first!=0)\\n                    {\\n                        if(dp[i][j].first==dp[i+1][j+1].first)\\n                        {\\n                            dp[i][j] = {dp[i][j].first,(dp[i][j].second+dp[i+1][j+1].second)%1000000007};\\n                        }\\n                        else\\n                        {\\n                            if(dp[i][j].first<dp[i+1][j+1].first)\\n                            {\\n                                dp[i][j] = dp[i+1][j+1];\\n                            }\\n                        }\\n                    }\\n                    if(board[i][j]!=\\'E\\' && (board[i+1][j+1]==\\'S\\' || dp[i][j].first!=0))\\n                        dp[i][j].first= (dp[i][j].first+(board[i][j]-\\'0\\'))%1000000007;\\n                }\\n            }\\n        }\\n        return {dp[0][0].first%1000000007,dp[0][0].second%1000000007};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169828,
                "title": "c-2d-dp-solution-beats-100-in-time-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int n = board.size();\\n        int m = board[0].size();\\n        \\n        pair<int, int> dp[n][m];\\n        dp[0][0] = {0, 1};\\n        \\n        //filling up the first row and column as they are the base cases\\n        int MOD = (int)(1e9 + 7);\\n        for (int i = 1; i < m; i++) {\\n            //If current pos is \\'X\\' then give it a very low value so that it never gets picked\\n            if (board[0][i] == \\'X\\') {\\n                dp[0][i] = {-MOD, 0};  \\n                continue;\\n            }\\n            \\n            dp[0][i].first = (dp[0][i - 1].first + (int)(board[0][i] - \\'0\\'));\\n            dp[0][i].second = 1;\\n            \\n        }\\n        \\n        for (int i = 1; i < n; i++) {\\n            if (board[i][0] == \\'X\\') {\\n                dp[i][0] = {-MOD, 0};  \\n                continue;\\n            }\\n            \\n            dp[i][0].first = (dp[i - 1][0].first + (int)(board[i][0] - \\'0\\'));\\n            dp[i][0].second = 1;\\n        }\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int j = 1; j < m; j++) {\\n                \\n                if (board[i][j] == \\'X\\') {\\n                    dp[i][j] = {-MOD, 0};\\n                    continue;\\n                }\\n                \\n                //Traverse over the 3 neighbours and find out the max value possible while updating the ways too\\n                \\n                int maxVal = -1; //set maxVal as -1 not 0 as 0 is also a feasable option(eg: for (0,0) neighbours)\\n                if (dp[i - 1][j - 1].first > maxVal) {\\n                    maxVal = dp[i - 1][j - 1].first;\\n                    dp[i][j].second = dp[i - 1][j - 1].second;\\n                } else if (dp[i - 1][j - 1].first == maxVal) {\\n                    // if this value is same as max till now we can use it\\'s path as well\\n                    dp[i][j].second = (dp[i][j].second + dp[i - 1][j - 1].second) % MOD;\\n                }\\n                \\n                if (dp[i - 1][j].first > maxVal) {\\n                    maxVal = dp[i - 1][j].first;\\n                    dp[i][j].second = dp[i - 1][j].second;\\n                } else if (dp[i - 1][j].first == maxVal) {\\n                    dp[i][j].second = (dp[i][j].second + dp[i - 1][j].second) % MOD;\\n                }\\n                \\n                if (dp[i][j - 1].first > maxVal) {\\n                    maxVal = dp[i][j - 1].first;\\n                    dp[i][j].second = dp[i][j - 1].second;\\n                } else if (dp[i][j - 1].first == maxVal) {\\n                    dp[i][j].second = (dp[i][j].second + dp[i][j - 1].second) % MOD;\\n                }\\n                \\n                //maxVal < 0 indicates that no neighbour is connected to (0,0) so mark this node with least value\\n                if (maxVal < 0) {\\n                     dp[i][j] = {-MOD, 0};\\n                } else {\\n                    dp[i][j].first =  maxVal + (int)(board[i][j] - \\'0\\');\\n                }\\n                \\n            }\\n        }\\n        \\n        vector<int> ans;\\n        if (dp[n - 1][m - 1].first == -MOD) return {0, 0};\\n        \\n        //subtracting (int)(board[n - 1][m - 1] - \\'0\\' as source node has added (\\'S\\' - \\'0\\') which should have been 0\\n        return {dp[n - 1][m - 1].first - (int)(board[n - 1][m - 1] - \\'0\\'), dp[n - 1][m - 1].second};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int n = board.size();\\n        int m = board[0].size();\\n        \\n        pair<int, int> dp[n][m];\\n        dp[0][0] = {0, 1};\\n        \\n        //filling up the first row and column as they are the base cases\\n        int MOD = (int)(1e9 + 7);\\n        for (int i = 1; i < m; i++) {\\n            //If current pos is \\'X\\' then give it a very low value so that it never gets picked\\n            if (board[0][i] == \\'X\\') {\\n                dp[0][i] = {-MOD, 0};  \\n                continue;\\n            }\\n            \\n            dp[0][i].first = (dp[0][i - 1].first + (int)(board[0][i] - \\'0\\'));\\n            dp[0][i].second = 1;\\n            \\n        }\\n        \\n        for (int i = 1; i < n; i++) {\\n            if (board[i][0] == \\'X\\') {\\n                dp[i][0] = {-MOD, 0};  \\n                continue;\\n            }\\n            \\n            dp[i][0].first = (dp[i - 1][0].first + (int)(board[i][0] - \\'0\\'));\\n            dp[i][0].second = 1;\\n        }\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int j = 1; j < m; j++) {\\n                \\n                if (board[i][j] == \\'X\\') {\\n                    dp[i][j] = {-MOD, 0};\\n                    continue;\\n                }\\n                \\n                //Traverse over the 3 neighbours and find out the max value possible while updating the ways too\\n                \\n                int maxVal = -1; //set maxVal as -1 not 0 as 0 is also a feasable option(eg: for (0,0) neighbours)\\n                if (dp[i - 1][j - 1].first > maxVal) {\\n                    maxVal = dp[i - 1][j - 1].first;\\n                    dp[i][j].second = dp[i - 1][j - 1].second;\\n                } else if (dp[i - 1][j - 1].first == maxVal) {\\n                    // if this value is same as max till now we can use it\\'s path as well\\n                    dp[i][j].second = (dp[i][j].second + dp[i - 1][j - 1].second) % MOD;\\n                }\\n                \\n                if (dp[i - 1][j].first > maxVal) {\\n                    maxVal = dp[i - 1][j].first;\\n                    dp[i][j].second = dp[i - 1][j].second;\\n                } else if (dp[i - 1][j].first == maxVal) {\\n                    dp[i][j].second = (dp[i][j].second + dp[i - 1][j].second) % MOD;\\n                }\\n                \\n                if (dp[i][j - 1].first > maxVal) {\\n                    maxVal = dp[i][j - 1].first;\\n                    dp[i][j].second = dp[i][j - 1].second;\\n                } else if (dp[i][j - 1].first == maxVal) {\\n                    dp[i][j].second = (dp[i][j].second + dp[i][j - 1].second) % MOD;\\n                }\\n                \\n                //maxVal < 0 indicates that no neighbour is connected to (0,0) so mark this node with least value\\n                if (maxVal < 0) {\\n                     dp[i][j] = {-MOD, 0};\\n                } else {\\n                    dp[i][j].first =  maxVal + (int)(board[i][j] - \\'0\\');\\n                }\\n                \\n            }\\n        }\\n        \\n        vector<int> ans;\\n        if (dp[n - 1][m - 1].first == -MOD) return {0, 0};\\n        \\n        //subtracting (int)(board[n - 1][m - 1] - \\'0\\' as source node has added (\\'S\\' - \\'0\\') which should have been 0\\n        return {dp[n - 1][m - 1].first - (int)(board[n - 1][m - 1] - \\'0\\'), dp[n - 1][m - 1].second};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1142917,
                "title": "c-dp",
                "content": "For any cell, we only need to keep the maximum sum and count (paths to the sum).\\n\\n```\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        unordered_map<int, vector<ll>> dp;\\n        auto res = helper(0, 0, board, dp);\\n        if(res[0]< 0) return {0, 0};\\n        \\n        return {(int) res[0], (int) res[1]};\\n    }\\n    \\n    vector<ll> helper(int r, int c, vector<string>& board, unordered_map<int, vector<ll>>& dp) {\\n        ll big = 1e9 + 7;\\n        vector<ll> res = {};\\n        if(board[r][c] == \\'X\\') return {INT_MIN, INT_MIN};\\n        \\n        int m = board.size(), n = board[0].size();\\n        if(r == m - 1 && c == n-1) return {0, 1};\\n        \\n        if(!dp[r*101 + c].empty()) return dp[r*101 + c];\\n        \\n        int cur = board[r][c] == \\'E\\' ? 0 : board[r][c] - \\'0\\';\\n        \\n        if(r+1 < m) {\\n            auto p = helper(r+1, c, board, dp);\\n            res = {p[0]+cur, p[1]};\\n        }\\n        \\n        if(c+1 < n) {\\n            auto p = helper(r, c+1, board, dp);\\n            if(res.empty() || p[0] + cur > res[0]) {\\n                res = {p[0] + cur, p[1]};\\n            } else if(p[0] + cur == res[0]) {\\n                res = {p[0] + cur, res[1] + p[1]};\\n            }\\n        }\\n        \\n        if(r+1 < m && c+1 < n) {\\n            auto p = helper(r+1, c+1, board, dp);\\n            if(res.empty() || p[0] + cur > res[0]) {\\n                res = {p[0] + cur, p[1]};\\n            } else if(p[0] + cur == res[0]) {\\n                res = {p[0] + cur, res[1] + p[1]};\\n            }\\n        }        \\n        \\n        res[1] = res[1] % big;\\n        dp[r * 101 + c] = res;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        unordered_map<int, vector<ll>> dp;\\n        auto res = helper(0, 0, board, dp);\\n        if(res[0]< 0) return {0, 0};\\n        \\n        return {(int) res[0], (int) res[1]};\\n    }\\n    \\n    vector<ll> helper(int r, int c, vector<string>& board, unordered_map<int, vector<ll>>& dp) {\\n        ll big = 1e9 + 7;\\n        vector<ll> res = {};\\n        if(board[r][c] == \\'X\\') return {INT_MIN, INT_MIN};\\n        \\n        int m = board.size(), n = board[0].size();\\n        if(r == m - 1 && c == n-1) return {0, 1};\\n        \\n        if(!dp[r*101 + c].empty()) return dp[r*101 + c];\\n        \\n        int cur = board[r][c] == \\'E\\' ? 0 : board[r][c] - \\'0\\';\\n        \\n        if(r+1 < m) {\\n            auto p = helper(r+1, c, board, dp);\\n            res = {p[0]+cur, p[1]};\\n        }\\n        \\n        if(c+1 < n) {\\n            auto p = helper(r, c+1, board, dp);\\n            if(res.empty() || p[0] + cur > res[0]) {\\n                res = {p[0] + cur, p[1]};\\n            } else if(p[0] + cur == res[0]) {\\n                res = {p[0] + cur, res[1] + p[1]};\\n            }\\n        }\\n        \\n        if(r+1 < m && c+1 < n) {\\n            auto p = helper(r+1, c+1, board, dp);\\n            if(res.empty() || p[0] + cur > res[0]) {\\n                res = {p[0] + cur, p[1]};\\n            } else if(p[0] + cur == res[0]) {\\n                res = {p[0] + cur, res[1] + p[1]};\\n            }\\n        }        \\n        \\n        res[1] = res[1] % big;\\n        dp[r * 101 + c] = res;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1141001,
                "title": "java-no-recursion",
                "content": "```\\nclass Solution {\\n    private static final int MOD = 1000000007;\\n    int[][] dir = {\\n        {-1, 0},\\n        {0, -1},\\n        {-1, -1}\\n    };\\n    \\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int rows = board.size();\\n        int cols = board.get(0).length();\\n        int[][] memo = new int[rows][cols];\\n        int[][] ways = new int[rows][cols];\\n        fill(board, rows, cols, memo, ways);\\n        int[] result = getMaxNeighborAndWays(memo, ways, rows - 1, cols - 1);\\n        if (result[0] == -1) {\\n            result = new int[] {0,0};\\n        }\\n        return result;\\n    }\\n    \\n    private void fill(List<String> board, int rows, int cols, int[][] memo, int[][] ways) {\\n        for (int row = 0; row < rows; row++) {\\n            for (int col=0; col<cols; col++) {\\n                char c = board.get(row).charAt(col);\\n                if (row==0 && col==0) {\\n                    ways[row][col] = 1;\\n                    continue;\\n                }\\n                if (isDigit(c)) {\\n                    int val = c - \\'0\\';\\n                    int[] naw = getMaxNeighborAndWays(memo, ways, row, col);\\n                    int max = naw[0];\\n                    \\n                    if (max != -1) {\\n                        memo[row][col] = (max + val);\\n                        ways[row][col] = naw[1];\\n                    } else {\\n                        memo[row][col] = -1;\\n                    }\\n                } else if (c == \\'X\\') {\\n                    memo[row][col] = -1;\\n                }\\n            }\\n        }\\n    }\\n    \\n    private int[] getMaxNeighborAndWays(int[][] memo, int[][] ways, int row, int col) {\\n        int max = -1;\\n        int waycount = 0;\\n        for (int[] d : dir) {\\n            int nr = row + d[0];\\n            int nc = col + d[1];\\n            if (nr >= 0 && nc >= 0 && memo[nr][nc] > -1) {\\n                int i = memo[nr][nc];\\n                if (i == max) {\\n                    waycount+=ways[nr][nc];\\n                } else if (i > max) {\\n                    waycount=ways[nr][nc];\\n                    max = i;\\n                }\\n            }\\n        }\\n        return new int[] {(int)(max % MOD), ((int)waycount  % MOD)};\\n    }\\n\\n    private boolean isDigit(char c) {\\n        return (c >= \\'0\\' && c <= \\'9\\');\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int MOD = 1000000007;\\n    int[][] dir = {\\n        {-1, 0},\\n        {0, -1},\\n        {-1, -1}\\n    };\\n    \\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int rows = board.size();\\n        int cols = board.get(0).length();\\n        int[][] memo = new int[rows][cols];\\n        int[][] ways = new int[rows][cols];\\n        fill(board, rows, cols, memo, ways);\\n        int[] result = getMaxNeighborAndWays(memo, ways, rows - 1, cols - 1);\\n        if (result[0] == -1) {\\n            result = new int[] {0,0};\\n        }\\n        return result;\\n    }\\n    \\n    private void fill(List<String> board, int rows, int cols, int[][] memo, int[][] ways) {\\n        for (int row = 0; row < rows; row++) {\\n            for (int col=0; col<cols; col++) {\\n                char c = board.get(row).charAt(col);\\n                if (row==0 && col==0) {\\n                    ways[row][col] = 1;\\n                    continue;\\n                }\\n                if (isDigit(c)) {\\n                    int val = c - \\'0\\';\\n                    int[] naw = getMaxNeighborAndWays(memo, ways, row, col);\\n                    int max = naw[0];\\n                    \\n                    if (max != -1) {\\n                        memo[row][col] = (max + val);\\n                        ways[row][col] = naw[1];\\n                    } else {\\n                        memo[row][col] = -1;\\n                    }\\n                } else if (c == \\'X\\') {\\n                    memo[row][col] = -1;\\n                }\\n            }\\n        }\\n    }\\n    \\n    private int[] getMaxNeighborAndWays(int[][] memo, int[][] ways, int row, int col) {\\n        int max = -1;\\n        int waycount = 0;\\n        for (int[] d : dir) {\\n            int nr = row + d[0];\\n            int nc = col + d[1];\\n            if (nr >= 0 && nc >= 0 && memo[nr][nc] > -1) {\\n                int i = memo[nr][nc];\\n                if (i == max) {\\n                    waycount+=ways[nr][nc];\\n                } else if (i > max) {\\n                    waycount=ways[nr][nc];\\n                    max = i;\\n                }\\n            }\\n        }\\n        return new int[] {(int)(max % MOD), ((int)waycount  % MOD)};\\n    }\\n\\n    private boolean isDigit(char c) {\\n        return (c >= \\'0\\' && c <= \\'9\\');\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068132,
                "title": "lack-test-cases",
                "content": "all the test cases lc provided can\\'t rule out the possibility of a dead(unaccessible tile from start)contributing to the final result, just try test case[\"E191\",\"12XX\",\"1111\",\"111S\"] and delete my conditions on producing max in the helper function. \\n```\\nint mod = 1_000_000_007;\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int n  = board.size(), b[][] = new int[n][n], dp[][][] = new int[n][n][2];\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < n; j++){\\n                char cur = board.get(i).charAt(j);\\n                if (cur == \\'E\\' || cur == \\'S\\'){\\n                    continue;\\n                }else if (cur == \\'X\\'){\\n                    b[i][j] = -1;\\n                }else{\\n                    b[i][j] =Integer.valueOf(String.valueOf(cur));\\n                }\\n            }\\n        }\\n        dp[n-1][n-1][1] = 1;\\n        for (int i = n-2; i >=0; i--){\\n            if (b[n-1][i] == -1) break;\\n            dp[n-1][i][0] = dp[n-1][i+1][0] + b[n-1][i];\\n            dp[n-1][i][1] = 1;\\n        }\\n        for (int i = n-2; i >=0; i--){\\n            if (b[i][n-1] == -1) break;\\n            dp[i][n-1][0] = dp[i+1][n-1][0] + b[i][n-1];\\n            dp[i][n-1][1] = 1;\\n        }\\n        for (int i = n-2; i >= 0; i--){\\n            if (b[i][i] != -1) helper(i,i,b[i][i],dp);\\n            for (int j = n - 3; j >= 0; j--){\\n                if (b[i][j] != -1) helper(i,j,b[i][j],dp);\\n            }\\n            for (int j = n - 3; j >= 0; j--){\\n                if (b[j][i] != -1) helper(j,i,b[j][i],dp);\\n            }\\n        }\\n        if (dp[0][0][1] == 0){\\n            return new int[]{0,0};\\n        }\\n        return dp[0][0];\\n    }\\n    void helper(int r, int c, int val, int[][][] dp){\\n        long res = 0;\\n        int max = 0;\\n        if (dp[r+1][c][1]!=0){\\n            max = Math.max(max,dp[r+1][c][0]);\\n        }\\n        if (dp[r+1][c+1][1]!=0){\\n            max = Math.max(max,dp[r+1][c+1][0]);\\n        }\\n        if (dp[r][c+1][1]!=0){\\n            max = Math.max(max,dp[r][c+1][0]);\\n        }\\n        if (dp[r+1][c][0] == max){\\n            res += dp[r+1][c][1];\\n        }\\n        if (dp[r][c+1][0] == max){\\n            res += dp[r][c+1][1];\\n        }\\n        if (dp[r+1][c+1][0] == max){\\n            res += dp[r+1][c+1][1];\\n        }\\n        res%=mod;\\n        dp[r][c][0] = max+val;\\n        dp[r][c][1] = (int)res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint mod = 1_000_000_007;\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int n  = board.size(), b[][] = new int[n][n], dp[][][] = new int[n][n][2];\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < n; j++){\\n                char cur = board.get(i).charAt(j);\\n                if (cur == \\'E\\' || cur == \\'S\\'){\\n                    continue;\\n                }else if (cur == \\'X\\'){\\n                    b[i][j] = -1;\\n                }else{\\n                    b[i][j] =Integer.valueOf(String.valueOf(cur));\\n                }\\n            }\\n        }\\n        dp[n-1][n-1][1] = 1;\\n        for (int i = n-2; i >=0; i--){\\n            if (b[n-1][i] == -1) break;\\n            dp[n-1][i][0] = dp[n-1][i+1][0] + b[n-1][i];\\n            dp[n-1][i][1] = 1;\\n        }\\n        for (int i = n-2; i >=0; i--){\\n            if (b[i][n-1] == -1) break;\\n            dp[i][n-1][0] = dp[i+1][n-1][0] + b[i][n-1];\\n            dp[i][n-1][1] = 1;\\n        }\\n        for (int i = n-2; i >= 0; i--){\\n            if (b[i][i] != -1) helper(i,i,b[i][i],dp);\\n            for (int j = n - 3; j >= 0; j--){\\n                if (b[i][j] != -1) helper(i,j,b[i][j],dp);\\n            }\\n            for (int j = n - 3; j >= 0; j--){\\n                if (b[j][i] != -1) helper(j,i,b[j][i],dp);\\n            }\\n        }\\n        if (dp[0][0][1] == 0){\\n            return new int[]{0,0};\\n        }\\n        return dp[0][0];\\n    }\\n    void helper(int r, int c, int val, int[][][] dp){\\n        long res = 0;\\n        int max = 0;\\n        if (dp[r+1][c][1]!=0){\\n            max = Math.max(max,dp[r+1][c][0]);\\n        }\\n        if (dp[r+1][c+1][1]!=0){\\n            max = Math.max(max,dp[r+1][c+1][0]);\\n        }\\n        if (dp[r][c+1][1]!=0){\\n            max = Math.max(max,dp[r][c+1][0]);\\n        }\\n        if (dp[r+1][c][0] == max){\\n            res += dp[r+1][c][1];\\n        }\\n        if (dp[r][c+1][0] == max){\\n            res += dp[r][c+1][1];\\n        }\\n        if (dp[r+1][c+1][0] == max){\\n            res += dp[r+1][c+1][1];\\n        }\\n        res%=mod;\\n        dp[r][c][0] = max+val;\\n        dp[r][c][1] = (int)res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1038628,
                "title": "c-dp-many-if-else",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tconst int MOD = 1e9 + 7;\\n\\t\\tvector<int> pathsWithMaxScore(vector<string>& board) {\\n\\t\\t\\tint m = board.size();\\n\\t\\t\\tint n = board[0].size();\\n\\t\\t\\tint DP[m][n];\\n\\t\\t\\tint count[m][n];\\n\\t\\t\\tmemset(DP,0,sizeof(DP));\\n\\t\\t\\tmemset(count,0,sizeof(count));\\n\\t\\t\\tcount[m - 1][n - 1] = 1;\\n\\t\\t\\tfor(int i = m - 1; i >= 0; i--){\\n\\t\\t\\t\\tfor(int j = n - 1; j >= 0; j--){\\n\\t\\t\\t\\t\\tif( board[i][j] == \\'X\\' ) continue;\\n\\t\\t\\t\\t\\tint val = board[i][j] - \\'0\\';\\n\\t\\t\\t\\t\\tif( board[i][j] == \\'S\\' || board[i][j] == \\'E\\' ) val = 0;\\n\\n\\t\\t\\t\\t\\tif( i < m - 1 && board[i + 1][j] != \\'X\\' && (DP[i + 1][j] > 0 || board[i + 1][j] == \\'S\\') ){\\n\\t\\t\\t\\t\\t\\tif( DP[i][j] < val + DP[i + 1][j] ){\\n\\t\\t\\t\\t\\t\\t\\tDP[i][j] = val + DP[i + 1][j];\\n\\t\\t\\t\\t\\t\\t\\tcount[i][j] = count[i + 1][j] % MOD;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if( DP[i][j] == val + DP[i + 1][j] ){\\n\\t\\t\\t\\t\\t\\t\\tcount[i][j] = (count[i][j] + count[i + 1][j]) % MOD;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif( j < n - 1 && board[i][j + 1] != \\'X\\' && (DP[i][j + 1] > 0 || board[i][j + 1] == \\'S\\') ){\\n\\t\\t\\t\\t\\t\\tif( DP[i][j] < val + DP[i][j + 1] ){\\n\\t\\t\\t\\t\\t\\t\\tDP[i][j] = val + DP[i][j + 1];\\n\\t\\t\\t\\t\\t\\t\\tcount[i][j] = count[i][j + 1] % MOD;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if( DP[i][j] == val + DP[i][j + 1] ){\\n\\t\\t\\t\\t\\t\\t\\tcount[i][j] = (count[i][j] + count[i][j + 1]) % MOD;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif( i < m - 1 && j < n - 1 && board[i + 1][j + 1] != \\'X\\' && (DP[i + 1][j + 1] > 0 || board[i + 1][j + 1] == \\'S\\') ){\\n\\t\\t\\t\\t\\t\\tif( DP[i][j] < val + DP[i + 1][j + 1] ){\\n\\t\\t\\t\\t\\t\\t\\tDP[i][j] = val + DP[i + 1][j + 1];\\n\\t\\t\\t\\t\\t\\t\\tcount[i][j] = count[i + 1][j + 1] % MOD;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if( DP[i][j] == val + DP[i + 1][j + 1] ){\\n\\t\\t\\t\\t\\t\\t\\tcount[i][j] = (count[i][j] +  count[i + 1][j + 1]) % MOD;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn {DP[0][0], count[0][0]};\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tconst int MOD = 1e9 + 7;\\n\\t\\tvector<int> pathsWithMaxScore(vector<string>& board) {\\n\\t\\t\\tint m = board.size();\\n\\t\\t\\tint n = board[0].size();\\n\\t\\t\\tint DP[m][n];\\n\\t\\t\\tint count[m][n];\\n\\t\\t\\tmemset(DP,0,sizeof(DP));\\n\\t\\t\\tmemset(count,0,sizeof(count));\\n\\t\\t\\tcount[m - 1][n - 1] = 1;\\n\\t\\t\\tfor(int i = m - 1; i >= 0; i--){\\n\\t\\t\\t\\tfor(int j = n - 1; j >= 0; j--){\\n\\t\\t\\t\\t\\tif( board[i][j] == \\'X\\' ) continue;\\n\\t\\t\\t\\t\\tint val = board[i][j] - \\'0\\';\\n\\t\\t\\t\\t\\tif( board[i][j] == \\'S\\' || board[i][j] == \\'E\\' ) val = 0;\\n\\n\\t\\t\\t\\t\\tif( i < m - 1 && board[i + 1][j] != \\'X\\' && (DP[i + 1][j] > 0 || board[i + 1][j] == \\'S\\') ){\\n\\t\\t\\t\\t\\t\\tif( DP[i][j] < val + DP[i + 1][j] ){\\n\\t\\t\\t\\t\\t\\t\\tDP[i][j] = val + DP[i + 1][j];\\n\\t\\t\\t\\t\\t\\t\\tcount[i][j] = count[i + 1][j] % MOD;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1037456,
                "title": "c-12ms-87-dp-solution-with-comments",
                "content": "Runtime: 12 ms, faster than 86.84% of C++ online submissions for Number of Paths with Max Score.\\nMemory Usage: 8.8 MB, less than 81.58% of C++ online submissions for Number of Paths with Max Score.\\n```\\nclass Solution {\\npublic:\\n  vector<int> pathsWithMaxScore(vector<string>& board) {\\n   \\n    int n = board.size(), nend = board.size() - 1;\\n    vector<vector<int>> mat(n, vector<int>(n));\\n    vector<vector<int>> level(n, vector<int>(n));\\n    board[nend][nend] = \\'0\\', board[0][0] = \\'0\\' , mat[0][0] = 0;\\n    \\n    //construct array of muximum for path\\n    for(int y = 1; y < n; y++)\\n      if(board[y][0] != \\'X\\') mat[y][0] = board[y][0] - \\'0\\' + mat[y-1][0];\\n      else mat[y][0] = 0;\\n    \\n    for(int x = 1; x < n; x++) \\n      if(board[0][x] != \\'X\\') mat[0][x] = board[0][x] - \\'0\\' + mat[0][x-1];\\n      else mat[0][x] = 0;\\n    \\n    for(int y = 1; y < n; y++)\\n      for(int x = 1; x < n; x++)\\n        if(board[y][x] == \\'X\\') mat[y][x] = 0;\\n        else mat[y][x] = board[y][x] - \\'0\\' + max(mat[y-1][x-1],max(mat[y-1][x],mat[y][x-1]));\\n      \\n    //construct array of level of steps for maximum\\n    for(int y = 0; y < n; y++)\\n      if(board[y][0] != \\'X\\') level[y][0] = 1;\\n      else for(; y < n; y++) level[y][0] = 0;\\n    \\n    for(int x = 0; x < n ; x++)\\n      if(board[0][x] != \\'X\\') level[0][x] = 1;\\n      else for(; x < n; x++) level[0][x] = 0;\\n    \\n    for(int y = 1; y < n; y++)\\n\\t\\t\\tfor(int x = 1; x < n; x++){\\n\\t\\t\\t\\tif(board[y][x] == \\'X\\') {level[y][x] = 0; continue;}\\n        int t = board[y][x] - \\'0\\';\\n        \\n\\t\\t\\t\\tif(mat[y-1][x] + t == mat[y][x]) level[y][x] += level[y-1][x];\\n\\t\\t\\t\\tif(mat[y][x-1] + t == mat[y][x]) level[y][x] += level[y][x-1];\\n\\t\\t\\t\\tif(mat[y-1][x-1] + t == mat[y][x]) level[y][x] += level[y-1][x-1];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tlevel[y][x] %= 1000000007;\\n\\t\\t\\t}\\n    \\n\\t\\tif(level[nend][nend] == 0) return {0,0};\\n\\t\\treturn {mat[nend][nend] , level[nend][nend]};\\n  }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n  vector<int> pathsWithMaxScore(vector<string>& board) {\\n   \\n    int n = board.size(), nend = board.size() - 1;\\n    vector<vector<int>> mat(n, vector<int>(n));\\n    vector<vector<int>> level(n, vector<int>(n));\\n    board[nend][nend] = \\'0\\', board[0][0] = \\'0\\' , mat[0][0] = 0;\\n    \\n    //construct array of muximum for path\\n    for(int y = 1; y < n; y++)\\n      if(board[y][0] != \\'X\\') mat[y][0] = board[y][0] - \\'0\\' + mat[y-1][0];\\n      else mat[y][0] = 0;\\n    \\n    for(int x = 1; x < n; x++) \\n      if(board[0][x] != \\'X\\') mat[0][x] = board[0][x] - \\'0\\' + mat[0][x-1];\\n      else mat[0][x] = 0;\\n    \\n    for(int y = 1; y < n; y++)\\n      for(int x = 1; x < n; x++)\\n        if(board[y][x] == \\'X\\') mat[y][x] = 0;\\n        else mat[y][x] = board[y][x] - \\'0\\' + max(mat[y-1][x-1],max(mat[y-1][x],mat[y][x-1]));\\n      \\n    //construct array of level of steps for maximum\\n    for(int y = 0; y < n; y++)\\n      if(board[y][0] != \\'X\\') level[y][0] = 1;\\n      else for(; y < n; y++) level[y][0] = 0;\\n    \\n    for(int x = 0; x < n ; x++)\\n      if(board[0][x] != \\'X\\') level[0][x] = 1;\\n      else for(; x < n; x++) level[0][x] = 0;\\n    \\n    for(int y = 1; y < n; y++)\\n\\t\\t\\tfor(int x = 1; x < n; x++){\\n\\t\\t\\t\\tif(board[y][x] == \\'X\\') {level[y][x] = 0; continue;}",
                "codeTag": "Java"
            },
            {
                "id": 979961,
                "title": "recursive-solution-giving-tle",
                "content": "I am getting TLE. Below is my code-\\nclass Solution {\\npublic:\\n    vector<vector<int>> dir{{-1,0},{0,-1},{-1,-1}};\\n    int mod = 1e9+7;\\n    class pair_{\\n        public:\\n        int s=-1,p=0;\\n    };\\n   \\n    pair_ pathsWithMaxScore(vector<string>& board,vector<vector<pair_>> &dp, int rows,int cols, int i, int j){\\n        if(board[i][j] == \\'E\\'){\\n            dp[i][j].s = 0;\\n            dp[i][j].p = 1;\\n            return dp[i][j];\\n        }\\n        if(dp[i][j].s != -1)\\n            return dp[i][j];\\n        pair_ ans,score;\\n        int x, y;\\n        for(int d=0;d<dir.size();d++){\\n            x = i + dir[d][0];\\n            y = j + dir[d][1];\\n            if(x>=0 && x<rows && y>=0 && y<cols && board[x][y] != \\'X\\'){\\n                score = pathsWithMaxScore(board,dp,rows,cols,x,y);\\n                if(ans.s < score.s){\\n                    ans.s = score.s;\\n                    ans.p = score.p;\\n                }\\n                else if(ans.s == score.s)\\n                    ans.p += score.p;\\n                }\\n            }\\n         if(ans.s == -1)\\n             return dp[i][j] = ans;\\n         if(board[i][j] != \\'S\\')\\n            dp[i][j].s = ((board[i][j] - \\'0\\')% mod + ans.s % mod)% mod;\\n        else\\n            dp[i][j].s = ans.s;\\n        dp[i][j].p = ans.p;\\n        return dp[i][j];\\n    }\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int rows = board.size(), cols = board[0].size();\\n        vector<vector<pair_>> dp(rows,vector<pair_>(cols));\\n        pair_ ans;\\n        vector<int> v(2);\\n        ans = pathsWithMaxScore(board,dp,rows,cols,rows-1,cols-1);\\n        v[0] = ans.s==-1? 0 : ans.s;\\n        v[1] = ans.p;\\n        return v;\\n    }\\n};\\nCan anyone tell what\\'s wrong with my code.\\nThanks in advance.",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> dir{{-1,0}",
                "codeTag": "Java"
            },
            {
                "id": 974843,
                "title": "java-simple-dp",
                "content": "```\\nclass Solution {\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int len = board.size();\\n        int mod = 1_000_000_007;\\n        char[][] b = new char[len][len];\\n        for(int i=0; i<len; i++)\\n            for(int j=0; j<len; j++)\\n                b[i][j] = board.get(i).charAt(j);\\n        b[0][0]=\\'0\\';\\n        long[][][] dp = new long[len+1][len+1][2];\\n        dp[len-1][len-1][0] = 0;\\n        dp[len-1][len-1][1] = 1;\\n        for(int i=len-1; i>=0; i--){\\n            for(int j=len-1; j>=0; j--){\\n                if(i==len-1 && j==len-1 || b[i][j] == \\'X\\') continue;\\n                if(dp[i+1][j][1]!=0 || dp[i][j+1][1]!=0){\\n                    dp[i][j][0] = Math.max(dp[i+1][j][0], dp[i][j+1][0]) + b[i][j] -\\'0\\';\\n                    dp[i][j][1] = dp[i+1][j][0]==dp[i][j+1][0] ? (dp[i+1][j][1]+dp[i][j+1][1])%mod : dp[i+1][j][0]>dp[i][j+1][0] ? dp[i+1][j][1] : dp[i][j+1][1]; \\n                }else if(dp[i+1][j+1][1] != 0){\\n                    dp[i][j][0] = dp[i+1][j+1][0] + b[i][j] -\\'0\\';\\n                    dp[i][j][1] = dp[i+1][j+1][1];\\n                }\\n            }\\n        }\\n        return new int[]{(int)dp[0][0][0], (int)dp[0][0][1]};\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int len = board.size();\\n        int mod = 1_000_000_007;\\n        char[][] b = new char[len][len];\\n        for(int i=0; i<len; i++)\\n            for(int j=0; j<len; j++)\\n                b[i][j] = board.get(i).charAt(j);\\n        b[0][0]=\\'0\\';\\n        long[][][] dp = new long[len+1][len+1][2];\\n        dp[len-1][len-1][0] = 0;\\n        dp[len-1][len-1][1] = 1;\\n        for(int i=len-1; i>=0; i--){\\n            for(int j=len-1; j>=0; j--){\\n                if(i==len-1 && j==len-1 || b[i][j] == \\'X\\') continue;\\n                if(dp[i+1][j][1]!=0 || dp[i][j+1][1]!=0){\\n                    dp[i][j][0] = Math.max(dp[i+1][j][0], dp[i][j+1][0]) + b[i][j] -\\'0\\';\\n                    dp[i][j][1] = dp[i+1][j][0]==dp[i][j+1][0] ? (dp[i+1][j][1]+dp[i][j+1][1])%mod : dp[i+1][j][0]>dp[i][j+1][0] ? dp[i+1][j][1] : dp[i][j+1][1]; \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 913133,
                "title": "c-solution-dp",
                "content": "```\\n#define mod 1000000007\\n\\nclass Solution {\\n    //coded by harsh\\n    vector<vector<pair<int, int>>> dp;\\n    vector<int> ans;\\n    int n,m;\\n    vector<int> dx = {0,1,1};\\n    vector<int> dy = {1,0,1};\\n    int mx;\\npublic:\\n    pair<int,int> rec(int i, int j, vector<string> &board){\\n        if(dp[i][j].first != -1) return dp[i][j];\\n        \\n        if(board[i][j] == \\'X\\'){\\n            dp[i][j] = {0,0};\\n            return {0,0};\\n        }\\n        \\n        if(board[i][j] == \\'S\\'){\\n            dp[i][j] = {0, 1};\\n            return dp[i][j];\\n        }\\n        \\n        int  curr = (board[i][j] - \\'0\\');\\n        if(i==0 && j==0 ) curr = 0;\\n        \\n        dp[i][j] = {0,0};\\n        \\n        for(int k=0;k<3;k++){\\n            int newx = i + dx[k];\\n            int newy = j + dy[k];\\n            \\n            if(newx>=0 && newy>=0 && newx<n && newy<m){\\n                pair<int, int> temp;\\n                if(board[newx][newy] == \\'X\\') {temp = {0,0}; continue;}\\n                else{temp = rec(newx, newy, board);}\\n                \\n                if(temp.second == 0) continue;\\n                \\n                \\n                if(dp[i][j].first < curr + temp.first){\\n                    dp[i][j].second = temp.second;\\n                    dp[i][j].first = curr + temp.first;\\n                    // cout<<dp[i][j].first<<\" \"<<dp[i][j].second<<endl;\\n                }\\n                else if(dp[i][j].first == curr + temp.first){\\n                    dp[i][j].second = (dp[i][j].second +  temp.second)%mod;\\n                }\\n                \\n            }\\n        }\\n        \\n        return dp[i][j];     \\n    }\\n    \\n    \\n    \\n    \\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        n = board.size();\\n        ans = vector<int> (2, 0);\\n        if(n==0) return ans;\\n        m = board[0].length();\\n        \\n        \\n        dp = vector<vector<pair<int,int>>> (n, vector<pair<int,int>> (m, {-1,-1}));\\n        \\n        // dp[n-1][m-1] = {0,1};\\n        \\n        pair<int, int> temp = rec(0,0,board);\\n        ans[0] = temp.first;\\n        ans[1] = temp.second;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define mod 1000000007\\n\\nclass Solution {\\n    //coded by harsh\\n    vector<vector<pair<int, int>>> dp;\\n    vector<int> ans;\\n    int n,m;\\n    vector<int> dx = {0,1,1};\\n    vector<int> dy = {1,0,1};\\n    int mx;\\npublic:\\n    pair<int,int> rec(int i, int j, vector<string> &board){\\n        if(dp[i][j].first != -1) return dp[i][j];\\n        \\n        if(board[i][j] == \\'X\\'){\\n            dp[i][j] = {0,0};\\n            return {0,0};\\n        }\\n        \\n        if(board[i][j] == \\'S\\'){\\n            dp[i][j] = {0, 1};\\n            return dp[i][j];\\n        }\\n        \\n        int  curr = (board[i][j] - \\'0\\');\\n        if(i==0 && j==0 ) curr = 0;\\n        \\n        dp[i][j] = {0,0};\\n        \\n        for(int k=0;k<3;k++){\\n            int newx = i + dx[k];\\n            int newy = j + dy[k];\\n            \\n            if(newx>=0 && newy>=0 && newx<n && newy<m){\\n                pair<int, int> temp;\\n                if(board[newx][newy] == \\'X\\') {temp = {0,0}; continue;}\\n                else{temp = rec(newx, newy, board);}\\n                \\n                if(temp.second == 0) continue;\\n                \\n                \\n                if(dp[i][j].first < curr + temp.first){\\n                    dp[i][j].second = temp.second;\\n                    dp[i][j].first = curr + temp.first;\\n                    // cout<<dp[i][j].first<<\" \"<<dp[i][j].second<<endl;\\n                }\\n                else if(dp[i][j].first == curr + temp.first){\\n                    dp[i][j].second = (dp[i][j].second +  temp.second)%mod;\\n                }\\n                \\n            }\\n        }\\n        \\n        return dp[i][j];     \\n    }\\n    \\n    \\n    \\n    \\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        n = board.size();\\n        ans = vector<int> (2, 0);\\n        if(n==0) return ans;\\n        m = board[0].length();\\n        \\n        \\n        dp = vector<vector<pair<int,int>>> (n, vector<pair<int,int>> (m, {-1,-1}));\\n        \\n        // dp[n-1][m-1] = {0,1};\\n        \\n        pair<int, int> temp = rec(0,0,board);\\n        ans[0] = temp.first;\\n        ans[1] = temp.second;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 903179,
                "title": "java-dp-o-n-2-time-complexity-6-ms-faster-than-98-25-of-java-submissions",
                "content": "```\\nclass Solution {\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int rows = board.size(), cols = board.get(0).length(), counter = 0;\\n        char[][] boardMatrix = new char[rows][cols];\\n        int[][] DP = new int[rows][cols];\\n        int[][] PATH = new int[rows][cols];\\n        int[] result = new int[2];\\n        for(String boardRow : board) {\\n            boardMatrix[counter] = boardRow.toCharArray();\\n            counter++;\\n        }\\n        counter = cols - 2;\\n        while(counter >= 0) {\\n            if(boardMatrix[rows - 1][counter] == \\'X\\') {\\n                break;\\n            }\\n            DP[rows - 1][counter] = (DP[rows - 1][counter + 1] + (boardMatrix[rows - 1][counter] - \\'0\\'));\\n            PATH[rows - 1][counter] = 1;\\n            counter--;\\n        }\\n        counter = rows - 2;\\n        while(counter >= 0) {\\n            if(boardMatrix[counter][cols - 1] == \\'X\\') {\\n                break;\\n            }\\n            DP[counter][cols - 1] = (DP[counter + 1][cols - 1] + (boardMatrix[counter][cols - 1] - \\'0\\'));\\n            PATH[counter][cols - 1] = 1;\\n            counter--;\\n        }\\n        DP[rows - 1][cols - 1] = 1;\\n        for(int i = (rows - 2); i >= 0; i--) {\\n            for(int j = (cols - 2); j >= 0; j--) {\\n                if(!(DP[i + 1][j] == 0 && DP[i][j + 1] == 0 && DP[i + 1][j + 1] == 0)) {\\n                    if(boardMatrix[i][j] != \\'X\\') {\\n                        if(boardMatrix[i][j] != \\'E\\') {\\n                            DP[i][j] = (Math.max(DP[i + 1][j + 1], Math.max(DP[i + 1][j], DP[i][j + 1])) + (boardMatrix[i][j] - \\'0\\'));\\n                        }\\n                        else {\\n                            DP[i][j] = (Math.max(DP[i + 1][j + 1], Math.max(DP[i + 1][j], DP[i][j + 1])));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int i = (rows - 2); i >= 0; i--) {\\n            for(int j = (cols - 2); j >= 0; j--) {\\n                if(!(DP[i + 1][j] == 0 && DP[i][j + 1] == 0 && DP[i + 1][j + 1] == 0) && boardMatrix[i][j] != \\'X\\') {\\n                    if(i == (rows - 2) && j == (cols - 2)) {\\n                        if(DP[i + 1][j] == DP[i][j + 1] && DP[i + 1][j] != 0) {\\n                            PATH[i][j] = 2;\\n                        } else {\\n                            PATH[i][j] = 1;\\n                        }\\n                    } else {\\n                        if(DP[i + 1][j] > DP[i][j + 1] && DP[i + 1][j] > DP[i + 1][j + 1]) {\\n                            PATH[i][j] = PATH[i + 1][j];\\n                        } else if(DP[i][j + 1] > DP[i + 1][j] && DP[i][j + 1] > DP[i + 1][j + 1]) {\\n                            PATH[i][j] = PATH[i][j + 1];\\n                        } else if(DP[i + 1][j + 1] > DP[i + 1][j] && DP[i + 1][j + 1] > DP[i][j + 1]) {\\n                            PATH[i][j] = PATH[i + 1][j + 1];\\n                        } else if(DP[i + 1][j] == DP[i][j + 1] && DP[i + 1][j] == DP[i + 1][j + 1]) {\\n                            PATH[i][j] = (PATH[i + 1][j] + PATH[i][j + 1] + PATH[i + 1][j + 1]) % 1000000007;\\n                        } else if(DP[i + 1][j] == DP[i][j + 1]) {\\n                            PATH[i][j] = (PATH[i + 1][j] + PATH[i][j + 1]) % 1000000007;\\n                        } else if(DP[i][j + 1] == DP[i + 1][j + 1]) {\\n                            PATH[i][j] = (PATH[i][j + 1] + PATH[i + 1][j + 1]) % 1000000007;\\n                        } else if(DP[i + 1][j] == DP[i + 1][j + 1]) {\\n                            PATH[i][j] = (PATH[i + 1][j] + PATH[i + 1][j + 1]) % 1000000007;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        result[0] = DP[0][0];\\n        result[1] = PATH[0][0] % 1000000007;\\n        if(boardMatrix[rows - 2][cols - 1] == \\'X\\' && boardMatrix[rows - 1][cols - 2] == \\'X\\' && boardMatrix[rows - 2][cols - 2] != \\'X\\') {\\n            result[0]--;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int rows = board.size(), cols = board.get(0).length(), counter = 0;\\n        char[][] boardMatrix = new char[rows][cols];\\n        int[][] DP = new int[rows][cols];\\n        int[][] PATH = new int[rows][cols];\\n        int[] result = new int[2];\\n        for(String boardRow : board) {\\n            boardMatrix[counter] = boardRow.toCharArray();\\n            counter++;\\n        }\\n        counter = cols - 2;\\n        while(counter >= 0) {\\n            if(boardMatrix[rows - 1][counter] == \\'X\\') {\\n                break;\\n            }\\n            DP[rows - 1][counter] = (DP[rows - 1][counter + 1] + (boardMatrix[rows - 1][counter] - \\'0\\'));\\n            PATH[rows - 1][counter] = 1;\\n            counter--;\\n        }\\n        counter = rows - 2;\\n        while(counter >= 0) {\\n            if(boardMatrix[counter][cols - 1] == \\'X\\') {\\n                break;\\n            }\\n            DP[counter][cols - 1] = (DP[counter + 1][cols - 1] + (boardMatrix[counter][cols - 1] - \\'0\\'));\\n            PATH[counter][cols - 1] = 1;\\n            counter--;\\n        }\\n        DP[rows - 1][cols - 1] = 1;\\n        for(int i = (rows - 2); i >= 0; i--) {\\n            for(int j = (cols - 2); j >= 0; j--) {\\n                if(!(DP[i + 1][j] == 0 && DP[i][j + 1] == 0 && DP[i + 1][j + 1] == 0)) {\\n                    if(boardMatrix[i][j] != \\'X\\') {\\n                        if(boardMatrix[i][j] != \\'E\\') {\\n                            DP[i][j] = (Math.max(DP[i + 1][j + 1], Math.max(DP[i + 1][j], DP[i][j + 1])) + (boardMatrix[i][j] - \\'0\\'));\\n                        }\\n                        else {\\n                            DP[i][j] = (Math.max(DP[i + 1][j + 1], Math.max(DP[i + 1][j], DP[i][j + 1])));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int i = (rows - 2); i >= 0; i--) {\\n            for(int j = (cols - 2); j >= 0; j--) {\\n                if(!(DP[i + 1][j] == 0 && DP[i][j + 1] == 0 && DP[i + 1][j + 1] == 0) && boardMatrix[i][j] != \\'X\\') {\\n                    if(i == (rows - 2) && j == (cols - 2)) {\\n                        if(DP[i + 1][j] == DP[i][j + 1] && DP[i + 1][j] != 0) {\\n                            PATH[i][j] = 2;\\n                        } else {\\n                            PATH[i][j] = 1;\\n                        }\\n                    } else {\\n                        if(DP[i + 1][j] > DP[i][j + 1] && DP[i + 1][j] > DP[i + 1][j + 1]) {\\n                            PATH[i][j] = PATH[i + 1][j];\\n                        } else if(DP[i][j + 1] > DP[i + 1][j] && DP[i][j + 1] > DP[i + 1][j + 1]) {\\n                            PATH[i][j] = PATH[i][j + 1];\\n                        } else if(DP[i + 1][j + 1] > DP[i + 1][j] && DP[i + 1][j + 1] > DP[i][j + 1]) {\\n                            PATH[i][j] = PATH[i + 1][j + 1];\\n                        } else if(DP[i + 1][j] == DP[i][j + 1] && DP[i + 1][j] == DP[i + 1][j + 1]) {\\n                            PATH[i][j] = (PATH[i + 1][j] + PATH[i][j + 1] + PATH[i + 1][j + 1]) % 1000000007;\\n                        } else if(DP[i + 1][j] == DP[i][j + 1]) {\\n                            PATH[i][j] = (PATH[i + 1][j] + PATH[i][j + 1]) % 1000000007;\\n                        } else if(DP[i][j + 1] == DP[i + 1][j + 1]) {\\n                            PATH[i][j] = (PATH[i][j + 1] + PATH[i + 1][j + 1]) % 1000000007;\\n                        } else if(DP[i + 1][j] == DP[i + 1][j + 1]) {\\n                            PATH[i][j] = (PATH[i + 1][j] + PATH[i + 1][j + 1]) % 1000000007;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        result[0] = DP[0][0];\\n        result[1] = PATH[0][0] % 1000000007;\\n        if(boardMatrix[rows - 2][cols - 1] == \\'X\\' && boardMatrix[rows - 1][cols - 2] == \\'X\\' && boardMatrix[rows - 2][cols - 2] != \\'X\\') {\\n            result[0]--;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900698,
                "title": "python-a-short-recursive-solution",
                "content": "**Solution:**\\n\\n*helper function*\\nStart at the lower right corner of the board **(M-1, N-1)**.\\nAt each step consider 3 options: Move up, move up-left, move left.\\nReturn the option that yields the greatest value **and** the count of all options that have that value.\\n\\n*preprocessing*\\n**d** maps each number to an integer (\\'1\\' -> 1), start and end (\\'S\\' and \\'E\\') to 0, and walls (\\'X\\') to -&infin;.  \\n\\n*post-processing*\\nIf our best result is -&infin; then return [0, 0], otherwise return our best result.\\n\\nHope this helps!\\n\\n<br>\\n\\n```python\\ndef pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n\\n\\t@functools.lru_cache(None)\\n\\tdef helper(i, j):\\n\\n\\t\\tif i == j == 0:\\n\\t\\t\\treturn (0, 1) # We reached the end, return 0 points and 1 path\\n\\n\\t\\tif (i < 0) or (j < 0):\\n\\t\\t\\treturn (float(\\'-inf\\'), 0) # Treat going off the board like a wall, return -inf\\n\\n\\t\\toptions = [helper(i-1, j), helper(i-1, j-1), helper(i, j-1)]\\n\\t\\ttarget = max(options, key = lambda opt: opt[0])[0]\\n\\t\\treturn (board[i][j] + target, sum((opt[1] for opt in options if opt[0] == target)))\\n\\n\\n\\tMOD = 10**9 + 7\\n\\td = {str(i): i for i in range(1,10)}\\n\\td.update({\\'S\\': 0, \\'E\\': 0, \\'X\\': float(\\'-inf\\')})\\n\\tboard = [[d[char] for char in row] for row in board]\\n\\n\\tres = helper(len(board) - 1, len(board[0]) - 1)\\n\\treturn (res[0] % MOD, res[1] % MOD) if res[0] != float(\\'-inf\\') else [0,0]\\n```",
                "solutionTags": [],
                "code": "```python\\ndef pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n\\n\\t@functools.lru_cache(None)\\n\\tdef helper(i, j):\\n\\n\\t\\tif i == j == 0:\\n\\t\\t\\treturn (0, 1) # We reached the end, return 0 points and 1 path\\n\\n\\t\\tif (i < 0) or (j < 0):\\n\\t\\t\\treturn (float(\\'-inf\\'), 0) # Treat going off the board like a wall, return -inf\\n\\n\\t\\toptions = [helper(i-1, j), helper(i-1, j-1), helper(i, j-1)]\\n\\t\\ttarget = max(options, key = lambda opt: opt[0])[0]\\n\\t\\treturn (board[i][j] + target, sum((opt[1] for opt in options if opt[0] == target)))\\n\\n\\n\\tMOD = 10**9 + 7\\n\\td = {str(i): i for i in range(1,10)}\\n\\td.update({\\'S\\': 0, \\'E\\': 0, \\'X\\': float(\\'-inf\\')})\\n\\tboard = [[d[char] for char in row] for row in board]\\n\\n\\tres = helper(len(board) - 1, len(board[0]) - 1)\\n\\treturn (res[0] % MOD, res[1] % MOD) if res[0] != float(\\'-inf\\') else [0,0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 859700,
                "title": "python-dp-table-solution",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n\\t\\t\\tm = len(board)\\n\\t\\t\\tn = len(board[0])\\n\\t\\t\\tdp = [[(0, 0) for _ in range(n)] for _ in range(m)]\\n\\t\\t\\tMOD = 10**9+7\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tif i == 0 and j == 0:\\n\\t\\t\\t\\t\\t\\tdp[i][j] = [0, 1]\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tif board[i][j] == \\'X\\':\\n\\t\\t\\t\\t\\t\\tdp[i][j] = [0, 0]\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tcur_score = int(board[i][j]) if board[i][j] != \\'S\\' else 0\\n\\t\\t\\t\\t\\ta = [dp[i-1][j][0] + cur_score, dp[i-1][j][1]]  if i-1 >= 0 and dp[i-1][j][1] > 0 else [0, 0]\\n\\t\\t\\t\\t\\tb = [dp[i-1][j-1][0] + cur_score, dp[i-1][j-1][1]] if i-1 >= 0 and j-1 >= 0 and dp[i-1][j-1][1] > 0 else [0, 0]\\n\\t\\t\\t\\t\\tc = [dp[i][j-1][0] + cur_score, dp[i][j-1][1]] if j-1 >= 0 and dp[i][j-1][1] > 0 else [0, 0]\\n\\t\\t\\t\\t\\tmax_score = max(a[0], b[0], c[0])\\n\\t\\t\\t\\t\\tfreq = 0\\n\\t\\t\\t\\t\\tfor score in (a, b, c):\\n\\t\\t\\t\\t\\t\\tif score[0] == max_score:\\n\\t\\t\\t\\t\\t\\t\\tfreq += score[1]\\n\\t\\t\\t\\t\\tdp[i][j] = [max_score, freq%MOD]\\n\\n\\t\\t\\treturn dp[m-1][n-1] \\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n\\t\\t\\tm = len(board)\\n\\t\\t\\tn = len(board[0])\\n\\t\\t\\tdp = [[(0, 0) for _ in range(n)] for _ in range(m)]\\n\\t\\t\\tMOD = 10**9+7\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tif i == 0 and j == 0:\\n\\t\\t\\t\\t\\t\\tdp[i][j] = [0, 1]\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tif board[i][j] == \\'X\\':\\n\\t\\t\\t\\t\\t\\tdp[i][j] = [0, 0]\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\tcur_score = int(board[i][j]) if board[i][j] != \\'S\\' else 0\\n\\t\\t\\t\\t\\ta = [dp[i-1][j][0] + cur_score, dp[i-1][j][1]]  if i-1 >= 0 and dp[i-1][j][1] > 0 else [0, 0]\\n\\t\\t\\t\\t\\tb = [dp[i-1][j-1][0] + cur_score, dp[i-1][j-1][1]] if i-1 >= 0 and j-1 >= 0 and dp[i-1][j-1][1] > 0 else [0, 0]\\n\\t\\t\\t\\t\\tc = [dp[i][j-1][0] + cur_score, dp[i][j-1][1]] if j-1 >= 0 and dp[i][j-1][1] > 0 else [0, 0]\\n\\t\\t\\t\\t\\tmax_score = max(a[0], b[0], c[0])\\n\\t\\t\\t\\t\\tfreq = 0\\n\\t\\t\\t\\t\\tfor score in (a, b, c):\\n\\t\\t\\t\\t\\t\\tif score[0] == max_score:\\n\\t\\t\\t\\t\\t\\t\\tfreq += score[1]\\n\\t\\t\\t\\t\\tdp[i][j] = [max_score, freq%MOD]\\n\\n\\t\\t\\treturn dp[m-1][n-1] \\n\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 823643,
                "title": "basic-java-solution-tle-dp",
                "content": "\\tclass Solution {\\n\\t\\tint[][][]dp;\\n\\t\\tint length;\\n\\t\\tint mod=1000000007;\\n\\t\\tpublic int[] pathsWithMaxScore(List<String> board) {\\n\\t\\t\\tdp=new int[board.size()][board.size()][2];\\n\\t\\t\\tlength=board.size();\\n\\t\\t\\tdp[dp.length-1][dp.length-1][0]=0;\\n\\t\\t\\tdp[dp.length-1][dp.length-1][1]=1;\\n\\t\\t\\tint ans=fn(board,0,0)%mod;\\n\\t\\t\\t/*for(int i=0;i<length;i++){\\n\\t\\t\\t\\tfor(int j=0;j<length;j++){\\n\\t\\t\\t\\t\\tSystem.out.print(dp[i][j][0]+\" \"+dp[i][j][1]+\"        \");\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tSystem.out.println(\"\");\\n\\t\\t\\t}*/\\n\\t\\t\\treturn new int[]{ans,dp[0][0][1]};\\n\\t\\t}\\n\\t\\tpublic int fn(List<String>board,int x,int y){\\n\\t\\t\\tif(x>= length ){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tif(y>=length ){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tif(x==length-1 && y==length-1){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tchar tp=board.get(x).charAt(y);\\n\\t\\t\\tint num=-1;\\n\\t\\t\\tif(tp!=\\'X\\'){\\n\\t\\t\\t\\t   num=(int)tp-48; \\n\\t\\t\\t}\\n\\t\\t\\tif(tp==\\'S\\'||tp==\\'E\\'){\\n\\t\\t\\t\\t   num=0; \\n\\t\\t\\t}\\n\\t\\t   // System.out.println(x+\" \"+ y);\\n\\t\\t\\tif(num==-1){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tif(dp[x][y][1]!=0){\\n\\t\\t\\t\\treturn dp[x][y][0]%mod;\\n\\t\\t\\t}\\n\\t\\t\\tif(x<length-1&&y<length-1){\\n\\t\\t\\t\\tint temp=fn(board,x+1,y)%mod;\\n\\t\\t\\t   if(temp!=0&&dp[x][y][0]<num+temp){\\n\\t\\t\\t\\t   dp[x][y][0]=(num+temp)%mod;\\n\\t\\t\\t\\t   dp[x][y][1]=dp[x+1][y][1];\\n\\t\\t\\t   }else if(temp!=0&&dp[x][y][0]==num+temp){\\n\\t\\t\\t\\t   dp[x][y][1]+=dp[x+1][y][1];\\n\\t\\t\\t   }\\n\\t\\t\\t\\ttemp=fn(board,x,y+1)%mod;\\n\\t\\t\\t   if(temp!=0&&dp[x][y][0]<num+temp){\\n\\t\\t\\t\\t   dp[x][y][0]=(num+temp)%mod;\\n\\t\\t\\t\\t   dp[x][y][1]=dp[x][y+1][1];\\n\\t\\t\\t   }else if(temp!=0&&dp[x][y][0]==num+temp){\\n\\t\\t\\t\\t   dp[x][y][1]+=dp[x][y+1][1];\\n\\t\\t\\t   }\\n\\t\\t\\t\\ttemp=fn(board,x+1,y+1)%mod;\\n\\t\\t\\t\\t//((y==length-2)&&(x==length-2))\\n\\t\\t\\t   if((temp!=0||((y==length-2)&&(x==length-2)))&&dp[x][y][0]<num+temp){\\n\\t\\t\\t\\t   dp[x][y][0]=(num+temp)%mod;\\n\\t\\t\\t\\t   dp[x][y][1]=dp[x+1][y+1][1];\\n\\t\\t\\t   }else if((temp!=0||((y==length-2)&&(x==length-2)))&&dp[x][y][0]==num+temp){\\n\\t\\t\\t\\t   dp[x][y][1]+=dp[x+1][y+1][1];\\n\\t\\t\\t   }    \\n\\n\\t\\t\\t}\\n\\t\\t\\tif(x==length-1){\\n\\t\\t\\t\\tint temp=fn(board,x,y+1)%mod;\\n\\t\\t\\t   if((temp!=0||y==length-2)&&dp[x][y][0]<num+temp){\\n\\t\\t\\t\\t   dp[x][y][0]=(num+temp)%mod;\\n\\t\\t\\t\\t   dp[x][y][1]=1;\\n\\t\\t\\t   }else if(temp!=0&&dp[x][y][0]==num+temp){\\n\\t\\t\\t\\t   dp[x][y][1]+=1;\\n\\t\\t\\t   }\\n\\t\\t\\t}\\n\\t\\t\\tif(y==length-1){\\n\\t\\t\\t\\t int temp=fn(board,x+1,y)%mod;\\n\\t\\t\\t   if((temp!=0||x==length-2)&&dp[x][y][0]<num+temp){\\n\\t\\t\\t\\t   dp[x][y][0]=(num+temp)%mod;\\n\\t\\t\\t\\t   dp[x][y][1]=1;\\n\\t\\t\\t   }else if(temp!=0&&dp[x][y][0]==num+temp){\\n\\t\\t\\t\\t   dp[x][y][1]+=1;\\n\\t\\t\\t   }\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn dp[x][y][0]%mod;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\t\\tint[][][]dp;\\n\\t\\tint length;\\n\\t\\tint mod=1000000007;\\n\\t\\tpublic int[] pathsWithMaxScore(List<String> board) {\\n\\t\\t\\tdp=new int[board.size()][board.size()][2];\\n\\t\\t\\tlength=board.size();\\n\\t\\t\\tdp[dp.length-1][dp.length-1][0]=0;\\n\\t\\t\\tdp[dp.length-1][dp.length-1][1]=1;\\n\\t\\t\\tint ans=fn(board,0,0)%mod;\\n\\t\\t\\t/*for(int i=0;i<length;i++){\\n\\t\\t\\t\\tfor(int j=0;j<length;j++){\\n\\t\\t\\t\\t\\tSystem.out.print(dp[i][j][0]+\" \"+dp[i][j][1]+\"        \");\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 815657,
                "title": "one-pass-simple-easy-to-understand-java-solution",
                "content": "Beats 96% of Java submissions in runtime & 85% in Memory.\\n```\\nclass Solution {\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        if (board==null || board.size()==0)\\n            return new int[2];\\n        final int MOD = 1_000_000_007;\\n        int len = board.size();\\n        int[][] sum = new int[len][len];\\n        int[][] counts = new int[len][len]; \\n        counts[len-1][len-1] = 1;\\n        final int[][] neighs = new int[][]{\\n            {1,0}, {0,1}, {1,1}\\n        };\\n        for(int i=len-1;i>=0;i--) {\\n            for(int j=len-1;j>=0;j--) {\\n                int val = getValue(board.get(i).charAt(j));\\n                if (val==-1)\\n                    continue;\\n                // System.out.println(\"Processing (\"+i+\",\"+j+\")\");\\n                for(int[] neigh : neighs) {\\n                    int row = i + neigh[0];\\n                    int col = j + neigh[1];\\n                    if (row>len-1 || col>len-1 || counts[row][col]==0)\\n                        continue;\\n                    // System.out.println(\"Processing Neighbor(\"+row+\",\"+col+\")\");\\n                    int newSum = val + sum[row][col];\\n                    if (newSum<sum[i][j])\\n                        continue;\\n                    if (newSum==sum[i][j]) {\\n                        counts[i][j] = (counts[i][j] + counts[row][col])%MOD;\\n                    }\\n                    if (newSum>sum[i][j]) {\\n                        sum[i][j]=newSum;\\n                        counts[i][j] = counts[row][col];\\n                    }\\n                }\\n            }\\n        }\\n        return new int[]{sum[0][0], counts[0][0]};\\n    }\\n    \\n    private int getValue(char c) {\\n        if (c==\\'S\\' || c==\\'E\\') {\\n            return 0;\\n        }\\n        if (c==\\'X\\')\\n            return -1;\\n        return c-\\'0\\';\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        if (board==null || board.size()==0)\\n            return new int[2];\\n        final int MOD = 1_000_000_007;\\n        int len = board.size();\\n        int[][] sum = new int[len][len];\\n        int[][] counts = new int[len][len]; \\n        counts[len-1][len-1] = 1;\\n        final int[][] neighs = new int[][]{\\n            {1,0}, {0,1}, {1,1}\\n        };\\n        for(int i=len-1;i>=0;i--) {\\n            for(int j=len-1;j>=0;j--) {\\n                int val = getValue(board.get(i).charAt(j));\\n                if (val==-1)\\n                    continue;\\n                // System.out.println(\"Processing (\"+i+\",\"+j+\")\");\\n                for(int[] neigh : neighs) {\\n                    int row = i + neigh[0];\\n                    int col = j + neigh[1];\\n                    if (row>len-1 || col>len-1 || counts[row][col]==0)\\n                        continue;\\n                    // System.out.println(\"Processing Neighbor(\"+row+\",\"+col+\")\");\\n                    int newSum = val + sum[row][col];\\n                    if (newSum<sum[i][j])\\n                        continue;\\n                    if (newSum==sum[i][j]) {\\n                        counts[i][j] = (counts[i][j] + counts[row][col])%MOD;\\n                    }\\n                    if (newSum>sum[i][j]) {\\n                        sum[i][j]=newSum;\\n                        counts[i][j] = counts[row][col];\\n                    }\\n                }\\n            }\\n        }\\n        return new int[]{sum[0][0], counts[0][0]};\\n    }\\n    \\n    private int getValue(char c) {\\n        if (c==\\'S\\' || c==\\'E\\') {\\n            return 0;\\n        }\\n        if (c==\\'X\\')\\n            return -1;\\n        return c-\\'0\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794235,
                "title": "ruby-dp-beats-100",
                "content": "```\\nMOD = 10**9 + 7\\n\\ndef paths_with_max_score(board)\\n  n, m, f = board.size, board[0].size, []\\n  f[0] ||= []\\n  f[0][0] ||= [0, 1]\\n  (0..n-1).each do |i|\\n    f[i] ||= []\\n    (0..m-1).each do |j|\\n      next if board[i][j] == \\'X\\'\\n      if i == 0 && j > 0 && f[i][j-1]\\n        f[i][j] = f[i][j-1].clone\\n      elsif j == 0 && i > 0 && f[i-1][j]\\n        f[i][j] = f[i-1][j].clone\\n      elsif i > 0 && j > 0\\n        f[i][j] = f[i-1][j-1].clone\\n\\n        if f[i][j-1]\\n          if f[i][j].nil? || f[i][j-1][0] > f[i][j][0]\\n            f[i][j] = f[i][j-1].clone\\n          elsif f[i][j-1][0] == f[i][j][0]\\n            f[i][j][1] += f[i][j-1][1]\\n          end\\n        end\\n\\n        if f[i-1][j]\\n          if f[i][j].nil? || f[i-1][j][0] > f[i][j][0]\\n            f[i][j] = f[i-1][j].clone\\n          elsif f[i-1][j][0] == f[i][j][0]\\n            f[i][j][1] += f[i-1][j][1]\\n          end\\n        end\\n      end\\n      f[i][j][0] += board[i][j].to_i if f[i][j]\\n      f[i][j][1] %= MOD if f[i][j]\\n    end\\n  end\\n  f[-1][-1] || [0, 0]\\nend\\n```",
                "solutionTags": [],
                "code": "```\\nMOD = 10**9 + 7\\n\\ndef paths_with_max_score(board)\\n  n, m, f = board.size, board[0].size, []\\n  f[0] ||= []\\n  f[0][0] ||= [0, 1]\\n  (0..n-1).each do |i|\\n    f[i] ||= []\\n    (0..m-1).each do |j|\\n      next if board[i][j] == \\'X\\'\\n      if i == 0 && j > 0 && f[i][j-1]\\n        f[i][j] = f[i][j-1].clone\\n      elsif j == 0 && i > 0 && f[i-1][j]\\n        f[i][j] = f[i-1][j].clone\\n      elsif i > 0 && j > 0\\n        f[i][j] = f[i-1][j-1].clone\\n\\n        if f[i][j-1]\\n          if f[i][j].nil? || f[i][j-1][0] > f[i][j][0]\\n            f[i][j] = f[i][j-1].clone\\n          elsif f[i][j-1][0] == f[i][j][0]\\n            f[i][j][1] += f[i][j-1][1]\\n          end\\n        end\\n\\n        if f[i-1][j]\\n          if f[i][j].nil? || f[i-1][j][0] > f[i][j][0]\\n            f[i][j] = f[i-1][j].clone\\n          elsif f[i-1][j][0] == f[i][j][0]\\n            f[i][j][1] += f[i-1][j][1]\\n          end\\n        end\\n      end\\n      f[i][j][0] += board[i][j].to_i if f[i][j]\\n      f[i][j][1] %= MOD if f[i][j]\\n    end\\n  end\\n  f[-1][-1] || [0, 0]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 794003,
                "title": "beautiful-java-reads-almost-like-shakespeare",
                "content": "```\\nimport org.junit.Test;\\n\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.Optional;\\n\\nimport static org.junit.Assert.assertArrayEquals;\\n\\npublic class Solution {\\n\\n    private static class Node {\\n\\n        final int val;\\n        int sum = -1;\\n        int numberOfWays = 1;\\n\\n        Node(final int val) {\\n            this.val = val;\\n        }\\n\\n    }\\n\\n    private static final Node X = new Node(-1);\\n\\n    public int[] pathsWithMaxScore(final List<String> board) {\\n        final int n = board.size();\\n        final Node[][] dp = new Node[n][n];\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                final int x = n - 1 - i;\\n                final int y = n - 1 - j;\\n                final char c = board.get(x).charAt(y);\\n                int val = c - \\'0\\';\\n\\n                if (c == \\'S\\' || c == \\'E\\') {\\n                    val = 0;\\n                } else if (c == \\'X\\') {\\n                    val = -1;\\n                }\\n\\n                dp[i][j] = new Node(val);\\n\\n                if (val == -1) {\\n                    continue;\\n                }\\n\\n                if (i == 0 && j == 0) {\\n                    dp[0][0].sum = 0;\\n                    continue;\\n                }\\n\\n                Node top = X;\\n\\n                if (i >= 1) {\\n                    top = dp[i - 1][j];\\n                }\\n\\n                Node left = X;\\n\\n                if (j >= 1) {\\n                    left = dp[i][j - 1];\\n                }\\n\\n                Node topLeft = X;\\n\\n                if (i >= 1 && j >= 1) {\\n                    topLeft = dp[i - 1][j - 1];\\n                }\\n\\n                final int maxSum = Math.max(Math.max(top.sum, left.sum), topLeft.sum);\\n\\n                if (maxSum != -1) {\\n                    long numberOfWays = 0L;\\n\\n                    if (top.sum == maxSum) {\\n                        numberOfWays = numberOfWays + top.numberOfWays;\\n                    }\\n\\n                    if (left.sum == maxSum) {\\n                        numberOfWays = numberOfWays + left.numberOfWays;\\n                    }\\n\\n                    if (topLeft.sum == maxSum) {\\n                        numberOfWays = numberOfWays + topLeft.numberOfWays;\\n                    }\\n\\n                    dp[i][j].sum = dp[i][j].val + maxSum;\\n                    dp[i][j].numberOfWays = (int) (numberOfWays % (1e9 + 7));\\n                }\\n            }\\n        }\\n\\n        final Node end = dp[n - 1][n - 1];\\n\\n        if (end.sum == -1) {\\n            return new int[]{0, 0};\\n        }\\n\\n        return new int[]{end.sum, end.numberOfWays};\\n    }\\n\\n    @Test\\n    public void test() {\\n        assertArrayEquals(new int[]{34, 3}, new Solution().pathsWithMaxScore(Arrays.asList(\"E11345\",\"X452XX\",\"3X43X4\",\"422812\",\"284522\",\"13422S\")));\\n        assertArrayEquals(new int[]{7, 1}, new Solution().pathsWithMaxScore(Arrays.asList(\"E23\",\"2X2\",\"12S\")));\\n        assertArrayEquals(new int[]{4, 2}, new Solution().pathsWithMaxScore(Arrays.asList(\"E12\",\"1X1\",\"21S\")));\\n        assertArrayEquals(new int[]{0, 0}, new Solution().pathsWithMaxScore(Arrays.asList(\"E11\",\"XXX\",\"11S\")));\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport org.junit.Test;\\n\\nimport java.util.Arrays;\\nimport java.util.List;\\nimport java.util.Optional;\\n\\nimport static org.junit.Assert.assertArrayEquals;\\n\\npublic class Solution {\\n\\n    private static class Node {\\n\\n        final int val;\\n        int sum = -1;\\n        int numberOfWays = 1;\\n\\n        Node(final int val) {\\n            this.val = val;\\n        }\\n\\n    }\\n\\n    private static final Node X = new Node(-1);\\n\\n    public int[] pathsWithMaxScore(final List<String> board) {\\n        final int n = board.size();\\n        final Node[][] dp = new Node[n][n];\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                final int x = n - 1 - i;\\n                final int y = n - 1 - j;\\n                final char c = board.get(x).charAt(y);\\n                int val = c - \\'0\\';\\n\\n                if (c == \\'S\\' || c == \\'E\\') {\\n                    val = 0;\\n                } else if (c == \\'X\\') {\\n                    val = -1;\\n                }\\n\\n                dp[i][j] = new Node(val);\\n\\n                if (val == -1) {\\n                    continue;\\n                }\\n\\n                if (i == 0 && j == 0) {\\n                    dp[0][0].sum = 0;\\n                    continue;\\n                }\\n\\n                Node top = X;\\n\\n                if (i >= 1) {\\n                    top = dp[i - 1][j];\\n                }\\n\\n                Node left = X;\\n\\n                if (j >= 1) {\\n                    left = dp[i][j - 1];\\n                }\\n\\n                Node topLeft = X;\\n\\n                if (i >= 1 && j >= 1) {\\n                    topLeft = dp[i - 1][j - 1];\\n                }\\n\\n                final int maxSum = Math.max(Math.max(top.sum, left.sum), topLeft.sum);\\n\\n                if (maxSum != -1) {\\n                    long numberOfWays = 0L;\\n\\n                    if (top.sum == maxSum) {\\n                        numberOfWays = numberOfWays + top.numberOfWays;\\n                    }\\n\\n                    if (left.sum == maxSum) {\\n                        numberOfWays = numberOfWays + left.numberOfWays;\\n                    }\\n\\n                    if (topLeft.sum == maxSum) {\\n                        numberOfWays = numberOfWays + topLeft.numberOfWays;\\n                    }\\n\\n                    dp[i][j].sum = dp[i][j].val + maxSum;\\n                    dp[i][j].numberOfWays = (int) (numberOfWays % (1e9 + 7));\\n                }\\n            }\\n        }\\n\\n        final Node end = dp[n - 1][n - 1];\\n\\n        if (end.sum == -1) {\\n            return new int[]{0, 0};\\n        }\\n\\n        return new int[]{end.sum, end.numberOfWays};\\n    }\\n\\n    @Test\\n    public void test() {\\n        assertArrayEquals(new int[]{34, 3}, new Solution().pathsWithMaxScore(Arrays.asList(\"E11345\",\"X452XX\",\"3X43X4\",\"422812\",\"284522\",\"13422S\")));\\n        assertArrayEquals(new int[]{7, 1}, new Solution().pathsWithMaxScore(Arrays.asList(\"E23\",\"2X2\",\"12S\")));\\n        assertArrayEquals(new int[]{4, 2}, new Solution().pathsWithMaxScore(Arrays.asList(\"E12\",\"1X1\",\"21S\")));\\n        assertArrayEquals(new int[]{0, 0}, new Solution().pathsWithMaxScore(Arrays.asList(\"E11\",\"XXX\",\"11S\")));\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741604,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    long mod=(long)(1e9+7);\\n    int n,m;\\n    \\n    class data\\n    {\\n        long val=0;\\n        long path=0;\\n        \\n        data(long val,long path)\\n        {\\n            this.val=val;\\n            this.path=path;\\n        }\\n    }\\n    public int[] pathsWithMaxScore(List<String> board) \\n    {\\n        n=board.size();\\n        m=board.get(0).length();\\n        \\n        data dp[][]=new data[n][m];\\n        \\n        data ans=helper(board,dp,0,0);\\n\\n        int val=ans.val<0?0:(int)ans.val;\\n        int path=ans.val<0?0:(int)ans.path;\\n        return new int[]{val,path};\\n    }\\n    \\n    private data helper(List<String>board,data dp[][],int start,int end)\\n    {\\n        if(start==n-1&&end==m-1)\\n            return new data(0,1);\\n        \\n        if(start>=n||end>=m||board.get(start).charAt(end)==\\'X\\')\\n            return new data(Integer.MIN_VALUE,0);\\n        \\n        if(dp[start][end]!=null)\\n            return dp[start][end];\\n        \\n        data val1=helper(board,dp,start+1,end);\\n        data val2=helper(board,dp,start+1,end+1);\\n        data val3=helper(board,dp,start,end+1);\\n        \\n        long val=Math.max(val1.val,Math.max(val2.val,val3.val));\\n        \\n        int path=0;\\n        if(val>=0)\\n        {\\n            if(val==val1.val)\\n                path+=val1.path;\\n            \\n            if(val==val2.val)\\n                path+=val2.path;\\n            \\n            if(val==val3.val)\\n                path+=val3.path;\\n        }\\n        \\n        if(start>0||end>0)\\n            val+=(board.get(start).charAt(end)-\\'0\\');\\n        \\n        val%=mod;\\n        path%=mod;\\n        \\n        dp[start][end]=new data(val,path);\\n        return dp[start][end];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long mod=(long)(1e9+7);\\n    int n,m;\\n    \\n    class data\\n    {\\n        long val=0;\\n        long path=0;\\n        \\n        data(long val,long path)\\n        {\\n            this.val=val;\\n            this.path=path;\\n        }\\n    }\\n    public int[] pathsWithMaxScore(List<String> board) \\n    {\\n        n=board.size();\\n        m=board.get(0).length();\\n        \\n        data dp[][]=new data[n][m];\\n        \\n        data ans=helper(board,dp,0,0);\\n\\n        int val=ans.val<0?0:(int)ans.val;\\n        int path=ans.val<0?0:(int)ans.path;\\n        return new int[]{val,path};\\n    }\\n    \\n    private data helper(List<String>board,data dp[][],int start,int end)\\n    {\\n        if(start==n-1&&end==m-1)\\n            return new data(0,1);\\n        \\n        if(start>=n||end>=m||board.get(start).charAt(end)==\\'X\\')\\n            return new data(Integer.MIN_VALUE,0);\\n        \\n        if(dp[start][end]!=null)\\n            return dp[start][end];\\n        \\n        data val1=helper(board,dp,start+1,end);\\n        data val2=helper(board,dp,start+1,end+1);\\n        data val3=helper(board,dp,start,end+1);\\n        \\n        long val=Math.max(val1.val,Math.max(val2.val,val3.val));\\n        \\n        int path=0;\\n        if(val>=0)\\n        {\\n            if(val==val1.val)\\n                path+=val1.path;\\n            \\n            if(val==val2.val)\\n                path+=val2.path;\\n            \\n            if(val==val3.val)\\n                path+=val3.path;\\n        }\\n        \\n        if(start>0||end>0)\\n            val+=(board.get(start).charAt(end)-\\'0\\');\\n        \\n        val%=mod;\\n        path%=mod;\\n        \\n        dp[start][end]=new data(val,path);\\n        return dp[start][end];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 728894,
                "title": "python-easy",
                "content": "```\\ndef f(x,ci,cj,v,m,n,c,di):\\n    global found\\n    if ci==0 and cj==0:\\n        global found\\n        found=True\\n        return [0,1]\\n    tu=(ci,cj)\\n    if tu in di:\\n        return di[tu]\\n    a=-math.inf\\n    b=0\\n    for d,e in [[ci-1,cj-1],[ci,cj-1],[ci-1,cj]]:\\n        #d=ci+d;e=cj+e\\n        if d>=0 and e>=0 and d<m and e<n and v[d][e]==0 and x[d][e]!=\\'X\\':\\n            v[d][e]=1\\n            qqq=f(x,d,e,v,m,n,c+int(x[d][e]),di)\\n            z=int(x[d][e])+qqq[0]\\n            if z>a:\\n                a=z\\n                b=qqq[1]\\n            elif z==a:\\n                b+=qqq[1]\\n            v[d][e]=0\\n    di[tu]=[a,b]\\n    return [a,b]\\nfound=False\\nclass Solution:\\n    def pathsWithMaxScore(self, x: List[str]) -> List[int]:\\n        global found;found=False\\n        global ma;ma=0\\n        m=len(x)\\n        n=len(x[0])\\n        x=[list(i) for i in x]\\n        x[-1][-1]=0\\n        v=[[0 for i in range(n)] for j in range(m)]\\n        x[0][0]=0\\n        v[-1][-1]=1\\n        di={}\\n        ans=f(x,m-1,n-1,v,m,n,0,di)\\n        if not found:return [0,0]\\n        return [ans[0],ans[1]%(10**9+7)]\\n```",
                "solutionTags": [],
                "code": "```\\ndef f(x,ci,cj,v,m,n,c,di):\\n    global found\\n    if ci==0 and cj==0:\\n        global found\\n        found=True\\n        return [0,1]\\n    tu=(ci,cj)\\n    if tu in di:\\n        return di[tu]\\n    a=-math.inf\\n    b=0\\n    for d,e in [[ci-1,cj-1],[ci,cj-1],[ci-1,cj]]:\\n        #d=ci+d;e=cj+e\\n        if d>=0 and e>=0 and d<m and e<n and v[d][e]==0 and x[d][e]!=\\'X\\':\\n            v[d][e]=1\\n            qqq=f(x,d,e,v,m,n,c+int(x[d][e]),di)\\n            z=int(x[d][e])+qqq[0]\\n            if z>a:\\n                a=z\\n                b=qqq[1]\\n            elif z==a:\\n                b+=qqq[1]\\n            v[d][e]=0\\n    di[tu]=[a,b]\\n    return [a,b]\\nfound=False\\nclass Solution:\\n    def pathsWithMaxScore(self, x: List[str]) -> List[int]:\\n        global found;found=False\\n        global ma;ma=0\\n        m=len(x)\\n        n=len(x[0])\\n        x=[list(i) for i in x]\\n        x[-1][-1]=0\\n        v=[[0 for i in range(n)] for j in range(m)]\\n        x[0][0]=0\\n        v[-1][-1]=1\\n        di={}\\n        ans=f(x,m-1,n-1,v,m,n,0,di)\\n        if not found:return [0,0]\\n        return [ans[0],ans[1]%(10**9+7)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717095,
                "title": "c-simple-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int n = board.size(), m = board[0].size(), j, mod = 1e9 + 7;\\n        vector<vector<int>> val(n, vector<int>(m)), times(n, vector<int>(m)), dirs = {{0,-1},{-1,0},{-1,-1}};\\n        times[n-1][m-1] = 1;\\n        for (int sum = n + m - 2; sum; sum--)\\n            for (int i = n-1; i >= 0; i--)\\n            {\\n                if (sum < i || sum - i >= m) continue;\\n                j = sum - i;\\n                if (board[i][j] == \\'X\\' || !times[i][j]) continue;\\n                for (vector<int>& d : dirs)\\n                {\\n                    int tmpi = i + d[0], tmpj = j + d[1];\\n                    if (tmpi < 0 || tmpj < 0 || board[tmpi][tmpj] == \\'X\\') continue;\\n                    int currval = val[i][j] + (board[tmpi][tmpj] == \\'E\\' ? 0 : (board[tmpi][tmpj] - \\'0\\'));\\n                    if (currval == val[tmpi][tmpj]) times[tmpi][tmpj] = (times[tmpi][tmpj] + times[i][j]) % mod;\\n                    else if (currval > val[tmpi][tmpj])\\n                    {\\n                        val[tmpi][tmpj] = currval;\\n                        times[tmpi][tmpj] = times[i][j];\\n                    }\\n                }\\n            }\\n        return {val[0][0], times[0][0]};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int n = board.size(), m = board[0].size(), j, mod = 1e9 + 7;\\n        vector<vector<int>> val(n, vector<int>(m)), times(n, vector<int>(m)), dirs = {{0,-1},{-1,0},{-1,-1}};\\n        times[n-1][m-1] = 1;\\n        for (int sum = n + m - 2; sum; sum--)\\n            for (int i = n-1; i >= 0; i--)\\n            {\\n                if (sum < i || sum - i >= m) continue;\\n                j = sum - i;\\n                if (board[i][j] == \\'X\\' || !times[i][j]) continue;\\n                for (vector<int>& d : dirs)\\n                {\\n                    int tmpi = i + d[0], tmpj = j + d[1];\\n                    if (tmpi < 0 || tmpj < 0 || board[tmpi][tmpj] == \\'X\\') continue;\\n                    int currval = val[i][j] + (board[tmpi][tmpj] == \\'E\\' ? 0 : (board[tmpi][tmpj] - \\'0\\'));\\n                    if (currval == val[tmpi][tmpj]) times[tmpi][tmpj] = (times[tmpi][tmpj] + times[i][j]) % mod;\\n                    else if (currval > val[tmpi][tmpj])\\n                    {\\n                        val[tmpi][tmpj] = currval;\\n                        times[tmpi][tmpj] = times[i][j];\\n                    }\\n                }\\n            }\\n        return {val[0][0], times[0][0]};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693836,
                "title": "a-simple-python-solution-accepted",
                "content": "```\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        mod=10**9+7\\n        dp1=[[0]*len(board[0]) for i in range(len(board))]\\n        dp2=[[0]*len(board[0]) for i in range(len(board))]\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j]==\\'E\\':\\n                    dp1[i][j]=0\\n                    dp2[i][j]=1\\n                    continue\\n                if board[i][j]!=\\'X\\':\\n                    s1=dp1[i-1][j] if i-1>=0 and dp1[i-1][j]>=0 else -1\\n                    s2=dp1[i][j-1] if j-1>=0 and dp1[i][j-1]>=0 else -1\\n                    s3=dp1[i-1][j-1] if i-1>=0 and j-1>=0 and dp1[i-1][j-1]>=0 else -1\\n                    if s1==-1 and s2==-1 and s3==-1:\\n                        dp1[i][j]=-1\\n                        dp2[i][j]=0\\n                    else:\\n                        dp1[i][j]=int(board[i][j]) if board[i][j]!=\\'S\\' else 0\\n                        s=max(s1,s2,s3)\\n                        arr=[dp2[i-1][j],dp2[i][j-1],dp2[i-1][j-1]]\\n                        dp1[i][j]=(s+dp1[i][j])%mod\\n                        \\n                        for k,v in enumerate([s1,s2,s3]):\\n                            if v==s:\\n                                dp2[i][j]=(dp2[i][j]+arr[k])%mod\\n                else:\\n                    dp1[i][j]=-1\\n                    dp2[i][j]=0\\n        return [dp1[-1][-1] if dp1[-1][-1]>-1 else 0,dp2[-1][-1]]\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def pathsWithMaxScore(self, board: List[str]) -> List[int]:\\n        mod=10**9+7\\n        dp1=[[0]*len(board[0]) for i in range(len(board))]\\n        dp2=[[0]*len(board[0]) for i in range(len(board))]\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j]==\\'E\\':\\n                    dp1[i][j]=0\\n                    dp2[i][j]=1\\n                    continue\\n                if board[i][j]!=\\'X\\':\\n                    s1=dp1[i-1][j] if i-1>=0 and dp1[i-1][j]>=0 else -1\\n                    s2=dp1[i][j-1] if j-1>=0 and dp1[i][j-1]>=0 else -1\\n                    s3=dp1[i-1][j-1] if i-1>=0 and j-1>=0 and dp1[i-1][j-1]>=0 else -1\\n                    if s1==-1 and s2==-1 and s3==-1:\\n                        dp1[i][j]=-1\\n                        dp2[i][j]=0\\n                    else:\\n                        dp1[i][j]=int(board[i][j]) if board[i][j]!=\\'S\\' else 0\\n                        s=max(s1,s2,s3)\\n                        arr=[dp2[i-1][j],dp2[i][j-1],dp2[i-1][j-1]]\\n                        dp1[i][j]=(s+dp1[i][j])%mod\\n                        \\n                        for k,v in enumerate([s1,s2,s3]):\\n                            if v==s:\\n                                dp2[i][j]=(dp2[i][j]+arr[k])%mod\\n                else:\\n                    dp1[i][j]=-1\\n                    dp2[i][j]=0\\n        return [dp1[-1][-1] if dp1[-1][-1]>-1 else 0,dp2[-1][-1]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 671003,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        vector<int>v;\\n        vector<vector<vector<int>>>dp(board.size(),vector<vector<int>>(board[0].size(),vector<int>(3))); //[sum,number of val,can pass]\\n        int r=board.size();\\n        int c=board[0].size();\\n        dp[r-1][c-1][2]=1;\\n        dp[r-1][c-1][1]=1;\\n        board[0][0]=\\'0\\';//modify to 0, without any affect\\n        for(int i=c-2;i>=0;i--){\\n            if(board[r-1][i]==\\'X\\'){\\n                dp[r-1][i][2]=0;//can not pass\\n            }else{\\n                if(dp[r-1][i+1][2]==0){//nothing can pass\\n                     dp[r-1][i][2]=0;\\n                }else{\\n                     dp[r-1][i][2]=1;//can pass\\n                     dp[r-1][i][1]=1;\\n                     dp[r-1][i][0]=dp[r-1][i+1][0]+(board[r-1][i]-\\'0\\');\\n                }\\n            }\\n        }\\n        for(int i=r-2;i>=0;i--){\\n            for(int j=c-1;j>=0;j--){//3 case\\n                if(board[i][j]==\\'X\\'){\\n                    dp[i][j][2]=0;\\n                }else{\\n                    int M=INT_MIN;\\n                    vector<pair<int,int>>v;\\n                    if(inrange(board,i+1,j)&&dp[i+1][j][2]==1){\\n                        M=max(M,dp[i+1][j][0]);\\n                        v.push_back({dp[i+1][j][0],dp[i+1][j][1]});\\n                    }\\n                    if(inrange(board,i+1,j+1)&&dp[i+1][j+1][2]==1){\\n                        M=max(M,dp[i+1][j+1][0]);\\n                        v.push_back({dp[i+1][j+1][0],dp[i+1][j+1][1]});\\n                    }\\n                    if(inrange(board,i,j+1)&&dp[i][j+1][2]==1){\\n                        M=max(M,dp[i][j+1][0]);\\n                        v.push_back({dp[i][j+1][0],dp[i][j+1][1]});\\n                    }\\n                    if(v.size()==0){\\n                        dp[i][j][2]=0;\\n                    }else{\\n                        dp[i][j][0]=M+(board[i][j]-\\'0\\');\\n                        dp[i][j][2]=1;\\n                        for(pair<int,int>p:v){\\n                            if(p.first==M){\\n                                dp[i][j][1]+=p.second;\\n                                dp[i][j][1]%=mod;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(dp[0][0][2]==1){\\n            v.push_back(dp[0][0][0]);\\n            v.push_back(dp[0][0][1]);\\n        }else{\\n            v.push_back(0);v.push_back(0);\\n        }\\n        return v;\\n    }\\n    \\n    bool inrange(vector<string>& board,int r,int c){\\n        if(r<0||c<0||r>=board.size()||c>=board[0].size())return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=1000000007;\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        vector<int>v;\\n        vector<vector<vector<int>>>dp(board.size(),vector<vector<int>>(board[0].size(),vector<int>(3))); //[sum,number of val,can pass]\\n        int r=board.size();\\n        int c=board[0].size();\\n        dp[r-1][c-1][2]=1;\\n        dp[r-1][c-1][1]=1;\\n        board[0][0]=\\'0\\';//modify to 0, without any affect\\n        for(int i=c-2;i>=0;i--){\\n            if(board[r-1][i]==\\'X\\'){\\n                dp[r-1][i][2]=0;//can not pass\\n            }else{\\n                if(dp[r-1][i+1][2]==0){//nothing can pass\\n                     dp[r-1][i][2]=0;\\n                }else{\\n                     dp[r-1][i][2]=1;//can pass\\n                     dp[r-1][i][1]=1;\\n                     dp[r-1][i][0]=dp[r-1][i+1][0]+(board[r-1][i]-\\'0\\');\\n                }\\n            }\\n        }\\n        for(int i=r-2;i>=0;i--){\\n            for(int j=c-1;j>=0;j--){//3 case\\n                if(board[i][j]==\\'X\\'){\\n                    dp[i][j][2]=0;\\n                }else{\\n                    int M=INT_MIN;\\n                    vector<pair<int,int>>v;\\n                    if(inrange(board,i+1,j)&&dp[i+1][j][2]==1){\\n                        M=max(M,dp[i+1][j][0]);\\n                        v.push_back({dp[i+1][j][0],dp[i+1][j][1]});\\n                    }\\n                    if(inrange(board,i+1,j+1)&&dp[i+1][j+1][2]==1){\\n                        M=max(M,dp[i+1][j+1][0]);\\n                        v.push_back({dp[i+1][j+1][0],dp[i+1][j+1][1]});\\n                    }\\n                    if(inrange(board,i,j+1)&&dp[i][j+1][2]==1){\\n                        M=max(M,dp[i][j+1][0]);\\n                        v.push_back({dp[i][j+1][0],dp[i][j+1][1]});\\n                    }\\n                    if(v.size()==0){\\n                        dp[i][j][2]=0;\\n                    }else{\\n                        dp[i][j][0]=M+(board[i][j]-\\'0\\');\\n                        dp[i][j][2]=1;\\n                        for(pair<int,int>p:v){\\n                            if(p.first==M){\\n                                dp[i][j][1]+=p.second;\\n                                dp[i][j][1]%=mod;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(dp[0][0][2]==1){\\n            v.push_back(dp[0][0][0]);\\n            v.push_back(dp[0][0][1]);\\n        }else{\\n            v.push_back(0);v.push_back(0);\\n        }\\n        return v;\\n    }\\n    \\n    bool inrange(vector<string>& board,int r,int c){\\n        if(r<0||c<0||r>=board.size()||c>=board[0].size())return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 669418,
                "title": "easy-to-understand-top-down-dp-with-memorization-solution-in-python",
                "content": "```\\nclass Solution(object):\\n    def traverse(self, board, x, y, hm):\\n        if x < 0 or x >= len(board) or y < 0 or y >= len(board[0]) or board[x][y] == \\'X\\':\\n            return [-1,0]\\n        if x == 0 and y == 0:\\n            return [0,1]\\n        \\n        hash_key = str(x) + \\'#\\' + str(y)\\n        if hash_key in hm:\\n            return hm[hash_key]\\n        left_res =  self.traverse(board, x, y - 1, hm)\\n        up_res =  self.traverse(board, x - 1, y, hm)\\n        dig_res =  self.traverse(board, x - 1, y - 1, hm)\\n        \\n        max_num_collected = max(left_res[0], max(up_res[0], dig_res[0]))\\n        if max_num_collected == -1:\\n            hm[hash_key] =  [-1, 0]\\n            return hm[hash_key]\\n        cur_collected = int(board[x][y]) if board[x][y] != \\'S\\' else 0 \\n        \\n        path_count = 0\\n        if left_res[0] == max_num_collected:\\n            path_count += left_res[1]\\n        if up_res[0] == max_num_collected:\\n            path_count += up_res[1]\\n        if dig_res[0] == max_num_collected:\\n            path_count += dig_res[1]\\n        \\n        hm[hash_key] = [cur_collected + max_num_collected, path_count % (10** 9 + 7)]\\n        return hm[hash_key]\\n       \\n        \\n    def pathsWithMaxScore(self, board):\\n        \"\"\"\\n        :type board: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        tmp = self.traverse(board, len(board) -1, len(board[0]) - 1, {}) \\n        return tmp if tmp != [-1, 0] else [0,0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def traverse(self, board, x, y, hm):\\n        if x < 0 or x >= len(board) or y < 0 or y >= len(board[0]) or board[x][y] == \\'X\\':\\n            return [-1,0]\\n        if x == 0 and y == 0:\\n            return [0,1]\\n        \\n        hash_key = str(x) + \\'#\\' + str(y)\\n        if hash_key in hm:\\n            return hm[hash_key]\\n        left_res =  self.traverse(board, x, y - 1, hm)\\n        up_res =  self.traverse(board, x - 1, y, hm)\\n        dig_res =  self.traverse(board, x - 1, y - 1, hm)\\n        \\n        max_num_collected = max(left_res[0], max(up_res[0], dig_res[0]))\\n        if max_num_collected == -1:\\n            hm[hash_key] =  [-1, 0]\\n            return hm[hash_key]\\n        cur_collected = int(board[x][y]) if board[x][y] != \\'S\\' else 0 \\n        \\n        path_count = 0\\n        if left_res[0] == max_num_collected:\\n            path_count += left_res[1]\\n        if up_res[0] == max_num_collected:\\n            path_count += up_res[1]\\n        if dig_res[0] == max_num_collected:\\n            path_count += dig_res[1]\\n        \\n        hm[hash_key] = [cur_collected + max_num_collected, path_count % (10** 9 + 7)]\\n        return hm[hash_key]\\n       \\n        \\n    def pathsWithMaxScore(self, board):\\n        \"\"\"\\n        :type board: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        tmp = self.traverse(board, len(board) -1, len(board[0]) - 1, {}) \\n        return tmp if tmp != [-1, 0] else [0,0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661011,
                "title": "c-dp-bottom-up-solution",
                "content": "```\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int n = board.size();\\n        vector<vector<pair<int, int>>> dp(n + 1, vector<pair<int, int>>(n+1, {0, 1}));\\n        \\n        for (int i = 0; i <= n; i++)\\n            dp[i][n].first = dp[n][i].first = -1;\\n        \\n        for (int i = n-1; i >= 0; i--) {\\n            for (int j = n-1; j >= 0; j--) {\\n                char digit = board[i][j];\\n                dp[i][j] = calculate(dp, digit, i, j);\\n            }\\n        }\\n        \\n        if (dp[0][0].first < 0)\\n            return {0, 0};\\n        \\n        return { dp[0][0].first, dp[0][0].second };\\n    }\\n\\nprivate:\\n    pair<int, int> calculate(const vector<vector<pair<int, int>>> &dp, char digit, int y, int x) {\\n        int value;\\n        if (digit == \\'E\\') {\\n            value = 0;\\n        } else if (digit >= \\'0\\' && digit <= \\'9\\') {\\n            value = digit - \\'0\\';\\n        } else {\\n            return { digit == \\'S\\' ? 0 : -1, 1 };\\n        }\\n        \\n        pair<int, int> current = {-1, 0};\\n        for (int i = 0; i <= 1; i++) {\\n            for (int j = 0; j <= 1; j++) {\\n                int total = dp[y+i][x+j].first;\\n                int counter = dp[y+i][x+j].second;\\n                \\n                if (total < 0)\\n                    continue;\\n                \\n                if (i == 0 && j == 0)\\n                    continue;\\n                \\n                if (total > current.first)\\n                    current = { total, 0 };\\n                \\n                if (total == current.first)\\n                    current.second = (current.second + counter) % mod;\\n            }\\n        }\\n        \\n        if (current.first < 0)\\n            return current;\\n        \\n        current.first += value;\\n        return current;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define mod 1000000007\\n\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int n = board.size();\\n        vector<vector<pair<int, int>>> dp(n + 1, vector<pair<int, int>>(n+1, {0, 1}));\\n        \\n        for (int i = 0; i <= n; i++)\\n            dp[i][n].first = dp[n][i].first = -1;\\n        \\n        for (int i = n-1; i >= 0; i--) {\\n            for (int j = n-1; j >= 0; j--) {\\n                char digit = board[i][j];\\n                dp[i][j] = calculate(dp, digit, i, j);\\n            }\\n        }\\n        \\n        if (dp[0][0].first < 0)\\n            return {0, 0};\\n        \\n        return { dp[0][0].first, dp[0][0].second };\\n    }\\n\\nprivate:\\n    pair<int, int> calculate(const vector<vector<pair<int, int>>> &dp, char digit, int y, int x) {\\n        int value;\\n        if (digit == \\'E\\') {\\n            value = 0;\\n        } else if (digit >= \\'0\\' && digit <= \\'9\\') {\\n            value = digit - \\'0\\';\\n        } else {\\n            return { digit == \\'S\\' ? 0 : -1, 1 };\\n        }\\n        \\n        pair<int, int> current = {-1, 0};\\n        for (int i = 0; i <= 1; i++) {\\n            for (int j = 0; j <= 1; j++) {\\n                int total = dp[y+i][x+j].first;\\n                int counter = dp[y+i][x+j].second;\\n                \\n                if (total < 0)\\n                    continue;\\n                \\n                if (i == 0 && j == 0)\\n                    continue;\\n                \\n                if (total > current.first)\\n                    current = { total, 0 };\\n                \\n                if (total == current.first)\\n                    current.second = (current.second + counter) % mod;\\n            }\\n        }\\n        \\n        if (current.first < 0)\\n            return current;\\n        \\n        current.first += value;\\n        return current;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653283,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\n    vector<int> pathsWithMaxScore(vector<string>& board){\\n        int m=board.size();\\n        if(m==0)\\n            return{0,0};\\n        ll mod=1e9+7;\\n        int n=board[0].size();\\n        vector<vector<ll>> dpsum(m,vector<ll>(n)),dppath(m,vector<ll>(n));\\n        for(int i=n-2;i>=0;i--){\\n            if(board[m-1][i]==\\'X\\')\\n                break;\\n            dpsum[m-1][i]+=dpsum[m-1][i+1]+board[m-1][i]-\\'0\\';\\n            dppath[m-1][i]=1;\\n        }\\n        for(int i=m-2;i>=0;i--){\\n            if(board[i][n-1]==\\'X\\')\\n                break;\\n            dpsum[i][n-1]+=dpsum[i+1][n-1]+board[i][n-1]-\\'0\\';\\n            dppath[i][n-1]=1;\\n        }\\n        \\n        for(int i=m-2;i>=0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                if(board[i][j]==\\'X\\')\\n                    continue;\\n                ll maxm=max(dpsum[i+1][j],max(dpsum[i+1][j+1],dpsum[i][j+1]));\\n                    if(maxm==0){\\n                        if(i==m-2 && j==n-2)\\n                            dppath[i][j]=1,dpsum[i][j]=(board[i][j]==\\'E\\')?0:board[i][j]-\\'0\\';\\n                        continue;\\n                    }\\n                else dpsum[i][j]=(maxm+(board[i][j]-\\'0\\'))%mod;\\n                if(i==0 && j==0)\\n                    dpsum[i][j]=maxm%mod;\\n                if(dpsum[i][j+1]==maxm)\\n                    dppath[i][j]=(dppath[i][j]+dppath[i][j+1])%mod;\\n                if(dpsum[i+1][j+1]==maxm)\\n                    dppath[i][j]=(dppath[i][j]+dppath[i+1][j+1])%mod;\\n                if(dpsum[i+1][j]==maxm)\\n                    dppath[i][j]=(dppath[i][j]+dppath[i+1][j])%mod;\\n            }\\n        }\\n        return {(int)dpsum[0][0],(int)dppath[0][0]};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\n    vector<int> pathsWithMaxScore(vector<string>& board){\\n        int m=board.size();\\n        if(m==0)\\n            return{0,0};\\n        ll mod=1e9+7;\\n        int n=board[0].size();\\n        vector<vector<ll>> dpsum(m,vector<ll>(n)),dppath(m,vector<ll>(n));\\n        for(int i=n-2;i>=0;i--){\\n            if(board[m-1][i]==\\'X\\')\\n                break;\\n            dpsum[m-1][i]+=dpsum[m-1][i+1]+board[m-1][i]-\\'0\\';\\n            dppath[m-1][i]=1;\\n        }\\n        for(int i=m-2;i>=0;i--){\\n            if(board[i][n-1]==\\'X\\')\\n                break;\\n            dpsum[i][n-1]+=dpsum[i+1][n-1]+board[i][n-1]-\\'0\\';\\n            dppath[i][n-1]=1;\\n        }\\n        \\n        for(int i=m-2;i>=0;i--){\\n            for(int j=n-2;j>=0;j--){\\n                if(board[i][j]==\\'X\\')\\n                    continue;\\n                ll maxm=max(dpsum[i+1][j],max(dpsum[i+1][j+1],dpsum[i][j+1]));\\n                    if(maxm==0){\\n                        if(i==m-2 && j==n-2)\\n                            dppath[i][j]=1,dpsum[i][j]=(board[i][j]==\\'E\\')?0:board[i][j]-\\'0\\';\\n                        continue;\\n                    }\\n                else dpsum[i][j]=(maxm+(board[i][j]-\\'0\\'))%mod;\\n                if(i==0 && j==0)\\n                    dpsum[i][j]=maxm%mod;\\n                if(dpsum[i][j+1]==maxm)\\n                    dppath[i][j]=(dppath[i][j]+dppath[i][j+1])%mod;\\n                if(dpsum[i+1][j+1]==maxm)\\n                    dppath[i][j]=(dppath[i][j]+dppath[i+1][j+1])%mod;\\n                if(dpsum[i+1][j]==maxm)\\n                    dppath[i][j]=(dppath[i][j]+dppath[i+1][j])%mod;\\n            }\\n        }\\n        return {(int)dpsum[0][0],(int)dppath[0][0]};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 640930,
                "title": "c-dp-clean-concise-bottom-up-commented-must-see",
                "content": "The idea is simple, we have to maintain 2 dp tables, one for maximum value and other for number of paths from a given state. Let\\'s call them dp and paths respectively now, the recurrence relation is dp[i][j] = board[i][j] + max( dp[i+1][j], dp[i][j+1], dp[i+1][j+1] ) and paths[i][j] = sum of paths having the maximum value. \\n\\n\\n\\n```\\nint const mod = 1e9 +7;\\n\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        \\n        int n = board.size(), m = board[0].size();\\n        \\n        int dp[n+1][m+1];\\n        int paths[n+1][m+1];\\n        \\n        memset(paths, 0, sizeof paths);\\n        \\n        // Initializing to -infinity\\n        for(int i=0;i<=n;i++)\\n            for(int j=0;j<=m;j++)dp[i][j] = -10000000;\\n        // -----------------------------------\\n        \\n        \\n        // Updating for convenience\\n        board[0][0] = \\'0\\';\\n        board[n-1][m-1] = \\'0\\';\\n        //---------------------\\n        \\n        \\n        // Base cases \\n        \\n        dp[n][m] = 0;\\n        dp[n][m-1] = 0;\\n        dp[n-1][m] = 0;\\n        paths[n][m] = 1;\\n        \\n        // ---------      \\n        \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n\\n                if(board[i][j] == \\'X\\')continue;\\n                dp[i][j] = board[i][j] - \\'0\\';\\n                \\n                int maxval = max(dp[i+1][j], max(dp[i][j+1], dp[i+1][j+1]));\\n                dp[i][j] += maxval;                \\n                \\n                if(dp[i][j+1] == maxval)paths[i][j]+=paths[i][j+1];\\n                if(dp[i+1][j] == maxval)paths[i][j]+=paths[i+1][j];\\n                if(dp[i+1][j+1] == maxval)paths[i][j]+=paths[i+1][j+1];\\n                \\n                paths[i][j] %= mod;\\n\\n            }\\n        }\\n                \\n        \\n        if(dp[0][0]<0)return {0,0};\\n        \\n        return {dp[0][0], paths[0][0]};\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint const mod = 1e9 +7;\\n\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        \\n        int n = board.size(), m = board[0].size();\\n        \\n        int dp[n+1][m+1];\\n        int paths[n+1][m+1];\\n        \\n        memset(paths, 0, sizeof paths);\\n        \\n        // Initializing to -infinity\\n        for(int i=0;i<=n;i++)\\n            for(int j=0;j<=m;j++)dp[i][j] = -10000000;\\n        // -----------------------------------\\n        \\n        \\n        // Updating for convenience\\n        board[0][0] = \\'0\\';\\n        board[n-1][m-1] = \\'0\\';\\n        //---------------------\\n        \\n        \\n        // Base cases \\n        \\n        dp[n][m] = 0;\\n        dp[n][m-1] = 0;\\n        dp[n-1][m] = 0;\\n        paths[n][m] = 1;\\n        \\n        // ---------      \\n        \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n\\n                if(board[i][j] == \\'X\\')continue;\\n                dp[i][j] = board[i][j] - \\'0\\';\\n                \\n                int maxval = max(dp[i+1][j], max(dp[i][j+1], dp[i+1][j+1]));\\n                dp[i][j] += maxval;                \\n                \\n                if(dp[i][j+1] == maxval)paths[i][j]+=paths[i][j+1];\\n                if(dp[i+1][j] == maxval)paths[i][j]+=paths[i+1][j];\\n                if(dp[i+1][j+1] == maxval)paths[i][j]+=paths[i+1][j+1];\\n                \\n                paths[i][j] %= mod;\\n\\n            }\\n        }\\n                \\n        \\n        if(dp[0][0]<0)return {0,0};\\n        \\n        return {dp[0][0], paths[0][0]};\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 626820,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n\\tpublic int[] pathsWithMaxScore(List<String> board) {\\n\\t\\tint[] ans = new int[2];\\n\\t\\tint[][] dp = new int[board.size()][board.get(0).length()];\\n\\t\\tlong[][] paths = new long[board.size()][board.get(0).length()];\\n\\t\\tint[][] dirs = { { 1, 0 }, { 0, 1 }, { 1, 1 } };\\n\\t\\tpaths[board.size() - 1][board.get(0).length() - 1] = 1;\\n\\t\\tfor (int i = board.size() - 1; i >= 0; i--) {\\n\\t\\t\\tfor (int j = board.get(0).length() - 1; j >= 0; j--) {\\n\\t\\t\\t\\tchar c = board.get(i).charAt(j);\\n\\t\\t\\t\\tif (c == \\'X\\' || c == \\'S\\') {\\n\\t\\t\\t\\t\\tdp[i][j] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint val = c == \\'E\\' ? 0 : Character.getNumericValue(c);\\n\\t\\t\\t\\tfor (int[] dir : dirs) {\\n\\t\\t\\t\\t\\tint ii = i + dir[0], jj = j + dir[1];\\n\\t\\t\\t\\t\\tif (ii < board.size() && jj < board.size() && board.get(ii).charAt(jj) != \\'X\\') {\\n\\t\\t\\t\\t\\t\\tdp[i][j] = Math.max(dp[i][j], val + dp[ii][jj]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor (int[] dir : dirs) {\\n\\t\\t\\t\\t\\tint ii = i + dir[0], jj = j + dir[1];\\n\\t\\t\\t\\t\\tif (ii < board.size() && jj < board.size() && board.get(ii).charAt(jj) != \\'X\\') {\\n\\t\\t\\t\\t\\t\\tif (dp[ii][jj] == dp[i][j] - val) {\\n\\t\\t\\t\\t\\t\\t\\tpaths[i][j] += paths[ii][jj];\\n\\t\\t\\t\\t\\t\\t\\tpaths[i][j] %= (1e9 + 7);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tans[0] = dp[0][0];\\n\\t\\tans[1] = (int) (paths[0][0] % (1e9 + 7));\\n\\t\\treturn ans[1] == 0 ? new int[] { 0, 0 } : ans;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tpublic int[] pathsWithMaxScore(List<String> board) {\\n\\t\\tint[] ans = new int[2];\\n\\t\\tint[][] dp = new int[board.size()][board.get(0).length()];\\n\\t\\tlong[][] paths = new long[board.size()][board.get(0).length()];\\n\\t\\tint[][] dirs = { { 1, 0 }, { 0, 1 }, { 1, 1 } };\\n\\t\\tpaths[board.size() - 1][board.get(0).length() - 1] = 1;\\n\\t\\tfor (int i = board.size() - 1; i >= 0; i--) {\\n\\t\\t\\tfor (int j = board.get(0).length() - 1; j >= 0; j--) {\\n\\t\\t\\t\\tchar c = board.get(i).charAt(j);\\n\\t\\t\\t\\tif (c == \\'X\\' || c == \\'S\\') {\\n\\t\\t\\t\\t\\tdp[i][j] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint val = c == \\'E\\' ? 0 : Character.getNumericValue(c);\\n\\t\\t\\t\\tfor (int[] dir : dirs) {\\n\\t\\t\\t\\t\\tint ii = i + dir[0], jj = j + dir[1];\\n\\t\\t\\t\\t\\tif (ii < board.size() && jj < board.size() && board.get(ii).charAt(jj) != \\'X\\') {\\n\\t\\t\\t\\t\\t\\tdp[i][j] = Math.max(dp[i][j], val + dp[ii][jj]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor (int[] dir : dirs) {\\n\\t\\t\\t\\t\\tint ii = i + dir[0], jj = j + dir[1];\\n\\t\\t\\t\\t\\tif (ii < board.size() && jj < board.size() && board.get(ii).charAt(jj) != \\'X\\') {\\n\\t\\t\\t\\t\\t\\tif (dp[ii][jj] == dp[i][j] - val) {\\n\\t\\t\\t\\t\\t\\t\\tpaths[i][j] += paths[ii][jj];\\n\\t\\t\\t\\t\\t\\t\\tpaths[i][j] %= (1e9 + 7);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tans[0] = dp[0][0];\\n\\t\\tans[1] = (int) (paths[0][0] % (1e9 + 7));\\n\\t\\treturn ans[1] == 0 ? new int[] { 0, 0 } : ans;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 603593,
                "title": "c-dp-solution-o-mn-time-and-space",
                "content": "```\\n My code is long ,it could be shorter.\\n class Solution {\\npublic:\\n    typedef long long ll;\\n    vector<int> pathsWithMaxScore(vector<string>& board)\\n    {\\n        int m=board.size();\\n        if(m==0)\\n            return{0,0};\\n        ll mod=1e9+7;\\n        int n=board[0].size();\\n        vector<vector<ll>> dpsum(m,vector<ll>(n)),dppath(m,vector<ll>(n));\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(board[m-1][i]==\\'X\\')\\n                break;\\n            dpsum[m-1][i]+=dpsum[m-1][i+1]+board[m-1][i]-\\'0\\';\\n            dppath[m-1][i]=1;\\n        }\\n        for(int i=m-2;i>=0;i--)\\n        {\\n            if(board[i][n-1]==\\'X\\')\\n                break;\\n            dpsum[i][n-1]+=dpsum[i+1][n-1]+board[i][n-1]-\\'0\\';\\n            dppath[i][n-1]=1;\\n        }\\n        \\n        for(int i=m-2;i>=0;i--)\\n        {\\n            for(int j=n-2;j>=0;j--)\\n            {\\n                if(board[i][j]==\\'X\\')\\n                    continue;\\n                ll maxm=max(dpsum[i+1][j],max(dpsum[i+1][j+1],dpsum[i][j+1]));\\n                    if(maxm==0)\\n                    {\\n                        if(i==m-2 && j==n-2)\\n                            dppath[i][j]=1,dpsum[i][j]=(board[i][j]==\\'E\\')?0:board[i][j]-\\'0\\';\\n                        continue;\\n                    }\\n                else dpsum[i][j]=(maxm+(board[i][j]-\\'0\\'))%mod;\\n                if(i==0 && j==0)\\n                    dpsum[i][j]=maxm%mod;\\n                if(dpsum[i][j+1]==maxm)\\n                    dppath[i][j]=(dppath[i][j]+dppath[i][j+1])%mod;\\n                if(dpsum[i+1][j+1]==maxm)\\n                    dppath[i][j]=(dppath[i][j]+dppath[i+1][j+1])%mod;\\n                if(dpsum[i+1][j]==maxm)\\n                    dppath[i][j]=(dppath[i][j]+dppath[i+1][j])%mod;\\n            }\\n        }\\n        return {(int)dpsum[0][0],(int)dppath[0][0]};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n My code is long ,it could be shorter.\\n class Solution {\\npublic:\\n    typedef long long ll;\\n    vector<int> pathsWithMaxScore(vector<string>& board)\\n    {\\n        int m=board.size();\\n        if(m==0)\\n            return{0,0};\\n        ll mod=1e9+7;\\n        int n=board[0].size();\\n        vector<vector<ll>> dpsum(m,vector<ll>(n)),dppath(m,vector<ll>(n));\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(board[m-1][i]==\\'X\\')\\n                break;\\n            dpsum[m-1][i]+=dpsum[m-1][i+1]+board[m-1][i]-\\'0\\';\\n            dppath[m-1][i]=1;\\n        }\\n        for(int i=m-2;i>=0;i--)\\n        {\\n            if(board[i][n-1]==\\'X\\')\\n                break;\\n            dpsum[i][n-1]+=dpsum[i+1][n-1]+board[i][n-1]-\\'0\\';\\n            dppath[i][n-1]=1;\\n        }\\n        \\n        for(int i=m-2;i>=0;i--)\\n        {\\n            for(int j=n-2;j>=0;j--)\\n            {\\n                if(board[i][j]==\\'X\\')\\n                    continue;\\n                ll maxm=max(dpsum[i+1][j],max(dpsum[i+1][j+1],dpsum[i][j+1]));\\n                    if(maxm==0)\\n                    {\\n                        if(i==m-2 && j==n-2)\\n                            dppath[i][j]=1,dpsum[i][j]=(board[i][j]==\\'E\\')?0:board[i][j]-\\'0\\';\\n                        continue;\\n                    }\\n                else dpsum[i][j]=(maxm+(board[i][j]-\\'0\\'))%mod;\\n                if(i==0 && j==0)\\n                    dpsum[i][j]=maxm%mod;\\n                if(dpsum[i][j+1]==maxm)\\n                    dppath[i][j]=(dppath[i][j]+dppath[i][j+1])%mod;\\n                if(dpsum[i+1][j+1]==maxm)\\n                    dppath[i][j]=(dppath[i][j]+dppath[i+1][j+1])%mod;\\n                if(dpsum[i+1][j]==maxm)\\n                    dppath[i][j]=(dppath[i][j]+dppath[i+1][j])%mod;\\n            }\\n        }\\n        return {(int)dpsum[0][0],(int)dppath[0][0]};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598803,
                "title": "easy-dp-16ms-c",
                "content": "```class Solution {\\n    int dp[200][200];\\n    int maxi[200][200];\\n    int mod = 1e9+7;\\npublic:\\n    int n ,m;\\n    vector<string> bo ;\\n    \\n    int solve(int i ,int j){\\n        if(i >=n || j>=m) return 0;\\n        \\n        if(dp[i][j]!= 0){\\n            return dp[i][j];\\n        }\\n        if(bo[i][j] == \\'X\\') return 0;\\n        \\n        \\n        int ans = 0;\\n        \\n        int a = solve(i+1,j);\\n        int b = solve(i,j+1);\\n        int c = solve(i+1,j+1);\\n        int ret = max({a,b,c});\\n        \\n        \\n        int x = ret;\\n        if(x == a){\\n            (maxi[i][j] += maxi[i+1][j])%=mod;\\n        }\\n        if(x == b){\\n            (maxi[i][j] += maxi[i][j+1])%=mod;\\n        }\\n        if(x == c){\\n            (maxi[i][j] +=maxi[i+1][j+1])%=mod;\\n        }\\n        \\n        if(bo[i][j] != \\'E\\' && bo[i][j]!=\\'S\\') ret += bo[i][j] -\\'0\\';\\n        \\n        return dp[i][j] = ret;\\n    }\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        n = board.size();\\n        m = board[0].size();\\n        bo = board;\\n        maxi[n-1][m-1] = 1;\\n        \\n        memset(dp,0,sizeof(dp));\\n        int ans1 = solve(0,0);\\n        int ans2 = maxi[0][0];\\n        \\n        if(ans2 == 0){\\n            return vector<int>({0,0});\\n        }else\\n            return vector<int>({ans1,ans2});\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```class Solution {\\n    int dp[200][200];\\n    int maxi[200][200];\\n    int mod = 1e9+7;\\npublic:\\n    int n ,m;\\n    vector<string> bo ;\\n    \\n    int solve(int i ,int j){\\n        if(i >=n || j>=m) return 0;\\n        \\n        if(dp[i][j]!= 0){\\n            return dp[i][j];\\n        }\\n        if(bo[i][j] == \\'X\\') return 0;\\n        \\n        \\n        int ans = 0;\\n        \\n        int a = solve(i+1,j);\\n        int b = solve(i,j+1);\\n        int c = solve(i+1,j+1);\\n        int ret = max({a,b,c});\\n        \\n        \\n        int x = ret;\\n        if(x == a){\\n            (maxi[i][j] += maxi[i+1][j])%=mod;\\n        }\\n        if(x == b){\\n            (maxi[i][j] += maxi[i][j+1])%=mod;\\n        }\\n        if(x == c){\\n            (maxi[i][j] +=maxi[i+1][j+1])%=mod;\\n        }\\n        \\n        if(bo[i][j] != \\'E\\' && bo[i][j]!=\\'S\\') ret += bo[i][j] -\\'0\\';\\n        \\n        return dp[i][j] = ret;\\n    }\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        n = board.size();\\n        m = board[0].size();\\n        bo = board;\\n        maxi[n-1][m-1] = 1;\\n        \\n        memset(dp,0,sizeof(dp));\\n        int ans1 = solve(0,0);\\n        int ans2 = maxi[0][0];\\n        \\n        if(ans2 == 0){\\n            return vector<int>({0,0});\\n        }else\\n            return vector<int>({ans1,ans2});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 592511,
                "title": "c-easy-to-understand-dp-o-n-2-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int N=board.size();\\n        const int M=1e9+7;\\n        vector<vector<vector<int>>>dp(N,vector<vector<int>>(N, vector<int>(2,0)));\\n        // <maxweight,no of path>\\n        dp[N-1][N-1]={0,1};\\n        for(int i=N-2;i>=0;i--){\\n            //cout<<i<<endl;\\n            if(board[i][N-1]!=\\'X\\'){\\n                int wt=(int)(board[i][N-1]-\\'0\\');\\n                // cout<<board[i][N-1]<<\" \"<<wt<<endl;\\n                dp[i][N-1]={dp[i+1][N-1][0]+wt,1};\\n            }\\n            else\\n                break;\\n        }\\n        for(int i=N-2;i>=0;i--){\\n            if(board[N-1][i]!=\\'X\\'){\\n                int wt=(int)(board[N-1][i]-\\'0\\');\\n                dp[N-1][i]={dp[N-1][i+1][0]+wt,1};\\n            }\\n            else\\n                break;\\n        }\\n        for(int i=N-2;i>=0;i--){\\n            for(int j=N-2;j>=0;j--){\\n                if(board[i][j]==\\'X\\')\\n                    continue;\\n                int wt=0;\\n                if(board[i][j]!=\\'E\\')\\n                    wt=(int)(board[i][j]-\\'0\\');\\n                \\n                int maxtill = max({dp[i+1][j][0]*(dp[i+1][j][1]>0),dp[i][j+1][0]*(dp[i][j+1][1]>0),dp[i+1][j+1][0]*(dp[i+1][j+1][1]>0)});\\n                // cout<<i<<\" \"<<j<<\" \"<<maxtill<<endl;\\n                int maxpathtill=0;\\n                if(maxtill==dp[i+1][j][0])\\n                    maxpathtill+=dp[i+1][j][1];\\n                maxpathtill%=M;\\n                if(maxtill==dp[i][j+1][0])\\n                    maxpathtill+=dp[i][j+1][1];\\n                maxpathtill%=M;\\n                if(maxtill==dp[i+1][j+1][0])\\n                    maxpathtill+=dp[i+1][j+1][1];\\n                maxpathtill%=M;\\n                // cout<<i<<\" \"<<j<<\" \"<<maxtill+wt<<\" \"<<maxpathtill<<endl;\\n                if(maxpathtill==0)\\n                    dp[i][j]={maxtill,maxpathtill};\\n                else\\n                    dp[i][j]={maxtill+wt,maxpathtill};\\n            }\\n        }\\n        /*\\n        for(int i=0;i<N;i++){\\n            for(int j=0;j<N;j++){\\n                cout<<\"(\"<<dp[i][j][0]<<\",\"<<dp[i][j][1]<<\")\"<<\"\\\\t\";\\n            }\\n            cout<<endl;\\n        }\\n        \\n        */\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int N=board.size();\\n        const int M=1e9+7;\\n        vector<vector<vector<int>>>dp(N,vector<vector<int>>(N, vector<int>(2,0)));\\n        // <maxweight,no of path>\\n        dp[N-1][N-1]={0,1};\\n        for(int i=N-2;i>=0;i--){\\n            //cout<<i<<endl;\\n            if(board[i][N-1]!=\\'X\\'){\\n                int wt=(int)(board[i][N-1]-\\'0\\');\\n                // cout<<board[i][N-1]<<\" \"<<wt<<endl;\\n                dp[i][N-1]={dp[i+1][N-1][0]+wt,1};\\n            }\\n            else\\n                break;\\n        }\\n        for(int i=N-2;i>=0;i--){\\n            if(board[N-1][i]!=\\'X\\'){\\n                int wt=(int)(board[N-1][i]-\\'0\\');\\n                dp[N-1][i]={dp[N-1][i+1][0]+wt,1};\\n            }\\n            else\\n                break;\\n        }\\n        for(int i=N-2;i>=0;i--){\\n            for(int j=N-2;j>=0;j--){\\n                if(board[i][j]==\\'X\\')\\n                    continue;\\n                int wt=0;\\n                if(board[i][j]!=\\'E\\')\\n                    wt=(int)(board[i][j]-\\'0\\');\\n                \\n                int maxtill = max({dp[i+1][j][0]*(dp[i+1][j][1]>0),dp[i][j+1][0]*(dp[i][j+1][1]>0),dp[i+1][j+1][0]*(dp[i+1][j+1][1]>0)});\\n                // cout<<i<<\" \"<<j<<\" \"<<maxtill<<endl;\\n                int maxpathtill=0;\\n                if(maxtill==dp[i+1][j][0])\\n                    maxpathtill+=dp[i+1][j][1];\\n                maxpathtill%=M;\\n                if(maxtill==dp[i][j+1][0])\\n                    maxpathtill+=dp[i][j+1][1];\\n                maxpathtill%=M;\\n                if(maxtill==dp[i+1][j+1][0])\\n                    maxpathtill+=dp[i+1][j+1][1];\\n                maxpathtill%=M;\\n                // cout<<i<<\" \"<<j<<\" \"<<maxtill+wt<<\" \"<<maxpathtill<<endl;\\n                if(maxpathtill==0)\\n                    dp[i][j]={maxtill,maxpathtill};\\n                else\\n                    dp[i][j]={maxtill+wt,maxpathtill};\\n            }\\n        }\\n        /*\\n        for(int i=0;i<N;i++){\\n            for(int j=0;j<N;j++){\\n                cout<<\"(\"<<dp[i][j][0]<<\",\"<<dp[i][j][1]<<\")\"<<\"\\\\t\";\\n            }\\n            cout<<endl;\\n        }\\n        \\n        */\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 574807,
                "title": "java-recursion-dp",
                "content": "```\\nclass Solution {\\n    int MOD = 1000000007;\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int i = board.size();\\n        int j = board.get(0).length();\\n        \\n        int[][][] dp = new int[i][j][2];\\n        boolean[][] visited = new boolean[i][j];\\n        \\n        dp[i-1][j-1][1] = 1;\\n        visited[i-1][j-1] = true;\\n        \\n        return helper(dp, board, 0, 0, visited);\\n    }\\n    \\n    private int[] helper(int[][][] dp, List<String> board, int i, int j, boolean[][] visited) {\\n        int[] r = new int[2];\\n        \\n        if (i < 0 || j < 0 || i >= dp.length || j >= dp[0].length || \\n           board.get(i).charAt(j) == \\'X\\')\\n            return r;\\n        \\n        if (visited[i][j])\\n            return dp[i][j];\\n        \\n        int[] a1 = helper(dp, board, i+1, j, visited);\\n        int[] a2 = helper(dp, board, i+1, j+1, visited);\\n        int[] a3 = helper(dp, board, i, j+1, visited);\\n        \\n        r[0] = Math.max(Math.max(a1[0], a2[0]), a3[0]);\\n        if (a1[0] == r[0]) r[1] = (r[1]+ a1[1]) % MOD;\\n        if (a2[0] == r[0]) r[1] = (r[1]+ a2[1]) % MOD;\\n        if (a3[0] == r[0]) r[1] = (r[1]+ a3[1]) % MOD;\\n        \\n        if (board.get(i).charAt(j) != \\'E\\' && r[1] != 0)\\n            r[0] = (r[0] + (board.get(i).charAt(j) - \\'0\\')) % MOD;\\n        \\n        dp[i][j] = r;\\n        visited[i][j] = true;\\n        \\n        return r;\\n            \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int MOD = 1000000007;\\n    public int[] pathsWithMaxScore(List<String> board) {\\n        int i = board.size();\\n        int j = board.get(0).length();\\n        \\n        int[][][] dp = new int[i][j][2];\\n        boolean[][] visited = new boolean[i][j];\\n        \\n        dp[i-1][j-1][1] = 1;\\n        visited[i-1][j-1] = true;\\n        \\n        return helper(dp, board, 0, 0, visited);\\n    }\\n    \\n    private int[] helper(int[][][] dp, List<String> board, int i, int j, boolean[][] visited) {\\n        int[] r = new int[2];\\n        \\n        if (i < 0 || j < 0 || i >= dp.length || j >= dp[0].length || \\n           board.get(i).charAt(j) == \\'X\\')\\n            return r;\\n        \\n        if (visited[i][j])\\n            return dp[i][j];\\n        \\n        int[] a1 = helper(dp, board, i+1, j, visited);\\n        int[] a2 = helper(dp, board, i+1, j+1, visited);\\n        int[] a3 = helper(dp, board, i, j+1, visited);\\n        \\n        r[0] = Math.max(Math.max(a1[0], a2[0]), a3[0]);\\n        if (a1[0] == r[0]) r[1] = (r[1]+ a1[1]) % MOD;\\n        if (a2[0] == r[0]) r[1] = (r[1]+ a2[1]) % MOD;\\n        if (a3[0] == r[0]) r[1] = (r[1]+ a3[1]) % MOD;\\n        \\n        if (board.get(i).charAt(j) != \\'E\\' && r[1] != 0)\\n            r[0] = (r[0] + (board.get(i).charAt(j) - \\'0\\')) % MOD;\\n        \\n        dp[i][j] = r;\\n        visited[i][j] = true;\\n        \\n        return r;\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 560315,
                "title": "c-easy-o-n-2-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int n = board.size();\\n        vector<int> ans;\\n        int mod = pow(10, 9) + 7;\\n        vector<vector<pair<unsigned int, unsigned int>>> dp(n, vector<pair<unsigned int, unsigned int>>(n, make_pair(0, 0)));\\n        for (int j=1; j<n; j++) {\\n            if (board[0][j] == \\'X\\') break;\\n            dp[0][j] = make_pair(dp[0][j-1].first + board[0][j] - \\'0\\', 1);\\n        }\\n        for (int i=1; i<n; i++) {\\n            if (board[i][0] == \\'X\\') break;\\n            dp[i][0] = make_pair(dp[i-1][0].first + board[i][0] - \\'0\\', 1);\\n        }\\n        for (int i=1; i<n; i++) {\\n            for (int j=1; j<n; j++) {\\n                if (board[i][j] == \\'X\\') continue;\\n                unsigned int score = max(dp[i-1][j].first, max(dp[i-1][j-1].first, dp[i][j-1].first));\\n                if (score == 0) {\\n                    if (board[i-1][j-1] == \\'E\\' && board[i][j] == \\'S\\')\\n                        dp[i][j] = make_pair(0, 1);\\n                    else \\n                        continue;\\n                }\\n                else {\\n                    unsigned int paths = 0;\\n                    if (score == dp[i-1][j].first) paths += dp[i-1][j].second;\\n                    if (score == dp[i-1][j-1].first) paths += dp[i-1][j-1].second;\\n                    if (score == dp[i][j-1].first) paths += dp[i][j-1].second;\\n                    score %= mod;\\n                    if (board[i][j] == \\'S\\')\\n                        dp[i][j] = make_pair(score, paths%mod);\\n                    else\\n                        dp[i][j] = make_pair(score + board[i][j] - \\'0\\', paths%mod);\\n                }\\n            }\\n        }\\n        \\n        // Print matrix\\n        /*\\n        for (int i=0; i<n; i++) {\\n            for (int j=0; j<n; j++) {\\n                cout << dp[i][j].first << \",\" << dp[i][j].second << \" \"; \\n            }\\n            cout << endl;\\n        }\\n        */\\n        \\n        ans.push_back(dp[n-1][n-1].first);\\n        ans.push_back(dp[n-1][n-1].second);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        int n = board.size();\\n        vector<int> ans;\\n        int mod = pow(10, 9) + 7;\\n        vector<vector<pair<unsigned int, unsigned int>>> dp(n, vector<pair<unsigned int, unsigned int>>(n, make_pair(0, 0)));\\n        for (int j=1; j<n; j++) {\\n            if (board[0][j] == \\'X\\') break;\\n            dp[0][j] = make_pair(dp[0][j-1].first + board[0][j] - \\'0\\', 1);\\n        }\\n        for (int i=1; i<n; i++) {\\n            if (board[i][0] == \\'X\\') break;\\n            dp[i][0] = make_pair(dp[i-1][0].first + board[i][0] - \\'0\\', 1);\\n        }\\n        for (int i=1; i<n; i++) {\\n            for (int j=1; j<n; j++) {\\n                if (board[i][j] == \\'X\\') continue;\\n                unsigned int score = max(dp[i-1][j].first, max(dp[i-1][j-1].first, dp[i][j-1].first));\\n                if (score == 0) {\\n                    if (board[i-1][j-1] == \\'E\\' && board[i][j] == \\'S\\')\\n                        dp[i][j] = make_pair(0, 1);\\n                    else \\n                        continue;\\n                }\\n                else {\\n                    unsigned int paths = 0;\\n                    if (score == dp[i-1][j].first) paths += dp[i-1][j].second;\\n                    if (score == dp[i-1][j-1].first) paths += dp[i-1][j-1].second;\\n                    if (score == dp[i][j-1].first) paths += dp[i][j-1].second;\\n                    score %= mod;\\n                    if (board[i][j] == \\'S\\')\\n                        dp[i][j] = make_pair(score, paths%mod);\\n                    else\\n                        dp[i][j] = make_pair(score + board[i][j] - \\'0\\', paths%mod);\\n                }\\n            }\\n        }\\n        \\n        // Print matrix\\n        /*\\n        for (int i=0; i<n; i++) {\\n            for (int j=0; j<n; j++) {\\n                cout << dp[i][j].first << \",\" << dp[i][j].second << \" \"; \\n            }\\n            cout << endl;\\n        }\\n        */\\n        \\n        ans.push_back(dp[n-1][n-1].first);\\n        ans.push_back(dp[n-1][n-1].second);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 536731,
                "title": "c-bottom-up-dp-faster-than-98-less-memory-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        \\n        vector<vector<int>>m_path(board.size(), vector<int>(board[0].size(),-1));\\n        vector<vector<int>>n_m_path(board.size(), vector<int>(board[0].size(), 0));\\n        m_path[0][0]=0;\\n        m_path[m_path.size()-1][m_path[0].size()-1]=0;\\n        n_m_path[0][0]=1;\\n        \\n        for(int row=1; row<board.size(); row++){\\n            if(board[row][0]==\\'X\\'||m_path[row-1][0]==-1)\\n                continue;\\n            m_path[row][0]=m_path[row-1][0];\\n            n_m_path[row][0]=n_m_path[row-1][0];\\n            if(board[row][0]!=\\'S\\')\\n                m_path[row][0]=(m_path[row][0]+board[row][0]-\\'0\\')%(1000000000+7);\\n        }\\n        \\n        for(int col=1; col<board[0].size(); col++){\\n            if(board[0][col]==\\'X\\'||m_path[0][col-1]==-1)\\n                continue;\\n            m_path[0][col]=m_path[0][col-1];\\n            n_m_path[0][col]=n_m_path[0][col-1];\\n            if(board[0][col]!=\\'S\\')\\n                m_path[0][col]=(m_path[0][col]+board[0][col]-\\'0\\')%(1000000000+7);\\n        }\\n        \\n        for(int row=1; row<board.size(); row++){\\n            for(int col=1; col<board[0].size(); col++){\\n                int max_=0;\\n                max_=max(max(m_path[row-1][col],m_path[row][col-1]),m_path[row-1][col-1]);\\n                if(max_==-1||board[row][col]==\\'X\\')continue;\\n                m_path[row][col]=max_;\\n                if(board[row][col]!=\\'S\\')\\n                    m_path[row][col]=(m_path[row][col]+board[row][col]-\\'0\\')%(1000000000+7);\\n                if(m_path[row-1][col]==max_)\\n                    n_m_path[row][col]=(n_m_path[row][col]+n_m_path[row-1][col])%(1000000000+7);\\n                if(m_path[row][col-1]==max_)\\n                    n_m_path[row][col]=(n_m_path[row][col]+n_m_path[row][col-1])%(1000000000+7);\\n                if(m_path[row-1][col-1]==max_)\\n                    n_m_path[row][col]=(n_m_path[row][col]+n_m_path[row-1][col-1])%(1000000000+7);\\n            }\\n        }\\n        \\n        vector<int>ret={m_path[m_path.size()-1][m_path[0].size()-1], n_m_path[n_m_path.size()-1][n_m_path[0].size()-1]};\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> pathsWithMaxScore(vector<string>& board) {\\n        \\n        vector<vector<int>>m_path(board.size(), vector<int>(board[0].size(),-1));\\n        vector<vector<int>>n_m_path(board.size(), vector<int>(board[0].size(), 0));\\n        m_path[0][0]=0;\\n        m_path[m_path.size()-1][m_path[0].size()-1]=0;\\n        n_m_path[0][0]=1;\\n        \\n        for(int row=1; row<board.size(); row++){\\n            if(board[row][0]==\\'X\\'||m_path[row-1][0]==-1)\\n                continue;\\n            m_path[row][0]=m_path[row-1][0];\\n            n_m_path[row][0]=n_m_path[row-1][0];\\n            if(board[row][0]!=\\'S\\')\\n                m_path[row][0]=(m_path[row][0]+board[row][0]-\\'0\\')%(1000000000+7);\\n        }\\n        \\n        for(int col=1; col<board[0].size(); col++){\\n            if(board[0][col]==\\'X\\'||m_path[0][col-1]==-1)\\n                continue;\\n            m_path[0][col]=m_path[0][col-1];\\n            n_m_path[0][col]=n_m_path[0][col-1];\\n            if(board[0][col]!=\\'S\\')\\n                m_path[0][col]=(m_path[0][col]+board[0][col]-\\'0\\')%(1000000000+7);\\n        }\\n        \\n        for(int row=1; row<board.size(); row++){\\n            for(int col=1; col<board[0].size(); col++){\\n                int max_=0;\\n                max_=max(max(m_path[row-1][col],m_path[row][col-1]),m_path[row-1][col-1]);\\n                if(max_==-1||board[row][col]==\\'X\\')continue;\\n                m_path[row][col]=max_;\\n                if(board[row][col]!=\\'S\\')\\n                    m_path[row][col]=(m_path[row][col]+board[row][col]-\\'0\\')%(1000000000+7);\\n                if(m_path[row-1][col]==max_)\\n                    n_m_path[row][col]=(n_m_path[row][col]+n_m_path[row-1][col])%(1000000000+7);\\n                if(m_path[row][col-1]==max_)\\n                    n_m_path[row][col]=(n_m_path[row][col]+n_m_path[row][col-1])%(1000000000+7);\\n                if(m_path[row-1][col-1]==max_)\\n                    n_m_path[row][col]=(n_m_path[row][col]+n_m_path[row-1][col-1])%(1000000000+7);\\n            }\\n        }\\n        \\n        vector<int>ret={m_path[m_path.size()-1][m_path[0].size()-1], n_m_path[n_m_path.size()-1][n_m_path[0].size()-1]};\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533165,
                "title": "top-down-memoization",
                "content": "The 0th index is sum and 1st index is count. Rest of the code is straight forward.\\n```\\npublic class Solution \\n{\\n    private int[,][] dp;\\n    \\n    private const int MOD = 1000000007;\\n    \\n    public int[] PathsWithMaxScore(IList<string> board) \\n    {\\n        int m = board.Count;\\n        int n = board[0].Length;\\n        \\n        dp = new int[m, n][];\\n        \\n        dp[m - 1, n - 1] = new int[] { int.MaxValue, int.MaxValue };\\n        \\n        int[] result = PathsWithMaxScore(board, 0, 0, m, n);\\n        \\n        //Chech whether we reached end\\n        if(dp[m - 1, n - 1][0] != int.MaxValue)\\n            return result;\\n        else\\n            return new int[]{ 0, 0 };\\n    }\\n    \\n    private int[] PathsWithMaxScore(IList<string> board, int r, int c, int m, int n)\\n    {\\n        if(r > m - 1 || c > n - 1 || board[r][c] == \\'X\\')\\n            return new int[] { 0, 0 };\\n\\t\\t\\t\\n        //Base case once we reach the end, we return a zero sum with count as 1\\n        if(r == m - 1 && c == n - 1)\\n        {\\n            dp[r, c] = new int[] { 0, 1 };\\n            return dp[r, c];\\n        }\\n        \\n        if(dp[r, c] != null)\\n            return dp[r, c];\\n        \\n        int val = char.IsDigit(board[r][c]) ? (int)char.GetNumericValue(board[r][c]) : 0;\\n        \\n        int[] down = PathsWithMaxScore(board, r + 1, c, m, n);\\n        \\n        int[] right = PathsWithMaxScore(board, r, c + 1, m, n);\\n        \\n        int[] upRightDiag = PathsWithMaxScore(board, r + 1, c + 1, m, n);\\n        \\n        int[] next = new int[2];\\n        \\n        next[0] = Math.Max(down[0], Math.Max(right[0], upRightDiag[0]));\\n        \\n\\t\\t//If the max is equal to the sum from left path add the count\\n        if(next[0] == down[0])\\n            next[1] = ((next[1] + down[1]) % MOD);\\n        \\n\\t\\t//If the max is equal to the sum from right path add the count\\n        if(next[0] == right[0])\\n            next[1] = ((next[1] + right[1]) % MOD);\\n        \\n\\t\\t//If the max is equal to the sum from diag path add the count\\n        if(next[0] == upRightDiag[0])\\n            next[1] = ((next[1] + upRightDiag[1]) % MOD);\\n        \\n\\t\\t//Add the current location\\'s val\\n        next[0] += val;\\n        \\n        dp[r, c] = next;\\n        \\n        return next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\npublic class Solution \\n{\\n    private int[,][] dp;\\n    \\n    private const int MOD = 1000000007;\\n    \\n    public int[] PathsWithMaxScore(IList<string> board) \\n    {\\n        int m = board.Count;\\n        int n = board[0].Length;\\n        \\n        dp = new int[m, n][];\\n        \\n        dp[m - 1, n - 1] = new int[] { int.MaxValue, int.MaxValue };\\n        \\n        int[] result = PathsWithMaxScore(board, 0, 0, m, n);\\n        \\n        //Chech whether we reached end\\n        if(dp[m - 1, n - 1][0] != int.MaxValue)\\n            return result;\\n        else\\n            return new int[]{ 0, 0 };\\n    }\\n    \\n    private int[] PathsWithMaxScore(IList<string> board, int r, int c, int m, int n)\\n    {\\n        if(r > m - 1 || c > n - 1 || board[r][c] == \\'X\\')\\n            return new int[] { 0, 0 };\\n\\t\\t\\t\\n        //Base case once we reach the end, we return a zero sum with count as 1\\n        if(r == m - 1 && c == n - 1)\\n        {\\n            dp[r, c] = new int[] { 0, 1 };\\n            return dp[r, c];\\n        }\\n        \\n        if(dp[r, c] != null)\\n            return dp[r, c];\\n        \\n        int val = char.IsDigit(board[r][c]) ? (int)char.GetNumericValue(board[r][c]) : 0;\\n        \\n        int[] down = PathsWithMaxScore(board, r + 1, c, m, n);\\n        \\n        int[] right = PathsWithMaxScore(board, r, c + 1, m, n);\\n        \\n        int[] upRightDiag = PathsWithMaxScore(board, r + 1, c + 1, m, n);\\n        \\n        int[] next = new int[2];\\n        \\n        next[0] = Math.Max(down[0], Math.Max(right[0], upRightDiag[0]));\\n        \\n\\t\\t//If the max is equal to the sum from left path add the count\\n        if(next[0] == down[0])\\n            next[1] = ((next[1] + down[1]) % MOD);\\n        \\n\\t\\t//If the max is equal to the sum from right path add the count\\n        if(next[0] == right[0])\\n            next[1] = ((next[1] + right[1]) % MOD);\\n        \\n\\t\\t//If the max is equal to the sum from diag path add the count\\n        if(next[0] == upRightDiag[0])\\n            next[1] = ((next[1] + upRightDiag[1]) % MOD);\\n        \\n\\t\\t//Add the current location\\'s val\\n        next[0] += val;\\n        \\n        dp[r, c] = next;\\n        \\n        return next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1946511,
                "content": [
                    {
                        "username": "akhilg11",
                        "content": "Gives TLE if you use a 2D dp array to find maximum path sum and another 3D dp array to get number of paths of that maximum sum"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "no mine got accepted but with very bad run time"
                    }
                ]
            }
        ]
    },
    {
        "title": "Calculate Money in Leetcode Bank",
        "question_content": "<p>Hercy wants to save money for his first car. He puts money in the Leetcode&nbsp;bank <strong>every day</strong>.</p>\n\n<p>He starts by putting in <code>$1</code> on Monday, the first day. Every day from Tuesday to Sunday, he will put in <code>$1</code> more than the day before. On every subsequent Monday, he will put in <code>$1</code> more than the <strong>previous Monday</strong>.<span style=\"display: none;\"> </span></p>\n\n<p>Given <code>n</code>, return <em>the total amount of money he will have in the Leetcode bank at the end of the </em><code>n<sup>th</sup></code><em> day.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4\n<strong>Output:</strong> 10\n<strong>Explanation:</strong>&nbsp;After the 4<sup>th</sup> day, the total is 1 + 2 + 3 + 4 = 10.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 10\n<strong>Output:</strong> 37\n<strong>Explanation:</strong>&nbsp;After the 10<sup>th</sup> day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37. Notice that on the 2<sup>nd</sup> Monday, Hercy only puts in $2.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 20\n<strong>Output:</strong> 96\n<strong>Explanation:</strong>&nbsp;After the 20<sup>th</sup> day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1009171,
                "title": "faster-than-100-00-commented-java-cpp-c",
                "content": "**[CPP]**\\n```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int m=n/7;  //(no.of full weeks)\\n        // first week  1 2 3 4 5 6 7 (sum is 28 i.e. 7*(i+3) if i=1)\\n        // second week  2 3 4 5 6 7 8 (sum is 35 i.e. 7*(i+3) if i=2)\\n        //.... so on\\n        int res=0; //for result\\n        //calculating full weeks\\n        for(int i=1;i<=m;i++){\\n            res+=7*(i+3);\\n        }\\n        //calculating left days\\n        for(int i=7*m;i<n;i++){\\n            res+=++m;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**[JAVA]**\\n```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int m=n/7;  //(no.of full weeks)\\n        // first week  1 2 3 4 5 6 7 (sum is 28 i.e. 7*(i+3) if i=1)\\n        // second week  2 3 4 5 6 7 8 (sum is 35 i.e. 7*(i+3) if i=2)\\n        //.... so on\\n        int res=0; //for result\\n        //calculating full weeks\\n        for(int i=1;i<=m;i++){\\n            res+=7*(i+3);\\n        }\\n        //calculating left days\\n        for(int i=7*m;i<n;i++){\\n            res+=++m;\\n        }\\n        return res;\\n    }\\n}\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int m=n/7;  //(no.of full weeks)\\n        // first week  1 2 3 4 5 6 7 (sum is 28 i.e. 7*(i+3) if i=1)\\n        // second week  2 3 4 5 6 7 8 (sum is 35 i.e. 7*(i+3) if i=2)\\n        //.... so on\\n        int res=0; //for result\\n        //calculating full weeks\\n        for(int i=1;i<=m;i++){\\n            res+=7*(i+3);\\n        }\\n        //calculating left days\\n        for(int i=7*m;i<n;i++){\\n            res+=++m;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int m=n/7;  //(no.of full weeks)\\n        // first week  1 2 3 4 5 6 7 (sum is 28 i.e. 7*(i+3) if i=1)\\n        // second week  2 3 4 5 6 7 8 (sum is 35 i.e. 7*(i+3) if i=2)\\n        //.... so on\\n        int res=0; //for result\\n        //calculating full weeks\\n        for(int i=1;i<=m;i++){\\n            res+=7*(i+3);\\n        }\\n        //calculating left days\\n        for(int i=7*m;i<n;i++){\\n            res+=++m;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009192,
                "title": "c-o-1-math",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Brute Force\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/calculate-money-in-leetcode-bank/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int s = 1, ans = 0;\\n        while (n > 0) {\\n            for (int i = 0; i < 7 && n-- > 0; ++i) ans += s + i;\\n            s++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Solution 2. Math\\n\\nWe have `f = n / 7` full weeks. \\n\\nThe first week we deposit `(1 + 7) * 7 / 2 = 28` dollars.\\n\\nThe `w`th week we deposit `(w + w + 6) * 7 / 2 = (w + 3) * 7` dollars, the `w + 1`th week we deposit `7` dollars more.\\n\\nSo the money we deposit each week is also an arithmetic sequence, whose sum is `(28 + 28 + 7 * (f - 1)) * f / 2 = (49 + 7 * f) * f / 2`.\\n\\nThe last non-full week has `d = n % 7` days. We deposit `f + 1` dollars on its Monday, so we deposit `(f + 1 + (f + 1 + d - 1)) * d / 2 = (2 * f + d + 1) * d / 2` dollars for this week.\\n\\nSo the final answer is `(49 + 7 * f) * f / 2 + (2 * f + d + 1) * d / 2`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/calculate-money-in-leetcode-bank/\\n// Author: github.com/lzl124631x\\n// Time: O(1)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int f = n / 7, d = n % 7;\\n        return (49 + 7 * f) * f / 2 + (2 * f + d + 1) * d / 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/calculate-money-in-leetcode-bank/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int s = 1, ans = 0;\\n        while (n > 0) {\\n            for (int i = 0; i < 7 && n-- > 0; ++i) ans += s + i;\\n            s++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/calculate-money-in-leetcode-bank/\\n// Author: github.com/lzl124631x\\n// Time: O(1)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int f = n / 7, d = n % 7;\\n        return (49 + 7 * f) * f / 2 + (2 * f + d + 1) * d / 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008876,
                "title": "python-simple-maths-with-explanation-o-1",
                "content": "Basic idea is, its like a AP problem for a week the total is 28 and every it will increase by 7 because second week will start with 2 and likewise third, something like 28, 28+7, 28+14, ......\\n\\n```\\ndef totalMoney(self, n: int) -> int:\\n\\tif n <= 7:\\n\\t\\treturn n * (n+1)//2\\n\\n\\tweeks = n // 7\\n\\ttotal = weeks * 28\\n\\t# Sum of AP\\n\\ttotal += (weeks*(weeks-1)*7)//2\\n\\n\\tif n % 7 != 0:\\n\\t\\tdays = n % 7\\n\\t\\tday = weeks+1\\n\\t\\tfor j in range(days):\\n\\t\\t\\ttotal += day\\n\\t\\t\\tday += 1\\n\\n\\treturn total\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "Basic idea is, its like a AP problem for a week the total is 28 and every it will increase by 7 because second week will start with 2 and likewise third, something like 28, 28+7, 28+14, ......\\n\\n```\\ndef totalMoney(self, n: int) -> int:\\n\\tif n <= 7:\\n\\t\\treturn n * (n+1)//2\\n\\n\\tweeks = n // 7\\n\\ttotal = weeks * 28\\n\\t# Sum of AP\\n\\ttotal += (weeks*(weeks-1)*7)//2\\n\\n\\tif n % 7 != 0:\\n\\t\\tdays = n % 7\\n\\t\\tday = weeks+1\\n\\t\\tfor j in range(days):\\n\\t\\t\\ttotal += day\\n\\t\\t\\tday += 1\\n\\n\\treturn total\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1008897,
                "title": "o-1-java-2-liner",
                "content": "Let\\'s observe the sequence of this :\\n```\\n 1,  2,  3,  4,  5,  6,  7,\\n 2,  3,  4,  5,  6,  7,  8,\\n 3,  4,  5,  6,  7,  8,  9,\\n 4,  5,  6,  7,  8,  9, 10,\\n```\\nLet\\'s figure out the values at given n :\\n1. (n = 4) => sum (1,2,3,4) => sum until 4th index (1-based) in 1st row.\\n2. (n = 10) => sum (1,2,3,4,5,6,7,2,3,4) => sum until 3rd index in 2nd row + sum of first row. \\n\\nSimilary, we can observe that for given n (suppose belonging to row **R** and column **C**), we have to find sum of all elements in previous rows and sum of all elements in row **R** and column <= **C**\\n\\nNow, \\n```\\ncurrent row = n/7; (0-based)\\ncurrent col = n%7; (1-based here, if it turns out to be 0 => n belongs to last element of row)\\n```\\nLet\\'s first focus on sum of previous rows. Things to notice about sum of rows :\\n1. Sum of xth row = 7 + sum of (x-1)th row.\\n2. 1+2+3+4+5+6+7 = 28. Base sum of all rows is 28, additional sum is in the sequence (0, 7, 14, 21, 28,... ) => in multiples of 7.\\n\\nNow, **weeks** which is 0-based row value of n, also represents total number of previous rows. Hence the formulae 28*(weeks) calculates total base sum of all previous rows. \\n7 * weeks*(weeks-1)/2 gives extra sum of all previous rows. (Please try to figure this out, or else ask in comment, can\\'t make this too messy).\\n\\t\\nNow, sum upto this column in this particular row :\\n1. **extra** is 1-based column value of n.\\n2. For this sum, I have visualized the last row as all indexes having base value of (number of previous weeks) + 1-based value of their respective columns.\\n3. Here, I have divided this sum as :\\n\\t3.1 (weeks * extra) : sum of base values of all elements in last row, till 1-based column : extra.\\n\\t3.2 (extra * (extra+1))/2 : sum of extra values (1-based column values).\\n\\n\\n```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int extra = n%7, weeks = n/7;\\n        return 28 * weeks + 7 * (weeks)*(weeks-1)/2 + weeks*extra + (extra)*(extra+1)/2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n 1,  2,  3,  4,  5,  6,  7,\\n 2,  3,  4,  5,  6,  7,  8,\\n 3,  4,  5,  6,  7,  8,  9,\\n 4,  5,  6,  7,  8,  9, 10,\\n```\n```\\ncurrent row = n/7; (0-based)\\ncurrent col = n%7; (1-based here, if it turns out to be 0 => n belongs to last element of row)\\n```\n```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int extra = n%7, weeks = n/7;\\n        return 28 * weeks + 7 * (weeks)*(weeks-1)/2 + weeks*extra + (extra)*(extra+1)/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010596,
                "title": "python-one-line-simple",
                "content": "```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        return sum([i//7 + i%7 + 1 for i in range(n)])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        return sum([i//7 + i%7 + 1 for i in range(n)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1014075,
                "title": "java-solution-constant-space",
                "content": "```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int monday = 1, cur = 1, bank = 0;\\n        for(int i = 1; i <= n; i++) {\\n                bank += cur;\\n                cur++;\\n            if (i % 7 == 0) {\\n                monday+=1;\\n                cur = monday;\\n            }\\n            \\n        }\\n        return bank;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int monday = 1, cur = 1, bank = 0;\\n        for(int i = 1; i <= n; i++) {\\n                bank += cur;\\n                cur++;\\n            if (i % 7 == 0) {\\n                monday+=1;\\n                cur = monday;\\n            }\\n            \\n        }\\n        return bank;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1013944,
                "title": "c-naive-vs-gaussian-solution-compared-and-explained-100-time",
                "content": "Fun problem, that we can solve in a few ways.\\n\\nFirst of all, we can just create an accumulator variable `res` and loop from `1` to `n`, included, to increase its value.\\n\\nWe will also use a variable `c`, initially set to `1`, that we will keep adding to `res` at each step, resetting it to be `i / 7` every time `i` is a perfect multiple of `7`.\\n\\nNaive solution, running in linear time:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int res = 0;\\n        for (int i = 1, c = 1; i <= n; i++, c++) {\\n            res += c;\\n            c = i % 7 ? c : (i / 7);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nAnother solution might be playing a bit smarter than that, identifying recurring patterns.\\n\\nTo do so, we first of all create 2 variables:\\n* `r` will store the remainder of the days divided by `7` - ie: how many days at the end of the period we will have which do not fit into a full week;\\n* `d` will store the result of the division by `7` - ie: how many full weeks we are in.\\n\\nLet\\'s do the last part (incomplete weeks) first, for example with `n == 20` as in one of the sample inputs; we will then have 6 days in an incomplete weeks, with values as follows:\\n\\n```cpp\\n3 + 4 + 5 + 6 + 7 + 8\\n```\\n\\nAnd this can be further seen with the Gaussian formula for summations as:\\n\\n```cpp\\n3 + 4 + 5 + 6 + 7 + 8 =\\n1 + 2 + 3 + 4 + 5 + 6 + // (r + 1) * r / 2\\n2 + 2 + 2 + 2 + 2 + 2   // r * d\\n```\\n\\nNow, with some grouping:\\n\\n```cpp\\n(r + 1) * r / 2 + r * d =\\nr * ((r + 1) / 2 + d) =\\nr * (r + 1 + 2 * d)\\n```\\n\\nAnd this covers the \"tail\" of our formula, the first one I focused on the full weeks. In our example with `n == 20` we will have:\\n\\n```cpp\\n1 + 2 + 3 + 4 + 5 + 6 + 7 // week 1\\n2 + 3 + 4 + 5 + 6 + 7 + 8 // week 2\\n```\\n\\nMore in general we will have that for full weeks we will get:\\n\\n```cpp\\n1 + 2 + 3 + 4 + 5 + 6 + 7 =\\n1 + 2 + 3 + 4 + 5 + 6 + 7 +\\n0 + 0 + 0 + 0 + 0 + 0 + 0 // week 1\\n2 + 3 + 4 + 5 + 6 + 7 + 8 =\\n1 + 2 + 3 + 4 + 5 + 6 + 7 +\\n1 + 1 + 1 + 1 + 1 + 1 + 1 // week 2\\n3 + 4 + 5 + 6 + 7 + 8 + 9 =\\n1 + 2 + 3 + 4 + 5 + 6 + 7 +\\n2 + 2 + 2 + 2 + 2 + 2 + 2 // week 3\\n...\\n```\\n\\nNow, since `1 + 2 + 3 + 4 + 5 + 6 + 7 == 28`, we will have that each week will contribute with `28` plus `7` times its index.\\n\\nMore in general, and again summoning Gauss\\' early wisdom to our support, we can derive the formula as `d * 28 + (d - 1) * d / 2 * 7`.\\n\\nWith that in mind, we can finally return the whole result as the sum of the 2 parts: `d * 28 + (d - 1) * d / 2 * 7 + (r + 1 + 2 * d) * r / 2` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int r = n % 7, d = n / 7;\\n        return d * 28 + (d - 1) * d / 2 * 7 + (r + 1 + 2 * d) * r / 2;\\n    }\\n};\\n```\\n\\nOr, if you want to impress your friends with bitwise operators, just go wild with them:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int r = n % 7, d = n / 7;\\n        return d * 28 + ((d - 1) * d >> 1) * 7 + ((r + 1 + (d << 1)) * r >> 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int res = 0;\\n        for (int i = 1, c = 1; i <= n; i++, c++) {\\n            res += c;\\n            c = i % 7 ? c : (i / 7);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\n3 + 4 + 5 + 6 + 7 + 8\\n```\n```cpp\\n3 + 4 + 5 + 6 + 7 + 8 =\\n1 + 2 + 3 + 4 + 5 + 6 + // (r + 1) * r / 2\\n2 + 2 + 2 + 2 + 2 + 2   // r * d\\n```\n```cpp\\n(r + 1) * r / 2 + r * d =\\nr * ((r + 1) / 2 + d) =\\nr * (r + 1 + 2 * d)\\n```\n```cpp\\n1 + 2 + 3 + 4 + 5 + 6 + 7 // week 1\\n2 + 3 + 4 + 5 + 6 + 7 + 8 // week 2\\n```\n```cpp\\n1 + 2 + 3 + 4 + 5 + 6 + 7 =\\n1 + 2 + 3 + 4 + 5 + 6 + 7 +\\n0 + 0 + 0 + 0 + 0 + 0 + 0 // week 1\\n2 + 3 + 4 + 5 + 6 + 7 + 8 =\\n1 + 2 + 3 + 4 + 5 + 6 + 7 +\\n1 + 1 + 1 + 1 + 1 + 1 + 1 // week 2\\n3 + 4 + 5 + 6 + 7 + 8 + 9 =\\n1 + 2 + 3 + 4 + 5 + 6 + 7 +\\n2 + 2 + 2 + 2 + 2 + 2 + 2 // week 3\\n...\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int r = n % 7, d = n / 7;\\n        return d * 28 + (d - 1) * d / 2 * 7 + (r + 1 + 2 * d) * r / 2;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int r = n % 7, d = n / 7;\\n        return d * 28 + ((d - 1) * d >> 1) * 7 + ((r + 1 + (d << 1)) * r >> 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1128072,
                "title": "js-c-ruby-arithmetic-series-o-1-o-1",
                "content": "##### Solution Analysis: **`Time O(1) | Space O(1)`**\\nI learned from other solutions and will try to summarize the thought process as best as I can here.\\n\\n##### Finding the pattern\\nIf you write out the amount deposited each week, what may be clear is that:\\n**`total sum = sum of previous weeks + sum of days in current week`**. \\n\\nThe key here is that each week has a predictable sequence (e.g. 1 + 2 + ... + 6 + 7 ), which we can sum with the [arithmetic series formula](https://mathbitsnotebook.com/Algebra2/Sequences/SSGauss.html):\\n\\n**`S_n = n(a_1 + a_n) / 2`** where `a_1` = first term, `a_n` = last term, `n` = total terms\\n\\n**Sum of previous weeks**\\nTo get the **`sum of previous weeks`**, we can think of each full week separately then sum them up to the `k`th full week:\\n```\\nweek 1 = 7 * (1+7)/2 = `7 * 4`\\nweek 2 = 7 * (2+8)/2 = `7 * 5`\\nweek 3 = 7 * (3+9)/2 = `7 * 6`\\n...\\nweek k = 7 * (k + (k-1 + 7))/2 = 7 * (2k+6)/2 = `7 * (k+3)`\\n```\\nWhen we sum them up, we also see that \\\\*gasp\\\\* there\\'s *another* arithmetic sequence here...\\n```\\nsum of previous k weeks \\n= (7*4) + (7*5) + (7*6) + ... + (7*(k+3))\\n= 7 * (4 + 5 + 6 + ... + (k+3) ) // 2nd sequence\\n= 7 * [k * (4 + (k+3)) / 2]\\n= 7 * k * (k+7) / 2\\n```\\nAnother way you can think of it: using the base of 28 for a full week + 7 for each additional week:\\n```\\nweek 1 = `28 + 7 * 0`\\nweek 2 = `28 + 7 * 1`\\nweek 3 = `28 + 7 * 2`\\n...\\nweek k = `28 + 7 * (k-1)`\\n```\\nAnd look, another sequence??\\n```\\nsum of previous k weeks \\n= (28 + 7 * 0) + (28 + 7 * 1) + (28 + 7 * 2) + ... + (28 + 7 * (k-1))\\n= 28 * k + 7 * (0 + 1 + 2 + ... + (k-1)) // 2nd sequence\\n= 28 * k + 7 * [k * (0 + (k-1)) / 2]\\n= 28 * k + 7 * k * (k-1) / 2\\n```\\nBoth are valid for `sum of previous weeks` and you can find that \\n**`7 * k * (k+7) / 2`** == **`28 * k + 7 * k * (k-1) / 2`**\\n\\nThere might only be a super slight, negligible difference in computation. They also work because if n < 7 (no full weeks yet), they\\'re both 0.\\n\\n**Sum of days in current week**\\nTo get the **`sum of days in current week`**, we can use `x = n % 7` to give us the day of the week. Then we can find the sum up to and including the day of the week, depending on which week we\\'re in.\\n```\\nS_1 = 1 + 2 + ... + x     = `x * (1+x) / 2` // if we were in week 1\\nS_2 = 2 + 3 + ... + (x+1) = (1 + 2 + ... + x) + 1 * x = `S_1 + 1 * x`  // in week 2\\nS_3 = 3 + 4 + ... + (x+2) = (1 + 2 + ... + x) + 2 * x = `S_1 + 2 * x` // in week 3\\n...\\nS_(k+1) \\n= S_1 + k * x  // (because k = number of -full- weeks)\\n= (x * (x + 1) / 2) + k * x\\n= x * (2 * k + x + 1) / 2\\n```\\n##### Putting everything together:\\n**`total sum =  sum of k full weeks + sum of x days in current week`**\\n`(where k = n / 7 and x = n % 7)`\\n\\n**`= [7 * k * (k+7) / 2] + [ x * (2 * k + x + 1) / 2]`**\\n\\n---\\n### JS\\n```\\nfunction totalMoney(n) {\\n  const k = Math.floor(n / 7), x = n % 7; // k = # full weeks, x = day of week\\n  return (7 * k * (k + 7) / 2) + (x * (2*k + x + 1) / 2); // (sum of k weeks) + (sum of x days)\\n}\\n```\\n### C#\\n```\\npublic class Solution {\\n  public int TotalMoney(int n)\\n  {\\n    int k = n / 7; int x = n % 7;\\n    return (7 * k * (k + 7) / 2) + (x * (2*k + x + 1) / 2);\\n  }\\n}\\n```\\n### Ruby\\n```\\ndef totalMoney(n)\\n  k, x = n / 7, n % 7\\n  (7 * k * (k + 7) / 2) + (x * (2*k + x + 1) / 2)\\nend\\n```\\n\\n*If you see anything that can be clarified or optimized more (I\\'m a novice so I often miss things that might be obvious to others), feel free to comment!*",
                "solutionTags": [
                    "JavaScript",
                    "Ruby",
                    "Math"
                ],
                "code": "```\\nweek 1 = 7 * (1+7)/2 = `7 * 4`\\nweek 2 = 7 * (2+8)/2 = `7 * 5`\\nweek 3 = 7 * (3+9)/2 = `7 * 6`\\n...\\nweek k = 7 * (k + (k-1 + 7))/2 = 7 * (2k+6)/2 = `7 * (k+3)`\\n```\n```\\nsum of previous k weeks \\n= (7*4) + (7*5) + (7*6) + ... + (7*(k+3))\\n= 7 * (4 + 5 + 6 + ... + (k+3) ) // 2nd sequence\\n= 7 * [k * (4 + (k+3)) / 2]\\n= 7 * k * (k+7) / 2\\n```\n```\\nweek 1 = `28 + 7 * 0`\\nweek 2 = `28 + 7 * 1`\\nweek 3 = `28 + 7 * 2`\\n...\\nweek k = `28 + 7 * (k-1)`\\n```\n```\\nsum of previous k weeks \\n= (28 + 7 * 0) + (28 + 7 * 1) + (28 + 7 * 2) + ... + (28 + 7 * (k-1))\\n= 28 * k + 7 * (0 + 1 + 2 + ... + (k-1)) // 2nd sequence\\n= 28 * k + 7 * [k * (0 + (k-1)) / 2]\\n= 28 * k + 7 * k * (k-1) / 2\\n```\n```\\nS_1 = 1 + 2 + ... + x     = `x * (1+x) / 2` // if we were in week 1\\nS_2 = 2 + 3 + ... + (x+1) = (1 + 2 + ... + x) + 1 * x = `S_1 + 1 * x`  // in week 2\\nS_3 = 3 + 4 + ... + (x+2) = (1 + 2 + ... + x) + 2 * x = `S_1 + 2 * x` // in week 3\\n...\\nS_(k+1) \\n= S_1 + k * x  // (because k = number of -full- weeks)\\n= (x * (x + 1) / 2) + k * x\\n= x * (2 * k + x + 1) / 2\\n```\n```\\nfunction totalMoney(n) {\\n  const k = Math.floor(n / 7), x = n % 7; // k = # full weeks, x = day of week\\n  return (7 * k * (k + 7) / 2) + (x * (2*k + x + 1) / 2); // (sum of k weeks) + (sum of x days)\\n}\\n```\n```\\npublic class Solution {\\n  public int TotalMoney(int n)\\n  {\\n    int k = n / 7; int x = n % 7;\\n    return (7 * k * (k + 7) / 2) + (x * (2*k + x + 1) / 2);\\n  }\\n}\\n```\n```\\ndef totalMoney(n)\\n  k, x = n / 7, n % 7\\n  (7 * k * (k + 7) / 2) + (x * (2*k + x + 1) / 2)\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069281,
                "title": "c-simple-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint totalMoney(int n) {\\n\\t\\t  int sum = 0;\\n\\t\\t  int firstDay = 1;\\n\\t\\t  int count = firstDay;\\n\\t\\t  for(int i = 1; i <= n; i++){\\n\\t\\t\\tsum += count;\\n\\t\\t\\tcount++;\\n\\t\\t\\tif(i%7 == 0){\\n\\t\\t\\t  firstDay++;\\n\\t\\t\\t  count = firstDay;\\n\\t\\t\\t}\\n\\t\\t  }   \\n\\t\\t  return sum;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint totalMoney(int n) {\\n\\t\\t  int sum = 0;\\n\\t\\t  int firstDay = 1;\\n\\t\\t  int count = firstDay;\\n\\t\\t  for(int i = 1; i <= n; i++){\\n\\t\\t\\tsum += count;\\n\\t\\t\\tcount++;\\n\\t\\t\\tif(i%7 == 0){\\n\\t\\t\\t  firstDay++;\\n\\t\\t\\t  count = firstDay;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1138960,
                "title": "python-3-very-easy-solution",
                "content": "```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        res,k=0,0\\n        for i in range(n):\\n            if i%7==0:\\n                k+=1\\n            res+=k+(i%7)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        res,k=0,0\\n        for i in range(n):\\n            if i%7==0:\\n                k+=1\\n            res+=k+(i%7)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010448,
                "title": "c-solution",
                "content": "```\\nint totalMoney(int n) {\\n    int money = 0, daily_increase = 1, monday_increase = 2;\\n    \\n    for (int i = 0; i < n; i++) {\\n        if ((i != 0) && (i % 7) == 0) {\\n            daily_increase = monday_increase;\\n            monday_increase++;\\n        }\\n        money+=daily_increase;\\n        daily_increase++;\\n    }\\n    \\n    return money;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint totalMoney(int n) {\\n    int money = 0, daily_increase = 1, monday_increase = 2;\\n    \\n    for (int i = 0; i < n; i++) {\\n        if ((i != 0) && (i % 7) == 0) {\\n            daily_increase = monday_increase;\\n            monday_increase++;\\n        }\\n        money+=daily_increase;\\n        daily_increase++;\\n    }\\n    \\n    return money;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1008856,
                "title": "1716-calculate-money-in-leetcode-bank-javascript",
                "content": "```\\nvar totalMoney = function(n) {\\n    let min = 1;\\n    let days = 7;\\n    let total = 0;\\n    let inc = 1;\\n    for (let i = 0; i < n; i++) {\\n        if (days !== 0) {\\n            total += min;\\n            min++;\\n            days--;\\n        } else {\\n            inc++;\\n            min = inc\\n            days = 7;\\n            i--;\\n        }\\n    }\\n    return total;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar totalMoney = function(n) {\\n    let min = 1;\\n    let days = 7;\\n    let total = 0;\\n    let inc = 1;\\n    for (let i = 0; i < n; i++) {\\n        if (days !== 0) {\\n            total += min;\\n            min++;\\n            days--;\\n        } else {\\n            inc++;\\n            min = inc\\n            days = 7;\\n            i--;\\n        }\\n    }\\n    return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3234998,
                "title": "c-easy-approach-o-n-0ms-100-beats",
                "content": "# Intuition\\nSimple game of quotient and remainder.\\n\\n# Approach\\nDividing given number by 7, and storing the *quotient*. *The quotient is the number of total sets (of 7) completed by the given number.* The remainder will contain the set that is *incomplete*. If there is one complete set then we could say the addition of the set (i.e. 1+2+3+4+5+6+7 = 28 which is 7x4), the addition of other set (i.e. 2+3+4+5+6+7+8 = 35 which is 7x5). Therefore we ran the loop *que* times, and incremented the multiplier 4 everytime. Now we got the total addition of complete set stored in *ans*. Now, dealing with the incomplete set, it will run from 1 till the remainder of the number, and here we will also increment the quotient by 1, because the next monday has 1 more dollor than the previous one. We will keep this incrementing till the loop terminates. And will finally return *ans+sd*, in my case.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int que = n / 7; long ans = 0; int start = 4;\\n        for(int i = 1; i <= que; i++) {\\n            ans = ans + (7*start);\\n            start++;\\n        }\\n        int holdQue = que;\\n        int remain = n % 7; int newStarter = que + 1; int sd = 0;\\n        for(int i = 1; i <= (remain); i++) {\\n            sd = sd + newStarter;\\n            newStarter++;\\n        }\\n        return (ans+sd);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int que = n / 7; long ans = 0; int start = 4;\\n        for(int i = 1; i <= que; i++) {\\n            ans = ans + (7*start);\\n            start++;\\n        }\\n        int holdQue = que;\\n        int remain = n % 7; int newStarter = que + 1; int sd = 0;\\n        for(int i = 1; i <= (remain); i++) {\\n            sd = sd + newStarter;\\n            newStarter++;\\n        }\\n        return (ans+sd);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1267628,
                "title": "c-baisc-fater-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int sum=0;\\n        int j=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum=(i+j)+sum;\\n            if((i+1)%7==0) //since it is o based for loop\\n            {\\n                j++; //each monaday there is addion of 1\\n                i=-1; //since it will become 0 with iteration in for loop\\n                n=n-7; //minus 7 days from total number of days\\n            }\\n            //cout<<sum<<\" \";\\n        }\\n        return sum;\\n    }\\n    \\n};\\n# If you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int sum=0;\\n        int j=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum=(i+j)+sum;\\n            if((i+1)%7==0) //since it is o based for loop\\n            {\\n                j++; //each monaday there is addion of 1\\n                i=-1; //since it will become 0 with iteration in for loop\\n                n=n-7; //minus 7 days from total number of days\\n            }\\n            //cout<<sum<<\" \";\\n        }\\n        return sum;\\n    }\\n    \\n};\\n# If you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3879959,
                "title": "python3-solution-beats-100-in-runtime-only-5-lines-code",
                "content": "![image.png](https://assets.leetcode.com/users/images/2f3418d9-04d9-483c-a41f-87c71b45cc76_1691471550.6305616.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        income=1;a=[1];ans=0\\n        for i in range(n):\\n            if i%7==0 and i!=0:income=(a[len(a)-7])\\n            ans+=income;income+=1;a.append(income)      \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        income=1;a=[1];ans=0\\n        for i in range(n):\\n            if i%7==0 and i!=0:income=(a[len(a)-7])\\n            ans+=income;income+=1;a.append(income)      \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085063,
                "title": "c-simply-formula-solution-both100-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int a=n/7,b=n%7;\\n        return ((49+7*a)*a+(2*a+b+1)*b)/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int a=n/7,b=n%7;\\n        return ((49+7*a)*a+(2*a+b+1)*b)/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1061513,
                "title": "javascript-solution-math-o-1",
                "content": "Using the formula ```f(x) = (x^2 + 7x) / 2``` we can calculate what we have to multiply 7 by, add them to the sum, and then loop the final week if there are remaining days.\\n\\n```Week 1: (1+2+3+4+5+6+7) gives 7 * 4 = 28```\\n```Week 2: (2+3+4+5+6+7+8) gives 7 * 5 = 35```\\n```Week 3: (3+4+5+6+7+8+9) gives 7 * 6 = 42```\\n\\n```Weeks 1 + 2 + 3 = 105```\\nWe can use the formula above ```f(3) = (3^2 + 7(3)) / 2 = 15```, which is just adding up ```4 + 5 + 6``` in the sequence above. This is what we use to multiply 7 by, ```7 * 15 = 105```.\\nThe solution at most is O(6) time complexity, which is just O(1). Space is also O(1).\\n\\n```\\n// Time: O(1)\\n// Space: O(1)\\nvar totalMoney = function(n) {\\n    let countMonday = Math.floor(n / 7);\\n    let seq = ((countMonday ** 2) + (7 * countMonday)) / 2;\\n    let sum = seq * 7;\\n    for(let i = 0; i < n - (countMonday * 7); i++) {\\n        sum += countMonday + i + 1;\\n    }\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```f(x) = (x^2 + 7x) / 2```\n```Week 1: (1+2+3+4+5+6+7) gives 7 * 4 = 28```\n```Week 2: (2+3+4+5+6+7+8) gives 7 * 5 = 35```\n```Week 3: (3+4+5+6+7+8+9) gives 7 * 6 = 42```\n```Weeks 1 + 2 + 3 = 105```\n```f(3) = (3^2 + 7(3)) / 2 = 15```\n```4 + 5 + 6```\n```7 * 15 = 105```\n```\\n// Time: O(1)\\n// Space: O(1)\\nvar totalMoney = function(n) {\\n    let countMonday = Math.floor(n / 7);\\n    let seq = ((countMonday ** 2) + (7 * countMonday)) / 2;\\n    let sum = seq * 7;\\n    for(let i = 0; i < n - (countMonday * 7); i++) {\\n        sum += countMonday + i + 1;\\n    }\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2799050,
                "title": "java-100-faster-3-solutions",
                "content": "# Solution 1 | 80% time (1ms) | 17% memory\\n```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int whole = n / 7, part = n % 7, sum = 0;\\n        for (int i = 1; i <= whole; i++) {\\n            //it is arithmetic progression for each 7 numbers\\n            //but already divided by two\\n            //initial form was: (i + i + 6) * 7 / 2\\n            sum += (i + 3) * 7;\\n        }\\n        sum += ((whole + 1 + whole + part) * part) / 2;\\n        return sum;\\n    }\\n}\\n```\\n\\n# Solution 2 | 80% time (1ms) | 8% memory\\nFilling out map with all values from 1 to 1000 (constraint by description).\\n```\\nclass Solution {\\n    static Map<Integer, Integer> map = new HashMap<>();\\n    public int totalMoney(int n) {\\n        if (map.size() == 0) {\\n            fillMap();\\n        }\\n        return map.get(n);\\n    }\\n    static void fillMap() {\\n        int count = 0, sum = 0, increment = 1;\\n        for (int i = 1; i <= 1000 ; i++) {\\n            if (count % 7 == 0) {\\n                increment = 1 + (count / 7);\\n            }\\n            sum += increment;\\n            map.put(i, sum);\\n            count++;\\n            increment++;\\n        }\\n    }\\n}\\n```\\n\\n\\n# Solution 3 | 100% time | 89% memory\\nFilling out array with values from 1 to 1000. It is faster.\\n```\\nclass Solution {\\n    static int[] values = new int[1000];\\n    public int totalMoney(int n) {\\n        if (values[0] == 0) {\\n            fillArray();\\n        }\\n        return values[n - 1];\\n    }\\n\\n    static void fillArray() {\\n        int count = 0, sum = 0, increment = 1;\\n        for (int i = 1; i <= 1000 ; i++) {\\n            if (count % 7 == 0) {\\n                increment = 1 + (count / 7);\\n            }\\n            sum += increment;\\n            values[i - 1] = sum;\\n            count++;\\n            increment++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int whole = n / 7, part = n % 7, sum = 0;\\n        for (int i = 1; i <= whole; i++) {\\n            //it is arithmetic progression for each 7 numbers\\n            //but already divided by two\\n            //initial form was: (i + i + 6) * 7 / 2\\n            sum += (i + 3) * 7;\\n        }\\n        sum += ((whole + 1 + whole + part) * part) / 2;\\n        return sum;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    static Map<Integer, Integer> map = new HashMap<>();\\n    public int totalMoney(int n) {\\n        if (map.size() == 0) {\\n            fillMap();\\n        }\\n        return map.get(n);\\n    }\\n    static void fillMap() {\\n        int count = 0, sum = 0, increment = 1;\\n        for (int i = 1; i <= 1000 ; i++) {\\n            if (count % 7 == 0) {\\n                increment = 1 + (count / 7);\\n            }\\n            sum += increment;\\n            map.put(i, sum);\\n            count++;\\n            increment++;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    static int[] values = new int[1000];\\n    public int totalMoney(int n) {\\n        if (values[0] == 0) {\\n            fillArray();\\n        }\\n        return values[n - 1];\\n    }\\n\\n    static void fillArray() {\\n        int count = 0, sum = 0, increment = 1;\\n        for (int i = 1; i <= 1000 ; i++) {\\n            if (count % 7 == 0) {\\n                increment = 1 + (count / 7);\\n            }\\n            sum += increment;\\n            values[i - 1] = sum;\\n            count++;\\n            increment++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689980,
                "title": "recursive-solution-python3",
                "content": "# Intuition\\nRecursive solution\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        def week(days, n=1, wek=7):\\n            res = 0\\n            for day in range(n, days+n):\\n                res += day\\n                print(day)\\n                if day == wek:\\n                    return res + week(days-7, n+1, wek+1)\\n            return res\\n        return week(n)\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        def week(days, n=1, wek=7):\\n            res = 0\\n            for day in range(n, days+n):\\n                res += day\\n                print(day)\\n                if day == wek:\\n                    return res + week(days-7, n+1, wek+1)\\n            return res\\n        return week(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1671220,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int a=i/7;\\n            int rem=i%7;\\n            sum+=rem+a+1;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int a=i/7;\\n            int rem=i%7;\\n            sum+=rem+a+1;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194158,
                "title": "c-o-1-math",
                "content": "**Explaination**\\n\\nCalculate weeks before given day week,\\n`7*((4*x) + (x*(x-1))/2)`, where x is weeks passed\\nwhich is calculated by `x=n/7`\\nadd sum of the given week to it\\n\\n**Complexity**\\n\\nTime `O(1)`\\nSpace `O(1)`\\n\\n**C++ Code**\\n\\n```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int weekspassed = n/7;\\n        int givenWeekDays = n%7;\\n        int totalSum = 7*((4*weekspassed) + (weekspassed*(weekspassed-1))/2);\\n        int starting = weekspassed+1;\\n        for(int i=0; i<givenWeekDays; i++) {\\n            totalSum += starting;\\n            starting++;\\n        }\\n        return totalSum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int weekspassed = n/7;\\n        int givenWeekDays = n%7;\\n        int totalSum = 7*((4*weekspassed) + (weekspassed*(weekspassed-1))/2);\\n        int starting = weekspassed+1;\\n        for(int i=0; i<givenWeekDays; i++) {\\n            totalSum += starting;\\n            starting++;\\n        }\\n        return totalSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126840,
                "title": "c-o-1-time-space-100-faster-single-line",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int r = n%7 , q = n/7; return (7*q*(q+7)+ r*(r+2*q+1))/2;\\n    }\\n};\\n```\\nGive a upvote if you got it OR leave  comment for doubts : )",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int r = n%7 , q = n/7; return (7*q*(q+7)+ r*(r+2*q+1))/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016081,
                "title": "detailed-mathematical-solution-explanation-w-visual-graphs",
                "content": "So the obvious solution to this problem is a programmatic one, but this problem can also be solved in one step, mathematically.\\n\\nIn order to solve it, we can first visualize what the 2-dimensional graph result of a sample input might look like, say **n = 31**.\\n\\n![image](https://assets.leetcode.com/users/images/0b3c77f6-a4bf-4437-80b0-6fb1498e8de0_1610602161.8942583.png)\\n\\nThe first week would range in values from **1** to **7**, the second week from **2** to **8**, etc., and after four full weeks, we\\'d have an extra **3** days ranging from **5** to **7**. At this point, we can understand that the area of the graph (*shaded red*) is going to be our answer, so the problem becomes more of a geometric one rather than a coding one.\\n\\nThe natural strategy to solve a geometric problem like this is to break the graph down into manageable segments of which we can more easily find the area. In order to do this, we can opt to look for an additive assortment of repetitive shapes, like so:\\n\\n![image](https://assets.leetcode.com/users/images/34615464-56f4-43d0-9fc3-d8d8a7ab1e80_1610604453.8215835.png)\\n\\nThis allows us to solve the problem mathematically, with just a few pieces of logic. The number of large triangles (*shaded orange*) wil be the number of full weeks, and the area of each will be the **7**th triangular number. The number of long rectangles (*shaded dark green*) will be the triangular number of one less than the full number of weeks, and the area of each will be **7** times **1**. The one extra triangle (*shaded yellow*) will be the triangular number of the number of extra days. The one extra rectangle (*shaded light green*) will be the number of full weeks times the number of extra days.\\n```\\n                                                                 // for n = 31:\\n                    numWeeks = Math.ceil(n / 7)                  // Math.ceil(31 / 7) = 4\\n                     numDays = n % 7                             // 31 % 7 = 3\\n           numLgTri (orange) = numWeeks                          // 4\\n          lgTriArea (orange) = 7 * ( 7 + 1) / 2 = 28             // 28\\n     numLongRec (dark green) = numWeeks * (numWeeks - 1) / 2     // 4 * (4 - 1) / 2 = 6\\n    longRecArea (dark green) = 7 * 1 = 7                         // 7\\n       extraTriArea (yellow) = numDays * (numDays + 1) / 2       // 3 * (3 + 1) / 2 = 6\\n  extraRecArea (light green) = numDays * numWeeks                // 3 * 4 = 12\\n```\\nWith this logic, we can represent the area of the red shaded area and the answer to the problem as:\\n```\\nanswer = (numLgTri * lgTriArea) + (numLongRec * longRecArea) + extraTriArea + extraRecArea\\n    // or, filling in the constants:\\nanswer = (numLgTri * 28) + (numLongRec * 7) + extraTriArea + extraRecArea\\n    // or, filling in the known equations:\\nanswer = numWeeks * 28 + numWeeks * (numWeeks - 1) / 2 * 7 + numDays * (numDays + 1) / 2 + numDays * numWeeks\\n    // or, slightly more simply:\\nanswer = 3.5 * numWeeks ** 2 + 24.5 * numWeeks + numDays * (numDays + 1) / 2 + numDays * numWeeks\\n```\\nBut what I\\'d really like to point out is that sometimes we should look beyond the additive solution in order to include the subtractive solutions, as well. In this problem, for example, we can alternately imagine the graph thusly:\\n\\n![image](https://assets.leetcode.com/users/images/9d7de999-71b0-43dc-a397-9fb6cb0533fa_1610607414.5514367.png)\\n\\nBy viewing the solution this way, we can see that the solution is actually a bit more simple. The area of the whole large triangle is the **n**th triangular number. The number of parallelograms (*shaded dark green*) is the triangular number of one less than the full number of weeks, and the area of each will be **7** times **6**. The area of the one extra parallelogram (*shaded light green*) will be the number of extra days, times the number of weeks, times **6**.\\n```\\n                                                                 // for n = 31:\\n                    numWeeks = Math.ceil(n / 7)                  // Math.ceil(31 / 7) = 4\\n                     numDays = n % 7                             // 31 % 7 = 3\\n                    fullArea = n * (n + 1) / 2                   // 31 * (31 + 1) / 2 = 496\\n        numPara (dark green) = numWeeks * (numWeeks - 1) / 2     // 4 * (4 - 1) / 2 = 6\\n       paraArea (dark green) = 7 * 6 = 42                        // 42\\n extraParaArea (light green) = numDays * (numWeeks * 6)          // 3 * (4 * 6) = 72\\n```\\nWith this logic, we can represent the area of the red shaded area and the answer to the problem as:\\n```\\nanswer = fullArea - (numPara * paraArea) - extraParaArea\\n    // or, filling in the constant:\\nanswer = fullArea - (numPara * 42) - extraParaArea\\n    // or, filling in the known equations:\\nanswer = n * (n + 1) / 2 - numWeeks * (numWeeks - 1) / 2 * 42 - numDays * numWeeks * 6\\n    // or, slightly more simply:\\nanswer = n * (n + 1) / 2 - 21 * numWeeks * (numWeeks - 1) - 6 * numDays * numWeeks\\n```\\nAnd as there\\'s only one instance of numDays, there\\'s no real reason to have a separate variable, so the entire solution can be expressed very cleanly as:\\n```\\nweeks = Math.ceil(n / 7)\\nanswer = n * (n + 1) / 2 - 21 * weeks * (weeks - 1) - 6 * (n % 7) * weeks\\n```",
                "solutionTags": [],
                "code": "```\\n                                                                 // for n = 31:\\n                    numWeeks = Math.ceil(n / 7)                  // Math.ceil(31 / 7) = 4\\n                     numDays = n % 7                             // 31 % 7 = 3\\n           numLgTri (orange) = numWeeks                          // 4\\n          lgTriArea (orange) = 7 * ( 7 + 1) / 2 = 28             // 28\\n     numLongRec (dark green) = numWeeks * (numWeeks - 1) / 2     // 4 * (4 - 1) / 2 = 6\\n    longRecArea (dark green) = 7 * 1 = 7                         // 7\\n       extraTriArea (yellow) = numDays * (numDays + 1) / 2       // 3 * (3 + 1) / 2 = 6\\n  extraRecArea (light green) = numDays * numWeeks                // 3 * 4 = 12\\n```\n```\\nanswer = (numLgTri * lgTriArea) + (numLongRec * longRecArea) + extraTriArea + extraRecArea\\n    // or, filling in the constants:\\nanswer = (numLgTri * 28) + (numLongRec * 7) + extraTriArea + extraRecArea\\n    // or, filling in the known equations:\\nanswer = numWeeks * 28 + numWeeks * (numWeeks - 1) / 2 * 7 + numDays * (numDays + 1) / 2 + numDays * numWeeks\\n    // or, slightly more simply:\\nanswer = 3.5 * numWeeks ** 2 + 24.5 * numWeeks + numDays * (numDays + 1) / 2 + numDays * numWeeks\\n```\n```\\n                                                                 // for n = 31:\\n                    numWeeks = Math.ceil(n / 7)                  // Math.ceil(31 / 7) = 4\\n                     numDays = n % 7                             // 31 % 7 = 3\\n                    fullArea = n * (n + 1) / 2                   // 31 * (31 + 1) / 2 = 496\\n        numPara (dark green) = numWeeks * (numWeeks - 1) / 2     // 4 * (4 - 1) / 2 = 6\\n       paraArea (dark green) = 7 * 6 = 42                        // 42\\n extraParaArea (light green) = numDays * (numWeeks * 6)          // 3 * (4 * 6) = 72\\n```\n```\\nanswer = fullArea - (numPara * paraArea) - extraParaArea\\n    // or, filling in the constant:\\nanswer = fullArea - (numPara * 42) - extraParaArea\\n    // or, filling in the known equations:\\nanswer = n * (n + 1) / 2 - numWeeks * (numWeeks - 1) / 2 * 42 - numDays * numWeeks * 6\\n    // or, slightly more simply:\\nanswer = n * (n + 1) / 2 - 21 * numWeeks * (numWeeks - 1) - 6 * numDays * numWeeks\\n```\n```\\nweeks = Math.ceil(n / 7)\\nanswer = n * (n + 1) / 2 - 21 * weeks * (weeks - 1) - 6 * (n % 7) * weeks\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1015180,
                "title": "python-unique-one-liner-with-itertools-cycle",
                "content": "```python\\nfrom itertools import cycle, \\\\\\n                      repeat, \\\\\\n                      starmap\\nfrom operator import floordiv\\n\\n\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        return sum(starmap(add,zip(\\n            starmap(floordiv, zip(range(n), repeat(7, n))),\\n            cycle((1,2,3,4,5,6,7))\\n        )))\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nfrom itertools import cycle, \\\\\\n                      repeat, \\\\\\n                      starmap\\nfrom operator import floordiv\\n\\n\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        return sum(starmap(add,zip(\\n            starmap(floordiv, zip(range(n), repeat(7, n))),\\n            cycle((1,2,3,4,5,6,7))\\n        )))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008877,
                "title": "easy-python-solution-with-explanation-accepted",
                "content": "\\n\\n**Explanation**\\nFirstly, we calculate the loop of (1+2+..+7) numbers. Then we need to know the length of last item (ex: 2+3+4). \\nAfter that start to calculate the sum of each loop 1+2+3+4+5+6+7 =(7x8)/2=28. second loop 1+2+3+4+5+6+7+7=28+7=28+7x(2-1)\\nthird loop 1+2+3+4+5+6+7+7+7=28+7x2=28+7x(3-1)\\n**Complexity**\\n\\nTime ```O(N/7+N%7)```\\nSpace ```O(N)```\\n\\n**Python:**\\n```\\ndef totalMoney(self, n: int) -> int:\\n        lp = n//7\\n        if lp<1:   # when n is lower than 7\\n            return (n*(n+1))//2\\n        res = 0\\n        for i in range(1,lp+1):\\n            res += (28 + 7*(i-1))\\n        last = n%7\\n        for i in range(last):\\n            res += (lp+i+1)     # in the last loop we start from lp+1 ex: (2)+3+4  when n=10 (with only 1 full loop)\\n\\t\\treturn res\\n```",
                "solutionTags": [],
                "code": "```O(N/7+N%7)```\n```O(N)```\n```\\ndef totalMoney(self, n: int) -> int:\\n        lp = n//7\\n        if lp<1:   # when n is lower than 7\\n            return (n*(n+1))//2\\n        res = 0\\n        for i in range(1,lp+1):\\n            res += (28 + 7*(i-1))\\n        last = n%7\\n        for i in range(last):\\n            res += (lp+i+1)     # in the last loop we start from lp+1 ex: (2)+3+4  when n=10 (with only 1 full loop)\\n\\t\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3328681,
                "title": "ts-js-simple-solution",
                "content": "\\n# Code\\n```\\nfunction totalMoney(n: number): number {\\n    let balance = 0;\\n    let day = 1;\\n    let week = 0;\\n\\n    for (let i = 1; i <= n; i++) {\\n        balance = balance + (week + day );\\n        day++;\\n        \\n        if (i % 7 === 0) {\\n            week++;\\n            day = 1;\\n        }\\n    }\\n\\n    return balance;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction totalMoney(n: number): number {\\n    let balance = 0;\\n    let day = 1;\\n    let week = 0;\\n\\n    for (let i = 1; i <= n; i++) {\\n        balance = balance + (week + day );\\n        day++;\\n        \\n        if (i % 7 === 0) {\\n            week++;\\n            day = 1;\\n        }\\n    }\\n\\n    return balance;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3228344,
                "title": "simple-and-fastest-100-c-solution-pattern-find-problem",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBasically This Question Try to Test Pattern Finding Skill.\\nThis Problem has 2 things two Consider.\\n1) Firstly We Divide n by 7 ( as Week is of  Days ) So that We get Value Which Indicates that Total Number of Weeks need to Consider in Final Answer.\\n\\n2) Now We Do n%7 which gives answer between 0 to 6 which indicates Remaining Days after Step 1. So We need To calculate Sum of Savings for That n%7 days Separately.\\n\\nAs Sum of\\n \\nWeek 1 : 28\\nWeek 2 : 35\\nWeek 3 : 42\\nWeek 4 : 49\\nWeek 5 : 56\\nand so on...\\n Indicates Pattern that We only need How many Whole Week Need to Consider in answer and that We got in Step 1.\\nSo add 28+35+.. upto n/7 terms\\n\\n\\nNow , In Step 2 , We need to consider Saving For Remainig Days which is n%7.\\nSuppose Rem Day is B then B*(B+1)/2 Will be Saving at B day of Week 1.We know that we have n/7 week so n/7*b will be added to B*(B+1)/2\\n.This is Final answer of Step 2.\\n\\n3) Add Both answer of Step 1 and Step 2.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int Rem(int a)\\n    {\\n        return (a * (a+1) )/2;\\n    }\\n    int totalMoney(int n) {\\n        int ans = 0,dif=28;\\n        int a = 0;\\n\\n        a = n/7;\\n        \\n        for(int i=0;i<a;i++)\\n        {\\n            ans+=dif;\\n            dif+=7;\\n        }\\n\\n        int b = n%7;\\n        int ad = Rem(b);\\n        ad+= a*b;\\n\\n        ans+=ad;\\n\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int Rem(int a)\\n    {\\n        return (a * (a+1) )/2;\\n    }\\n    int totalMoney(int n) {\\n        int ans = 0,dif=28;\\n        int a = 0;\\n\\n        a = n/7;\\n        \\n        for(int i=0;i<a;i++)\\n        {\\n            ans+=dif;\\n            dif+=7;\\n        }\\n\\n        int b = n%7;\\n        int ad = Rem(b);\\n        ad+= a*b;\\n\\n        ans+=ad;\\n\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103041,
                "title": "c-solution-easy-to-understand",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Calculate Money in Leetcode Bank.\\nMemory Usage: 5.9 MB, less than 88.33% of C++ online submissions for Calculate Money in Leetcode Bank.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\tint totalMoney(int n) {\\n        int cost=0,sum=0,j;\\n        for(int i=0;i<n;i++){\\n            if(i%7==0){\\n                cost++;\\n                j=0;\\n            }\\n            sum=sum+cost+j;\\n            j++;\\n        }\\n       return sum; \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Calculate Money in Leetcode Bank.\\nMemory Usage: 5.9 MB, less than 88.33% of C++ online submissions for Calculate Money in Leetcode Bank.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\tint totalMoney(int n) {\\n        int cost=0,sum=0,j;\\n        for(int i=0;i<n;i++){\\n            if(i%7==0){\\n                cost++;\\n                j=0;\\n            }\\n            sum=sum+cost+j;\\n            j++;\\n        }\\n       return sum; \\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3089006,
                "title": "cpp-solution-only-using-maths-o-1-complexity",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt very first time i see the problem, it clicks in my mind that i can solve this using maths only, it took me more than a hour and finally i came up with a formula which worked.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this solution we\\'re doind addition in parts. I took ```x``` and ```y``` variables as remainder and quotient respectively. Now, we know that we have to add the money from monday to sunday and from every monday it\\'ll increase the money by 1 comparative to the last monday. So, for every complete 7 days of weeks we\\'re doing ```(28*y)```, and for increment of every week, we\\'re doing ```(7*(y*(y-1))/2)``` (by this, we\\'re adding all the increments done).\\n\\nNow, for the last days which haven\\'t completed the complete week that has to be calculated seperately. So, x is gising us the remainder which means we\\'ve to add for that last x number of days which coudn\\'t form a group. so for the series sum, I used ```((x*(x+1))/2)``` and for increment, I added ```(x*y)```, where x gives us the count of numbers in which we\\'ve to increment and y gives the weeks that has passed(e.g. in week 3, there has 2 week passed so, we\\'re getting increment of 2 in the next monday, i.e. the 3rd week will be starting from 3, 4, 5.... and so on)\\n\\nThanks for the view and comment if you\\'ve any doubt.\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int x=n%7, y=n/7;\\n        return ( (28*y) + (7*(y*(y-1))/2) + ((x*(x+1))/2) + (x*y) );\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```x```\n```y```\n```(28*y)```\n```(7*(y*(y-1))/2)```\n```((x*(x+1))/2)```\n```(x*y)```\n```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int x=n%7, y=n/7;\\n        return ( (28*y) + (7*(y*(y-1))/2) + ((x*(x+1))/2) + (x*y) );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087708,
                "title": "o-log-n-sliding-window-like-approach",
                "content": "# Complexity\\n- Time complexity: should be O(Log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n      int dollarStart = 1;\\n      int dollarEnd = 7;\\n      int sevenPeriodSum = 28;\\n      int total = 0;\\n\\n      // some what of a sliding window approach\\n      // i increment by seven and add the sum to the total\\n      // then i recalculate sevenPeriodSum and loop again\\n      // if i can sub a full week from n\\n      while ((n - 7) > 0) {\\n        total += sevenPeriodSum;\\n\\n        sevenPeriodSum -= dollarStart++;\\n        sevenPeriodSum += ++dollarEnd;\\n\\n        n -= 7;\\n      }\\n\\n      // this for loop is to clean up the last partial week\\n      // and what it does is take the dollar start week and \\n      // add it up to the last n day \\n      for (int i = 0; i < n; ++i) {\\n        total += dollarStart;\\n        ++dollarStart;\\n      }\\n\\n      return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n      int dollarStart = 1;\\n      int dollarEnd = 7;\\n      int sevenPeriodSum = 28;\\n      int total = 0;\\n\\n      // some what of a sliding window approach\\n      // i increment by seven and add the sum to the total\\n      // then i recalculate sevenPeriodSum and loop again\\n      // if i can sub a full week from n\\n      while ((n - 7) > 0) {\\n        total += sevenPeriodSum;\\n\\n        sevenPeriodSum -= dollarStart++;\\n        sevenPeriodSum += ++dollarEnd;\\n\\n        n -= 7;\\n      }\\n\\n      // this for loop is to clean up the last partial week\\n      // and what it does is take the dollar start week and \\n      // add it up to the last n day \\n      for (int i = 0; i < n; ++i) {\\n        total += dollarStart;\\n        ++dollarStart;\\n      }\\n\\n      return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2521378,
                "title": "python3-o-1-solution-faster-than-100",
                "content": "```\\n def totalMoney(self, n: int) -> int:\\n        week = n//7\\n        left = n%7\\n        total = 0\\n        if week>0:\\n\\t\\t\\t# here sum is like (1+2+3+4+5+6+7) + (2+3+...+8) + ... = 28+ 35 + ...= , so the sum is calculated by #summation formula n/2{2a + (n-1)d}\\n            total += week*(2*28 + (week-1)*7)//2\\n        total += (left*(left+1))//2 + week*left\\n        return total\\n```\\nPlease upvote if you like this solution :)",
                "solutionTags": [],
                "code": "```\\n def totalMoney(self, n: int) -> int:\\n        week = n//7\\n        left = n%7\\n        total = 0\\n        if week>0:\\n\\t\\t\\t# here sum is like (1+2+3+4+5+6+7) + (2+3+...+8) + ... = 28+ 35 + ...= , so the sum is calculated by #summation formula n/2{2a + (n-1)d}\\n            total += week*(2*28 + (week-1)*7)//2\\n        total += (left*(left+1))//2 + week*left\\n        return total\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2084531,
                "title": "100-faster-easiest-solution-beginner-friendly",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n    int sum=0;\\n    int org=n; \\n    int rem=org%7; //For finding sum when n becomes<7.\\n    int j=1,i=1,k=7;\\n        while(n>=7)\\n        {\\n            i++;  //Value for each Monday\\n            while(j<=k) //Loop iterating only seven times,also increasing the upper limit.\\n            {\\n                sum+=j;\\n                j++;\\n            }\\n            j=i; //Making j=i So that next loop starts 1 more than the previous inital value;\\n            k++;\\n            n=n-7;\\n        }\\n        while(rem) // For the remaining days which are <7.\\n        {\\n            sum=sum+j;\\n            rem--;\\n            j++;\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int totalMoney(int n) {\\n    int sum=0;\\n    int org=n; \\n    int rem=org%7; //For finding sum when n becomes<7.\\n    int j=1,i=1,k=7;\\n        while(n>=7)\\n        {\\n            i++;  //Value for each Monday\\n            while(j<=k) //Loop iterating only seven times,also increasing the upper limit.\\n            {\\n                sum+=j;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1770458,
                "title": "c-one-liner-beats-100-math-o-1-detailed-explanation",
                "content": "**Approach**\\nYou can divide problem into four parts a, b, c, d.\\nThe series is like (commented part is sum) \\n1 2 3 ... 7  // 28\\n2 3 4 ... 8  // 35\\n3 4 5 ... 9  // 42\\nYou can see I can write series as 28 + 0 + 28 + 7 + 28 + 14 + ... if n%7 == 0\\nBut if n%7 != 0 then I have to add remaining part too\\nif you look closely you can take 28 and 7 common from all terms and it will become 28*(n/7) and you can take 7 common leading to 7*(0 + 1 + 2 + ...).\\nWe can also do similar when n%7 != 0, by calculating c and d part\\n```\\nint totalMoney(int n) {\\n        //int a = 28*(n/7), b = 7*(n/7)*(n/7-1)/2, c = ((n/7)+1)*(n%7), d = ((n%7)-1)*(n%7)/2;\\n        //cout << a << \" \" << b << \" \" << c << \" \" << d << \"\\\\n\";\\n        return 28*(n/7)+7*(n/7)*(n/7-1)/2+((n/7)+1)*(n%7)+((n%7)-1)*(n%7)/2;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nint totalMoney(int n) {\\n        //int a = 28*(n/7), b = 7*(n/7)*(n/7-1)/2, c = ((n/7)+1)*(n%7), d = ((n%7)-1)*(n%7)/2;\\n        //cout << a << \" \" << b << \" \" << c << \" \" << d << \"\\\\n\";\\n        return 28*(n/7)+7*(n/7)*(n/7-1)/2+((n/7)+1)*(n%7)+((n%7)-1)*(n%7)/2;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1656210,
                "title": "java-one-line",
                "content": "```\\npublic int totalMoney(int n) {\\n\\treturn n / 7 * 28 + (n / 7 - 1) * (n / 7) / 2 * 7 + (n / 7 + 1 + n / 7 + n % 7) * (n % 7) / 2;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int totalMoney(int n) {\\n\\treturn n / 7 * 28 + (n / 7 - 1) * (n / 7) / 2 * 7 + (n / 7 + 1 + n / 7 + n % 7) * (n % 7) / 2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1622750,
                "title": "swift-o-1-math-solution-with-explanation",
                "content": "``` swift\\nclass Solution {\\n    \\n    /// Let\\'s make this problem easier:\\n    /// \\n    /// week 1:    [1, 2, 3, 4, 5, 6, 7]\\n    /// week 2:    [1+1, 2+1, 3+1, 4+1, 5+1, 6+1, 7+1] = [1, 2, 3, 4, 5, 6, 7] + 1 * 7\\n    /// week 3:    [1+2, 2+2, 3+2, 4+2, 5+2, 6+2, 7+2] = [1, 2, 3, 4, 5, 6, 7] + 2 * 7\\n    /// ......\\n    /// last week: [x, x + 1,...,x + y]\\n    ///\\n    /// so we can get the result by:\\n    ///\\n    ///     sum all entire weeks from $1~$7:\\n    ///         sum of an entire week: (1 + 7) * 7 / 2 = 28\\n    ///         entire week count: n / 7, as `count`\\n    ///         we can get:\\n    ///         28 * count\\n    ///\\n    ///     sum $1 in all entire weeks:\\n    ///         sum `1 * 7` to `(count - 1) * 7`: (1 + count - 1) * (count - 1) / 2 * 7\\n    ///         we can get:\\n    ///         (count - 1) * count / 2 * 7\\n    ///\\n    ///     sum of the last week not entire:\\n    ///         the last not entire week start from: count + 1\\n    ///         the last not entire week day count: n % 7, as `mod`, so ended at: count + mod\\n    ///         we can get:\\n    ///         (count + 1 + count + mod) * mod / 2\\n    ///\\n    /// finally the result is:\\n    ///     28 * count +\\n    ///     (count - 1) * count / 2 * 7 +\\n    ///     (count + 1 + count + mod) * mod / 2\\n    ///\\n    func totalMoney(_ n: Int) -> Int {\\n        // count of entire week\\n        let count = n / 7\\n        // the last not entire week day count\\n        let mod = n % 7\\n        // sum of all entire weeks from $1~$7\\n        return 28 * count +\\n        // sum of $1 in all entire weeks\\n               (count - 1) * count / 2 * 7 +\\n        // sum of the last week not entire\\n               (count + 1 + count + mod) * mod / 2\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Math"
                ],
                "code": "``` swift\\nclass Solution {\\n    \\n    /// Let\\'s make this problem easier:\\n    /// \\n    /// week 1:    [1, 2, 3, 4, 5, 6, 7]\\n    /// week 2:    [1+1, 2+1, 3+1, 4+1, 5+1, 6+1, 7+1] = [1, 2, 3, 4, 5, 6, 7] + 1 * 7\\n    /// week 3:    [1+2, 2+2, 3+2, 4+2, 5+2, 6+2, 7+2] = [1, 2, 3, 4, 5, 6, 7] + 2 * 7\\n    /// ......\\n    /// last week: [x, x + 1,...,x + y]\\n    ///\\n    /// so we can get the result by:\\n    ///\\n    ///     sum all entire weeks from $1~$7:\\n    ///         sum of an entire week: (1 + 7) * 7 / 2 = 28\\n    ///         entire week count: n / 7, as `count`\\n    ///         we can get:\\n    ///         28 * count\\n    ///\\n    ///     sum $1 in all entire weeks:\\n    ///         sum `1 * 7` to `(count - 1) * 7`: (1 + count - 1) * (count - 1) / 2 * 7\\n    ///         we can get:\\n    ///         (count - 1) * count / 2 * 7\\n    ///\\n    ///     sum of the last week not entire:\\n    ///         the last not entire week start from: count + 1\\n    ///         the last not entire week day count: n % 7, as `mod`, so ended at: count + mod\\n    ///         we can get:\\n    ///         (count + 1 + count + mod) * mod / 2\\n    ///\\n    /// finally the result is:\\n    ///     28 * count +\\n    ///     (count - 1) * count / 2 * 7 +\\n    ///     (count + 1 + count + mod) * mod / 2\\n    ///\\n    func totalMoney(_ n: Int) -> Int {\\n        // count of entire week\\n        let count = n / 7\\n        // the last not entire week day count\\n        let mod = n % 7\\n        // sum of all entire weeks from $1~$7\\n        return 28 * count +\\n        // sum of $1 in all entire weeks\\n               (count - 1) * count / 2 * 7 +\\n        // sum of the last week not entire\\n               (count + 1 + count + mod) * mod / 2\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594752,
                "title": "0ms-100-faster-c-using-arrays",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int arr[] = {1,2,3,4,5,6,7};\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum += arr[i%7];\\n            arr[i%7] += 1;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int arr[] = {1,2,3,4,5,6,7};\\n        int sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum += arr[i%7];\\n            arr[i%7] += 1;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234777,
                "title": "java-math-solution-o-1",
                "content": "My solution uses the concept of arithmetic progression (AP). First we calculate the total number of complete weeks. For each week start week one, we can tell that an AP is seen starting from 28 (1 + 2 + 3 + 4 + 5 + 6 + 7) going till the total number of complete weeks with a common difference of 7. \\n\\nAfter computing this, we can see that the remaining days also form an AP together. The start number will be number of weeks + 1, and this will go for all the remaining days with a common difference of 1. \\n\\nCompute the sum of these two APs and add them. Voila! You have the answer.\\n\\n```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int weeks = n/7;\\n        int rem = n%7;\\n        int start = weeks + 1;\\n        int sum = rem * (2*start + rem - 1) + 7 * weeks * (2*4 + weeks - 1);\\n        return sum/2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int weeks = n/7;\\n        int rem = n%7;\\n        int start = weeks + 1;\\n        int sum = rem * (2*start + rem - 1) + 7 * weeks * (2*4 + weeks - 1);\\n        return sum/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157091,
                "title": "rust-solution-in-1-cycle",
                "content": "```\\nimpl Solution {\\n    pub fn total_money(n: i32) -> i32 {\\n        let mut s = 0;\\n        \\n        for i in 1..=n {\\n            s += if i % 7 > 0 {\\n                (i % 7) + (i / 7)\\n            } else {\\n                6 + (i / 7)\\n            }\\n        }\\n        \\n        s\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn total_money(n: i32) -> i32 {\\n        let mut s = 0;\\n        \\n        for i in 1..=n {\\n            s += if i % 7 > 0 {\\n                (i % 7) + (i / 7)\\n            } else {\\n                6 + (i / 7)\\n            }\\n        }\\n        \\n        s\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1153312,
                "title": "c-one-line-math-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int x= n%7;\\n        n/=7;\\n        return  (n*(2*28 + (n-1)*7))/2 + ( x*(2*(n+1) + (x-1) ) )/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int x= n%7;\\n        n/=7;\\n        return  (n*(2*28 + (n-1)*7))/2 + ( x*(2*(n+1) + (x-1) ) )/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143554,
                "title": "easy-approach-using-while-loop-in-java",
                "content": "class Solution {\\n    public int totalMoney(int n) {\\n        int i=1;\\n        int k=1;\\n        int temp=1;\\n        int sum=0;\\n            while(i<=n){\\n                    sum+=k++;\\n                    if(i%7==0){\\n                          k=temp+1;\\n                            temp++;\\n                    }\\n                i++;\\n            } \\n            return sum;     \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int totalMoney(int n) {\\n        int i=1;\\n        int k=1;\\n        int temp=1;\\n        int sum=0;\\n            while(i<=n){\\n                    sum+=k++;\\n                    if(i%7==0){\\n                          k=temp+1;\\n                            temp++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1125226,
                "title": "python-easy-to-understand",
                "content": "```\\ndef totalMoney(self, n: int) -> int:\\n        \"\"\"\\n            thought:\\n                There is a pattern that every seven day appears.\\n                This pattern we can use Trapezoidal formula to solve.\\n                And the rest of day we just sum up.\\n        \"\"\"\\n        \\n        remains = n % 7\\n        head = n // 7 + 1\\n        ans = 0\\n        \\n        for i in range(1, head):\\n            ans += sum([i for i in range(i, i+7)])\\n        for i in range(head, head + remains):\\n            ans += i\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef totalMoney(self, n: int) -> int:\\n        \"\"\"\\n            thought:\\n                There is a pattern that every seven day appears.\\n                This pattern we can use Trapezoidal formula to solve.\\n                And the rest of day we just sum up.\\n        \"\"\"\\n        \\n        remains = n % 7\\n        head = n // 7 + 1\\n        ans = 0\\n        \\n        for i in range(1, head):\\n            ans += sum([i for i in range(i, i+7)])\\n        for i in range(head, head + remains):\\n            ans += i\\n        \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1120875,
                "title": "incremental-addition",
                "content": "```\\ndef totalMoney(self, n: int) -> int:\\n\\tstart = 0\\n\\ttotalSavings = 0\\n\\tprevDay = start\\n\\tfor i in range(1,n+1, 1):\\n\\t\\tif i%7 == 1:\\n\\t\\t\\tstart+=1\\n\\t\\t\\ttotalSavings+=start\\n\\t\\t\\tprevDay = start\\n\\t\\telse:\\n\\t\\t\\tprevDay+=1\\n\\t\\t\\ttotalSavings+=prevDay\\n\\treturn totalSavings\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\ndef totalMoney(self, n: int) -> int:\\n\\tstart = 0\\n\\ttotalSavings = 0\\n\\tprevDay = start\\n\\tfor i in range(1,n+1, 1):\\n\\t\\tif i%7 == 1:\\n\\t\\t\\tstart+=1\\n\\t\\t\\ttotalSavings+=start\\n\\t\\t\\tprevDay = start\\n\\t\\telse:\\n\\t\\t\\tprevDay+=1\\n\\t\\t\\ttotalSavings+=prevDay\\n\\treturn totalSavings\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1034051,
                "title": "python-just-math-w-comment",
                "content": "```py\\n\\'\\'\\'\\nwe can calculate the money accumulated by week, then by day\\n\\'\\'\\'\\n\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        w = n // 7\\n        d = n % 7\\n        \\n        \\n        base1 = 28 * w  # the total money for 1st week\\n        base2 = w + 1 if d else 0 #the money for the Monday, d > 0 means we would start a new week\\n                                    # else we should stop in previous week (on Sunday)\\n        \\n        \\n        # 1. calculate the money for previous week\\n        for i in range(1, w):\\n            base1 += i * 7\\n            \\n        \\n        # 2. calcuate the money until the current day\\n        for i in range(1,d):\\n            print(base2)\\n            base2 += (w+1+i)\\n            \\n        \\n        return base1 + base2\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```py\\n\\'\\'\\'\\nwe can calculate the money accumulated by week, then by day\\n\\'\\'\\'\\n\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        w = n // 7\\n        d = n % 7\\n        \\n        \\n        base1 = 28 * w  # the total money for 1st week\\n        base2 = w + 1 if d else 0 #the money for the Monday, d > 0 means we would start a new week\\n                                    # else we should stop in previous week (on Sunday)\\n        \\n        \\n        # 1. calculate the money for previous week\\n        for i in range(1, w):\\n            base1 += i * 7\\n            \\n        \\n        # 2. calcuate the money until the current day\\n        for i in range(1,d):\\n            print(base2)\\n            base2 += (w+1+i)\\n            \\n        \\n        return base1 + base2\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009297,
                "title": "o-1-javascript-solutions",
                "content": "solution 1: \\nthe idea is to pre-calculate the 1000 days savings on each day\\n\\n```\\nres = [1];\\nfor (let i = 1,week=1,day=1; i < 1000; i++) {\\n    if (!i%7) {\\n        week++;\\n        day = week;\\n    } else day++;\\n    res[i] = res[i-1]+day;\\n}\\nvar totalMoney = function (n,res) {\\n    return res[n-1];\\n};\\n```\\nsolution 2 :\\n\\nWe have nbWeeks= n / 7.\\n\\nThe first week we deposit (1 + 7) * 7 / 2 = 28$.\\n\\nThe wth week we deposit (w + w + 6) * 7 / 2 = (w + 3) * 7 $, the w + 1th week we deposit 7$ more.\\n\\nSo the money we deposit each week is also an arithmetic sequence, whose sum is (28 + 28 + 7 * (nbWeeks - 1)) * nbWeeks / 2 = (49 + 7 * nbWeeks) * nbWeeks / 2.\\n\\nThe last week has d = n % 7 days. We deposit nbWeeks + 1$ on its Monday, so we deposit (nbWeeks + 1 + (nbWeeks + 1 + d - 1)) * d / 2 = (2 * nbWeeks + d + 1) * d / 2 $ for that week.\\n\\nall the credits to :\\n// https://leetcode.com/lzl124631x/\\n```\\nvar totalMoney = function (n) {\\n    let nbWeeks=parseInt(n/7),d=n%7;\\n    return ((49+7*nbWeeks)*(nbWeeks/2))+((2*nbWeeks+d+1)*(d/2));\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nres = [1];\\nfor (let i = 1,week=1,day=1; i < 1000; i++) {\\n    if (!i%7) {\\n        week++;\\n        day = week;\\n    } else day++;\\n    res[i] = res[i-1]+day;\\n}\\nvar totalMoney = function (n,res) {\\n    return res[n-1];\\n};\\n```\n```\\nvar totalMoney = function (n) {\\n    let nbWeeks=parseInt(n/7),d=n%7;\\n    return ((49+7*nbWeeks)*(nbWeeks/2))+((2*nbWeeks+d+1)*(d/2));\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1009139,
                "title": "java-simple-java-solution-o-n",
                "content": "if you like it pls upvote\\n\\nJAVA \\n```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int res = 0;\\n        int monday = 0;\\n        int cur = 1;\\n        for(int i = 0;i<n;i++){\\n            if(i%7 == 0){\\n                monday++;\\n                cur = monday;\\n            }\\n            res+=cur++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int res = 0;\\n        int monday = 0;\\n        int cur = 1;\\n        for(int i = 0;i<n;i++){\\n            if(i%7 == 0){\\n                monday++;\\n                cur = monday;\\n            }\\n            res+=cur++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008986,
                "title": "java-o-1-with-explanation",
                "content": "```\\nSum of n natural numbers = n * (n + 1) / 2 \\n\\nSum for each week:\\nT(1) = 7 * 8 / 2 = 28\\nT(2) = 1*7 + 28\\nT(3) = 2*7 + 28\\nT(4) = 3*7 + 28\\nT(K) = (k-1)*7 + 28\\n\\nTotal sum for k weeks = T(1) + T(2) ..... T(K)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  = 28 + 1*7 + 28 + 2*7 + 28 .... + (k-1) * 7 + 28\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  = 28 * k + 7(sum to k-1)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  = 28 k + 7 . k . (K - 1) / 2\\n\\nSum of n days of kth week = n * k + n * (n + 1) / 2\\n```\\n\\n**Java Solution:**\\n\\n```\\n    public int totalMoney(int n) {\\n        int weeks = n / 7;\\n        int days_left = n % 7;\\n        return (28 * weeks + 7 * weeks * (weeks - 1) / 2) + (days_left * weeks + days_left * (days_left + 1) / 2);\\n    }\\n```\\n\\t\\t\\t\\t",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nSum of n natural numbers = n * (n + 1) / 2 \\n\\nSum for each week:\\nT(1) = 7 * 8 / 2 = 28\\nT(2) = 1*7 + 28\\nT(3) = 2*7 + 28\\nT(4) = 3*7 + 28\\nT(K) = (k-1)*7 + 28\\n\\nTotal sum for k weeks = T(1) + T(2) ..... T(K)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  = 28 + 1*7 + 28 + 2*7 + 28 .... + (k-1) * 7 + 28\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  = 28 * k + 7(sum to k-1)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  = 28 k + 7 . k . (K - 1) / 2\\n\\nSum of n days of kth week = n * k + n * (n + 1) / 2\\n```\n```\\n    public int totalMoney(int n) {\\n        int weeks = n / 7;\\n        int days_left = n % 7;\\n        return (28 * weeks + 7 * weeks * (weeks - 1) / 2) + (days_left * weeks + days_left * (days_left + 1) / 2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1008891,
                "title": "normal-c-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int j =1;\\n        int sum =0;\\n        int count =j;\\n       for(int i=1; i<=n; i++){\\n             if(i%7==1 && i!=1){\\n                 j++;\\n                 count =j;\\n             }\\n            //cout<<count<<endl;\\n            sum+=count;\\n           count++;\\n       } \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int j =1;\\n        int sum =0;\\n        int count =j;\\n       for(int i=1; i<=n; i++){\\n             if(i%7==1 && i!=1){\\n                 j++;\\n                 count =j;\\n             }\\n            //cout<<count<<endl;\\n            sum+=count;\\n           count++;\\n       } \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1008870,
                "title": "simple-java-solution",
                "content": "```  \\n/* Simply add natural number sum keeping track of startMoney on Monday. EndMoney is  amount \\non last day of the corresponding week ( For first week, endMoney = 7)*/\\npublic int totalMoney(int n) {\\n        int weeks = n / 7 ;\\n        int days = n % 7;\\n        int endMoney = 7;\\n        int ans = 0;\\n        \\n        for (int i = 1 ; i <= weeks ; i++) {\\n\\t\\t\\t//Need to substract sum of natural number upto startMoney on Monday.\\n            ans += (endMoney * (endMoney+1) ) / 2 - ((i - 1) * (i) )/ 2;\\n            endMoney++;\\n        }\\n        \\n        int count = 1;\\n        for (int i = count ; i <= days ; i++) {          \\n            ans += weeks + count++;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```  \\n/* Simply add natural number sum keeping track of startMoney on Monday. EndMoney is  amount \\non last day of the corresponding week ( For first week, endMoney = 7)*/\\npublic int totalMoney(int n) {\\n        int weeks = n / 7 ;\\n        int days = n % 7;\\n        int endMoney = 7;\\n        int ans = 0;\\n        \\n        for (int i = 1 ; i <= weeks ; i++) {\\n\\t\\t\\t//Need to substract sum of natural number upto startMoney on Monday.\\n            ans += (endMoney * (endMoney+1) ) / 2 - ((i - 1) * (i) )/ 2;\\n            endMoney++;\\n        }\\n        \\n        int count = 1;\\n        for (int i = count ; i <= days ; i++) {          \\n            ans += weeks + count++;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1008858,
                "title": "java-o-1",
                "content": "```\\n    private int sln2(int n){\\n        int m = (n-1)/7;\\n        int k = (n-1)%7+1;\\n        int sum1 = (28+28+(m-1)*7)*m/2;\\n        int sum2 = (m+1+m+k)*k/2;\\n        return sum1+sum2;\\n    }\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "```\\n    private int sln2(int n){\\n        int m = (n-1)/7;\\n        int k = (n-1)%7+1;\\n        int sum1 = (28+28+(m-1)*7)*m/2;\\n        int sum2 = (m+1+m+k)*k/2;\\n        return sum1+sum2;\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1008853,
                "title": "kt-js-py3-cpp-iterative-accumulation",
                "content": "**Synopsis:**\\n\\nLet `x` be the monotonically increasing amount of money we can save each `day`.  Return the `total` acummulated savings.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun totalMoney(n: Int): Int {\\n        var total = 0\\n        var start = 1\\n        var x = 0\\n        for (day in 0 until n) {\\n            if (day % 7 == 0)\\n                x = start++\\n            total += x++\\n        }\\n        return total\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet totalMoney = (n, start = 1, day = 0, x = 0, total = 0) => {\\n    while (n--) {\\n        if (day++ % 7 == 0)\\n            x = start++;\\n        total += x++;\\n    }\\n    return total;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def totalMoney(self, n: int, start = 1, x = 0, total = 0) -> int:\\n        for day in range(n):\\n            if day % 7 == 0:\\n                x = start; start += 1\\n            total += x; x += 1\\n        return total\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    int totalMoney(int n, int start = 1, int day = 0, int x = 0, int total = 0) {\\n        while (n--) {\\n            if (day++ % 7 == 0)\\n                x = start++;\\n            total += x++;\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun totalMoney(n: Int): Int {\\n        var total = 0\\n        var start = 1\\n        var x = 0\\n        for (day in 0 until n) {\\n            if (day % 7 == 0)\\n                x = start++\\n            total += x++\\n        }\\n        return total\\n    }\\n}\\n```\n```\\nlet totalMoney = (n, start = 1, day = 0, x = 0, total = 0) => {\\n    while (n--) {\\n        if (day++ % 7 == 0)\\n            x = start++;\\n        total += x++;\\n    }\\n    return total;\\n};\\n```\n```\\nclass Solution:\\n    def totalMoney(self, n: int, start = 1, x = 0, total = 0) -> int:\\n        for day in range(n):\\n            if day % 7 == 0:\\n                x = start; start += 1\\n            total += x; x += 1\\n        return total\\n```\n```\\nclass Solution {\\npublic:\\n    int totalMoney(int n, int start = 1, int day = 0, int x = 0, int total = 0) {\\n        while (n--) {\\n            if (day++ % 7 == 0)\\n                x = start++;\\n            total += x++;\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042454,
                "title": "fastest-solution-in-java-o-1-beats-100",
                "content": "# Intuition\\nsimple solution based on weeks and the remaining days\\n\\n# Approach\\nusing the sum of natural numbers,\\n->Find the number of weeks and the remaining Odd days\\n->If weeks is 0 , just find the sum of days and return\\n->Find the number of extra 7\\'s we need and multiply it with 7 and it to the result.\\n->multiply the sum of the week or 28 with the number of weeks and add to the result.\\n->Find the sum of odd days and add into the result.\\n->Finally multiply weeks and oddDays to the result.\\n\\nHope it helps, if you find any trouble just Contact me.\\n -> balajileo19@gmail.com\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        return ((n/7*(n/7-1))/2 * 7) + (n/7 * 28) + (((n%7)*((n%7)+1)) /2) + (n/7 * (n%7));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        return ((n/7*(n/7-1))/2 * 7) + (n/7 * 28) + (((n%7)*((n%7)+1)) /2) + (n/7 * (n%7));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015868,
                "title": "c-one-line",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int TotalMoney(int n) =>\\n        Enumerable.Range(1, n).Select((val, index) => (val % 7 == 0 ? 7 : val % 7) + index / 7).Sum();\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int TotalMoney(int n) =>\\n        Enumerable.Range(1, n).Select((val, index) => (val % 7 == 0 ? 7 : val % 7) + index / 7).Sum();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996268,
                "title": "o-1-very-beginner-s-friendly-approach",
                "content": "# Intuition\\nRepition and increment after a week\\n# Approach\\nif weekly the price is increasing means we have to use loop and reset certain values like here we are doing for the day \\n\\n# Complexity\\n- Time complexity:O(1)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n    int total = 0;\\n    int currentMoney = 1; // Amount of money Hercy puts in on the current day\\n    int week = 1; // Keep track of the current week\\n\\n    for (int day = 1, i = 1; i <= n; i++) {\\n        total += currentMoney; // Add the money for the current day\\n        currentMoney++; // Increment the money for the next day\\n\\n        if (day == 7) {\\n            // If it\\'s Sunday (day 7), start a new week on Monday\\n            day = 1;\\n            currentMoney = week + 1; // Reset the daily amount to (week + 1)\\n            week++; // Increment the week\\n        } else {\\n            day++; // Move to the next day\\n        }\\n    }\\n    return total;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n    int total = 0;\\n    int currentMoney = 1; // Amount of money Hercy puts in on the current day\\n    int week = 1; // Keep track of the current week\\n\\n    for (int day = 1, i = 1; i <= n; i++) {\\n        total += currentMoney; // Add the money for the current day\\n        currentMoney++; // Increment the money for the next day\\n\\n        if (day == 7) {\\n            // If it\\'s Sunday (day 7), start a new week on Monday\\n            day = 1;\\n            currentMoney = week + 1; // Reset the daily amount to (week + 1)\\n            week++; // Increment the week\\n        } else {\\n            day++; // Move to the next day\\n        }\\n    }\\n    return total;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693770,
                "title": "calculate-money-in-leetcode-bank-java-solution-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int sum = 0;\\n        int count = 1;\\n        int temp_count = 2;\\n\\n        for(int i=1; i<=n; i++){\\n            sum+=count;\\n            count++;\\n\\n            if(i%7==0){\\n                count = temp_count;\\n                temp_count++;\\n            }\\n            \\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int sum = 0;\\n        int count = 1;\\n        int temp_count = 2;\\n\\n        for(int i=1; i<=n; i++){\\n            sum+=count;\\n            count++;\\n\\n            if(i%7==0){\\n                count = temp_count;\\n                temp_count++;\\n            }\\n            \\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287719,
                "title": "python-elegant-short-true-o-1-math-divmod",
                "content": "```\\nclass Solution:\\n    N = 7\\n\\n    def totalMoney(self, n: int) -> int:\\n        weeks, days = divmod(n, self.N)\\n        return weeks * self.N * (self.N + weeks) // 2 + weeks * days + days * (days + 1) // 2\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    N = 7\\n\\n    def totalMoney(self, n: int) -> int:\\n        weeks, days = divmod(n, self.N)\\n        return weeks * self.N * (self.N + weeks) // 2 + weeks * days + days * (days + 1) // 2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202732,
                "title": "calculate-money-in-leetcode-bank-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int i, j, k, sum=0;\\n        i = n/7;\\n        j = n%7;\\n        for(k=1 ; k<=i ; k++)\\n        {\\n            if(k==1)\\n            {\\n                sum += 28;\\n            }\\n            else\\n            {\\n                sum += 7*(3+k);\\n            }\\n        }\\n        for(k=0 ; k<j ; k++)\\n        {\\n            sum += (i+1+k);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int i, j, k, sum=0;\\n        i = n/7;\\n        j = n%7;\\n        for(k=1 ; k<=i ; k++)\\n        {\\n            if(k==1)\\n            {\\n                sum += 28;\\n            }\\n            else\\n            {\\n                sum += 7*(3+k);\\n            }\\n        }\\n        for(k=0 ; k<j ; k++)\\n        {\\n            sum += (i+1+k);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975710,
                "title": "easy-java-solution-1ms-only",
                "content": "\\n- Time complexity: O(n)\\n \\n```\\nclass Solution {\\n    public int totalMoney(int n) {\\n\\n        int i=1,j=0,sum=0,count=1,su=1;\\n        while(i!=n+1)\\n        {\\n            if(j==7)\\n            {\\n                su++;\\n                count=su;\\n                sum+=count;\\n                count++;\\n                j=1;\\n            }\\n            else\\n            {\\n                sum+=count;\\n                count++;\\n                j++;\\n            }\\n            i++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int totalMoney(int n) {\\n\\n        int i=1,j=0,sum=0,count=1,su=1;\\n        while(i!=n+1)\\n        {\\n            if(j==7)\\n            {\\n                su++;\\n                count=su;\\n                sum+=count;\\n                count++;\\n                j=1;\\n            }\\n            else\\n            {\\n                sum+=count;\\n                count++;\\n                j++;\\n            }\\n            i++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2911173,
                "title": "simple-cpp",
                "content": "\\n    int totalMoney(int n) {\\n        int sum=0;\\n        int cnt=0;\\n\\n        for(int i=1;i<=n;i++){\\n            for(int j=i;j<=6+i;j++){\\n                cnt++;\\n                if(cnt<=n){\\n                    sum=sum+j;\\n                }\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n    int totalMoney(int n) {\\n        int sum=0;\\n        int cnt=0;\\n\\n        for(int i=1;i<=n;i++){\\n            for(int j=i;j<=6+i;j++){\\n                cnt++;\\n                if(cnt<=n){\\n                    sum=sum+j;\\n                }\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2888659,
                "title": "c-simple-solution-less-than-71",
                "content": "![image.png](https://assets.leetcode.com/users/images/a4cc4b1c-05ca-41af-af9c-2c5e87d09c0e_1670447620.970576.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int TotalMoney(int n) {\\n        int counter = 0;\\n        int week = 0;\\n        int dayRate = 1;\\n        for (int i = 1; i <= n; i++)\\n        {\\n            counter += dayRate++ + week;\\n            if (i % 7 == 0)\\n            {\\n                week++;\\n                dayRate = 1;\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#",
                    "Math"
                ],
                "code": "```\\npublic class Solution {\\n    public int TotalMoney(int n) {\\n        int counter = 0;\\n        int week = 0;\\n        int dayRate = 1;\\n        for (int i = 1; i <= n; i++)\\n        {\\n            counter += dayRate++ + week;\\n            if (i % 7 == 0)\\n            {\\n                week++;\\n                dayRate = 1;\\n            }\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879490,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int i,j,k,a,b,x=1,y=7,sum=0;\\n        a=n/7;\\n        b=n%7;\\n        for(i=1;i<=a;i++)\\n        {\\n            for(j=x;j<=y;j++)\\n            {\\n                sum+=j;\\n            }\\n            x++;\\n            y++;\\n        }\\n        for(k=1;k<=b;k++)\\n        {\\n            sum+=x;\\n            x++;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int i,j,k,a,b,x=1,y=7,sum=0;\\n        a=n/7;\\n        b=n%7;\\n        for(i=1;i<=a;i++)\\n        {\\n            for(j=x;j<=y;j++)\\n            {\\n                sum+=j;\\n            }\\n            x++;\\n            y++;\\n        }\\n        for(k=1;k<=b;k++)\\n        {\\n            sum+=x;\\n            x++;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780104,
                "title": "just-one-while-java",
                "content": "# Intuition\\nPlease upvote if you find it useful\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int sum=0;\\n        int m=1;\\n        while(true){\\n            if(n>=7){\\n                sum+=(2*m+6)*7/2;\\n                n-=7;\\n                m++;\\n            }else if(n==0){\\n                break;\\n            }else{\\n                sum+=(2*m+n-1)*n/2;\\n                break;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int sum=0;\\n        int m=1;\\n        while(true){\\n            if(n>=7){\\n                sum+=(2*m+6)*7/2;\\n                n-=7;\\n                m++;\\n            }else if(n==0){\\n                break;\\n            }else{\\n                sum+=(2*m+n-1)*n/2;\\n                break;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739200,
                "title": "calculate-money-in-leetcode-bank-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int ans=0;\\n        int subseq=1;\\n        for(int i=1;i<=n;++i)\\n        {\\n            if(i%7==0)\\n            {\\n                ans+=(6+subseq);\\n                subseq++;\\n                continue;\\n            }\\n            ans+=(subseq+((i%7)-1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int ans=0;\\n        int subseq=1;\\n        for(int i=1;i<=n;++i)\\n        {\\n            if(i%7==0)\\n            {\\n                ans+=(6+subseq);\\n                subseq++;\\n                continue;\\n            }\\n            ans+=(subseq+((i%7)-1));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691286,
                "title": "python-faster-than-98",
                "content": "```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        # sumx = (n*(n+1))//2\\n        # n goes from 1 to 2 as we see into next week\\n        def ap(a):\\n            return (7*(2*a + 6))//2  # Sn = n/2 * (2a + (n-1)d)\\n        \\n        factor = n // 7\\n        rem = n % 7\\n        ans = 0\\n        start = 1\\n        \\n        for i in range(factor):\\n            ans += ap(start)\\n            start += 1\\n        sumx = 0\\n        for i in range(rem):\\n            sumx += start\\n            start += 1\\n\\t\\t\\t\\n        return ans + sumx",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        # sumx = (n*(n+1))//2\\n        # n goes from 1 to 2 as we see into next week\\n        def ap(a):\\n            return (7*(2*a + 6))//2  # Sn = n/2 * (2a + (n-1)d)\\n        \\n        factor = n // 7\\n        rem = n % 7\\n        ans = 0\\n        start = 1\\n        \\n        for i in range(factor):\\n            ans += ap(start)\\n            start += 1\\n        sumx = 0\\n        for i in range(rem):\\n            sumx += start\\n            start += 1\\n\\t\\t\\t\\n        return ans + sumx",
                "codeTag": "Java"
            },
            {
                "id": 2599747,
                "title": "100-time-48ms-o-1-javascript-using-triangular-number-formula-w-comments",
                "content": "```\\nvar totalMoney = function(n) {\\n    /*\\n    Exploring the numbers for insights\\n\\tShows the weekly amounts, the weekly totals, the running total, and the related triangular number\\n    01 02 03 04 05 06 07 = 28 = 7*4 | 7*4  | 10 tri(4)\\n    02 03 04 05 06 07 08 = 35 = 7*5 | 7*9  | 15 tri(5)\\n    03 04 05 06 07 08 09 = 42 = 7*6 | 7*15 | 21 tri(6)\\n    04 05 06 07 08 09 10 = 49 = 7*7 | 7*22 | 28 tri(7)\\n    05 06 07 08 09 10 11 = 56 = 7*8 | 7*30 | 36 tri(8)\\n    06 07 08 09 10 11 12 = 63 = 7*9 | 7*39 | 45 tri(9)\\n    07 08 09 10 11 12 13 = 70 = 7*10| 7*49 | 55 tri(10)\\n    */\\n    //Original Math Approach\\n    /*\\n    const tri = n => (n * (n + 1)) / 2; //Gets triangular number n\\n    const wksTot = n => 7 * (tri(n + 3) - 6); //Gets total at end of week n note:6 is tri(3)\\n    const wks = ~~(n / 7); //Total number of complete weeks\\n    const days = n % 7; //Total number of days in final partial week\\n    return wksTot(wks) + (days * wks) + tri(days);\\n    */\\n    \\n    //Mathematical approach, with conditionals to optimize\\n    let wksTot = 0; //Default the total across all weeks to 0\\n    let daysTot = 0; //Default the total across the partial week at the end to 0\\n    let wks = ~~(n / 7); //shorthand to truncate number of full weeks\\n    let days = n % 7; //Get remaining number of days\\n    const tri = n => (n * (n + 1)) / 2; //Helper function to get triangular number n 1,3,6 etc.\\n    if(days > 0) { //If there is a partial week at the end, calculate daysTot\\n        daysTot = (days * wks) + tri(days);\\n    }\\n    if(n >= 7) { //If there is at least one complete week, calculate wksTot\\n        wksTot = 7 * (tri(wks + 3) - 6); //Gets total at end of week n note:6 is tri(3)   \\n    }\\n    return wksTot + daysTot;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar totalMoney = function(n) {\\n    /*\\n    Exploring the numbers for insights\\n\\tShows the weekly amounts, the weekly totals, the running total, and the related triangular number\\n    01 02 03 04 05 06 07 = 28 = 7*4 | 7*4  | 10 tri(4)\\n    02 03 04 05 06 07 08 = 35 = 7*5 | 7*9  | 15 tri(5)\\n    03 04 05 06 07 08 09 = 42 = 7*6 | 7*15 | 21 tri(6)\\n    04 05 06 07 08 09 10 = 49 = 7*7 | 7*22 | 28 tri(7)\\n    05 06 07 08 09 10 11 = 56 = 7*8 | 7*30 | 36 tri(8)\\n    06 07 08 09 10 11 12 = 63 = 7*9 | 7*39 | 45 tri(9)\\n    07 08 09 10 11 12 13 = 70 = 7*10| 7*49 | 55 tri(10)\\n    */\\n    //Original Math Approach\\n    /*\\n    const tri = n => (n * (n + 1)) / 2; //Gets triangular number n\\n    const wksTot = n => 7 * (tri(n + 3) - 6); //Gets total at end of week n note:6 is tri(3)\\n    const wks = ~~(n / 7); //Total number of complete weeks\\n    const days = n % 7; //Total number of days in final partial week\\n    return wksTot(wks) + (days * wks) + tri(days);\\n    */\\n    \\n    //Mathematical approach, with conditionals to optimize\\n    let wksTot = 0; //Default the total across all weeks to 0\\n    let daysTot = 0; //Default the total across the partial week at the end to 0\\n    let wks = ~~(n / 7); //shorthand to truncate number of full weeks\\n    let days = n % 7; //Get remaining number of days\\n    const tri = n => (n * (n + 1)) / 2; //Helper function to get triangular number n 1,3,6 etc.\\n    if(days > 0) { //If there is a partial week at the end, calculate daysTot\\n        daysTot = (days * wks) + tri(days);\\n    }\\n    if(n >= 7) { //If there is at least one complete week, calculate wksTot\\n        wksTot = 7 * (tri(wks + 3) - 6); //Gets total at end of week n note:6 is tri(3)   \\n    }\\n    return wksTot + daysTot;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2521788,
                "title": "c-easy-solution",
                "content": "```\\nint totalMoney(int n) \\n{\\n\\tint money = 0;\\n\\tint week = n / 7;\\n\\tint day = n % 7;\\n\\n\\tfor(int i=1; i<=week; i++)\\n\\t\\tmoney += (i+3)*7;\\n\\n\\tfor(int j=1; j<=day; j++)\\n\\t\\tmoney += ++week;\\n\\n\\treturn money;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint totalMoney(int n) \\n{\\n\\tint money = 0;\\n\\tint week = n / 7;\\n\\tint day = n % 7;\\n\\n\\tfor(int i=1; i<=week; i++)\\n\\t\\tmoney += (i+3)*7;\\n\\n\\tfor(int j=1; j<=day; j++)\\n\\t\\tmoney += ++week;\\n\\n\\treturn money;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2520012,
                "title": "java-fastest-solution",
                "content": "```class Solution {\\n    public int totalMoney(int n) \\n    {\\n        int week=n/7;\\n        int rem=n%7;\\n        \\n        int z=28*week+(7*(week-1)*week)/2+ week*rem+(rem*(rem+1)/2);\\n       \\n        return z;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int totalMoney(int n) \\n    {\\n        int week=n/7;\\n        int rem=n%7;\\n        \\n        int z=28*week+(7*(week-1)*week)/2+ week*rem+(rem*(rem+1)/2);\\n       \\n        return z;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2501610,
                "title": "o-1-time-math-solution",
                "content": "```\\nfunc totalMoney(n int) int {\\n    w := n/7\\n    d := n%7\\n    res:=7*((w-1)*w)/2+28*w+(d+d*d)/2+w*d\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc totalMoney(n int) int {\\n    w := n/7\\n    d := n%7\\n    res:=7*((w-1)*w)/2+28*w+(d+d*d)/2+w*d\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2386670,
                "title": "c-and-java-runtime-0ms-faster-than-100-easy-understanding-solution",
                "content": "**C++ Solution**\\n```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int i=0, ret=0;\\n        \\n        for(; i<n/7; i++)\\n            ret+=(28+(7*i));  // 28 is money saved in 1 week\\n        \\n        for(int j=1; j<=n%7; j++)\\n            ret+=(j+i);\\n        \\n        return ret;\\n    }\\n};\\n```\\n**Java Solution**\\n```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int i=0, ret=0;\\n        \\n        for(; i<n/7; i++)\\n            ret+=(28+(7*i));  // 28 is money saved in 1 week\\n        \\n        for(int j=1; j<=n%7; j++)\\n            ret+=(j+i);\\n        \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int i=0, ret=0;\\n        \\n        for(; i<n/7; i++)\\n            ret+=(28+(7*i));  // 28 is money saved in 1 week\\n        \\n        for(int j=1; j<=n%7; j++)\\n            ret+=(j+i);\\n        \\n        return ret;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int i=0, ret=0;\\n        \\n        for(; i<n/7; i++)\\n            ret+=(28+(7*i));  // 28 is money saved in 1 week\\n        \\n        for(int j=1; j<=n%7; j++)\\n            ret+=(j+i);\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351676,
                "title": "easy-java-solution",
                "content": "```   \\npublic int totalMoney(int n) {\\n        int seven = n/7;\\n        int val = 7;\\n        int ans = 0;\\n        int i =1;\\n        for(i=1;i<=seven;i++){\\n            ans += val*(val+1)/2-((i)*(i-1)/2);\\n            val++;\\n        }\\n        val -= 6;\\n        for(i=0;i<n%7;i++){\\n            ans += val;\\n            val++;\\n        }\\n        return ans;\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```   \\npublic int totalMoney(int n) {\\n        int seven = n/7;\\n        int val = 7;\\n        int ans = 0;\\n        int i =1;\\n        for(i=1;i<=seven;i++){\\n            ans += val*(val+1)/2-((i)*(i-1)/2);\\n            val++;\\n        }\\n        val -= 6;\\n        for(i=0;i<n%7;i++){\\n            ans += val;\\n            val++;\\n        }\\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2308333,
                "title": "accepted-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int j=1,sum = 0;\\n        for(int i = 1;i<n+1;i++){\\n            sum += (j++);\\n            if(i%7 == 0){\\n                j = j-6;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int j=1,sum = 0;\\n        for(int i = 1;i<n+1;i++){\\n            sum += (j++);\\n            if(i%7 == 0){\\n                j = j-6;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2157789,
                "title": "swift-runtime-100-memory-100",
                "content": "```\\nclass Solution {\\n    func totalMoney(_ n: Int) -> Int {\\n        var money = 0\\n        for i in 0 ..< n {\\n            money += i % 7 + i / 7 + 1\\n        }\\n        return money\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/e5e8afce-aa4f-489a-8c06-98ba69891fb1_1655365126.8127213.png)\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func totalMoney(_ n: Int) -> Int {\\n        var money = 0\\n        for i in 0 ..< n {\\n            money += i % 7 + i / 7 + 1\\n        }\\n        return money\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106948,
                "title": "java-easy-solution",
                "content": "```\\npublic int totalMoney(int n) {\\n        int ans=0;\\n        int k=0;\\n        while(true){\\n            for(int i=1;i<8;i++){\\n                ans+=i+k;\\n                n--;\\n                if(n==0) return ans;\\n            }\\n            k++;\\n        }\\n        \\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int totalMoney(int n) {\\n        int ans=0;\\n        int k=0;\\n        while(true){\\n            for(int i=1;i<8;i++){\\n                ans+=i+k;\\n                n--;\\n                if(n==0) return ans;\\n            }\\n            k++;\\n        }\\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2031947,
                "title": "easy-java-solution-totalmoney",
                "content": "class Solution {\\n    public int totalMoney(int n) {\\n        \\n        int sum = 0, num = 1;\\n        int a = 2, b = 1;\\n        \\n        for (int i = 0; i < n; i++){\\n            if (b % 8 == 0){\\n                num = a;\\n                a++;\\n                b = 1;\\n            }\\n            \\n            sum += num;\\n            num += 1;\\n            b++;\\n        }\\n        \\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int totalMoney(int n) {\\n        \\n        int sum = 0, num = 1;\\n        int a = 2, b = 1;\\n        \\n        for (int i = 0; i < n; i++){\\n            if (b % 8 == 0){\\n                num = a;\\n                a++;\\n                b = 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1949965,
                "title": "java-solution-0ms-100-math",
                "content": "```\\nclass Solution {\\n    public int totalMoney(int n) {\\n      int weekly = n/7;\\n      int daily = n%7;  \\n      return getWeeklyMoney(weekly)+getDailyMoney(daily, weekly+1);  \\n    }\\n    \\n    public int getWeeklyMoney(int w) {\\n        int sum =0;\\n        if(w==0) return sum;\\n        for(int i=1; i<=w; i++) {\\n            sum += (28 + 7*(i-1)) ;\\n        }\\n        return sum;\\n    }\\n    \\n    public int getDailyMoney(int d, int w) {\\n        int sum = 0;\\n        for(int i= w; i< d+w; i++) {\\n            sum= sum + i;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int totalMoney(int n) {\\n      int weekly = n/7;\\n      int daily = n%7;  \\n      return getWeeklyMoney(weekly)+getDailyMoney(daily, weekly+1);  \\n    }\\n    \\n    public int getWeeklyMoney(int w) {\\n        int sum =0;\\n        if(w==0) return sum;\\n        for(int i=1; i<=w; i++) {\\n            sum += (28 + 7*(i-1)) ;\\n        }\\n        return sum;\\n    }\\n    \\n    public int getDailyMoney(int d, int w) {\\n        int sum = 0;\\n        for(int i= w; i< d+w; i++) {\\n            sum= sum + i;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942706,
                "title": "easy-java-solution-using-arrays",
                "content": "```\\nclass Solution {\\n    public int totalMoney(int n) \\n    {\\n        int arr[]=new int[8];\\n        for(int i=0;i<8;i++)\\n            arr[i]=i;\\n        int c=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(i>7)\\n            {\\n                if(i%7!=0)\\n                {\\n                    arr[i%7]++;\\n                    c+=arr[i%7];\\n                }\\n                else\\n                {\\n                    arr[7]++;\\n                    c+=arr[7];\\n                }\\n            }\\n            else\\n                c+=i;\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int totalMoney(int n) \\n    {\\n        int arr[]=new int[8];\\n        for(int i=0;i<8;i++)\\n            arr[i]=i;\\n        int c=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(i>7)\\n            {\\n                if(i%7!=0)\\n                {\\n                    arr[i%7]++;\\n                    c+=arr[i%7];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1935941,
                "title": "java-easy-solution-2-ms",
                "content": "```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int i=0, sum = 0, totCount = 1,check = 1;\\n        int j = n/7;\\n        while(j>=0){\\n            i = check;\\n            int count = 0;\\n            while(count < 7 && totCount <= n){\\n                sum += i;\\n                i++;\\n                count++;\\n                totCount++;\\n            }\\n            j--;\\n            check++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int i=0, sum = 0, totCount = 1,check = 1;\\n        int j = n/7;\\n        while(j>=0){\\n            i = check;\\n            int count = 0;\\n            while(count < 7 && totCount <= n){\\n                sum += i;\\n                i++;\\n                count++;\\n                totCount++;\\n            }\\n            j--;\\n            check++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1933680,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int sum=0;\\n        int a=n/7;\\n\\t\\t //calculating weekly deposit\\n        while(a!=0)\\n        {\\n            sum+=28+(a-1)*7;\\n            a--;\\n        }\\n\\t\\t//calculating left days deposit\\n        while(n%7!=0)\\n        {\\n            sum+=n/7+n%7;\\n            n--;\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int totalMoney(int n) {\\n        int sum=0;\\n        int a=n/7;\\n\\t\\t //calculating weekly deposit\\n        while(a!=0)\\n        {\\n            sum+=28+(a-1)*7;\\n            a--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1812289,
                "title": "java-solution-simple-math-o-1-0ms-100-faster-with-explanation",
                "content": "Simple maths problem\\nExplanation in comments\\n...\\n\\n\\tpublic int totalMoney(int n) {\\n        //mu calculation\\n        int w = n / 7, d = n % 7;\\n        \\n        //money saved in total weeks\\n        int weekMoney = (w * (56 + (w - 1) * 7)) / 2;\\n        //calculation is 28 is sum of first week\\n        //then every week sum behaves like A.P\\n        //28, 35, 42, 49,... -> use sum of A.p\\n        //S = n/2 * (2a + (n - 1) * d)\\n        \\n        //days money\\n        int dayMoney = (d*(d + 1))/2 + d * w;\\n        //sum of money in d days for first week -> sum of d natural numbers\\n        //for any day in any week money on that day is x more than the money of that day in first week\\n        //x is no of weeks before this week\\n        //e.g Monday of 3rd week -> 3 i.e 2 more than Mon of 1st week, 2 weeks completed\\n        //so for d days the difference b/w sum of d days in this week and in 1st weel = d * w\\n        \\n        int total = weekMoney + dayMoney;\\n        \\n        return total;\\n    }\\n\\n...\\nUpvote if you want.\\nAsk in comments if you have any doubt.",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "Simple maths problem\\nExplanation in comments\\n...\\n\\n\\tpublic int totalMoney(int n) {\\n        //mu calculation\\n        int w = n / 7, d = n % 7;\\n        \\n        //money saved in total weeks\\n        int weekMoney = (w * (56 + (w - 1) * 7)) / 2;\\n        //calculation is 28 is sum of first week\\n        //then every week sum behaves like A.P\\n        //28, 35, 42, 49,... -> use sum of A.p\\n        //S = n/2 * (2a + (n - 1) * d)\\n        \\n        //days money\\n        int dayMoney = (d*(d + 1))/2 + d * w;\\n        //sum of money in d days for first week -> sum of d natural numbers\\n        //for any day in any week money on that day is x more than the money of that day in first week\\n        //x is no of weeks before this week\\n        //e.g Monday of 3rd week -> 3 i.e 2 more than Mon of 1st week, 2 weeks completed\\n        //so for d days the difference b/w sum of d days in this week and in 1st weel = d * w\\n        \\n        int total = weekMoney + dayMoney;\\n        \\n        return total;\\n    }\\n\\n...\\nUpvote if you want.\\nAsk in comments if you have any doubt.",
                "codeTag": "Unknown"
            },
            {
                "id": 1723923,
                "title": "c-100-simple-fast-solution",
                "content": "```\\nint totalMoney(int n) {\\n    int base_mon = 0;\\n    int temp_sum = 0;\\n    int sum = 0;\\n    \\n    for(int i=0;i<n;i++) {\\n        if(i%7 == 0) {\\n            // printf(\"============\\\\n\");\\n            base_mon++;\\n            temp_sum = base_mon;\\n        }\\n        // printf(\"%d\\\\n\", temp_sum);\\n        sum += temp_sum;\\n        temp_sum ++;\\n    }\\n\\n    return sum;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint totalMoney(int n) {\\n    int base_mon = 0;\\n    int temp_sum = 0;\\n    int sum = 0;\\n    \\n    for(int i=0;i<n;i++) {\\n        if(i%7 == 0) {\\n            // printf(\"============\\\\n\");\\n            base_mon++;\\n            temp_sum = base_mon;\\n        }\\n        // printf(\"%d\\\\n\", temp_sum);\\n        sum += temp_sum;\\n        temp_sum ++;\\n    }\\n\\n    return sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1716409,
                "title": "c-easy-solution-tc-o-n-faster-than-100-sc-o-1",
                "content": "Here I made variable to count on which day i am on partiular value of n and a variable that stores the amount we need to put in bank on monday and a variable that gives the amount we store in bank on nth day .\\nTC : O(n)\\nSC: O(1)\\n```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int p=1,d=1,val=1;;\\n        int sum=0;\\n        while(n>0)\\n        {\\n            if(d==1)\\n            {\\n                val=p;\\n            }\\n            if(d==7)\\n            {\\n                d=0;\\n                p++;\\n            }\\n            sum+=val;\\n            val++;\\n            d++;\\n            n--;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int p=1,d=1,val=1;;\\n        int sum=0;\\n        while(n>0)\\n        {\\n            if(d==1)\\n            {\\n                val=p;\\n            }\\n            if(d==7)\\n            {\\n                d=0;\\n                p++;\\n            }\\n            sum+=val;\\n            val++;\\n            d++;\\n            n--;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673780,
                "title": "c-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int sum=0;\\n        for(int i=0; i<n/7; ++i){\\n            sum+=(28+7*i);\\n        }\\n        if(n%7!=0){\\n            sum+=(n%7)*((n%7)+1)/2;\\n            sum+=(n/7) * (n%7);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int sum=0;\\n        for(int i=0; i<n/7; ++i){\\n            sum+=(28+7*i);\\n        }\\n        if(n%7!=0){\\n            sum+=(n%7)*((n%7)+1)/2;\\n            sum+=(n/7) * (n%7);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658609,
                "title": "java-faster-than-100-00-of-java-online-submissions",
                "content": "\\n    class Solution {\\n    public int totalMoney(int n) {\\n        int x=n/7;\\n        int p=n%7;\\n        int sum=0;\\n        sum+=28*x+(7*(x)*(x-1))/2;\\n        x=x+1;\\n        sum+=x*p+(p*(p-1))/2;\\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int totalMoney(int n) {\\n        int x=n/7;\\n        int p=n%7;\\n        int sum=0;\\n        sum+=28*x+(7*(x)*(x-1))/2;\\n        x=x+1;\\n        sum+=x*p+(p*(p-1))/2;\\n        return sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1641160,
                "title": "java-easy-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int i=1;\\n        int sum=0;\\n        int last_amount;\\n        for(;i<=n/7;i++){\\n             last_amount=6+i;\\n            sum+=((last_amount)*(last_amount+1))/2-((i-1)*i)/2;\\n        }\\n        last_amount=(n%7-1)+i;\\n        sum+=((last_amount)*(last_amount+1))/2-((i-1)*i)/2;\\n        return sum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int i=1;\\n        int sum=0;\\n        int last_amount;\\n        for(;i<=n/7;i++){\\n             last_amount=6+i;\\n            sum+=((last_amount)*(last_amount+1))/2-((i-1)*i)/2;\\n        }\\n        last_amount=(n%7-1)+i;\\n        sum+=((last_amount)*(last_amount+1))/2-((i-1)*i)/2;\\n        return sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552278,
                "title": "go-time-o-n-o-1-0-ms-100-space-o-1-1-9-mb-60",
                "content": "**O(n) Linear Solution**\\n```\\nfunc totalMoney(n int) int {\\n    result := 0\\n    \\n    for d, m, s := 1, 1, 1; d <= n; d, m = d + 1, m + 1 {\\n        if d % 7 == 1 {\\n            m = s\\n            s++\\n        }\\n        result += m\\n    }\\n    \\n    return result\\n}\\n```\\n\\n**O(1) Constant Solution**. Thanks to [Ajna\\'s solution](https://leetcode.com/problems/calculate-money-in-leetcode-bank/discuss/1013944/C%2B%2B-Naive-vs.-Gaussian-Solution-Compared-and-Explained-100-Time).\\n```\\nfunc totalMoney(n int) int {\\n    d, r := n / 7, n % 7\\n\\n    return d * 28 + (d - 1) * d / 2 * 7 + (r + 1 + 2 * d) * r / 2\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc totalMoney(n int) int {\\n    result := 0\\n    \\n    for d, m, s := 1, 1, 1; d <= n; d, m = d + 1, m + 1 {\\n        if d % 7 == 1 {\\n            m = s\\n            s++\\n        }\\n        result += m\\n    }\\n    \\n    return result\\n}\\n```\n```\\nfunc totalMoney(n int) int {\\n    d, r := n / 7, n % 7\\n\\n    return d * 28 + (d - 1) * d / 2 * 7 + (r + 1 + 2 * d) * r / 2\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1542766,
                "title": "solution-for-c-concise-method",
                "content": "iteration and recursion are all OK\\n```cpp\\nclass Solution\\n{\\npublic:\\n    int totalMoney(int n)\\n    {\\n        if (n < 8)\\n        {\\n            return (1 + n) * n / 2;\\n        }\\n        else\\n        {\\n            n -= 7;\\n            return 28 + n + totalMoney(n);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution\\n{\\npublic:\\n    int totalMoney(int n)\\n    {\\n        if (n < 8)\\n        {\\n            return (1 + n) * n / 2;\\n        }\\n        else\\n        {\\n            n -= 7;\\n            return 28 + n + totalMoney(n);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523791,
                "title": "java-solution-o-1",
                "content": "```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        \\n        int complete_weeks = n / 7;\\n        int rem_days = n % 7;\\n        \\n        int weeks_base_amount = 28*complete_weeks;\\n        \\n        int added_amount_weekly = (7*(complete_weeks)*(complete_weeks-1)) / 2;\\n        \\n        \\n        int starting_week_amount = complete_weeks+1;\\n        \\n        int common_amount = rem_days * starting_week_amount;\\n        \\n        int extra_week_base = ((rem_days)*(rem_days-1)) / 2;\\n        \\n        return weeks_base_amount + added_amount_weekly + common_amount + extra_week_base;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        \\n        int complete_weeks = n / 7;\\n        int rem_days = n % 7;\\n        \\n        int weeks_base_amount = 28*complete_weeks;\\n        \\n        int added_amount_weekly = (7*(complete_weeks)*(complete_weeks-1)) / 2;\\n        \\n        \\n        int starting_week_amount = complete_weeks+1;\\n        \\n        int common_amount = rem_days * starting_week_amount;\\n        \\n        int extra_week_base = ((rem_days)*(rem_days-1)) / 2;\\n        \\n        return weeks_base_amount + added_amount_weekly + common_amount + extra_week_base;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522789,
                "title": "c-easy-solution-using-a-p-100-runtime-95-memory",
                "content": "**Please upvote if you like the approach**\\n\\n```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int res=0,x=1;\\n        while(n>=7)\\n        {\\n            res+=(7*(2*x+6))/2;\\n            n-=7;\\n            x++;\\n        }\\n        while(n--)\\n        {\\n            res+=x;\\n            x++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int res=0,x=1;\\n        while(n>=7)\\n        {\\n            res+=(7*(2*x+6))/2;\\n            n-=7;\\n            x++;\\n        }\\n        while(n--)\\n        {\\n            res+=x;\\n            x++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478607,
                "title": "faster-than-100-java-solution-with-o-1-complexity",
                "content": "\\n\\n\\n\\tclass Solution {\\n    public int totalMoney(int n) {\\n        int re=n%7;\\n        int ntime=n/7;\\n        return (re*(re+1))/2+28*ntime+7*((ntime-1)*(ntime)/2)+ntime*(re);\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n    public int totalMoney(int n) {\\n        int re=n%7;\\n        int ntime=n/7;\\n        return (re*(re+1))/2+28*ntime+7*((ntime-1)*(ntime)/2)+ntime*(re);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1478599,
                "title": "brute-force-o-n-to-o-1-math-solution-100-faster-with-proper-names-and-comments",
                "content": "\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t#bruteforce\\n        sumi=0\\n        i,j=1,1\\n        previ=0\\n        while(j<=n):#j is iterator and i,previ is for checking constraints\\n            if j%7==1:\\n                i=previ+1\\n                previ+=1\\n            sumi+=i\\n            i+=1\\n            j+=1\\n        return sumi\\n        \\n\\t\\t#o(1) solution\\n        re=n%7#remainder\\n        ntime=n//7#no of time\\n        return (re*(re+1))//2+28*ntime+7*((ntime-1)*(ntime)//2)+ntime*(re)\\n        \\n            \\n",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t#bruteforce\\n        sumi=0\\n        i,j=1,1\\n        previ=0\\n        while(j<=n):#j is iterator and i,previ is for checking constraints\\n            if j%7==1:\\n                i=previ+1\\n                previ+=1\\n            sumi+=i\\n            i+=1\\n            j+=1\\n        return sumi\\n        \\n\\t\\t#o(1) solution\\n        re=n%7#remainder\\n        ntime=n//7#no of time\\n        return (re*(re+1))//2+28*ntime+7*((ntime-1)*(ntime)//2)+ntime*(re)\\n        \\n            \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1467850,
                "title": "c-space-complexity-o-1-time-complexity-o-1-math",
                "content": "Here, the idea is to find the number of times we can have 7 integers in n. We find it by dividing the n by 7.\\nIf some integer n is not divisible by 7. We find the remainder of n on dividing by 7.\\n\\n```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) \\n    {\\n        int sm = 0;\\n        int f = n/7;\\n        int r = n%7;\\n        \\n        sm+=f*28+f*(f-1)*7/2;\\n        sm+=(r*(r+1)/2)+f*r;\\n        \\n        return sm;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) \\n    {\\n        int sm = 0;\\n        int f = n/7;\\n        int r = n%7;\\n        \\n        sm+=f*28+f*(f-1)*7/2;\\n        sm+=(r*(r+1)/2)+f*r;\\n        \\n        return sm;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458374,
                "title": "python-easy-92-63-speed-solution",
                "content": "```python\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        \\n        # 1. init monday money status : it have to be updated every monday\\n        # ex) # i % 7 == 1 --> update monday init\\n        monday_init = 1\\n        cnt = monday_init\\n        \\n        # return this variable\\n        money = 0\\n        \\n        # execute loop\\n        for i in range(1, n+1):\\n            # 2. except 1 at the beginning of the loop to update the monday money status\\n            if i % 7 == 1 and i != 1:\\n                monday_init +=1\\n                # 3. restart the weekly beginning money (== update the init money)\\n                cnt = monday_init\\n            # 4. if i % 7 != 1, then add money\\n            money += cnt\\n            cnt +=1\\n        return money\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        \\n        # 1. init monday money status : it have to be updated every monday\\n        # ex) # i % 7 == 1 --> update monday init\\n        monday_init = 1\\n        cnt = monday_init\\n        \\n        # return this variable\\n        money = 0\\n        \\n        # execute loop\\n        for i in range(1, n+1):\\n            # 2. except 1 at the beginning of the loop to update the monday money status\\n            if i % 7 == 1 and i != 1:\\n                monday_init +=1\\n                # 3. restart the weekly beginning money (== update the init money)\\n                cnt = monday_init\\n            # 4. if i % 7 != 1, then add money\\n            money += cnt\\n            cnt +=1\\n        return money\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439870,
                "title": "java-math-solution-with-simple-explanation",
                "content": "```\\nclass Solution { \\n    public int totalMoney(int n) {\\n        int ans = 0;\\n        for (int i = 0; i < n; i += 7) { //count full 7 days (weeks)\\n            ans += 28 + (i / 7) * 7;\\n        }\\n        int restDay = 7 - n % 7;   //Rest days, Ex: n = 18, we count 21 days minus 3 days\\n        int num = 0;\\n        for (int i = 0; i < restDay; i++) {  //\\n            num += i;\\n        }\\n        int over = (7 + (n / 7)) * restDay - num; // count rest days \\n        //Ex: n=18, the over 3 days\\uFF1A9+9+9-0-1-2 = 9+8+7\\n        return n % 7 == 0 ? ans : ans - over;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution { \\n    public int totalMoney(int n) {\\n        int ans = 0;\\n        for (int i = 0; i < n; i += 7) { //count full 7 days (weeks)\\n            ans += 28 + (i / 7) * 7;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1420623,
                "title": "faster-than-100-simple-and-operator",
                "content": "\\n\\n```\\nclass Solution {\\n    public int totalMoney(int n) {\\n      \\n        int ans = 0;\\n        int fullWeeks = n/7;\\n        int remainingDays = n%7;\\n        \\n        for(int i = 1; i <= fullWeeks; i++){\\n            ans += fun(i,7);\\n        }\\n        \\n        ans += fun(fullWeeks+1, remainingDays);\\n        return ans;\\n    }\\n    \\n    public int fun(int start, int days){      \\n        int sum = 0;\\n        int n = (start + days);\\n        for(int i = start; i < n; i++){\\n            sum += start;\\n            start += 1;\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int totalMoney(int n) {\\n      \\n        int ans = 0;\\n        int fullWeeks = n/7;\\n        int remainingDays = n%7;\\n        \\n        for(int i = 1; i <= fullWeeks; i++){\\n            ans += fun(i,7);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1417312,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int totalMoney(int n) {\\n        int i,m,k,j,s=0;\\n        for(m=n/7;m>0;m--)\\n        {\\n            k=m;\\n            for(j=1;j<=7;j++)\\n            {\\n                s=s+k;\\n                k++;\\n           }\\n        }\\n        m=(n/7)+1;\\n        for(j=1;j<=n%7;j++)\\n        {\\n            s=s+m;\\n            m++;\\n        }\\n        return s;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int totalMoney(int n) {\\n        int i,m,k,j,s=0;\\n        for(m=n/7;m>0;m--)\\n        {\\n            k=m;\\n            for(j=1;j<=7;j++)\\n            {\\n                s=s+k;\\n                k++;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 1355790,
                "title": "python-40-ms-solution",
                "content": "```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        count = n\\n        money = 0\\n        i = 1\\n        j = 1\\n        while i<=n:\\n            if i != 1 and i % 7 == 1:\\n                j = (i // 7)+1\\n            money+=j\\n            j+=1\\n            i+=1\\n        \\n        return money\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        count = n\\n        money = 0\\n        i = 1\\n        j = 1\\n        while i<=n:\\n            if i != 1 and i % 7 == 1:\\n                j = (i // 7)+1\\n            money+=j\\n            j+=1\\n            i+=1\\n        \\n        return money\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276717,
                "title": "c-easy-to-understand-solution-100-faster",
                "content": "```class Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int a[8]={6,1,2,3,4,5,6,7};\\n        \\n        if(n<=7)\\n        {\\n            int sum=(n)*(n+1);\\n            return sum/2;\\n            \\n        }\\n        else{\\n            int sum=7*(4);\\n            for(int i=8;i<=n;i++)\\n            {\\n            int rem=i%7;\\n            int num=i/7;\\n              sum=sum+a[rem]+num;  \\n            }\\n            return sum;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int a[8]={6,1,2,3,4,5,6,7}",
                "codeTag": "Java"
            },
            {
                "id": 1262580,
                "title": "used-arithmetic-progression-to-calculate-the-money-faster-than-100-solution",
                "content": "```\\nint totalMoney(int n) {\\n        \\n        int money = 0;\\n        \\n        if(n<8){\\n            money = (n*(n+1))/2;\\n        }\\n        else{\\n            int rem = n%7; //remaining days\\n            int div= n/7;  //to find out multiple of seven\\n            \\n            int remsum = 28*(div) + (div)*rem + (rem*(rem+1))/2 ;\\n            money+=remsum;\\n            \\n            for(int i=0;i<div;i++){\\n                money+= 7*i;\\n            }\\n        }\\n        \\n        \\n        return money;\\n        \\n    }\\t\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint totalMoney(int n) {\\n        \\n        int money = 0;\\n        \\n        if(n<8){\\n            money = (n*(n+1))/2;\\n        }\\n        else{\\n            int rem = n%7; //remaining days\\n            int div= n/7;  //to find out multiple of seven\\n            \\n            int remsum = 28*(div) + (div)*rem + (rem*(rem+1))/2 ;\\n            money+=remsum;\\n            \\n            for(int i=0;i<div;i++){\\n                money+= 7*i;\\n            }\\n        }\\n        \\n        \\n        return money;\\n        \\n    }\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1260758,
                "title": "c-no-math-easy-100-faster",
                "content": "```\\nint totalMoney(int n) {\\n        int day = 1, monday = 1, count = 1,sum  = 0;\\n        for(int i=1; i<=n; i++){\\n            if(count > 7){\\n                monday++;\\n                day = monday;\\n                count = 1;\\n            }\\n            sum = sum + day;\\n            day++;count++;\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint totalMoney(int n) {\\n        int day = 1, monday = 1, count = 1,sum  = 0;\\n        for(int i=1; i<=n; i++){\\n            if(count > 7){\\n                monday++;\\n                day = monday;\\n                count = 1;\\n            }\\n            sum = sum + day;\\n            day++;count++;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1233879,
                "title": "easy-to-understand-c-0ms-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int prev = 1;\\n        int curr = 1;\\n        int sum = 0;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            sum = sum + curr;\\n            curr++;\\n            if(i % 7 == 0)\\n            {\\n                curr = prev + 1;\\n                prev = curr;\\n            }\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int prev = 1;\\n        int curr = 1;\\n        int sum = 0;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            sum = sum + curr;\\n            curr++;\\n            if(i % 7 == 0)\\n            {\\n                curr = prev + 1;\\n                prev = curr;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1217567,
                "title": "c-100-easy-and-efficient-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int add=28,money=0,temp=n;\\n        while(temp>=7)\\n        {\\n            money+=add;\\n            add+=7;\\n            temp-=7;\\n        }\\n        add=n/7+1;\\n        n=n%7;\\n        while(n!=0)\\n        {\\n            money+=add;\\n            add+=1;\\n            n--;\\n        }\\n        return money;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int add=28,money=0,temp=n;\\n        while(temp>=7)\\n        {\\n            money+=add;\\n            add+=7;\\n            temp-=7;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1206286,
                "title": "python-solution-20-ms-faster-than-99-48",
                "content": "```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n\\t\\t#here s is sum of 1 to 7\\t\\n        s = 28\\n        res = 0\\n        if n>7:\\n            res = s\\n            div = n//7\\n            for i in range(1,div):\\n                res+=s+7*i\\n            rem = n%7\\n            for i in range(1,rem+1):\\n                res+=i+div\\n        else:\\n            for i in range(1,n+1):\\n                res+=i\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n\\t\\t#here s is sum of 1 to 7\\t\\n        s = 28\\n        res = 0\\n        if n>7:\\n            res = s\\n            div = n//7\\n            for i in range(1,div):\\n                res+=s+7*i\\n            rem = n%7\\n            for i in range(1,rem+1):\\n                res+=i+div\\n        else:\\n            for i in range(1,n+1):\\n                res+=i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1202928,
                "title": "c-solution-formulas-based-on-arithmetic-progression",
                "content": "```\\nclass Solution {\\npublic:\\n    // all formulas are based on sum of arithmetic progression\\n    int totalMoney(int n) {\\n        int s = 0;\\n        auto const k = n / 7; // number of full weeks\\n        if (k > 0)\\n            s += 28 * k + 7 * (k - 1) * k / 2;\\n        auto const i = n % 7; // the remainder of the last partial week \\n        return s + k * i + (i + 1) * i / 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // all formulas are based on sum of arithmetic progression\\n    int totalMoney(int n) {\\n        int s = 0;\\n        auto const k = n / 7; // number of full weeks\\n        if (k > 0)\\n            s += 28 * k + 7 * (k - 1) * k / 2;\\n        auto const i = n % 7; // the remainder of the last partial week \\n        return s + k * i + (i + 1) * i / 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1202718,
                "title": "faster-than-100-c-solutions-best-and-easy-c-solution",
                "content": "int totalMoney(int n) {\\n        int w=0,ans=0;\\n        while(n>0)\\n        {\\n            if(n>=7)\\n            {\\n                ans=ans+((7+w)*(8+w))/2-((w)*(w+1)/2);\\n                n=n-7;\\n                w++;\\n            }\\n            else\\n            {\\n                ans=ans+((n+w)*(n+1+w))/2-((w)*(w+1)/2);\\n                n=n-7;\\n                w++;\\n            }\\n            \\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "int totalMoney(int n) {\\n        int w=0,ans=0;\\n        while(n>0)\\n        {\\n            if(n>=7)\\n            {\\n                ans=ans+((7+w)*(8+w))/2-((w)*(w+1)/2);\\n                n=n-7;\\n                w++;\\n            }\\n            else\\n            {\\n                ans=ans+((n+w)*(n+1+w))/2-((w)*(w+1)/2);\\n                n=n-7;\\n                w++;\\n            }\\n            \\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1183566,
                "title": "c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int sum = 0;\\n        int k = 0;\\n        for(int i = 0;i<n;){\\n            for(int j=1;j<=7 and i<n;j++,i++){\\n                sum+=k+j;\\n            }\\n            k++;\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int sum = 0;\\n        int k = 0;\\n        for(int i = 0;i<n;){\\n            for(int j=1;j<=7 and i<n;j++,i++){\\n                sum+=k+j;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1176984,
                "title": "simple-c-solution-0-ms",
                "content": "\\n\\nint totalMoney(int n){\\n    \\n       int count=0, startwkMoney=1,sum=0;\\n       int j=startwkMoney;\\n    \\n      for(int i=0;i<n;i++){\\n          \\n          sum+=j;\\n           j++;\\n           count++;\\n          if(count==7){\\n              startwkMoney+=1;\\n              count=0;\\n              j=startwkMoney;}\\n          }\\n      \\n      return sum;\\n\\n}",
                "solutionTags": [],
                "code": "\\n\\nint totalMoney(int n){\\n    \\n       int count=0, startwkMoney=1,sum=0;\\n       int j=startwkMoney;\\n    \\n      for(int i=0;i<n;i++){\\n          \\n          sum+=j;\\n           j++;\\n           count++;\\n          if(count==7){\\n              startwkMoney+=1;\\n              count=0;\\n              j=startwkMoney;}\\n          }\\n      \\n      return sum;\\n\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1153456,
                "title": "faster-than-100",
                "content": "int totalMoney(int n) {\\n        int counter=1;\\n       int pre=1;\\n        int sum=0;\\n        for(int i=1;i<=n;i++){\\n            sum=sum+counter;\\n            counter++;\\n            \\n            if(i%7==0&&i!=0){\\n            counter=pre+1;\\n                pre=counter;\\n            }\\n        }\\n        return sum;",
                "solutionTags": [],
                "code": "int totalMoney(int n) {\\n        int counter=1;\\n       int pre=1;\\n        int sum=0;\\n        for(int i=1;i<=n;i++){\\n            sum=sum+counter;\\n            counter++;\\n            \\n            if(i%7==0&&i!=0){\\n            counter=pre+1;\\n                pre=counter;\\n            }\\n        }\\n        return sum;",
                "codeTag": "Unknown"
            },
            {
                "id": 1140051,
                "title": "0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "\\n```\\nint totalMoney(int n){\\n    \\n    int i,sum=0,fun=1,x=0;\\n    \\n    for(i=0;i<n;i++)\\n    {\\n        if(i%7==0)\\n        {\\n            x=x+1;\\n            sum=sum+x;  \\n            fun=x+1;\\n        }\\n        else if(i%6==0&&i==0)\\n        {\\n            sum=sum+1;\\n            fun=fun+1;\\n            x=1;\\n        }\\n        else \\n        {\\n            sum=sum+fun;\\n            fun=fun+1;\\n        }\\n    }\\n    \\n    return sum;\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint totalMoney(int n){\\n    \\n    int i,sum=0,fun=1,x=0;\\n    \\n    for(i=0;i<n;i++)\\n    {\\n        if(i%7==0)\\n        {\\n            x=x+1;\\n            sum=sum+x;  \\n            fun=x+1;\\n        }\\n        else if(i%6==0&&i==0)\\n        {\\n            sum=sum+1;\\n            fun=fun+1;\\n            x=1;\\n        }\\n        else \\n        {\\n            sum=sum+fun;\\n            fun=fun+1;\\n        }\\n    }\\n    \\n    return sum;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1137522,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        cnt,temp=1,1\\n        d,ans=[],[]\\n        for i in range(n):\\n            d.append(cnt)\\n            cnt+=1\\n            if len(d)==7:\\n                ans.append(sum(d))\\n                d.clear()\\n                temp+=1\\n                cnt=temp        \\n        return sum(ans+d)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        cnt,temp=1,1\\n        d,ans=[],[]\\n        for i in range(n):\\n            d.append(cnt)\\n            cnt+=1\\n            if len(d)==7:\\n                ans.append(sum(d))\\n                d.clear()\\n                temp+=1\\n                cnt=temp        \\n        return sum(ans+d)",
                "codeTag": "Java"
            },
            {
                "id": 1137177,
                "title": "faster-than-100-c-solution-cpp-o-1",
                "content": "```\\nint totalMoney(int n) {\\n        if(n<=7)\\n            return n*(n+1)/2;\\n        return (28*(n/7) + 7*((n/7)*(n/7-1))/2 + (n%7)*(n%7+1)/2 + (n/7)*(n%7));\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint totalMoney(int n) {\\n        if(n<=7)\\n            return n*(n+1)/2;\\n        return (28*(n/7) + 7*((n/7)*(n/7-1))/2 + (n%7)*(n%7+1)/2 + (n/7)*(n%7));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1136200,
                "title": "faster-than-100-solution",
                "content": "\\tint totalMoney(int n) {\\n\\t\\t\\tint x=1;\\n\\t\\t\\tint sum=0;\\n\\t\\t\\tstack<int> Mon;\\n\\t\\t\\tMon.push(1);\\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\tif(i%7==0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsum+=x;\\n\\t\\t\\t\\t\\tx=Mon.top()+1;\\n\\t\\t\\t\\t\\tMon.push(x);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tsum+=x;\\n\\t\\t\\t\\t\\tx++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn sum;\\n\\t\\t}",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "\\tint totalMoney(int n) {\\n\\t\\t\\tint x=1;\\n\\t\\t\\tint sum=0;\\n\\t\\t\\tstack<int> Mon;\\n\\t\\t\\tMon.push(1);\\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\tif(i%7==0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsum+=x;\\n\\t\\t\\t\\t\\tx=Mon.top()+1;\\n\\t\\t\\t\\t\\tMon.push(x);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tsum+=x;\\n\\t\\t\\t\\t\\tx++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn sum;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1123072,
                "title": "c-using-arithmetic-sum-formula",
                "content": "This uses the formula the arithmetic sum to calculate all of the completed weeks and then adds up the rest of the remaining days (if there are any).\\n0 ms runtime. Beats 100%\\nCan probably be optimized by writing a formula for the remaining days. \\n```\\nint totalMoney(int n) {\\n        int sum = 0;\\n        int remaining_days = n % 7;\\n        int num_weeks = n/7;\\n        \\n        //calculate the sum after completed weeks\\n        // Week 1\\'s sum is 28\\n        // Week 2\\'s sum is 35\\n        // Week 3\\'s sum is 42\\n        // Each week, the value increases by 7. We can use\\n        // the sum of arithmetic series to do most of the work.\\n        sum = num_weeks * 0.5 * (56 + (num_weeks -1) * 7);\\n        \\n        // Then we just need to calculate the remaining days\\n        for(int i = 1 ; i <= remaining_days; i++) {\\n            sum += i + (num_weeks);\\n        }\\n        \\n        return sum;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nint totalMoney(int n) {\\n        int sum = 0;\\n        int remaining_days = n % 7;\\n        int num_weeks = n/7;\\n        \\n        //calculate the sum after completed weeks\\n        // Week 1\\'s sum is 28\\n        // Week 2\\'s sum is 35\\n        // Week 3\\'s sum is 42\\n        // Each week, the value increases by 7. We can use\\n        // the sum of arithmetic series to do most of the work.\\n        sum = num_weeks * 0.5 * (56 + (num_weeks -1) * 7);\\n        \\n        // Then we just need to calculate the remaining days\\n        for(int i = 1 ; i <= remaining_days; i++) {\\n            sum += i + (num_weeks);\\n        }\\n        \\n        return sum;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1112327,
                "title": "java-math",
                "content": "# Approach: Math O(1) 100%\\nThe idea of this solution is to get rid of weeks first. Then solve the remaining days.\\nWe see that when solving weeks, we are summing up the sequence of `a, a+7, a+14, ...`.\\nOn the other hand, when solving the days, we are summing up the sequence of `1+s, 2+s, ..., r+s`, which is `r*s + (r+1)*r/2`.\\n```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        // total money\\n        int res = 0;\\n        \\n        // remaining days after get rid of weeks\\n        int r = n % 7;\\n        \\n        // streak of 7 days\\n        int s = (n - r) / 7;\\n        \\n        // increasing sequence: a, a+7, a+14, ...\\n\\t\\t// 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28\\n        int a = 28;\\n        \\n\\t\\t// solve increasing sequence\\n        res += a*s + 7*s*(s-1)/2;\\n        \\n        // solve remaining days\\n        if (r > 0) res += r*s + (r+1)*r/2;\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        // total money\\n        int res = 0;\\n        \\n        // remaining days after get rid of weeks\\n        int r = n % 7;\\n        \\n        // streak of 7 days\\n        int s = (n - r) / 7;\\n        \\n        // increasing sequence: a, a+7, a+14, ...\\n\\t\\t// 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28\\n        int a = 28;\\n        \\n\\t\\t// solve increasing sequence\\n        res += a*s + 7*s*(s-1)/2;\\n        \\n        // solve remaining days\\n        if (r > 0) res += r*s + (r+1)*r/2;\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110831,
                "title": "94-fast",
                "content": "```\\ndef totalMoney(self, n: int) -> int:\\n        total = 0\\n        if n == 0: return total\\n        if n <= 7:\\n            return self.getDay(1,n)\\n            \\n        # get full week\\n        week = n // 7\\n        for i in range(1,week+1, 1):\\n            total += 7*(i+3)\\n        \\n        # get rest of days\\n        rest = n % 7\\n        for i in range(week+1, week+1+rest, 1):\\n            total += i\\n        return total\\n        \\n    def getDay(self, first, last):\\n        total = 0\\n        for i in range(first, last+1, 1):\\n            total += i\\n        return total\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef totalMoney(self, n: int) -> int:\\n        total = 0\\n        if n == 0: return total\\n        if n <= 7:\\n            return self.getDay(1,n)\\n            \\n        # get full week\\n        week = n // 7\\n        for i in range(1,week+1, 1):\\n            total += 7*(i+3)\\n        \\n        # get rest of days\\n        rest = n % 7\\n        for i in range(week+1, week+1+rest, 1):\\n            total += i\\n        return total\\n        \\n    def getDay(self, first, last):\\n        total = 0\\n        for i in range(first, last+1, 1):\\n            total += i\\n        return total\\n            \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1102943,
                "title": "java-math-solution-o-1",
                "content": "\\'\\'\\'\\n\\n\\tpublic int totalMoney(int n) {\\n        int week=n/7,remainder=n%7;\\n        \\n        return week*21+7*(week+1)*(week)/2 + remainder*(week+1)+(remainder-1)*remainder/2;\\n        \\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n\\tpublic int totalMoney(int n) {\\n        int week=n/7,remainder=n%7;\\n        \\n        return week*21+7*(week+1)*(week)/2 + remainder*(week+1)+(remainder-1)*remainder/2;\\n        \\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1094378,
                "title": "javascript-calculate-money-in-leetcode-bank-with-76ms-and-clear-variable-naming",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar totalMoney = function(n) {\\n    let startAmount = 1, nextStartAmount = 1;\\n    let total = 0;\\n    let days = 7;\\n    \\n    for(let i = 0; i < n; i++) {\\n        if(days !== 0) {\\n            total += startAmount;\\n            startAmount++;\\n            days--;\\n        } else {\\n            nextStartAmount++;\\n            startAmount = nextStartAmount;\\n            days = 7;\\n            i--;\\n        }\\n    }\\n    \\n    return total;\\n};\\n```\\n\\nCredit to https://leetcode.com/KondalDurgam/",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar totalMoney = function(n) {\\n    let startAmount = 1, nextStartAmount = 1;\\n    let total = 0;\\n    let days = 7;\\n    \\n    for(let i = 0; i < n; i++) {\\n        if(days !== 0) {\\n            total += startAmount;\\n            startAmount++;\\n            days--;\\n        } else {\\n            nextStartAmount++;\\n            startAmount = nextStartAmount;\\n            days = 7;\\n            i--;\\n        }\\n    }\\n    \\n    return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1088610,
                "title": "simple-dp-solution-in-faster-than-100-percent-c",
                "content": "class Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int dp[n];\\n        dp[0]=1;\\n        int sum=1;\\n        int i;\\n        for(i=1;i<n;i++)\\n        {\\n            if(i%7!=0)\\n            {\\n                dp[i]=dp[i-1]+1; // only adding 1 in previous day balance\\n            }\\n            else\\n            {\\n                dp[i]=dp[i-7]+1; // checking if day is monday so just using previous monday balance+1 \\n            }\\n            sum+=dp[i];\\n        }\\n        return sum;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int dp[n];\\n        dp[0]=1;\\n        int sum=1;\\n        int i;\\n        for(i=1;i<n;i++)\\n        {\\n            if(i%7!=0)\\n            {\\n                dp[i]=dp[i-1]+1; // only adding 1 in previous day balance\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1082217,
                "title": "java-clean-concise-code-natural-sum-technique-0ms-time-100-faster-solution",
                "content": "```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        \\n        int money = 0;\\n        int start = 0;\\n        int rem = n % 7;\\n        \\n        while (start < n / 7) {\\n            int curr = 7 + start;\\n            money += (curr * (curr + 1) / 2) - (start * (start + 1) / 2);\\n            start++;\\n        }\\n        \\n        return money + ((rem + start) * (rem + start + 1) / 2) - (start * (start + 1) / 2);\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        \\n        int money = 0;\\n        int start = 0;\\n        int rem = n % 7;\\n        \\n        while (start < n / 7) {\\n            int curr = 7 + start;\\n            money += (curr * (curr + 1) / 2) - (start * (start + 1) / 2);\\n            start++;\\n        }\\n        \\n        return money + ((rem + start) * (rem + start + 1) / 2) - (start * (start + 1) / 2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072565,
                "title": "c-o-1-time",
                "content": "We have 2 arithmetic progressions: by weeks and by days. Calculate count of full passed weeks. And days after last week begin. The sum of n members of arithmetic progression a1, a2, ... an with step d is:\\nS = (2 * a1 + d * (n - 1)) * n / 2\\n\\n```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int fullWeeks = n / 7;\\n        int daysAfterWeekStart =  n % 7;\\n        \\n        return (2 * 28 + 7 * (fullWeeks - 1)) * fullWeeks / 2 +\\n            (2 * (fullWeeks + 1) + daysAfterWeekStart - 1) * daysAfterWeekStart / 2;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int fullWeeks = n / 7;\\n        int daysAfterWeekStart =  n % 7;\\n        \\n        return (2 * 28 + 7 * (fullWeeks - 1)) * fullWeeks / 2 +\\n            (2 * (fullWeeks + 1) + daysAfterWeekStart - 1) * daysAfterWeekStart / 2;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072251,
                "title": "c-c-simple-one-liner",
                "content": "```\\nint totalMoney(int n) {\\n\\treturn 7*(n/7)*(n/7+7)/2 + (n%7)*(2*((n-1)/7)+1 + n%7)/2;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nint totalMoney(int n) {\\n\\treturn 7*(n/7)*(n/7+7)/2 + (n%7)*(2*((n-1)/7)+1 + n%7)/2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1070842,
                "title": "c-this-is-pure-math",
                "content": "class Solution {\\npublic:\\n    /*\\n    1, 2, 3, 4, 5, 6, 7\\n    2, 3, 4, 5, 6, 7, 8\\n    3, 4, 5, 6, 7, 8, 9\\n    \\n    For each week, the total money is 7 times the money of Thursday.\\n    For example, the first week total money is 1+2+3+4+5+6+7 = 28 = 4 * 7.\\n    We need to figure out how many full weeks in total.\\n    For all the full weeks, we just use the [Thursday Money] * 7.\\n    \\n    For the last week which is not full week, we can add day by day.\\n    \\n    Now come back to full weeks.\\n    if full week is two. we have 7 * (4 + 5)\\n    if full week is three, we have 7 * (4 + 5 + 6).\\n    if full week is m, we have 7 * (4 + 5 + ... + (4+m - 1)) == 7 * (1 + 2 + ... +  (4 + m -1)) - 7 * (1 + 2 + 3)\\n    \\n    \\n    the first day (Monday) of remain Days, what\\'s the money? it is m + 1.\\n    the last day of remain Days must be  m  +  n % 7\\n    so the money for that last week is  (m + 1) + (m + 2) + ... + (m + n%7) == m * (n % 7) + (n%7 ) (n%7 + 1) / 2\\n        \\n    \\n    the final answer is 7 * (m + 3) * ( m + 4) / 2 - 42 + [all the money from remainDays]\\n    \\n    */\\n    int totalMoney(int n) {\\n        int mWeeks = n / 7;\\n        int remainDays = n % 7;\\n        int result = 0;\\n        int moneyOnMonday = mWeeks + 1;\\n        \\n        // Full weeks       \\n        result += (7 * (mWeeks + 3) * (mWeeks + 4) / 2 - 42);\\n        \\n        // last week\\n        result += mWeeks * (remainDays) + (remainDays) * (remainDays + 1) / 2;\\n        \\n        \\n        return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    /*\\n    1, 2, 3, 4, 5, 6, 7\\n    2, 3, 4, 5, 6, 7, 8\\n    3, 4, 5, 6, 7, 8, 9\\n    \\n    For each week, the total money is 7 times the money of Thursday.\\n    For example, the first week total money is 1+2+3+4+5+6+7 = 28 = 4 * 7.\\n    We need to figure out how many full weeks in total.\\n    For all the full weeks, we just use the [Thursday Money] * 7.\\n    \\n    For the last week which is not full week, we can add day by day.\\n    \\n    Now come back to full weeks.\\n    if full week is two. we have 7 * (4 + 5)\\n    if full week is three, we have 7 * (4 + 5 + 6).\\n    if full week is m, we have 7 * (4 + 5 + ... + (4+m - 1)) == 7 * (1 + 2 + ... +  (4 + m -1)) - 7 * (1 + 2 + 3)\\n    \\n    \\n    the first day (Monday) of remain Days, what\\'s the money? it is m + 1.\\n    the last day of remain Days must be  m  +  n % 7\\n    so the money for that last week is  (m + 1) + (m + 2) + ... + (m + n%7) == m * (n % 7) + (n%7 ) (n%7 + 1) / 2\\n        \\n    \\n    the final answer is 7 * (m + 3) * ( m + 4) / 2 - 42 + [all the money from remainDays]\\n    \\n    */\\n    int totalMoney(int n) {\\n        int mWeeks = n / 7;\\n        int remainDays = n % 7;\\n        int result = 0;\\n        int moneyOnMonday = mWeeks + 1;\\n        \\n        // Full weeks       \\n        result += (7 * (mWeeks + 3) * (mWeeks + 4) / 2 - 42);\\n        \\n        // last week\\n        result += mWeeks * (remainDays) + (remainDays) * (remainDays + 1) / 2;\\n        \\n        \\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1063522,
                "title": "python-3-o-1-complexity-no-loop-used-pure-maths",
                "content": "q --> Weeks\\nr --> remaining days\\n\\n```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        q=n//7\\n        r=n%7\\n        \\n        return int(q*(24.5+r+3.5*q)+r*(r+1)//2)\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        q=n//7\\n        r=n%7\\n        \\n        return int(q*(24.5+r+3.5*q)+r*(r+1)//2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1057237,
                "title": "python3-faster-than-83-simple-solution",
                "content": "```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:      \\n        if n<=7:\\n            return int(n*(n+1)/2)\\n        else:\\n            l = [i for i in range(1,8)]\\n            s=28\\n            while n>0:      \\n                n-=7\\n                l = [i+1 for i in l][:n]\\n                \\n                if n<=7:\\n                    s += sum(l)\\n                    return s\\n                else:\\n                    s += sum(l)\\n        return s\\n```\\n* First check if ```n <= 7```, so as to remove any corner cases and directly return the sum of these ```n``` natural numbers.\\n* If ```n >= 7```, definitely the final sum will be >= 28. So initialise ```s``` as 28 and iterate thereafter, till ```n != 0```.\\n* With each iteration, ```n``` reduces by 7, and each element of the list ```l``` gets added by 1. Now, if ```n <= 7```, we should just add the sum of first ```n``` elements of the modified list, else we have to add the sum of all the elements.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:      \\n        if n<=7:\\n            return int(n*(n+1)/2)\\n        else:\\n            l = [i for i in range(1,8)]\\n            s=28\\n            while n>0:      \\n                n-=7\\n                l = [i+1 for i in l][:n]\\n                \\n                if n<=7:\\n                    s += sum(l)\\n                    return s\\n                else:\\n                    s += sum(l)\\n        return s\\n```\n```n <= 7```\n```n```\n```n >= 7```\n```s```\n```n != 0```\n```n```\n```l```\n```n <= 7```\n```n```",
                "codeTag": "Java"
            },
            {
                "id": 1052742,
                "title": "easy-solution-with-sum-of-ap-of-7-terms-o-n-c",
                "content": "Sum of n terms of arithmetic progression = (n*(a+l))/2\\nwhere a = first term, l = last term.\\nHere l = (a + 7 - 1) = a + 6\\n```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int total = n/7;\\n        int rem = n%7;\\n        int a = 1;\\n        int ans = 0;\\n        while(a <= total){\\n            ans += (7 *(2*a + 6))/2;\\n            a++;\\n        }\\n        ans += (rem * (2*a + rem - 1)) / 2;\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int total = n/7;\\n        int rem = n%7;\\n        int a = 1;\\n        int ans = 0;\\n        while(a <= total){\\n            ans += (7 *(2*a + 6))/2;\\n            a++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1043977,
                "title": "java-o-1-faster-than-100-selft-explanatory-sum-of-ariphmetic-progression-formula",
                "content": "```\\nclass Solution {\\n    private static final int DAYS_PER_WEEK = 7;\\n    private static final int SUM_OF_FIRST_WEEK = 28;\\n    \\n    public int totalMoney(int n) {\\n        var fullWeekCount = n / DAYS_PER_WEEK;\\n        var lastMondayN = fullWeekCount * DAYS_PER_WEEK + 1;\\n        var lastMondayVal = fullWeekCount + 1;\\n        var lastWeekDaysCount = n - lastMondayN + 1;\\n\\n        return ariphmeticProgressionSum(SUM_OF_FIRST_WEEK, fullWeekCount, DAYS_PER_WEEK)\\n            + ariphmeticProgressionSum(lastMondayVal, lastWeekDaysCount, 1);\\n    }\\n    \\n    private static int ariphmeticProgressionSum(int firstVal, int numOfValues, int diff) {\\n        //https://en.wikipedia.org/wiki/Arithmetic_progression\\n        return (2 * firstVal + (numOfValues - 1) * diff) * numOfValues / 2; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final int DAYS_PER_WEEK = 7;\\n    private static final int SUM_OF_FIRST_WEEK = 28;\\n    \\n    public int totalMoney(int n) {\\n        var fullWeekCount = n / DAYS_PER_WEEK;\\n        var lastMondayN = fullWeekCount * DAYS_PER_WEEK + 1;\\n        var lastMondayVal = fullWeekCount + 1;\\n        var lastWeekDaysCount = n - lastMondayN + 1;\\n\\n        return ariphmeticProgressionSum(SUM_OF_FIRST_WEEK, fullWeekCount, DAYS_PER_WEEK)\\n            + ariphmeticProgressionSum(lastMondayVal, lastWeekDaysCount, 1);\\n    }\\n    \\n    private static int ariphmeticProgressionSum(int firstVal, int numOfValues, int diff) {\\n        //https://en.wikipedia.org/wiki/Arithmetic_progression\\n        return (2 * firstVal + (numOfValues - 1) * diff) * numOfValues / 2; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1041125,
                "title": "python-3",
                "content": "Runtime: 36 ms\\nMemory Usage: 14.2 MB\\n\\n```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        ttl, flag, add = 0, 0, 0\\n        cont = 7\\n        for _ in range(n):\\n            add += 1\\n            ttl += add\\n            cont -= 1\\n            if cont <= 0:\\n                flag += 1\\n                add = flag\\n                cont = 7\\n        return ttl\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        ttl, flag, add = 0, 0, 0\\n        cont = 7\\n        for _ in range(n):\\n            add += 1\\n            ttl += add\\n            cont -= 1\\n            if cont <= 0:\\n                flag += 1\\n                add = flag\\n                cont = 7\\n        return ttl\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027774,
                "title": "c-solution",
                "content": "```\\nint totalMoney(int n) {\\n    int total = 0;\\n    for (int i = 0; i < n; total += (i % 7) + 1 + i++ / 7);\\n    return total;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint totalMoney(int n) {\\n    int total = 0;\\n    for (int i = 0; i < n; total += (i % 7) + 1 + i++ / 7);\\n    return total;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1026954,
                "title": "python3-math-o-1",
                "content": "**Algo**\\n`1 2 3 4 5 6 7`\\n`2 3 4 5 6 7 8`\\n`3 4 5 6 7 8 9`\\n\\nThe pattern is like above. We just need to compute the rows and columns to calculate the sum. \\n\\n**Implementation** (16ms, 99.95%)\\n```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        q, r = divmod(n, 7)\\n        return ((7*q + (49+2*r))*q + r*(r+1))//2\\n```\\n\\nAnalysis\\nTime complexity `O(1)`\\nSpace complexity `O(1)`\\n\\nAn alternative `O(N)` approach easier to understand is given below \\n```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        ans = x = 0\\n        for i in range(n): \\n            if i%7 == 0: x += 1\\n            ans += x + i%7\\n        return ans \\n```\\n\\n```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        ans = val = 0\\n        for x in range(n): \\n            if x % 7 == 0: val = x//7 # reset \\n            val += 1\\n            ans += val\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        q, r = divmod(n, 7)\\n        return ((7*q + (49+2*r))*q + r*(r+1))//2\\n```\n```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        ans = x = 0\\n        for i in range(n): \\n            if i%7 == 0: x += 1\\n            ans += x + i%7\\n        return ans \\n```\n```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        ans = val = 0\\n        for x in range(n): \\n            if x % 7 == 0: val = x//7 # reset \\n            val += 1\\n            ans += val\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1026099,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        \\n        int result = 0;\\n        int initial = 1;\\n        \\n        while(n > 0){\\n            result += sumWeek(n, initial);\\n            n-=7;\\n            initial++;\\n\\n        }\\n        return result;\\n    }\\n    \\n    private int sumWeek(int n, int initial){\\n        int sum = 0;\\n        \\n        if (n >= 7) n = 7;\\n        for (int i=0; i<n; i++){\\n            sum+=initial;\\n            initial++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        \\n        int result = 0;\\n        int initial = 1;\\n        \\n        while(n > 0){\\n            result += sumWeek(n, initial);\\n            n-=7;\\n            initial++;\\n\\n        }\\n        return result;\\n    }\\n    \\n    private int sumWeek(int n, int initial){\\n        int sum = 0;\\n        \\n        if (n >= 7) n = 7;\\n        for (int i=0; i<n; i++){\\n            sum+=initial;\\n            initial++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1020295,
                "title": "python-with-math-formula",
                "content": "```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int: \\n        i = 1\\n        total = 0\\n        while  n >= 7:\\n            total += (7 * (7 + i) / 2)\\n            n -= 7\\n            i += 2\\n        total += (n * (n + i) / 2)\\n        return int(total)\\n```\\n\\nA spesifically modified version of gauss sum formula for just this problem. Returns 28 for first week, 35 for second and so on.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int: \\n        i = 1\\n        total = 0\\n        while  n >= 7:\\n            total += (7 * (7 + i) / 2)\\n            n -= 7\\n            i += 2\\n        total += (n * (n + i) / 2)\\n        return int(total)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1020076,
                "title": "c-o-1-solution-with-proof-enjoy",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int w = n/7;\\n        int d = n%7;\\n        \\n        // Proof:\\n        // complete weeks:\\n        // w/2(2+(w-1)1) + w/2(4+(w-1)1) + w/2(6+(w-1)1) + w/2(8+(w-1)1)\\n        // + w/2(10+(w-1)1) + w/2(12+(w-1)1) + w/2(14+(w-1)1)\\n        // = w/2(56 + 7w - 7)  = w/2(7w+49)\\n        // additional days:\\n        // d/2(2(w+1) + (d-1)1)  = d/2(2w + 1 + d)\\n        \\n        return (w*(7*w+49))/2 + ((d)*(2*w+1+d))/2;\\n            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int w = n/7;\\n        int d = n%7;\\n        \\n        // Proof:\\n        // complete weeks:\\n        // w/2(2+(w-1)1) + w/2(4+(w-1)1) + w/2(6+(w-1)1) + w/2(8+(w-1)1)\\n        // + w/2(10+(w-1)1) + w/2(12+(w-1)1) + w/2(14+(w-1)1)\\n        // = w/2(56 + 7w - 7)  = w/2(7w+49)\\n        // additional days:\\n        // d/2(2(w+1) + (d-1)1)  = d/2(2w + 1 + d)\\n        \\n        return (w*(7*w+49))/2 + ((d)*(2*w+1+d))/2;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1018411,
                "title": "faster-than-100-00-cpp-c-98-21-memory-percentile-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int money = 0;\\n        int mon = 0;\\n        int prev;\\n        for(int i=0;i<n;i++){\\n            if(i%7==0){\\n               mon++;\\n               money = money + mon;\\n               prev = mon;\\n             \\n            }\\n            else{\\n                prev++;\\n                money = money + prev;\\n                \\n            }\\n        }\\n        \\n        \\n        return money;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int money = 0;\\n        int mon = 0;\\n        int prev;\\n        for(int i=0;i<n;i++){\\n            if(i%7==0){\\n               mon++;\\n               money = money + mon;\\n               prev = mon;\\n             \\n            }\\n            else{\\n                prev++;\\n                money = money + prev;\\n                \\n            }\\n        }\\n        \\n        \\n        return money;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1017240,
                "title": "c-python3-no-loops-just-math-o-1-o-1",
                "content": "**C++**\\n```\\npublic:\\n    int totalMoney(int n) {\\n        int weeks = n / 7;\\n        int pastWeeksMoney = 7 * (weeks + 3) * (weeks + 4) / 2 - 42;\\n        int d = n % 7;\\n        int thisWeeksMoney = d * (d + 1) / 2 + d * weeks;\\n        return pastWeeksMoney + thisWeeksMoney;\\n    }\\n};\\n```\\n\\n**Python3**\\n```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        weeks = n // 7\\n        past_weeks_money = 7 * (weeks + 3) * (weeks + 4) // 2 - 42\\n        d = n % 7\\n        this_week_money = d * (d + 1) // 2 + d * weeks\\n        return past_weeks_money + this_week_money\\n```",
                "solutionTags": [],
                "code": "```\\npublic:\\n    int totalMoney(int n) {\\n        int weeks = n / 7;\\n        int pastWeeksMoney = 7 * (weeks + 3) * (weeks + 4) / 2 - 42;\\n        int d = n % 7;\\n        int thisWeeksMoney = d * (d + 1) / 2 + d * weeks;\\n        return pastWeeksMoney + thisWeeksMoney;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        weeks = n // 7\\n        past_weeks_money = 7 * (weeks + 3) * (weeks + 4) // 2 - 42\\n        d = n % 7\\n        this_week_money = d * (d + 1) // 2 + d * weeks\\n        return past_weeks_money + this_week_money\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016685,
                "title": "0-1-time-and-0-1-space-swift-100-faster-than-other-solutions",
                "content": "Basically can be just simplified as a series. We also make use of sum of first n numbers formula which is 1+2+ 3+ ....n = n * (n + 1) /2\\nNow, let ques = n / 7 and remain = n % 7\\nUntil *ques* weeks we will have full weeks collection(having collection on all 7 days) as below\\n\\n\\t\\tweek-1:         1 + 2 + 3 + 4 + 5 + 6 + 7\\n\\t\\tweek-2:         2 + 3 + 4 + 5 + 6 + 7 + 8 = (1 + 2 + 3 + 4 + 5 + 6 + 7) + 7\\n\\t\\tweek-3:         3 + 4 + 5 + 6 + 7 + 8 + 9 = (1 + 2 + 3 + 4 + 5 + 6 + 7) + 7 * 2\\n\\t\\t....\\n\\t\\tweek-ques:  (ques + 1) + ... + (ques + 7) = (1 + 2 + 3 + 4 + 5 + 6 + 7) + 7 * (ques - 1)\\n\\nlets add all\\n               \\n\\t    Full weeks collection =  (1 + 2 + 3 + 4 + 5 + 6 + 7) * ques + 7 * (1 + 2 + 3 + ... + ques - 1)\\n\\t   \\n and simplify a bit\\n \\n        Full weeks collection = (1 + 2 + 3 + 4 + 5 + 6 + 7) * ques + 7 * (1 + 2 + 3 + ... + ques - 1) = 28 * ques + 7 * (ques-1) * ques / 2\\n\\nFor last week i.e for *remain* days, our collection will look like:\\n\\n       Last week collection = (ques + 1) + (ques + 2) + (ques + 3) + ....... (ques + remain) =  ques * remain  + remain * (remain + 1) / 2 \\n\\nFinally we add the two:\\n\\n     Total collection =  (28 * ques + 7 * (ques-1) * ques / 2) + (ques * remain  + remain * (remain + 1) / 2)\\n\\n```\\nclass Solution {\\n    func totalMoney(_ n: Int) -> Int {\\n        let ques = n / 7\\n        var sum = 28*ques + 7*(ques-1)*ques/2\\n        let remain = n % 7\\n        return sum + remain*ques + remain*(remain+1)/2\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func totalMoney(_ n: Int) -> Int {\\n        let ques = n / 7\\n        var sum = 28*ques + 7*(ques-1)*ques/2\\n        let remain = n % 7\\n        return sum + remain*ques + remain*(remain+1)/2\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1014315,
                "title": "python-one-line-solution",
                "content": "```\\ndef totalMoney(self, n: int) -> int:\\n\\treturn sum([i%7+ 1 + i // 7 for i in range(n)])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef totalMoney(self, n: int) -> int:\\n\\treturn sum([i%7+ 1 + i // 7 for i in range(n)])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1013629,
                "title": "o-1-space-and-time-faster-than-100-3-lines-solution-without-even-loop",
                "content": "```\\nint totalMoney(int n) {\\n        int q = n/7;\\n        int r = n%7;\\n        return q*28 + (7*(q-1)*(q))/2 + ((r+1)*r)/2 + (q)*r;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nint totalMoney(int n) {\\n        int q = n/7;\\n        int r = n%7;\\n        return q*28 + (7*(q-1)*(q))/2 + ((r+1)*r)/2 + (q)*r;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1011795,
                "title": "simple-swift-solution",
                "content": "Simple Swift solution\\n```\\nclass Solution {\\n    func totalMoney(_ n: Int) -> Int {\\n        var result = 0\\n        for i in 0..<n {\\n            let day = i % 7 + 1, week = i / 7\\n            result += day + week\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func totalMoney(_ n: Int) -> Int {\\n        var result = 0\\n        for i in 0..<n {\\n            let day = i % 7 + 1, week = i / 7\\n            result += day + week\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1011567,
                "title": "c-1-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        return (n / 7) * 28 + (n % 7) * (n % 7 + 1) / 2 + (n / 7) * (n % 7) + ((n / 7) * (n / 7 - 1) / 2) * 7;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        return (n / 7) * 28 + (n % 7) * (n % 7 + 1) / 2 + (n / 7) * (n % 7) + ((n / 7) * (n / 7 - 1) / 2) * 7;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010768,
                "title": "c-easy-solution-0ms",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint totalMoney(int n) {\\n\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tint startPoint = 1;\\n\\n\\t\\t\\twhile(n>0){\\n\\n\\t\\t\\t\\tint i=0;\\n\\t\\t\\t\\twhile(i < 7){\\n\\t\\t\\t\\t\\tans += startPoint + i;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tn--;\\n\\t\\t\\t\\t\\tif(n==0) break;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tstartPoint++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint totalMoney(int n) {\\n\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tint startPoint = 1;\\n\\n\\t\\t\\twhile(n>0){\\n\\n\\t\\t\\t\\tint i=0;\\n\\t\\t\\t\\twhile(i < 7){\\n\\t\\t\\t\\t\\tans += startPoint + i;\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tn--;\\n\\t\\t\\t\\t\\tif(n==0) break;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1010007,
                "title": "c-0ms-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int div, mod, sum=0;\\n        div=n/7;\\n        mod=n%7;\\n        \\n        if(div==0) {\\n            for(int m=1; m<=mod; m++) {\\n                sum+=m;\\n            }\\n        }\\n        else {\\n            for(int i=1; i<=div; i++) {\\n            for(int j=i; j<7+i; j++) {\\n                sum+=j;\\n            }\\n        }\\n        if(mod!=0) {\\n            for(int k=div+1; k<=div+mod; k++) {\\n            sum+=k;\\n        }\\n        }\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\\nThe solution calculates the no of weeks and the no of extra days if any and then finds the sum for 2 cases:\\ncase1: when o week but some days\\ncase 2: 2 sub cases\\n\\t\\t\\t\\tcase a: only weeks \\n\\t\\t\\t\\tcase b: week + some extra days\\n\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int div, mod, sum=0;\\n        div=n/7;\\n        mod=n%7;\\n        \\n        if(div==0) {\\n            for(int m=1; m<=mod; m++) {\\n                sum+=m;\\n            }\\n        }\\n        else {\\n            for(int i=1; i<=div; i++) {\\n            for(int j=i; j<7+i; j++) {\\n                sum+=j;\\n            }\\n        }\\n        if(mod!=0) {\\n            for(int k=div+1; k<=div+mod; k++) {\\n            sum+=k;\\n        }\\n        }\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009485,
                "title": "java-solution",
                "content": "\\tpublic int totalMoney(int n) {\\n        int res = 0, tmp = 0;\\n        for(int i=0;i<n/7;i++)\\n            res += 28 + tmp++ * 7;\\n        for(int i=0;i<n%7;i++)\\n            res += tmp + 1 + i;\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "\\tpublic int totalMoney(int n) {\\n        int res = 0, tmp = 0;\\n        for(int i=0;i<n/7;i++)\\n            res += 28 + tmp++ * 7;\\n        for(int i=0;i<n%7;i++)\\n            res += tmp + 1 + i;\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1009220,
                "title": "python-math-with-explanation",
                "content": "```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        weeks, days = divmod(n, 7) \\n        return (28 * weeks +                        # (1+2+...+7) = 28 * number of full weeks\\n                (weeks-1) * 7 * weeks // 2 +        # (0+7+14+28+..) adding 7 for weeks - 1 starting from the second one\\n                (2*weeks + days + 1) * days // 2)   # last week sum:  (weeks + 1) + .... + [(weeks + 1) + (days - 1)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        weeks, days = divmod(n, 7) \\n        return (28 * weeks +                        # (1+2+...+7) = 28 * number of full weeks\\n                (weeks-1) * 7 * weeks // 2 +        # (0+7+14+28+..) adding 7 for weeks - 1 starting from the second one\\n                (2*weeks + days + 1) * days // 2)   # last week sum:  (weeks + 1) + .... + [(weeks + 1) + (days - 1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008981,
                "title": "c-o-n-solution-and-o-1-solution-with-brief-explanation",
                "content": "Idea:\\n1. 1st week: 1234567->28 in total\\n2. 2nd week: 2345678->35 in total\\n3. the sum of money for ith week is 7 * (i+3) (1 indexed)\\n(or 7 * (i+4) if 0 indexed)\\nO(n) solution\\n```\\nint totalMoney(int n) \\n{\\n\\tint result=0;\\n\\tfor(int i=0;i<n/7;i++)\\n\\t{\\n\\t\\tresult+=7*(i+4); //the sum of money every week\\n\\t}\\n\\tfor(int i=0;i<n%7;i++)\\n\\t{\\n\\t\\tresult+=n/7+i+1; //sum of money for the last week\\n\\t}\\n\\treturn result;\\n}\\n```\\nO(1) solution\\n```\\nint totalMoney(int n) \\n{\\n\\tint weeks=n/7,days=n%7;\\n\\treturn 7*4*weeks+7*((weeks*(weeks-1))/2)+weeks*days+days+(days*(days-1))/2;\\n}\\n```\\nExplanation:\\n```\\nweeks=n/7\\ndays=n%7\\n7 * 4 * weeks: for summation of 7 * 4 from 0~n/7\\n7*((weeks*(weeks-1))/2): for \"summation for 7 * i with i from 0~n/7\"\\nweeks * days: for summation of n/7 from 0~n%7\\ndays: for summation of 1 from 0~n%7\\n(days*(days-1))/2: for \"summation for i with i from 0~n%7\"\\n```",
                "solutionTags": [],
                "code": "```\\nint totalMoney(int n) \\n{\\n\\tint result=0;\\n\\tfor(int i=0;i<n/7;i++)\\n\\t{\\n\\t\\tresult+=7*(i+4); //the sum of money every week\\n\\t}\\n\\tfor(int i=0;i<n%7;i++)\\n\\t{\\n\\t\\tresult+=n/7+i+1; //sum of money for the last week\\n\\t}\\n\\treturn result;\\n}\\n```\n```\\nint totalMoney(int n) \\n{\\n\\tint weeks=n/7,days=n%7;\\n\\treturn 7*4*weeks+7*((weeks*(weeks-1))/2)+weeks*days+days+(days*(days-1))/2;\\n}\\n```\n```\\nweeks=n/7\\ndays=n%7\\n7 * 4 * weeks: for summation of 7 * 4 from 0~n/7\\n7*((weeks*(weeks-1))/2): for \"summation for 7 * i with i from 0~n/7\"\\nweeks * days: for summation of n/7 from 0~n%7\\ndays: for summation of 1 from 0~n%7\\n(days*(days-1))/2: for \"summation for i with i from 0~n%7\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1008968,
                "title": "java-o-1-solution",
                "content": "```\\nclass Solution {\\n\\t public int totalMoney(int n) {\\n\\tif(n<=7)\\n\\t{\\n\\t\\treturn  (n*(n+1))/2;\\n\\t}\\n\\tint total=0;\\n\\tint sum= (7*(7+1))/2;\\n\\tint last=7;\\n\\tint count=1;\\n\\twhile (n>7)\\n\\t{\\n\\t\\ttotal+=sum;\\n\\t\\tsum=sum-count;\\n\\t\\tlast+=1;\\n\\t\\tcount+=1;\\n\\t\\tsum+=last;\\n\\t\\tn=n-7;\\n\\t}\\n\\twhile (n>0)\\n\\t{\\n\\t\\ttotal+=count;\\n\\t\\tcount+=1;\\n\\t\\tn--;\\n\\t}\\n\\treturn total;\\n}\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t public int totalMoney(int n) {\\n\\tif(n<=7)\\n\\t{\\n\\t\\treturn  (n*(n+1))/2;\\n\\t}\\n\\tint total=0;\\n\\tint sum= (7*(7+1))/2;\\n\\tint last=7;\\n\\tint count=1;\\n\\twhile (n>7)\\n\\t{\\n\\t\\ttotal+=sum;\\n\\t\\tsum=sum-count;\\n\\t\\tlast+=1;\\n\\t\\tcount+=1;\\n\\t\\tsum+=last;\\n\\t\\tn=n-7;\\n\\t}\\n\\twhile (n>0)\\n\\t{\\n\\t\\ttotal+=count;\\n\\t\\tcount+=1;\\n\\t\\tn--;\\n\\t}\\n\\treturn total;\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008884,
                "title": "java-solution",
                "content": "[https://achievementguru.com/leetcode-1716-calculate-money-in-leetcode-bank-java-solution/]\\n```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int sum = 0;\\n        int div  =  n/7;\\n        \\n        int div1 =div+1;\\n        \\n        int rem = n%7;\\n        if(div>=1){\\n            sum=28;\\n            div--;\\n        }\\n        \\n        int p =sum;\\n        \\n        while(div-->0){\\n            p+=7;\\n           \\n            sum+=p;\\n             \\n        }\\n        while(rem-->0){\\n            sum+=div1;\\n            div1+=1;\\n             \\n        }\\n        \\n        return sum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int sum = 0;\\n        int div  =  n/7;\\n        \\n        int div1 =div+1;\\n        \\n        int rem = n%7;\\n        if(div>=1){\\n            sum=28;\\n            div--;\\n        }\\n        \\n        int p =sum;\\n        \\n        while(div-->0){\\n            p+=7;\\n           \\n            sum+=p;\\n             \\n        }\\n        while(rem-->0){\\n            sum+=div1;\\n            div1+=1;\\n             \\n        }\\n        \\n        return sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008882,
                "title": "c-o-noofweeks",
                "content": "Find number of weeks, each week will be a Arithmetic Progression with first element as the nth week.\\n Find sum of each of the above AP.\\n \\n    int noOfWeeks = n/7;\\n\\tint remDays = n%7;\\n\\tint i,totalSum = 0;\\n\\tfor(i=1;i<noOfWeeks+1;i++)\\n\\t  totalSum += 7*(i+3);\\n\\ttotalSum += remDays * (2*i+remDays-1) /2;\\n    return totalSum;",
                "solutionTags": [],
                "code": "Find number of weeks, each week will be a Arithmetic Progression with first element as the nth week.\\n Find sum of each of the above AP.\\n \\n    int noOfWeeks = n/7;\\n\\tint remDays = n%7;\\n\\tint i,totalSum = 0;\\n\\tfor(i=1;i<noOfWeeks+1;i++)\\n\\t  totalSum += 7*(i+3);\\n\\ttotalSum += remDays * (2*i+remDays-1) /2;\\n    return totalSum;",
                "codeTag": "Unknown"
            },
            {
                "id": 4103711,
                "title": "easy-c-solution-using-ap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int day=n%7;\\n        int div=n/7;\\n\\n        return (div*(2*28+(div-1)*7)/2)+(day*(2*(div+1)+(day-1))/2);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int totalMoney(int n) {\\n        int day=n%7;\\n        int div=n/7;\\n\\n        return (div*(2*28+(div-1)*7)/2)+(day*(2*(div+1)+(day-1))/2);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097745,
                "title": "my-solution-is-a-good-solution-this-code-solos-goku-java",
                "content": "# Intuition\\nLooking at this problem, I was thinking of just mathing it.\\n\\n# Approach\\nI just calculated the math as the increase per week is consistent. Code should be nice to read.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int mon=0;\\n        int days=n%7;\\n        int weeks=n/7;\\n        for(int i =0;i<weeks; i++){\\n            mon+=28+7*i;\\n        }\\n        for(int i =1; i<=days;i++){\\n            mon+=i+weeks;\\n        }\\n        \\n        return mon;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        int mon=0;\\n        int days=n%7;\\n        int weeks=n/7;\\n        for(int i =0;i<weeks; i++){\\n            mon+=28+7*i;\\n        }\\n        for(int i =1; i<=days;i++){\\n            mon+=i+weeks;\\n        }\\n        \\n        return mon;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095290,
                "title": "2023-09-27-second",
                "content": "# Code\\n```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        money = 0\\n        for i in range(n):\\n            money += (i + 1) // 7 + (i + 1) % 7\\n            if (i + 1) != 0 and (i + 1) % 7 == 0:\\n                money += 7 - 1\\n        return money\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        money = 0\\n        for i in range(n):\\n            money += (i + 1) // 7 + (i + 1) % 7\\n            if (i + 1) != 0 and (i + 1) % 7 == 0:\\n                money += 7 - 1\\n        return money\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085045,
                "title": "java8-solution",
                "content": "\\n# Approach\\nJava8\\n\\n# Code\\n```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        if (n <= 7) {\\n            return (n * (n + 1)) / 2;\\n        }\\n        int res = 0;\\n        int count = 1;\\n        while (n != 0) {\\n            int temp = Math.min(n, 7);\\n            res = res + IntStream.range(count, count+temp).sum();\\n            n = n - temp;\\n            count++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int totalMoney(int n) {\\n        if (n <= 7) {\\n            return (n * (n + 1)) / 2;\\n        }\\n        int res = 0;\\n        int count = 1;\\n        while (n != 0) {\\n            int temp = Math.min(n, 7);\\n            res = res + IntStream.range(count, count+temp).sum();\\n            n = n - temp;\\n            count++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074641,
                "title": "easy-javascript-solution-with-line-by-line-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar totalMoney = function (n) {\\n\\n    // initialize count and monday to zero and k to 1\\n    let count = 0, monday = 0, k = 1;\\n\\n    // loop through 1 to n\\n    for (let i = 1; i <= n; i++) {\\n\\n        // add sum of k and monday to count\\n        count += (k + monday);\\n\\n        // find monday value by dividing i by 7 and round down the value using Math.floor()\\n        monday = Math.floor(i / 7);\\n\\n        // if i modulo 7 is equal to zero then make k equal to 1 otherwise increment k\\n        if (i % 7 === 0) {\\n            k = 1;\\n        } else {\\n            k++;\\n        }\\n    }\\n\\n    // return the count\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar totalMoney = function (n) {\\n\\n    // initialize count and monday to zero and k to 1\\n    let count = 0, monday = 0, k = 1;\\n\\n    // loop through 1 to n\\n    for (let i = 1; i <= n; i++) {\\n\\n        // add sum of k and monday to count\\n        count += (k + monday);\\n\\n        // find monday value by dividing i by 7 and round down the value using Math.floor()\\n        monday = Math.floor(i / 7);\\n\\n        // if i modulo 7 is equal to zero then make k equal to 1 otherwise increment k\\n        if (i % 7 === 0) {\\n            k = 1;\\n        } else {\\n            k++;\\n        }\\n    }\\n\\n    // return the count\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1574910,
                "content": [
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta = n // 7\\n\\tb = n % 7\\n\\treturn a * 28 + 7 * (a - 1) * a // 2 + (a + 1 + a + b) * b // 2"
                    },
                    {
                        "username": "geo1923",
                        "content": "(a + 1 + a + b) * b / 2 <-- this is Gauss formula for summing n consecutive integers, (a + 1) is the first, (b + a) is the last, and they are b integers\n\n28 * a + 7 * (a - 1) * a / 2 <-- 28 is what each row would contribute if there was no increment for each Monday, therefore you do 28 * a, but you need to adjust for the increment, that is 7 each week, therefore 7 * (a - 1).\n\nBut what with the \"* a / 2\"? I don't get it, could someone explain this?\n\nEDIT: I think I got it, it's (n - 1) * n / 2 to sum the first n - 1 numbers (the first week does not bring a +7 increment, it's just 28)"
                    },
                    {
                        "username": "Akhil_176",
                        "content": "class Solution(object):\\n    def totalMoney(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        a=[1]\\n        out=1\\n\\n        income=1\\n        for i in range(2,n+1):\\n            if float((i+6)/7).is_integer() :\\n                income+=1\\n                a.append(income)\\n                out=income\\n            else:\\n                out+=1\\n                a.append(out)\\n                \\n                          \\n        \\n        return sum(a)\\n\\n      \\n\\nCan anyone tell me what is the problem with my code as on any other compiler it will work as just run this :\\n\\ndef totalMoney(n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        a=[1]\\n        out=1\\n\\n        income=1\\n        for i in range(2,n+1):\\n            if float((i+6)/7).is_integer() :\\n                income+=1\\n                a.append(income)\\n                out=income\\n            else:\\n                out+=1\\n                a.append(out)\\n                \\n                          \\n        \\n        return sum(a)\\n\\nprint(totalMoney(10))"
                    },
                    {
                        "username": "shoumikhin",
                        "content": "Week starts with a Sunday"
                    },
                    {
                        "username": "matt_lv",
                        "content": "World is not Only US you goofball"
                    },
                    {
                        "username": "singh_3662",
                        "content": "But in this Question week starts from Monday"
                    }
                ]
            },
            {
                "id": 2074706,
                "content": [
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta = n // 7\\n\\tb = n % 7\\n\\treturn a * 28 + 7 * (a - 1) * a // 2 + (a + 1 + a + b) * b // 2"
                    },
                    {
                        "username": "geo1923",
                        "content": "(a + 1 + a + b) * b / 2 <-- this is Gauss formula for summing n consecutive integers, (a + 1) is the first, (b + a) is the last, and they are b integers\n\n28 * a + 7 * (a - 1) * a / 2 <-- 28 is what each row would contribute if there was no increment for each Monday, therefore you do 28 * a, but you need to adjust for the increment, that is 7 each week, therefore 7 * (a - 1).\n\nBut what with the \"* a / 2\"? I don't get it, could someone explain this?\n\nEDIT: I think I got it, it's (n - 1) * n / 2 to sum the first n - 1 numbers (the first week does not bring a +7 increment, it's just 28)"
                    },
                    {
                        "username": "Akhil_176",
                        "content": "class Solution(object):\\n    def totalMoney(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        a=[1]\\n        out=1\\n\\n        income=1\\n        for i in range(2,n+1):\\n            if float((i+6)/7).is_integer() :\\n                income+=1\\n                a.append(income)\\n                out=income\\n            else:\\n                out+=1\\n                a.append(out)\\n                \\n                          \\n        \\n        return sum(a)\\n\\n      \\n\\nCan anyone tell me what is the problem with my code as on any other compiler it will work as just run this :\\n\\ndef totalMoney(n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        a=[1]\\n        out=1\\n\\n        income=1\\n        for i in range(2,n+1):\\n            if float((i+6)/7).is_integer() :\\n                income+=1\\n                a.append(income)\\n                out=income\\n            else:\\n                out+=1\\n                a.append(out)\\n                \\n                          \\n        \\n        return sum(a)\\n\\nprint(totalMoney(10))"
                    },
                    {
                        "username": "shoumikhin",
                        "content": "Week starts with a Sunday"
                    },
                    {
                        "username": "matt_lv",
                        "content": "World is not Only US you goofball"
                    },
                    {
                        "username": "singh_3662",
                        "content": "But in this Question week starts from Monday"
                    }
                ]
            },
            {
                "id": 1806604,
                "content": [
                    {
                        "username": "FACEPLANT",
                        "content": "\\ta = n // 7\\n\\tb = n % 7\\n\\treturn a * 28 + 7 * (a - 1) * a // 2 + (a + 1 + a + b) * b // 2"
                    },
                    {
                        "username": "geo1923",
                        "content": "(a + 1 + a + b) * b / 2 <-- this is Gauss formula for summing n consecutive integers, (a + 1) is the first, (b + a) is the last, and they are b integers\n\n28 * a + 7 * (a - 1) * a / 2 <-- 28 is what each row would contribute if there was no increment for each Monday, therefore you do 28 * a, but you need to adjust for the increment, that is 7 each week, therefore 7 * (a - 1).\n\nBut what with the \"* a / 2\"? I don't get it, could someone explain this?\n\nEDIT: I think I got it, it's (n - 1) * n / 2 to sum the first n - 1 numbers (the first week does not bring a +7 increment, it's just 28)"
                    },
                    {
                        "username": "Akhil_176",
                        "content": "class Solution(object):\\n    def totalMoney(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        a=[1]\\n        out=1\\n\\n        income=1\\n        for i in range(2,n+1):\\n            if float((i+6)/7).is_integer() :\\n                income+=1\\n                a.append(income)\\n                out=income\\n            else:\\n                out+=1\\n                a.append(out)\\n                \\n                          \\n        \\n        return sum(a)\\n\\n      \\n\\nCan anyone tell me what is the problem with my code as on any other compiler it will work as just run this :\\n\\ndef totalMoney(n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        a=[1]\\n        out=1\\n\\n        income=1\\n        for i in range(2,n+1):\\n            if float((i+6)/7).is_integer() :\\n                income+=1\\n                a.append(income)\\n                out=income\\n            else:\\n                out+=1\\n                a.append(out)\\n                \\n                          \\n        \\n        return sum(a)\\n\\nprint(totalMoney(10))"
                    },
                    {
                        "username": "shoumikhin",
                        "content": "Week starts with a Sunday"
                    },
                    {
                        "username": "matt_lv",
                        "content": "World is not Only US you goofball"
                    },
                    {
                        "username": "singh_3662",
                        "content": "But in this Question week starts from Monday"
                    }
                ]
            }
        ]
    }
]