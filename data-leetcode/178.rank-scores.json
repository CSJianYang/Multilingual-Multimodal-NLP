[
    {
        "title": "Subsets",
        "question_content": "Given an integer array nums of unique elements, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\nExample 2:\n\nInput: nums = [0]\nOutput: [[],[0]]\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 10\n\t-10 <= nums[i] <= 10\n\tAll the numbers of&nbsp;nums are unique.",
        "solutions": [
            {
                "id": 27281,
                "title": "a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning",
                "content": "This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum. \\n\\nSubsets : [https://leetcode.com/problems/subsets/][1]\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n\\n\\nSubsets II (contains duplicates) : [https://leetcode.com/problems/subsets-ii/][2]\\n\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    } \\n\\n\\n----------\\n\\nPermutations : [https://leetcode.com/problems/permutations/][3]\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       // Arrays.sort(nums); // not necessary\\n       backtrack(list, new ArrayList<>(), nums);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\\n       if(tempList.size() == nums.length){\\n          list.add(new ArrayList<>(tempList));\\n       } else{\\n          for(int i = 0; i < nums.length; i++){ \\n             if(tempList.contains(nums[i])) continue; // element already exists, skip\\n             tempList.add(nums[i]);\\n             backtrack(list, tempList, nums);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    } \\n\\nPermutations II (contains duplicates) : [https://leetcode.com/problems/permutations-ii/][4]\\n\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\\n        if(tempList.size() == nums.length){\\n            list.add(new ArrayList<>(tempList));\\n        } else{\\n            for(int i = 0; i < nums.length; i++){\\n                if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\\n                used[i] = true; \\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, used);\\n                used[i] = false; \\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\n\\n----------\\n\\nCombination Sum : [https://leetcode.com/problems/combination-sum/][5]\\n\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{ \\n            for(int i = start; i < nums.length; i++){\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\nCombination Sum II (can't reuse same element) : [https://leetcode.com/problems/combination-sum-ii/][6]\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n        \\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for(int i = start; i < nums.length; i++){\\n                if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i + 1);\\n                tempList.remove(tempList.size() - 1); \\n            }\\n        }\\n    } \\n\\n\\nPalindrome Partitioning : [https://leetcode.com/problems/palindrome-partitioning/][7]\\n\\n    public List<List<String>> partition(String s) {\\n       List<List<String>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<>(), s, 0);\\n       return list;\\n    }\\n    \\n    public void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\\n       if(start == s.length())\\n          list.add(new ArrayList<>(tempList));\\n       else{\\n          for(int i = start; i < s.length(); i++){\\n             if(isPalindrome(s, start, i)){\\n                tempList.add(s.substring(start, i + 1));\\n                backtrack(list, tempList, s, i + 1);\\n                tempList.remove(tempList.size() - 1);\\n             }\\n          }\\n       }\\n    }\\n    \\n    public boolean isPalindrome(String s, int low, int high){\\n       while(low < high)\\n          if(s.charAt(low++) != s.charAt(high--)) return false;\\n       return true;\\n    } \\n\\n\\n\\n  [1]: https://leetcode.com/problems/subsets/\\n  [2]: https://leetcode.com/problems/subsets-ii/\\n  [3]: https://leetcode.com/problems/permutations/\\n  [4]: https://leetcode.com/problems/permutations-ii/\\n  [5]: https://leetcode.com/problems/combination-sum/\\n  [6]: https://leetcode.com/problems/combination-sum-ii/\\n  [7]: https://leetcode.com/problems/palindrome-partitioning/",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum. \\n\\nSubsets : [https://leetcode.com/problems/subsets/][1]\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n\\n\\nSubsets II (contains duplicates) : [https://leetcode.com/problems/subsets-ii/][2]\\n\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    } \\n\\n\\n----------\\n\\nPermutations : [https://leetcode.com/problems/permutations/][3]\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       // Arrays.sort(nums); // not necessary\\n       backtrack(list, new ArrayList<>(), nums);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\\n       if(tempList.size() == nums.length){\\n          list.add(new ArrayList<>(tempList));\\n       } else{\\n          for(int i = 0; i < nums.length; i++){ \\n             if(tempList.contains(nums[i])) continue; // element already exists, skip\\n             tempList.add(nums[i]);\\n             backtrack(list, tempList, nums);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    } \\n\\nPermutations II (contains duplicates) : [https://leetcode.com/problems/permutations-ii/][4]\\n\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\\n        if(tempList.size() == nums.length){\\n            list.add(new ArrayList<>(tempList));\\n        } else{\\n            for(int i = 0; i < nums.length; i++){\\n                if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\\n                used[i] = true; \\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, used);\\n                used[i] = false; \\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\n\\n----------\\n\\nCombination Sum : [https://leetcode.com/problems/combination-sum/][5]\\n\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{ \\n            for(int i = start; i < nums.length; i++){\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\nCombination Sum II (can't reuse same element) : [https://leetcode.com/problems/combination-sum-ii/][6]\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n        \\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for(int i = start; i < nums.length; i++){\\n                if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i + 1);\\n                tempList.remove(tempList.size() - 1); \\n            }\\n        }\\n    } \\n\\n\\nPalindrome Partitioning : [https://leetcode.com/problems/palindrome-partitioning/][7]\\n\\n    public List<List<String>> partition(String s) {\\n       List<List<String>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<>(), s, 0);\\n       return list;\\n    }\\n    \\n    public void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\\n       if(start == s.length())\\n          list.add(new ArrayList<>(tempList));\\n       else{\\n          for(int i = start; i < s.length(); i++){\\n             if(isPalindrome(s, start, i)){\\n                tempList.add(s.substring(start, i + 1));\\n                backtrack(list, tempList, s, i + 1);\\n                tempList.remove(tempList.size() - 1);\\n             }\\n          }\\n       }\\n    }\\n    \\n    public boolean isPalindrome(String s, int low, int high){\\n       while(low < high)\\n          if(s.charAt(low++) != s.charAt(high--)) return false;\\n       return true;\\n    } \\n\\n\\n\\n  [1]: https://leetcode.com/problems/subsets/\\n  [2]: https://leetcode.com/problems/subsets-ii/\\n  [3]: https://leetcode.com/problems/permutations/\\n  [4]: https://leetcode.com/problems/permutations-ii/\\n  [5]: https://leetcode.com/problems/combination-sum/\\n  [6]: https://leetcode.com/problems/combination-sum-ii/\\n  [7]: https://leetcode.com/problems/palindrome-partitioning/",
                "codeTag": "Unknown"
            },
            {
                "id": 27278,
                "title": "c-recursive-iterative-bit-manipulation",
                "content": "**Recursive (Backtracking)**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> subs;\\n        vector<int> sub;\\n        subsets(nums, 0, sub, subs);\\n        return subs;\\n    }\\nprivate:\\n    void subsets(vector<int>& nums, int i, vector<int>& sub, vector<vector<int>>& subs) {\\n        subs.push_back(sub);\\n        for (int j = i; j < nums.size(); j++) {\\n            sub.push_back(nums[j]);\\n            subsets(nums, j + 1, sub, subs);\\n            sub.pop_back();\\n        }\\n    }\\n};\\n```\\n\\n**Iterative**\\n\\nUsing `[1, 2, 3]` as an example, the iterative process is like:\\n\\n 1. Initially, one empty subset `[[]]`\\n 2. Adding `1` to `[]`: `[[], [1]]`;\\n 3. Adding `2` to `[]` and `[1]`: `[[], [1], [2], [1, 2]]`;\\n 4. Adding `3` to `[]`, `[1]`, `[2]` and `[1, 2]`: `[[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> subs = {{}};\\n        for (int num : nums) {\\n            int n = subs.size();\\n            for (int i = 0; i < n; i++) {\\n                subs.push_back(subs[i]); \\n                subs.back().push_back(num);\\n            }\\n        }\\n        return subs;\\n    }\\n}; \\n```\\n\\n**Bit Manipulation**\\n\\nTo give all the possible subsets, we just need to exhaust all the possible combinations of the numbers. And each number has only two possibilities: either in or not in a subset. And this can be represented using a bit.\\n\\nUsing `[1, 2, 3]` as an example, `1` appears once in every two consecutive subsets, `2` appears twice in every four consecutive subsets, and `3` appears four times in every eight subsets (initially all subsets are empty):\\n\\n```\\n[], [ ], [ ], [    ], [ ], [    ], [    ], [       ]\\n[], [1], [ ], [1   ], [ ], [1   ], [    ], [1      ]\\n[], [1], [2], [1, 2], [ ], [1   ], [2   ], [1, 2   ]\\n[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]\\n```\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size(), p = 1 << n;\\n        vector<vector<int>> subs(p);\\n        for (int i = 0; i < p; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if ((i >> j) & 1) {\\n                    subs[i].push_back(nums[j]);\\n                }\\n            }\\n        }\\n        return subs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> subs;\\n        vector<int> sub;\\n        subsets(nums, 0, sub, subs);\\n        return subs;\\n    }\\nprivate:\\n    void subsets(vector<int>& nums, int i, vector<int>& sub, vector<vector<int>>& subs) {\\n        subs.push_back(sub);\\n        for (int j = i; j < nums.size(); j++) {\\n            sub.push_back(nums[j]);\\n            subsets(nums, j + 1, sub, subs);\\n            sub.pop_back();\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> subs = {{}};\\n        for (int num : nums) {\\n            int n = subs.size();\\n            for (int i = 0; i < n; i++) {\\n                subs.push_back(subs[i]); \\n                subs.back().push_back(num);\\n            }\\n        }\\n        return subs;\\n    }\\n}; \\n```\n```\\n[], [ ], [ ], [    ], [ ], [    ], [    ], [       ]\\n[], [1], [ ], [1   ], [ ], [1   ], [    ], [1      ]\\n[], [1], [2], [1, 2], [ ], [1   ], [2   ], [1, 2   ]\\n[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size(), p = 1 << n;\\n        vector<vector<int>> subs(p);\\n        for (int i = 0; i < p; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if ((i >> j) & 1) {\\n                    subs[i].push_back(nums[j]);\\n                }\\n            }\\n        }\\n        return subs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 122645,
                "title": "3ms-easiest-solution-no-backtracking-no-bit-manipulation-no-dfs-no-bullshit",
                "content": "While iterating through all numbers, for each new number, we can either pick it or not pick it\\n1, if pick, just add current number to every existing subset.\\n2, if not pick, just leave all existing subsets as they are.\\nWe just combine both into our result.\\n\\nFor example, {1,2,3} intially we have an emtpy set as result [ [ ] ]\\nConsidering 1, if not use it, still [ ], if use 1, add it to [ ], so we have [1] now\\nCombine them, now we have [ [ ], [1] ] as all possible subset\\n\\nNext considering 2, if not use it, we still have [ [ ], [1] ], if use 2, just add 2 to each previous subset, we have [2], [1,2]\\nCombine them, now we have [ [ ], [1], [2], [1,2] ]\\n\\nNext considering 3, if not use it, we still have  [ [ ], [1], [2], [1,2] ], if use 3, just add 3 to each previous subset, we have [ [3], [1,3], [2,3], [1,2,3] ]\\nCombine them, now we have  [ [ ], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3] ]\\n\\n```\\npublic List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(new ArrayList<>());\\n        for(int n : nums){\\n            int size = result.size();\\n            for(int i=0; i<size; i++){\\n                List<Integer> subset = new ArrayList<>(result.get(i));\\n                subset.add(n);\\n                result.add(subset);\\n            }\\n        }\\n        return result;\\n    }\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(new ArrayList<>());\\n        for(int n : nums){\\n            int size = result.size();\\n            for(int i=0; i<size; i++){\\n                List<Integer> subset = new ArrayList<>(result.get(i));\\n                subset.add(n);\\n                result.add(subset);\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 27301,
                "title": "python-easy-to-understand-solutions-dfs-recursively-bit-manipulation-iteratively",
                "content": "```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        ret = []\\n        self.dfs(nums, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, path, ret):\\n        ret.append(path)\\n        for i in range(len(nums)):\\n            self.dfs(nums[i+1:], path+[nums[i]], ret)\\n       \\n    # Bit Manipulation    \\n    def subsets2(self, nums):\\n        res = []\\n        nums.sort()\\n        for i in xrange(1<<len(nums)):\\n            tmp = []\\n            for j in xrange(len(nums)):\\n                if i & 1 << j:  # if i >> j & 1:\\n                    tmp.append(nums[j])\\n            res.append(tmp)\\n        return res\\n\\t\\t\\n    # Iteratively\\n    def subsets(self, nums):\\n        res = [[]]\\n        for num in sorted(nums):\\n            res += [item+[num] for item in res]\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        ret = []\\n        self.dfs(nums, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, path, ret):\\n        ret.append(path)\\n        for i in range(len(nums)):\\n            self.dfs(nums[i+1:], path+[nums[i]], ret)\\n       \\n    # Bit Manipulation    \\n    def subsets2(self, nums):\\n        res = []\\n        nums.sort()\\n        for i in xrange(1<<len(nums)):\\n            tmp = []\\n            for j in xrange(len(nums)):\\n                if i & 1 << j:  # if i >> j & 1:\\n                    tmp.append(nums[j])\\n            res.append(tmp)\\n        return res\\n\\t\\t\\n    # Iteratively\\n    def subsets(self, nums):\\n        res = [[]]\\n        for num in sorted(nums):\\n            res += [item+[num] for item in res]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27288,
                "title": "my-solution-using-bit-manipulation",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int> > subsets(vector<int> &S) {\\n            sort (S.begin(), S.end());\\n            int elem_num = S.size();\\n            int subset_num = pow (2, elem_num);\\n            vector<vector<int> > subset_set (subset_num, vector<int>());\\n            for (int i = 0; i < elem_num; i++)\\n                for (int j = 0; j < subset_num; j++)\\n                    if ((j >> i) & 1)\\n                        subset_set[j].push_back (S[i]);\\n            return subset_set;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > subsets(vector<int> &S) {\\n            sort (S.begin(), S.end());\\n            int elem_num = S.size();\\n            int subset_num = pow (2, elem_num);\\n            vector<vector<int> > subset_set (subset_num, vector<int>());\\n            for (int i = 0; i < elem_num; i++)\\n                for (int j = 0; j < subset_num; j++)\\n                    if ((j >> i) & 1)\\n                        subset_set[j].push_back (S[i]);\\n            return subset_set;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 429534,
                "title": "general-backtracking-questions-solutions-in-python-for-reference",
                "content": "I have taken solutions of @caikehe from frequently asked backtracking questions which I found really helpful and had copied for my reference. I thought this post will be helpful for everybody as in an interview I think these basic solutions can come in handy. Please add any more questions in comments that you think might be important and I can add it in the post.\\n\\n#### Combinations :\\n```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```  \\n\\t\\n#### Permutations I\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```        \\n\\n#### Permutations II\\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\\n\\n \\n#### Subsets 1\\n\\n\\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Subsets II  \\n\\n\\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Combination Sum        \\n\\n\\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\\n\\n        \\n        \\n#### Combination Sum II        \\n\\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27356,
                "title": "5-lines-of-python",
                "content": "    class Solution(object):\\n        def subsets(self, nums):\\n            nums.sort()\\n            result = [[]]\\n            for num in nums:\\n                result += [i + [num] for i in result]\\n            return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def subsets(self, nums):\\n            nums.sort()\\n            result = [[]]\\n            for num in nums:\\n                result += [i + [num] for i in result]\\n            return result",
                "codeTag": "Java"
            },
            {
                "id": 731215,
                "title": "c-3-approaches-recursive-iterative-bit-manipulation-solutions",
                "content": "```\\n// Recursive Solution\\n// Time complexity : O(N*(2^N))\\n// Space complexity : O(N*(2^N))\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    \\n    void sub(vector<int> &nums, int i, vector<int> temp)\\n    {\\n        if(i==nums.size())\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        sub(nums, i+1, temp);\\n        temp.push_back(nums[i]);\\n        sub(nums, i+1, temp);\\n    }\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int> temp;       \\n        sub(nums, 0, temp); // or sub(nums, 0, vector<int> {});\\n        return ans;\\n    }\\n};\\n```\\n```\\n// Iterative Solution\\n// Time complexity : O(N*(2^N))\\n// Space complexity : O(N*(2^N))\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int n = nums.size();\\n        \\n        ans.push_back({});\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int sz = ans.size();\\n            for(int j=0; j<sz; j++)\\n            {\\n                vector<int> temp = ans[j];\\n                temp.push_back(nums[i]);\\n                ans.push_back(temp);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n```\\n// Bit Manipulation\\n// Time complexity : O(N*(2^N))\\n// Space complexity : O(N*(2^N))\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int n = nums.size();\\n        int num = pow(2, n), i = 0;\\n        \\n        while(i<num)\\n        {\\n            vector<int> temp;\\n            for(int j=0; j<n; j++)\\n            {\\n                if(i & 1<<j)\\n                    temp.push_back(nums[j]);\\n            }\\n            ans.push_back(temp);\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion",
                    "Iterator",
                    "Bitmask"
                ],
                "code": "```\\n// Recursive Solution\\n// Time complexity : O(N*(2^N))\\n// Space complexity : O(N*(2^N))\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    \\n    void sub(vector<int> &nums, int i, vector<int> temp)\\n    {\\n        if(i==nums.size())\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        sub(nums, i+1, temp);\\n        temp.push_back(nums[i]);\\n        sub(nums, i+1, temp);\\n    }\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int> temp;       \\n        sub(nums, 0, temp); // or sub(nums, 0, vector<int> {});\\n        return ans;\\n    }\\n};\\n```\n```\\n// Iterative Solution\\n// Time complexity : O(N*(2^N))\\n// Space complexity : O(N*(2^N))\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int n = nums.size();\\n        \\n        ans.push_back({});\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int sz = ans.size();\\n            for(int j=0; j<sz; j++)\\n            {\\n                vector<int> temp = ans[j];\\n                temp.push_back(nums[i]);\\n                ans.push_back(temp);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\n// Bit Manipulation\\n// Time complexity : O(N*(2^N))\\n// Space complexity : O(N*(2^N))\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int n = nums.size();\\n        int num = pow(2, n), i = 0;\\n        \\n        while(i<num)\\n        {\\n            vector<int> temp;\\n            for(int j=0; j<n; j++)\\n            {\\n                if(i & 1<<j)\\n                    temp.push_back(nums[j]);\\n            }\\n            ans.push_back(temp);\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766675,
                "title": "java-intuition-of-approach-backtracking",
                "content": "****\\nPlease upvote if the explanation helps, as it keeps up the motivation to provide such posts.\\n****\\n\\n**Intuition**\\n\\nThis falls into a set of classic problems that can be solved using \"pick\"- \"don\\'t pick\" approach. \\n\\n![image](https://assets.leetcode.com/users/images/1ca8ad88-a0dc-4995-82e0-ce6822177b98_1621218217.2663536.png)\\n\\nAs through observation, it is clear that we start with having a choice to pick or not pick from the first element and then, we propagate this choice down the tree. \\nSo, \\n1. we either pick the element and move ahead ( increment the index ) or,\\n2. we don\\'t pick the element and move ahead\\n\\n```\\nclass Solution {\\n    List<List<Integer>> result;\\n    public List<List<Integer>> subsets(int[] nums) {\\n        result = new ArrayList();\\n        if(nums==null || nums.length==0) return result;\\n        \\n        subsets(nums,new ArrayList<Integer>(), 0);\\n        return result;\\n    }\\n    \\n    private void subsets(int[] nums, ArrayList<Integer> temp, int index) {\\n        // base condition\\n        if(index >= nums.length) {\\n            result.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        \\n        // main logic\\n\\t\\t// case 1 : we pick the element\\n        temp.add(nums[index]);\\n        subsets(nums, temp, index+1); // move ahead\\n        temp.remove(temp.size()-1);\\n        \\n\\t\\t// case 2 : we don\\'t pick the element ( notice, we did not add the current element in our temporary list\\n        subsets(nums, temp, index+1); // move ahead\\n    }\\n}\\n```\\n*****\\n\\n\\u2714\\uFE0F **Another related problems** : \\n* https://leetcode.com/problems/subsets-ii/\\n* https://leetcode.com/problems/permutations/\\n* https://leetcode.com/problems/permutations-ii/\\n* https://leetcode.com/problems/combination-sum/\\n* https://leetcode.com/problems/combination-sum-ii/\\n* https://leetcode.com/problems/palindrome-partitioning/\\n\\n\\n\\u2714\\uFE0F **Complexity Analysis:**\\n* TC: `O(n * 2^n)`, as every element has two options-to pick or not pick and `n` bcz we are copying the list of size `n` in base case.\\n* SC: `O(n * 2^n)`\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> result;\\n    public List<List<Integer>> subsets(int[] nums) {\\n        result = new ArrayList();\\n        if(nums==null || nums.length==0) return result;\\n        \\n        subsets(nums,new ArrayList<Integer>(), 0);\\n        return result;\\n    }\\n    \\n    private void subsets(int[] nums, ArrayList<Integer> temp, int index) {\\n        // base condition\\n        if(index >= nums.length) {\\n            result.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        \\n        // main logic\\n\\t\\t// case 1 : we pick the element\\n        temp.add(nums[index]);\\n        subsets(nums, temp, index+1); // move ahead\\n        temp.remove(temp.size()-1);\\n        \\n\\t\\t// case 2 : we don\\'t pick the element ( notice, we did not add the current element in our temporary list\\n        subsets(nums, temp, index+1); // move ahead\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27279,
                "title": "simple-java-solution-with-for-each-loops",
                "content": "No  messy indexing. Avoid the ConcurrentModificationException by using a temp list.\\n\\n    public class Solution {\\n        public List<List<Integer>> subsets(int[] S) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            res.add(new ArrayList<Integer>());\\n            \\n            Arrays.sort(S);\\n            for(int i : S) {\\n                List<List<Integer>> tmp = new ArrayList<>();\\n                for(List<Integer> sub : res) {\\n                    List<Integer> a = new ArrayList<>(sub);\\n                    a.add(i);\\n                    tmp.add(a);\\n                }\\n                res.addAll(tmp);\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> subsets(int[] S) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            res.add(new ArrayList<Integer>());\\n            \\n            Arrays.sort(S);\\n            for(int i : S) {\\n                List<List<Integer>> tmp = new ArrayList<>();\\n                for(List<Integer> sub : res) {\\n                    List<Integer> a = new ArrayList<>(sub);\\n                    a.add(i);\\n                    tmp.add(a);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 973667,
                "title": "backtracking-template-explanation-visual-python",
                "content": "TL;DR use standard backtracking template that can be applied to backtracking problems that involve [combinations](https://leetcode.com/problems/combinations/) or [permutations](https://leetcode.com/problems/permutations/discuss/971584/Backtracking-or-Explanation-%2B-Visual-or-Python)\\n\\n(starter list of problems that use template  below + explanation + visual) \\n\\n```python \\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\t    res, path = [], []\\n        self.dfs(0, res, path, nums)\\n        return res\\n\\t\\t\\n def dfs(self, index, res, path, nums):\\n        res.append(list(path)) \\n        for i in range(index, len(nums)):\\n            path.append(nums[i])\\n            self.dfs(i+1, res, path, nums)\\n            path.pop()\\n```\\n#### Problems That Use This Template\\n1. [Combinations](https://leetcode.com/problems/combinations/)\\n2. [Combination Sum I](https://leetcode.com/problems/combination-sum/)\\n3. [Combination sum II](https://leetcode.com/problems/combination-sum-ii/)\\n4. [Combination sum III](https://leetcode.com/problems/combination-sum-iii/)\\n5. [N Queens I](https://leetcode.com/problems/n-queens/)\\n6. [N Queens II](https://leetcode.com/problems/n-queens-ii/discuss/)\\n7. [Permutations I](https://leetcode.com/problems/permutations/)\\n8. [Permutations II](https://leetcode.com/problems/permutations-ii/discuss/972627/Backtracking-%2B-Permutation-Template-or-Explanation-or-Python)\\n\\n(there are definetly more problems that use this template feel free to comment below if you know one and i will update the list) \\n\\n### Explanation + Visual \\n\\nThe goal is to generate all possible subsets given a set of ```N``` elements. \\n\\nTo put another way the goal is to find the power (the set of all subsets) set of ```S``` (the given set of elements) \\n\\nAll subsets must be generated,  meaning all options must be exaushted. This indicates that backtracking is a good approach to take to solve the problem.  \\n\\nFrom a recursive perspective, a choice is made at each step, to include an element in the subset or exclude an element from the subset. the choice is binary (yes or no) and this choice must be made for all  ```N``` elements and we make every choice. this results in a runtime of \\n```O(N*2^N)``` \\n\\nThe code uses a DFS traversal and undoes previous decisions by removing a previous choice from the current subset. ***This is the heart of backtracking***, we try all possibilities knowing that some may not lead to a solution. when path no longer can lead to a solution, the decision is reveresed. \\n\\nTo understand the code for this problem, it is essntial to understand how the recursion tree (state space tree) is generated. Thus i have provided a visual with numbers to denote the order in which nodes are generated. \\n\\nVisual is for example ```[1, 2 , 3]```\\n![image](https://assets.leetcode.com/users/images/5252e51a-8e1f-4394-af00-0c0bea61aa8b_1608066366.6589456.png)\\n\\n",
                "solutionTags": [],
                "code": "```python \\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\t    res, path = [], []\\n        self.dfs(0, res, path, nums)\\n        return res\\n\\t\\t\\n def dfs(self, index, res, path, nums):\\n        res.append(list(path)) \\n        for i in range(index, len(nums)):\\n            path.append(nums[i])\\n            self.dfs(i+1, res, path, nums)\\n            path.pop()\\n```\n```N```\n```S```\n```N```\n```O(N*2^N)```\n```[1, 2 , 3]```",
                "codeTag": "Python3"
            },
            {
                "id": 27511,
                "title": "c-8ms-simple-iterative-solution",
                "content": "    class Solution {\\n    public:\\n\\tvector<vector<int> > subsets(vector<int> &S) {\\n\\t\\tvector<vector<int> > res(1, vector<int>());\\n\\t\\tsort(S.begin(), S.end());\\n\\t\\t\\n\\t\\tfor (int i = 0; i < S.size(); i++) {\\n\\t\\t\\tint n = res.size();\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tres.push_back(res[j]);\\n\\t\\t\\t\\tres.back().push_back(S[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t  }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n\\tvector<vector<int> > subsets(vector<int> &S) {\\n\\t\\tvector<vector<int> > res(1, vector<int>());\\n\\t\\tsort(S.begin(), S.end());\\n\\t\\t\\n\\t\\tfor (int i = 0; i < S.size(); i++) {\\n\\t\\t\\tint n = res.size();\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tres.push_back(res[j]);\\n\\t\\t\\t\\tres.back().push_back(S[i]);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1766969,
                "title": "c-100-faster-solution-0-ms-bit-manipulation-easy-to-understand",
                "content": "**Upvote if helpful**\\n\\n**Explaination** : We can use a n-bit integer ( from 0 to 2^n-1) whose individual bits represent wether the element(present at ith index) of the string is included or not.\\nthe two options can be represented as :\\n\\n* \\'1\\' (set bit ) denotes element included\\n\\n* \\'0\\' denotes element not included\\n\\n**If the ith bit in the integer is set then, append ith element from the string for the subset.**\\n```\\nTry to understand this thing with the help of example:\\n\\nchar s[3] = [\\'1\\' , \\'2\\' , \\'3\\' ]\\nTotal number of subsets = pow(2, n) = pow(2, 3) = 8\\nValue of integer Subsets\\n\\n000                    -> Empty set\\n001                    -> 1\\n010                    -> 2\\n011                    -> 12\\n100                    -> 3\\n101                    -> 13\\n110                    -> 23\\n111                    -> 123\\n```\\n![image](https://assets.leetcode.com/users/images/a78610ac-542e-4301-8c85-0e236a43dec6_1644758596.1727226.png)\\n\\n* **Code**\\n```\\nvoid findsub( vector<vector<int>> &res , vector<int> nums , int i){\\n        int j = 0;\\n        vector<int>v;\\n        while(i>0){\\n            if((i&1)==1) v.push_back(nums[j]);\\n            j++;\\n            i = i>>1;\\n        }\\n        res.push_back(v);\\n        return;\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        int n = nums.size();\\n        for(int i = 0 ; i < (1<<n) ;i++){\\n            findsub(res,nums,i);\\n        }\\n        return res;\\n    }\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nTry to understand this thing with the help of example:\\n\\nchar s[3] = [\\'1\\' , \\'2\\' , \\'3\\' ]\\nTotal number of subsets = pow(2, n) = pow(2, 3) = 8\\nValue of integer Subsets\\n\\n000                    -> Empty set\\n001                    -> 1\\n010                    -> 2\\n011                    -> 12\\n100                    -> 3\\n101                    -> 13\\n110                    -> 23\\n111                    -> 123\\n```\n```\\nvoid findsub( vector<vector<int>> &res , vector<int> nums , int i){\\n        int j = 0;\\n        vector<int>v;\\n        while(i>0){\\n            if((i&1)==1) v.push_back(nums[j]);\\n            j++;\\n            i = i>>1;\\n        }\\n        res.push_back(v);\\n        return;\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        int n = nums.size();\\n        for(int i = 0 ; i < (1<<n) ;i++){\\n            findsub(res,nums,i);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 940599,
                "title": "3-approaches-for-your-interview-dry-run-iterative-recursive-bitmasking",
                "content": "#### **Approach  1:** Recursive\\n* simplest insight is to follow : `\\'take it\\'`, and` \\'dont take\\' `approach\\n\\n<br>\\n\\n```\\nvar subsets = function(nums) {\\n\\tlet res=[]                    // the final arr, which we will display\\n\\tlet auxArr = [], i=0             // global vars\\n    \\n    function recur(nums,i,auxArr){\\n        if(i==nums.length) { res.push(auxArr); return } //operation of recursion will be upto i=n-1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t // when it will hit, i==n, it will store the computed arr, in the final arr, and break(return)\\n        \\n\\t\\t// take it\\n        recur(nums, i+1, [...auxArr, nums[i] ] ) //or, we can use \\'aux.concat(nums[i])\\'\\n\\t\\t\\n\\t\\t// dont take\\n        recur(nums, i+1, auxArr)\\n    \\n    }\\n    \\n    recur(nums,i,auxArr) // passing the global variable declared already\\n    return res        // rerturn the final 2d arr\\n    \\n    \\n};\\n\\n\\n\\t                  1 2 3\\n \\t\\t\\t\\t  /           \\\\\\n \\t\\t    \\t1 \\t\\t\\t     []\\t\\n              /     \\\\           /.  \\\\\\n            1 2\\t     1\\t       2.    []\\n           /  \\\\\\t\\t/ \\\\       / \\\\    / \\\\\\n        123.   12. 13. 1.    23. 2. 3. [].\\n\\n```\\n\\nAll the left part are result of : `\\'Take it\\'`\\nAll the right one are :  `\\'dont take\\'`\\n<br><br><br>\\n<hr><hr>\\n<br>\\n\\n#### **Approach 2**  : Iterative \\n\\n```\\nvar subsets = function(nums) {\\n    let res = [[]], appendarr= []\\n    \\n    for(let num of nums){\\n        appendarr = []\\n        for(let entry of res){\\n            appendarr.push([...entry, num])\\n        }\\n        \\n        res.push(...appendarr)\\n    }\\n    \\n    return res\\n    \\n};\\n\\n\\n0 (Empty)             :         [] \\n1 (Adding 1 to it)    :         [] [1] \\n2 (Adding 2 to it)    :         [] [1] [2] [1,2]\\n3 (Adding 3 to it)    :         [] [1] [2] [1,2] [3] [1,3] [2,3] [1,2,3]\\n```\\n\\n<br> <br> <br> <hr> <hr>\\n#### **Approach 3** : Bit Masking \\n<br> <br>\\n```\\nvar subsets = function(nums) {\\n  const result = [];\\n  result.push([]);   // handling the first case (i=0). for that, an empty arr should be there\\n  \\n  let size = nums.length\\n  \\n  for(let i = 1; i < (1<<size) ; i++){   // generating for range upto [(2^n)-1]\\n    let subset = [];\\n    let bitmask=0\\n    \\n      while(bitmask<size){\\n          if(i & (1 << bitmask)){           // if it exists (not zero)\\n              subset.push( nums[bitmask] );\\n          }\\n          bitmask++   \\n      }\\n      result.push(subset)\\n  }\\n  return result\\n};\\n```\\n<br> <br>\\n```\\nDry Run: \\n\\nlets take nums = [1,2,3]\\nwe will be searching all elem from 0-> 2^n\\n\\nso, checking :\\n\\ni         \\n\\u2B07                                  while(bitmask<size)\\n\\n0 [000]                             [ ] \\n\\n\\n1 [001]      i=1.           \\n\\t\\t\\t\\t\\t\\t\\ti\\t\\t001      001      001\\n\\t\\t\\t  \\t          mask\\t    001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t   ----     ----     ----\\n\\t\\t\\t\\t\\t\\t\\t\\t  [001]      000      000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n2 [010]      i=2.                        \\n\\t\\t\\t\\t\\t       i        010      010      010\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t000     [010]     000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3 [011]      i=3.           \\n\\t\\t\\t\\t\\t       i        011      011      011\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t  [001]     [010]     000\\n\\t\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t\\t\\t  \\n4 [100]      i=4.         \\n\\t\\t\\t\\t\\t       i        100      100      100\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t000      000     [100]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n5 [101]      i=5.           \\n\\t\\t\\t\\t\\t       i        101      101      101\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t   [001]      000     [100]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n6 [110]      i=6.          \\n\\t\\t\\t\\t\\t       i        110      110      110\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t    000     [010]    [100]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n7 [111]      i=7.          \\n\\t\\t\\t\\t\\t       i        111      111      111\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t   [001]     [010]    [100]\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nvar subsets = function(nums) {\\n\\tlet res=[]                    // the final arr, which we will display\\n\\tlet auxArr = [], i=0             // global vars\\n    \\n    function recur(nums,i,auxArr){\\n        if(i==nums.length) { res.push(auxArr); return } //operation of recursion will be upto i=n-1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t // when it will hit, i==n, it will store the computed arr, in the final arr, and break(return)\\n        \\n\\t\\t// take it\\n        recur(nums, i+1, [...auxArr, nums[i] ] ) //or, we can use \\'aux.concat(nums[i])\\'\\n\\t\\t\\n\\t\\t// dont take\\n        recur(nums, i+1, auxArr)\\n    \\n    }\\n    \\n    recur(nums,i,auxArr) // passing the global variable declared already\\n    return res        // rerturn the final 2d arr\\n    \\n    \\n};\\n\\n\\n\\t                  1 2 3\\n \\t\\t\\t\\t  /           \\\\\\n \\t\\t    \\t1 \\t\\t\\t     []\\t\\n              /     \\\\           /.  \\\\\\n            1 2\\t     1\\t       2.    []\\n           /  \\\\\\t\\t/ \\\\       / \\\\    / \\\\\\n        123.   12. 13. 1.    23. 2. 3. [].\\n\\n```\n```\\nvar subsets = function(nums) {\\n    let res = [[]], appendarr= []\\n    \\n    for(let num of nums){\\n        appendarr = []\\n        for(let entry of res){\\n            appendarr.push([...entry, num])\\n        }\\n        \\n        res.push(...appendarr)\\n    }\\n    \\n    return res\\n    \\n};\\n\\n\\n0 (Empty)             :         [] \\n1 (Adding 1 to it)    :         [] [1] \\n2 (Adding 2 to it)    :         [] [1] [2] [1,2]\\n3 (Adding 3 to it)    :         [] [1] [2] [1,2] [3] [1,3] [2,3] [1,2,3]\\n```\n```\\nvar subsets = function(nums) {\\n  const result = [];\\n  result.push([]);   // handling the first case (i=0). for that, an empty arr should be there\\n  \\n  let size = nums.length\\n  \\n  for(let i = 1; i < (1<<size) ; i++){   // generating for range upto [(2^n)-1]\\n    let subset = [];\\n    let bitmask=0\\n    \\n      while(bitmask<size){\\n          if(i & (1 << bitmask)){           // if it exists (not zero)\\n              subset.push( nums[bitmask] );\\n          }\\n          bitmask++   \\n      }\\n      result.push(subset)\\n  }\\n  return result\\n};\\n```\n```\\nDry Run: \\n\\nlets take nums = [1,2,3]\\nwe will be searching all elem from 0-> 2^n\\n\\nso, checking :\\n\\ni         \\n\\u2B07                                  while(bitmask<size)\\n\\n0 [000]                             [ ] \\n\\n\\n1 [001]      i=1.           \\n\\t\\t\\t\\t\\t\\t\\ti\\t\\t001      001      001\\n\\t\\t\\t  \\t          mask\\t    001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t   ----     ----     ----\\n\\t\\t\\t\\t\\t\\t\\t\\t  [001]      000      000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n2 [010]      i=2.                        \\n\\t\\t\\t\\t\\t       i        010      010      010\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t000     [010]     000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3 [011]      i=3.           \\n\\t\\t\\t\\t\\t       i        011      011      011\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t  [001]     [010]     000\\n\\t\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t\\t\\t  \\n4 [100]      i=4.         \\n\\t\\t\\t\\t\\t       i        100      100      100\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t000      000     [100]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n5 [101]      i=5.           \\n\\t\\t\\t\\t\\t       i        101      101      101\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t   [001]      000     [100]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n6 [110]      i=6.          \\n\\t\\t\\t\\t\\t       i        110      110      110\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t    000     [010]    [100]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n7 [111]      i=7.          \\n\\t\\t\\t\\t\\t       i        111      111      111\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t   [001]     [010]    [100]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 27294,
                "title": "simple-iteration-no-recursion-no-twiddling-explanation",
                "content": "My idea was to start out with an empty subset and either take or don't take the next element in the input array. Here's how it goes down for input `[1,2,3]`:\\n\\nstart with\\n\\n    [] // empty set is always a subset\\n\\nthen either take or not take the next element (`1`), this doubles the result size:\\n\\n    []   // not take 1\\n    [1] //      take 1 + new\\n\\nthen take or not take the next element: `2`\\n\\n    []    // not take 1, not take 2\\n    [2]   // not take 1,     take 2 + new\\n    [1]   //     take 1, not take 2\\n    [1,2] //     take 1,     take 2 + new\\n\\nand finally take or not take `3`.\\n\\n    []      // not take 1, not take 2, not take 3\\n    [3]     // not take 1, not take 2,     take 3 + new\\n    [2]     // not take 1,     take 2, not take 3\\n    [2,3]   // not take 1,     take 2,     take 3 + new\\n    [1]     //     take 1, not take 2, not take 3\\n    [1,3]   //     take 1, not take 2,     take 3 + new\\n    [1,2]   //     take 1,     take 2, not take 3\\n    [1,2,3] //     take 1,     take 2,     take 3 + new\\n\\nAnd we're done, we have all `2^3 = 8` subsets generated.\\n\\nIt is possible to generate these with a simple loop, there's only one trick here, the variable `size`. It's usually a good practice to cache method call results, but now it is cached for a different reason: because it changes in every iteration. If we don't want to end up with an infinite loop, we have to remember how many `results` were available in the previous iteration, which is exactly the `size()` of the `result` at the beginning of the current iteration.\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        Arrays.sort(nums); // make sure subsets are ordered\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(new ArrayList<>()); // start with empty set\\n        for (int i = 0; i < nums.length; ++i) {\\n            for (int j = 0, size = result.size(); j < size; ++j) { // remember\\n                List<Integer> subset = new ArrayList<>(result.get(j)); // copy a new one\\n                subset.add(nums[i]); // expand\\n                result.add(subset); // collect\\n            }\\n        }\\n        return result;\\n    }\\n\\nIt is also necessary to order the input to satisfy the requirement:\\n\\n> * Elements in a subset must be in non-descending order.\\n\\nBecause `i` is increasing it means that whatever we take from nums will also be in increasing order.\\n\\nThe other requirement:\\n\\n> * The solution set must not contain duplicate subsets.\\n\\nis automatically guaranteed by the input specification and the algorithm walking indices straight and once:\\n\\n> Given a set of **distinct** integers, `nums`, return all possible subsets. *[emphasis mine]*",
                "solutionTags": [
                    "Java"
                ],
                "code": "My idea was to start out with an empty subset and either take or don't take the next element in the input array. Here's how it goes down for input `[1,2,3]`:\\n\\nstart with\\n\\n    [] // empty set is always a subset\\n\\nthen either take or not take the next element (`1`), this doubles the result size:\\n\\n    []   // not take 1\\n    [1] //      take 1 + new\\n\\nthen take or not take the next element: `2`\\n\\n    []    // not take 1, not take 2\\n    [2]   // not take 1,     take 2 + new\\n    [1]   //     take 1, not take 2\\n    [1,2] //     take 1,     take 2 + new\\n\\nand finally take or not take `3`.\\n\\n    []      // not take 1, not take 2, not take 3\\n    [3]     // not take 1, not take 2,     take 3 + new\\n    [2]     // not take 1,     take 2, not take 3\\n    [2,3]   // not take 1,     take 2,     take 3 + new\\n    [1]     //     take 1, not take 2, not take 3\\n    [1,3]   //     take 1, not take 2,     take 3 + new\\n    [1,2]   //     take 1,     take 2, not take 3\\n    [1,2,3] //     take 1,     take 2,     take 3 + new\\n\\nAnd we're done, we have all `2^3 = 8` subsets generated.\\n\\nIt is possible to generate these with a simple loop, there's only one trick here, the variable `size`. It's usually a good practice to cache method call results, but now it is cached for a different reason: because it changes in every iteration. If we don't want to end up with an infinite loop, we have to remember how many `results` were available in the previous iteration, which is exactly the `size()` of the `result` at the beginning of the current iteration.\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        Arrays.sort(nums); // make sure subsets are ordered\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(new ArrayList<>()); // start with empty set\\n        for (int i = 0; i < nums.length; ++i) {\\n            for (int j = 0, size = result.size(); j < size; ++j) { // remember\\n                List<Integer> subset = new ArrayList<>(result.get(j)); // copy a new one\\n                subset.add(nums[i]); // expand\\n                result.add(subset); // collect\\n            }\\n        }\\n        return result;\\n    }\\n\\nIt is also necessary to order the input to satisfy the requirement:\\n\\n> * Elements in a subset must be in non-descending order.\\n\\nBecause `i` is increasing it means that whatever we take from nums will also be in increasing order.\\n\\nThe other requirement:\\n\\n> * The solution set must not contain duplicate subsets.\\n\\nis automatically guaranteed by the input specification and the algorithm walking indices straight and once:\\n\\n> Given a set of **distinct** integers, `nums`, return all possible subsets. *[emphasis mine]*",
                "codeTag": "Unknown"
            },
            {
                "id": 729863,
                "title": "c-using-bit-masking-most-simpler-with-explain",
                "content": "Idea is ---\\nAs they said all numbers are ```distinct integers``` and We need to find out  all possible subsets\\nNo of subsets would be ```(2 power, No_of_element[from the array])```\\nAnd how We are going to Find It Out ????\\nNeed To Run A loop From 0 to 2^No_of_element and for each number Find All Set Bit Positions Element from that array\\n\\nlets take An Example For better Understanding\\n\\narray = [1,2,3]\\nNo of subsets = 2^3 = 8\\nfrom 0 to 8 for each value find setbit and put into an array\\n\\n    No     BitRepresentation       Array         Ans_Array \\n    0         [ 0 0 0 ]             []            {}                  ----->as There No Set Bit \\n\\n    1         [ 0 0 1 ]            [ 0 0 3]       {3}  \\n\\n    2         [ 0 1 0 ]            [ 0 2 0]       {2}  \\n\\n    3         [ 0 1 1 ]            [ 0 2 3]       {2,3}  \\n\\n    4         [ 1 0 0 ]            [ 1 0 0]       {1}  \\n\\n    5         [ 1 0 1 ]            [ 1 0 3]       {1,3}  \\n\\n    6         [ 1 1 0 ]            [ 1 2 0]       {1,2}  \\n\\n    7         [ 1 1 1 ]            [ 1 2 3]       {1,2,3}  \\n \\nANSWER - [{},{3},{2},{1},{1,3},{1,2},{1,2,3}]  - --->return It\\n   \\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int>FindSubSet(int no,vector<int>&nums){\\n        vector<int>re;\\n        int i = 0;\\n        while(no){\\n            if(no&1){\\n                re.push_back(nums[i]);\\n            }\\n            i++;\\n            no>>=1;\\n        }\\n        return re;\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>>ans;\\n        int total = 1<<n;\\n        for(int i=0;i<total;i++){\\n            vector<int>temp = FindSubSet(i,nums);\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nI hope It Help You \\nIf You Realy Like This Please UpVote\\nAny Suggesstion Comments below\\nThank You (^-^)",
                "solutionTags": [],
                "code": "```distinct integers```\n```(2 power, No_of_element[from the array])```\n```\\nclass Solution {\\npublic:\\n    vector<int>FindSubSet(int no,vector<int>&nums){\\n        vector<int>re;\\n        int i = 0;\\n        while(no){\\n            if(no&1){\\n                re.push_back(nums[i]);\\n            }\\n            i++;\\n            no>>=1;\\n        }\\n        return re;\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>>ans;\\n        int total = 1<<n;\\n        for(int i=0;i<total;i++){\\n            vector<int>temp = FindSubSet(i,nums);\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140388,
                "title": "clear-and-simple-explanation-with-example-100-faster",
                "content": "**Intuition:** Since we are asked to calculate all the possible subsets, hence we will use backtracking , accepting the cases which satisfy conditions and reject the others.\\n\\n**Concept:** This problem is different than the rest of the usual backtracking ones in the sense that , in this problem, we dont have a separate base case that tells us when to stop with the recursion. We keep looping until we run out of indexes and that marks the end of our recursion. \\n\\nWe basically loop over every element in our input `nums`, and we recursively call the method to generate subsets corresponding to that element in the next line and then we remove that element since we are done with it, and we add it to our `subsets` array. \\n\\nAnd **VOILA!!!** Its done.\\nI know it sounds confusing, hence I am going to give an example to explain myself better:\\n\\n**Let\\'s take an example -> nums = [1,2,3]**\\n * first of all, we created current = [ ]\\nNow, we are going to create a copy of current and add it to our subsets Arraylist.\\nSo far, we have subsets = [[ ]]  \\n\\n* Now, we insert the nums[i] i.e., nums[0] in current. Current become -> [1]\\nNow, we make a recursion call with index = 1 and current = [1].\\n\\n* Now, we  add current in subsets. Subsets = [[ ], [1]] (created a copy of current and added it to subset)\\nAdd nums[i] to current where index = 1. Current = [1,2]\\nRecursion call -> index = 2, current = [1, 2].\\n\\n* Add current to subsets. Subsets = [[ ], [1], [1,2]]\\nAdd nums[i] to current where index = 2.\\nRecursion call -> index = 3, current = [1,2,3]\\n\\n* Add current to subset. Subsets = [[ ], [1],[1,2],[1,2,3]]\\nNow, for loop won\\'t execute because index > nums.length().\\nSo, it will return now. \\n\\n* Now, we come to statement current.remove(current.size() - 1).\\nWe now get, current = [1,2]. i = 2 here. Now, we come to next iteration of for loop, i becomes 3 but 3 < nums.length(). \\nSo, it will again return.\\n\\n* Now, we come to statement current.remove(current.size() - 1) again.\\nWe now get, current = [1], i = 1 here. Now, in next loop iteration, i = 2.\\nWe add nums[i] to current. i = 2. Current = [1,3]\\nRecursion Call -> current = [1,3], index = 3\\n\\n* Insert current to subset. Subset = [[ ], [1], [1,2], [1,2,3], [1,3]]\\nWe now try to run the loop but i = 3 and it is not less than nums.length(). \\nSo, we return.\\n\\n* Now, we come back to statement current.remove(current.size() - 1).\\nAnd in the same fashion, [1] is also removed. After 1 is removed, we get [ ] and we insert 2 in it. then we insert [2] in subsets. Then we insert [2,3]. Then we remove 3 and 2. Then we insert [3]. And we are done.\\n\\n* We finally get subset = [[ ], [1], [1,2], [1,2,3], [1,3], [2], [2,3], [3]] ------> ANSWER. Return it. \\n\\nI hope this helped ,and now to implement the logic above , here is the code:\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>subset;\\n    void helper(int index, vector<int>&current,vector<int>&nums)\\n    {\\n        subset.push_back(current); // push the current subset into the resultant array\\n        for(int i=index;i<nums.size();i++)\\n        {\\n            current.push_back(nums[i]); // add the current element to consider the subsets corresponding to it\\n            helper(i+1,current,nums);  //generate subsets for this array\\n            current.pop_back(); // as this has been used, pop it\\n        }\\n        return;\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int>current;\\n        helper(0,current,nums);\\n        return subset; //return answer\\n    }\\n};\\n```\\n**For similar problems: [Backtracking Collection](https://leetcode.com/discuss/interview-question/1141947/backtracking-study-and-analysis)**\\n\\nIf you like, please **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>subset;\\n    void helper(int index, vector<int>&current,vector<int>&nums)\\n    {\\n        subset.push_back(current); // push the current subset into the resultant array\\n        for(int i=index;i<nums.size();i++)\\n        {\\n            current.push_back(nums[i]); // add the current element to consider the subsets corresponding to it\\n            helper(i+1,current,nums);  //generate subsets for this array\\n            current.pop_back(); // as this has been used, pop it\\n        }\\n        return;\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int>current;\\n        helper(0,current,nums);\\n        return subset; //return answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27332,
                "title": "java-subsets-solution",
                "content": "public class Solution {\\n    \\n    \\n    public List<List<Integer>> subsets(int[] S) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n       \\n        if(S.length == 0){\\n            return result;\\n        }\\n        \\n        Arrays.sort(S);\\n        dfs(S, 0, new ArrayList<Integer>(), result);\\n        return result;\\n    }\\n    \\n    public void dfs(int[] s, int index, List<Integer> path, List<List<Integer>> result){\\n        result.add(new ArrayList<Integer>(path));\\n        \\n        for(int i = index; i < s.length; i++){\\n            path.add(s[i]);\\n            dfs(s, i+1, path, result);\\n            path.remove(path.size()-1);\\n        }\\n    }\\n    \\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    \\n    public List<List<Integer>> subsets(int[] S) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n       \\n        if(S.length == 0){\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 360873,
                "title": "python-backtracking",
                "content": "This is a classic backtracking problem. Every back tracking problem can be solved by using the **\"choose\"-> \"explore\" -> \"unchoose\"** strategy.\\n\"Choosing\" is based on the decision tree specific to the problem. Look at the image attached. ![image](https://assets.leetcode.com/users/geekcoder1989/image_1566089485.png)\\n At every level, the decision is whether to include the first element from the remaining set into the chosen set. Based on the decision, further exploration follows.\\n\\n\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def explore(chosen, remaining, res):\\n            if not remaining:\\n                res.append(chosen[:])\\n                return\\n            d = remaining.pop(0)\\n            #choose\\n            chosen.append(d)\\n            #explore\\n            explore(chosen, remaining, res)\\n            chosen.pop()\\n            explore(chosen, remaining, res)\\n            #unchoose\\n            remaining.insert(0, d)\\n        \\n        res = []\\n        chosen = []\\n        explore(chosen, nums, res)\\n        return res\\n```\\t\\t",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def explore(chosen, remaining, res):\\n            if not remaining:\\n                res.append(chosen[:])\\n                return\\n            d = remaining.pop(0)\\n            #choose\\n            chosen.append(d)\\n            #explore\\n            explore(chosen, remaining, res)\\n            chosen.pop()\\n            explore(chosen, remaining, res)\\n            #unchoose\\n            remaining.insert(0, d)\\n        \\n        res = []\\n        chosen = []\\n        explore(chosen, nums, res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27353,
                "title": "short-and-clear-solutions",
                "content": "Straight-forward iterative solution:\\n\\n    def subsets(self, nums):\\n        subsets = [[]]\\n        for n in nums:\\n            subsets += [s + [n] for s in subsets]\\n        return subsets\\n\\nSame thing but with `reduce` instead of the loop:\\n\\n    def subsets(self, nums):\\n        return reduce(lambda subsets, n: subsets + [s+[n] for s in subsets], nums, [[]])\\n\\nUsing `combinations` from the library:\\n\\n    def subsets(self, nums):\\n        return [s for n in range(len(nums)+1)\\n                for s in itertools.combinations(nums, n)]\\n\\nUsing integers as bit mask to tell which elements to use in a subset:\\n\\n    def subsets(self, nums):\\n        return [[nums[i] for i in range(len(nums)) if mask >> i & 1]\\n                for mask in range(2 ** len(nums))]",
                "solutionTags": [
                    "Python"
                ],
                "code": "Straight-forward iterative solution:\\n\\n    def subsets(self, nums):\\n        subsets = [[]]\\n        for n in nums:\\n            subsets += [s + [n] for s in subsets]\\n        return subsets\\n\\nSame thing but with `reduce` instead of the loop:\\n\\n    def subsets(self, nums):\\n        return reduce(lambda subsets, n: subsets + [s+[n] for s in subsets], nums, [[]])\\n\\nUsing `combinations` from the library:\\n\\n    def subsets(self, nums):\\n        return [s for n in range(len(nums)+1)\\n                for s in itertools.combinations(nums, n)]\\n\\nUsing integers as bit mask to tell which elements to use in a subset:\\n\\n    def subsets(self, nums):\\n        return [[nums[i] for i in range(len(nums)) if mask >> i & 1]\\n                for mask in range(2 ** len(nums))]",
                "codeTag": "Python3"
            },
            {
                "id": 1766584,
                "title": "python3-bit-manipulation-99-55-faster-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nThe idea is to use a bitmask where every bit represents an element in the `nums` list. If a bit is set to one, that means the corresponding element is active and goes to a subset. By subtracting the mask by 1 until it turns to zero, we will be able to iterate all possible variations of unique subsets. Example: `nums=[1, 2, 3]`:\\nmask=111 | nums=[**1, 2, 3**]\\nmask=110 | nums=[**1,2,** 3]\\nmask=101 | nums=[**1,** 2, **3**]\\nmask=100 | nums=[**1,** 2, 3]\\netc.\\n\\nTime: **O(N * 2^N)** - iterations\\nSpace: **O(1)** - if not account for the answer list \\n\\nRuntime: 24 ms, faster than **99.55%** of Python3 online submissions for Subsets.\\nMemory Usage: 14.1 MB, less than **95.43%** of Python3 online submissions for Subsets.\\n\\n```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\tL, ans = len(nums), list([[]])\\n\\n\\tmask = 2**L - 1\\n\\twhile mask:\\n\\t\\tcopy, i, subset = mask, L - 1, list()\\n\\t\\twhile copy:\\n\\t\\t\\tif copy & 1: subset.append(nums[i])\\n\\t\\t\\ti, copy = i - 1, copy >> 1\\n\\n\\t\\tans.append(subset)\\n\\t\\tmask -= 1\\n\\n\\treturn ans\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\tL, ans = len(nums), list([[]])\\n\\n\\tmask = 2**L - 1\\n\\twhile mask:\\n\\t\\tcopy, i, subset = mask, L - 1, list()\\n\\t\\twhile copy:\\n\\t\\t\\tif copy & 1: subset.append(nums[i])\\n\\t\\t\\ti, copy = i - 1, copy >> 1\\n\\n\\t\\tans.append(subset)\\n\\t\\tmask -= 1\\n\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 299665,
                "title": "recursive-javascript-solution",
                "content": "```js\\nfunction subsets(nums) {\\n\\tconst powerset = [];\\n\\tgeneratePowerset([], 0);\\n\\n\\tfunction generatePowerset(path, index) {\\n\\t\\tpowerset.push(path);\\n\\t\\tfor (let i = index; i < nums.length; i++) {\\n\\t\\t\\tgeneratePowerset([...path, nums[i]], i + 1);\\n\\t\\t}\\n\\t}\\n\\n\\treturn powerset;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```js\\nfunction subsets(nums) {\\n\\tconst powerset = [];\\n\\tgeneratePowerset([], 0);\\n\\n\\tfunction generatePowerset(path, index) {\\n\\t\\tpowerset.push(path);\\n\\t\\tfor (let i = index; i < nums.length; i++) {\\n\\t\\t\\tgeneratePowerset([...path, nums[i]], i + 1);\\n\\t\\t}\\n\\t}\\n\\n\\treturn powerset;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 27277,
                "title": "5-line-simple-python-solution-beat-96",
                "content": "```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = [[]]\\n        for n in nums:\\n            for i in range(len(res)):\\n                res.append(res[i] + [n])\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = [[]]\\n        for n in nums:\\n            for i in range(len(res)):\\n                res.append(res[i] + [n])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27485,
                "title": "share-my-12-line-simple-java-code-with-brief-explanations",
                "content": "    /*\\n        dfs. \\u6bcf\\u4e2a\\u4f4d\\u7f6e\\u90fd\\u6709\\u9009\\u4e0e\\u4e0d\\u9009\\u4e24\\u4e2a\\u9009\\u9879, \\u4e5f\\u53ef\\u4ee5\\u770b\\u6210\\u904d\\u5386\\u4e00\\u68f5\\u4e8c\\u53c9\\u6811, \\u5411\\u5de6\\u8d70\\u9009, \\u5411\\u53f3\\u8d70\\u4e0d\\u9009\\n    */\\n    public class Solution {\\n        public List<List<Integer>> subsets(int[] nums) {\\n            List<List<Integer>> ans = new ArrayList<>();\\n            if (nums == null) { return ans; }\\n            Arrays.sort(nums);  // non-descending order\\n            dfs(ans, nums, new ArrayList<Integer>(), 0);\\n            return ans; \\n        }\\n        \\n        private void dfs(List<List<Integer>> ans, int[] nums, List<Integer> list, int index) {\\n            if (index == nums.length) { ans.add(new ArrayList<Integer>(list)); return; }\\n            dfs(ans, nums, list, index+1);  // not pick the number at this index\\n            list.add(nums[index]);\\n            dfs(ans, nums, list, index+1);  // pick the number at this index\\n            list.remove(list.size()-1);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> subsets(int[] nums) {\\n            List<List<Integer>> ans = new ArrayList<>();\\n            if (nums == null) { return ans; }",
                "codeTag": "Java"
            },
            {
                "id": 381670,
                "title": "c-backtracking-solution-with-comments",
                "content": "```\\n/*\\nTime complexity : O(N*(2^N))\\nSpace complexity : O(N*(2^N))\\n\\nI am not very clear, please refer to Back to Back SWE\\n*/\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> cache;\\n        vector<int> temp;\\n        subsets(nums, cache, temp, 0);\\n        return cache;\\n    }\\nprivate:\\n    void subsets(vector<int>& nums, vector<vector<int>>& cache, vector<int> &temp, int start) {\\n        // goal, once we reach the end, add it to the result\\n        if(start == nums.size()) {\\n            cache.push_back(temp);\\n            return;\\n        }\\n        // for every element we have two choices : keep it or drop it\\n        // choice 1, keep it\\n        temp.push_back(nums[start]);\\n        subsets(nums, cache, temp, start + 1);\\n        // choice 2, drop it\\n        temp.pop_back();\\n        subsets(nums, cache, temp, start + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\n/*\\nTime complexity : O(N*(2^N))\\nSpace complexity : O(N*(2^N))\\n\\nI am not very clear, please refer to Back to Back SWE\\n*/\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> cache;\\n        vector<int> temp;\\n        subsets(nums, cache, temp, 0);\\n        return cache;\\n    }\\nprivate:\\n    void subsets(vector<int>& nums, vector<vector<int>>& cache, vector<int> &temp, int start) {\\n        // goal, once we reach the end, add it to the result\\n        if(start == nums.size()) {\\n            cache.push_back(temp);\\n            return;\\n        }\\n        // for every element we have two choices : keep it or drop it\\n        // choice 1, keep it\\n        temp.push_back(nums[start]);\\n        subsets(nums, cache, temp, start + 1);\\n        // choice 2, drop it\\n        temp.pop_back();\\n        subsets(nums, cache, temp, start + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184674,
                "title": "javascript",
                "content": "```\nvar subsets = function(nums) {\n    let result = [];\n    dfs([], 0);\n    \n    function dfs(current, index){\n        result.push(current);\n        for(let i = index; i < nums.length; i++) {\n            dfs(current.concat(nums[i]), i + 1);\n        }\n    }\n    \n    return result;\n};\n```",
                "solutionTags": [],
                "code": "```\nvar subsets = function(nums) {\n    let result = [];\n    dfs([], 0);\n    \n    function dfs(current, index){\n        result.push(current);\n        for(let i = index; i < nums.length; i++) {\n            dfs(current.concat(nums[i]), i + 1);\n        }\n    }\n    \n    return result;\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 729842,
                "title": "python-3-solutions-backtracking-2-oneliners-explained",
                "content": "In this problem we need to return all posible subsets of given set, and there are a big number of them: `2^n`. It usually means, that we need to use some backtracking approach to do it.\\nLet us have function `dfs(self, current, nums)`, with parameters:\\n1. `current` is set of indexes choosen number: we always choose indexes in increasing order. \\n2. `nums` are our original numbers (we can make it global varialbe as well).\\n\\nAlso I start with dummy variable index `-1`, and when we add subset to final answer, we remove this element. Then we recursively run `dfs` with new added number `i`.\\n\\n**Complexity**: both time ans space is `O(2^n*n)`, because we have `2^n` subsets with n/2 elements in average.\\n\\n```\\nclass Solution:\\n    def subsets(self, nums):\\n        self.out = []\\n        self.dfs([-1],nums)\\n        return self.out\\n\\n    def dfs(self, current, nums):\\n        self.out.append([nums[s] for s in current][1:])\\n        for i in range(current[-1] + 1, len(nums)):\\n            self.dfs(current + [i], nums)\\n```\\n\\n**Oneliners**\\nFirst one is to use `combinations` library from python, and we itarate over all possible number of elements. Second one uses binary masks.\\n\\n```\\nreturn chain.from_iterable(combinations(nums, i) for i in range(len(nums)+1))\\n\\nreturn [[nums[j] for j in range(len(nums)) if (i&(1<<j))] for i in range(1<<len(nums))]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums):\\n        self.out = []\\n        self.dfs([-1],nums)\\n        return self.out\\n\\n    def dfs(self, current, nums):\\n        self.out.append([nums[s] for s in current][1:])\\n        for i in range(current[-1] + 1, len(nums)):\\n            self.dfs(current + [i], nums)\\n```\n```\\nreturn chain.from_iterable(combinations(nums, i) for i in range(len(nums)+1))\\n\\nreturn [[nums[j] for j in range(len(nums)) if (i&(1<<j))] for i in range(1<<len(nums))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362545,
                "title": "python3-backtracking",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    level 0: []\\n    level 1: [11]                    [22]       [33]\\n    level 2: [11,22]     [11,33]     [22,33] \\n    level 3: [11,22,33]\\n  \\n    \"\"\"\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.backtracking(res,0,[],nums)\\n        return res\\n    def backtracking(self,res,start,subset,nums):\\n        res.append(list(subset))\\n        for i in range(start,len(nums)):\\n            subset.append(nums[i])\\n            self.backtracking(res,i+1,subset,nums)\\n            subset.pop()\\n```\\n* The length of subset:\\nwe have two choices for a given item in the nums: in the subset or not in the subset. So, if we have 2 choices for each of the \\uD835\\uDC5B elements, the total number of subsets possible is 2**n.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    level 0: []\\n    level 1: [11]                    [22]       [33]\\n    level 2: [11,22]     [11,33]     [22,33] \\n    level 3: [11,22,33]\\n  \\n    \"\"\"\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.backtracking(res,0,[],nums)\\n        return res\\n    def backtracking(self,res,start,subset,nums):\\n        res.append(list(subset))\\n        for i in range(start,len(nums)):\\n            subset.append(nums[i])\\n            self.backtracking(res,i+1,subset,nums)\\n            subset.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766662,
                "title": "easy-to-go-solution",
                "content": ">In this question if you observe you will found out that we have given some `choices` & on that `choices` we have to make `decision`.\\n>>So, what choices we have given is whether **to include \"Yes\" or not \"No\".**\\n\\nLet\\'s say we have **input:** [1, 2, 3] to make it\\'s recursive diagram. We have choices like to include 1 or not & so on...\\n\\n```\\n       1                    2                      3\\n\\t  / \\\\                  / \\\\                    / \\\\\\n\\tYes  No              Yes  No                Yes  No\\n```\\n\\nSo, on these choices whatever decision I will take, it will make my subset!\\n\\n![image](https://assets.leetcode.com/users/images/e031f1ed-c20f-4999-ab43-bc49bb1e235d_1644719174.8762171.png)\\n\\nSo, if you see we are taking choices whether to have or not. [ 0 or 1 ] And by these choices we are making decision\\'s. And because of that. Our Input is getting smaller.\\n\\nNow let\\'s understand, how we will build our **recursion tree**\\n\\nAgain, let\\'s understand with example we have to get subset of [1, 2]\\n\\n```\\n|  [ ]  |   1 -> 0 2 -> 0\\n|  1    |   1 -> 1 2 -> 0\\n|  2    |   1 -> 0 2 -> 1\\n|  12   |   1 -> 1 2 -> 1\\n```\\n\\nSo, instead of representing in `1->0 2->0` way. We want to represent in a good way & that way is called **Recursive Tree**\\n\\nFor Recursive tree there is a method called **\"IP - OP Method\"**\\n\\n![image](https://assets.leetcode.com/users/images/f3beda30-bb5b-4f19-8642-56ce05fff151_1644719440.842423.png)\\n\\nLet\\'s understand this tree with an example as well. **Get subset of [1, 2, 3]**\\n\\n![image](https://assets.leetcode.com/users/images/219e18c6-cc00-45c5-b9c2-e1cc287123d8_1644720694.847087.png)\\n\\nSo, as you see once the **input is becoming empty** we are getting our answer:\\nWe put our base-condition `if input size becomes 0`\\n **return & get\\'s the answer**\\n\\n\\n>**2 steps to solve Recursion Problem**\\n* `Design a recursive tree`\\n* `F8ck the problem a.k.a` **Write the code**\\n\\n*I hope now, you got the idea.* **Let\\'s code it:**\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<Integer> ip = new ArrayList<>(); // ip = input\\n        for(int i = 0; i < nums.length; i++){\\n            ip.add(nums[i]);\\n        }\\n        List<Integer> op = new ArrayList<>(); // op = output\\n        List<List<Integer>> res = new ArrayList<>(); \\n        \\n        solve(ip, op, res);\\n        return res;\\n    }\\n    public void solve(List<Integer> ip, List<Integer> op, List<List<Integer>> res){\\n        if(ip.size() == 0){\\n            res.add(op);\\n            return;\\n        }\\n        \\n        List<Integer> op1 = new ArrayList<>(op); // op1 = output1\\n        List<Integer> op2 = new ArrayList<>(op); // op2 = output2\\n        \\n        op2.add(ip.get(0));\\n        \\n        //NEED TO DECALARE NEW input ARRAYLIST BECUASE JAVA IS \"PASS BY VALUE\"\\n        List<Integer> input = new ArrayList<>(ip);\\n\\n        input.remove(0);\\n        \\n        solve(input, op1, res);\\n        solve(input, op2, res);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n       1                    2                      3\\n\\t  / \\\\                  / \\\\                    / \\\\\\n\\tYes  No              Yes  No                Yes  No\\n```\n```\\n|  [ ]  |   1 -> 0 2 -> 0\\n|  1    |   1 -> 1 2 -> 0\\n|  2    |   1 -> 0 2 -> 1\\n|  12   |   1 -> 1 2 -> 1\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<Integer> ip = new ArrayList<>(); // ip = input\\n        for(int i = 0; i < nums.length; i++){\\n            ip.add(nums[i]);\\n        }\\n        List<Integer> op = new ArrayList<>(); // op = output\\n        List<List<Integer>> res = new ArrayList<>(); \\n        \\n        solve(ip, op, res);\\n        return res;\\n    }\\n    public void solve(List<Integer> ip, List<Integer> op, List<List<Integer>> res){\\n        if(ip.size() == 0){\\n            res.add(op);\\n            return;\\n        }\\n        \\n        List<Integer> op1 = new ArrayList<>(op); // op1 = output1\\n        List<Integer> op2 = new ArrayList<>(op); // op2 = output2\\n        \\n        op2.add(ip.get(0));\\n        \\n        //NEED TO DECALARE NEW input ARRAYLIST BECUASE JAVA IS \"PASS BY VALUE\"\\n        List<Integer> input = new ArrayList<>(ip);\\n\\n        input.remove(0);\\n        \\n        solve(input, op1, res);\\n        solve(input, op2, res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598122,
                "title": "python-subsets-vs-combinations-vs-permutations-visualized",
                "content": "**Idea:**\\n- To generate subsets, each node in the recrsive tree is part of the solution.\\n- The generation of **subsets** and that of **combinations** are simialr. In fact, combinations is a special case of subsets where the answers must be of a specific size k (nCk)\\n- On the other hand, subsets come in varying sizes - from 0 (aka. empty subset)all the way to size n.\\n- **Visually,** the recursive tree that we must generate to arrive at *both* **subsets** and **combinations** of a list is the same. \\n- However, only **leaf nodes that are of size k** make up the solution to the **combination problem,** whereas the solution for the **subsets** problem comprise of **all nodes** in the recursive tree without exception.\\n- See below visuals for a comparison between: \\n    - **Trimming algortihm** (used in generating subsets, combinations)\\n    - **Swapping algorithm** (used in generating permutations)\\n\\n![image](https://assets.leetcode.com/users/images/f45911f6-3d16-4ff9-b745-ea473f48b70e_1641245486.5257618.png)\\n\\n![image](https://assets.leetcode.com/users/images/73e04b91-2fac-40f8-9cc2-d696fb7c81f2_1637989748.5639527.png)\\n\\n\\n------------------------------------------------------------------------------\\n[1] Recursive\\n--------------------------------\\n------------------------------------------------------------------------------\\n```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\t\\'\\'\\'\\n\\tRecursive\\n\\t\\'\\'\\'\\n\\t# - helper\\n\\tdef recurse(start, subset):\\n\\n\\t\\tres.append(subset)\\n\\t\\tfor i in range(start, len(nums)):\\n\\t\\t\\trecurse(i+1, subset+[nums[i]])\\n\\t\\treturn res\\n\\n\\t# - main\\n\\tres = []\\n\\treturn recurse(0, []) # startIndx, subset\\n```\\n------------------------------------------------------------------------------\\n[2] Iterative\\n--------------------------------\\n------------------------------------------------------------------------------\\n```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\t\\'\\'\\'\\n\\titerative\\n\\t\\'\\'\\'\\n\\tstack = [(0, [])] # start, subset\\n\\tres = []\\n\\twhile stack:\\n\\t\\tstart, subset = stack.pop()\\n\\t\\tres.append(subset) # no cond to be checked (unlike combinations, perm)\\n\\n\\t\\tfor i in range(start, len(nums)):\\n\\t\\t\\tstack.append((i+1, subset+[nums[i]]))\\n\\n\\treturn res\\n```\\n- Similar problems:\\n\\t- Combinations: https://leetcode.com/problems/combinations/discuss/1409224/Python-4-Approaches-Explained-%2B-Visualized\\n\\t- Permuations: https://leetcode.com/problems/permutations/discuss/993970/Python-4-Approaches-%3A-Visuals-%2B-Time-Complexity-Analysis",
                "solutionTags": [
                    "Recursion",
                    "Iterator",
                    "Probability and Statistics"
                ],
                "code": "```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\t\\'\\'\\'\\n\\tRecursive\\n\\t\\'\\'\\'\\n\\t# - helper\\n\\tdef recurse(start, subset):\\n\\n\\t\\tres.append(subset)\\n\\t\\tfor i in range(start, len(nums)):\\n\\t\\t\\trecurse(i+1, subset+[nums[i]])\\n\\t\\treturn res\\n\\n\\t# - main\\n\\tres = []\\n\\treturn recurse(0, []) # startIndx, subset\\n```\n```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\t\\'\\'\\'\\n\\titerative\\n\\t\\'\\'\\'\\n\\tstack = [(0, [])] # start, subset\\n\\tres = []\\n\\twhile stack:\\n\\t\\tstart, subset = stack.pop()\\n\\t\\tres.append(subset) # no cond to be checked (unlike combinations, perm)\\n\\n\\t\\tfor i in range(start, len(nums)):\\n\\t\\t\\tstack.append((i+1, subset+[nums[i]]))\\n\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 473975,
                "title": "learning-and-summarizing-3-solutions",
                "content": "\\n**BFS**\\n```\\nlet subsetsbfs = function (nums) {\\n  const res = [[]];\\n  for (let i = 0; i < nums.length; i++) {\\n    const size = res.length;\\n    for (let j = 0; j < size; j++) {\\n      res.push([...res[j], nums[i]]);\\n    }\\n  }\\n  return res;\\n};\\n```\\n\\n\\n**Backtracking**\\n```\\nlet subsets = function (nums) {\\n  const res = [];\\n  const backtracking = (nums, res, idx, path) => {\\n    res.push([...path]);\\n\\n    for (let i = idx; i < nums.length; i++) {\\n      path.push(nums[i]);\\n      backtracking(nums, res, i + 1, path);\\n      path.pop();\\n    }\\n  };\\n\\n  backtracking(nums, res, 0, []);\\n\\n  return res;\\n};\\n```\\n\\n\\n**Lexicographic Subsets**\\n```\\nvar subsets = function(nums) {\\n    let res = []\\n    const powSize = Math.pow(2, nums.length)\\n\\n    for (let i = 0; i < powSize; i++) {\\n        let set = []\\n        for (let j = 0; j < nums.length; j++) {\\n            if ((i & (1 << j)) > 0) {\\n                set.push(nums[j])\\n            }\\n        }\\n        res.push(set)\\n    }\\n    return res\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet subsetsbfs = function (nums) {\\n  const res = [[]];\\n  for (let i = 0; i < nums.length; i++) {\\n    const size = res.length;\\n    for (let j = 0; j < size; j++) {\\n      res.push([...res[j], nums[i]]);\\n    }\\n  }\\n  return res;\\n};\\n```\n```\\nlet subsets = function (nums) {\\n  const res = [];\\n  const backtracking = (nums, res, idx, path) => {\\n    res.push([...path]);\\n\\n    for (let i = idx; i < nums.length; i++) {\\n      path.push(nums[i]);\\n      backtracking(nums, res, i + 1, path);\\n      path.pop();\\n    }\\n  };\\n\\n  backtracking(nums, res, 0, []);\\n\\n  return res;\\n};\\n```\n```\\nvar subsets = function(nums) {\\n    let res = []\\n    const powSize = Math.pow(2, nums.length)\\n\\n    for (let i = 0; i < powSize; i++) {\\n        let set = []\\n        for (let j = 0; j < nums.length; j++) {\\n            if ((i & (1 << j)) > 0) {\\n                set.push(nums[j])\\n            }\\n        }\\n        res.push(set)\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1571250,
                "title": "c-solution-using-recursion-with-full-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- We pass ans array, index, input array(ip), output array(op) to solve function.\\n- In every function call either we have to take the input to the array or skip that.\\n- If we skip we simply call the function and increase the index by 1.\\n- else we include that in op array\\xA0***//op.push_back(ip[i])***\\n- again we call for the next index and after we return we simply pop last element from op\\n- Base condition: When idx is equal to the size of ip we return.\\n- **Time complexity:** O().\\n\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\n    void solve(vector<vector<int>> &ans, int i, vector<int>& ip, vector<int> op){\\n        if(ip.size()==i){\\n            ans.push_back(op);\\n            return;\\n        }\\n        solve(ans, i+1, ip, op);        \\n        op.push_back(ip[i]);\\n        solve(ans, i+1, ip, op);\\n        return;\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& ip) {\\n        vector<vector<int>> ans;\\n        vector<int>op;\\n        solve(ans, 0, ip, op);\\n        return ans;\\n        \\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\n    void solve(vector<vector<int>> &ans, int i, vector<int>& ip, vector<int> op){\\n        if(ip.size()==i){\\n            ans.push_back(op);\\n            return;\\n        }\\n        solve(ans, i+1, ip, op);        \\n        op.push_back(ip[i]);\\n        solve(ans, i+1, ip, op);\\n        return;\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& ip) {\\n        vector<vector<int>> ans;\\n        vector<int>op;\\n        solve(ans, 0, ip, op);\\n        return ans;\\n        \\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549657,
                "title": "java-tc-o-n-2-n-sc-o-1-constant-space-iterative-backtracking-solutions",
                "content": "**Constant Space Iterative Solution**\\n```java\\n/**\\n * Constant Space Iterative Solution\\n *\\n * S(n) = (0 \\xD7 (n C 0) + 1 \\xD7 (n C 1) + 2 \\xD7 (n C 2) + \\u2026 + n \\xD7 (n C n))\\n * Note that (n C k) = (n C n-k). Therefore:\\n * S(n) = 0 \\xD7 (n C n) + 1 \\xD7 (n C n-1) + 2 \\xD7 (n C n-2) + \\u2026 + n \\xD7 (n C 0)\\n * If we add these two together, we get\\n * 2S(n) = n \\xD7 (n C 0) + n \\xD7 (n C 1) + \\u2026 + n \\xD7 (n C n)\\n *       = n \\xD7 (n C 0 + n C 1 + \\u2026 + n C n)\\n * As per binomial theorem, (n C 0 + n C 1 + \\u2026 + n C n) = 2^n, so\\n * 2*S(n) = n * 2^n => S(n) = n * 2^(n-1)\\n *\\n * Time Complexity: O(S(N) + n C 0) = O(N * 2^(N-1) + 1) = O(N * 2^N)\\n *\\n * Space Complexity: O(1) (Excluding the result space)\\n *\\n * N = Length of input nums array\\n */\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null) {\\n            return result;\\n        }\\n\\n        result.add(new ArrayList<>());\\n        for (int n : nums) {\\n            int size = result.size();\\n            for (int i = 0; i < size; i++) {\\n                List<Integer> temp = new ArrayList<>(result.get(i));\\n                temp.add(n);\\n                result.add(temp);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n**Backtracking (Recursion). This solution take O(N) space for recursion depth and temp list.**\\n```java\\n/**\\n * Backtracking (Recursion)\\n *\\n * Time Complexity: O(N * 2 ^ N) Refer to above explanation\\n *\\n * Space Complexity: O(N) (Recursion Depth + TempList)\\n *\\n * N = Length of input nums array\\n */\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null) {\\n            return result;\\n        }\\n\\n        subsetsHelper(nums, 0, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void subsetsHelper(int[] nums, int start, List<Integer> temp, List<List<Integer>> result) {\\n        result.add(new ArrayList<>(temp));\\n\\n        for (int i = start; i < nums.length; i++) {\\n            temp.add(nums[i]);\\n            subsetsHelper(nums, i + 1, temp, result);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Subsets questions on LeetCode:\\n- [90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/1549662/Java-or-TC:-O(N*2N)-or-SC:-O(UniqueNums)-or-Space-Optimized-Iterative-and-Backtracking-solutions)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n/**\\n * Constant Space Iterative Solution\\n *\\n * S(n) = (0 \\xD7 (n C 0) + 1 \\xD7 (n C 1) + 2 \\xD7 (n C 2) + \\u2026 + n \\xD7 (n C n))\\n * Note that (n C k) = (n C n-k). Therefore:\\n * S(n) = 0 \\xD7 (n C n) + 1 \\xD7 (n C n-1) + 2 \\xD7 (n C n-2) + \\u2026 + n \\xD7 (n C 0)\\n * If we add these two together, we get\\n * 2S(n) = n \\xD7 (n C 0) + n \\xD7 (n C 1) + \\u2026 + n \\xD7 (n C n)\\n *       = n \\xD7 (n C 0 + n C 1 + \\u2026 + n C n)\\n * As per binomial theorem, (n C 0 + n C 1 + \\u2026 + n C n) = 2^n, so\\n * 2*S(n) = n * 2^n => S(n) = n * 2^(n-1)\\n *\\n * Time Complexity: O(S(N) + n C 0) = O(N * 2^(N-1) + 1) = O(N * 2^N)\\n *\\n * Space Complexity: O(1) (Excluding the result space)\\n *\\n * N = Length of input nums array\\n */\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null) {\\n            return result;\\n        }\\n\\n        result.add(new ArrayList<>());\\n        for (int n : nums) {\\n            int size = result.size();\\n            for (int i = 0; i < size; i++) {\\n                List<Integer> temp = new ArrayList<>(result.get(i));\\n                temp.add(n);\\n                result.add(temp);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```java\\n/**\\n * Backtracking (Recursion)\\n *\\n * Time Complexity: O(N * 2 ^ N) Refer to above explanation\\n *\\n * Space Complexity: O(N) (Recursion Depth + TempList)\\n *\\n * N = Length of input nums array\\n */\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null) {\\n            return result;\\n        }\\n\\n        subsetsHelper(nums, 0, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void subsetsHelper(int[] nums, int start, List<Integer> temp, List<List<Integer>> result) {\\n        result.add(new ArrayList<>(temp));\\n\\n        for (int i = start; i < nums.length; i++) {\\n            temp.add(nums[i]);\\n            subsetsHelper(nums, i + 1, temp, result);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855802,
                "title": "java-backtracking-2-n-100-fast-solution-time-complexity-explained",
                "content": "```\\nclass Solution {\\n    int nums[];\\n    List<List<Integer>> result;\\n    \\n    public List<List<Integer>> subsets(int[] nums) {\\n        this.result=new ArrayList<List<Integer>>();\\n        this.nums=nums;\\n        \\n        compute(0,new ArrayList<Integer>());\\n        return result;\\n    }\\n    \\n    private void compute(int i,ArrayList<Integer> al){\\n        if(i==nums.length){\\n            result.add(new ArrayList<Integer>(al));\\n            return;\\n        }\\n        compute(i+1,al);\\n        al.add(nums[i]);\\n        compute(i+1,al);\\n        al.remove(new Integer(nums[i]));\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/d2f21464-a034-4873-a490-179e24383fa5_1600613703.2150216.png)\\n\\n\\nFor set of n elements, power set will have, 2^n elements.\\n\\nso let\\'s say.. we have elements [1,2,3]\\nso for every number we have a choice, we include that number, or we exclude it..\\n\\nso above approach follows same concept..\\n\\nLook at the image above, \\n1) intially index is 0, and list is empty.. \\n2) so now, element at index 0 have two functions calls, one where 1 is not included in arrayList\\n   and other one where 1 is included..\\n3) now, for level-1\\'s dunction call, index is 1. so again element at index 2, will have those function calls..\\n4) continue same, till the last element. \\n5) when index reaches value n (i.e, processed all elements) \\n   copy the content of list into other arraylist, and insert it into new list.\\n   \\nNOTE: if you have noticed, all lists will be unique.. reason is, this approach creates, exactly 2^n paths from root to leaf nodes and every leaf node represents one list from power set.\\n\\nTime Complexity: \\n1) let\\'s ccreate recurrence relation first.. T(n) = 2*T(n-1) &  if(n=1) T(0)= 1;\\n2) so now, T(n) = 2*2*T(n-2)\\n3) T(n) = (2^2) * T(n-2)\\n4) if we generalize this expression, using k,\\n    T(n) = (2^k) * T(n-k)\\n5) when k=n,\\n    T(n) = 2^n * T(0) and T(0) = 1;\\ntherfore time complexity of above program is, T(n) = 2^n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int nums[];\\n    List<List<Integer>> result;\\n    \\n    public List<List<Integer>> subsets(int[] nums) {\\n        this.result=new ArrayList<List<Integer>>();\\n        this.nums=nums;\\n        \\n        compute(0,new ArrayList<Integer>());\\n        return result;\\n    }\\n    \\n    private void compute(int i,ArrayList<Integer> al){\\n        if(i==nums.length){\\n            result.add(new ArrayList<Integer>(al));\\n            return;\\n        }\\n        compute(i+1,al);\\n        al.add(nums[i]);\\n        compute(i+1,al);\\n        al.remove(new Integer(nums[i]));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527606,
                "title": "several-python-solution-w-explanation-demo",
                "content": "Here, we share some solution, including bit serial mapping, element adding, concise DFS, as well as built-in iteration tools in Python.\\n\\nTime Complexity: O( n * 2^n )\\nSpace Complexity: O( n * 2^n )\\n\\n---\\n**Algorithm**:\\n\\n**#1: Bit serial mapping**\\n\\nThe bit serial from 0 to 2^n - 1 can be mapped to element selction for subset generation.\\n\\nTake nums = [1,2,3] for example.\\n\\nsize of input = 3.\\nThus, we go through bit serial from 0 to 2^3 -1 = ( 1 << 3 ) - 1 =  7, then getting corresponding subset on the fly.\\n\\n0 = 0b 000 = empty set = [ ]\\n1 = 0b 00**1** = select first element = [ 1 ]\\n2 = 0b 0**1**0 = select second element = [ 2 ]\\n3 = 0b 0**11** = select first and second elements = [ 1, 2 ]\\n4 = 0b **1**00 = select third element = [ 3 ]\\n5 = 0b **1**0**1** = select first and third elements = [ 1, 3 ]\\n6 = 0b **11**0 = select second and third elements = [ 2, 3 ]\\n7 = 0b **111** = select all elements = [ 1, 2 , 3 ]\\n\\n---\\n\\n**Implementation_#1**:\\nBy bit serial mapping\\n\\n```\\nclass Solution:\\n    \\n    def subsets(self, nums):\\n    \\n        size = len(nums)\\n        upper_bound = 1 << size\\n\\t\\t\\n        return [ [ nums[i]  for i in range(size) if bits_sn & (1 << i) != 0 ] for bits_sn in range(upper_bound) ]\\n```\\n\\nor\\n\\n```\\nclass Solution:\\n    \\n    def subsets(self, nums):\\n    \\n        size = len(nums)\\n        upper_bound = 1 << size \\n        \\n        all_subset = [ ]\\n        for bits_sn in range(upper_bound):\\n            \\n            cur_subset = []\\n            \\n            for i in range(size):\\n                \\n                if bits_sn & (1 << i) != 0:\\n                    \\n                    cur_subset.append( nums[i] )\\n            \\n            all_subset.append( cur_subset )\\n        \\n        return all_subset\\n```\\n\\n---\\n\\n**#2: Element adding**\\n\\n**Base case** is **empty set**: [ **[ ]**  ]\\nBuild all subsets from base-case in bottom-up, add one element for each iteration.\\n\\nTake nums = [1,2,3] for example.\\n\\nInitialization of solution = [ **[ ]**  ] # empty set\\n\\n1st iteration, add [ **1** ] to current solution\\nsolution = [ [ ], [ **1** ] ]\\n\\n2nd iteration, add [ **2** ] to current solution\\nsolution = [ [ ], [ 1 ], [ **2** ], [ 1, **2** ] ]\\n\\n3rd iteration, add [ **3** ] to current solution\\nsolution = [ [ ], [ 1 ], [ 2 ], [ 1, 2 ], [ **3** ], [ 1, **3** ], [ 2, **3** ], [ 1, 2, **3** ] ]\\n\\nCompleted.\\n\\nAll subsets = [ [ ], [ 1 ], [ 2 ], [ 1, 2 ], [ 3 ], [ 1, 3 ], [ 2, 3 ], [ 1, 2, 3 ] ]\\n\\n---\\n\\n**Implementation_#2**:\\nBy element adding\\n\\n```\\nclass Solution:\\n    \\n    def subsets(self, nums):\\n        \\n        # Base case:\\n        solution = [ [] ]\\n        \\n        # General case:\\n        # Generate subset by element adding\\n        for element in nums:\\n            \\n            solution += ( [ current + [ element ] for current in solution ] )\\n            \\n        return solution\\n```\\n\\n---\\n\\n**#3: Concise DFS**\\n\\n---\\n\\n**Implementation_#3**:\\nBy concise DFS\\n\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        \\n        solution = []\\n        size = len(nums)\\n        \\n        def dfs(cur, set_len, start_idx):\\n            \\n            if set_len == len(cur):\\n                solution.append( cur[::] )\\n                return\\n            \\n            for j in range(start_idx, size):\\n                \\n                cur.append( nums[j] )\\n                dfs(cur, set_len, j+1)\\n                cur.pop()\\n        #------------------------------------------\\n        \\n        for set_len in range(0, size+1):\\n            dfs(cur=[], set_len=set_len, start_idx=0)\\n        \\n        return solution\\n```\\n\\n---\\n\\n**#4: Built-in iteration tools in Python**\\n\\nLet size = *n* denote the length of input array\\n\\nAll subset \\n= subset of no element, subset of 1 element, subset of 2 element,... subset of n elements\\n= cases of C( *n*, 0) + cases of C( *n*, 1) + cases of C( *n*, 2) + ... + cases of C( *n*, *n* )\\n= 2^n cases in total\\n\\nPython have **built-in tool** to generate **Combination** of given list and *k*, *k* is from 1 to *n*. Its syntax is as following:\\n\\nitertools.combinations( *iterable* , *k* )\\n\\nExample:\\ncombinations(\\'ABCD\\', 2) --> AB AC AD BC BD CD\\n\\n---\\n\\n**Implementation_#4**:\\nBy built-in iteration tools in Python\\n\\n```\\nfrom itertools import combinations\\n\\nclass Solution:\\n    def subsets(self, nums):\\n        \\n        solution, size = [], len(nums)\\n        \\n        for k in range(size+1):\\n            \\n            solution += [ list(comb) for comb in combinations(nums, k) ]\\n        \\n        return solution\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #90 Subset II](https://leetcode.com/problems/subsets-ii/)\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about bitwise shift operator <<, >>](https://docs.python.org/3/reference/expressions.html#shifting-operations)\\n\\n[2] [Python official docs about list comprehension [ ... ]](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions)\\n\\n[3] [Python official docs about itertools.combination( )](https://docs.python.org/3.8/library/itertools.html#itertools.combinations)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def subsets(self, nums):\\n    \\n        size = len(nums)\\n        upper_bound = 1 << size\\n\\t\\t\\n        return [ [ nums[i]  for i in range(size) if bits_sn & (1 << i) != 0 ] for bits_sn in range(upper_bound) ]\\n```\n```\\nclass Solution:\\n    \\n    def subsets(self, nums):\\n    \\n        size = len(nums)\\n        upper_bound = 1 << size \\n        \\n        all_subset = [ ]\\n        for bits_sn in range(upper_bound):\\n            \\n            cur_subset = []\\n            \\n            for i in range(size):\\n                \\n                if bits_sn & (1 << i) != 0:\\n                    \\n                    cur_subset.append( nums[i] )\\n            \\n            all_subset.append( cur_subset )\\n        \\n        return all_subset\\n```\n```\\nclass Solution:\\n    \\n    def subsets(self, nums):\\n        \\n        # Base case:\\n        solution = [ [] ]\\n        \\n        # General case:\\n        # Generate subset by element adding\\n        for element in nums:\\n            \\n            solution += ( [ current + [ element ] for current in solution ] )\\n            \\n        return solution\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        \\n        solution = []\\n        size = len(nums)\\n        \\n        def dfs(cur, set_len, start_idx):\\n            \\n            if set_len == len(cur):\\n                solution.append( cur[::] )\\n                return\\n            \\n            for j in range(start_idx, size):\\n                \\n                cur.append( nums[j] )\\n                dfs(cur, set_len, j+1)\\n                cur.pop()\\n        #------------------------------------------\\n        \\n        for set_len in range(0, size+1):\\n            dfs(cur=[], set_len=set_len, start_idx=0)\\n        \\n        return solution\\n```\n```\\nfrom itertools import combinations\\n\\nclass Solution:\\n    def subsets(self, nums):\\n        \\n        solution, size = [], len(nums)\\n        \\n        for k in range(size+1):\\n            \\n            solution += [ list(comb) for comb in combinations(nums, k) ]\\n        \\n        return solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187733,
                "title": "backtrack-template-make-backtracking-easy",
                "content": "Here is my summary about Backtracking Template:\\n[Never be stuck by Backtracking Problem -- Backtracking problem Template](https://leetcode.com/problems/palindrome-partitioning/discuss/182307/Java:-Backtracking-Template-General-Approach)\\n\\n```java\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        // Backtracking\\n        // Edge case\\n        if(nums == null || nums.length == 0) return new ArrayList<>();\\n        \\n        List<Integer> step = new ArrayList<>();\\n        List<List<Integer>> result = new ArrayList<>();\\n        helper(nums, 0, step, result);\\n        return result;\\n    }\\n    public void helper(int[] nums, int start, List<Integer> step, List<List<Integer>> result) {\\n        result.add(new ArrayList<>(step));\\n        for(int i = start; i < nums.length; i++) {\\n            // choose\\n            step.add(nums[i]);\\n            // explore\\n            helper(nums, i + 1, step, result);\\n            // unchoose\\n            step.remove(step.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        // Backtracking\\n        // Edge case\\n        if(nums == null || nums.length == 0) return new ArrayList<>();\\n        \\n        List<Integer> step = new ArrayList<>();\\n        List<List<Integer>> result = new ArrayList<>();\\n        helper(nums, 0, step, result);\\n        return result;\\n    }\\n    public void helper(int[] nums, int start, List<Integer> step, List<List<Integer>> result) {\\n        result.add(new ArrayList<>(step));\\n        for(int i = start; i < nums.length; i++) {\\n            // choose\\n            step.add(nums[i]);\\n            // explore\\n            helper(nums, i + 1, step, result);\\n            // unchoose\\n            step.remove(step.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768746,
                "title": "python3-o-n-2-n-3-line-solution",
                "content": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        ans=[[]]\\n        for j in nums:\\n            ans+=[i+[j] for i in ans]\\n        return ans\\n            \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        ans=[[]]\\n        for j in nums:\\n            ans+=[i+[j] for i in ans]\\n        return ans\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27550,
                "title": "very-simple-and-fast-java-solution-with-explanation",
                "content": "\\n    public List<List<Integer>> subsets(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> each = new ArrayList<>();\\n        helper(res, each, 0, nums);\\n        return res;\\n    }\\n    public void helper(List<List<Integer>> res, List<Integer> each, int pos, int[] n) {\\n        if (pos <= n.length) {\\n            res.add(each);\\n        }\\n        for (int i = pos; i < n.length; i++) {\\n            each.add(n[i]);\\n            helper(res, new ArrayList<>(each), i + 1, n);\\n            each.remove(each.size() - 1);\\n        }\\n        return;\\n    }\\n\\n\\n----------\\nThe idea is use pos to keep track of the index of the array. Compare to other backracking problem like combinations, the condition that each single List adds to the List<List<Integer>> is when the index of the array is valid. Meanwhile, after adding to the List<List<Integer>> , keeping going for the for loop.\\n\\n\\n----------\\nthe following is the combinations I wrote, which is very similar to this problem.\\n\\n        public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> each = new ArrayList<>();\\n        helper(res, each, 1, n, k);\\n        return res;\\n    }\\n    public void helper(List<List<Integer>> res, List<Integer> each, int pos, int n, int k) {\\n        if (each.size() == k) {\\n            res.add(each);\\n            return;\\n        }\\n        for (int i = pos; i <= n; i++) {\\n            each.add(i);\\n            helper(res, new ArrayList<>(each), i + 1, n, k);\\n            each.remove(each.size() - 1);\\n        }\\n        return;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public List<List<Integer>> subsets(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> each = new ArrayList<>();\\n        helper(res, each, 0, nums);\\n        return res;\\n    }\\n    public void helper(List<List<Integer>> res, List<Integer> each, int pos, int[] n) {\\n        if (pos <= n.length) {\\n            res.add(each);\\n        }\\n        for (int i = pos; i < n.length; i++) {\\n            each.add(n[i]);\\n            helper(res, new ArrayList<>(each), i + 1, n);\\n            each.remove(each.size() - 1);\\n        }\\n        return;\\n    }\\n\\n\\n----------\\nThe idea is use pos to keep track of the index of the array. Compare to other backracking problem like combinations, the condition that each single List adds to the List<List<Integer>> is when the index of the array is valid. Meanwhile, after adding to the List<List<Integer>> , keeping going for the for loop.\\n\\n\\n----------\\nthe following is the combinations I wrote, which is very similar to this problem.\\n\\n        public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> each = new ArrayList<>();\\n        helper(res, each, 1, n, k);\\n        return res;\\n    }\\n    public void helper(List<List<Integer>> res, List<Integer> each, int pos, int n, int k) {\\n        if (each.size() == k) {\\n            res.add(each);\\n            return;\\n        }\\n        for (int i = pos; i <= n; i++) {\\n            each.add(i);\\n            helper(res, new ArrayList<>(each), i + 1, n, k);\\n            each.remove(each.size() - 1);\\n        }\\n        return;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2418147,
                "title": "c-explained-beats-100-optimized-tc-o-2-n",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Time complexity: O(2^n)**\\n**Space complexity: O(n)**\\n\\n**Approach:**\\n* Subsets can be determined by trying different combinations, so we will use recursion here.\\n* Case1: exclude the element then include the element.\\n* Case2: include the element then exclude the element.\\n* Either of the cases can be used to solve this problem.\\n\\n**Case1:**\\n```\\nclass Solution {\\nprivate:\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int>>& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        \\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n\\n**Case2:**\\n```\\nclass Solution {\\nprivate:\\n    void subset_finder(vector<int>& nums, int index, vector<int> one_subset, vector<vector<int>> &ans)\\n    {\\n        // base case\\n        if(index>=nums.size())\\n        {\\n            ans.push_back(one_subset);\\n            return;\\n        }\\n        // take\\n        one_subset.push_back(nums[index]);\\n        subset_finder(nums, index+1, one_subset, ans);\\n        \\n        // not take\\n\\t\\t// backtracking\\n        one_subset.pop_back();\\n        subset_finder(nums, index+1, one_subset, ans);\\n    }\\n    \\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> one_subset;\\n        int index = 0;\\n        subset_finder(nums, index, one_subset, ans);\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int>>& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        \\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    void subset_finder(vector<int>& nums, int index, vector<int> one_subset, vector<vector<int>> &ans)\\n    {\\n        // base case\\n        if(index>=nums.size())\\n        {\\n            ans.push_back(one_subset);\\n            return;\\n        }\\n        // take\\n        one_subset.push_back(nums[index]);\\n        subset_finder(nums, index+1, one_subset, ans);\\n        \\n        // not take\\n\\t\\t// backtracking\\n        one_subset.pop_back();\\n        subset_finder(nums, index+1, one_subset, ans);\\n    }\\n    \\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> one_subset;\\n        int index = 0;\\n        subset_finder(nums, index, one_subset, ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489255,
                "title": "javascript-backtracking",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar subsets = function(nums) {\\n    let result = [[]];\\n    \\n    function backtrack(first, current) {\\n    // we iterate over the indexes i from \\'first\\' to the length\\n    //of the entire sequence \\'nums\\'\\n    for (let i = first; i < nums.length; i++) {\\n        current.push(nums[i]);\\n\\n        // use distructure operator to clone \\'current\\' value and save to \\'result\\'\\n        result.push([...current]);\\n\\n        // generate all other subsets for the current subset.\\n        // increasing the position by one to avoid duplicates in \\'result\\'\\n        backtrack(i + 1, current);\\n\\n        // BACKTRACK.\\n        current.pop();\\n    }\\n}\\n    \\n    backtrack(0, []);\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar subsets = function(nums) {\\n    let result = [[]];\\n    \\n    function backtrack(first, current) {\\n    // we iterate over the indexes i from \\'first\\' to the length\\n    //of the entire sequence \\'nums\\'\\n    for (let i = first; i < nums.length; i++) {\\n        current.push(nums[i]);\\n\\n        // use distructure operator to clone \\'current\\' value and save to \\'result\\'\\n        result.push([...current]);\\n\\n        // generate all other subsets for the current subset.\\n        // increasing the position by one to avoid duplicates in \\'result\\'\\n        backtrack(i + 1, current);\\n\\n        // BACKTRACK.\\n        current.pop();\\n    }\\n}\\n    \\n    backtrack(0, []);\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 827202,
                "title": "best-java-fastest-solution-0ms-100-faster-and-98-3-less-space",
                "content": "\\nits works on concept of taking the item and ignoring the item at each step\\n\\n```\\n public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> ll=new ArrayList<>();\\n        generate(nums,0,new ArrayList<>(),ll);\\n        return ll;\\n    }\\n    public void generate(int[] nums,int i,List<Integer> ls,List<List<Integer>> ll){\\n        if(i==nums.length){\\n            ll.add(new ArrayList(ls));\\n            return;\\n        }\\n        generate(nums,i+1,ls,ll);\\n        ls.add(nums[i]);\\n        generate(nums,i+1,ls,ll);\\n        ls.remove(ls.size()-1);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> ll=new ArrayList<>();\\n        generate(nums,0,new ArrayList<>(),ll);\\n        return ll;\\n    }\\n    public void generate(int[] nums,int i,List<Integer> ls,List<List<Integer>> ll){\\n        if(i==nums.length){\\n            ll.add(new ArrayList(ls));\\n            return;\\n        }\\n        generate(nums,i+1,ls,ll);\\n        ls.add(nums[i]);\\n        generate(nums,i+1,ls,ll);\\n        ls.remove(ls.size()-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 159942,
                "title": "python3-backtracking-no-loops-very-easy-to-understand",
                "content": "I\\'m a beginner, so I learned about backtracking from a Stanford lecture on youtube. Most python solutions on here used loops, which initially was hard for me to understand. \\n\\nBasically, the idea here is that you\\'re \"choosing\" an element, running the helper *including* the element (which gets all possible sublists with the \"chosen\" one), then running the helper again *not including* the chosen one.\\n\\n*sidenote*: In the helper, I appended a copy of the aux list. If you pass in the reference, your result will have all empty sublists.\\n```\\nclass Solution:\\n    def subsets(self, nums):\\n        res = []\\n        self.helper(nums, 0, res, [])\\n        return res\\n    \\n    def helper(self, nums, idx, res, aux):\\n        if idx == len(nums):\\n            res.append(aux.copy())\\n            return\\n        aux.append(nums[idx])\\n        self.helper(nums, idx + 1, res, aux)\\n        aux.pop()\\n        self.helper(nums, idx + 1, res, aux)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums):\\n        res = []\\n        self.helper(nums, 0, res, [])\\n        return res\\n    \\n    def helper(self, nums, idx, res, aux):\\n        if idx == len(nums):\\n            res.append(aux.copy())\\n            return\\n        aux.append(nums[idx])\\n        self.helper(nums, idx + 1, res, aux)\\n        aux.pop()\\n        self.helper(nums, idx + 1, res, aux)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27604,
                "title": "not-sure-if-this-is-the-best-solution-using-java",
                "content": "    public List<List<Integer>> subsets(int[] S) {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        res.add(new ArrayList<Integer>());\\n        Arrays.sort(S);\\n        for(int i = S.length - 1; i >= 0; i--){\\n            int size = res.size() - 1;\\n            for(int j = size; j >= 0; j--){\\n                List<Integer> newList1 = new ArrayList<>();\\n                newList1.add(S[i]);\\n                newList1.addAll(res.get(j));\\n                res.add(newList1);\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    public List<List<Integer>> subsets(int[] S) {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        res.add(new ArrayList<Integer>());\\n        Arrays.sort(S);\\n        for(int i = S.length - 1; i >= 0; i--){\\n            int size = res.size() - 1;\\n            for(int j = size; j >= 0; j--){\\n                List<Integer> newList1 = new ArrayList<>();\\n                newList1.add(S[i]);\\n                newList1.addAll(res.get(j));\\n                res.add(newList1);\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1333022,
                "title": "c-simple-and-short-solution-no-recursion-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res = {{}};\\n        vector<int> curr;\\n        int size;\\n        \\n        for (auto num : nums) {\\n            size = res.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                curr = res[i];\\n                curr.push_back(num);\\n                res.push_back(curr);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res = {{}};\\n        vector<int> curr;\\n        int size;\\n        \\n        for (auto num : nums) {\\n            size = res.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                curr = res[i];\\n                curr.push_back(num);\\n                res.push_back(curr);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 250619,
                "title": "javascript-solution",
                "content": "```\\nvar subsets = function(nums) {\\n    let res = [[]]\\n    for (let i = 0; i < nums.length; ++i) {\\n  \\t\\tlet length = res.length;\\n\\t\\tfor (let j = 0; j < length; ++j) {\\n\\t\\t\\tres.push([...res[j],nums[i]])\\n        }  \\n   }\\n   return res\\n };\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar subsets = function(nums) {\\n    let res = [[]]\\n    for (let i = 0; i < nums.length; ++i) {\\n  \\t\\tlet length = res.length;\\n\\t\\tfor (let j = 0; j < length; ++j) {\\n\\t\\t\\tres.push([...res[j],nums[i]])\\n        }  \\n   }\\n   return res\\n };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 27522,
                "title": "haven-t-see-dp-solution-here-it-is",
                "content": "\\nFor this question, DP or recursive or backtrack what ever, I think it's almost same thing,but let's do it in a pure DP way:\\n        \\n1 Start from only 1 dig in the list, then result is obvious, [[],[nums[0]]]\\n        \\n2 Than for each new dig, the result is the previous list + previous list append the new dig,\\n          it's easy to understand, since once the new dig come in, there is 2 options, with it or with out it.\\n          without it, is the previous result, with it, it  to add this dig in each array of the previuos result\\n    \\n\\n    def subnets(nums):\\n        nums.sort()\\n        dp={}\\n        dp[0]=[[],[nums[0]] ] \\n        \\n        for i in range(1,len(nums)):\\n            dp[i]=dp[i-1]+[x+[nums[i]] for x in dp[i-1]]\\n        return dp[len(nums)-1]",
                "solutionTags": [],
                "code": "\\nFor this question, DP or recursive or backtrack what ever, I think it's almost same thing,but let's do it in a pure DP way:\\n        \\n1 Start from only 1 dig in the list, then result is obvious, [[],[nums[0]]]\\n        \\n2 Than for each new dig, the result is the previous list + previous list append the new dig,\\n          it's easy to understand, since once the new dig come in, there is 2 options, with it or with out it.\\n          without it, is the previous result, with it, it  to add this dig in each array of the previuos result\\n    \\n\\n    def subnets(nums):\\n        nums.sort()\\n        dp={}\\n        dp[0]=[[],[nums[0]] ] \\n        \\n        for i in range(1,len(nums)):\\n            dp[i]=dp[i-1]+[x+[nums[i]] for x in dp[i-1]]\\n        return dp[len(nums)-1]",
                "codeTag": "Python3"
            },
            {
                "id": 27543,
                "title": "simple-java-solution-using-bit-operations",
                "content": "    public class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        int n = nums.length;\\n        List<List<Integer>> subsets = new ArrayList<>();\\n        for (int i = 0; i < Math.pow(2, n); i++)\\n        {\\n            List<Integer> subset = new ArrayList<>();\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (((1 << j) & i) != 0)\\n                    subset.add(nums[j]);\\n            }\\n            Collections.sort(subset);\\n            subsets.add(subset);\\n        }\\n        return subsets;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        int n = nums.length;\\n        List<List<Integer>> subsets = new ArrayList<>();\\n        for (int i = 0; i < Math.pow(2, n); i++)\\n        {\\n            List<Integer> subset = new ArrayList<>();\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (((1 << j) & i) != 0)\\n                    subset.add(nums[j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1768235,
                "title": "python-recursion-dfs-backtractking-easy-to-understand",
                "content": "**Approach:**\\n1.  If index reaches to the end that means we have covered all the values in the set.\\n2.  We simply leave the value and move to the next position once.\\n3.  We add the value to subSet and then move to next position.\\nFinally, we get powerset with all the unique subsets.\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        n, result = len(nums), []\\n        def powerSet(nums, i, subSet): \\n            if i==n:\\n                result.append(subSet) \\n                return \\n            powerSet(nums, i+1, subSet) \\n            powerSet(nums, i+1, subSet + [nums[i]]) \\n        powerSet(nums, 0, [])\\n        return result \\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        n, result = len(nums), []\\n        def powerSet(nums, i, subSet): \\n            if i==n:\\n                result.append(subSet) \\n                return \\n            powerSet(nums, i+1, subSet) \\n            powerSet(nums, i+1, subSet + [nums[i]]) \\n        powerSet(nums, 0, [])\\n        return result \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767500,
                "title": "c-backtracking-recursion-two-approaches",
                "content": "***Brief note about Question-***\\n* We have to return *all possible subsets (the power set).*\\n```\\nLets take an example which is not given in the question-\\nsuppose array is given arr[]: [7,4,5]\\n\\nso, the answer should be \\n[[],[7],[4],[4,7],[5],[5,7],[4,5],[4,5,7]]\\n```\\n________\\n***Solution - I (Backtracking, Accepted)-***\\n```\\nclass Solution {\\npublic:\\n    // it is use to store answer\\n    vector<vector<int>> ans;\\n    \\n    // solve function for generating answer\\n    void solve(int i, vector<int>&arr, vector<int>&temp)\\n    {\\n        if(i == arr.size()) // if index reaches the size of the array \\n        {\\n            //if we find out a possibility, push it into the answer array\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        // taking ith element\\n        temp.push_back(arr[i]);\\n        \\n        // call for the next index\\n        solve(i + 1, arr, temp);\\n        \\n        // not taking ith ele,so first pop that already pushed ele, and then call for next index and generating the next possibility\\n        temp.pop_back();\\n        \\n        // calling for next index\\n        solve(i + 1, arr, temp);\\n        \\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        ans.clear(); // clear global array\\n        \\n        vector<int> temp; // temporary array for generating answer\\n        solve(0, arr, temp); // generating all possibility\\n        \\n        return ans;\\n    }\\n};\\n```\\n__________\\n***Solution - II (Accepted)-***\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans; // to store answer\\n    \\n    void solve(vector<int> &arr, int i, vector<int> temp)\\n    {\\n        if(i == arr.size()) // if we find out one possibility\\n        {\\n            //push into the final answer that possibility\\n            ans.push_back(temp); \\n            return;\\n        }\\n        \\n        solve(arr, i + 1, temp); // finding possibility for next index\\n        \\n        temp.push_back(arr[i]); // push into the array\\n        \\n        solve(arr, i + 1, temp); //again finding out the next possibility\\n        \\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n         vector<int> temp; // vector to store temporary answer\\n        \\n        solve(arr, 0, temp); // function that will generate our final answer\\n        \\n        return ans; // return the final answer\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nLets take an example which is not given in the question-\\nsuppose array is given arr[]: [7,4,5]\\n\\nso, the answer should be \\n[[],[7],[4],[4,7],[5],[5,7],[4,5],[4,5,7]]\\n```\n```\\nclass Solution {\\npublic:\\n    // it is use to store answer\\n    vector<vector<int>> ans;\\n    \\n    // solve function for generating answer\\n    void solve(int i, vector<int>&arr, vector<int>&temp)\\n    {\\n        if(i == arr.size()) // if index reaches the size of the array \\n        {\\n            //if we find out a possibility, push it into the answer array\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        // taking ith element\\n        temp.push_back(arr[i]);\\n        \\n        // call for the next index\\n        solve(i + 1, arr, temp);\\n        \\n        // not taking ith ele,so first pop that already pushed ele, and then call for next index and generating the next possibility\\n        temp.pop_back();\\n        \\n        // calling for next index\\n        solve(i + 1, arr, temp);\\n        \\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        ans.clear(); // clear global array\\n        \\n        vector<int> temp; // temporary array for generating answer\\n        solve(0, arr, temp); // generating all possibility\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans; // to store answer\\n    \\n    void solve(vector<int> &arr, int i, vector<int> temp)\\n    {\\n        if(i == arr.size()) // if we find out one possibility\\n        {\\n            //push into the final answer that possibility\\n            ans.push_back(temp); \\n            return;\\n        }\\n        \\n        solve(arr, i + 1, temp); // finding possibility for next index\\n        \\n        temp.push_back(arr[i]); // push into the array\\n        \\n        solve(arr, i + 1, temp); //again finding out the next possibility\\n        \\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n         vector<int> temp; // vector to store temporary answer\\n        \\n        solve(arr, 0, temp); // function that will generate our final answer\\n        \\n        return ans; // return the final answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651200,
                "title": "c-iterative-generate-next-subset-based-on-previous-subsets",
                "content": "Start with empty subset, and for each of existing subsets, create the copy and add next num to it.\\n\\n```csharp\\npublic IList<IList<int>> Subsets(int[] nums) \\n{        \\n\\tIList<IList<int>> result = new List<IList<int>>();\\n\\tresult.Add(new List<int>());\\n\\n\\tforeach(var num in nums)\\n\\t{\\n\\t\\tint currentCount = result.Count;\\n\\t\\tfor(int i = 0; i < currentCount; i++)\\n\\t\\t{\\n\\t\\t\\tList<int> subset = result[i].ToList();\\n\\t\\t\\tsubset.Add(num);\\n\\t\\t\\tresult.Add(subset);                \\n\\t\\t}            \\n\\t}\\n\\n\\treturn result;\\n}\\n```\\n\\nUsing bit mask\\n```csharp\\npublic IList<IList<int>> Subsets(int[] nums) \\n{\\n\\tIList<IList<int>> result = new List<IList<int>>();\\n\\tint size = (int) Math.Pow(2, nums.Length);\\n\\n\\tfor(int i = 0; i < size; i++)\\n\\t{\\n\\t\\tList<int> subset = new List<int>();\\n\\t\\tfor(int j = 0; j < nums.Length; j++)\\n\\t\\t{\\n\\t\\t\\tif((i & (1 << j)) != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsubset.Add(nums[j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult.Add(subset);\\n\\t}\\n\\n\\treturn result;\\n}\\n```\\n\\nAlso, recursive solution:\\n```csharp\\npublic IList<IList<int>> Subsets(int[] nums) \\n{       \\n\\tIList<IList<int>> result = new List<IList<int>>();\\n\\tList<int> currentList = new List<int>();\\n\\thelper(nums, result, currentList, 0);\\n\\treturn result;\\n}\\n\\nprivate void helper(int[] nums, IList<IList<int>> result, List<int> currentList, int start)\\n{\\n\\tresult.Add(currentList.ToList());\\n\\tfor(int i = start; i < nums.Length; i++)\\n\\t{\\n\\t\\tcurrentList.Add(nums[i]); \\n\\t\\thelper(nums, result, currentList, i + 1);\\n\\t\\tcurrentList.RemoveAt(currentList.Count - 1);\\n\\t}\\n} \\n```\\n",
                "solutionTags": [
                    "Recursion",
                    "Iterator"
                ],
                "code": "```csharp\\npublic IList<IList<int>> Subsets(int[] nums) \\n{        \\n\\tIList<IList<int>> result = new List<IList<int>>();\\n\\tresult.Add(new List<int>());\\n\\n\\tforeach(var num in nums)\\n\\t{\\n\\t\\tint currentCount = result.Count;\\n\\t\\tfor(int i = 0; i < currentCount; i++)\\n\\t\\t{\\n\\t\\t\\tList<int> subset = result[i].ToList();\\n\\t\\t\\tsubset.Add(num);\\n\\t\\t\\tresult.Add(subset);                \\n\\t\\t}            \\n\\t}\\n\\n\\treturn result;\\n}\\n```\n```csharp\\npublic IList<IList<int>> Subsets(int[] nums) \\n{\\n\\tIList<IList<int>> result = new List<IList<int>>();\\n\\tint size = (int) Math.Pow(2, nums.Length);\\n\\n\\tfor(int i = 0; i < size; i++)\\n\\t{\\n\\t\\tList<int> subset = new List<int>();\\n\\t\\tfor(int j = 0; j < nums.Length; j++)\\n\\t\\t{\\n\\t\\t\\tif((i & (1 << j)) != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsubset.Add(nums[j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult.Add(subset);\\n\\t}\\n\\n\\treturn result;\\n}\\n```\n```csharp\\npublic IList<IList<int>> Subsets(int[] nums) \\n{       \\n\\tIList<IList<int>> result = new List<IList<int>>();\\n\\tList<int> currentList = new List<int>();\\n\\thelper(nums, result, currentList, 0);\\n\\treturn result;\\n}\\n\\nprivate void helper(int[] nums, IList<IList<int>> result, List<int> currentList, int start)\\n{\\n\\tresult.Add(currentList.ToList());\\n\\tfor(int i = start; i < nums.Length; i++)\\n\\t{\\n\\t\\tcurrentList.Add(nums[i]); \\n\\t\\thelper(nums, result, currentList, i + 1);\\n\\t\\tcurrentList.RemoveAt(currentList.Count - 1);\\n\\t}\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 27466,
                "title": "java-concise-recursive-solution",
                "content": "        \\n    public List<List<Integer>> subsets(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> ret = new ArrayList<>();\\n        dfs(nums, 0, new ArrayList<>(), ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(int[] nums, int idx, List<Integer> path, List<List<Integer>> ret) {\\n        ret.add(path);\\n        for (int i = idx; i < nums.length; i++) {\\n            List<Integer> p = new ArrayList<>(path);\\n            p.add(nums[i]);\\n            dfs(nums, i+1, p, ret);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "        \\n    public List<List<Integer>> subsets(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> ret = new ArrayList<>();\\n        dfs(nums, 0, new ArrayList<>(), ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(int[] nums, int idx, List<Integer> path, List<List<Integer>> ret) {\\n        ret.add(path);\\n        for (int i = idx; i < nums.length; i++) {\\n            List<Integer> p = new ArrayList<>(path);\\n            p.add(nums[i]);\\n            dfs(nums, i+1, p, ret);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2216391,
                "title": "python-most-concise-recursive-and-iterative-backtracking-with-explanations",
                "content": "I think that an iterative solution is more intuitive for beginners because you can easily debug it step by step and understand what is going on. \\n\\n```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n        # create list for storing subsets\\n        ans = []\\n        \\n\\t\\t# initialize stack with empty subset and next position equal to 0\\n        stack = [(0,[])]\\n        \\n        while stack:\\n            \\n\\t\\t\\t# retrieve last subset in a stack and its\\' corresponding next position\\n            next_pos, subset = stack.pop()\\n\\t\\t\\t\\n\\t\\t\\t# save current subset\\n            ans.append(subset)\\n            \\n\\t\\t\\t# append each available element starting from next position\\n\\t\\t\\t# to the current subset and append it to the stack increasing next \\n\\t\\t\\t# position by one\\n            for i in range(next_pos,len(nums)):\\n                stack.append((i+1,subset+[nums[i]]))\\n        \\n        return ans\\n```\\nRecursive solution is absolutely the same, but instead of using stack explicitly it uses the call stack.\\n\\n```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n        \\n        ans = []\\n        \\n        def dfs(next_pos,subset):\\n            \\n            ans.append(subset)\\n            \\n            for i in range(next_pos,len(nums)):\\n                \\n                dfs(i+1,subset+[nums[i]])\\n        \\n        dfs(0,[])\\n        \\n        return ans\\n```\\nAnd also, to understand all these backtracking problems you should draw it: draw a corresponding tree of choices and you will understand it faster.",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Stack",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n        # create list for storing subsets\\n        ans = []\\n        \\n\\t\\t# initialize stack with empty subset and next position equal to 0\\n        stack = [(0,[])]\\n        \\n        while stack:\\n            \\n\\t\\t\\t# retrieve last subset in a stack and its\\' corresponding next position\\n            next_pos, subset = stack.pop()\\n\\t\\t\\t\\n\\t\\t\\t# save current subset\\n            ans.append(subset)\\n            \\n\\t\\t\\t# append each available element starting from next position\\n\\t\\t\\t# to the current subset and append it to the stack increasing next \\n\\t\\t\\t# position by one\\n            for i in range(next_pos,len(nums)):\\n                stack.append((i+1,subset+[nums[i]]))\\n        \\n        return ans\\n```\n```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n        \\n        ans = []\\n        \\n        def dfs(next_pos,subset):\\n            \\n            ans.append(subset)\\n            \\n            for i in range(next_pos,len(nums)):\\n                \\n                dfs(i+1,subset+[nums[i]])\\n        \\n        dfs(0,[])\\n        \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1918862,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func subsets(_ nums: [Int]) -> [[Int]] {\\n        var res: [[Int]] = []\\n\\n\\n        func backtrack(_ path: [Int], _ max: Int, _ target: Int) {\\n            if target == 0 {\\n                res.append([])\\n                return\\n            }\\n            \\n            if path.count == target {\\n                res.append(path.map({ nums[$0] }))\\n                return\\n            }\\n            \\n            var path = path\\n            \\n            for index in max+1..<nums.count {\\n                path.append(index)\\n                backtrack(path, index, target)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n        \\n        for i in 0...nums.count {\\n            backtrack([], -1, i)\\n        }\\n        \\n        return res\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func subsets(_ nums: [Int]) -> [[Int]] {\\n        var res: [[Int]] = []\\n\\n\\n        func backtrack(_ path: [Int], _ max: Int, _ target: Int) {\\n            if target == 0 {\\n                res.append([])\\n                return\\n            }\\n            \\n            if path.count == target {\\n                res.append(path.map({ nums[$0] }))\\n                return\\n            }\\n            \\n            var path = path\\n            \\n            for index in max+1..<nums.count {\\n                path.append(index)\\n                backtrack(path, index, target)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n        \\n        for i in 0...nums.count {\\n            backtrack([], -1, i)\\n        }\\n        \\n        return res\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957648,
                "title": "python-4-lines-iterative-recursive-mapping-bits",
                "content": "Iterative\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        subsets = [[]]\\n        for n in nums:\\n            subsets += [s + [n] for s in subsets]        \\n        return subsets\\n```\\nRecursive\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        if not nums:\\n            return [[]]\\n        without = self.subsets(nums[1:])\\n        return without + [s + [nums[0]] for s in without]\\n```\\nMapping bits\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        subsets = []\\n        for n in range(2**len(nums)):            \\n            subsets.append([nums[i] for i, c in enumerate(bin(n)[:1:-1]) if c == \\'1\\'])\\n        return subsets\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        subsets = [[]]\\n        for n in nums:\\n            subsets += [s + [n] for s in subsets]        \\n        return subsets\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        if not nums:\\n            return [[]]\\n        without = self.subsets(nums[1:])\\n        return without + [s + [nums[0]] for s in without]\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        subsets = []\\n        for n in range(2**len(nums)):            \\n            subsets.append([nums[i] for i, c in enumerate(bin(n)[:1:-1]) if c == \\'1\\'])\\n        return subsets\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27337,
                "title": "simple-fast-and-short-swift-solution-beat-97-3",
                "content": "Add one integer every time. Not only add to ans array, but add a integer to ans array 's element. For example,\\ninput = [1,2,3] \\nAdd a number 1:\\nans = [ [1] ]\\nand add a number 2:\\nans = [ [1], [1,2], [2] ]\\nand add a number 3:\\nans = [ [1], [1,2], [2], [1,3], [1,2,3], [2,3], [3] ]    \\n\\n```\\n    func subsets(_ nums: [Int]) -> [[Int]] {\\n        var ans:[[Int]] = []\\n        for i in 0..<nums.count{\\n            for j in 0..<ans.count{\\n                var temp = ans[j]\\n                temp.append(nums[i])\\n                ans.append(temp)\\n            }\\n            ans.append([nums[i]])\\n        }\\n        ans.append([])\\n        return ans\\n    }",
                "solutionTags": [
                    "Swift"
                ],
                "code": "Add one integer every time. Not only add to ans array, but add a integer to ans array 's element. For example,\\ninput = [1,2,3] \\nAdd a number 1:\\nans = [ [1] ]\\nand add a number 2:\\nans = [ [1], [1,2], [2] ]\\nand add a number 3:\\nans = [ [1], [1,2], [2], [1,3], [1,2,3], [2,3], [3] ]    \\n\\n```\\n    func subsets(_ nums: [Int]) -> [[Int]] {\\n        var ans:[[Int]] = []\\n        for i in 0..<nums.count{\\n            for j in 0..<ans.count{\\n                var temp = ans[j]\\n                temp.append(nums[i])\\n                ans.append(temp)\\n            }\\n            ans.append([nums[i]])\\n        }\\n        ans.append([])\\n        return ans\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 27536,
                "title": "4ms-c-solution-using-recursion",
                "content": "    class Solution {\\n    public:\\n    \\tvoid f(vector<int>& temp,vector<vector<int>>&result,int i,vector<int>& nums){\\n    \\t\\tif(i==nums.size()){\\n    \\t\\t\\tresult.push_back(temp);\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\ttemp.push_back(nums[i]);\\n    \\t\\tf(temp,result,i+1,nums);\\n    \\t\\ttemp.pop_back();\\n    \\t\\tf(temp,result,i+1,nums);\\n    \\t\\treturn;\\n    \\t}\\n        vector<vector<int>> subsets(vector<int>& nums) {\\n            sort(nums.begin(),nums.end());\\n            vector<int> temp;\\n    \\t\\tvector<vector<int>>result;\\n    \\t\\tf(temp,result,0,nums);\\n    \\t\\treturn result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tvoid f(vector<int>& temp,vector<vector<int>>&result,int i,vector<int>& nums){\\n    \\t\\tif(i==nums.size()){\\n    \\t\\t\\tresult.push_back(temp);\\n    \\t\\t\\treturn;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 27546,
                "title": "share-my-recursive-solution",
                "content": "I am a big recursive person. And I would like to think everything in a recursive way. \\n\\nFor the case of this problem, using a loop seems definitely to be a more elegant solution. But I would still like to share my recursive solution with you guys.\\n\\nI make recursive call trying to go over the vector from left to right. For each number in vector, it has to options: show in the subset, or not show in the subset. There for each recursive call will generate two more recursive calls. And in the base case, we add the vector to result set. \\n\\nHope you liked my solution.\\n\\n    class Solution {\\n    public:\\n        void subsets_helper(vector<int> tmpVec, vector<vector<int>>& result, vector<int>& S, int level){\\n            if(level==0) result.push_back(tmpVec);\\n            else{\\n                vector<int> newVec0 = tmpVec; newVec0.push_back(S[S.size()-level]);\\n                vector<int> newVec1 = tmpVec;\\n                subsets_helper(newVec0, result, S, level-1);\\n                subsets_helper(newVec1, result, S, level-1);\\n            }\\n        }\\n    \\n        vector<vector<int> > subsets(vector<int> &S) {\\n            sort(S.begin(), S.end());\\n            vector<vector<int>> result;\\n            vector<int> tmpVec;\\n            subsets_helper(tmpVec, result, S, S.size());\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void subsets_helper(vector<int> tmpVec, vector<vector<int>>& result, vector<int>& S, int level){\\n            if(level==0) result.push_back(tmpVec);\\n            else{\\n                vector<int> newVec0 = tmpVec; newVec0.push_back(S[S.size()-level]);\\n                vector<int> newVec1 = tmpVec;\\n                subsets_helper(newVec0, result, S, level-1);\\n                subsets_helper(newVec1, result, S, level-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3088930,
                "title": "simple-c-using-bitmask-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(2^n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>>ans;\\n        for(int i=0;i<(1<<n);i++){\\n            vector<int>temp;\\n           for(int j=0;j<n;j++){\\n              if(i&(1<<j))temp.push_back(arr[j]);\\n           }\\n           ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>>ans;\\n        for(int i=0;i<(1<<n);i++){\\n            vector<int>temp;\\n           for(int j=0;j<n;j++){\\n              if(i&(1<<j))temp.push_back(arr[j]);\\n           }\\n           ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739067,
                "title": "python-java-js-c-by-dfs-backtracking-w-demo",
                "content": "[\\u4E2D\\u6587\\u8A73\\u89E3 \\u89E3\\u8AAA\\u5F71\\u7247\\nTutorial video in Chinese](https://www.youtube.com/watch?v=ITwWVCfLgug&t=0s)\\n\\n**Hint**\\n\\nWhen it comes to **subset**, **combination**, **permutation**, **tree path sum**, think of **DFS+backtracking**.\\n\\n\\nTime Complexity: O( n * 2^n )\\nSpace Complexity: O( n * 2^n )\\n\\n\\n---\\n\\nReview of DFS + backtracking template\\n\\n```\\n\\ndef backtrack( parameter ):\\n\\n\\t# Base case handle, aka stop condition\\n\\tif stop condition:\\n\\t\\t# save valid result if needed\\n\\t\\treturn\\n\\t\\t\\n\\t\\n\\t# General cases handle:\\n\\tfor each possible next move/next selection:\\n\\t\\t\\n\\t\\tmake a next move/ select a element\\n\\t\\n\\t\\tbacktrack( updated parameter )\\n\\t\\t\\n\\t\\troll back / undo selection\\n\\t\\t\\n\\treturn\\n```\\n\\n---\\n\\n**Demo of subset generation with input = [1, 2, 3]**\\n\\n<img src=\"https://i.imgur.com/FrdBKKY.png\">\\n\\n---\\n\\n**Python**\\n\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        \\n        \\n        all_subset = []\\n        bag = []\\n        \\n        \\n        def makeSubsetFrom( startIndex ):\\n            \\n            # Add current subset into final result\\n            # Note: python object is passing by reference, so we have to make a copy\\n            all_subset.append( bag[::] )\\n            \\n            \\n            ## Base cases aka stop condition:\\n            # No more element\\n            if startIndex == len(nums):\\n                return\\n            \\n            ## General cases\\n            # Current level, we choouse element on index i\\n            for i in range(startIndex, len(nums) ):\\n                \\n                bag.append( nums[i] )           # put this element into bag\\n                makeSubsetFrom( i+1 )           # make subset from remaining elements\\n                bag.pop()                       # undo selection\\n            \\n            return\\n        \\n        #----------------------------------------\\n        makeSubsetFrom( startIndex = 0 )\\n        \\n        return all_subset\\n```\\n\\n---\\n\\n**Java**\\n\\n```\\nclass Solution {\\n    \\n    private List< List<Integer> > allSubset = new ArrayList< List<Integer> >();\\n    private List< Integer > bag = new ArrayList<Integer>();\\n    \\n    public List<List<Integer>> subsets(int[] nums) {\\n        \\n        makeSubsetFrom( 0, nums );    \\n    \\n        return allSubset;\\n    }\\n    \\n    private void makeSubsetFrom( int startIndex, int[] nums){\\n        \\n        // Add current subset into final result\\n        // Java object is passing by refernce, so we have to make a copy here\\n        allSubset.add( new ArrayList<Integer>(bag) );\\n\\n\\n        //// Base cases aka stop condition:\\n        // No more element\\n        if( startIndex == nums.length ){\\n            return;\\n        }\\n\\n        //// General cases\\n        // Current level, we choouse element on index i\\n        for( int i = startIndex ; i < nums.length ; i++ ){ \\n\\n            bag.add( nums[i] );            // put this element into bag\\n            makeSubsetFrom( i+1, nums );   // make subset from remaining elements\\n            bag.remove( bag.size()-1);     // undo selection\\n        }\\n        return;\\n        \\n    }\\n    \\n}\\n```\\n\\n---\\n\\n**Javascript**\\n\\n```\\nvar subsets = function(nums) {\\n    \\n    let allSubset = [];\\n    let bag = [];\\n    \\n    \\n    var makeSubsetFrom = function( startIndex ){\\n        \\n        // JS object is passing by referece, so we have to make a copy here\\n        allSubset.push( [...bag] );\\n        \\n        //// Base cases aka stop condition:\\n        // No more element\\n        if ( startIndex == nums.length ){\\n            return;\\n        }\\n        \\n        //// General cases\\n        // Current level, we choouse element on index i\\n        for( let i = startIndex ; i < nums.length ; i++){\\n            \\n            bag.push( nums[i] );    // put this element into bag\\n            makeSubsetFrom( i+1 );  // make subset from remaining elements\\n            bag.pop();              // undo selection\\n        }\\n        return;\\n    }\\n    // ---------------------------------\\n    makeSubsetFrom( startIndex = 0 );\\n    return allSubset;\\n    \\n};\\n```\\n\\n---\\n\\n**C++**\\n\\n```\\nclass Solution{\\npublic:\\n    vector< vector<int> > subsets( vector<int>& nums ){\\n    \\n        vector< vector<int> > allSubset;\\n        vector< int > bag;\\n        \\n        \\n        std::function< void(int)> makeSubsetFrom = [&](int startIndex)->void{\\n            \\n            // Add current subset into final result\\n            allSubset.emplace_back( bag );\\n            \\n            \\n            //// Base cases aka stop condition:\\n            // No more element\\n            if( startIndex == nums.size() ){\\n                return;\\n            }\\n            \\n            //// General cases\\n            // Current level, we choouse element on index i\\n            for( int i = startIndex ; i < nums.size() ; i++ ){ \\n                \\n                bag.emplace_back( nums[i] );            // put this element into bag\\n                makeSubsetFrom( i+1 );                  // make subset from remaining elements\\n                bag.pop_back();                         // undo selection\\n            }\\n            return;\\n        };\\n        \\n        //----------------------------------------\\n        makeSubsetFrom( 0 );    \\n    \\n        return allSubset;\\n    }\\n};\\n\\n```\\n\\n---\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n\\ndef backtrack( parameter ):\\n\\n\\t# Base case handle, aka stop condition\\n\\tif stop condition:\\n\\t\\t# save valid result if needed\\n\\t\\treturn\\n\\t\\t\\n\\t\\n\\t# General cases handle:\\n\\tfor each possible next move/next selection:\\n\\t\\t\\n\\t\\tmake a next move/ select a element\\n\\t\\n\\t\\tbacktrack( updated parameter )\\n\\t\\t\\n\\t\\troll back / undo selection\\n\\t\\t\\n\\treturn\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        \\n        \\n        all_subset = []\\n        bag = []\\n        \\n        \\n        def makeSubsetFrom( startIndex ):\\n            \\n            # Add current subset into final result\\n            # Note: python object is passing by reference, so we have to make a copy\\n            all_subset.append( bag[::] )\\n            \\n            \\n            ## Base cases aka stop condition:\\n            # No more element\\n            if startIndex == len(nums):\\n                return\\n            \\n            ## General cases\\n            # Current level, we choouse element on index i\\n            for i in range(startIndex, len(nums) ):\\n                \\n                bag.append( nums[i] )           # put this element into bag\\n                makeSubsetFrom( i+1 )           # make subset from remaining elements\\n                bag.pop()                       # undo selection\\n            \\n            return\\n        \\n        #----------------------------------------\\n        makeSubsetFrom( startIndex = 0 )\\n        \\n        return all_subset\\n```\n```\\nclass Solution {\\n    \\n    private List< List<Integer> > allSubset = new ArrayList< List<Integer> >();\\n    private List< Integer > bag = new ArrayList<Integer>();\\n    \\n    public List<List<Integer>> subsets(int[] nums) {\\n        \\n        makeSubsetFrom( 0, nums );    \\n    \\n        return allSubset;\\n    }\\n    \\n    private void makeSubsetFrom( int startIndex, int[] nums){\\n        \\n        // Add current subset into final result\\n        // Java object is passing by refernce, so we have to make a copy here\\n        allSubset.add( new ArrayList<Integer>(bag) );\\n\\n\\n        //// Base cases aka stop condition:\\n        // No more element\\n        if( startIndex == nums.length ){\\n            return;\\n        }\\n\\n        //// General cases\\n        // Current level, we choouse element on index i\\n        for( int i = startIndex ; i < nums.length ; i++ ){ \\n\\n            bag.add( nums[i] );            // put this element into bag\\n            makeSubsetFrom( i+1, nums );   // make subset from remaining elements\\n            bag.remove( bag.size()-1);     // undo selection\\n        }\\n        return;\\n        \\n    }\\n    \\n}\\n```\n```\\nvar subsets = function(nums) {\\n    \\n    let allSubset = [];\\n    let bag = [];\\n    \\n    \\n    var makeSubsetFrom = function( startIndex ){\\n        \\n        // JS object is passing by referece, so we have to make a copy here\\n        allSubset.push( [...bag] );\\n        \\n        //// Base cases aka stop condition:\\n        // No more element\\n        if ( startIndex == nums.length ){\\n            return;\\n        }\\n        \\n        //// General cases\\n        // Current level, we choouse element on index i\\n        for( let i = startIndex ; i < nums.length ; i++){\\n            \\n            bag.push( nums[i] );    // put this element into bag\\n            makeSubsetFrom( i+1 );  // make subset from remaining elements\\n            bag.pop();              // undo selection\\n        }\\n        return;\\n    }\\n    // ---------------------------------\\n    makeSubsetFrom( startIndex = 0 );\\n    return allSubset;\\n    \\n};\\n```\n```\\nclass Solution{\\npublic:\\n    vector< vector<int> > subsets( vector<int>& nums ){\\n    \\n        vector< vector<int> > allSubset;\\n        vector< int > bag;\\n        \\n        \\n        std::function< void(int)> makeSubsetFrom = [&](int startIndex)->void{\\n            \\n            // Add current subset into final result\\n            allSubset.emplace_back( bag );\\n            \\n            \\n            //// Base cases aka stop condition:\\n            // No more element\\n            if( startIndex == nums.size() ){\\n                return;\\n            }\\n            \\n            //// General cases\\n            // Current level, we choouse element on index i\\n            for( int i = startIndex ; i < nums.size() ; i++ ){ \\n                \\n                bag.emplace_back( nums[i] );            // put this element into bag\\n                makeSubsetFrom( i+1 );                  // make subset from remaining elements\\n                bag.pop_back();                         // undo selection\\n            }\\n            return;\\n        };\\n        \\n        //----------------------------------------\\n        makeSubsetFrom( 0 );    \\n    \\n        return allSubset;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1095689,
                "title": "cpp-using-aditya-verma-subset-video-12-recursion-playlist",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int> >m;\\n    void solve(vector<int>nums,vector<int>op)\\n    {\\n        if(nums.size()==0)\\n        {\\n            m.push_back(op);\\n            return;\\n        }\\n        vector<int>op1=op,op2=op;\\n        op1.push_back(nums[0]);\\n        nums.erase(nums.begin()+0);\\n        solve(nums,op1);\\n        solve(nums,op2);\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int>op;\\n        solve(nums,op);\\n        return m;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int> >m;\\n    void solve(vector<int>nums,vector<int>op)\\n    {\\n        if(nums.size()==0)\\n        {\\n            m.push_back(op);\\n            return;\\n        }\\n        vector<int>op1=op,op2=op;\\n        op1.push_back(nums[0]);\\n        nums.erase(nums.begin()+0);\\n        solve(nums,op1);\\n        solve(nums,op2);\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int>op;\\n        solve(nums,op);\\n        return m;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 803124,
                "title": "simple-python-recursive-and-iterative-solution",
                "content": "Recursive:\\n```\\ndef subsets(self, nums):\\n    res = []\\n    self.generateSubsets(nums, res, [], 0)\\n    return res\\ndef generateSubsets(self, nums, res, curr, index):\\n    res.append(list(curr))\\n    for i in range(index, len(nums)):\\n        curr.append(nums[i])\\n        self.generateSubsets(nums, res, curr, i + 1)\\n        curr.pop()\\n```\\n\\nIterative:\\n```\\ndef subsets(self, nums):\\n        result = [[]]\\n        for num in nums:\\n            size = len(result)\\n            for j in range(size):\\n                subset = list(result[j])                \\n                subset.append(num) # or subset += [num]\\n                result.append(subset) # or result += subset\\n            \\n        return result\\n```\\n\\nI think understanding the recursive and iterative solution for this problem helps understand the concept better.\\n(I know there is a shorter one-line iterative solution for this, but I think writing it out helps to better visualize and understand the algorithm)\\n\\n*Note: we do list(result[j]) to manipulate the copy of result[j] instead of the direct reference to result[j]",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef subsets(self, nums):\\n    res = []\\n    self.generateSubsets(nums, res, [], 0)\\n    return res\\ndef generateSubsets(self, nums, res, curr, index):\\n    res.append(list(curr))\\n    for i in range(index, len(nums)):\\n        curr.append(nums[i])\\n        self.generateSubsets(nums, res, curr, i + 1)\\n        curr.pop()\\n```\n```\\ndef subsets(self, nums):\\n        result = [[]]\\n        for num in nums:\\n            size = len(result)\\n            for j in range(size):\\n                subset = list(result[j])                \\n                subset.append(num) # or subset += [num]\\n                result.append(subset) # or result += subset\\n            \\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 332547,
                "title": "java-very-simple-bit-manipulation-solution-time-1ms-space-37-5-mb",
                "content": "```\\n public class Solution {\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        for (int i = 0; i < 1 << nums.length; ++i) {\\n            List<Integer> subSet = new ArrayList<>();\\n\\n            for (int b = 0; b < nums.length; ++b) {\\n                if (((i >> b) & 1) == 1) {\\n                    subSet.add(nums[b]);\\n                }\\n            }\\n\\n            result.add(subSet);\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\nExplanation:\\nInput: nums = [1,2,3]\\nOutput:\\n *   [3],       0 0 1\\n *   [1],       1 0 0\\n *   [2],       0 1 0\\n *   [1,2,3],   1 1 1\\n *   [1,3],     1 0 1\\n *   [2,3],     0 1 1\\n *   [1,2],     1 1 0\\n *   []         0 0 0",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n public class Solution {\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        for (int i = 0; i < 1 << nums.length; ++i) {\\n            List<Integer> subSet = new ArrayList<>();\\n\\n            for (int b = 0; b < nums.length; ++b) {\\n                if (((i >> b) & 1) == 1) {\\n                    subSet.add(nums[b]);\\n                }\\n            }\\n\\n            result.add(subSet);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 246941,
                "title": "c-solution-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> dp;\\n        \\n        dp.push_back({});\\n        \\n        for (auto i = 0; i < nums.size(); i++) {\\n            auto size = dp.size();\\n\\n            for (auto j = 0; j < size; j++) {\\n                auto v = dp[j];\\n                v.push_back(nums[i]);\\n                dp.push_back(v);\\n            }\\n        }\\n        return dp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> dp;\\n        \\n        dp.push_back({});\\n        \\n        for (auto i = 0; i < nums.size(); i++) {\\n            auto size = dp.size();\\n\\n            for (auto j = 0; j < size; j++) {\\n                auto v = dp[j];\\n                v.push_back(nums[i]);\\n                dp.push_back(v);\\n            }\\n        }\\n        return dp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611072,
                "title": "c-3-approach-recursive-bit-manipulation-iterative",
                "content": "# Approach 1: Recusion\\n<!-- Describe your approach to solving the problem. -->\\n# Code \\n```\\nclass Solution {\\npublic:\\n    \\n    void sub(int i,vector<int> &nums, vector<int> &temp,vector<vector<int>>&ans)\\n    {\\n        if(i>=nums.size())\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        // pick\\n        temp.push_back(nums[i]);\\n        sub(nums, i+1, temp,ans);\\n\\n        // not pick\\n        temp.pop_back();\\n        //this pop is necessary because we are passing temp by reference. \\n        //if anything will be picked in above call it will remain in temp if we will not pop it.\\n        sub(nums, i+1, temp,ans);\\n    }\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;       \\n        sub(nums, 0, temp,ans); \\n        return ans;\\n    }\\n};\\n```\\n# Complexity\\n- `Time complexity:O(N*(2^N))`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- `Space complexity: O(N) + O(N*(2^N)) = O(N*(2^N)) `\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1. maximum depth of recusion tree will be N hence recursion stack space is O(N).\\n2. we have to store 2^N subsets in ans each of size O(N)\\n\\n# Video Solution by Striver :\\n[https://youtu.be/AxNNVECce8c]()\\n---\\n\\n\\n# Approach 2: Bit Manipulation (Power Set)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int>> ans;\\n        // (1<<n) =2^n\\n        for(int subset_num=0; subset_num < (1<<n); subset_num++)\\n        {\\n            vector<int> subset;\\n            for(int i=0;i<n;i++)\\n            {\\n                // if the ith bit is set \\n                if( (subset_num & (1<<i)) )\\n                {\\n                    subset.push_back(nums[i]);\\n                }\\n            }\\n            ans.push_back(subset);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Complexity\\n- `Time complexity: O(N*(2^N))`\\n1. 2^N subsets will be generated.\\n2. for each subset number we check N bits (set or not)\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- `Space complexity:  O(N*(2^N)) `\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1. we have to store 2^N subsets in ans each of size O(N)\\n\\n# Video Solution by Striver :\\n[https://youtu.be/b7AYbpM5YrE]()\\n---\\n\\n# Approach 3: Iterative\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        int n=nums.size();\\n\\n        output.push_back({});\\n        // initialising the output with an empty subset\\n\\n        for(int i=0; i<n;i++)\\n        {\\n            // for every index i in nums make a copy of all the existing rows in output.\\n            // Then add the ith num to the copy and then push it in output \\n            int size=output.size();\\n            for(int j=0;j<size;j++)\\n            {\\n                vector<int> newRow=output[j]; //O(N)\\n                \\n                newRow.push_back(nums[i]);\\n                output.push_back(newRow);\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```\\n# Complexity\\n- `Time complexity: O(N*(2^N))`\\n1. 2^N subsets will be generated.\\n2. while generating each subset we have to copy one of the previous subset:\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- `Space complexity:  O(N*(2^N))` \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1. we have to store 2^N subsets in ans each of size O(N)\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void sub(int i,vector<int> &nums, vector<int> &temp,vector<vector<int>>&ans)\\n    {\\n        if(i>=nums.size())\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        // pick\\n        temp.push_back(nums[i]);\\n        sub(nums, i+1, temp,ans);\\n\\n        // not pick\\n        temp.pop_back();\\n        //this pop is necessary because we are passing temp by reference. \\n        //if anything will be picked in above call it will remain in temp if we will not pop it.\\n        sub(nums, i+1, temp,ans);\\n    }\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;       \\n        sub(nums, 0, temp,ans); \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int>> ans;\\n        // (1<<n) =2^n\\n        for(int subset_num=0; subset_num < (1<<n); subset_num++)\\n        {\\n            vector<int> subset;\\n            for(int i=0;i<n;i++)\\n            {\\n                // if the ith bit is set \\n                if( (subset_num & (1<<i)) )\\n                {\\n                    subset.push_back(nums[i]);\\n                }\\n            }\\n            ans.push_back(subset);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        int n=nums.size();\\n\\n        output.push_back({});\\n        // initialising the output with an empty subset\\n\\n        for(int i=0; i<n;i++)\\n        {\\n            // for every index i in nums make a copy of all the existing rows in output.\\n            // Then add the ith num to the copy and then push it in output \\n            int size=output.size();\\n            for(int j=0;j<size;j++)\\n            {\\n                vector<int> newRow=output[j]; //O(N)\\n                \\n                newRow.push_back(nums[i]);\\n                output.push_back(newRow);\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252865,
                "title": "python3-using-recursion",
                "content": "\\n# Complexity\\n- Time complexity:\\n2^N\\n\\n- Space complexity:\\n0(N) due to recursive stack\\n\\n# Code\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        n=len(nums)\\n        ans=[]\\n        def solve(idx,lst):\\n            if idx>=n:\\n                ans.append(lst)\\n                return \\n            solve(idx+1,lst)                    #Not Take\\n            solve(idx+1,lst+[nums[idx]])        #Take\\n        solve(0,[])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        n=len(nums)\\n        ans=[]\\n        def solve(idx,lst):\\n            if idx>=n:\\n                ans.append(lst)\\n                return \\n            solve(idx+1,lst)                    #Not Take\\n            solve(idx+1,lst+[nums[idx]])        #Take\\n        solve(0,[])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770171,
                "title": "c-iterative-solution-with-explanation",
                "content": "Kindly **upvote** if you find it helpful **: )**\\n```\\n//Consider nums = [1, 2, 3]\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans = {{}}; //Initialize nums with an empty subset\\n        //In first iteration, adding 1 to []: [[], [1]];\\n        //In second iteration, adding 2 to [] and [1]: [[], [1], [2], [1, 2]];\\n        //In third iteration, adding 3 to [], [1], [2] and [1, 2]: [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]];\\n        for (int a : nums) { \\n            int n = ans.size();\\n            for (int i = 0; i < n; i++) {\\n                ans.push_back(ans[i]); //adds existing element of ans to ans\\n                ans.back().push_back(a);//adds nums\\'s element to the back of the ans\\'s element\\n            }\\n        }\\n        return ans;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\n//Consider nums = [1, 2, 3]\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans = {{}}; //Initialize nums with an empty subset\\n        //In first iteration, adding 1 to []: [[], [1]];\\n        //In second iteration, adding 2 to [] and [1]: [[], [1], [2], [1, 2]];\\n        //In third iteration, adding 3 to [], [1], [2] and [1, 2]: [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]];\\n        for (int a : nums) { \\n            int n = ans.size();\\n            for (int i = 0; i < n; i++) {\\n                ans.push_back(ans[i]); //adds existing element of ans to ans\\n                ans.back().push_back(a);//adds nums\\'s element to the back of the ans\\'s element\\n            }\\n        }\\n        return ans;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766515,
                "title": "easy-python-dp-solution",
                "content": "Keep track of all subsets in an array `dp`. Initially add the empty set. Then iterate through the numbers and add each number to all existing solutions, so all possible subsets are generated.\\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        dp = [[]]\\n        for n in nums:\\n            tmp = []\\n            for x in dp:\\n                tmp.append(x + [n])\\n            dp += tmp\\n        return dp\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        dp = [[]]\\n        for n in nums:\\n            tmp = []\\n            for x in dp:\\n                tmp.append(x + [n])\\n            dp += tmp\\n        return dp\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1381418,
                "title": "c-solution-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void solve(vector<int>input, vector<int>output){\\n        if(input.size() == 0){\\n            ans.push_back(output);   \\n            return;\\n        }\\n        vector<int>op1 = output, op2 = output;\\n        op1.push_back(input[0]);\\n        input.erase(input.begin() + 0);\\n        solve(input, op1);\\n        solve(input, op2);   \\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        solve(nums, {});\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void solve(vector<int>input, vector<int>output){\\n        if(input.size() == 0){\\n            ans.push_back(output);   \\n            return;\\n        }\\n        vector<int>op1 = output, op2 = output;\\n        op1.push_back(input[0]);\\n        input.erase(input.begin() + 0);\\n        solve(input, op1);\\n        solve(input, op2);   \\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        solve(nums, {});\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195865,
                "title": "c-easy-backtracking-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    \\n    vector <vector <int>> powerSet;\\n    void getSubset(vector<int> &nums, vector<int> subset, int i) {\\n        if (i == nums.size()) {\\n            powerSet.push_back(subset);\\n            return;\\n        }\\n        \\n        // accepting element\\n        subset.push_back(nums[i]);\\n        getSubset(nums, subset, i + 1);\\n        \\n        // rejecting element\\n        subset.pop_back();\\n        getSubset(nums, subset, i + 1);\\n    }\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector <int> subset;\\n        getSubset(nums, subset, 0);\\n        return powerSet;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector <vector <int>> powerSet;\\n    void getSubset(vector<int> &nums, vector<int> subset, int i) {\\n        if (i == nums.size()) {\\n            powerSet.push_back(subset);\\n            return;\\n        }\\n        \\n        // accepting element\\n        subset.push_back(nums[i]);\\n        getSubset(nums, subset, i + 1);\\n        \\n        // rejecting element\\n        subset.pop_back();\\n        getSubset(nums, subset, i + 1);\\n    }\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector <int> subset;\\n        getSubset(nums, subset, 0);\\n        return powerSet;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388568,
                "title": "subsets-i-ii-java-solution-with-detailed-explanation-and-comments-recursion-iteration",
                "content": "Reference: [Subsets I](https://leetcode.com/problems/subsets/) & [Subsets II](https://leetcode.com/problems/subsets-ii/) <span class=\"gray\">EPI 15.5</span>\\nDifficulty: <span class=\"orange\">Medium</span> (I think Subsets II should be hard)\\n\\n\\n\\n## Problem\\n\\n> Given a set of `distinct` integers, `nums`, return all possible subsets (the power set).\\n\\n**Note:** The solution set must not contain duplicate subsets.\\n\\n**Example:** \\n\\n```java\\nInput: nums = [1,2,3]\\nOutput: [\\n  [3],\\n  [1],\\n  [2],\\n  [1,2,3],\\n  [1,3],\\n  [2,3],\\n  [1,2],\\n  []\\n]\\n```\\n\\n**Follow up:** Check out the [Subsets II](#subsets_ii) section below.\\n\\n\\n## Analysis\\n\\nThe power set of a set `S` is the set of all subsets of `S`, including both the empty set `emptyset` and `S` itself. The power set of `{1, 2, 3}` is graphically illustrated as follows.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/mgtg8.jpg)\\n\\n\\n### Backtracking\\n\\nThe idea is that we loop over the number list. For each number, we have two choices: pick it, or not. For example, in `[1, 2, 3]`, we pick `1` and then do the same thing for the subproblem `[2, 3]`; and we don\\'t pick `1` and then do the same thing for the subproblem `[2, 3]`.\\n\\nThe size of subproblems is decreasing. When picking `2`, the subproblem becomes `[3]` instead of `[1, 3]`.\\n\\nConsider the following questions:\\n\\n- What is the base case?\\n- When do we add the list to the result?\\n\\nHere is an illustration of recursive process on `[1, 2, 3]`.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/gfdd3.jpg)\\n\\n\\n**Note:** Remember to add empty set manually.\\n\\n\\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  \\n  result.add(new ArrayList<>()); // empty set\\n  subsets(0, nums, numList, result);\\n  return result;\\n}\\n\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result) {\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // pick\\n  numList.add(val);\\n  subsets(offset + 1, nums, numList, result);\\n  // add to result\\n  result.add(new ArrayList<>(numList));\\n  // not pick\\n  numList.remove(numList.size() - 1);\\n  subsets(offset + 1, nums, numList, result);\\n}\\n```\\n\\n**Time:** `O(N * 2^N)` since the recurrence is `T(N) = 2T(N - 1)` and we also spend at most `O(N)` time within a call.\\n**Space:** `O(N * 2^N)` since there are `2^N` subsets. If we only print the result, we just need `O(N)` space.\\n\\n\\n### Iteration\\n\\nThe idea is simple. We go through the elements in the `nums` list. For each element, we loop over the current `result` list we have constructed so far. For each list in the `result`, we make a copy of this list and append the current element to it (it means picking the element). It is based on the same idea in backtracking (in each step you have choices: `pick` or `not pick`).\\n\\nThe result list initially contains an empty list `[]`. We loop over each element of `nums`, e.g. `[1, 2, 3]`.\\n\\n- After the first round, we have `[[], [1]]`.\\n- After the second round, we have `[[], [1], [2], [1,2]]`.\\n- After the third round, we have `[[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]`.\\n\\nFirst, let\\'s go over an incorrect version. There are two errors:\\n\\n1. We add a new element to `L`, but it changes the existed `L`. Thus, we should make a new copy of it.\\n2. While looping over `result`, we are modifying its size. In Java, the compiler would yell.\\n\\n**Incorrect version:**\\n\\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  for (int i = 0; i < nums.length; ++i) {\\n    for (List<Integer> L : result) {\\n      L.add(nums[i]);\\n      result.add(L);\\n    }\\n  }\\n  return result;\\n}\\n```\\n\\n**Correct version:**\\n\\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  for (int i = 0; i < nums.length; ++i) {\\n    List<List<Integer>> newResult = new ArrayList<>(); // used for new lists\\n    for (List<Integer> L : result) {\\n      L = new ArrayList<>(L); // copy\\n      L.add(nums[i]);\\n      newResult.add(L);\\n    }\\n    result.addAll(newResult);  // concatenate\\n  }\\n  return result;\\n}\\n```\\n\\n**Time:** `O(N * 2^N)`\\n- The outer loop takes `O(N)` time.\\n- The inner loop takes `2, 4, 8, ..., 2^N` time respectively.\\n- In inner loop, making a new copy of `L` takes at most `O(N)` time.\\n- Total runtime `T(N) = N * (2 + 4 + 8 + ... + 2^N) ~= N * 2^N`\\n\\n**Space:** `O(N * 2^N)`\\n\\n\\n\\n### K-Size Subsets\\n\\nActually, we can use the code in [77. Combinations](https://www.junhaow.com/lc/problems/backtracking/77_combinations.html) to solve this problem.\\n\\n\\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  \\n  int n = nums.length;\\n  for (int k = 0; k <= n; ++k) { // compatible with empty set\\n    combine(n, k, 1, nums, numList, result);\\n  }\\n  return result;\\n}\\n\\nprivate void combine(int n, int k, int d, int[] nums, List<Integer> numList, List<List<Integer>> result) {\\n  // base case (in order to handle empty set, ordering of two IFs matters)\\n  if (numList.size() == k) { // get a result\\n    result.add(new ArrayList<>(numList));\\n    return;\\n  }\\n  if (n - d + 1 < k - numList.size()) { // remaining elements are not enough\\n    return;\\n  }\\n\\n  for (int i = d; i <= n; ++i) {\\n    int val = nums[i - 1];\\n    numList.add(val);\\n    combine(n, k, i + 1, nums, numList, result);\\n    numList.remove(numList.size() - 1); // remove the last\\n  }\\n}\\n```\\n\\n**Time:** `O(N * 2^N)`\\n- `C(0, N) + C(1, N) + C(2, N) + C(3, N) + ... + C(N, N) = 2^N`\\n\\n**Space:** `O(N * 2^N)`\\n\\n\\n## Subsets II\\n\\nReference:\\n\\n- [[Java] Two Way of Recursive thinking](https://leetcode.com/problems/subsets-ii/discuss/169226/Java-Two-Way-of-Recursive-thinking)\\n- [Simple iterative solution](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution)\\n\\n> Given a collection of integers that might **contain duplicates**, `nums`, return all possible subsets (the power set).\\n\\n**Note:** The solution set must not contain duplicate subsets.\\n\\n```java\\nInput: [1,2,2]\\nOutput: [\\n  [2],\\n  [1],\\n  [1,2,2],\\n  [2,2],\\n  [1,2],\\n  []\\n]\\n```\\n\\n### Backtracking\\n\\nWe need to know when we **should not** add a list to the result list.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/wek92.jpg)\\n\\nBy observation, a duplicate list occurs when `offset >= 1` (when `offset = 0`, duplicate cannot occur) and `nums[offset - 1] == nums[offset]` and in the previous step we did not pick `nums[offset - 1]`. The information of whether it picks or not could be passed down by a **boolean parameter** `isPicked`.\\n \\nIf the above condition is satisfied:\\n- Do not add the list to the result list.\\n- Do not do the subproblem after picking the current element.\\n- Only do the subproblem after not picking the current element.\\n\\n**Note:** Be careful where we should put the `numList.add(val)` and `numList.remove(numList.size() - 1)`.\\n\\n```java\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n  // sorting\\n  Arrays.sort(nums);\\n  \\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  result.add(new ArrayList<>());\\n  subsets(0, nums, numList, result, true);\\n  return result;\\n}\\n\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result, boolean isPicked) {\\n  // base case\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // duplicate checking (convert && to ||)\\n  if (offset == 0 || nums[offset - 1] != nums[offset] || isPicked == true) {\\n    // pick\\n    numList.add(val);\\n    subsets(offset + 1, nums, numList, result, true);\\n    result.add(new ArrayList<>(numList));  // add to the result list\\n    numList.remove(numList.size() - 1);\\n  }\\n  // not pick\\n  subsets(offset + 1, nums, numList, result, false);\\n}\\n```\\n\\nAnother version (similar): \\n\\n```java\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result, boolean isPicked) {\\n  // base case\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // not pick\\n  subsets(offset + 1, nums, numList, result, false);\\n  // duplicate check\\n  if (offset >= 1 && nums[offset - 1] == nums[offset] && isPicked == false) {\\n    return;\\n  }\\n  // pick\\n  numList.add(val);\\n  subsets(offset + 1, nums, numList, result, true);\\n  result.add(new ArrayList<>(numList));  // add to the result list\\n  numList.remove(numList.size() - 1); \\n}\\n```\\n\\n**Time:** `O(N * 2^N)`\\n**Space:** `O(N * 2^N)`\\n\\n\\n\\n\\n### Iteration\\n\\nUsing the same idea in backtracking, we need to figure out when we should add a list to the result list. Check out three examples below (`[1,2,3]`, `[1,2,2]`, `[5,5,5]`).\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/y0inx.jpg)\\n\\nBy observation, we learn that we should start from, if duplicate is detected, a specific location in the result list. In Subsets I, we always start from $0$.\\n\\nInterestingly, the specific location corresponds to the initial size of the result list in the previous round. Since we change the result list in each round, we should cache the size of the result list as `cachedSize`.\\n\\nThen we denote the starting index as `startIdx`. In each round, similar to what we\\'ve done in Subsets I, we set `startIdx` as:\\n\\n- `0` (no duplicate or `i == 0`)\\n- `cachedSize` (duplicate occurs)\\n\\nAfter setting `startIdx`, remember to do the caching job for the current size of the result list. Notice a fact that this cached size may not be used in the next round.\\n\\n\\n```java\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n  // sort\\n  Arrays.sort(nums);\\n  \\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  \\n  int cachedSize = 0, startIdx = 0;\\n  for (int i = 0; i < nums.length; ++i) {\\n    List<List<Integer>> newResult = new ArrayList<>();  // used for new lists\\n    // set startIdx first before we update cachedSize\\n    startIdx = (i > 0 && nums[i - 1] == nums[i]) ? cachedSize : 0; // if duplicate occurs\\n    cachedSize = result.size(); // cache the size for startIdx in the next round\\n    for (int j = startIdx; j < result.size(); ++j) {\\n      List<Integer> L = result.get(j);\\n      L = new ArrayList<>(L);  // copy\\n      L.add(nums[i]);\\n      newResult.add(L);\\n    }\\n    result.addAll(newResult);  // concatenate\\n  }\\n  return result;\\n}\\n```\\n\\n**Time:** `O(N * 2^N)`\\n**Space:** `O(N * 2^N)`\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```java\\nInput: nums = [1,2,3]\\nOutput: [\\n  [3],\\n  [1],\\n  [2],\\n  [1,2,3],\\n  [1,3],\\n  [2,3],\\n  [1,2],\\n  []\\n]\\n```\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  \\n  result.add(new ArrayList<>()); // empty set\\n  subsets(0, nums, numList, result);\\n  return result;\\n}\\n\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result) {\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // pick\\n  numList.add(val);\\n  subsets(offset + 1, nums, numList, result);\\n  // add to result\\n  result.add(new ArrayList<>(numList));\\n  // not pick\\n  numList.remove(numList.size() - 1);\\n  subsets(offset + 1, nums, numList, result);\\n}\\n```\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  for (int i = 0; i < nums.length; ++i) {\\n    for (List<Integer> L : result) {\\n      L.add(nums[i]);\\n      result.add(L);\\n    }\\n  }\\n  return result;\\n}\\n```\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  for (int i = 0; i < nums.length; ++i) {\\n    List<List<Integer>> newResult = new ArrayList<>(); // used for new lists\\n    for (List<Integer> L : result) {\\n      L = new ArrayList<>(L); // copy\\n      L.add(nums[i]);\\n      newResult.add(L);\\n    }\\n    result.addAll(newResult);  // concatenate\\n  }\\n  return result;\\n}\\n```\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  \\n  int n = nums.length;\\n  for (int k = 0; k <= n; ++k) { // compatible with empty set\\n    combine(n, k, 1, nums, numList, result);\\n  }\\n  return result;\\n}\\n\\nprivate void combine(int n, int k, int d, int[] nums, List<Integer> numList, List<List<Integer>> result) {\\n  // base case (in order to handle empty set, ordering of two IFs matters)\\n  if (numList.size() == k) { // get a result\\n    result.add(new ArrayList<>(numList));\\n    return;\\n  }\\n  if (n - d + 1 < k - numList.size()) { // remaining elements are not enough\\n    return;\\n  }\\n\\n  for (int i = d; i <= n; ++i) {\\n    int val = nums[i - 1];\\n    numList.add(val);\\n    combine(n, k, i + 1, nums, numList, result);\\n    numList.remove(numList.size() - 1); // remove the last\\n  }\\n}\\n```\n```java\\nInput: [1,2,2]\\nOutput: [\\n  [2],\\n  [1],\\n  [1,2,2],\\n  [2,2],\\n  [1,2],\\n  []\\n]\\n```\n```java\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n  // sorting\\n  Arrays.sort(nums);\\n  \\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  result.add(new ArrayList<>());\\n  subsets(0, nums, numList, result, true);\\n  return result;\\n}\\n\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result, boolean isPicked) {\\n  // base case\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // duplicate checking (convert && to ||)\\n  if (offset == 0 || nums[offset - 1] != nums[offset] || isPicked == true) {\\n    // pick\\n    numList.add(val);\\n    subsets(offset + 1, nums, numList, result, true);\\n    result.add(new ArrayList<>(numList));  // add to the result list\\n    numList.remove(numList.size() - 1);\\n  }\\n  // not pick\\n  subsets(offset + 1, nums, numList, result, false);\\n}\\n```\n```java\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result, boolean isPicked) {\\n  // base case\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // not pick\\n  subsets(offset + 1, nums, numList, result, false);\\n  // duplicate check\\n  if (offset >= 1 && nums[offset - 1] == nums[offset] && isPicked == false) {\\n    return;\\n  }\\n  // pick\\n  numList.add(val);\\n  subsets(offset + 1, nums, numList, result, true);\\n  result.add(new ArrayList<>(numList));  // add to the result list\\n  numList.remove(numList.size() - 1); \\n}\\n```\n```java\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n  // sort\\n  Arrays.sort(nums);\\n  \\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  \\n  int cachedSize = 0, startIdx = 0;\\n  for (int i = 0; i < nums.length; ++i) {\\n    List<List<Integer>> newResult = new ArrayList<>();  // used for new lists\\n    // set startIdx first before we update cachedSize\\n    startIdx = (i > 0 && nums[i - 1] == nums[i]) ? cachedSize : 0; // if duplicate occurs\\n    cachedSize = result.size(); // cache the size for startIdx in the next round\\n    for (int j = startIdx; j < result.size(); ++j) {\\n      List<Integer> L = result.get(j);\\n      L = new ArrayList<>(L);  // copy\\n      L.add(nums[i]);\\n      newResult.add(L);\\n    }\\n    result.addAll(newResult);  // concatenate\\n  }\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 363804,
                "title": "python-4-ms-beats-100-00-the-shortest-solution-ever-image-explanation",
                "content": "```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res, path = [], []\\n        def inner(nums, path, res):\\n            for i, el in enumerate(nums):\\n                inner(nums[i+1:], path + [el], res)\\n            res.append(path)\\n        inner(nums, path, res)\\n        return res\\n```\\nIllustration for recursion tree in case of nums = [1, 2, 3]\\n![image](https://assets.leetcode.com/users/deniskoder/image_1566992853.png)",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res, path = [], []\\n        def inner(nums, path, res):\\n            for i, el in enumerate(nums):\\n                inner(nums[i+1:], path + [el], res)\\n            res.append(path)\\n        inner(nums, path, res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226217,
                "title": "java-super-simple-8-lines-iterative-1-ms-beats-100",
                "content": "I\\'ve seen all sorts of long and complicated solutions to this problem, with backtracking and recursion and bit manipulation and other stuff.  But it\\'s a pretty simple problem.  Each element of nums is either in, or not in, each subset.  So we can start with the empty set, and then just iteratively build up the solution by simply adding each element.\\n```\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> powerSet = new ArrayList<List<Integer>>( 1<<nums.length );\\n        powerSet.add( new ArrayList<Integer>() );\\n        \\n        for( int num: nums )\\n            for( int i=0, j=powerSet.size(); i<j; i++ ) {\\n                List<Integer> withNum = new ArrayList<Integer>( powerSet.get(i) );\\n                withNum.add( num );\\n                powerSet.add( withNum );\\n            }\\n        \\n        return powerSet;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> powerSet = new ArrayList<List<Integer>>( 1<<nums.length );\\n        powerSet.add( new ArrayList<Integer>() );\\n        \\n        for( int num: nums )\\n            for( int i=0, j=powerSet.size(); i<j; i++ ) {\\n                List<Integer> withNum = new ArrayList<Integer>( powerSet.get(i) );\\n                withNum.add( num );\\n                powerSet.add( withNum );\\n            }\\n        \\n        return powerSet;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 216279,
                "title": "python-solution",
                "content": "Recursive algorithm. Time complexity: `O(2^n)`, space complexity: `O(2^n)`.\\n\\n```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def helper(nums, i, j):\\n            if i > j:\\n                return [[]]\\n            if j - i == 1:\\n                return [[], [nums[i]]]\\n            head = nums[i]\\n            res = helper(nums, i+1, j)\\n            for i in range(len(res)):\\n                res.append(res[i]+[head])\\n            return res\\n        \\n        return helper(nums, 0, len(nums))\\n```\\n\\nIterative algorithm. Time complexity: `O(2^n)`, space complexity: `O(2^n)`.\\n\\n```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = [[]]\\n        for n in nums:\\n            for i in range(len(res)):\\n                res.append(res[i]+[n])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def helper(nums, i, j):\\n            if i > j:\\n                return [[]]\\n            if j - i == 1:\\n                return [[], [nums[i]]]\\n            head = nums[i]\\n            res = helper(nums, i+1, j)\\n            for i in range(len(res)):\\n                res.append(res[i]+[head])\\n            return res\\n        \\n        return helper(nums, 0, len(nums))\\n```\n```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = [[]]\\n        for n in nums:\\n            for i in range(len(res)):\\n                res.append(res[i]+[n])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27520,
                "title": "three-ways-to-do-this-c",
                "content": "1. Clone the lists when process each num.\\n-----------------------------------------\\n\\nAt beginning, there is only one empty list. <br>\\n**{{}}**<br>\\nWhen we process the first num( use 1 to represent), clone all the existing list, for the cloned list, add the cur num to the list.  . Add all the cloned list to the result.<br>\\n**{{},{1}}**<br>\\nwhen we process the second num( use 2 to represent), again clone all existing list, and add cur num to the cloned list. Add all the cloned list to the result.<br>\\n**{{},{1},{2},{1,2}}**<br>\\n\\ndo this until n. \\n\\n    public IList<IList<int>> Subsets(int[] nums) \\n    {\\n        Array.Sort(nums);\\n        IList<IList<int>> res = new List<IList<int>>();\\n        res.Add(new List<int>());\\n        if( nums == null || nums.Length == 0 ) return res;\\n        \\n        for( int i = 0; i < nums.Length; ++i )\\n        {\\n            int count = res.Count;\\n            for( int j = 0; j < count; ++j )\\n            {\\n                List<int> newList = new List<int>( res[j] );\\n                newList.Add( nums[i] );\\n                res.Add(newList);\\n            }\\n            \\n        }\\n        return res;\\n    }\\n\\n\\n2.Bit manipulation\\n------------------\\ngo from 0 to Pow(2, nums.Length) <br>\\n0 -> 0000  -> {}<br>\\n1 -> 0001  -> {1}  // {1} means the list contains the first num in the array nums<br>\\n2 -> 0010  -> {2}<br>\\n3 -> 0011  -> {2,1}<br>\\n.....<br>\\nPow(2, nums.Length) -> ......<br>\\nAdd all above list to the result.<br>\\n\\n\\n    public IList<IList<int>> Subsets(int[] nums) \\n    {\\n        Array.Sort(nums);\\n        \\n        IList<IList<int>> result = new List<IList<int>>();\\n        \\n        int max =  (int)Math.Pow(2, nums.Length);\\n        for( int counter = 0; counter < max; ++counter )\\n        {\\n           IList<int> subSet = new List<int>();\\n           int mark = 1;\\n           for( int j = 0; j < nums.Length; ++j ) \\n           {\\n               if( (mark & counter) != 0 )\\n               {\\n                  subSet.Add(nums[j]); \\n               }\\n               mark <<= 1;\\n           }\\n           \\n           result.Add(subSet);\\n        } \\n        \\n        return result;\\n        \\n    }\\n\\n\\n3. Back tracking\\n----------------\\nWhen process each num, there're two choice, add or do not add. If add, a back track is needed.<br>\\n\\n    public class Solution {\\n    public IList<IList<int>> Subsets(int[] nums) \\n    {\\n        Array.Sort(nums);\\n        \\n        IList<IList<int>> res = new List<IList<int>>();\\n        IList<int> list = new List<int>();\\n        \\n        Subset(res, list, nums, 0);\\n        \\n        return res;\\n    }\\n    \\n    private void Subset( IList<IList<int>> res, IList<int> list, int[] nums, int index )\\n    {\\n       if( index == nums.Length ) \\n       {\\n           res.Add(new List<int>(list));\\n           return;\\n       }\\n       \\n       int count = list.Count;\\n       Subset( res, list, nums,index +1 );\\n      \\n       list.Add( nums[index] );\\n       Subset( res, list, nums,index +1 );\\n       list.RemoveAt( list.Count -1 );\\n       \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    public IList<IList<int>> Subsets(int[] nums) \\n    {\\n        Array.Sort(nums);\\n        \\n        IList<IList<int>> res = new List<IList<int>>();\\n        IList<int> list = new List<int>();\\n        \\n        Subset(res, list, nums, 0);\\n        \\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 27560,
                "title": "1-3-lines-ruby-solutions",
                "content": "**Solution 1**\\n\\n    def subsets(nums)\\n      (0..nums.size).flat_map{ |k| nums.combination(k).to_a }\\n    end\\n\\n**Solution 2**\\n\\n    def subsets(nums)\\n      subsets = [[]]\\n      nums.each { |n| subsets += subsets.map { |s| s + [n] } }\\n      subsets\\n    end\\n\\n**Solution 3**\\n\\n    def subsets(nums)\\n      nums.reduce([[]]) { |subsets, n| subsets + subsets.map { |s| s + [n] } }\\n    end",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "**Solution 1**\\n\\n    def subsets(nums)\\n      (0..nums.size).flat_map{ |k| nums.combination(k).to_a }\\n    end\\n\\n**Solution 2**\\n\\n    def subsets(nums)\\n      subsets = [[]]\\n      nums.each { |n| subsets += subsets.map { |s| s + [n] } }\\n      subsets\\n    end\\n\\n**Solution 3**\\n\\n    def subsets(nums)\\n      nums.reduce([[]]) { |subsets, n| subsets + subsets.map { |s| s + [n] } }\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 27582,
                "title": "java-recursion-solution",
                "content": "    public class Solution {\\n        public List<List<Integer>> subsets(int[] nums) {\\n            List<List<Integer>> res = new ArrayList<List<Integer>>();\\n            List<Integer> subset = new ArrayList<Integer>();\\n            res.add(subset);\\n            \\n            Arrays.sort(nums);\\n            doSubsets(nums,res,subset,0);\\n            return res;\\n        }\\n        \\n        private void doSubsets(int[] nums, List res,List subset,int start){\\n            if(start != nums.length){\\n                for(int i=start; i<nums.length; i++){\\n                    subset.add(nums[i]);\\n                    res.add(new ArrayList(subset));\\n                    doSubsets(nums,res,subset,i+1);\\n                    subset.remove(subset.get(subset.size()-1));\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> subsets(int[] nums) {\\n            List<List<Integer>> res = new ArrayList<List<Integer>>();\\n            List<Integer> subset = new ArrayList<Integer>();\\n            res.add(subset);\\n            \\n            Arrays.sort(nums);\\n            doSubsets(nums,res,subset,0);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3509457,
                "title": "c-recursive-solution-100-beat-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void subsetsum(int index, vector<int>& nums, vector<int>& subset, vector<vector<int>>& result) {\\n        if (index == nums.size()) {\\n            result.push_back(subset);\\n            return;\\n        }\\n        subset.push_back(nums[index]);\\n        subsetsum(index + 1, nums, subset, result);\\n        subset.pop_back();\\n        subsetsum(index + 1, nums, subset, result);\\n    }\\n\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int> subset;\\n        vector<vector<int>> result;\\n        subsetsum(0, nums, subset, result);\\n        return result;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void subsetsum(int index, vector<int>& nums, vector<int>& subset, vector<vector<int>>& result) {\\n        if (index == nums.size()) {\\n            result.push_back(subset);\\n            return;\\n        }\\n        subset.push_back(nums[index]);\\n        subsetsum(index + 1, nums, subset, result);\\n        subset.pop_back();\\n        subsetsum(index + 1, nums, subset, result);\\n    }\\n\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int> subset;\\n        vector<vector<int>> result;\\n        subsetsum(0, nums, subset, result);\\n        return result;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342430,
                "title": "using-bit-manipulation-power-set-concept-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each element we need to take two decisions. Either to **take it or not to take it**, this is how we can create all the subsets.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf an array is of \\'n\\' size, then it must have \\'2^n\\' subsets. \\n- So, the outer loop is running till \\'2^n\\' (same as 1<<n).\\n- We need to take decision(take or not take) for each element. As there are \\'n\\' elements in the array, the inner loop is running \\'n\\' times.\\n- In the inner loop **if (1<<j)&i is giving a set bit** then jth element is taken in the subset, otherwise it is not taken.\\n- at the end of the inner loop the subset is inserted in ans (**vector of vectors**) ans.\\n- At the end of the Outer loop ans is returned.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*2^n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2) \\n\\nIf you find it helpful then please upvote\\u2B06\\uFE0F\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int n=nums.size();\\n        for(int i=0;i<(1<<n);i++){\\n            vector<int>v;\\n            for(int j=0;j<n;j++){\\n                if((1<<j)&i){\\n                    v.push_back(nums[j]);\\n                }\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int n=nums.size();\\n        for(int i=0;i<(1<<n);i++){\\n            vector<int>v;\\n            for(int j=0;j<n;j++){\\n                if((1<<j)&i){\\n                    v.push_back(nums[j]);\\n                }\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209304,
                "title": "best-c-solution-ever-easy-solution-backtracking-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Array + Backtracking\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approach by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity : O(2^N), For every index, we make 2 recursion calls and there are N elements so total time complexity is O(2^N).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity : O(2^N*N), There are 2^N-1 subsets and for every subset, we need O(N) space on average so total space complexity is O(2^N*N).\\n\\n# Code\\n```\\n/*\\n\\n    Time complexity : O(2^N), For every index, we make 2 recursion calls and there are N elements so total time\\n    complexity is O(2^N).\\n\\n    Space complexity : O(2^N*N), There are 2^N-1 subsets and for every subset, we need O(N) space on average so\\n    total space complexity is O(2^N*N).\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void subsets(vector<int> &nums, vector<vector<int>> &output, vector<int>&temp, int index){\\n        if(nums.size() == index){\\n            output.push_back(temp);\\n            return;\\n        }\\n        // Exclude Element\\n        subsets(nums, output, temp, index+1);\\n        // Include Element\\n        temp.push_back(nums[index]);\\n        subsets(nums, output, temp, index+1);\\n        temp.pop_back();\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        subsets(nums, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void subsets(vector<int> nums, vector<vector<int>> &output, vector<int> temp, int index){\\n        if(nums.size() == index){\\n            output.push_back(temp);\\n            return;\\n        }\\n        // Exclude Element\\n        subsets(nums, output, temp, index+1);\\n        // Include Element\\n        temp.push_back(nums[index]);\\n        subsets(nums, output, temp, index+1);\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        subsets(nums, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\n    Time complexity : O(2^N), For every index, we make 2 recursion calls and there are N elements so total time\\n    complexity is O(2^N).\\n\\n    Space complexity : O(2^N*N), There are 2^N-1 subsets and for every subset, we need O(N) space on average so\\n    total space complexity is O(2^N*N).\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void subsets(vector<int> &nums, vector<vector<int>> &output, vector<int>&temp, int index){\\n        if(nums.size() == index){\\n            output.push_back(temp);\\n            return;\\n        }\\n        // Exclude Element\\n        subsets(nums, output, temp, index+1);\\n        // Include Element\\n        temp.push_back(nums[index]);\\n        subsets(nums, output, temp, index+1);\\n        temp.pop_back();\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        subsets(nums, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void subsets(vector<int> nums, vector<vector<int>> &output, vector<int> temp, int index){\\n        if(nums.size() == index){\\n            output.push_back(temp);\\n            return;\\n        }\\n        // Exclude Element\\n        subsets(nums, output, temp, index+1);\\n        // Include Element\\n        temp.push_back(nums[index]);\\n        subsets(nums, output, temp, index+1);\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        subsets(nums, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088993,
                "title": "beats-100-simple-c-back-tracking-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple try to generate all the subseqeunces of array and backtrack.\\nSimply in each backtraking problem three steps are there :\\n- Choose \\n- Explore\\n- Unchoose\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Pick a starting point.\\n- while problem is not solved\\n  -  For each path from the starting point\\n      make recursive call to rest of the problem\\n        before which we undo the current move.\\n \\n- Keep adding the answer in ans vector generated at each recursive call.\\n\\n# Complexity\\n- Time complexity:$$O(n*2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n*2^n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void backtrack(vector<int>&arr,int start,vector<int>&temp){\\n        ans.push_back(temp);\\n        for(int i=start;i<arr.size();i++){\\n            temp.push_back(arr[i]);\\n            backtrack(arr,i+1,temp);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>temp;\\n        backtrack(arr,0,temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void backtrack(vector<int>&arr,int start,vector<int>&temp){\\n        ans.push_back(temp);\\n        for(int i=start;i<arr.size();i++){\\n            temp.push_back(arr[i]);\\n            backtrack(arr,i+1,temp);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>temp;\\n        backtrack(arr,0,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2217980,
                "title": "go-bfs",
                "content": "```\\nfunc subsets(nums []int) [][]int {\\n    var queue [][]int\\n    queue = append(queue, []int{})\\n    \\n    for i := 0; i < len(nums); i++ {\\n        length := len(queue)\\n        \\n        for j := 0; j < length; j++ {\\n            item := queue[j]\\n            \\n            tmp := make([]int, len(item))\\n            copy(tmp, item)\\n            tmp = append(tmp, nums[i])\\n            \\n            queue = append(queue, tmp)\\n        }\\n    }\\n    \\n    return queue\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunc subsets(nums []int) [][]int {\\n    var queue [][]int\\n    queue = append(queue, []int{})\\n    \\n    for i := 0; i < len(nums); i++ {\\n        length := len(queue)\\n        \\n        for j := 0; j < length; j++ {\\n            item := queue[j]\\n            \\n            tmp := make([]int, len(item))\\n            copy(tmp, item)\\n            tmp = append(tmp, nums[i])\\n            \\n            queue = append(queue, tmp)\\n        }\\n    }\\n    \\n    return queue\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1697053,
                "title": "bit-manipulation-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        \\n        int n=nums.size();\\n        int setSize = 1<<n;   // 2^n Number of subset ;\\n        \\n        for(int i=0;i<setSize;i++){\\n            \\n            vector<int>temp;   // for storing values in subsets\\n            \\n            for(int j=0;j<n;j++){\\n                \\n                if(i & (1<<j)){ //Checking for set bits in number i;\\n                temp.push_back(nums[j]);   // Push the value which is at founded index of setbit \\n                }\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nHow to check if ith bit is set or not of number num i.e. (num & 1<<(i-1))\\n\\n We have to check if ith bit is set or not\\n \\n Step 1 : Take number 1 \\n Step 2 : Left shift this to i-1 times so the number becomes 10000 (like this)\\n Step 3 : DO Bitwise And  with num to check if the ith bit is set or not\\n \\n For Example : \\n      Let\\'s Have number 9 \\n\\t  Its Binary representation is 1001\\n\\t  if we have to check is 4th bit\\n\\t  \\n\\t  According to steps take 1 and left shift it 3 times so Number is 1000\\n\\t  Now \\n\\t   1001\\n\\t&1000\\n\\tResults 1000 that is not zero which means that 4th bit is set.\\n\\t\\n\\tHere is picture how to algorithm works :\\n\\t\\n![image](https://assets.leetcode.com/users/images/197bb06c-5c6b-4bb0-a37f-6701c6b2026d_1642422912.8045533.jpeg)\\n\\n\\n\\n\\t\\n\\tThanks",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        \\n        int n=nums.size();\\n        int setSize = 1<<n;   // 2^n Number of subset ;\\n        \\n        for(int i=0;i<setSize;i++){\\n            \\n            vector<int>temp;   // for storing values in subsets\\n            \\n            for(int j=0;j<n;j++){\\n                \\n                if(i & (1<<j)){ //Checking for set bits in number i;\\n                temp.push_back(nums[j]);   // Push the value which is at founded index of setbit \\n                }\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628820,
                "title": "78-subsets-c-solution-2-approaches-full-explaination",
                "content": "**Please upvote if you like the solution and any improvements or suggestion are welcomed in the comments.**\\n**Problem Statement:** Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.\\n## Approach 1: Using Optimal Substructure\\n**Intuition:** \\nIf we know all the subsets of vector of size n, so, we know the solution for nums[1..n-1]\\nEg - n=3 nums[1,2,3]\\n`Subsets for [1, 2] => {[],[1],[2],[1,2]}`\\nNow, as you can see on adding one more element 3 in above set, \\n* all  the subsets of nums[1..n-1] are also subsets of nums[1..n], so copy them\\n* in all subsets of nums[n-1] add one more element at the end and it will create the subsets resulted by adding the last element\\nSo,\\n```\\nsubsets of [1,2,3]= { [] , [1] , [2] , [1,2] } + { []+[3] , [1] + [3] , [2] + [3] , [1,2] + [3] }\\n                    |  subsets of [1,2]        |   new subsets due to element 3                 | \\n\\t\\t\\t\\t\\t={ [],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]}\\n```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Subsets.\\nMemory Usage: 7.3 MB, less than 37.30% of C++ online submissions for Subsets\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> superset={{},{nums[0]}};\\n        for(int i=1;i<nums.size();i++){\\n           vector<vector<int>> curr=superset;\\n            for(auto vec : curr){\\n                vec.push_back(nums[i]);\\n                superset.push_back(vec);\\n            }\\n        }\\n        return superset;\\n    }\\n};\\n```\\n**Time Complexity=O(n*2^n)**\\n## Approach 2: Bit Manipulation\\nIntuition-\\nFor set of size n, we know there are 2^n subsets.  So, each element is represented by a bit of N (=2^n)\\nfor i=0 to 2^n-1\\n    select the elements from array whose bit is set\\nExample-\\nFor n=3, there will be N=2^3 = 8 subsets.\\nrepresenting i as 3 bits\\ni=0 => [000] => []\\ni=1 => [00**1**] => [1]\\ni=2 => [0**1**0] => [2]\\ni=3 => [0**11**] => [1,2]\\ni=4 => [**1**00] => [3]\\ni=5 => [**1**0**1**] => [1,3]\\ni=6 => [**11**0] => [2,3]\\ni=7 => [**111**] => [1,2,3]\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int n = nums.size();\\n        int num = pow(2, n), i = 0;\\n        \\n        while(i<num)\\n        {\\n            vector<int> temp;\\n            for(int j=0; j<n; j++)\\n            {\\n                if(i & 1<<j)\\n                    temp.push_back(nums[j]);\\n            }\\n            for(int i=0; i < temp.size(); i++)\\n            cout<<temp[i]<<\" \";\\n            cout<<\"\\\\n\";\\n            ans.push_back(temp);\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Time Complexity=O(n*2^n)**",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nsubsets of [1,2,3]= { [] , [1] , [2] , [1,2] } + { []+[3] , [1] + [3] , [2] + [3] , [1,2] + [3] }\\n                    |  subsets of [1,2]        |   new subsets due to element 3                 | \\n\\t\\t\\t\\t\\t={ [],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> superset={{},{nums[0]}};\\n        for(int i=1;i<nums.size();i++){\\n           vector<vector<int>> curr=superset;\\n            for(auto vec : curr){\\n                vec.push_back(nums[i]);\\n                superset.push_back(vec);\\n            }\\n        }\\n        return superset;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int n = nums.size();\\n        int num = pow(2, n), i = 0;\\n        \\n        while(i<num)\\n        {\\n            vector<int> temp;\\n            for(int j=0; j<n; j++)\\n            {\\n                if(i & 1<<j)\\n                    temp.push_back(nums[j]);\\n            }\\n            for(int i=0; i < temp.size(); i++)\\n            cout<<temp[i]<<\" \";\\n            cout<<\"\\\\n\";\\n            ans.push_back(temp);\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1207948,
                "title": "c-78-backtrack-approach",
                "content": "class Solution {\\npublic:\\n    \\n    int n;\\n    vector<vector<int>> ans;\\n    vector<int> eachpair;\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        n = nums.size();\\n        backtrack(0, nums);\\n        \\n        return ans;\\n    }\\n    \\n    void backtrack(int index, vector<int>& nums){\\n        if(index == n){\\n            ans.push_back(eachpair);\\n        }\\n        else{\\n            eachpair.push_back(nums[index]);\\n            backtrack(index+1, nums);\\n            eachpair.pop_back();\\n            backtrack(index+1, nums);\\n        }\\n    }\\n    \\n};\\n\\n![image](https://assets.leetcode.com/users/images/25b23cc5-74c9-45a8-aa6f-a274810c588b_1620993522.5976417.jpeg)\\n",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int n;\\n    vector<vector<int>> ans;\\n    vector<int> eachpair;\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        n = nums.size();\\n        backtrack(0, nums);\\n        \\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 348032,
                "title": "swift-one-line-solution",
                "content": "```\\nfunc subsets(_ nums: [Int]) -> [[Int]] {\\n        return nums.reduce([[]]){result, num in\\n              result + result.map{$0 + [num]}\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfunc subsets(_ nums: [Int]) -> [[Int]] {\\n        return nums.reduce([[]]){result, num in\\n              result + result.map{$0 + [num]}\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 27324,
                "title": "simple-c-using-recursion-and-a-template-to-solve-similar-problems",
                "content": "Actually there is a template to those combination problems, you can refer to this post I wrote: [A template to those combination problems](https://discuss.leetcode.com/topic/97538/a-template-to-those-combination-problems).\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>>res;\\n        backtrack(nums, 0, vector<int>(), res);\\n        return res;\\n    }\\n    \\n    void backtrack(vector<int>& nums, int k, vector<int> subset, vector<vector<int>>& res){\\n        if(k == nums.size()){\\n            res.push_back(subset);\\n            return;\\n        }\\n        backtrack(nums, k+1, subset, res);\\n        subset.push_back(nums[k]);\\n        backtrack(nums, k+1, subset, res);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>>res;\\n        backtrack(nums, 0, vector<int>(), res);\\n        return res;\\n    }\\n    \\n    void backtrack(vector<int>& nums, int k, vector<int> subset, vector<vector<int>>& res){\\n        if(k == nums.size()){\\n            res.push_back(subset);\\n            return;\\n        }\\n        backtrack(nums, k+1, subset, res);\\n        subset.push_back(nums[k]);\\n        backtrack(nums, k+1, subset, res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27495,
                "title": "share-my-several-c-solutions-easy-to-understand",
                "content": "***Solution(1):***\\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> subsets(vector<int>& nums) {\\n            int n = nums.size();\\n            vector<vector<int>> ret;\\n            if (n == 0)\\n                return ret;\\n                \\n            sort(nums.begin(), nums.end());\\n            \\n            int i = 0, j = 0, len = 0;\\n            vector<int> temp;\\n            ret.push_back(temp);\\n            \\n            for (i = 0; i < n; i++)\\n            {\\n                len = ret.size();\\n                for (j = 0; j < len; j++)\\n                {\\n                    temp = ret[j];\\n                    temp.push_back(nums[i]);\\n                    ret.push_back(temp);\\n                }\\n            }\\n            \\n            return ret;\\n        }\\n    };\\n\\n***Solution(2):using recursion***\\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> subsets(vector<int>& nums) {\\n            int n = nums.size();\\n            vector<vector<int>> ret;\\n            vector<int> temp;\\n            \\n            if (n == 0)\\n                return ret;\\n                \\n            sort(nums.begin(), nums.end());\\n            \\n            subsetRecusion(nums, ret, temp, 0);\\n            \\n            return ret;\\n        }\\n        \\n        void subsetRecusion(vector<int>& nums, vector<vector<int>>& ret, vector<int> temp, int i)\\n        {\\n            if (i == nums.size())\\n            {\\n                ret.push_back(temp);\\n                return;\\n            }\\n            \\n            //there is no nums[i]\\n            subsetRecusion(nums, ret, temp, i+1);\\n            \\n            //there is nums[i]\\n            temp.push_back(nums[i]);\\n            subsetRecusion(nums, ret, temp, i+1);\\n        }\\n    };\\n\\n***Solution(3):bit manipulation*** \\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> subsets(vector<int>& nums) {\\n            int n = nums.size();\\n            vector<vector<int>> ret;\\n            if (n == 0)\\n                return ret;\\n                \\n            int total = 1 << n;\\n            int i = 0, j = 0, t = 0;\\n            \\n            sort(nums.begin(), nums.end());\\n            \\n            for (i = 0; i < total; i++)\\n            {\\n                vector<int> temp;\\n                t = i;\\n                j = 0;\\n                \\n                for (j = 0; j < n; j++)\\n                {\\n                    if (t == 0)\\n                        break;\\n                    if (t & 1)\\n                        temp.push_back(nums[j]);\\n                    \\n                    t = t >> 1;\\n                }\\n                \\n                ret.push_back(temp);\\n            }\\n            \\n            return ret;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> subsets(vector<int>& nums) {\\n            int n = nums.size();\\n            vector<vector<int>> ret;\\n            if (n == 0)\\n                return ret;\\n                \\n            sort(nums.begin(), nums.end());\\n            \\n            int i = 0, j = 0, len = 0;\\n            vector<int> temp;\\n            ret.push_back(temp);\\n            \\n            for (i = 0; i < n; i++)\\n            {\\n                len = ret.size();\\n                for (j = 0; j < len; j++)\\n                {\\n                    temp = ret[j];\\n                    temp.push_back(nums[i]);\\n                    ret.push_back(temp);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 27564,
                "title": "simple-python-code",
                "content": "    class Solution:\\n        # @param S, a list of integer\\n        # @return a list of lists of integer\\n        def subsets(self, S):\\n        \\tif S == []:\\n        \\t\\treturn []\\n            S.sort() #sort the array to avoid descending list of int\\n            res=[[]]\\n            for element in S:\\n            \\ttemp = []\\n            \\tfor ans in res:\\n            \\t\\t #append the new int to each existing list\\n            \\t\\ttemp.append(ans+[element])\\n            \\tres += temp\\n            return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param S, a list of integer\\n        # @return a list of lists of integer\\n        def subsets(self, S):\\n        \\tif S == []:\\n        \\t\\treturn []\\n            S.sort() #sort the array to avoid descending list of int\\n            res=[[]]\\n            for element in S:\\n            \\ttemp = []\\n            \\tfor ans in res:\\n            \\t\\t #append the new int to each existing list\\n            \\t\\ttemp.append(ans+[element])\\n            \\tres += temp\\n            return res",
                "codeTag": "Java"
            },
            {
                "id": 3434928,
                "title": "java-100-faster-solution-recursion-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(2^n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/d36f503d-b393-4657-a375-4904ec0d9f31_1681911363.8691647.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n\\n        List<List<Integer>> ans = new ArrayList<>(); // initialize the answer list\\n\\n        ArrayList<Integer> subset = new ArrayList<>(); // initialize the subset list\\n\\n        helper(nums, 0, subset, ans); // call the recursive helper function with initial values\\n\\n        return ans; // return the answer list\\n    }\\n\\n    public void helper(int nums[], int i, ArrayList<Integer> subset, List<List<Integer>> ans){\\n        \\n        // base case: if the index i has reached the end of the array, add the current subset to the answer list and return\\n        if(i == nums.length){\\n            ans.add(new ArrayList<>(subset));\\n            return;\\n        }\\n\\n        // add the current element to the subset and recursively call the helper function with the next index\\n        subset.add(nums[i]);\\n        helper(nums, i + 1, subset, ans);\\n\\n        // remove the last element from the subset and recursively call the helper function with the next index\\n        subset.remove(subset.size()-1);\\n        helper(nums, i + 1, subset, ans);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n\\n        List<List<Integer>> ans = new ArrayList<>(); // initialize the answer list\\n\\n        ArrayList<Integer> subset = new ArrayList<>(); // initialize the subset list\\n\\n        helper(nums, 0, subset, ans); // call the recursive helper function with initial values\\n\\n        return ans; // return the answer list\\n    }\\n\\n    public void helper(int nums[], int i, ArrayList<Integer> subset, List<List<Integer>> ans){\\n        \\n        // base case: if the index i has reached the end of the array, add the current subset to the answer list and return\\n        if(i == nums.length){\\n            ans.add(new ArrayList<>(subset));\\n            return;\\n        }\\n\\n        // add the current element to the subset and recursively call the helper function with the next index\\n        subset.add(nums[i]);\\n        helper(nums, i + 1, subset, ans);\\n\\n        // remove the last element from the subset and recursively call the helper function with the next index\\n        subset.remove(subset.size()-1);\\n        helper(nums, i + 1, subset, ans);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215703,
                "title": "easiest-solution-have-a-look-java-c",
                "content": "Please Upvote \\uD83D\\uDE0A\\uD83D\\uDE0A\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<IList<int>> Subsets(int[] nums) {\\n        IList<IList<int>> subsets = new List<IList<int>>();\\n        subsets.Add(new List<int>()); \\n\\n        for(int i=0; i<nums.Length; i++)\\n        {\\n            int count = subsets.Count;\\n            for(int j=0; j<count; j++)\\n            {\\n                var temp = subsets[j].ToList();\\n                temp.Add(nums[i]);\\n                subsets.Add(temp);\\n\\n            }\\n        }\\n        return subsets;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> Subsets(int[] nums) {\\n        IList<IList<int>> subsets = new List<IList<int>>();\\n        subsets.Add(new List<int>()); \\n\\n        for(int i=0; i<nums.Length; i++)\\n        {\\n            int count = subsets.Count;\\n            for(int j=0; j<count; j++)\\n            {\\n                var temp = subsets[j].ToList();\\n                temp.Add(nums[i]);\\n                subsets.Add(temp);\\n\\n            }\\n        }\\n        return subsets;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772766,
                "title": "subsets-java-solution-2-approaches-with-explanation",
                "content": "```\\n1. First Approach\\n\\ndivide task for recursion and for us\\nExample:- a[1,2,3]\\n\\ndivide problem as [1] & [2,3]\\nand for [2,3] subsets are :- [],[2],[3],[2,3] now our task is simply add [1] in [2,3] subsets\\ni.e. [1],[1,2],[1,3],[1,2,3] and before updating [2,3] subsets with [1] make a copy of them\\n\\nsubsets of [1,2,3] = [],[2],[3],[2,3],[1],[1,2],[1,3],[1,2,3] \\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        \\n        return helper(nums,0);\\n    }\\n    public List<List<Integer>> helper(int[] nums, int index)\\n    {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if(index==nums.length){\\n            List<Integer> store = new ArrayList<>();\\n            ans.add(store);\\n            return ans;\\n        }\\n        \\n        List<List<Integer>> partialAns = helper(nums,index+1);\\n        \\n        //store or make a copy of recursion subsets ans so that when we adding our first elementnit does not effect\\n        for(List<Integer> list : partialAns){\\n            ans.add(list);\\n        }\\n        \\n\\t\\t//adding first element to the recursion ans\\n        for(List<Integer> list : partialAns){\\n           List<Integer> list1 = new ArrayList<>();\\n            list1.add(nums[index]);\\n            for(int elem:list)\\n                list1.add(elem);\\n            \\n            ans.add(list1);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n2. Second Approach :- Take or Not Take  || Include or Not include\\n\\nExample :- [1,2,3]\\nin this approach we have two options for each element either take this element in our final ans or not take\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n       \\n        List<Integer> subset = new ArrayList<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        helper(nums,0,ans,subset);\\n        return ans;\\n    }\\n    public void helper(int[] nums, int index, List<List<Integer>> ans, List<Integer> subset)\\n    {\\n        if(index==nums.length){\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        \\n        //include\\n        subset.add(nums[index]);\\n        helper(nums,index+1,ans,subset);\\n        \\n        //exclude\\n        subset.remove(subset.size()-1);\\n        helper(nums,index+1,ans,subset);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n1. First Approach\\n\\ndivide task for recursion and for us\\nExample:- a[1,2,3]\\n\\ndivide problem as [1] & [2,3]\\nand for [2,3] subsets are :- [],[2],[3],[2,3] now our task is simply add [1] in [2,3] subsets\\ni.e. [1],[1,2],[1,3],[1,2,3] and before updating [2,3] subsets with [1] make a copy of them\\n\\nsubsets of [1,2,3] = [],[2],[3],[2,3],[1],[1,2],[1,3],[1,2,3] \\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        \\n        return helper(nums,0);\\n    }\\n    public List<List<Integer>> helper(int[] nums, int index)\\n    {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if(index==nums.length){\\n            List<Integer> store = new ArrayList<>();\\n            ans.add(store);\\n            return ans;\\n        }\\n        \\n        List<List<Integer>> partialAns = helper(nums,index+1);\\n        \\n        //store or make a copy of recursion subsets ans so that when we adding our first elementnit does not effect\\n        for(List<Integer> list : partialAns){\\n            ans.add(list);\\n        }\\n        \\n\\t\\t//adding first element to the recursion ans\\n        for(List<Integer> list : partialAns){\\n           List<Integer> list1 = new ArrayList<>();\\n            list1.add(nums[index]);\\n            for(int elem:list)\\n                list1.add(elem);\\n            \\n            ans.add(list1);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n2. Second Approach :- Take or Not Take  || Include or Not include\\n\\nExample :- [1,2,3]\\nin this approach we have two options for each element either take this element in our final ans or not take\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n       \\n        List<Integer> subset = new ArrayList<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        helper(nums,0,ans,subset);\\n        return ans;\\n    }\\n    public void helper(int[] nums, int index, List<List<Integer>> ans, List<Integer> subset)\\n    {\\n        if(index==nums.length){\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        \\n        //include\\n        subset.add(nums[index]);\\n        helper(nums,index+1,ans,subset);\\n        \\n        //exclude\\n        subset.remove(subset.size()-1);\\n        helper(nums,index+1,ans,subset);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877168,
                "title": "c-4-ms-easy-to-understand-recursion",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid solve(vector<int>& nums,vector<int>output,int index,vector<vector<int>>&ans)\\n\\t\\t{\\n\\t\\t\\tif(index>=nums.size())\\n\\t\\t\\t{\\n\\t\\t\\t\\tans.push_back(output);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tsolve(nums,output,index+1,ans);\\n\\n\\t\\t\\tint element=nums[index];\\n\\t\\t\\toutput.push_back(element);\\n\\t\\t\\t solve(nums,output,index+1,ans);\\n\\n\\n\\t\\t}\\n\\t\\tvector<vector<int>> subsets(vector<int>& nums) {\\n\\t\\tvector<vector<int>>ans;\\n\\t\\tvector<int>output;\\n\\t\\tint index=0;\\n\\t\\tsolve(nums,output,index,ans);\\n\\n\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid solve(vector<int>& nums,vector<int>output,int index,vector<vector<int>>&ans)\\n\\t\\t{\\n\\t\\t\\tif(index>=nums.size())\\n\\t\\t\\t{\\n\\t\\t\\t\\tans.push_back(output);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1855532,
                "title": "java-simple-iterative-solution-with-easy-explanation-0-ms-faster-than-100-00",
                "content": "![image](https://assets.leetcode.com/users/images/f72cdcf3-be55-4ee2-956a-9824dcdb5f59_1647450776.2683885.jpeg)\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> outer=new ArrayList<>();\\n        outer.add(new ArrayList<>());\\n        for(int num:nums){\\n            int size=outer.size();\\n            for(int i=0;i<size;i++){\\n                List<Integer> internal=new ArrayList<>(outer.get(i));\\n                internal.add(num);\\n                outer.add(internal);\\n            }\\n        }\\n        return outer;\\n    }\\n}\\n//please give a reputation if it seems to be easy to understand to you\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> outer=new ArrayList<>();\\n        outer.add(new ArrayList<>());\\n        for(int num:nums){\\n            int size=outer.size();\\n            for(int i=0;i<size;i++){\\n                List<Integer> internal=new ArrayList<>(outer.get(i));\\n                internal.add(num);\\n                outer.add(internal);\\n            }\\n        }\\n        return outer;\\n    }\\n}\\n//please give a reputation if it seems to be easy to understand to you\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721954,
                "title": "java-easy-and-clean-code-with-comments",
                "content": "Runtime: 1 ms, faster than 71.85% of Java online submissions for Subsets.\\n\\n```\\n/*\\n\\nSubsets of an array of length n is (2 to the power n). We will loop i from 0 to (2 to the power n). \\nThen take binary form of i and make a subset. As binary form contains 0 or 1 only, so if 1 comes, \\nthen add the element from the array in the subset list, else not. In a subset of array, each element \\nhas 2 choices, either it will come in the subset, or not come in the subset. So, 1 represents that\\nelement will come in the subset, 0 represents element will not come in the subset. \\n\\nExample : nums = [1,2,3]\\n          Number of subsets = (2 to the power 3) = 8. \\n          So, loop from 0 to 7.\\n\\nLoop (i)     |     Binary form     |     Subset we get\\n0            |       000           |       []\\n1            |       001           |       [3]\\n2            |       010           |       [2]\\n3            |       011           |       [2,3]\\n4            |       100           |       [1]\\n5            |       101           |       [1,3]\\n6            |       110           |       [1,2]\\n7            |       111           |       [1,2,3]\\n\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        //main list to store subsets.\\n        List<List<Integer>> ml = new ArrayList<>();\\n        int n = nums.length;\\n        \\n        //total number of subsets = \\'2 to the power n\\' (1 << n = 1 * (2 to the power n) = 2 to the power n).\\n        int numOfSub = 1 << n; \\n        \\n        //As number of subsets of an array of length n is (2 to the power n), so loop i from 0 till (2 to the power n).\\n        for (int i = 0; i < numOfSub; i++) {\\n            //child list to store a subset.\\n            List<Integer> cl = new ArrayList<>();\\n            //Store i in a temp variable as i is controlling outer loop and cannot be messed with.\\n            int temp = i;\\n            \\n            //We are looping backwards, as when we are calculating binary of a number, the first bit that \\n\\t\\t\\t//comes after dividing the number with 2 is the LSB(Least Significant Bit) or the last bit of the \\n\\t\\t\\t//number\\'s binary form. \\n\\t\\t\\t//For more clarification :- When calculating binary form of a number we divide it repeatedly\\n\\t\\t\\t//by 2 until the remainder becomes 0. After that we write the remainder that has come at every \\n\\t\\t\\t//step of division backwards.\\n            for (int j = n - 1; j >= 0; j--) {\\n                //Taking remainder. (temp & 1) is equal to (temp % 2)\\n                int rem = temp & 1;\\n                //Then dividing it by 2. (temp >> 1) is equal to (temp / 2).\\n                temp = temp >> 1;\\n                \\n                //If rem is equal to 1, then add nums[j].\\n                if (rem == 1) {\\n                    cl.add(0, nums[j]);\\n                }\\n            }\\n            \\n            //After a subset is formed, add it in the main list.\\n            ml.add(cl);\\n        }\\n        \\n        return ml;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n/*\\n\\nSubsets of an array of length n is (2 to the power n). We will loop i from 0 to (2 to the power n). \\nThen take binary form of i and make a subset. As binary form contains 0 or 1 only, so if 1 comes, \\nthen add the element from the array in the subset list, else not. In a subset of array, each element \\nhas 2 choices, either it will come in the subset, or not come in the subset. So, 1 represents that\\nelement will come in the subset, 0 represents element will not come in the subset. \\n\\nExample : nums = [1,2,3]\\n          Number of subsets = (2 to the power 3) = 8. \\n          So, loop from 0 to 7.\\n\\nLoop (i)     |     Binary form     |     Subset we get\\n0            |       000           |       []\\n1            |       001           |       [3]\\n2            |       010           |       [2]\\n3            |       011           |       [2,3]\\n4            |       100           |       [1]\\n5            |       101           |       [1,3]\\n6            |       110           |       [1,2]\\n7            |       111           |       [1,2,3]\\n\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        //main list to store subsets.\\n        List<List<Integer>> ml = new ArrayList<>();\\n        int n = nums.length;\\n        \\n        //total number of subsets = \\'2 to the power n\\' (1 << n = 1 * (2 to the power n) = 2 to the power n).\\n        int numOfSub = 1 << n; \\n        \\n        //As number of subsets of an array of length n is (2 to the power n), so loop i from 0 till (2 to the power n).\\n        for (int i = 0; i < numOfSub; i++) {\\n            //child list to store a subset.\\n            List<Integer> cl = new ArrayList<>();\\n            //Store i in a temp variable as i is controlling outer loop and cannot be messed with.\\n            int temp = i;\\n            \\n            //We are looping backwards, as when we are calculating binary of a number, the first bit that \\n\\t\\t\\t//comes after dividing the number with 2 is the LSB(Least Significant Bit) or the last bit of the \\n\\t\\t\\t//number\\'s binary form. \\n\\t\\t\\t//For more clarification :- When calculating binary form of a number we divide it repeatedly\\n\\t\\t\\t//by 2 until the remainder becomes 0. After that we write the remainder that has come at every \\n\\t\\t\\t//step of division backwards.\\n            for (int j = n - 1; j >= 0; j--) {\\n                //Taking remainder. (temp & 1) is equal to (temp % 2)\\n                int rem = temp & 1;\\n                //Then dividing it by 2. (temp >> 1) is equal to (temp / 2).\\n                temp = temp >> 1;\\n                \\n                //If rem is equal to 1, then add nums[j].\\n                if (rem == 1) {\\n                    cl.add(0, nums[j]);\\n                }\\n            }\\n            \\n            //After a subset is formed, add it in the main list.\\n            ml.add(cl);\\n        }\\n        \\n        return ml;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1473439,
                "title": "python-solutions",
                "content": "attempt 2, bitmap\\n```\\n    # Runtime: 32 ms, faster than 83.27%\\n    # Memory Usage: 14.5 MB, less than 50.73%\\n    #\\n    # note:\\n    #     * use a bitmap, each bit represent whethre an element in @nums appears\\n    #       in a subset, e.g., for [1,2,3], 101 => [1,3]\\n    #     * for @nums of length n, we need n bits, so the bitmap would be from 0\\n    #       to 2**(n-1)\\n    #     * then each bit in the bitmap is tested, if the bit is 1, the\\n    #       corresponding element in @nums appears in the current subset\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        for bitmap in range(2**len(nums)): # O(2**n)\\n            cur = []\\n            for i in range(len(nums)):     # O(n)\\n                if bitmap & 2**i:          # note it is 2**i\\n                    cur.append(nums[i])\\n            res.append(cur)\\n        return res\\n```\\nattempt 3, recursion (is this backtrack?)\\n```   \\n   # Runtime: 26 ms, faster than 95.26%\\n    # Memory Usage: 14.5 MB, less than 50.73%\\n    #\\n    # note:\\n    #     * in each recursion, we decide whether node at current location is\\n    #       added to the subset, so the decision tree for [1,2,3] would be:\\n    #                  ___ 1 ___           -> to make decision for the 1st node\\n    #                y/         \\\\n\\n    #                /           \\\\\\n    #              _2_           _2_       -> to make decision for the 2nd node\\n    #            y/   \\\\n       y/   \\\\n\\n    #            /     \\\\       /     \\\\\\n    #           3       3     3       3    -> to make decision for the 3rd node\\n    #         y/ \\\\n   y/ \\\\n y/ \\\\n   y/ \\\\n\\n    #         /   \\\\   /   \\\\ /   \\\\   /   \\\\\\n    #       123   12 13   1 23  2  3    [] -> leaf nodes are all the subsets\\n    #\\n    # time: O(3*2**n)\\n    #     * number of nodes in the decision tree is:\\n    #         2**0 + 2**1 + ... + 2**n\\n    #       = bit(0) + bit(1) + ... + bit(n)\\n    #       = bit(n+1) - 1\\n    #     * for example, for [1,2,3] number of noeds in the decision tree is:\\n    #         2**0 + 2**1 + 2**2 + 2**3\\n    #       = 00001 + 00010 + 00100 + 01000\\n    #       = 01111\\n    #       = 10000 - 00001\\n    #       = 16 - 1 = 15\\n    #     * and for each of the 2**n result, it is appended to @res, this takes\\n    #       O(1) and the append is called 2**n times so totally O(2**n)\\n    #     * therefore the time complexity is:\\n    #         O(2**(n+1)) + O(2**n)\\n    #       = O(2*2**n) + O(2**n)\\n    #       = O(3*2**n)\\n    # space:\\n    #     * for stack usage, the longest path is log(n)\\n    #     * for the result, since there are 2**n results and each of length\\n    #       O(n), it would be O(n*2**n)\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(i, path):\\n            if i == len(nums):\\n                res.append(path) # subset decisided when a leaf is reached\\n                return\\n            backtrack(i + 1, path + [nums[i]]) # current element added (this creates a new list???)\\n            backtrack(i + 1, path)             # current element skipped\\n        res = []\\n        backtrack(0, [])\\n        return res\\n```\\nattempt 4, backtrack\\n```\\n    # peeked https://leetcode.com/problems/subsets/discuss/362545/Python3-Backtracking\\n    # Runtime: 32 ms, faster than 83.27%\\n    # Memory Usage: 14.5 MB, less than 18.88%\\n    #\\n    # note:\\n    #     * the decision tree for [1,2,3], infeasible paths are avoided by\\n    #       adding only elements with greater indices to the subset, this is how\\n    #       element uniqueness in a subset is guaranteed\\n    #                ____[]_______\\n    #               /         \\\\   \\\\\\n    #              [1]        [2] [3]\\n    #             /   \\\\       /\\n    #          [1,2] [1,3] [2,3]\\n    #           /\\n    #       [1,2,3]\\n    #     * this way the nodes and their subtrees like[1,3,1], [1,3,2], ... are\\n    #       \"pruned\"\\n    #     * therefore unlike the previous attempt, this one does not recored\\n    #       result when i==len(nums)\\n    #     * for path.pop():\\n    #       - as an example, if we just finished [1,2,3] and returned from a\\n    #         call to backtrack(), now @path is [1,2,3] and we want to go back\\n    #         to [1,2] and go the next path (which does not exist though)\\n    #       - as another example, if we just finished [1,2] and returned from a\\n    #         call to backtrack(), now @path is [1,2] and the next path is\\n    #         [1,3], so we have to remove 2\\n    #\\n    # time: O(2*2**n)\\n    #     * number of nodes in the decision tree is 2**n\\n    #     * appending a result to @res takes O(1) and it is called 2**n times\\n    # space: O(2**n)\\n    #     * for stack usage, the deepest path is the subset that contains all\\n    #       the element in @nums, and the elements are added one by one, so it\\n    #       is O(n)\\n    #     * for the result, it is O(n*2**n) as there are 2**n results each has\\n    #       length O(n)\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(i, path):\\n            # use list() because @path is passed by reference and we want to\\n            # create a new lispt here\\n            res.append(list(path)) # O(1)\\n            for i in range(i, len(nums)):\\n                path.append(nums[i])   # O(1)\\n                backtrack(i + 1, path)\\n                path.pop()             # O(1)\\n        res = []\\n        backtrack(0, [])\\n        return res\\n```\\nattempt 6, cascading\\n```\\n    # ref: https://leetcode.com/problems/subsets/discuss/519823/Simple-Intuitive-Python-Solution\\n    # Runtime: 28 ms, faster than 95.21%\\n    # Memory Usage: 14.2 MB, less than 92.48%\\n    #\\n    # note:\\n    #     * the challenging part of this method is that we can\\'t just create\\n    #       references to the elements in the lists, but we have to make copy of\\n    #       them\\n    #     * ---> [[]]\\n    #       -1-> [[],[1]]\\n    #       -2-> [[],[1],[2],[1,2]]\\n    #       -3-> [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\\n    #\\n    # time:\\n    #     * the process is taking lists in @res out and append @n for each of\\n    #       them and @res is started with only one element and ends up with 2**n\\n    #       elements\\n    #       - the process is done 2**0 + 2**1 + ... + 2**n = 2**(n+1) - 1 times\\n    #       - each time the list is copied and appended, which takes O(n) ???\\n    #       - so totally O(n*2**(n+1))\\n    #     * number of nodes in the tree:\\n    #\\n    #     * each element in a subset appended one by one\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = [[]]\\n        for n in nums:          # @n is the element to be added\\n            cur = []            # @cur will be a list in @res each with @n added\\n            for c in res:       # take elements in @res out and add with @n\\n                cur += [c + [n]] # this way we create a new copy of @c with @n added\\n            res += cur\\n        return res\\n```\\nattempt 5, cascading\\n```\\n    # peeked the solution page and\\n    # https://leetcode.com/problems/subsets/discuss/519823/Simple-Intuitive-Python-Solution\\n    #\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = [[]]\\n        for n in nums:\\n            res += [cur + [n] for cur in res]\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    # Runtime: 32 ms, faster than 83.27%\\n    # Memory Usage: 14.5 MB, less than 50.73%\\n    #\\n    # note:\\n    #     * use a bitmap, each bit represent whethre an element in @nums appears\\n    #       in a subset, e.g., for [1,2,3], 101 => [1,3]\\n    #     * for @nums of length n, we need n bits, so the bitmap would be from 0\\n    #       to 2**(n-1)\\n    #     * then each bit in the bitmap is tested, if the bit is 1, the\\n    #       corresponding element in @nums appears in the current subset\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        for bitmap in range(2**len(nums)): # O(2**n)\\n            cur = []\\n            for i in range(len(nums)):     # O(n)\\n                if bitmap & 2**i:          # note it is 2**i\\n                    cur.append(nums[i])\\n            res.append(cur)\\n        return res\\n```\n```   \\n   # Runtime: 26 ms, faster than 95.26%\\n    # Memory Usage: 14.5 MB, less than 50.73%\\n    #\\n    # note:\\n    #     * in each recursion, we decide whether node at current location is\\n    #       added to the subset, so the decision tree for [1,2,3] would be:\\n    #                  ___ 1 ___           -> to make decision for the 1st node\\n    #                y/         \\\\n\\n    #                /           \\\\\\n    #              _2_           _2_       -> to make decision for the 2nd node\\n    #            y/   \\\\n       y/   \\\\n\\n    #            /     \\\\       /     \\\\\\n    #           3       3     3       3    -> to make decision for the 3rd node\\n    #         y/ \\\\n   y/ \\\\n y/ \\\\n   y/ \\\\n\\n    #         /   \\\\   /   \\\\ /   \\\\   /   \\\\\\n    #       123   12 13   1 23  2  3    [] -> leaf nodes are all the subsets\\n    #\\n    # time: O(3*2**n)\\n    #     * number of nodes in the decision tree is:\\n    #         2**0 + 2**1 + ... + 2**n\\n    #       = bit(0) + bit(1) + ... + bit(n)\\n    #       = bit(n+1) - 1\\n    #     * for example, for [1,2,3] number of noeds in the decision tree is:\\n    #         2**0 + 2**1 + 2**2 + 2**3\\n    #       = 00001 + 00010 + 00100 + 01000\\n    #       = 01111\\n    #       = 10000 - 00001\\n    #       = 16 - 1 = 15\\n    #     * and for each of the 2**n result, it is appended to @res, this takes\\n    #       O(1) and the append is called 2**n times so totally O(2**n)\\n    #     * therefore the time complexity is:\\n    #         O(2**(n+1)) + O(2**n)\\n    #       = O(2*2**n) + O(2**n)\\n    #       = O(3*2**n)\\n    # space:\\n    #     * for stack usage, the longest path is log(n)\\n    #     * for the result, since there are 2**n results and each of length\\n    #       O(n), it would be O(n*2**n)\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(i, path):\\n            if i == len(nums):\\n                res.append(path) # subset decisided when a leaf is reached\\n                return\\n            backtrack(i + 1, path + [nums[i]]) # current element added (this creates a new list???)\\n            backtrack(i + 1, path)             # current element skipped\\n        res = []\\n        backtrack(0, [])\\n        return res\\n```\n```\\n    # peeked https://leetcode.com/problems/subsets/discuss/362545/Python3-Backtracking\\n    # Runtime: 32 ms, faster than 83.27%\\n    # Memory Usage: 14.5 MB, less than 18.88%\\n    #\\n    # note:\\n    #     * the decision tree for [1,2,3], infeasible paths are avoided by\\n    #       adding only elements with greater indices to the subset, this is how\\n    #       element uniqueness in a subset is guaranteed\\n    #                ____[]_______\\n    #               /         \\\\   \\\\\\n    #              [1]        [2] [3]\\n    #             /   \\\\       /\\n    #          [1,2] [1,3] [2,3]\\n    #           /\\n    #       [1,2,3]\\n    #     * this way the nodes and their subtrees like[1,3,1], [1,3,2], ... are\\n    #       \"pruned\"\\n    #     * therefore unlike the previous attempt, this one does not recored\\n    #       result when i==len(nums)\\n    #     * for path.pop():\\n    #       - as an example, if we just finished [1,2,3] and returned from a\\n    #         call to backtrack(), now @path is [1,2,3] and we want to go back\\n    #         to [1,2] and go the next path (which does not exist though)\\n    #       - as another example, if we just finished [1,2] and returned from a\\n    #         call to backtrack(), now @path is [1,2] and the next path is\\n    #         [1,3], so we have to remove 2\\n    #\\n    # time: O(2*2**n)\\n    #     * number of nodes in the decision tree is 2**n\\n    #     * appending a result to @res takes O(1) and it is called 2**n times\\n    # space: O(2**n)\\n    #     * for stack usage, the deepest path is the subset that contains all\\n    #       the element in @nums, and the elements are added one by one, so it\\n    #       is O(n)\\n    #     * for the result, it is O(n*2**n) as there are 2**n results each has\\n    #       length O(n)\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(i, path):\\n            # use list() because @path is passed by reference and we want to\\n            # create a new lispt here\\n            res.append(list(path)) # O(1)\\n            for i in range(i, len(nums)):\\n                path.append(nums[i])   # O(1)\\n                backtrack(i + 1, path)\\n                path.pop()             # O(1)\\n        res = []\\n        backtrack(0, [])\\n        return res\\n```\n```\\n    # ref: https://leetcode.com/problems/subsets/discuss/519823/Simple-Intuitive-Python-Solution\\n    # Runtime: 28 ms, faster than 95.21%\\n    # Memory Usage: 14.2 MB, less than 92.48%\\n    #\\n    # note:\\n    #     * the challenging part of this method is that we can\\'t just create\\n    #       references to the elements in the lists, but we have to make copy of\\n    #       them\\n    #     * ---> [[]]\\n    #       -1-> [[],[1]]\\n    #       -2-> [[],[1],[2],[1,2]]\\n    #       -3-> [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\\n    #\\n    # time:\\n    #     * the process is taking lists in @res out and append @n for each of\\n    #       them and @res is started with only one element and ends up with 2**n\\n    #       elements\\n    #       - the process is done 2**0 + 2**1 + ... + 2**n = 2**(n+1) - 1 times\\n    #       - each time the list is copied and appended, which takes O(n) ???\\n    #       - so totally O(n*2**(n+1))\\n    #     * number of nodes in the tree:\\n    #\\n    #     * each element in a subset appended one by one\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = [[]]\\n        for n in nums:          # @n is the element to be added\\n            cur = []            # @cur will be a list in @res each with @n added\\n            for c in res:       # take elements in @res out and add with @n\\n                cur += [c + [n]] # this way we create a new copy of @c with @n added\\n            res += cur\\n        return res\\n```\n```\\n    # peeked the solution page and\\n    # https://leetcode.com/problems/subsets/discuss/519823/Simple-Intuitive-Python-Solution\\n    #\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = [[]]\\n        for n in nums:\\n            res += [cur + [n] for cur in res]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 715304,
                "title": "python-2-ways-w-explnation",
                "content": "**IDEA 1:** For every number in nums, we have the option to either include it or exclude it and proceed further. So, if we have 2 choices for each of the \\uD835\\uDC5B elements, the total number of subsets possible is 2\\\\**n.\\nThis method first builds the lists by including numbers and then backtracks to exclude them and proceed further.\\n\\nThe output for the input [1,2,3] looks like:\\n```\\n    level 0: []\\n    level 1: [1]                    [2]                   [3]\\n    level 2: [1,2]               [1,3]                [2,3] \\n    level 3: [1,2,3]\\n\\n```\\nImplementation: \\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        result = []\\n        self.gen_subsets(nums, 0, [], result)\\n        return result\\n\\n    def gen_subsets(self, nums, curr_idx, curr, result):\\n        result.append(list(curr))\\n        # Iterating over all the elements of the array\\n        for i in range(curr_idx, len(nums)):\\n            # Include\\n            curr.append(nums[i])\\n            # Simulate proceeding while including it\\n            self.gen_subsets(nums, i + 1, curr, result)\\n            # Exclude\\n            curr.pop()\\n\\n```\\n\\n----------------------------------------------------------------------------------------------------\\n\\n\\n**IDEA 2:** Build the result list in a bottom-up manner. Here, we consider one number at a time and then keep building the rest of the list over it. This can be illustrated by the following example:\\n\\n```\\nINPUT                                                      OUTPUT\\n[1]                                                       [[], [1]]\\n[1,2]                                                 [[], [1], [2], [1,2]]\\n[1,2,3]                                     [[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]\\n```\\n\\nHere, we can see that when the input is [1,2], we have used the output for [1], as it is, and then added \\'2\\' to every list within the output to obtain the result for [1,2].\\nSimilarly, for [1,2,3], we have used the output for [1,2], as it is, and then added \\'3\\' to every list within the output to obtain the result for [1,2,3].\\n\\nThus, its like doubling the results with some modification.\\nA general pattern can be observed as:\\n**Output for [1...k] = Output for [1...(k-1)] + Add k to every entry in Output for [1...(k-1)]**\\n\\nThus, the implementation:\\n\\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        result = [[]]\\n        for ele in nums:\\n            result += [entry + [ele] for entry in result]\\n        return result\\n```\\n\\n\\nIf you found this helpful, please upvote and constructive criticism is always welcome! :)\\nPlease feel free to comment if you\\'ve any doubts! :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    level 0: []\\n    level 1: [1]                    [2]                   [3]\\n    level 2: [1,2]               [1,3]                [2,3] \\n    level 3: [1,2,3]\\n\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        result = []\\n        self.gen_subsets(nums, 0, [], result)\\n        return result\\n\\n    def gen_subsets(self, nums, curr_idx, curr, result):\\n        result.append(list(curr))\\n        # Iterating over all the elements of the array\\n        for i in range(curr_idx, len(nums)):\\n            # Include\\n            curr.append(nums[i])\\n            # Simulate proceeding while including it\\n            self.gen_subsets(nums, i + 1, curr, result)\\n            # Exclude\\n            curr.pop()\\n\\n```\n```\\nINPUT                                                      OUTPUT\\n[1]                                                       [[], [1]]\\n[1,2]                                                 [[], [1], [2], [1,2]]\\n[1,2,3]                                     [[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]\\n```\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        result = [[]]\\n        for ele in nums:\\n            result += [entry + [ele] for entry in result]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 358219,
                "title": "python3-clean-solution-in-5-lines-of-code",
                "content": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        ans = [[]]\\n        for num in nums:\\n            for i in range(len(ans)):\\n                ans.append(ans[i] + [num])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        ans = [[]]\\n        for num in nums:\\n            for i in range(len(ans)):\\n                ans.append(ans[i] + [num])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 221467,
                "title": "scala-solution",
                "content": "```\\n  def solution(nums: Array[Int]): List[List[Int]] = {\\n    if (nums.isEmpty) return List(List())\\n    val next = solution(nums.tail)\\n    next ++ next.map(_ :+ nums.head)\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  def solution(nums: Array[Int]): List[List[Int]] = {\\n    if (nums.isEmpty) return List(List())\\n    val next = solution(nums.tail)\\n    next ++ next.map(_ :+ nums.head)\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 180242,
                "title": "java-o-n-dfs-iterative-recursive-and-bfs",
                "content": "# DFS Iterative\\nThis Solution is a simple extension of **DFS Iterative Pre-Order Traversal** \\n1. Tree needs to be built. So In-Order or Post-Order cannot be used which require to visit child before visiting parent.\\n2. Only Pre-order (Top-Down) is possible.\\n\\n***DFS Iterative Pre-Order***\\n1. Create nodeStack \\n2. Add root to stack\\n3. while nodeStack not empty\\n\\t* \\tPop a node out of the stack\\n\\t* \\tVisit the node\\n\\t* \\tAdd left child to stack\\n\\t* \\tAdd right child ot stack\\n\\n***Extension for this problem***\\n* We do not have a tree yet.\\n* Need to build the tree\\n* So no point creating nodeStack\\n* Instead create positionStack to keep track of the position ***( nums[position] )*** we are dealing with at the moment.\\n* Each position in num[] array crossponds to each level in the tree\\n* Start with position 0\\n1. Create new levelStack \\n2. Add position 0 to levelStack\\n3. Create a tempList - as a carrier to transport values from parent to child\\n4. while ( levelStack not empty )\\n\\t* pop() position from levelStack\\n\\t* We will be dealing with nums[positon] in THIS iteration\\n\\t* Check Exit Condition\\n\\t* Time to create left child\\n\\t\\t* Do not add this num[position] to tempList for left child\\n\\t\\t* Push position+1 into stack\\n\\t* Right child\\n\\t\\t* Add nums[position] into tempList\\n\\t\\t* Again Push position+1 into stack for right child \\n\\t\\n\\t* Exit condition\\n\\t\\t* Check if we are at the leaf\\n\\t\\t* If yes - Then its time to record the node to result list\\n\\t\\t* Once result is recorded restore tempList to previous state (backtracking)\\n```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n\\t\\tif(nums == null || nums.length <= 0)\\n\\t\\t\\treturn new ArrayList<>();\\n\\t\\t\\n\\t\\tList<List<Integer>> res = new ArrayList<>();\\n\\t\\tStack<Integer> levelStack = new Stack<>();\\n\\t\\tList<Integer> tempList = new ArrayList<>();\\n\\t\\tlevelStack.push(0);\\n\\t\\t\\n\\t\\twhile(!levelStack.isEmpty()){\\n\\t\\t\\tint pos = levelStack.pop();\\n\\t\\t\\tif(pos == nums.length){ //Exit condition\\n\\t\\t\\t\\tlistCnt++; \\n\\t\\t\\t\\tres.add(new ArrayList<>(tempList));\\n\\t\\t\\t\\tif(!tempList.isEmpty())\\n\\t\\t\\t\\t\\ttempList.remove(tempList.size()-1);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t//Left child\\n\\t\\t\\tlevelStack.push(pos+1);\\n\\t\\t\\t//Right child\\n\\t\\t\\ttempList.add(nums[pos]);\\n\\t\\t\\tlevelStack.push(pos+1);\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n}\\n```\\n\\n# DFS Recursive\\n```\\npublic List<List<Integer>> subsets_DFS_Recursive(int[] nums) {\\n\\tif(nums == null || nums.length <= 0)\\n\\t\\treturn new ArrayList<>();\\n\\n\\tList<List<Integer>> result = new ArrayList<>();\\n\\tList<Integer> input = new ArrayList<>();\\n\\tdfs_Recursive(nums, 0, input, result);\\n\\treturn result;\\n}\\n\\nprivate void dfs_Recursive(int[] nums, int position, List<Integer> input, List<List<Integer>> result) {\\n\\tif(position == nums.length) {\\n\\t\\tresult.add(new ArrayList<>(input));\\n\\t\\treturn;\\n\\t}\\n\\n\\tdfs_Recursive(nums, position+1, input, result);\\n\\tinput.add(nums[position]);\\n\\tdfs_Recursive(nums, position+1, input, result);\\n\\tinput.remove(input.size()-1);\\n}\\n```\\n# BFS\\n```\\npublic List<List<Integer>> subsets_BFS(int[] nums) {\\n\\tif(nums == null || nums.length <= 0)\\n\\t\\treturn new ArrayList<>();\\n\\n\\tList<List<Integer>> res = new ArrayList<>();\\n\\tQueue<List<Integer>> queue = new LinkedList<>(); \\n\\tqueue.offer(new ArrayList<Integer>());\\n\\n\\tfor(int i=0; i<nums.length; i++){\\n\\t\\tint levelSize = queue.size();\\n\\t\\tfor(int j=0; j<levelSize; j++){\\n\\t\\t\\tList<Integer> polled = queue.poll();\\n\\n\\t\\t\\tList<Integer> leftChild = polled;\\n\\t\\t\\t//Left child - Reuse parent\\'s array list obj\\n\\t\\t\\tqueue.offer(leftChild);\\n\\n\\t\\t\\t//Left child has reused the parent\\'s arraylist.. So right child creates a new copy\\n\\t\\t\\tList<Integer> rightChild = new ArrayList<>(polled);\\n\\t\\t\\trightChild.add(nums[i]);\\n\\t\\t\\tqueue.offer(rightChild);\\n\\t\\t}\\t\\n\\t}\\n\\tres.addAll(queue);\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n\\t\\tif(nums == null || nums.length <= 0)\\n\\t\\t\\treturn new ArrayList<>();\\n\\t\\t\\n\\t\\tList<List<Integer>> res = new ArrayList<>();\\n\\t\\tStack<Integer> levelStack = new Stack<>();\\n\\t\\tList<Integer> tempList = new ArrayList<>();\\n\\t\\tlevelStack.push(0);\\n\\t\\t\\n\\t\\twhile(!levelStack.isEmpty()){\\n\\t\\t\\tint pos = levelStack.pop();\\n\\t\\t\\tif(pos == nums.length){ //Exit condition\\n\\t\\t\\t\\tlistCnt++; \\n\\t\\t\\t\\tres.add(new ArrayList<>(tempList));\\n\\t\\t\\t\\tif(!tempList.isEmpty())\\n\\t\\t\\t\\t\\ttempList.remove(tempList.size()-1);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t//Left child\\n\\t\\t\\tlevelStack.push(pos+1);\\n\\t\\t\\t//Right child\\n\\t\\t\\ttempList.add(nums[pos]);\\n\\t\\t\\tlevelStack.push(pos+1);\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n}\\n```\n```\\npublic List<List<Integer>> subsets_DFS_Recursive(int[] nums) {\\n\\tif(nums == null || nums.length <= 0)\\n\\t\\treturn new ArrayList<>();\\n\\n\\tList<List<Integer>> result = new ArrayList<>();\\n\\tList<Integer> input = new ArrayList<>();\\n\\tdfs_Recursive(nums, 0, input, result);\\n\\treturn result;\\n}\\n\\nprivate void dfs_Recursive(int[] nums, int position, List<Integer> input, List<List<Integer>> result) {\\n\\tif(position == nums.length) {\\n\\t\\tresult.add(new ArrayList<>(input));\\n\\t\\treturn;\\n\\t}\\n\\n\\tdfs_Recursive(nums, position+1, input, result);\\n\\tinput.add(nums[position]);\\n\\tdfs_Recursive(nums, position+1, input, result);\\n\\tinput.remove(input.size()-1);\\n}\\n```\n```\\npublic List<List<Integer>> subsets_BFS(int[] nums) {\\n\\tif(nums == null || nums.length <= 0)\\n\\t\\treturn new ArrayList<>();\\n\\n\\tList<List<Integer>> res = new ArrayList<>();\\n\\tQueue<List<Integer>> queue = new LinkedList<>(); \\n\\tqueue.offer(new ArrayList<Integer>());\\n\\n\\tfor(int i=0; i<nums.length; i++){\\n\\t\\tint levelSize = queue.size();\\n\\t\\tfor(int j=0; j<levelSize; j++){\\n\\t\\t\\tList<Integer> polled = queue.poll();\\n\\n\\t\\t\\tList<Integer> leftChild = polled;\\n\\t\\t\\t//Left child - Reuse parent\\'s array list obj\\n\\t\\t\\tqueue.offer(leftChild);\\n\\n\\t\\t\\t//Left child has reused the parent\\'s arraylist.. So right child creates a new copy\\n\\t\\t\\tList<Integer> rightChild = new ArrayList<>(polled);\\n\\t\\t\\trightChild.add(nums[i]);\\n\\t\\t\\tqueue.offer(rightChild);\\n\\t\\t}\\t\\n\\t}\\n\\tres.addAll(queue);\\n\\treturn res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 178796,
                "title": "kotlin-solution-short-and-simple",
                "content": "Kotlin deals with lists in very elegant way, as you can see below. The only thing that might be not obvious is `result.map { it + num}` which for each list in result adds current element `num`. BUT `map` doesn\\'t modify collection itself (`result` in this case), it returns mapped lists.\\n```\\n    fun subsets(nums: IntArray): List<List<Int>> {\\n        val result = mutableListOf(emptyList<Int>())\\n        nums.forEach { num ->\\n            val newAdditions = result.map { it + num}\\n            result.addAll(newAdditions)\\n        }\\n        return result\\n    }",
                "solutionTags": [],
                "code": "Kotlin deals with lists in very elegant way, as you can see below. The only thing that might be not obvious is `result.map { it + num}` which for each list in result adds current element `num`. BUT `map` doesn\\'t modify collection itself (`result` in this case), it returns mapped lists.\\n```\\n    fun subsets(nums: IntArray): List<List<Int>> {\\n        val result = mutableListOf(emptyList<Int>())\\n        nums.forEach { num ->\\n            val newAdditions = result.map { it + num}\\n            result.addAll(newAdditions)\\n        }\\n        return result\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 27622,
                "title": "share-my-accepted-simple-python-code",
                "content": "    class Solution:\\n    # @param S, a list of integer\\n    # @return a list of lists of integer\\n    def subsets(self, S):\\n        if not S:\\n            return [[]]\\n        else:\\n            S.sort()\\n            pre_subsets = self.subsets(S[1:])\\n            return pre_subsets + [[S[0]]+elem for elem in pre_subsets]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @param S, a list of integer\\n    # @return a list of lists of integer\\n    def subsets(self, S):\\n        if not S:\\n            return [[]]\\n        else:\\n            S.sort()\\n            pre_subsets = self.subsets(S[1:])\\n            return pre_subsets + [[S[0]]+elem for elem in pre_subsets]",
                "codeTag": "Java"
            },
            {
                "id": 27624,
                "title": "accepted-dynamic-solution-with-explanation-in-cpp",
                "content": "    /*\\n       LEgend:\\n            #S -> size of input set\\n            #SS(n) -> total number of subsets for a set with size n (i.e 2^n)\\n            S(i) ->ith element of input set\\n            SS(i) -> ith element of the set of subsets of S (starting from 0)\\n            SSn = set of Subset for Sn\\n            SS(#SS(n)-1) -> Last element in SSn\\n       \\n       Logic:\\n            #SS(n)= 2 * #SS(n-1)\\n            => SSn = SSn-1 U { {SS(0),S(n)} , {SS(1),S(n)} , ...  , {SS(#SS(n-1)-1),S(n)} }\\n      \\n       Explanation :      \\n        In simple words,I am using the logic of Dynamic Programming and breaking the problem in smaller subproblems\\n        \\n        eg. S={1,2}\\n        SS2 = { { } , {1} , {2} , {1,2} }\\n        \\n        now to get the subset for {1,2,3} we add the element 3 \\n         in each of the solution set of SS and with this new set do union of SS\\n        \\n        SS3 = SS2 U { {3} , {1,3} , {2,3} , {1,2,3} }\\n            = { {} , {1} , {2} , {1,2} , {3} , {1,3} , {2,3} , {1,2,3} }  \\n    */\\n    \\n        vector<vector<int> > subsets(vector<int> &S) {\\n            vector <int> temp;\\n            vector<vector<int> >ans;\\n            ans.push_back(temp);   //Enters null set\\n            int len=S.size();\\n            int len2;\\n            if(len==0)\\n             return ans;\\n        \\n            sort(S.begin(),S.end());\\n            \\n            for(int i=0 ; i<len ; i++)   //Traverses the whole input array\\n            {    \\n                len2=ans.size();\\n              // Since we cannot append the new number along with the null set therefore this is done outside the loop\\n                temp.clear();\\n                temp.push_back(S[i]);\\n                ans.push_back(temp);\\n            \\n                for(int j=1 ; j<len2 ; j++)\\n                {\\n                    vector<int> temp2(ans[j]);\\n                    temp2.push_back(S[i]);\\n                    ans.push_back(temp2);\\n                }\\n            }\\n            return ans;\\n        }",
                "solutionTags": [],
                "code": "    /*\\n       LEgend:\\n            #S -> size of input set\\n            #SS(n) -> total number of subsets for a set with size n (i.e 2^n)\\n            S(i) ->ith element of input set\\n            SS(i) -> ith element of the set of subsets of S (starting from 0)\\n            SSn = set of Subset for Sn\\n            SS(#SS(n)-1) -> Last element in SSn\\n       \\n       Logic:\\n            #SS(n)= 2 * #SS(n-1)\\n            => SSn = SSn-1 U { {SS(0),S(n)} , {SS(1),S(n)} , ...  , {SS(#SS(n-1)-1),S(n)} }\\n      \\n       Explanation :      \\n        In simple words,I am using the logic of Dynamic Programming and breaking the problem in smaller subproblems\\n        \\n        eg. S={1,2}\\n        SS2 = { { } , {1} , {2} , {1,2} }\\n        \\n        now to get the subset for {1,2,3} we add the element 3 \\n         in each of the solution set of SS and with this new set do union of SS\\n        \\n        SS3 = SS2 U { {3} , {1,3} , {2,3} , {1,2,3} }\\n            = { {} , {1} , {2} , {1,2} , {3} , {1,3} , {2,3} , {1,2,3} }  \\n    */\\n    \\n        vector<vector<int> > subsets(vector<int> &S) {\\n            vector <int> temp;\\n            vector<vector<int> >ans;\\n            ans.push_back(temp);   //Enters null set\\n            int len=S.size();\\n            int len2;\\n            if(len==0)\\n             return ans;\\n        \\n            sort(S.begin(),S.end());\\n            \\n            for(int i=0 ; i<len ; i++)   //Traverses the whole input array\\n            {    \\n                len2=ans.size();\\n              // Since we cannot append the new number along with the null set therefore this is done outside the loop\\n                temp.clear();\\n                temp.push_back(S[i]);\\n                ans.push_back(temp);\\n            \\n                for(int j=1 ; j<len2 ; j++)\\n                {\\n                    vector<int> temp2(ans[j]);\\n                    temp2.push_back(S[i]);\\n                    ans.push_back(temp2);\\n                }\\n            }\\n            return ans;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3164338,
                "title": "solution",
                "content": "```C++ []\\n#include <vector>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> pw_set;\\n        vector<int> subset;\\n        recurse(nums, subset, pw_set, 0);\\n        return pw_set;\\n    }\\nprivate:\\n    void recurse (vector<int>& nums, vector<int>& subset, vector<vector<int>>& pw_set, int i) {\\n        if (i >= nums.size()) {\\n            pw_set.push_back(subset);\\n            return;\\n        }\\n        subset.push_back(nums[i]);\\n        recurse(nums, subset, pw_set, i + 1);\\n\\n        subset.pop_back();\\n        recurse(nums, subset, pw_set, i + 1);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        subsets = [[]]\\n\\n        for num in nums:\\n            n = len(subsets)\\n\\n            for i in range(n):\\n                subset = list(subsets[i])\\n                subset.append(num)\\n                subsets.append(subset)\\n\\n        return subsets\\n```\\n\\n```Java []\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> outer = new ArrayList<>();\\n        outer.add(new ArrayList<>());\\n\\n        for(int num : nums) {\\n            int n = outer.size();\\n            for(int i = 0; i < n; i++) {\\n                List<Integer> list = new ArrayList<>(outer.get(i));\\n                list.add(num);\\n                outer.add(list);\\n            }\\n        }\\n        return outer;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\n#include <vector>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> pw_set;\\n        vector<int> subset;\\n        recurse(nums, subset, pw_set, 0);\\n        return pw_set;\\n    }\\nprivate:\\n    void recurse (vector<int>& nums, vector<int>& subset, vector<vector<int>>& pw_set, int i) {\\n        if (i >= nums.size()) {\\n            pw_set.push_back(subset);\\n            return;\\n        }\\n        subset.push_back(nums[i]);\\n        recurse(nums, subset, pw_set, i + 1);\\n\\n        subset.pop_back();\\n        recurse(nums, subset, pw_set, i + 1);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        subsets = [[]]\\n\\n        for num in nums:\\n            n = len(subsets)\\n\\n            for i in range(n):\\n                subset = list(subsets[i])\\n                subset.append(num)\\n                subsets.append(subset)\\n\\n        return subsets\\n```\n```Java []\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> outer = new ArrayList<>();\\n        outer.add(new ArrayList<>());\\n\\n        for(int num : nums) {\\n            int n = outer.size();\\n            for(int i = 0; i < n; i++) {\\n                List<Integer> list = new ArrayList<>(outer.get(i));\\n                list.add(num);\\n                outer.add(list);\\n            }\\n        }\\n        return outer;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2034062,
                "title": "subset-i-4-approaches-java-solution",
                "content": "### Approach 1 :  Recursive\\n```\\n//Runtime: 1 ms, faster than 78.66% of Java online submissions\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) \\n    {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        helper(nums , 0 , new ArrayList<Integer>() , ans );\\n        return ans;\\n    }\\n    \\n    void helper(int[] nums , int i , ArrayList<Integer> list , List<List<Integer>> ans)\\n    {\\n        if(i==nums.length)\\n        {\\n            ans.add(new ArrayList<>(list));\\n            return ;\\n        }\\n        helper(nums,i+1 , new ArrayList<>(list) , ans);\\n        list.add(nums[i]);\\n        helper(nums , i+1 , list , ans);\\n    }\\n}\\n```\\n\\n### Approach 2 :  Recursive Backtracking\\n```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) \\n    {\\n         List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        subset(nums, 0 , new ArrayList<>() , ans);\\n        return ans;\\n    }\\n    \\n    void subset(int[] nums , int p , ArrayList<Integer> list, List<List<Integer>> ans)\\n    {\\n        ans.add(new ArrayList<>(list));\\n        for(int i=p ; i<nums.length;i++)\\n        {\\n            list.add(nums[i]);\\n            subset(nums , i+1, list , ans);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n\\n```\\n\\n### Approach 3 : Bit Manipulation\\n\\n```\\n// Runtime: 1 ms, faster than 78.66% of Java online submissions\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) \\n    {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        int n = nums.length;\\n       //loop will run for 2^n-1 times\\n       for(int i=0;i<(1<<n) ; i++)\\n       {\\n           ArrayList<Integer> list = new ArrayList<>();\\n           for(int k=0;k<n;k++)\\n           {\\n               if((i & (1<<k))>0)\\n                   list.add(nums[k]);\\n           }\\n               ans.add(new ArrayList<>(list));\\n       }\\n       return ans;   \\n    }\\n}\\n```\\n\\n### Aproach 4 : Iterative Solution\\n```\\n// Runtime: 1 ms, faster than 78.66% of Java online submissions\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) \\n    {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        ans.add(new ArrayList<>()); //adding empty arraylist inside ans\\n        for(int i=0;i<nums.length;i++)   \\n        {\\n            int n=ans.size();\\n            for(int j=0;j<n;j++)\\n            {\\n                //have added the list with same elements \\n                ans.add(new ArrayList<>(ans.get(j)));\\n                //now make sure to add another element too\\n                ans.get(ans.size()-1).add(nums[i]);\\n            }   \\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n* We can see here , Recursive Backtracking is the fastest approach",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\n//Runtime: 1 ms, faster than 78.66% of Java online submissions\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) \\n    {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        helper(nums , 0 , new ArrayList<Integer>() , ans );\\n        return ans;\\n    }\\n    \\n    void helper(int[] nums , int i , ArrayList<Integer> list , List<List<Integer>> ans)\\n    {\\n        if(i==nums.length)\\n        {\\n            ans.add(new ArrayList<>(list));\\n            return ;\\n        }\\n        helper(nums,i+1 , new ArrayList<>(list) , ans);\\n        list.add(nums[i]);\\n        helper(nums , i+1 , list , ans);\\n    }\\n}\\n```\n```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) \\n    {\\n         List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        subset(nums, 0 , new ArrayList<>() , ans);\\n        return ans;\\n    }\\n    \\n    void subset(int[] nums , int p , ArrayList<Integer> list, List<List<Integer>> ans)\\n    {\\n        ans.add(new ArrayList<>(list));\\n        for(int i=p ; i<nums.length;i++)\\n        {\\n            list.add(nums[i]);\\n            subset(nums , i+1, list , ans);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n\\n```\n```\\n// Runtime: 1 ms, faster than 78.66% of Java online submissions\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) \\n    {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        int n = nums.length;\\n       //loop will run for 2^n-1 times\\n       for(int i=0;i<(1<<n) ; i++)\\n       {\\n           ArrayList<Integer> list = new ArrayList<>();\\n           for(int k=0;k<n;k++)\\n           {\\n               if((i & (1<<k))>0)\\n                   list.add(nums[k]);\\n           }\\n               ans.add(new ArrayList<>(list));\\n       }\\n       return ans;   \\n    }\\n}\\n```\n```\\n// Runtime: 1 ms, faster than 78.66% of Java online submissions\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) \\n    {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        ans.add(new ArrayList<>()); //adding empty arraylist inside ans\\n        for(int i=0;i<nums.length;i++)   \\n        {\\n            int n=ans.size();\\n            for(int j=0;j<n;j++)\\n            {\\n                //have added the list with same elements \\n                ans.add(new ArrayList<>(ans.get(j)));\\n                //now make sure to add another element too\\n                ans.get(ans.size()-1).add(nums[i]);\\n            }   \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766605,
                "title": "highly-commented-recursive-javascript-90-faster-easy-understanding",
                "content": "```\\n/* This is a recursive solution\\nFor recursion we need 2 main thing:\\n1) Base case or the terminating condition\\n2) Next state transition/Recurrence Relation i.e\\n A way to move to next from current state/input\\n\\n In this problem our base case will be when we have\\n iterated through the entire length of array i.e\\n when currentIndex >= nums.length\\n\\n And we can apply common sense to derive recurrence relation.\\n So for currentIndex we have only two choices i.e.\\n we can either select/include the number at current index in out set\\n or we can exclude/pass the number at current index.\\n If we choose to include the number in our set when we can do it by [...set,nums[currentIndex]]\\n otherwise if we exclude/pass currentIndex num then our set will remain same as it was earlier i.e set\\n And in either case we will increment our currentIndex so that next time we \\n check for another number in nums array\\n\\n Now let\\'s look into the code \\n */\\nvar subsets = function (nums) {\\n\\t//Array finalOutput stores all the power sets\\n\\tlet finalOutput = [];\\n\\n\\t// Helper method is a recursive function that call\\'s itself\\n\\tconst helper = (currentIndex, set) => {\\n\\t\\t// Check for base case as stated above\\n\\t\\tif (currentIndex >= nums.length) {\\n\\t\\t\\t// push the set of current iteration in finalOutput\\n\\t\\t\\tfinalOutput.push(set);\\n\\t\\t\\treturn; //Necessary to end the recursion iteration\\n\\t\\t}\\n\\n\\t\\t//This is the 1st case where we are including the currentIndex number\\n\\t\\t// We increment currentIndex and add currentNumber i.e nums[currentIndex] in our set i.e. [...set, nums[currentIndex]]\\n\\t\\thelper(currentIndex + 1, [...set, nums[currentIndex]]);\\n\\n\\t\\t// This is the second case where we are excluding the currentIndex number\\n\\t\\t// We increment currentIndex and our set remains unchanged\\n\\t\\thelper(currentIndex + 1, set);\\n\\t};\\n\\t//1st call to recursive function\\n\\thelper(0, []);\\n\\n\\t// return our power set stored in finalOutput\\n\\treturn finalOutput;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/* This is a recursive solution\\nFor recursion we need 2 main thing:\\n1) Base case or the terminating condition\\n2) Next state transition/Recurrence Relation i.e\\n A way to move to next from current state/input\\n\\n In this problem our base case will be when we have\\n iterated through the entire length of array i.e\\n when currentIndex >= nums.length\\n\\n And we can apply common sense to derive recurrence relation.\\n So for currentIndex we have only two choices i.e.\\n we can either select/include the number at current index in out set\\n or we can exclude/pass the number at current index.\\n If we choose to include the number in our set when we can do it by [...set,nums[currentIndex]]\\n otherwise if we exclude/pass currentIndex num then our set will remain same as it was earlier i.e set\\n And in either case we will increment our currentIndex so that next time we \\n check for another number in nums array\\n\\n Now let\\'s look into the code \\n */\\nvar subsets = function (nums) {\\n\\t//Array finalOutput stores all the power sets\\n\\tlet finalOutput = [];\\n\\n\\t// Helper method is a recursive function that call\\'s itself\\n\\tconst helper = (currentIndex, set) => {\\n\\t\\t// Check for base case as stated above\\n\\t\\tif (currentIndex >= nums.length) {\\n\\t\\t\\t// push the set of current iteration in finalOutput\\n\\t\\t\\tfinalOutput.push(set);\\n\\t\\t\\treturn; //Necessary to end the recursion iteration\\n\\t\\t}\\n\\n\\t\\t//This is the 1st case where we are including the currentIndex number\\n\\t\\t// We increment currentIndex and add currentNumber i.e nums[currentIndex] in our set i.e. [...set, nums[currentIndex]]\\n\\t\\thelper(currentIndex + 1, [...set, nums[currentIndex]]);\\n\\n\\t\\t// This is the second case where we are excluding the currentIndex number\\n\\t\\t// We increment currentIndex and our set remains unchanged\\n\\t\\thelper(currentIndex + 1, set);\\n\\t};\\n\\t//1st call to recursive function\\n\\thelper(0, []);\\n\\n\\t// return our power set stored in finalOutput\\n\\treturn finalOutput;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1570009,
                "title": "runtime-0-ms-faster-than-100-00-of-java-online-submissions-for-subsets",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        int n=nums.length;\\n        \\n        int range=1<<n;\\n        List<List<Integer>> ans=new ArrayList<>();\\n        for(int i=0;i<range;i++){\\n            int x=i;\\n            ArrayList<Integer> a=new ArrayList<>();\\n            int j=0;   \\n            while(x>0 && j<n){\\n                if((x&1)==1){\\n                    a.add(nums[n-1-j]);\\n                }\\n                j++;\\n                x=x>>1;\\n            }\\n            ans.add(a);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        int n=nums.length;\\n        \\n        int range=1<<n;\\n        List<List<Integer>> ans=new ArrayList<>();\\n        for(int i=0;i<range;i++){\\n            int x=i;\\n            ArrayList<Integer> a=new ArrayList<>();\\n            int j=0;   \\n            while(x>0 && j<n){\\n                if((x&1)==1){\\n                    a.add(nums[n-1-j]);\\n                }\\n                j++;\\n                x=x>>1;\\n            }\\n            ans.add(a);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1308506,
                "title": "java-0ms-easy-solution",
                "content": "```\\nclass Solution {\\n    List<List<Integer>> lists;\\n    public List<List<Integer>> subsets(int[] nums) {\\n        lists = new ArrayList<>();\\n        List<Integer> list = new ArrayList<>();\\n        solve(list,nums,0);\\n        \\n        return lists;\\n    }\\n    \\n    void solve(List<Integer> list,int[] nums,int curr)\\n    {\\n        \\n        if(curr == nums.length)\\n        {\\n            lists.add(new ArrayList(list));\\n            return;\\n        }\\n        \\n        List<Integer> list2 = new ArrayList(list);\\n        list.add(nums[curr]);\\n        solve(list2,nums,curr+1);\\n        solve(list,nums,curr+1);\\n        \\n    }\\n    \\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> lists;\\n    public List<List<Integer>> subsets(int[] nums) {\\n        lists = new ArrayList<>();\\n        List<Integer> list = new ArrayList<>();\\n        solve(list,nums,0);\\n        \\n        return lists;\\n    }\\n    \\n    void solve(List<Integer> list,int[] nums,int curr)\\n    {\\n        \\n        if(curr == nums.length)\\n        {\\n            lists.add(new ArrayList(list));\\n            return;\\n        }\\n        \\n        List<Integer> list2 = new ArrayList(list);\\n        list.add(nums[curr]);\\n        solve(list2,nums,curr+1);\\n        solve(list,nums,curr+1);\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213159,
                "title": "easiest-solution-with-recursive-tree-intuitive-java-diagram",
                "content": "**Intuition**\\n\\nThe intuition behind the following solution is too simple to believe. Let us first have a look at the following option tree : \\n\\n![image](https://assets.leetcode.com/users/images/1ca8ad88-a0dc-4995-82e0-ce6822177b98_1621218217.2663536.png)\\n\\nAs through observation, it is clear that we start with having a choice to pick or not pick from the first element and then, we propagate this choice down the tree. \\nSo, \\n1. we either pick the element and move ahead ( increment the index ) or,\\n2. we don\\'t pick the element and move ahead\\n\\n```\\nclass Solution {\\n    List<List<Integer>> result;\\n    public List<List<Integer>> subsets(int[] nums) {\\n        result = new ArrayList();\\n        if(nums==null || nums.length==0) return result;\\n        \\n        subsets(nums,new ArrayList<Integer>(), 0);\\n        return result;\\n    }\\n    \\n    private void subsets(int[] nums, ArrayList<Integer> temp, int index) {\\n        // base condition\\n        if(index >= nums.length) {\\n            result.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        \\n        // main logic\\n\\t\\t// case 1 : we pick the element\\n        temp.add(nums[index]);\\n        subsets(nums, temp, index+1); // move ahead\\n        temp.remove(temp.size()-1);\\n        \\n\\t\\t// case 2 : we don\\'t pick the element ( notice, we did not add the current element in our temporary list\\n        subsets(nums, temp, index+1); // move ahead\\n    }\\n}\\n```\\n\\n\\nProceed to solve this related problem : [https://leetcode.com/problems/subsets-ii/](http://)\\n\\n[ Here is the explanation to the same ]\\n[https://leetcode.com/problems/subsets-ii/discuss/1213326/Simple-Intuitive-Solution-or-Using-HashSet](http://)",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> result;\\n    public List<List<Integer>> subsets(int[] nums) {\\n        result = new ArrayList();\\n        if(nums==null || nums.length==0) return result;\\n        \\n        subsets(nums,new ArrayList<Integer>(), 0);\\n        return result;\\n    }\\n    \\n    private void subsets(int[] nums, ArrayList<Integer> temp, int index) {\\n        // base condition\\n        if(index >= nums.length) {\\n            result.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        \\n        // main logic\\n\\t\\t// case 1 : we pick the element\\n        temp.add(nums[index]);\\n        subsets(nums, temp, index+1); // move ahead\\n        temp.remove(temp.size()-1);\\n        \\n\\t\\t// case 2 : we don\\'t pick the element ( notice, we did not add the current element in our temporary list\\n        subsets(nums, temp, index+1); // move ahead\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161814,
                "title": "java-easy-bit-manipulation",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        \\n        List<List<Integer>> ans=  new ArrayList<>();\\n        for(int i= 0; i < (1 << nums.length); ++i){\\n            List<Integer> res = new ArrayList<>();\\n            for(int j= 0; j < nums.length; ++j){\\n                if(((i >> j) & 1 )!= 0)res.add(nums[j]);\\n            }\\n            \\n            ans.add(new ArrayList(res));\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        \\n        List<List<Integer>> ans=  new ArrayList<>();\\n        for(int i= 0; i < (1 << nums.length); ++i){\\n            List<Integer> res = new ArrayList<>();\\n            for(int j= 0; j < nums.length; ++j){\\n                if(((i >> j) & 1 )!= 0)res.add(nums[j]);\\n            }\\n            \\n            ans.add(new ArrayList(res));\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083568,
                "title": "4-different-solutions-to-find-subsets",
                "content": "**Solution 1: Use python funciton itertools.combinations**\\n````\\nfrom itertools import combinations\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        l = len(nums)\\n        ret = []\\n        for i in range(l+1):\\n            temp = list(map(list, combinations(nums, i)))\\n            ret += temp\\n        return ret\\n````\\n**Solution 2: Dynamic programming**\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        dp = [[]]\\n        for n in nums:\\n            dp += [it + [n] for it in dp]\\n        return dp\\n```\\n**Solution 3: General recursion + backtracking solution**\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        ret = []\\n        def dfs(i, path):\\n            ret.append(path)\\n            for j in range(i, len(nums)):\\n                dfs(j+1, path + [nums[j]]) # here should be j+1 rather than j!\\n        dfs(0, [])\\n        return ret\\n```\\n**Solution 4: Bit manipulation to find subsets**\\nUse bit manipulation to find subsets might be useful in other LeetCode problems.\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        # for example nums is [5, 6, 1], input number is 3, convert to binary is 011, then return list should be [6, 1]\\n\\t\\t# if input number is 5 which binary is 101, then return list is [5, 1]\\n        def bit2list(n):\\n            ret = []\\n            idx = 0\\n            while n:\\n                if n&1:\\n                    ret.append(nums[idx])\\n                n >>= 1\\n                idx += 1\\n            return ret\\n        # convert nums to binary, if len(nums)=3, output is 111; if len(nums)=4, output is 1111\\n        base, one = 0, 1\\n        for _ in range(len(nums)):\\n            base += one\\n            one <<= 1\\n        # Use bit manipulation to find subsets; e.g. base=11, subsets: 10, 01\\n\\t\\tret = []\\n        mask = base\\n        while mask:\\n            ret.append(bit2list(mask))\\n            mask = (mask - 1) & base\\n        return ret + [[]]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "````\\nfrom itertools import combinations\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        l = len(nums)\\n        ret = []\\n        for i in range(l+1):\\n            temp = list(map(list, combinations(nums, i)))\\n            ret += temp\\n        return ret\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        dp = [[]]\\n        for n in nums:\\n            dp += [it + [n] for it in dp]\\n        return dp\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        ret = []\\n        def dfs(i, path):\\n            ret.append(path)\\n            for j in range(i, len(nums)):\\n                dfs(j+1, path + [nums[j]]) # here should be j+1 rather than j!\\n        dfs(0, [])\\n        return ret\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        # for example nums is [5, 6, 1], input number is 3, convert to binary is 011, then return list should be [6, 1]\\n\\t\\t# if input number is 5 which binary is 101, then return list is [5, 1]\\n        def bit2list(n):\\n            ret = []\\n            idx = 0\\n            while n:\\n                if n&1:\\n                    ret.append(nums[idx])\\n                n >>= 1\\n                idx += 1\\n            return ret\\n        # convert nums to binary, if len(nums)=3, output is 111; if len(nums)=4, output is 1111\\n        base, one = 0, 1\\n        for _ in range(len(nums)):\\n            base += one\\n            one <<= 1\\n        # Use bit manipulation to find subsets; e.g. base=11, subsets: 10, 01\\n\\t\\tret = []\\n        mask = base\\n        while mask:\\n            ret.append(bit2list(mask))\\n            mask = (mask - 1) & base\\n        return ret + [[]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 946533,
                "title": "c-recursve-diagram-to-show-how-backtracking-works-here",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> subs;\\n        vector<int> currvec;\\n        subsets(nums, 0, currvec, subs);\\n        return subs;\\n    }\\nprivate:\\n    void subsets(vector<int> nums, int i, vector<int> currvec, vector<vector<int>>& subs) {\\n\\t\\n        subs.push_back(currvec);\\n\\t\\t\\n        for (int j = i; j < nums.size(); j++) {\\n            currvec.push_back(nums[j]);\\n            subsets(nums, j + 1, currvec, subs);\\n            currvec.pop_back();\\n        }\\n    }\\n};\\n\\n```\\n\\n![image](https://assets.leetcode.com/users/images/c1b75fc0-1b93-4663-a0b1-ce558ffe9a1e_1606145921.6017413.png)\\n",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> subs;\\n        vector<int> currvec;\\n        subsets(nums, 0, currvec, subs);\\n        return subs;\\n    }\\nprivate:\\n    void subsets(vector<int> nums, int i, vector<int> currvec, vector<vector<int>>& subs) {\\n\\t\\n        subs.push_back(currvec);\\n\\t\\t\\n        for (int j = i; j < nums.size(); j++) {\\n            currvec.push_back(nums[j]);\\n            subsets(nums, j + 1, currvec, subs);\\n            currvec.pop_back();\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917360,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    private IList<IList<int>> res = new List<IList<int>>();\\n    \\n    public IList<IList<int>> Subsets(int[] nums) {\\n        if (nums == null || nums.Length == 0)\\n            return res;\\n        \\n        Backtrack(nums, 0, new List<int>());\\n        \\n        return res;\\n    }\\n    \\n    private void Backtrack(int[] nums, int i, List<int> cur)\\n    {\\n        res.Add(new List<int>(cur));\\n        \\n        if (nums.Length == i)\\n            return;\\n        \\n        for (int j = i; j < nums.Length; j++)\\n        {\\n            cur.Add(nums[j]);\\n            \\n            Backtrack(nums, j + 1, cur);\\n            \\n            cur.RemoveAt(cur.Count - 1);\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    private IList<IList<int>> res = new List<IList<int>>();\\n    \\n    public IList<IList<int>> Subsets(int[] nums) {\\n        if (nums == null || nums.Length == 0)\\n            return res;\\n        \\n        Backtrack(nums, 0, new List<int>());\\n        \\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 891089,
                "title": "c-no-recursion-two-for-loops",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int>t;\\n        ans.push_back(t);\\n        for(int n:nums)\\n        {\\n            int s=ans.size();\\n            for(int i=0;i<s;i++)\\n            {\\n                auto t1=ans[i];\\n                t1.push_back(n);\\n                ans.push_back(t1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int>t;\\n        ans.push_back(t);\\n        for(int n:nums)\\n        {\\n            int s=ans.size();\\n            for(int i=0;i<s;i++)\\n            {\\n                auto t1=ans[i];\\n                t1.push_back(n);\\n                ans.push_back(t1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760907,
                "title": "cpp-iterative-solution",
                "content": "**PLEASE UPVOTE IF YOU LIKE THE SOLUTION**\\n \\n         vector<vector<int>> subsets;\\n         subsets.push_back({});\\n         int size=nums.size();\\n         for(int i=0;i<size;i++){\\n             int subsetsize=subsets.size();\\n             for(int j=0;j<subsetsize;j++){\\n                 vector<int>set=subsets[j];\\n                 set.push_back(nums[i]);\\n                 subsets.push_back(set);\\n             }\\n         }\\n        return subsets;",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "**PLEASE UPVOTE IF YOU LIKE THE SOLUTION**\\n \\n         vector<vector<int>> subsets;\\n         subsets.push_back({});\\n         int size=nums.size();\\n         for(int i=0;i<size;i++){\\n             int subsetsize=subsets.size();\\n             for(int j=0;j<subsetsize;j++){\\n                 vector<int>set=subsets[j];\\n                 set.push_back(nums[i]);\\n                 subsets.push_back(set);\\n             }\\n         }\\n        return subsets;",
                "codeTag": "Unknown"
            },
            {
                "id": 730024,
                "title": "java-clean-code-easy-to-understand-0-ms-time-100-faster",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        \\n        List<List<Integer>> answer = new ArrayList<> ();\\n        answer.add (new ArrayList<> ());\\n        \\n        for (int num : nums) {\\n            int size = answer.size ();\\n            \\n            for (int i = 0; i < size; i++) {\\n                List<Integer> curr = new ArrayList<> (answer.get (i));\\n                curr.add (num);\\n                answer.add (curr);\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        \\n        List<List<Integer>> answer = new ArrayList<> ();\\n        answer.add (new ArrayList<> ());\\n        \\n        for (int num : nums) {\\n            int size = answer.size ();\\n            \\n            for (int i = 0; i < size; i++) {\\n                List<Integer> curr = new ArrayList<> (answer.get (i));\\n                curr.add (num);\\n                answer.add (curr);\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729973,
                "title": "c-2-solutions-with-explanation",
                "content": "The last solution was inspired from leetcode solution\\n### Solution 1\\nThis solution is straightforward. Let\\'s take the example given in the q.\\nnums = [1,2,3]. Let ``i = 0`` the index we are looking at.\\nlet our ans be stored in the array = ans\\nEmpty is set is always a subset. So ans = ``[[]]``\\n\\nApporach: Iterate through the ans array and add nums[i] to that array and add this array to ans.\\n1. ``i=0; nums[i] =1; ans = [[]]``\\nans = [[],[1]];\\n2. ``i=1; nums[i]=2; ans = [[],[1]]``\\nNow we iterate over ans\\n```\\n[]  + 2 = [2]\\n[1] + 2 = [1,2]\\n```\\nPush these two values to ``ans = [[],[1],[2],[1,2]]``\\n3. ``i=2; nums[i]=3; ans = [[],[1],[2],[1,2]]``\\n\\tThis time we iterate over these 4 and inner arrays and add value 3 we get 4 more arrays.\\n```\\n[]    + 3 = [3]\\n[1]   + 3 = [1,3]\\n[2]   + 3 = [2,3]\\n[1,2] + 3 = [1,2,3]\\nadd these 4 new arrays to ans\\nans = [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\\n```\\nCODE: \\n```\\nclass Solution {\\npublic:\\n\\t//helper method\\n    void fillPowerSet(vector<int>& nums,int i,int n,vector<vector<int>>& ans){\\n        if(i==n) return;  //n is end of nums array if we reach there return\\n        int v = nums[i];  // The current element we are looking at\\n        vector<vector<int>>t = ans;  // temp array to store the arrays for current element\\n        for(auto x: t){\\n            x.push_back(v);   // add the current element\\n            ans.push_back(x);  // insert it to ans array\\n        }\\n        fillPowerSet(nums,i+1,n,ans);  // go for the next element (i = i+1)\\n    }\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int i = 0, n=nums.size();\\n        if(n==0) return {};  // if empty array\\n        vector<vector<int>>ans;\\n        ans.push_back({});\\n        fillPowerSet(nums,i,n,ans);\\n        return ans;\\n    }\\n};\\n```\\nTime and space complexity will be: O(2^n * n)\\n2^n iteration for each n;\\n\\n### Solution 2 (backtracking)\\n1. Let i denote the length of the current combination\\n\\tWhen i = 0, we are looking for combination []\\n\\tWhen i=1, we want [1], [2], [3] and so on.\\n2. Let start be the index from which we want to have the combination\\n\\tWhen start = 0 and i = 1 we will get [1]  (nums[start] = 1)\\n\\tstart =1 and i=1 we will get [2] (nums[start] = 2)\\n\\tstart =2 and i=1 we will get [3] ((nums[start] = 3))\\n3. It can be seen as take the sub-array from nums as nums(start,i) where start is the starting index and i is the number of element we need from the start index. (This is just an analogy to understand)\\n4. state is a temporary array that will contain the combinations of i lentgth which will be added to ans once the length of state array is same as i which is the length of the combination we need\\n5. After each time we call backtrack function (bt) we will remove the last element to get the next combination\\n\\nCODE: \\n```\\nclass Solution {\\n  void bt(vector<int>& nums,int start,int i,int n,vector<vector<int>>& ans,vector<int>& state) {\\n    // If this state is complete add to ans\\n\\tif (state.size() == i)  ans.push_back(state);\\n\\n    for (int j = start; j < n; j++) {\\n      state.push_back(nums[j]); // push our element to this combination\\n      bt(nums,j + 1, i,n,ans,state); // go to next element (j=j+1)\\n      state.pop_back();  //remove the last element we added \\n    }\\n  }\\n\\n  vector<vector<int>> subsets(vector<int>& nums) {\\n    int n = nums.size();\\n\\tif(!n) return {}; //empty array\\n\\tvector<vector<int>>ans;\\n    for (int i = 0; i <= n; i++) {\\n\\t\\tvector<int>state;\\n      bt(nums,0,i,n,ans,state);\\n    }\\n    return ans;\\n  }\\n}\\n```\\nTIme and space complexity same as the previous solution: O(2^n *  n)\\n\\n- Leetcode solution contains a third solution with same time & same complexity but is better due to bit masking.\\n\\nThank you!",
                "solutionTags": [],
                "code": "```\\n[]  + 2 = [2]\\n[1] + 2 = [1,2]\\n```\n```\\n[]    + 3 = [3]\\n[1]   + 3 = [1,3]\\n[2]   + 3 = [2,3]\\n[1,2] + 3 = [1,2,3]\\nadd these 4 new arrays to ans\\nans = [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\\n```\n```\\nclass Solution {\\npublic:\\n\\t//helper method\\n    void fillPowerSet(vector<int>& nums,int i,int n,vector<vector<int>>& ans){\\n        if(i==n) return;  //n is end of nums array if we reach there return\\n        int v = nums[i];  // The current element we are looking at\\n        vector<vector<int>>t = ans;  // temp array to store the arrays for current element\\n        for(auto x: t){\\n            x.push_back(v);   // add the current element\\n            ans.push_back(x);  // insert it to ans array\\n        }\\n        fillPowerSet(nums,i+1,n,ans);  // go for the next element (i = i+1)\\n    }\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int i = 0, n=nums.size();\\n        if(n==0) return {};  // if empty array\\n        vector<vector<int>>ans;\\n        ans.push_back({});\\n        fillPowerSet(nums,i,n,ans);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n  void bt(vector<int>& nums,int start,int i,int n,vector<vector<int>>& ans,vector<int>& state) {\\n    // If this state is complete add to ans\\n\\tif (state.size() == i)  ans.push_back(state);\\n\\n    for (int j = start; j < n; j++) {\\n      state.push_back(nums[j]); // push our element to this combination\\n      bt(nums,j + 1, i,n,ans,state); // go to next element (j=j+1)\\n      state.pop_back();  //remove the last element we added \\n    }\\n  }\\n\\n  vector<vector<int>> subsets(vector<int>& nums) {\\n    int n = nums.size();\\n\\tif(!n) return {}; //empty array\\n\\tvector<vector<int>>ans;\\n    for (int i = 0; i <= n; i++) {\\n\\t\\tvector<int>state;\\n      bt(nums,0,i,n,ans,state);\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729931,
                "title": "explanation-provided-c-approach-using-bit-manipulation-bit-masking",
                "content": "```\\nclass Solution {\\npublic:\\n    // Time Complexity: O(N*2^N), Space Complexity: O(N*2^N)\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        // Loop is run from 0 to 2^nums.size()-1 because that will be the total number of subsets.\\n        for(int i=0;i< 1<<nums.size(); i++){\\n            vector<int> subset;\\n            int temp = i, bitPos = 0;\\n            // Checking each bit of a number from the \"for\" loop.\\n            while(temp){\\n                if(temp&1)\\n                    subset.push_back(nums[bitPos]);\\n                bitPos++;\\n                temp = temp>>1;\\n            }\\n            ans.push_back(subset);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nFeel free to ask any doubts in the **comment** section.\\nIf you like this solution, do **UPVOTE**.\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Time Complexity: O(N*2^N), Space Complexity: O(N*2^N)\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        // Loop is run from 0 to 2^nums.size()-1 because that will be the total number of subsets.\\n        for(int i=0;i< 1<<nums.size(); i++){\\n            vector<int> subset;\\n            int temp = i, bitPos = 0;\\n            // Checking each bit of a number from the \"for\" loop.\\n            while(temp){\\n                if(temp&1)\\n                    subset.push_back(nums[bitPos]);\\n                bitPos++;\\n                temp = temp>>1;\\n            }\\n            ans.push_back(subset);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 519823,
                "title": "simple-intuitive-python-solution",
                "content": "![image](https://assets.leetcode.com/users/tohbaino/image_1582599357.png)\\n\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        n = len(nums)\\n        result = [[]]\\n        \\n        for num in nums:\\n            curRes = [val for val in result]\\n            for cur in curRes:\\n                result += [cur+[num]]\\n        \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        n = len(nums)\\n        result = [[]]\\n        \\n        for num in nums:\\n            curRes = [val for val in result]\\n            for cur in curRes:\\n                result += [cur+[num]]\\n        \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 347517,
                "title": "swift-solution-backtracking-explanation-with-simple-example",
                "content": "```\\nclass Solution {\\n    func subsets(_ nums: [Int]) -> [[Int]] {\\n        guard nums.count > 0 else { return [] }\\n        \\n        var result = [[Int]]()\\n        var candidates = [Int]()\\n        let startIndex = 0\\n        \\n        backTracking(&result, &candidates, startIndex, nums)\\n        return result\\n    }\\n    \\n    // assume it\\'s like a tree, we do a similar \"inorder traversal\"\\n    private func backTracking(_ result: inout [[Int]], _ candidates: inout [Int], _ startIndex: Int, _ nums: [Int]) {\\n        // store each case(\"node\")\\'s value\\n        result.append(candidates)\\n        \\n        // try to find if it has \"children\", if no \"child\", we done\\n        for i in startIndex..<nums.count {\\n            // update candidates to next level\\'s value(child\\'s value)\\n            candidates.append(nums[i])\\n            \\n            // startIndex + 1, go next level(go to its child)\\n            backTracking(&result, &candidates, i+1, nums)\\n            \\n            // update candidates to previous level\\'s value(parent\\'s value)\\n            candidates.removeLast()\\n        }\\n    }\\n}\\n\\n// eg: [1, 2, 3]; assume it is like a tree (inorder traversal)\\n//                     []\\n//              /       \\\\       \\\\\\n//            [1]       [2]    [3]\\n//           /   \\\\       |\\n//       [1, 2]  [1, 3] [2, 3]\\n//         /\\n//     [1, 2, 3]\\n\\n// output: [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\\n```\\n",
                "solutionTags": [
                    "Swift",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    func subsets(_ nums: [Int]) -> [[Int]] {\\n        guard nums.count > 0 else { return [] }\\n        \\n        var result = [[Int]]()\\n        var candidates = [Int]()\\n        let startIndex = 0\\n        \\n        backTracking(&result, &candidates, startIndex, nums)\\n        return result\\n    }\\n    \\n    // assume it\\'s like a tree, we do a similar \"inorder traversal\"\\n    private func backTracking(_ result: inout [[Int]], _ candidates: inout [Int], _ startIndex: Int, _ nums: [Int]) {\\n        // store each case(\"node\")\\'s value\\n        result.append(candidates)\\n        \\n        // try to find if it has \"children\", if no \"child\", we done\\n        for i in startIndex..<nums.count {\\n            // update candidates to next level\\'s value(child\\'s value)\\n            candidates.append(nums[i])\\n            \\n            // startIndex + 1, go next level(go to its child)\\n            backTracking(&result, &candidates, i+1, nums)\\n            \\n            // update candidates to previous level\\'s value(parent\\'s value)\\n            candidates.removeLast()\\n        }\\n    }\\n}\\n\\n// eg: [1, 2, 3]; assume it is like a tree (inorder traversal)\\n//                     []\\n//              /       \\\\       \\\\\\n//            [1]       [2]    [3]\\n//           /   \\\\       |\\n//       [1, 2]  [1, 3] [2, 3]\\n//         /\\n//     [1, 2, 3]\\n\\n// output: [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197900,
                "title": "python-solution-with-intuitive-explanation",
                "content": "Find all leaf nodes:\\n```text\\n                        []        \\n                   /          \\\\        \\n                  /            \\\\     \\n                 /              \\\\\\n              [1]                []\\n           /       \\\\           /    \\\\\\n          /         \\\\         /      \\\\        \\n       [1 2]       [1]       [2]     []\\n      /     \\\\     /   \\\\     /   \\\\    / \\\\\\n  [1 2 3] [1 2] [1 3] [1] [2 3] [2] [3] []\\n```\\n\\n```python\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n\\t\\t# DFS\\n        self.res = []\\n        self.dfs(nums, 0, [])\\n        return self.res\\n    \\n    def dfs(self, nums, pos, tmp):\\n        self.res.append(tmp)\\n        for i in range(pos, len(nums)):\\n            self.dfs(nums, i+1, tmp+[nums[i]])\\n        \\n\\t\\t# BFS    \\n        # res = [[]]\\n        # for num in nums:\\n        #     size = len(res)\\n        #     for i in range(size):\\n        #         res.append(copy.deepcopy(res[i]))\\n        #         res[-1].append(num)\\n        # return res\\n```",
                "solutionTags": [],
                "code": "```text\\n                        []        \\n                   /          \\\\        \\n                  /            \\\\     \\n                 /              \\\\\\n              [1]                []\\n           /       \\\\           /    \\\\\\n          /         \\\\         /      \\\\        \\n       [1 2]       [1]       [2]     []\\n      /     \\\\     /   \\\\     /   \\\\    / \\\\\\n  [1 2 3] [1 2] [1 3] [1] [2 3] [2] [3] []\\n```\n```python\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n\\t\\t# DFS\\n        self.res = []\\n        self.dfs(nums, 0, [])\\n        return self.res\\n    \\n    def dfs(self, nums, pos, tmp):\\n        self.res.append(tmp)\\n        for i in range(pos, len(nums)):\\n            self.dfs(nums, i+1, tmp+[nums[i]])\\n        \\n\\t\\t# BFS    \\n        # res = [[]]\\n        # for num in nums:\\n        #     size = len(res)\\n        #     for i in range(size):\\n        #         res.append(copy.deepcopy(res[i]))\\n        #         res[-1].append(num)\\n        # return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27430,
                "title": "5-line-python-code-with-easy-explanation",
                "content": "```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = [[]]\\n        for i in range(len(nums)):\\n            k = nums[i]\\n            res += map(lambda x:x+[k],res)\\n        return res\\n```\\nlet nums = [1,2,3]\\nFirst initialize res as empty list [[]], then pick the first element from nums, that is 1. Then append 1 to all subsets in res, also append the original res to update current res, so res becomes[[],[1]], then pick 2 from nums, res becomes[[],[1],[2],[1,2]]. Finally pick 3 from nums, res becomes [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]. This can be done easily by lambda functions.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = [[]]\\n        for i in range(len(nums)):\\n            k = nums[i]\\n            res += map(lambda x:x+[k],res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27481,
                "title": "java-straight-forward-iteration-method-easy-to-understand",
                "content": "Basic thought is that for every value in nums, generate new list based on result list with adding value to the result list, and add new list to the result list.\\n\\n    public class Solution {\\n        public List<List<Integer>> subsets(int[] nums) {\\n            List<List<Integer>> list = new ArrayList<List<Integer>>();\\n            Arrays.sort(nums);\\n\\n            for(int value : nums) { // for every value in nums, check the list, \\n                if(list.isEmpty()) {\\n                    list.add(new ArrayList(Arrays.asList(value)));\\n                } else {\\n                    int size = list.size();\\n                    for(int i = 0; i < size; i++) {\\n                        List<Integer> temp = new ArrayList<>(list.get(i)); // based on exist list\\n                        temp.add(value); // add value to each list\\n                        list.add(temp);\\n                    }\\n                    list.add(new ArrayList(Arrays.asList(value))); // add current single value\\n                }\\n            }\\n            \\n            list.add(new ArrayList<Integer>());\\n            return list;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> subsets(int[] nums) {\\n            List<List<Integer>> list = new ArrayList<List<Integer>>();\\n            Arrays.sort(nums);\\n\\n            for(int value : nums) { // for every value in nums, check the list, \\n                if(list.isEmpty()) {\\n                    list.add(new ArrayList(Arrays.asList(value)));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3741158,
                "title": "c-bit-mask-vs-backtracking-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code uses bit manipulation to generate all possible subsets of the input vector. It creates a vector called powerSet to store the subsets. The outer loop iterates from m = 0 to m = Mask - 1, representing all possible binary numbers of length n, where n is the size of the input vector. \\n\\nThe inner loop iterates through the elements of the input vector nums and checks if the i-th bit of m is set (i.e., if m & (1 << i) evaluates to true). If the bit is set, it adds the corresponding element nums[i] to the subset stored in powerSet[m]. Finally, it returns the generated power set powerSet.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$ O(2^N * N)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$ O(2^N * N)$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n=nums.size();\\n        int Mask=1<<n;\\n        vector<vector<int>> powerSet(Mask);\\n        for (int m=0; m<Mask; m++){\\n            for(int i=0; i<n; i++){\\n                if (m& 1<<i)\\n                    powerSet[m].push_back(nums[i]);\\n            }\\n        }\\n        return powerSet;\\n    }\\n};\\n```\\n# Code with Comments\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();                        // Get the size of the input vector\\n        int Mask = 1 << n;                           // Calculate the maximum number of subsets using bit manipulation\\n        vector<vector<int>> powerSet(Mask);          // Create a vector to store all the subsets\\n        \\n        for (int m = 0; m < Mask; m++) {              // Iterate through all the possible combinations of subsets\\n            for (int i = 0; i < n; i++) {             // Iterate through the elements of the input vector\\n                if (m & (1 << i))                     // Check if the i-th bit of m is set\\n                    powerSet[m].push_back(nums[i]);  // If the bit is set, add the corresponding element to the subset\\n            }\\n        }\\n        \\n        return powerSet;                             // Return the generated power set\\n    }\\n};\\n\\n```\\n# Code using Backtracking beats 100%\\n```\\nclass Solution {\\npublic:\\nint n;\\n    vector<vector<int>> powerSet;\\n    void dfs(int idx, vector<int> subset, vector<int>& nums ){\\n       \\n        powerSet.push_back(subset);\\n        \\n        for(int i=idx; i<n; i++){\\n            subset.push_back(nums[i]);\\n            dfs(i+1, subset, nums);\\n            subset.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        n=nums.size();\\n        dfs(0,  {}, nums);\\n        \\n        return powerSet;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n=nums.size();\\n        int Mask=1<<n;\\n        vector<vector<int>> powerSet(Mask);\\n        for (int m=0; m<Mask; m++){\\n            for(int i=0; i<n; i++){\\n                if (m& 1<<i)\\n                    powerSet[m].push_back(nums[i]);\\n            }\\n        }\\n        return powerSet;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();                        // Get the size of the input vector\\n        int Mask = 1 << n;                           // Calculate the maximum number of subsets using bit manipulation\\n        vector<vector<int>> powerSet(Mask);          // Create a vector to store all the subsets\\n        \\n        for (int m = 0; m < Mask; m++) {              // Iterate through all the possible combinations of subsets\\n            for (int i = 0; i < n; i++) {             // Iterate through the elements of the input vector\\n                if (m & (1 << i))                     // Check if the i-th bit of m is set\\n                    powerSet[m].push_back(nums[i]);  // If the bit is set, add the corresponding element to the subset\\n            }\\n        }\\n        \\n        return powerSet;                             // Return the generated power set\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\nint n;\\n    vector<vector<int>> powerSet;\\n    void dfs(int idx, vector<int> subset, vector<int>& nums ){\\n       \\n        powerSet.push_back(subset);\\n        \\n        for(int i=idx; i<n; i++){\\n            subset.push_back(nums[i]);\\n            dfs(i+1, subset, nums);\\n            subset.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        n=nums.size();\\n        dfs(0,  {}, nums);\\n        \\n        return powerSet;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596405,
                "title": "best-solution",
                "content": "# Approach\\nUsing Recursion\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^n*k)$$ --> k is average length of every subset\\n\\n- Space complexity:\\n$$O(2^n*k)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:    \\n    void subsetHelper(int idx, vector<int>& nums, int n, vector<int> &temp, vector<vector<int>>& ans) {\\n        if (idx == n) {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        temp.push_back(nums[idx]);\\n        subsetHelper(idx+1, nums, n, temp, ans);\\n        temp.pop_back();\\n        subsetHelper(idx+1, nums, n, temp, ans);\\n    }\\n\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        subsetHelper(0, nums, n, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    void subsetHelper(int idx, vector<int>& nums, int n, vector<int> &temp, vector<vector<int>>& ans) {\\n        if (idx == n) {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        temp.push_back(nums[idx]);\\n        subsetHelper(idx+1, nums, n, temp, ans);\\n        temp.pop_back();\\n        subsetHelper(idx+1, nums, n, temp, ans);\\n    }\\n\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        subsetHelper(0, nums, n, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432033,
                "title": "easy-python-solution-using-recursion",
                "content": "# Code\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        l=[]\\n        def subs(idx,tmp,lst,n,l):\\n            if idx>n:\\n                l.append(lst[:])\\n                return \\n            lst.append(tmp[idx])\\n            subs(idx+1,tmp,lst,n,l)\\n            lst.pop()\\n            subs(idx+1,tmp,lst,n,l)\\n            return \\n        lst=[]\\n        l=[]\\n        n=len(nums)-1\\n        subs(0,nums,lst,n,l)\\n        return sorted(l)\\n\\n       \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        l=[]\\n        def subs(idx,tmp,lst,n,l):\\n            if idx>n:\\n                l.append(lst[:])\\n                return \\n            lst.append(tmp[idx])\\n            subs(idx+1,tmp,lst,n,l)\\n            lst.pop()\\n            subs(idx+1,tmp,lst,n,l)\\n            return \\n        lst=[]\\n        l=[]\\n        n=len(nums)-1\\n        subs(0,nums,lst,n,l)\\n        return sorted(l)\\n\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939690,
                "title": "c-easy-to-understand-best-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void arrr(vector<vector<int>> &ans, int k) {\\n        vector<vector<int>> temp = ans;\\n        for (int i = 0; i < temp.size(); ++i) {\\n            temp[i].push_back(k);\\n            ans.push_back(temp[i]);\\n        }\\n    }\\n\\n    vector<vector<int>> subsets(vector<int>& n) {\\n        vector<vector<int>> ans;\\n        ans.push_back(vector<int>());\\n        for (int i = 0; i < n.size(); ++i) {\\n            arrr(ans, n[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void arrr(vector<vector<int>> &ans, int k) {\\n        vector<vector<int>> temp = ans;\\n        for (int i = 0; i < temp.size(); ++i) {\\n            temp[i].push_back(k);\\n            ans.push_back(temp[i]);\\n        }\\n    }\\n\\n    vector<vector<int>> subsets(vector<int>& n) {\\n        vector<vector<int>> ans;\\n        ans.push_back(vector<int>());\\n        for (int i = 0; i < n.size(); ++i) {\\n            arrr(ans, n[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630421,
                "title": "java-iterative-approach",
                "content": "```\\n        List<List<Integer>> ans=new ArrayList<>();\\n        ans.add(new ArrayList<Integer>());//[]\\n        \\n        for(int i=0;i<nums.length;i++){\\n            int n=ans.size();\\n            for(int j=0;j<n;j++){\\n                List<Integer> temp=new ArrayList(ans.get(j));\\n                temp.add(nums[i]);\\n                ans.add(temp);\\n            }\\n        }\\n       return ans; \\n",
                "solutionTags": [],
                "code": "```\\n        List<List<Integer>> ans=new ArrayList<>();\\n        ans.add(new ArrayList<Integer>());//[]\\n        \\n        for(int i=0;i<nums.length;i++){\\n            int n=ans.size();\\n            for(int j=0;j<n;j++){\\n                List<Integer> temp=new ArrayList(ans.get(j));\\n                temp.add(nums[i]);\\n                ans.add(temp);\\n            }\\n        }\\n       return ans; \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2331563,
                "title": "python-simple-backtracking-solution-clean-and-easy",
                "content": "**UPVOTE PLS :-)**\\n\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        ans=[]\\n        def backtrackMe(i,temp):\\n            if i==len(nums):\\n                ans.append(temp.copy())\\n                return\\n            else:\\n                backtrackMe(i+1,temp+[nums[i]])\\n                backtrackMe(i+1,temp)\\n        backtrackMe(0,[])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        ans=[]\\n        def backtrackMe(i,temp):\\n            if i==len(nums):\\n                ans.append(temp.copy())\\n                return\\n            else:\\n                backtrackMe(i+1,temp+[nums[i]])\\n                backtrackMe(i+1,temp)\\n        backtrackMe(0,[])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2301048,
                "title": "simple-js-solution-w-comments-bractracking",
                "content": "```\\n/**\\n * *Time: O(N x 2^N)\\n * *Space: O(N)\\n */\\n// Runtime: 112 ms, faster than 21.68% of JavaScript online submissions for Subsets.\\n// Memory Usage: 44.2 MB, less than 35.31% of JavaScript online submissions for Subsets.\\nconst subsets = nums => {\\n\\tconst output = [];\\n\\n\\tconst backtrack = (idx, subset) => {\\n\\t\\toutput.push([...subset]);\\n\\n    // for each of the current subset\\n    // recursively generate all possible subsets by increasing the position by one\\n\\t\\tfor (let i = idx; i < nums.length; i++) {\\n\\t\\t\\tsubset.push(nums[i]);\\n\\t\\t\\tbacktrack(i + 1, subset); // create next subset\\n\\t\\t\\tsubset.pop(); // backtrack\\n\\t\\t}\\n\\t};\\n\\n\\tbacktrack(0, []);\\n\\treturn output;\\n};\\n\\n// subset\\n// []\\n// [ 1 ]\\n// [ 1, 2 ]\\n// [ 1, 2, 3 ]\\n// [ 1, 3 ]\\n// [ 2 ]\\n// [ 2, 3 ]\\n// [ 3 ]\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * *Time: O(N x 2^N)\\n * *Space: O(N)\\n */\\n// Runtime: 112 ms, faster than 21.68% of JavaScript online submissions for Subsets.\\n// Memory Usage: 44.2 MB, less than 35.31% of JavaScript online submissions for Subsets.\\nconst subsets = nums => {\\n\\tconst output = [];\\n\\n\\tconst backtrack = (idx, subset) => {\\n\\t\\toutput.push([...subset]);\\n\\n    // for each of the current subset\\n    // recursively generate all possible subsets by increasing the position by one\\n\\t\\tfor (let i = idx; i < nums.length; i++) {\\n\\t\\t\\tsubset.push(nums[i]);\\n\\t\\t\\tbacktrack(i + 1, subset); // create next subset\\n\\t\\t\\tsubset.pop(); // backtrack\\n\\t\\t}\\n\\t};\\n\\n\\tbacktrack(0, []);\\n\\treturn output;\\n};\\n\\n// subset\\n// []\\n// [ 1 ]\\n// [ 1, 2 ]\\n// [ 1, 2, 3 ]\\n// [ 1, 3 ]\\n// [ 2 ]\\n// [ 2, 3 ]\\n// [ 3 ]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995496,
                "title": "easy-to-understand-python-recursion-solution",
                "content": "\\n\\n![image](https://assets.leetcode.com/users/images/88e79e57-7364-4dfa-a858-88c750d129ac_1651349284.1383734.png)\\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        \\n        def recursion(idx, currentSet):\\n            if idx == len(nums):\\n                results.append(currentSet)\\n                return\\n            \\n            #including the item at idx\\n            recursion(idx + 1, currentSet + [nums[idx]])\\n            #excluding the item at idx\\n            recursion(idx + 1, currentSet)\\n        \\n        results = []\\n        recursion(0,[])\\n        return results\\n```\\n\\nplease UPVOTE if you like \\uD83D\\uDE0A",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        \\n        def recursion(idx, currentSet):\\n            if idx == len(nums):\\n                results.append(currentSet)\\n                return\\n            \\n            #including the item at idx\\n            recursion(idx + 1, currentSet + [nums[idx]])\\n            #excluding the item at idx\\n            recursion(idx + 1, currentSet)\\n        \\n        results = []\\n        recursion(0,[])\\n        return results\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1858250,
                "title": "python-solutions-dp-bit-masking-recursion",
                "content": "# Method 1: using Dp.\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = [[]]\\n        for i in nums: res += [j+[i] for j in res]\\n        return res\\n# Method 2: using bit masking.\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res, n = [], len(nums)\\n        for i in range(1<<n):\\n            ans = []\\n            for j in range(n):\\n                if i & 1<<j: ans.append(nums[j])\\n            res.append(ans)\\n        return res\\n\\n# Method 3: using recursion.\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res, n = [], len(nums)\\n        def sub(i, l):\\n            if i == n:\\n                res.append(l)\\n                return\\n            sub(i + 1, l + [nums[i]])\\n            sub(i + 1, l)\\n        sub(0,[])\\n        return res\\n# please upvote if you like it!!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "# Method 1: using Dp.\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = [[]]\\n        for i in nums: res += [j+[i] for j in res]\\n        return res\\n# Method 2: using bit masking.\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res, n = [], len(nums)\\n        for i in range(1<<n):\\n            ans = []\\n            for j in range(n):\\n                if i & 1<<j: ans.append(nums[j])\\n            res.append(ans)\\n        return res\\n\\n# Method 3: using recursion.\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res, n = [], len(nums)\\n        def sub(i, l):\\n            if i == n:\\n                res.append(l)\\n                return\\n            sub(i + 1, l + [nums[i]])\\n            sub(i + 1, l)\\n        sub(0,[])\\n        return res\\n# please upvote if you like it!!",
                "codeTag": "Python3"
            },
            {
                "id": 1767767,
                "title": "c-simplest-short-solution-no-recursion-0-ms-faster-than-100",
                "content": "We start with a group that contains only the empty group.\\nThem, for each number in `nums`, we add it to all the previous groups.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res = {{}};\\n        vector<int> curr;\\n        int size;\\n        \\n        for (auto num : nums) {\\n            size = res.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                curr = res[i];\\n                curr.push_back(num);\\n                res.push_back(curr);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res = {{}};\\n        vector<int> curr;\\n        int size;\\n        \\n        for (auto num : nums) {\\n            size = res.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                curr = res[i];\\n                curr.push_back(num);\\n                res.push_back(curr);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767761,
                "title": "all-subsets-short-simple-8-lines-of-code-in-c-using-power-set",
                "content": "**Intuition :** Total number of subsets will be 2 to the power of `n` where n is the length of the given `nums` array. So if we find all the set bits for each positions for all the number between 0 to 2 to the power of `n`, we can replace the `nums[i]` (where i is the position of the number\\'s bit representation, if i th position is set bit or not) for each set bit positions consecutively. If we find that the i th position is set bit then we\\'ll put nums[i] in the postion and we\\'ll push back that into the resultant vector `res` and res vector into `ans`.\\n\\n**Note :** `1<<nums.size()` == `2 to the power of n` and `i & (1<<j)` with this we are checking if the jth position is set bit or not.\\n\\nIf you like this solution please upvote this THANKS **: )** \\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        \\n        for(int i=0; i<(1<<nums.size()); i++){\\n            vector<int> res;\\n            \\n            for(int j=0; j<nums.size(); j++){\\n                if(i & (1<<j))\\n                    res.push_back(nums[j]);\\n            }\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nIf you get any doubt  please comment down below...I\\'ll give my best to clear your doubtsb",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        \\n        for(int i=0; i<(1<<nums.size()); i++){\\n            vector<int> res;\\n            \\n            for(int j=0; j<nums.size(); j++){\\n                if(i & (1<<j))\\n                    res.push_back(nums[j]);\\n            }\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603493,
                "title": "rust-fast-100",
                "content": "```\\nimpl Solution {\\n    pub fn subsets(mut nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        if nums.len() == 0{\\n            return vec![vec![]];\\n        }\\n        let last = nums.pop().unwrap();\\n        let remain_subsets = Self::subsets(nums);\\n        let mut res = remain_subsets.clone();\\n        for mut v in remain_subsets{\\n            v.push(last);\\n            res.push(v);\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn subsets(mut nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        if nums.len() == 0{\\n            return vec![vec![]];\\n        }\\n        let last = nums.pop().unwrap();\\n        let remain_subsets = Self::subsets(nums);\\n        let mut res = remain_subsets.clone();\\n        for mut v in remain_subsets{\\n            v.push(last);\\n            res.push(v);\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 899942,
                "title": "simple-recursive-scala",
                "content": "```scala\\nobject Solution {\\n  def subsets(nums: Array[Int]): List[List[Int]] = {\\n    @annotation.tailrec\\n    def go(as: List[Int], acc: List[List[Int]]): List[List[Int]] = {\\n      as match {\\n        case Nil => acc\\n        case h::t => go(t, acc ::: acc.map(_.appended(h)))\\n      }\\n    }\\n\\n    go(nums.toList, List(List()))\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```scala\\nobject Solution {\\n  def subsets(nums: Array[Int]): List[List[Int]] = {\\n    @annotation.tailrec\\n    def go(as: List[Int], acc: List[List[Int]]): List[List[Int]] = {\\n      as match {\\n        case Nil => acc\\n        case h::t => go(t, acc ::: acc.map(_.appended(h)))\\n      }\\n    }\\n\\n    go(nums.toList, List(List()))\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 852038,
                "title": "simple-cpp-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>nums,vector<int>op,vector<vector<int>>& v)\\n    {  if(nums.size()==0)\\n        {   v.push_back(op);\\n            return;\\n        }\\n        vector<int>op1;\\n        vector<int>op2;\\n        for(int i=0;i<op.size();i++)\\n        {   op1.push_back(op[i]);\\n            op2.push_back(op[i]);\\n        }\\n        op2.push_back(nums[0]);\\n        vector<int>::iterator it;\\n        it=nums.begin();\\n        nums.erase(it);\\n        solve(nums,op1,v);\\n        solve(nums,op2,v);\\n        return;\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>>v;\\n        vector<int>op;\\n        solve(nums,op,v);\\n        return v;\\n    }\\n};\\n```\\nFor understanding the concept behind this solution check this-\\nhttps://www.youtube.com/watch?v=Yg5a2FxU4Fo&list=PL_z_8CaSLPWeT1ffjiImo0sYTcnLzo-wY&index=12",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>nums,vector<int>op,vector<vector<int>>& v)\\n    {  if(nums.size()==0)\\n        {   v.push_back(op);\\n            return;\\n        }\\n        vector<int>op1;\\n        vector<int>op2;\\n        for(int i=0;i<op.size();i++)\\n        {   op1.push_back(op[i]);\\n            op2.push_back(op[i]);\\n        }\\n        op2.push_back(nums[0]);\\n        vector<int>::iterator it;\\n        it=nums.begin();\\n        nums.erase(it);\\n        solve(nums,op1,v);\\n        solve(nums,op2,v);\\n        return;\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>>v;\\n        vector<int>op;\\n        solve(nums,op,v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 730432,
                "title": "swift-8ms-solution",
                "content": "```\\nfinal class Solution {\\n    func subsets(_ nums: [Int]) -> [[Int]] {\\n        var arrayVales = [[Int]]()\\n        arrayVales.append([])\\n        for num in nums {\\n            for val in arrayVales {\\n                var valUpdate = val\\n                valUpdate.append(num)\\n                arrayVales.append(valUpdate)\\n            }\\n        }\\n        return arrayVales\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfinal class Solution {\\n    func subsets(_ nums: [Int]) -> [[Int]] {\\n        var arrayVales = [[Int]]()\\n        arrayVales.append([])\\n        for num in nums {\\n            for val in arrayVales {\\n                var valUpdate = val\\n                valUpdate.append(num)\\n                arrayVales.append(valUpdate)\\n            }\\n        }\\n        return arrayVales\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729871,
                "title": "java-bitmask-solution",
                "content": "Explanation: In order to generate every subset, we decide wether or not to put an element of the array. Using combinatorics, the number of different subsets is `2^(num_of_elements)`, because for every element, we put it or not.\\n\\nInterestingly, if we take the binary representation of all the numbers from zero up to `2^(num_of_elements) - 1`, we can use the bits of those numbers to decide wether or not to put the corresponding number from the array. Notice that, starting from zero and going up to `2^(num_of_elements) - 1`, there are `2^(num_of_elements)` different values.\\n\\nIt works like this. Suppose your array has 5 elements. We then start from `0` and go up to `(2^5) - 1`. Using the describe approach, we then start with a bitmask containing `00000`. If a bit is zero it means `do not put the element at the correspoding bit position on the subset` and 1 means `put it on the subset`. For the first number, we have the empty subset. We then add one to our bitmask, resulting in `00001`, meaning we now have a subset with the first element only. The next one would be `00010`, and the next `00011`, and so on. This way we generate all the possible subsets. The last bitmask has all the ones set (`11111`).\\n\\n**Remarks**\\n- Why `2^(num_of_elements) - 1` ? When doing, for example, `2^5` you will have `100000`, if you do `-1` on that you will have `11111`.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        int total = (int)Math.pow(2,nums.length)-1;\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n\\t\\t//for every bitmask\\n        for(int i = 0; i <= total; i++) {\\n\\t\\t\\n            List<Integer> set = new ArrayList<Integer>();\\n\\t\\t\\t//for every element in the array\\n            for(int j = 0; j < nums.length; j++) {\\n\\t\\t\\t\\t//if the corresponding bit is set on the bitmask\\n                if ( ((i>>j)&1) == 1) set.add(nums[j]);\\n            }\\n\\t\\t\\t\\n            ans.add(set);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        int total = (int)Math.pow(2,nums.length)-1;\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n\\t\\t//for every bitmask\\n        for(int i = 0; i <= total; i++) {\\n\\t\\t\\n            List<Integer> set = new ArrayList<Integer>();\\n\\t\\t\\t//for every element in the array\\n            for(int j = 0; j < nums.length; j++) {\\n\\t\\t\\t\\t//if the corresponding bit is set on the bitmask\\n                if ( ((i>>j)&1) == 1) set.add(nums[j]);\\n            }\\n\\t\\t\\t\\n            ans.add(set);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707102,
                "title": "python-short-10-lines-with-complete-explanation",
                "content": "n is the length of the array.A subset is represented by a binarynumber of n bits.Each bit represents whether the number of that index exists in the subset or not.And the numbers that has this binary representation are [0,2^n-1] Now,we need to obtain the bits that are one\\'s in every number.\\n```Eg: input array = [4,7,6]\\n\\tExplanation:\\n\\tsubsets =[ ] [4] [7] [6] [4,7] [4,6]  [7,6] [4,7,6]\\n\\tThere are 3 numbers in the array i.e n = 3\\n\\tTherefore, no of subsets = 2^n = 2^3 = 8\\n\\tEach subset can be represented by a number in [0,2^n -1] i.e [0,1,2,3,4,5,6,7]\\n\\tbinary rep of 7 = \\'111\\'  => [4, 7, 6]\\n\\tbinary rep of 6 = \\'110\\'  => [4, 7   ]\\n\\tbinary rep of 5 = \\'101\\'  => [4,   ,6]\\n\\tbinary rep of 4 = \\'100\\'  => [4,      ]\\n\\t...... binary rep of 0 =\\'000\\' =>[ ]  i.e null set. \\n\\tSo,The idea is to represent [0,2^n -1] numbers in n-bit binary.\\n\\tFor each such number,find the subset by parsing the set-bits of binary number.\\n``` \\nNow, into the code. `Time:O(2^n),SpaceO(2^n)`\\n    \\n\\t\\t```python\\t\\n\\t\\tclass Solution:\\n\\t\\t\\tdef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\trightEnd = 2**n\\n\\t\\t\\tres = []\\n\\t\\t\\tfor number in range(rightEnd):\\n\\t\\t\\t\\tans = []\\n\\t\\t\\t\\tfor bit in range(n):\\n\\t\\t\\t\\t\\tif 1<<bit & number:\\n\\t\\t\\t\\t\\t\\tans.append(nums[bit])\\n\\t\\t\\t\\tres.append(ans)\\n\\t\\t\\treturn res\\n\\t\\t\\t```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```Eg: input array = [4,7,6]\\n\\tExplanation:\\n\\tsubsets =[ ] [4] [7] [6] [4,7] [4,6]  [7,6] [4,7,6]\\n\\tThere are 3 numbers in the array i.e n = 3\\n\\tTherefore, no of subsets = 2^n = 2^3 = 8\\n\\tEach subset can be represented by a number in [0,2^n -1] i.e [0,1,2,3,4,5,6,7]\\n\\tbinary rep of 7 = \\'111\\'  => [4, 7, 6]\\n\\tbinary rep of 6 = \\'110\\'  => [4, 7   ]\\n\\tbinary rep of 5 = \\'101\\'  => [4,   ,6]\\n\\tbinary rep of 4 = \\'100\\'  => [4,      ]\\n\\t...... binary rep of 0 =\\'000\\' =>[ ]  i.e null set. \\n\\tSo,The idea is to represent [0,2^n -1] numbers in n-bit binary.\\n\\tFor each such number,find the subset by parsing the set-bits of binary number.\\n```\n```python\\t\\n\\t\\tclass Solution:\\n\\t\\t\\tdef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\trightEnd = 2**n\\n\\t\\t\\tres = []\\n\\t\\t\\tfor number in range(rightEnd):\\n\\t\\t\\t\\tans = []\\n\\t\\t\\t\\tfor bit in range(n):\\n\\t\\t\\t\\t\\tif 1<<bit & number:\\n\\t\\t\\t\\t\\t\\tans.append(nums[bit])\\n\\t\\t\\t\\tres.append(ans)\\n\\t\\t\\treturn res\\n\\t\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 364179,
                "title": "python-iterative-backtracking-with-detail-explanation-and-deep-copy-problem",
                "content": "**Iterative Approach**\\nThe ituition is that when we have a subset of itmes a[0] to a[k-1] (we name this subset S(k-1)) what we could do to obtain the subset of a[0] to a[k] (S(k)).\\nSince for new item a[k], the subset of a[0] to a[k] could eigher contain a[k] or not. And when it not caintain a[k], this part of subset becomes S(k-1). when it caintains a[k], we could just add a[k] to all the subset of a[0] to a[k-1]. So we could write down the following fomula:\\nS(k) = S(k-1) + S(k-1)Ua[k]\\nthen we could write down the following codes:\\n```\\nclass Solution:\\n    def subsets(self, nums):\\n        res = [[]]\\n        for num in nums:\\n            res = res + [s+[num] for s in res]\\n        return res\\n```\\ntime analysis:\\n* we iterate over all the element in nums. For each element a[i], we iterate all the subset of a[0] to a[i-1]. So every step the time complexity if O(|S(i-1)|)\\n* according to the S(k) = S(k-1) + S(k-1)Ua[k], we could know that the |S(k)| (which is the number of subset of a[0] to a[k]) have the relationship: |S(k)| = 2|S(k-1)| =...=2^k|S(0)|=O(2^k)\\n* so the total time complexity would be O(1)+O(2)+...+O(2^n)=O(2^n)\\nspace complexity:\\n* since we only use res to store results, so it\\'s O(2^n)\\n\\n**Backtracking**\\nSince it\\'s hard to decide what is the subset of n items, we could try to the  break big one to some smaller problems. For k items, we could decide whether or not to include the first one in k items. Then the problem becomes for k-1 items what is their subset. After obtaining k-1\\'s subsets, we know that the subsets of k-1 items are also subsets of k items for the reason that k items include k-1 items. And we could also add the first one in k items to all the subsets of k-1\\'s subsets. So the algorithm becomes:\\n* when the nums equals zero, it means there is zero elements to work. We have chosen all the elements in the subsets, we could append them in the result and return.\\n* choose not to include nums[0] in the subsets and explore all the subsets of nums[1:]\\n* choose to include nums[0] in the subsets and explore all the subsets of nums[1:]. So the choose becomes choose+nums[0]\\n*  unchoose nums[0] so when backtrack to the uppper level, so, we donot let chosen array grow without control\\n```\\nimport copy\\nclass Solution:\\n    def subsets(self, nums):\\n        N = len(nums)\\n        res = []\\n        def helper(nums, chosen):\\n            if nums == []:\\n                res.append(copy.deepcopy(chosen))\\n                return\\n\\t\\t\\t#choose & explore\\n            helper(nums[1:], chosen)\\n\\t\\t\\t#choose & explore\\n            chosen.append(nums[0])\\n            helper(nums[1:], chosen)\\n\\t\\t\\t#unchoose\\n            chosen.pop()\\n            return\\n        helper(nums, [])\\n        return res\\n```\\n**Deep copy problem!**\\nI try to use `res.append(chosen)` in the first time, but find ou the output is very wired!! If you try the code without use of deepcopy then you would find that every time you change chosen, the res also changes. This is because how python pass parameters and the effect of shallow copy. After appending chosen, res[-1] and chosen reference points to the same memory location. As a result even since you append chosen to res, every time you modify chosen, you also change the element in res.\\nBTW, I am also wondering if it is okay to work on the results in the base case. We could also modify the method so it returns the subsets. I am not sure which one is better.\\n\\nIf there is anything confusing or misleading, please comment below. I would try my best to clarify.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums):\\n        res = [[]]\\n        for num in nums:\\n            res = res + [s+[num] for s in res]\\n        return res\\n```\n```\\nimport copy\\nclass Solution:\\n    def subsets(self, nums):\\n        N = len(nums)\\n        res = []\\n        def helper(nums, chosen):\\n            if nums == []:\\n                res.append(copy.deepcopy(chosen))\\n                return\\n\\t\\t\\t#choose & explore\\n            helper(nums[1:], chosen)\\n\\t\\t\\t#choose & explore\\n            chosen.append(nums[0])\\n            helper(nums[1:], chosen)\\n\\t\\t\\t#unchoose\\n            chosen.pop()\\n            return\\n        helper(nums, [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 351704,
                "title": "javascript-recursive",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar subsets = function(nums) {\\n    let res = [];\\n    const helper = (nums, i, arr) => {\\n        if(i === nums.length) {\\n            res.push(arr);\\n            return;\\n        }\\n        helper(nums, i+1, arr);\\n        helper(nums, i+1, arr.concat(nums[i]));\\n    };\\n    helper(nums, 0, []);\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar subsets = function(nums) {\\n    let res = [];\\n    const helper = (nums, i, arr) => {\\n        if(i === nums.length) {\\n            res.push(arr);\\n            return;\\n        }\\n        helper(nums, i+1, arr);\\n        helper(nums, i+1, arr.concat(nums[i]));\\n    };\\n    helper(nums, 0, []);\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 310034,
                "title": "simple-python-dfs-solutions-for-similar-backtrack-problems",
                "content": "Please see and vote for my simple solutions for\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 277064,
                "title": "bfs-to-generate-subset",
                "content": "Recursion is my favorite solution. However, the interviewer might ask non-recursion solution. In this case, BFS could be helpful. \\n\\nImagine sub-set generation as an implicit binary tree, where the node is a set A, and its 2 children are A + [x] and A + []. \\n\\nDo a level order BFS, and stop at `level == len(nums)`\\n\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        from collections import deque\\n        \\n        qu = deque([[]])\\n        \\n        i = 0\\n        while qu and i < len(nums):\\n            N = len(qu)\\n            \\n            for _ in range(N):\\n                lst = qu.popleft()\\n                \\n                qu.append(lst[:])\\n                qu.append(lst + [nums[i]])\\n            \\n            \\n            i += 1\\n            \\n        return list(qu)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        from collections import deque\\n        \\n        qu = deque([[]])\\n        \\n        i = 0\\n        while qu and i < len(nums):\\n            N = len(qu)\\n            \\n            for _ in range(N):\\n                lst = qu.popleft()\\n                \\n                qu.append(lst[:])\\n                qu.append(lst + [nums[i]])\\n            \\n            \\n            i += 1\\n            \\n        return list(qu)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 231695,
                "title": "why-everybody-overthink-it-just-simple-recursion-beats-100-c",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> Subsets(int[] nums) {\\n        return helper(nums, new List<IList<int>>(), 0);\\n    }\\n    \\n    public IList<IList<int>> helper(int[] nums, IList<IList<int>> ans, int index)\\n    {\\n        if(index == 0) ans.Add(new List<int>());\\n        if(index == nums.Length) return ans;\\n        int precount = ans.Count;\\n        for(int i = 0; i < precount; i++)\\n        {\\n            IList<int> cur = new List<int>(ans[i]);\\n            cur.Add(nums[index]);\\n            ans.Add(cur);\\n        }\\n        return helper(nums, ans, index + 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> Subsets(int[] nums) {\\n        return helper(nums, new List<IList<int>>(), 0);\\n    }\\n    \\n    public IList<IList<int>> helper(int[] nums, IList<IList<int>> ans, int index)\\n    {\\n        if(index == 0) ans.Add(new List<int>());\\n        if(index == nums.Length) return ans;\\n        int precount = ans.Count;\\n        for(int i = 0; i < precount; i++)\\n        {\\n            IList<int> cur = new List<int>(ans[i]);\\n            cur.Add(nums[index]);\\n            ans.Add(cur);\\n        }\\n        return helper(nums, ans, index + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197551,
                "title": "simple-javascript-recursive-solution-inspired-by-sicp-exercise-2-32",
                "content": "```\\nfunction subsets(s) {\\n    if (s.length === 0) {\\n        return [[]]\\n    } else {\\n        let rest = subsets(s.slice(1))  \\n        let newSets = rest.map(         \\n            (set) => [s[0], ...set]\\n        )\\n        return [...rest, ...newSets]    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunction subsets(s) {\\n    if (s.length === 0) {\\n        return [[]]\\n    } else {\\n        let rest = subsets(s.slice(1))  \\n        let newSets = rest.map(         \\n            (set) => [s[0], ...set]\\n        )\\n        return [...rest, ...newSets]    \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 172300,
                "title": "java-a-dp-solution",
                "content": "```\npublic List<List<Integer>> subsets( int[] nums ) {\n        List<List<Integer>> res = new ArrayList<>();\n        List<Integer> emptySubset = new ArrayList<>(); // 每个集合都有的 空子集\n        res.add(emptySubset);\n\n        for (int i = 0; i < nums.length; i++) {\n            // 遍历元素，将元素依次加进res的每个子集末尾，形成一个新子集；\n            int length = res.size();\n            for (int j = 0; j < length; j++) {\n                List<Integer> newSubset = new ArrayList<>(res.get(j));\n                newSubset.add(nums[i]);\n                res.add(newSubset);\n            }\n        }\n        return res;\n    }\n```",
                "solutionTags": [],
                "code": "```\npublic List<List<Integer>> subsets( int[] nums ) {\n        List<List<Integer>> res = new ArrayList<>();\n        List<Integer> emptySubset = new ArrayList<>(); // 每个集合都有的 空子集\n        res.add(emptySubset);\n\n        for (int i = 0; i < nums.length; i++) {\n            // 遍历元素，将元素依次加进res的每个子集末尾，形成一个新子集；\n            int length = res.size();\n            for (int j = 0; j < length; j++) {\n                List<Integer> newSubset = new ArrayList<>(res.get(j));\n                newSubset.add(nums[i]);\n                res.add(newSubset);\n            }\n        }\n        return res;\n    }\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 142650,
                "title": "a-c-0ms-solution-with-annotation",
                "content": "```\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *columnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** subsets(int* nums, int numsSize, int** columnSizes, int* returnSize) {\\n        *returnSize = 1 << numsSize;                                    // Power set of S always has 2^|S| elements\\n\\n        /* Allocating memory dynamically */\\n        int** rv = malloc(sizeof(*rv) * *returnSize);                   // Returned array of arrays\\n        *columnSizes = malloc(sizeof(**columnSizes) * *returnSize);     // columnSizes output\\n        \\n        for (int i = 0; i < *returnSize; ++i) {\\n                \\n                /* popcount is an x86 instruction which returns the number of 1 bits in a register */\\n                /* GCC compiler supports a similar instruction, regardless of platform */\\n                (*columnSizes)[i] = __builtin_popcount(i);              // Let client know length of array\\n\\n                rv[i] = malloc(sizeof(*(rv[i])) * (*columnSizes)[i]);   // Allocate array\\n\\n                int rvi_idx = 0;                                        // Index into newly allocated rv[i] array\\n                \\n                /* Each of the first numsSize bits of `i` is associated with an integer in nums */\\n                for (int idx = 0; idx < numsSize; ++idx) {\\n                        if ((1 << idx) & i) {\\n                                /* If the idx\\'th bit of `i` is 1, then we add the idx\\'th num to rv[i] */\\n                                rv[i][rvi_idx++] = nums[idx];\\n                        }\\n                }\\n        }\\n        return rv;\\n        \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *columnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** subsets(int* nums, int numsSize, int** columnSizes, int* returnSize) {\\n        *returnSize = 1 << numsSize;                                    // Power set of S always has 2^|S| elements\\n\\n        /* Allocating memory dynamically */\\n        int** rv = malloc(sizeof(*rv) * *returnSize);                   // Returned array of arrays\\n        *columnSizes = malloc(sizeof(**columnSizes) * *returnSize);     // columnSizes output\\n        \\n        for (int i = 0; i < *returnSize; ++i) {\\n                \\n                /* popcount is an x86 instruction which returns the number of 1 bits in a register */\\n                /* GCC compiler supports a similar instruction, regardless of platform */\\n                (*columnSizes)[i] = __builtin_popcount(i);              // Let client know length of array\\n\\n                rv[i] = malloc(sizeof(*(rv[i])) * (*columnSizes)[i]);   // Allocate array\\n\\n                int rvi_idx = 0;                                        // Index into newly allocated rv[i] array\\n                \\n                /* Each of the first numsSize bits of `i` is associated with an integer in nums */\\n                for (int idx = 0; idx < numsSize; ++idx) {\\n                        if ((1 << idx) & i) {\\n                                /* If the idx\\'th bit of `i` is 1, then we add the idx\\'th num to rv[i] */\\n                                rv[i][rvi_idx++] = nums[idx];\\n                        }\\n                }\\n        }\\n        return rv;\\n        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 27456,
                "title": "python-solution-inspired-by-prime-products",
                "content": "Python solution, similar to Prime Products and all kinds of num combination problems:\\n\\nReference: http://sahandsaba.com/interview-question-facebook-primes.html \\n\\n       class Solution:\\n            # @param S, a list of integer\\n            # @return a list of lists of integer\\n            def subsets(self, S):\\n                # Base result\\n                result = [[]]\\n                for num in S:\\n                    for element in result[:]:\\n                        x=element[:]\\n                        x.append(num)\\n                        result.append(x)\\n                return result",
                "solutionTags": [],
                "code": "Python solution, similar to Prime Products and all kinds of num combination problems:\\n\\nReference: http://sahandsaba.com/interview-question-facebook-primes.html \\n\\n       class Solution:\\n            # @param S, a list of integer\\n            # @return a list of lists of integer\\n            def subsets(self, S):\\n                # Base result\\n                result = [[]]\\n                for num in S:\\n                    for element in result[:]:\\n                        x=element[:]\\n                        x.append(num)\\n                        result.append(x)\\n                return result",
                "codeTag": "Java"
            },
            {
                "id": 27583,
                "title": "simple-backtracking-minimal-copying-16ms",
                "content": "Simply back-track, try both choosing the value at the given index or skipping it. \\n\\n    public:\\n        void op(const vector<int>& S, int idx){\\n            if(idx >= S.size()){\\n                mRes.push_back(mVec);\\n                return;\\n            }\\n            \\n            mVec.push_back(S[idx]);\\n            op(S, idx + 1);\\n            mVec.pop_back();\\n            op(S, idx + 1);\\n        }\\n    \\n        vector<vector<int> > subsets(vector<int> &S) {\\n            sort(S.begin(), S.end());\\n            op(S, 0);\\n            return mRes;\\n        }\\n    \\n    private:\\n        vector<int> mVec;\\n        vector< vector<int> > mRes;",
                "solutionTags": [
                    "C++"
                ],
                "code": "Simply back-track, try both choosing the value at the given index or skipping it. \\n\\n    public:\\n        void op(const vector<int>& S, int idx){\\n            if(idx >= S.size()){\\n                mRes.push_back(mVec);\\n                return;\\n            }\\n            \\n            mVec.push_back(S[idx]);\\n            op(S, idx + 1);\\n            mVec.pop_back();\\n            op(S, idx + 1);\\n        }\\n    \\n        vector<vector<int> > subsets(vector<int> &S) {\\n            sort(S.begin(), S.end());\\n            op(S, 0);\\n            return mRes;\\n        }\\n    \\n    private:\\n        vector<int> mVec;\\n        vector< vector<int> > mRes;",
                "codeTag": "Unknown"
            },
            {
                "id": 27649,
                "title": "accepted-java-solution-dfs",
                "content": "Basic idea is: \\n\\n1. sort the array\\n2. start from the end of the array, for each element, do recursive call to get subset for element 'n-1'.  \\n3. Once get all sebset for n-1, then your subset for n will be :  Subset(n)= Subset(n-1)+(n itself) +(add n to Subset(n-1))\\n4. at last, don't forget to add [] , from OJ, it counts as one subset as well.\\n\\n \\n\\n      public class Solution {\\n    \\n        public List <List <Integer>> subsets (int[] S) {\\n            if (S == null)\\n                return null;\\n            Arrays.sort (S);\\n            List <List <Integer>> result = new ArrayList <List <Integer>> ();\\n            result = getSubSet (S, S.length - 1);\\n            result.add (new ArrayList <Integer> ());\\n            return result;\\n        }\\n    \\n        List <List <Integer>> getSubSet (int[] s, int index) {\\n            List <List <Integer>> result = new ArrayList <List <Integer>> ();\\n            if (index < 0) {\\n                return result;\\n            }\\n            List <List <Integer>> subResult = getSubSet (s, index - 1);\\n            result.addAll (subResult);\\n            for (int i = 0; i < subResult.size (); i++) {\\n                List <Integer> bList = new ArrayList <> ();\\n                bList.addAll (subResult.get (i));\\n                bList.add (s[index]);\\n                result.add (bList);\\n            }\\n            result.add (Arrays.asList (s[index]));\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\n        public List <List <Integer>> subsets (int[] S) {\\n            if (S == null)\\n                return null;\\n            Arrays.sort (S);\\n            List <List <Integer>> result = new ArrayList <List <Integer>> ();\\n            result = getSubSet (S, S.length - 1);\\n            result.add (new ArrayList <Integer> ());\\n            return result;\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1804734,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1575501,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1566209,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1926509,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1570208,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1568898,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1567345,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1575771,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 2014481,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1936905,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1804734,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1575501,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1566209,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1926509,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1570208,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1568898,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1567345,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1575771,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 2014481,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1936905,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1935017,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 1758105,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 1715583,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 1572036,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 1571182,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 2060599,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 2026476,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 2013160,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 2006087,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 1951263,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 1936909,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            },
            {
                "id": 1911128,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            },
            {
                "id": 1808352,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            },
            {
                "id": 1800858,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            },
            {
                "id": 1781924,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            },
            {
                "id": 1776381,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            },
            {
                "id": 1767466,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            },
            {
                "id": 1754131,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            },
            {
                "id": 1739549,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            },
            {
                "id": 1733505,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            }
        ]
    },
    {
        "title": "Rank Scores",
        "question_content": "<p>Table: <code>Scores</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| score       | decimal |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table contains the score of a game. Score is a floating point value with two decimal places.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find the rank of the scores. The ranking should be calculated according to the following rules:</p>\n\n<ul>\n\t<li>The scores should be ranked from the highest to the lowest.</li>\n\t<li>If there is a tie between two scores, both should have the same ranking.</li>\n\t<li>After a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no holes between ranks.</li>\n</ul>\n\n<p>Return the result table ordered by <code>score</code> in descending order.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nScores table:\n+----+-------+\n| id | score |\n+----+-------+\n| 1  | 3.50  |\n| 2  | 3.65  |\n| 3  | 4.00  |\n| 4  | 3.85  |\n| 5  | 4.00  |\n| 6  | 3.65  |\n+----+-------+\n<strong>Output:</strong> \n+-------+------+\n| score | rank |\n+-------+------+\n| 4.00  | 1    |\n| 4.00  | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.50  | 4    |\n+-------+------+\n</pre>\n",
        "solutions": [
            {
                "id": 53094,
                "title": "simple-short-fast",
                "content": "These are four different solutions.\\n\\n---\\n**With Variables:** 841 ms\\n\\nFirst one uses two variables, one for the current rank and one for the previous score.\\n\\n    SELECT\\n      Score,\\n      @rank := @rank + (@prev <> (@prev := Score)) Rank\\n    FROM\\n      Scores,\\n      (SELECT @rank := 0, @prev := -1) init\\n    ORDER BY Score desc\\n\\n---\\n\\n**Always Count:** 1322 ms\\n\\nThis one counts, for each score, the number of distinct greater or equal scores.\\n\\n    SELECT\\n      Score,\\n      (SELECT count(distinct Score) FROM Scores WHERE Score >= s.Score) Rank\\n    FROM Scores s\\n    ORDER BY Score desc\\n\\n---\\n\\n**Always Count, Pre-uniqued:** 795 ms\\n\\nSame as the previous one, but faster because I have a subquery that \"uniquifies\" the scores first. Not entirely sure *why* it's faster, I'm guessing MySQL makes `tmp` a temporary table and uses it for every outer Score.\\n\\n    SELECT\\n      Score,\\n      (SELECT count(*) FROM (SELECT distinct Score s FROM Scores) tmp WHERE s >= Score) Rank\\n    FROM Scores\\n    ORDER BY Score desc\\n\\n---\\n\\n**Filter/count Scores^2:** 1414 ms\\n\\nInspired by the attempt in wangkan2001's answer. Finally `Id` is good for something :-)\\n\\n    SELECT s.Score, count(distinct t.score) Rank\\n    FROM Scores s JOIN Scores t ON s.Score <= t.score\\n    GROUP BY s.Id\\n    ORDER BY s.Score desc",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "These are four different solutions.\\n\\n---\\n**With Variables:** 841 ms\\n\\nFirst one uses two variables, one for the current rank and one for the previous score.\\n\\n    SELECT\\n      Score,\\n      @rank := @rank + (@prev <> (@prev := Score)) Rank\\n    FROM\\n      Scores,\\n      (SELECT @rank := 0, @prev := -1) init\\n    ORDER BY Score desc\\n\\n---\\n\\n**Always Count:** 1322 ms\\n\\nThis one counts, for each score, the number of distinct greater or equal scores.\\n\\n    SELECT\\n      Score,\\n      (SELECT count(distinct Score) FROM Scores WHERE Score >= s.Score) Rank\\n    FROM Scores s\\n    ORDER BY Score desc\\n\\n---\\n\\n**Always Count, Pre-uniqued:** 795 ms\\n\\nSame as the previous one, but faster because I have a subquery that \"uniquifies\" the scores first. Not entirely sure *why* it's faster, I'm guessing MySQL makes `tmp` a temporary table and uses it for every outer Score.\\n\\n    SELECT\\n      Score,\\n      (SELECT count(*) FROM (SELECT distinct Score s FROM Scores) tmp WHERE s >= Score) Rank\\n    FROM Scores\\n    ORDER BY Score desc\\n\\n---\\n\\n**Filter/count Scores^2:** 1414 ms\\n\\nInspired by the attempt in wangkan2001's answer. Finally `Id` is good for something :-)\\n\\n    SELECT s.Score, count(distinct t.score) Rank\\n    FROM Scores s JOIN Scores t ON s.Score <= t.score\\n    GROUP BY s.Id\\n    ORDER BY s.Score desc",
                "codeTag": "Unknown"
            },
            {
                "id": 456610,
                "title": "mysql-two-simple-solutions-and-explanations-for-beginners",
                "content": "# **1. MySQL Solution: (777ms)**\\n```\\nSELECT S.Score, COUNT(S2.Score) AS Rank FROM Scores S,\\n(SELECT DISTINCT Score FROM Scores) S2\\nWHERE S.Score<=S2.Score\\nGROUP BY S.Id \\nORDER BY S.Score DESC;\\n```\\n![image](https://assets.leetcode.com/users/sophiesu0827/image_1576871668.png)\\n\\n\\n\\n\\n# **2. Optional MySQL solution using Variables: (397ms)**\\n```\\nSELECT Score, convert(Rank,SIGNED) AS Rank FROM\\n    (SELECT Score, @rank:=CASE WHEN Score=@previous THEN @rank ELSE @rank+1 END AS Rank, @previous:=Score FROM Scores,\\n        (SELECT @previous:=-1,@rank:=0) AS initial\\n    ORDER BY Score DESC) A;  \\n```\\n**Intuition:** \\nFirst we sort the table by descending scores. We check each score to see if it is equal to or lower than the previous score. If equal, keep the same rank; If lower, increase the rank by 1.\\n\\n**Yes! We\\'ve found that using Variables would save half of the running time.**\\n",
                "solutionTags": [],
                "code": "```\\nSELECT S.Score, COUNT(S2.Score) AS Rank FROM Scores S,\\n(SELECT DISTINCT Score FROM Scores) S2\\nWHERE S.Score<=S2.Score\\nGROUP BY S.Id \\nORDER BY S.Score DESC;\\n```\n```\\nSELECT Score, convert(Rank,SIGNED) AS Rank FROM\\n    (SELECT Score, @rank:=CASE WHEN Score=@previous THEN @rank ELSE @rank+1 END AS Rank, @previous:=Score FROM Scores,\\n        (SELECT @previous:=-1,@rank:=0) AS initial\\n    ORDER BY Score DESC) A;  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 218193,
                "title": "dense-rank-sql-server-604-ms",
                "content": "Hello,\\n\\nI am not sure why I have not come across a solution using DENSE_RANK() since it\\'s made for exactly this purpose. Please do let me know if the goal of the question is to arrive at a solution without using DENSE_RANK().\\n\\nNOTE : I am using MS SQL SERVER and not MySQL. It accepts my solution.\\n\\nHere is my solution :\\n\\n```\\nSELECT s.Score as Score,\\nDENSE_RANK() OVER (ORDER BY s.Score DESC) as Rank\\nFROM Scores s\\n\\n```\\n\\nit does exactly what the question asks us to do. If you want ranks with gaps, we can use RANK() instead of DENSE_RANK()",
                "solutionTags": [],
                "code": "```\\nSELECT s.Score as Score,\\nDENSE_RANK() OVER (ORDER BY s.Score DESC) as Rank\\nFROM Scores s\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3861595,
                "title": "pandas-simple-2-step-approach-additional-knowledge-at-the-end",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Use the rank method with method=\\'dense\\' to assign ranks to the scores in descending order while handling ties. Add a new column \\'rank\\' to the scores DataFrame to store the ranks.\\n2. Sort the DataFrame by score in descending order. This can be achieved using the sort_values method.\\n\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    # Use the rank method to assign ranks to the scores in descending order with no gaps\\n    scores[\\'rank\\'] = scores[\\'score\\'].rank(method=\\'dense\\', ascending=False)\\n    \\n    # Drop id column & Sort the DataFrame by score in descending order\\n    result_df = scores.drop(\\'id\\',axis=1).sort_values(by=\\'score\\', ascending=False)\\n    \\n    return result_df\\n```\\n\\n# Additional Knowledge \\uD83E\\uDD29\\nThe Approach is super simple if we know about the rank method and method = \\'dense\\', but we should not stop here for this question let\\'s explore and increase our knowledge.\\n\\nwhat are other available options like dense? \\uD83E\\uDD14\\nIn Pandas\\' rank method, there are several options available for the method parameter to handle ties when assigning ranks. Here are the available options:\\n\\n**\\'average\\' (default):** This method assigns the average rank to tied elements. For example, if two elements tie for the second rank, they both get the rank of 2.5, and the next rank will be 4.\\n\\n**\\'min\\':** This method assigns the minimum rank to tied elements. For example, if two elements tie for the second rank, they both get the rank of 2, and the next rank will be 4.\\n\\n**\\'max\\':** This method assigns the maximum rank to tied elements. For example, if two elements tie for the second rank, they both get the rank of 3, and the next rank will be 4.\\n\\n**\\'first\\':** This method assigns ranks in the order they appear in the input data, without using any average or other calculations for ties. For example, if two elements tie for the second rank, the first element gets the rank of 2, and the next rank will be 4.\\n\\n**\\'dense\\':** This method assigns dense ranks to tied elements, meaning there are no gaps in the ranks. For example, if two elements tie for the second rank, they both get the rank of 2, and the next rank will be 3.\\n\\n**\\'ordinal\\':** This method is similar to \\'dense\\', but it considers the order of appearance in the data for assigning ranks to tied elements. For example, if two elements tie for the second rank, the first element gets the rank of 2, and the next rank will be 3.\\n\\nThese methods allow you to choose how ties in the data should be handled while assigning ranks. You can select the appropriate method based on your specific requirements. By default, \\'average\\' is used when the method parameter is not provided.\\n\\n## Please upvote the solution which gives me motivation to share high quality solutions like this. Thank You.\\n\\n\\n",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    # Use the rank method to assign ranks to the scores in descending order with no gaps\\n    scores[\\'rank\\'] = scores[\\'score\\'].rank(method=\\'dense\\', ascending=False)\\n    \\n    # Drop id column & Sort the DataFrame by score in descending order\\n    result_df = scores.drop(\\'id\\',axis=1).sort_values(by=\\'score\\', ascending=False)\\n    \\n    return result_df\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1967099,
                "title": "mysql-solution",
                "content": "# Solution\\n```\\nSELECT score, dense_rank() OVER(ORDER BY score DESC) as \"rank\"\\nFROM Scores\\n```\\nThe **DENSE_RANK()** is a window function that assigns a rank to each row within a partition of a result set. Unlike the **RANK()** function, the **DENSE_RANK()** function returns consecutive rank values. Rows in each partition receive the same ranks if they have the same values.\\nIf you find this **solution** and **explanation** helpful, please **upvote** it for others people.\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT score, dense_rank() OVER(ORDER BY score DESC) as \"rank\"\\nFROM Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53096,
                "title": "accepted-solution-using-innerjoin-and-groupby",
                "content": "    SELECT Scores.Score, COUNT(Ranking.Score) AS RANK\\n      FROM Scores\\n         , (\\n           SELECT DISTINCT Score\\n             FROM Scores\\n           ) Ranking\\n     WHERE Scores.Score <= Ranking.Score\\n     GROUP BY Scores.Id, Scores.Score\\n     ORDER BY Scores.Score DESC;",
                "solutionTags": [],
                "code": "    SELECT Scores.Score, COUNT(Ranking.Score) AS RANK\\n      FROM Scores\\n         , (\\n           SELECT DISTINCT Score\\n             FROM Scores\\n           ) Ranking\\n     WHERE Scores.Score <= Ranking.Score\\n     GROUP BY Scores.Id, Scores.Score\\n     ORDER BY Scores.Score DESC;",
                "codeTag": "Unknown"
            },
            {
                "id": 570963,
                "title": "logically-simple-4-lines-mysql-solution-701ms",
                "content": "```\\nSELECT S1.Score, (\\n    SELECT COUNT(DISTINCT Score) FROM Scores WHERE Score >= S1.Score) AS Rank\\nFROM Scores S1\\nORDER BY S1.Score DESC\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT S1.Score, (\\n    SELECT COUNT(DISTINCT Score) FROM Scores WHERE Score >= S1.Score) AS Rank\\nFROM Scores S1\\nORDER BY S1.Score DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53129,
                "title": "maybe-the-simpest-solution",
                "content": "Maybe the simplest solution I guess\\n-----------\\n\\nSELECT score,(SELECT COUNT(DISTINCT score) FROM Scores where score > a.score) + 1 rank\\n from Scores a  \\nORDER by score DESC;\\n\\n-----------\\n\\nInspired by Oracle Function row_number()\\uff0crank()\\uff0cdense()",
                "solutionTags": [],
                "code": "Maybe the simplest solution I guess\\n-----------\\n\\nSELECT score,(SELECT COUNT(DISTINCT score) FROM Scores where score > a.score) + 1 rank\\n from Scores a  \\nORDER by score DESC;\\n\\n-----------\\n\\nInspired by Oracle Function row_number()\\uff0crank()\\uff0cdense()",
                "codeTag": "Unknown"
            },
            {
                "id": 1803710,
                "title": "best-smart-mysql-solution-178-rank-scores",
                "content": "```\\nselect s1.score, (select count(distinct score) from scores s2 where s2.score >= s1.score) as \"rank\" from scores s1\\norder by s1.score DESC;\\n\\n#pls upvote if you find solution easy to understand..Thanks..!!\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s1.score, (select count(distinct score) from scores s2 where s2.score >= s1.score) as \"rank\" from scores s1\\norder by s1.score DESC;\\n\\n#pls upvote if you find solution easy to understand..Thanks..!!\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53110,
                "title": "accepted-solution-with-subqueries-and-group-by",
                "content": "# Solution with sub-queries\\n\\nWe just get the rows the distinct rows that are <= that each score, count them and wrap them in an external SELECT for formatting. \\n\\n    SELECT Scores.Score, Q3.Rank\\n    FROM(\\n        SELECT Q1.Score as Score, COUNT(Q1.Score) as Rank\\n        FROM \\n            (SELECT DISTINCT Score from Scores) as Q1,\\n            (SELECT DISTINCT Score from Scores) as Q2\\n        WHERE Q1.Score <= Q2.Score\\n        GROUP BY Q1.Score\\n        ) as Q3, Scores\\n    WHERE Q3.Score = Scores.Score\\n    ORDER BY Scores.Score DESC",
                "solutionTags": [],
                "code": "# Solution with sub-queries\\n\\nWe just get the rows the distinct rows that are <= that each score, count them and wrap them in an external SELECT for formatting. \\n\\n    SELECT Scores.Score, Q3.Rank\\n    FROM(\\n        SELECT Q1.Score as Score, COUNT(Q1.Score) as Rank\\n        FROM \\n            (SELECT DISTINCT Score from Scores) as Q1,\\n            (SELECT DISTINCT Score from Scores) as Q2\\n        WHERE Q1.Score <= Q2.Score\\n        GROUP BY Q1.Score\\n        ) as Q3, Scores\\n    WHERE Q3.Score = Scores.Score\\n    ORDER BY Scores.Score DESC",
                "codeTag": "Unknown"
            },
            {
                "id": 1046525,
                "title": "solution-without-dense-rank",
                "content": "```\\nSELECT \\n    b.Score, \\n\\t(SELECT COUNT(DISTINCT a.Score) FROM Scores a WHERE b.Score <= a.Score) as `Rank`\\nFROM Scores b ORDER BY `Rank`\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT \\n    b.Score, \\n\\t(SELECT COUNT(DISTINCT a.Score) FROM Scores a WHERE b.Score <= a.Score) as `Rank`\\nFROM Scores b ORDER BY `Rank`\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3301918,
                "title": "fast-windows-vs-windowless-function-examples",
                "content": "Generally, interviewers want you to use a Windows Function to solve a problem like this.  \\n\\nHowever, you might have an interviewer who specifically says, don\\'t use a Windows Function, so it\\'s good to know both ways.\\n\\nHas anyone every asked you to answer a question like this without a subquery?\\n\\nThanks!\\n\\n[@easyCodingSolutions](https://youtu.be/K3KFG8Hpb2M)\\n\\nhttps://youtu.be/K3KFG8Hpb2M\\n\\nWith Windows Function:\\n\\n```\\n# Using DENSE_RANK - generally what interviewers want\\nSELECT\\n    score\\n    , DENSE_RANK() OVER (ORDER BY score DESC) \\'rank\\'\\nFROM Scores\\n    ORDER BY score DESC\\n```\\n\\nSame as Windows Function:\\n```\\nSELECT\\n  score,\\n  (SELECT COUNT(*) FROM (SELECT distinct score s FROM Scores) CTE WHERE s >= score) \\'Rank\\'\\nFROM Scores\\nORDER BY Score DESC\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Using DENSE_RANK - generally what interviewers want\\nSELECT\\n    score\\n    , DENSE_RANK() OVER (ORDER BY score DESC) \\'rank\\'\\nFROM Scores\\n    ORDER BY score DESC\\n```\n```\\nSELECT\\n  score,\\n  (SELECT COUNT(*) FROM (SELECT distinct score s FROM Scores) CTE WHERE s >= score) \\'Rank\\'\\nFROM Scores\\nORDER BY Score DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1884813,
                "title": "simple-mysql-solution-with-and-without-window-function",
                "content": "```\\n# Window Function Approach\\nselect score, dense_rank() over (order by score desc) as \"Rank\" from scores;\\n\\n# Using count method\\nselect score, (select count(distinct score) from scores s2 where s2.score >= s1.score) as \"Rank\"\\nfrom scores s1\\norder by score desc;\\n\\n# Do upvote if you like both the approaches!!\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Window Function Approach\\nselect score, dense_rank() over (order by score desc) as \"Rank\" from scores;\\n\\n# Using count method\\nselect score, (select count(distinct score) from scores s2 where s2.score >= s1.score) as \"Rank\"\\nfrom scores s1\\norder by score desc;\\n\\n# Do upvote if you like both the approaches!!\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1082561,
                "title": "faster-than-96-memory-less-than-100",
                "content": "```\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \\'Rank\\'\\nFROM Scores \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \\'Rank\\'\\nFROM Scores \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2420861,
                "title": "mysql-easy-understanding-beginner-level-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome.***\\n____________________________________________________________________________________________________________________________\\n\\u2705 **MySQL Code :**\\n```\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \\'Rank\\'\\nFROM Scores \\n```\\n____________________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \\'Rank\\'\\nFROM Scores \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1756654,
                "title": "concise-solution-with-sql-ranking",
                "content": "There are many ways we can calculate the rank of each score, the easiest is to use a built in method named `DENSE_RANK()`. \\n\\n```\\nSELECT \\n    score, \\n    DENSE_RANK() OVER(ORDER BY score desc) AS `rank` \\nFROM scores\\nORDER BY `rank`\\n```\\n\\nTwo things to take in consideration here:\\n\\n1. There is another method called `RANK()` which will give different result for the same query. If you don\\'t understand their difference, I would suggest you to try this with `RANK()` and see the difference in results, it will help you.\\n2. In the 3rd line you have to put the alias `rank` inside `` or `\"\"`, otherwise mysql will give error. This is because `rank` is a syntax used by mysql itself so you have to tell the db engine explicitely that it\\'s not the build in method, it\\'s a string.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n    score, \\n    DENSE_RANK() OVER(ORDER BY score desc) AS `rank` \\nFROM scores\\nORDER BY `rank`\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 115770,
                "title": "accepted-solution-with-subquery-for-rank",
                "content": "SELECT s1.Score AS Score, \n(SELECT COUNT(DISTINCT S2.Score) FROM Scores as S2 WHERE S2.Score > S1.Score)+1 AS Rank\nFROM Scores AS s1\nORDER BY Rank ASC",
                "solutionTags": [],
                "code": "(SELECT COUNT(DISTINCT S2.Score) FROM Scores as S2 WHERE S2.Score > S1.Score)+1 AS Rank",
                "codeTag": "Unknown"
            },
            {
                "id": 3907201,
                "title": "pandas-2-lines-very-easy-and-simple-beginners-solution-with-comments",
                "content": "# Code\\n```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n\\n    #Sorting the table in descending Order\\n    scores=scores.sort_values(by=[\\'score\\'],ascending=False)\\n\\n    #Using \\'rank\\' to rank the rows in descending method\\n    #\\'dense\\' method gives ranks continuous without any gap. \\n    scores[\\'rank\\']=(scores[\\'score\\'].rank(method=\\'dense\\',ascending=False))\\n\\n    return scores[[\\'score\\',\\'rank\\']]\\n```\\n\\n---\\n\\n\\n# PLEASE UPVOTE :)",
                "solutionTags": [
                    "Python",
                    "Database",
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n\\n    #Sorting the table in descending Order\\n    scores=scores.sort_values(by=[\\'score\\'],ascending=False)\\n\\n    #Using \\'rank\\' to rank the rows in descending method\\n    #\\'dense\\' method gives ranks continuous without any gap. \\n    scores[\\'rank\\']=(scores[\\'score\\'].rank(method=\\'dense\\',ascending=False))\\n\\n    return scores[[\\'score\\',\\'rank\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3350226,
                "title": "mysql-simple-dense-rank-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nusing ranking method\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nusing dense_rank() approach\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect round(score,2) as score , \\ndense_rank() \\nOVER (  order by score desc ) \\nAS \\'rank\\'\\n from scores order by score desc\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect round(score,2) as score , \\ndense_rank() \\nOVER (  order by score desc ) \\nAS \\'rank\\'\\n from scores order by score desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 329735,
                "title": "mysql-and-ms-sql-accepted-solutions",
                "content": "1. MySQL Solution:\\n```\\nSELECT s1.Score as score, \\n(SELECT COUNT(DISTINCT s2.Score)+1 FROM Scores s2 WHERE s1.Score< s2.Score) AS \\'Rank\\' \\nFROM Scores s1\\nORDER BY 1 DESC\\n```\\n2. MS SQL Solution\\n```\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank\\nFROM Scores\\nORDER BY Score DESC\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT s1.Score as score, \\n(SELECT COUNT(DISTINCT s2.Score)+1 FROM Scores s2 WHERE s1.Score< s2.Score) AS \\'Rank\\' \\nFROM Scores s1\\nORDER BY 1 DESC\\n```\n```\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank\\nFROM Scores\\nORDER BY Score DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2648415,
                "title": "rank-scores-one-liner",
                "content": "\\tselect score, dense_rank() over(order by score desc) as \\'rank\\' from scores;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\tselect score, dense_rank() over(order by score desc) as \\'rank\\' from scores;",
                "codeTag": "Unknown"
            },
            {
                "id": 190760,
                "title": "simple-subquery-solution",
                "content": "My solution using subquery and allowing dense ranking\n```\nSELECT Score\n  \t   ,(SELECT count(distinct score)\n  \t   \t FROM scores b\n  \t   \t WHERE b.score>= a.score ) as Rank\nFROM scores a\nORDER BY Rank;\n```\n",
                "solutionTags": [],
                "code": "```\nSELECT Score\n  \t   ,(SELECT count(distinct score)\n  \t   \t FROM scores b\n  \t   \t WHERE b.score>= a.score ) as Rank\nFROM scores a\nORDER BY Rank;\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 431650,
                "title": "simple-mysql-solution-not-using-dense-rank",
                "content": "Simple mySql solution not using dense_rank()\\n\\n```\\nselect s.Score, count(a.Score) as rank \\nfrom scores s, (\\n    select distinct Score \\n    FROM Scores) a\\nwhere s.Score <= a.Score\\ngroup by s.Id, s.Score\\norder by s.Score desc;\\n```",
                "solutionTags": [],
                "code": "```\\nselect s.Score, count(a.Score) as rank \\nfrom scores s, (\\n    select distinct Score \\n    FROM Scores) a\\nwhere s.Score <= a.Score\\ngroup by s.Id, s.Score\\norder by s.Score desc;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3872817,
                "title": "pandas-vs-sql-elegant-short-all-30-days-of-pandas-solutions",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```Python []\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    return scores.sort_values(\\n        by=\\'score\\', ascending=False,\\n    ).assign(\\n        rank=scores[\\'score\\'].rank(method=\\'dense\\', ascending=False),\\n    )[[\\'score\\', \\'rank\\']]\\n```\\n```SQL []\\nSELECT s1.score,\\n       count(s2.score) AS \"Rank\"\\n  FROM Scores s1,\\n      (SELECT DISTINCT score FROM Scores) s2\\n WHERE s1.score <= s2.score\\n GROUP BY s1.id\\n ORDER BY s1.score DESC;\\n```\\n\\n# Important!\\n###### If you like the solution or find it useful, feel free to **upvote** for it, it will support me in creating high quality solutions)\\n\\n# 30 Days of Pandas solutions\\n\\n### Data Filtering \\u2705\\n- [Big Countries](https://leetcode.com/problems/big-countries/solutions/3848474/pandas-elegant-short-1-line/)\\n- [Recyclable and Low Fat Products](https://leetcode.com/problems/recyclable-and-low-fat-products/solutions/3848500/pandas-elegant-short-1-line/)\\n- [Customers Who Never Order](https://leetcode.com/problems/customers-who-never-order/solutions/3848527/pandas-elegant-short-1-line/)\\n- [Article Views I](https://leetcode.com/problems/article-views-i/solutions/3867192/pandas-elegant-short-1-line/)\\n\\n\\n### String Methods \\u2705\\n- [Invalid Tweets](https://leetcode.com/problems/invalid-tweets/solutions/3849121/pandas-elegant-short-1-line/)\\n- [Calculate Special Bonus](https://leetcode.com/problems/calculate-special-bonus/solutions/3867209/pandas-elegant-short-1-line/)\\n- [Fix Names in a Table](https://leetcode.com/problems/fix-names-in-a-table/solutions/3849167/pandas-elegant-short-1-line/)\\n- [Find Users With Valid E-Mails](https://leetcode.com/problems/find-users-with-valid-e-mails/solutions/3849177/pandas-elegant-short-1-line/)\\n- [Patients With a Condition](https://leetcode.com/problems/patients-with-a-condition/solutions/3849196/pandas-elegant-short-1-line-regex/)\\n\\n\\n### Data Manipulation \\u2705\\n- [Nth Highest Salary](https://leetcode.com/problems/nth-highest-salary/solutions/3867257/pandas-elegant-short-1-line/)\\n- [Second Highest Salary](https://leetcode.com/problems/second-highest-salary/solutions/3867278/pandas-elegant-short/)\\n- [Department Highest Salary](https://leetcode.com/problems/department-highest-salary/solutions/3867312/pandas-elegant-short-1-line/)\\n- [Rank Scores](https://leetcode.com/problems/rank-scores/solutions/3872817/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Delete Duplicate Emails](https://leetcode.com/problems/delete-duplicate-emails/solutions/3849211/pandas-elegant-short/)\\n- [Rearrange Products Table](https://leetcode.com/problems/rearrange-products-table/solutions/3849226/pandas-elegant-short-1-line/)\\n\\n\\n### Statistics \\u2705\\n- [The Number of Rich Customers](https://leetcode.com/problems/the-number-of-rich-customers/solutions/3849251/pandas-elegant-short-1-line/)\\n- [Immediate Food Delivery I](https://leetcode.com/problems/immediate-food-delivery-i/solutions/3872719/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Count Salary Categories](https://leetcode.com/problems/count-salary-categories/solutions/3872801/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n\\n\\n### Data Aggregation \\u2705\\n- [Find Total Time Spent by Each Employee](https://leetcode.com/problems/find-total-time-spent-by-each-employee/solutions/3872715/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Game Play Analysis I](https://leetcode.com/problems/game-play-analysis-i/solutions/3863223/pandas-elegant-short-1-line/)\\n- [Number of Unique Subjects Taught by Each Teacher](https://leetcode.com/problems/number-of-unique-subjects-taught-by-each-teacher/solutions/3863239/pandas-elegant-short-1-line/)\\n- [Classes More Than 5 Students](https://leetcode.com/problems/classes-more-than-5-students/solutions/3863249/pandas-elegant-short/)\\n- [Customer Placing the Largest Number of Orders](https://leetcode.com/problems/customer-placing-the-largest-number-of-orders/solutions/3863257/pandas-elegant-short-1-line/)\\n- [Group Sold Products By The Date](https://leetcode.com/problems/group-sold-products-by-the-date/solutions/3863267/pandas-elegant-short-1-line/)\\n- [Daily Leads and Partners](https://leetcode.com/problems/daily-leads-and-partners/solutions/3863279/pandas-elegant-short-1-line/)\\n\\n\\n### Data Aggregation \\u2705\\n- [Actors and Directors Who Cooperated At Least Three Times](https://leetcode.com/problems/actors-and-directors-who-cooperated-at-least-three-times/solutions/3863309/pandas-elegant-short/)\\n- [Replace Employee ID With The Unique Identifier](https://leetcode.com/problems/replace-employee-id-with-the-unique-identifier/solutions/3872822/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Students and Examinations](https://leetcode.com/problems/students-and-examinations/solutions/3872699/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Managers with at Least 5 Direct Reports](https://leetcode.com/problems/managers-with-at-least-5-direct-reports/solutions/3872861/pandas-elegant-short/)\\n- [Sales Person](https://leetcode.com/problems/sales-person/solutions/3872712/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "MySQL",
                    "Pandas"
                ],
                "code": "```Python []\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    return scores.sort_values(\\n        by=\\'score\\', ascending=False,\\n    ).assign(\\n        rank=scores[\\'score\\'].rank(method=\\'dense\\', ascending=False),\\n    )[[\\'score\\', \\'rank\\']]\\n```\n```SQL []\\nSELECT s1.score,\\n       count(s2.score) AS \"Rank\"\\n  FROM Scores s1,\\n      (SELECT DISTINCT score FROM Scores) s2\\n WHERE s1.score <= s2.score\\n GROUP BY s1.id\\n ORDER BY s1.score DESC;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3212948,
                "title": "178-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo rank the scores, we can use a window function DENSE_RANK() in SQL. The DENSE_RANK() function assigns ranks to rows within the partition of a result set. If two or more rows have the same value, they receive the same rank, and the next rank is assigned to the next row.\\n\\nHere\\'s the SQL query to rank the scores:\\n```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as `rank`\\nFROM Scores\\nORDER BY score DESC;\\n```\\nThis query selects the score column and applies the DENSE_RANK() function to it, which will generate the ranking. We order the result set by the score in descending order, which means the highest score will have the rank 1.\\n\\nThe output of the query for the given input in the problem statement will be:\\n\\n```\\n+-------+------+\\n| score | rank |\\n+-------+------+\\n| 4.00  | 1    |\\n| 4.00  | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.50  | 4    |\\n+-------+------+\\n\\n```\\nSecond example solution:\\n\\n```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\'\\nFROM Scores;\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as `rank`\\nFROM Scores\\nORDER BY score DESC;\\n\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as `rank`\\nFROM Scores\\nORDER BY score DESC;\\n```\n```\\n+-------+------+\\n| score | rank |\\n+-------+------+\\n| 4.00  | 1    |\\n| 4.00  | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.50  | 4    |\\n+-------+------+\\n\\n```\n```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\'\\nFROM Scores;\\n```\n```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as `rank`\\nFROM Scores\\nORDER BY score DESC;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2517177,
                "title": "two-mysql-solutions-simple-dense-rank-and-complex-row-number",
                "content": "1. Simple Method (which a lot of people have used)\\n\\n```\\nSELECT score, DENSE_RANK() over (ORDER BY score DESC) AS \\'rank\\'\\nFROM Scores\\n```\\n\\n2. Complex Method (if dense_rank did not exist) - Faster than 88.95% of MySQL submissions\\n\\n```\\nWITH s1 AS (SELECT score, \\n            ROW_NUMBER() OVER (ORDER BY score DESC) AS \\'rank\\'\\nFROM Scores\\nGROUP BY score) # First create a table with unique row numbers for each distinct score\\n\\nSELECT s1.score, s1.rank\\nFROM s1\\nRIGHT JOIN Scores AS s2  \\nUSING (score) # join two tables using score as the foreign key\\nORDER BY score DESC\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT score, DENSE_RANK() over (ORDER BY score DESC) AS \\'rank\\'\\nFROM Scores\\n```\n```\\nWITH s1 AS (SELECT score, \\n            ROW_NUMBER() OVER (ORDER BY score DESC) AS \\'rank\\'\\nFROM Scores\\nGROUP BY score) # First create a table with unique row numbers for each distinct score\\n\\nSELECT s1.score, s1.rank\\nFROM s1\\nRIGHT JOIN Scores AS s2  \\nUSING (score) # join two tables using score as the foreign key\\nORDER BY score DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3850672,
                "title": "best-solutions-mysql-pandas-beats-100",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT score, dense_rank() OVER(ORDER BY score DESC) as \"rank\"\\nFROM Scores\\n```\\n```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    df = scores.sort_values(by=\\'score\\', ascending=False)\\n    df[\\'rank\\'] = df[\\'score\\'].rank(method=\\'dense\\', ascending=False) \\n    return df[[\\'score\\',\\'rank\\']]\\n```",
                "solutionTags": [
                    "MySQL",
                    "Pandas"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT score, dense_rank() OVER(ORDER BY score DESC) as \"rank\"\\nFROM Scores\\n```\n```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    df = scores.sort_values(by=\\'score\\', ascending=False)\\n    df[\\'rank\\'] = df[\\'score\\'].rank(method=\\'dense\\', ascending=False) \\n    return df[[\\'score\\',\\'rank\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3824711,
                "title": "100-easy-fast-clean-solution",
                "content": "IF THIS WILL BE HELPFUL TO YOU, PLEASE UPVOTE 1\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT score, DENSE_RANK () OVER (ORDER BY score DESC) \\n\\nRANK FROM Scores;\\n```\\nIF THIS WILL BE HELPFUL TO YOU,PLEASE UPVOTE!![5kej8w.jpg](https://assets.leetcode.com/users/images/6bae3f42-eb8f-4240-a2a7-fd40f588350a_1690475198.0246775.jpeg)\\n",
                "solutionTags": [
                    "Oracle",
                    "Database"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT score, DENSE_RANK () OVER (ORDER BY score DESC) \\n\\nRANK FROM Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2308104,
                "title": "row-number-vs-rank-vs-dense-rank",
                "content": "This question is a great place to learn these 3 functions. The best way for you to understand these 3 functions is to simply run the below code for them and see why and what they produce as output. The correct answer is given by DENSE_RANK() but a beginner will always get confused on why and when to use DENSE_RANK() or RANK() or ROW_NUMBER()\\n\\n**ROW_NUMBER()** is like a basic counting function, where it will give continous ranks like 1-2-3-4-5-6 and does not care if the values are same or not. So lets suppose we have three people with marks as 100, 100 and 99. ROW_NUMBER() will give rank 1 to person with 100/100 marks and then give rank 2 to person with 100/100 marks and then give rank 3 to person with 99 marks.\\n\\n* Rank 1 --- 100/100 marks Person A\\n* Rank 2 --- 100/100 marks Person B\\n* Rank 3 --- 99/100 marks Person C\\n\\n```\\nSELECT \\n    score AS \"score\",\\n    ROW_NUMBER() OVER (\\n        ORDER BY score DESC\\n    ) AS \"rank\"\\nFROM\\n    Scores\\n;\\n```\\n\\n**RANK()** is the very close to the correct answer for this question but RANK() leaves hole when it operates. So lets suppose we have three people with marks as 100, 100 and 99. RANK() will give rank 1 to person with 100/100 marks and then give rank 1 to person with 100/100 marks but in the end it will give rank 3 to person with 99 marks.\\n\\n* Rank 1 --- 100/100 marks Person A\\n* Rank 1 --- 100/100 marks Person B\\n* Rank 3 ---  99/100 marks Person C\\n\\n```\\nSELECT \\n    score AS \"score\",\\n    RANK() OVER (\\n        ORDER BY score DESC\\n    ) AS \"rank\"\\nFROM\\n    Scores\\n;\\n```\\n\\n**DENSE_RANK()** is the perfect function as per our given requirments. So lets suppose we have three people with marks as 100, 100 and 99. DENSE_RANK() will give rank 1 to person with 100/100 marks and then give rank 1 to person with 100/100 marks but in the end it will give rank 2 to person with 99 marks.\\n\\n* Rank 1 --- 100/100 marks Person A\\n* Rank 1 --- 100/100 marks Person B\\n* Rank 2 ---  99/100 marks Person C\\n```\\nSELECT \\n    score AS \"score\",\\n    DENSE_RANK() OVER (\\n        ORDER BY score DESC\\n    ) AS \"rank\"\\nFROM\\n    Scores\\n;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n    score AS \"score\",\\n    ROW_NUMBER() OVER (\\n        ORDER BY score DESC\\n    ) AS \"rank\"\\nFROM\\n    Scores\\n;\\n```\n```\\nSELECT \\n    score AS \"score\",\\n    RANK() OVER (\\n        ORDER BY score DESC\\n    ) AS \"rank\"\\nFROM\\n    Scores\\n;\\n```\n```\\nSELECT \\n    score AS \"score\",\\n    DENSE_RANK() OVER (\\n        ORDER BY score DESC\\n    ) AS \"rank\"\\nFROM\\n    Scores\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2234543,
                "title": "mysql-solution",
                "content": "```\\nSELECT\\n    score,\\n    DENSE_RANK() OVER (\\n        ORDER BY\\n            score DESC\\n    ) AS \\'rank\\'\\nFROM\\n    SCORES;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    score,\\n    DENSE_RANK() OVER (\\n        ORDER BY\\n            score DESC\\n    ) AS \\'rank\\'\\nFROM\\n    SCORES;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1711996,
                "title": "super-simple-solution",
                "content": "select\\nscore, (select count(distinct score)+1 from Scores where score>s.score) as \"rank\"\\nfrom Scores s\\norder by score desc",
                "solutionTags": [],
                "code": "select\\nscore, (select count(distinct score)+1 from Scores where score>s.score) as \"rank\"\\nfrom Scores s\\norder by score desc",
                "codeTag": "Unknown"
            },
            {
                "id": 1698301,
                "title": "3-easiest-ways",
                "content": "Classic way\\n```\\nSELECT s.score\\n     , DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\n  FROM scores s\\n ORDER BY s.score DESC\\n```\\nOne stupid way. Use on the interview is your interviewer doesn\\'t know or hates window functions\\n```\\nSELECT t.score\\n     , (SELECT COUNT(DISTINCT s.score)  FROM scores s WHERE s.score >=t.score)  AS rank \\n  FROM scores t\\n ORDER BY t.score DESC\\n```\\n\\n3th way (MySQL):\\n```\\nSELECT s1.score\\n, 1+COUNT(DISTINCT CASE WHEN s2.score>s1.score AND s1.id!=s2.id THEN s2.score ELSE NULL END) AS \"rank\"\\nFROM scores s1\\nCROSS JOIN\\nscores s2\\nGROUP BY s1.id\\n, s1.score\\nORDER BY 2 ASC\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT s.score\\n     , DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\n  FROM scores s\\n ORDER BY s.score DESC\\n```\n```\\nSELECT t.score\\n     , (SELECT COUNT(DISTINCT s.score)  FROM scores s WHERE s.score >=t.score)  AS rank \\n  FROM scores t\\n ORDER BY t.score DESC\\n```\n```\\nSELECT s1.score\\n, 1+COUNT(DISTINCT CASE WHEN s2.score>s1.score AND s1.id!=s2.id THEN s2.score ELSE NULL END) AS \"rank\"\\nFROM scores s1\\nCROSS JOIN\\nscores s2\\nGROUP BY s1.id\\n, s1.score\\nORDER BY 2 ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 719776,
                "title": "easy-using-methods-to-rank-rows-in-sql",
                "content": "```\\nSELECT score, dense_rank() over (order by score desc) as \\'Rank\\'\\nFROM scores\\n```\\n\\n\\n\\nPlease note that the description says \"If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value\" \\n\\nThat\\'s why you need to use **DENSE_RANK** instead of rank or row_number. \\n\\nSee the functions for other rank methods:\\n-- row_number() : \"Returns a unique number for each row\" IN CASE OF A TIE: with rankings arbitrarily assigned \\n-- rank() \"Returns the same ranking\" IN CASE OF A TIE: gaps* in the rankings\\n-- dense_rank() \"Returns the same ranking\" IN CASE OF A TIE: no gaps in the rankings",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nSELECT score, dense_rank() over (order by score desc) as \\'Rank\\'\\nFROM scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53130,
                "title": "my-800ms-simple-solution-without-variables",
                "content": "    SELECT T2.Score Score, (SELECT COUNT(*) + 1 FROM (SELECT T1.Score FROM Scores T1 GROUP BY Score ORDER BY Score DESC) TEMP WHERE T2.Score < TEMP.Score) Rank FROM Scores T2 ORDER BY Score DESC;",
                "solutionTags": [],
                "code": "    SELECT T2.Score Score, (SELECT COUNT(*) + 1 FROM (SELECT T1.Score FROM Scores T1 GROUP BY Score ORDER BY Score DESC) TEMP WHERE T2.Score < TEMP.Score) Rank FROM Scores T2 ORDER BY Score DESC;",
                "codeTag": "Unknown"
            },
            {
                "id": 53148,
                "title": "very-concise-accepted-solution-without-variables-check-it-out",
                "content": "    Select sc.Score,\\n           (Select count(*)+1 from (select distinct (Score) from Scores)\\n            as uniqeScores where Score > sc.Score) as rank \\n    from Scores sc order by sc.Score desc;",
                "solutionTags": [],
                "code": "    Select sc.Score,\\n           (Select count(*)+1 from (select distinct (Score) from Scores)\\n            as uniqeScores where Score > sc.Score) as rank \\n    from Scores sc order by sc.Score desc;",
                "codeTag": "Unknown"
            },
            {
                "id": 53152,
                "title": "1169ms-solution-without-variables-and-union",
                "content": "    SELECT\\n      s2.`Score`,\\n      (SELECT COUNT(DISTINCT s1.`Score`) FROM `Scores` s1 WHERE s1.`Score` >= s2.`Score`)\\n        FROM `Scores` s2\\n          ORDER BY s2.`Score` DESC\\n\\np.s. please share more faster solutions!",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "    SELECT\\n      s2.`Score`,\\n      (SELECT COUNT(DISTINCT s1.`Score`) FROM `Scores` s1 WHERE s1.`Score` >= s2.`Score`)\\n        FROM `Scores` s2\\n          ORDER BY s2.`Score` DESC\\n\\np.s. please share more faster solutions!",
                "codeTag": "Unknown"
            },
            {
                "id": 3146556,
                "title": "easy-method-by-oracle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT s.score,\\n DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\n  FROM scores s\\n ORDER BY s.score DESC;\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT s.score,\\n DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\n  FROM scores s\\n ORDER BY s.score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2740501,
                "title": "sql-multiple-approaches-with-explanation-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/10/rank-scores.html\\nIt has solutions to almost every problem on Leetcode, and I recommend checking it out.\\nNote: You can bookmark it as a resource, and approach. Other approaches are in above blog\\n<br>\\n\\n```\\nSELECT s.score,\\n    (\\n        SELECT count(DISTINCT (ss.score)) + 1\\n        FROM Scores ss\\n        WHERE ss.score > s.score\\n        ) AS \\'rank\\'\\nFROM Scores s\\nORDER BY s.score DESC\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT s.score,\\n    (\\n        SELECT count(DISTINCT (ss.score)) + 1\\n        FROM Scores ss\\n        WHERE ss.score > s.score\\n        ) AS \\'rank\\'\\nFROM Scores s\\nORDER BY s.score DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1719541,
                "title": "faster-than-99",
                "content": "Subquery the grouped score with a rank so that you can duplicate the rows.\\n```\\nSELECT Scores.score, x.rank\\nFROM Scores\\nINNER JOIN (\\n    SELECT score, ROW_NUMBER() OVER (ORDER BY score DESC) as \"rank\"\\n    FROM Scores\\n    GROUP BY score\\n) x ON x.score = Scores.score\\nORDER BY x.rank\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT Scores.score, x.rank\\nFROM Scores\\nINNER JOIN (\\n    SELECT score, ROW_NUMBER() OVER (ORDER BY score DESC) as \"rank\"\\n    FROM Scores\\n    GROUP BY score\\n) x ON x.score = Scores.score\\nORDER BY x.rank\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1641262,
                "title": "good-of-sql-beginner-to-understand",
                "content": "select a.score, (select count(distinct b.score) from Scores b \\n                 where a.score <= b.score) as \"rank\"\\nfrom Scores a\\norder by score desc;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select a.score, (select count(distinct b.score) from Scores b \\n                 where a.score <= b.score) as \"rank\"\\nfrom Scores a\\norder by score desc;",
                "codeTag": "Unknown"
            },
            {
                "id": 1066148,
                "title": "no-dense-rank-faster-than-96-63-mysql",
                "content": "```\\nSELECT s.score, u.rank\\nFROM Scores s\\nLEFT JOIN(\\n    SELECT score, ROW_NUMBER() OVER (ORDER BY score DESC) AS `rank`\\n    FROM (SELECT DISTINCT score FROM Scores ORDER BY score DESC) d\\n) u\\nON s.score=u.score\\nORDER BY score DESC;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT s.score, u.rank\\nFROM Scores s\\nLEFT JOIN(\\n    SELECT score, ROW_NUMBER() OVER (ORDER BY score DESC) AS `rank`\\n    FROM (SELECT DISTINCT score FROM Scores ORDER BY score DESC) d\\n) u\\nON s.score=u.score\\nORDER BY score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 750332,
                "title": "mysql-dense-rank",
                "content": "```\\nSELECT score, dense_rank() over(order by score DESC) as \\'Rank\\'\\nFROM Scores\\n```\\nLeetcode updates the version of the MYSQL!!! Thank god.",
                "solutionTags": [],
                "code": "```\\nSELECT score, dense_rank() over(order by score DESC) as \\'Rank\\'\\nFROM Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 676422,
                "title": "ms-sql-server-solution-simple-and-fast",
                "content": "```\\nSELECT Score AS score,\\n       DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank\\nFROM Scores\\n```\\n\\nRuntime: 825 ms, faster than 91.66% of MS SQL Server online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MS SQL Server online submissions for Rank Scores.\\n",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT Score AS score,\\n       DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank\\nFROM Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 665469,
                "title": "solution-with-and-without-window-function",
                "content": "If you are allowed to use window functions, then a simple dense_rank() will work.\\nIf you are not allowed to use window functions:\\n```\\nSelect \\nScore,\\n(SELECT COUNT(*) FROM \\n        (SELECT DISTINCT Score S FROM Scores) TMP\\nWHERE S >= Score\\n) \"Rank\"\\nFROM Scores\\nORDER BY Score DESC\\n```",
                "solutionTags": [],
                "code": "```\\nSelect \\nScore,\\n(SELECT COUNT(*) FROM \\n        (SELECT DISTINCT Score S FROM Scores) TMP\\nWHERE S >= Score\\n) \"Rank\"\\nFROM Scores\\nORDER BY Score DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 525229,
                "title": "mysql-solution-works-on-leetcode-s-version-5-7",
                "content": "Generating `row_number` would have been a lot easier with version 8 with `ROW_NUMBER() OVER()`. Unfornately LeetCode has an older version of MySQL that does not have this feature.\\n```SQL\\nSELECT s.Score, r.Rank\\nFROM (\\n    --  Subquery 2: Generate row_number\\n    SELECT Score, (@row_number:=@row_number + 1) AS `Rank`\\n    FROM (\\n        -- Subquery 1: Generate ranked, unique scores\\n        SELECT Score\\n        FROM Scores\\n        GROUP BY Score\\n        ORDER BY Score DESC\\n    ) AS s, (SELECT @row_number:=0) AS dummie\\n) AS r\\nRIGHT JOIN Scores AS s\\n    ON s.Score = r.Score\\nORDER BY r.Rank;\\n```",
                "solutionTags": [],
                "code": "```SQL\\nSELECT s.Score, r.Rank\\nFROM (\\n    --  Subquery 2: Generate row_number\\n    SELECT Score, (@row_number:=@row_number + 1) AS `Rank`\\n    FROM (\\n        -- Subquery 1: Generate ranked, unique scores\\n        SELECT Score\\n        FROM Scores\\n        GROUP BY Score\\n        ORDER BY Score DESC\\n    ) AS s, (SELECT @row_number:=0) AS dummie\\n) AS r\\nRIGHT JOIN Scores AS s\\n    ON s.Score = r.Score\\nORDER BY r.Rank;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 354027,
                "title": "sql-easy-to-understand",
                "content": "SELECT s.Score, COUNT(t.Score) AS Rank FROM\\n(SELECT DISTINCT Score FROM Scores) AS t, Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.Id, s.Score\\nORDER BY s.Score DESC;",
                "solutionTags": [],
                "code": "SELECT s.Score, COUNT(t.Score) AS Rank FROM\\n(SELECT DISTINCT Score FROM Scores) AS t, Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.Id, s.Score\\nORDER BY s.Score DESC;",
                "codeTag": "Unknown"
            },
            {
                "id": 163333,
                "title": "no-variable-no-group-by",
                "content": "SELECT t1.Score,(\\nSELECT COUNT(DISTINCT t2.Score)+1\\n    FROM Scores t2\\n    WHERE t1.Score < t2.Score\\n) AS Rank\\nFROM Scores t1\\nORDER BY t1.Score DESC",
                "solutionTags": [],
                "code": "SELECT t1.Score,(\\nSELECT COUNT(DISTINCT t2.Score)+1\\n    FROM Scores t2\\n    WHERE t1.Score < t2.Score\\n) AS Rank\\nFROM Scores t1\\nORDER BY t1.Score DESC",
                "codeTag": "Unknown"
            },
            {
                "id": 3979058,
                "title": "sql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSelect score, dense_rank() over (Order By score DESC) as \\'rank\\' from Scores ;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect score, dense_rank() over (Order By score DESC) as \\'rank\\' from Scores ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466260,
                "title": "easy-approach",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect score,dense_rank() over( order by score desc) as \\'rank\\' from scores;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect score,dense_rank() over( order by score desc) as \\'rank\\' from scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3324093,
                "title": "mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect score, dense_rank() over (order by score desc) as `rank`\\nfrom Scores;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect score, dense_rank() over (order by score desc) as `rank`\\nfrom Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2797938,
                "title": "oracle-solution-with-correlated-subquery",
                "content": "```\\nSELECT s1.score AS score, \\n(\\n    SELECT COUNT(DISTINCT s2.score) \\n    FROM scores s2 \\n    WHERE s1.score < s2.score \\n) + 1 AS rank\\nFROM Scores s1\\nORDER BY score DESC;\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT s1.score AS score, \\n(\\n    SELECT COUNT(DISTINCT s2.score) \\n    FROM scores s2 \\n    WHERE s1.score < s2.score \\n) + 1 AS rank\\nFROM Scores s1\\nORDER BY score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2620875,
                "title": "sql-easy-approach-simple-and-fast",
                "content": "**If You Like, Please Upvote.**\\n![image](https://assets.leetcode.com/users/images/326dcf2e-e386-4ecf-8eb7-49c26770842f_1664080468.680641.png)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "**If You Like, Please Upvote.**\\n![image](https://assets.leetcode.com/users/images/326dcf2e-e386-4ecf-8eb7-49c26770842f_1664080468.680641.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2411341,
                "title": "simple-solution-using-correlated-subquery",
                "content": "```\\nselect score,\\n(select count(s2.score) from (select distinct score from scores) s2 \\nwhere s2.score >= s1.score) as \"RANK\"\\nfrom scores s1 \\nORDER BY score DESC;\\n```\\n\\nApproach : Rank will be decided based on unique scores. We want rank of all the scores. So the idea is to loop for all distinct scores and find the count of scores(s2) greater than or equal to current distinct score (s1) and store it as rank and display it in descending order.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect score,\\n(select count(s2.score) from (select distinct score from scores) s2 \\nwhere s2.score >= s1.score) as \"RANK\"\\nfrom scores s1 \\nORDER BY score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1305451,
                "title": "mysql-no-dense-rank-436ms-17-66",
                "content": "I was not aware that SQL had a function for this already, so after quite a bit of trial and error I arrived at this solution.\\n\\n```\\nSELECT s3.Score, s4.Rank\\nFROM Scores s3\\nINNER JOIN ( SELECT Score, @i:=@i+1 \\'Rank\\'\\n            FROM ( SELECT DISTINCT Score\\n                    FROM Scores\\n                    ORDER BY Score DESC) s1\\n            CROSS JOIN (SELECT @i:=0) s2) s4\\nON s3.Score = s4.Score\\nORDER BY s3.Score DESC;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT s3.Score, s4.Rank\\nFROM Scores s3\\nINNER JOIN ( SELECT Score, @i:=@i+1 \\'Rank\\'\\n            FROM ( SELECT DISTINCT Score\\n                    FROM Scores\\n                    ORDER BY Score DESC) s1\\n            CROSS JOIN (SELECT @i:=0) s2) s4\\nON s3.Score = s4.Score\\nORDER BY s3.Score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1122959,
                "title": "using-dense-rank-in-mysql-97-faster",
                "content": "```\\nSelect score, DENSE_RANK() over (\\norder by Score desc\\n)\\'Rank\\' from Scores;\\n```",
                "solutionTags": [],
                "code": "```\\nSelect score, DENSE_RANK() over (\\norder by Score desc\\n)\\'Rank\\' from Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374182,
                "title": "simply-answer",
                "content": "select s1.score, count(distinct s2.score) as Rank\\nfrom scores s1, scores s2\\nwhere s1.score <=s2.score\\ngroup by s1.id\\norder by s1.score desc\\n",
                "solutionTags": [],
                "code": "select s1.score, count(distinct s2.score) as Rank\\nfrom scores s1, scores s2\\nwhere s1.score <=s2.score\\ngroup by s1.id\\norder by s1.score desc\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 259968,
                "title": "solution-accepted",
                "content": "SELECT Score, \\n       (SELECT COUNT(DISTINCT Score) FROM Scores WHERE Score >= s.Score) Rank\\nFROM Scores s\\nORDER BY Score DESC",
                "solutionTags": [],
                "code": "SELECT Score, \\n       (SELECT COUNT(DISTINCT Score) FROM Scores WHERE Score >= s.Score) Rank\\nFROM Scores s\\nORDER BY Score DESC",
                "codeTag": "Unknown"
            },
            {
                "id": 187650,
                "title": "simple-dense-rank-solution",
                "content": "select score, dense_rank() over (  order by Score desc) [Rank] from scores",
                "solutionTags": [],
                "code": "select score, dense_rank() over (  order by Score desc) [Rank] from scores",
                "codeTag": "Unknown"
            },
            {
                "id": 53141,
                "title": "runtime-704-ms-use-two-variables",
                "content": "    select Score,Rank from \\n    (\\n    SELECT Score,\\n           CASE\\n               WHEN @dummy <=> Score THEN @Rank := @Rank \\n               ELSE @Rank := @Rank +1\\n    \\tEND AS Rank,@dummy := Score as dummy\\n    FROM\\n      (SELECT @Rank := 0,@dummy := NULL) r,\\n         Scores\\n    ORDER BY Score DESC\\n    ) AS C",
                "solutionTags": [],
                "code": "    select Score,Rank from \\n    (\\n    SELECT Score,\\n           CASE\\n               WHEN @dummy <=> Score THEN @Rank := @Rank \\n               ELSE @Rank := @Rank +1\\n    \\tEND AS Rank,@dummy := Score as dummy\\n    FROM\\n      (SELECT @Rank := 0,@dummy := NULL) r,\\n         Scores\\n    ORDER BY Score DESC\\n    ) AS C",
                "codeTag": "Unknown"
            },
            {
                "id": 53101,
                "title": "accepted-solution-with-variables",
                "content": "    select Score,\\n      case \\n        when @prevScore = Score then @rank\\n        when (@prevScore := Score) is not null then @rank := @rank+1\\n      end as Rank\\n    from Scores, (select @rank := 0, @prevScore := NULL) a\\n    order by Score desc;",
                "solutionTags": [],
                "code": "    select Score,\\n      case \\n        when @prevScore = Score then @rank\\n        when (@prevScore := Score) is not null then @rank := @rank+1\\n      end as Rank\\n    from Scores, (select @rank := 0, @prevScore := NULL) a\\n    order by Score desc;",
                "codeTag": "Unknown"
            },
            {
                "id": 3872696,
                "title": "simple-mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect score,dense_rank() over (order by score desc) as \\'Rank\\' from Scores\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect score,dense_rank() over (order by score desc) as \\'Rank\\' from Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3855743,
                "title": "simple-approach-beats-98",
                "content": "```\\nselect score,\\ndense_rank() over (order by score desc) as \\'Rank\\'\\nfrom Scores\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect score,\\ndense_rank() over (order by score desc) as \\'Rank\\'\\nfrom Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3850396,
                "title": "pandas-3-lines-sort-dense-rank",
                "content": "\\n# Code\\n```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    df = scores.sort_values(by=\\'score\\', ascending=False)\\n    # assign lowest rank to highest value\\n    # `method=\\'dense\\'` assigns same rank to equal values without skipping ranks\\n    df[\\'rank\\'] = df[\\'score\\'].rank(method=\\'dense\\', ascending=False) \\n    return df[[\\'score\\',\\'rank\\']]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    df = scores.sort_values(by=\\'score\\', ascending=False)\\n    # assign lowest rank to highest value\\n    # `method=\\'dense\\'` assigns same rank to equal values without skipping ranks\\n    df[\\'rank\\'] = df[\\'score\\'].rank(method=\\'dense\\', ascending=False) \\n    return df[[\\'score\\',\\'rank\\']]\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3523708,
                "title": "mysql-server-solution-for-rank-scores-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal of this SQL query is to retrieve the scores from the Scores table along with their corresponding rank, where the rank is determined by the score in descending order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Use the dense_rank() function to assign a rank to each score in the Scores table, ordered by score in descending order.\\n2. Select the Score column and the rank assigned by the dense_rank() function.\\n3. The result set will contain one row for each score in the Scores table, with the score and its corresponding rank.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n The time complexity of this query depends on the size of the Scores table and the efficiency of the database engine\\'s query optimizer. In general, the time complexity of a query with an ORDER BY clause is O(n * log n), where n is the number of rows in the table. However, the dense_rank() function may help to optimize the query execution plan and reduce the actual time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this query depends on the size of the result set and the size of the columns being selected. In this case, the result set will have at most as many rows as the Scores table, and each row will have two columns (Score and Rank). Therefore, the space complexity is O(n), where n is the number of rows in the Scores table.\\n\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nselect Score, dense_rank() over(order by Score desc) as Rank from Scores;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect Score, dense_rank() over(order by Score desc) as Rank from Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2908530,
                "title": "mysql-dense-rank-vs-rank",
                "content": "\\n\\n# Using **DENSE_RANK()**\\n```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score desc) as \\'rank\\'\\nFROM Scores\\nORDER BY score desc\\n```\\n\\n# Using **RANK()**\\nRank() not assigning rank in a consecutive order, it is assigning by a rank of row within same categories/ score in this case.\\n\\n\\n```\\nSELECT score, RANK() OVER (ORDER BY score desc) as \\'rank\\'\\nFROM Scores\\nORDER BY score desc\\n```\\nThe following are the differences between using **DENSE_RANK()** and **RANK()**:\\n![image.png](https://assets.leetcode.com/users/images/db3ecabf-c532-4ee5-9e36-3ca47585bc47_1671004821.9050007.png)\\n\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score desc) as \\'rank\\'\\nFROM Scores\\nORDER BY score desc\\n```\n```\\nSELECT score, RANK() OVER (ORDER BY score desc) as \\'rank\\'\\nFROM Scores\\nORDER BY score desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2607382,
                "title": "178-rank-scores",
                "content": "```\\nSELECT score,\\n    DENSE_RANK() OVER (\\n    ORDER BY score DESC\\n    ) AS \\'rank\\'\\nFROM SCORES;",
                "solutionTags": [],
                "code": "```\\nSELECT score,\\n    DENSE_RANK() OVER (\\n    ORDER BY score DESC\\n    ) AS \\'rank\\'\\nFROM SCORES;",
                "codeTag": "Unknown"
            },
            {
                "id": 2237222,
                "title": "simplest-oracle-solution",
                "content": "select score,DENSE_RANK() over(order by score desc ) as rank from Scores\\norder by score desc\\n",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "select score,DENSE_RANK() over(order by score desc ) as rank from Scores\\norder by score desc\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1730791,
                "title": "dense-rank-can-not-think-of-a-simpler-solution",
                "content": "```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) AS `rank` FROM Scores ORDER BY score DESC;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) AS `rank` FROM Scores ORDER BY score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1660727,
                "title": "dense-rank",
                "content": "```\\nSELECT \\n    score,\\n    DENSE_RANK() OVER (\\n        ORDER BY score DESC\\n    ) AS \\'rank\\'\\nFROM \\n    Scores;\\n```\\n\\nThe difference between rank and dense_rank is rank will skip numbers after ranking two equal values. Dense_rank will always rank with consecutive numbers.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n    score,\\n    DENSE_RANK() OVER (\\n        ORDER BY score DESC\\n    ) AS \\'rank\\'\\nFROM \\n    Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1556821,
                "title": "faster-than-99-95-solution-using-mysql-s-built-in-windowing-s-dense-rank",
                "content": "Runtime: 208 ms, faster than 99.95% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores.\\n\\nThe simplest solution is to use built-in Windowing with a [`DENSE_RANK` function](https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_dense-rank), which by design gives exactly what we need.\\n\\nTo learn more, please see [MySQL documentation and examples on Windowing](https://dev.mysql.com/doc/refman/8.0/en/window-functions-usage.html). Windowing concept is very powerful and is definitely the fastest way to calculate ranks, sums, averages, counts on \"buckets\" of data, where by the bucket I understand a group of data (groupped by a certain characteristic, like date, category or a given value type). Whereas Windowing is a bit harder to master, it\\'s definitely useful when creating reports.\\n\\n```sql\\n# Write your MySQL query statement below\\nSELECT\\n    s.score,\\n    DENSE_RANK() OVER (\\n        ORDER BY s.score DESC\\n    ) \\'rank\\'\\nFROM Scores s;\\n```\\n",
                "solutionTags": [
                    "MySQL",
                    "Sliding Window"
                ],
                "code": "```sql\\n# Write your MySQL query statement below\\nSELECT\\n    s.score,\\n    DENSE_RANK() OVER (\\n        ORDER BY s.score DESC\\n    ) \\'rank\\'\\nFROM Scores s;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1516798,
                "title": "without-dense-rank",
                "content": "Select s1.Score, count(distinct s2.Score) as \"Rank\"\\n    From Scores s1\\n    Join Scores s2 \\n    where s1.Score<=s2.Score\\n    Group by s1.Id\\n    order by Score DESC",
                "solutionTags": [],
                "code": "Select s1.Score, count(distinct s2.Score) as \"Rank\"\\n    From Scores s1\\n    Join Scores s2 \\n    where s1.Score<=s2.Score\\n    Group by s1.Id\\n    order by Score DESC",
                "codeTag": "Unknown"
            },
            {
                "id": 1507145,
                "title": "mssql-dense-rank",
                "content": "```\\nSELECT Score, DENSE_RANK() OVER (ORDER BY SCORE DESC) Rank\\nFROM SCORES S;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT Score, DENSE_RANK() OVER (ORDER BY SCORE DESC) Rank\\nFROM SCORES S;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1174149,
                "title": "solution-without-dense-rank",
                "content": "select c.score, d.ran as \\'Rank\\' from (\\nselect a.score, ROW_NUMBER() OVER (ORDER BY a.score desc) AS ran from\\n(select distinct score from Scores) as a ) as d \\ninner join\\nScores as c \\non c.score = d.score\\norder by ran asc",
                "solutionTags": [],
                "code": "select c.score, d.ran as \\'Rank\\' from (\\nselect a.score, ROW_NUMBER() OVER (ORDER BY a.score desc) AS ran from\\n(select distinct score from Scores) as a ) as d \\ninner join\\nScores as c \\non c.score = d.score\\norder by ran asc",
                "codeTag": "Unknown"
            },
            {
                "id": 972814,
                "title": "intuitive-answer-with-inner-join",
                "content": "Per question description, the rank of a number $a$ is the number of unique numbers larger than or equal to $a$. Translate that into sql:\\n\\n```sql\\n# Write your MySQL query statement below\\n\\nselect a.score\\n    , count(distinct(b.score)) as `Rank`\\nfrom Scores a\\ninner join Scores b\\non b.score >= a.score\\ngroup by a.id, a.score\\norder by `Rank` ASC\\n```",
                "solutionTags": [],
                "code": "```sql\\n# Write your MySQL query statement below\\n\\nselect a.score\\n    , count(distinct(b.score)) as `Rank`\\nfrom Scores a\\ninner join Scores b\\non b.score >= a.score\\ngroup by a.id, a.score\\norder by `Rank` ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 902347,
                "title": "one-line-with-dense-rank",
                "content": "select score, dense_rank() over (order by score desc) as \\'Rank\\' from scores",
                "solutionTags": [],
                "code": "select score, dense_rank() over (order by score desc) as \\'Rank\\' from scores",
                "codeTag": "Unknown"
            },
            {
                "id": 586577,
                "title": "1-liner",
                "content": "select score, dense_rank() over (order by score desc) as rank from scores",
                "solutionTags": [],
                "code": "select score, dense_rank() over (order by score desc) as rank from scores",
                "codeTag": "Unknown"
            },
            {
                "id": 437961,
                "title": "simple-mysql-solution-accepted-runtime-264-ms",
                "content": "SELECT t1.Score,(SELECT count(distinct Score)+1 from Scores t2 where t2.Score-t1.Score>0.00001) Rank FROM Scores t1 ORDER BY Rank;",
                "solutionTags": [],
                "code": "SELECT t1.Score,(SELECT count(distinct Score)+1 from Scores t2 where t2.Score-t1.Score>0.00001) Rank FROM Scores t1 ORDER BY Rank;",
                "codeTag": "Unknown"
            },
            {
                "id": 415318,
                "title": "one-more-simple-solution",
                "content": "Select s1.Score, ((Select  COUNT(DISTINCT Score)  From Scores Where Score > s1.Score) + 1) as Rank From Scores  s1    ORDER BY s1.Score DESC",
                "solutionTags": [],
                "code": "Select s1.Score, ((Select  COUNT(DISTINCT Score)  From Scores Where Score > s1.Score) + 1) as Rank From Scores  s1    ORDER BY s1.Score DESC",
                "codeTag": "Unknown"
            },
            {
                "id": 268759,
                "title": "very-simple-solution",
                "content": "```\\nSELECT  Score, DENSE_RANK( ) OVER (ORDER BY Score DESC ) as Rank\\nFROM Scores;",
                "solutionTags": [],
                "code": "```\\nSELECT  Score, DENSE_RANK( ) OVER (ORDER BY Score DESC ) as Rank\\nFROM Scores;",
                "codeTag": "Unknown"
            },
            {
                "id": 261595,
                "title": "solution-accepted",
                "content": "# Write your MySQL query statement below\\n```sql\\nSELECT Scores.Score as Score, count(rankings.Score) as Rank\\nFROM Scores, (Select Distinct Score from Scores) as rankings\\nWhere rankings.Score >= Scores.Score\\nGroup by Scores.id\\nOrder by Scores.Score DESC;\\n```",
                "solutionTags": [],
                "code": "```sql\\nSELECT Scores.Score as Score, count(rankings.Score) as Rank\\nFROM Scores, (Select Distinct Score from Scores) as rankings\\nWhere rankings.Score >= Scores.Score\\nGroup by Scores.id\\nOrder by Scores.Score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 229353,
                "title": "mysql-solution-not-use-row-number-function",
                "content": "This question seems to be not allowed row_number function.\\n```\\nselect score, rank\\nfrom\\n(\\n select \\n  a.id, \\n  a.score, \\n  count(distinct b.score) + 1 as rank \\n from Scores a \\n left outer join Scores b \\n on a.score < b.score\\n group by a.id, a.score\\n) tbl\\norder by rank\\n```",
                "solutionTags": [],
                "code": "```\\nselect score, rank\\nfrom\\n(\\n select \\n  a.id, \\n  a.score, \\n  count(distinct b.score) + 1 as rank \\n from Scores a \\n left outer join Scores b \\n on a.score < b.score\\n group by a.id, a.score\\n) tbl\\norder by rank\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 175722,
                "title": "simple-and-easy-to-understand",
                "content": "```\\nSELECT Scores.Score ,COUNT(DISTINCT greater.Score)+1 AS Rank\\nFROM Scores\\nLEFT JOIN Scores greater ON greater.Score>Scores.Score\\nGROUP BY Scores.Id\\nORDER BY Rank\\n```\\n\\nNotice that \\'rank of a score\\' = \\'#unique scores\\' + 1. For example, rank(4.0) = 0(no unique score greater than 4.0) + 1 = 1. \\nWe want to count unique score here because we want dense rank, which means all scores with the same value will be calculated as one rank (say two 4.0 won\\'t let 3.85 be rank3)\\u3002\\nIn the sql\\uFF0Cwe left join the original table with itself and calculate distinct count of scores greater than the current value. And the rank of current value = this count+1 ",
                "solutionTags": [],
                "code": "```\\nSELECT Scores.Score ,COUNT(DISTINCT greater.Score)+1 AS Rank\\nFROM Scores\\nLEFT JOIN Scores greater ON greater.Score>Scores.Score\\nGROUP BY Scores.Id\\nORDER BY Rank\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 170610,
                "title": "using-dense-rank-387ms-sql-server",
                "content": "```select  Score, dense_rank() over (order by Score DESC) as Rank from Scores;```",
                "solutionTags": [],
                "code": "```select  Score, dense_rank() over (order by Score DESC) as Rank from Scores;```",
                "codeTag": "Unknown"
            },
            {
                "id": 143486,
                "title": "accepted-solution-looking-for-simplified-idea",
                "content": "SELECT Score, CAST(Rank AS UNSIGNED) AS Rank\\nFROM (\\n    SELECT Score, CASE \\n        WHEN @preScore = Score \\n        THEN @countRank \\n        ELSE @countRank := @countRank + 1 \\n        END AS Rank, @preScore := Score AS preScore\\n    FROM Scores AS s, (SELECT @countRank := 0, @preScore := NULL) AS p\\n    ORDER BY Score DESC) AS sr;\\n",
                "solutionTags": [],
                "code": "SELECT Score, CAST(Rank AS UNSIGNED) AS Rank\\nFROM (\\n    SELECT Score, CASE \\n        WHEN @preScore = Score \\n        THEN @countRank \\n        ELSE @countRank := @countRank + 1 \\n        END AS Rank, @preScore := Score AS preScore\\n    FROM Scores AS s, (SELECT @countRank := 0, @preScore := NULL) AS p\\n    ORDER BY Score DESC) AS sr;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 124148,
                "title": "184ms-solution-beats-100-submission-easy-to-understand",
                "content": "Runtime 184ms\\n\\nFirst, create a table with distinct score and generate new rank id from 1 to 4.\\nSecond, left join with Scores table on score, keep score and rank id, then order by rank.\\n\\n```\\nSelect Scores.score as Score, rank.rankid as Rank\\nfrom\\nscores left join\\n(select @rowid := @rowid + 1 as rankid, temp1.score\\nfrom \\n    (select distinct score from scores order by score desc) as temp1, \\n    (select @rowid:=0) as temp2) as rank\\non Scores.score = rank.score\\norder by Rank\\n```",
                "solutionTags": [],
                "code": "```\\nSelect Scores.score as Score, rank.rankid as Rank\\nfrom\\nscores left join\\n(select @rowid := @rowid + 1 as rankid, temp1.score\\nfrom \\n    (select distinct score from scores order by score desc) as temp1, \\n    (select @rowid:=0) as temp2) as rank\\non Scores.score = rank.score\\norder by Rank\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53147,
                "title": "my-accepted-solution",
                "content": "# Write your MySQL query statement below\\nselect a.Score, count(b.Score) as Rank\\nfrom Scores as a, \\n    (select distinct Score\\n     from Scores) as b\\nwhere a.Score <= b.Score\\ngroup by a.ID\\norder by a.Score desc\\n;",
                "solutionTags": [],
                "code": "# Write your MySQL query statement below\\nselect a.Score, count(b.Score) as Rank\\nfrom Scores as a, \\n    (select distinct Score\\n     from Scores) as b\\nwhere a.Score <= b.Score\\ngroup by a.ID\\norder by a.Score desc\\n;",
                "codeTag": "Unknown"
            },
            {
                "id": 53151,
                "title": "solution-accepted-by-the-sqlfiddle-but-get-runtime-error-in-oj",
                "content": "[http://www.sqlfiddle.com/#!2/dc9b4d/3][1]\\n\\n\\n  [1]: http://www.sqlfiddle.com/#!2/dc9b4d/3",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3983443,
                "title": "extremely-simple-solution-in-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT s1.score, count(s2.score) AS \\'rank\\'\\nFROM scores s1, (SELECT DISTINCT score FROM scores) s2\\nWHERE s2.score>=s1.Score\\nGROUP BY s1.Id \\nORDER BY s1.score DESC;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT s1.score, count(s2.score) AS \\'rank\\'\\nFROM scores s1, (SELECT DISTINCT score FROM scores) s2\\nWHERE s2.score>=s1.Score\\nGROUP BY s1.Id \\nORDER BY s1.score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3931507,
                "title": "pandas-2-easy-and-different-ways-to-solve",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\n**Method 1:**\\n```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    \\n    df = scores.sort_values(by=\\'score\\', ascending=False)\\n    \\n    rank = []\\n    max_score = 1e9\\n    curr_rank = 0\\n    \\n    for idx, row in df.iterrows():\\n        if row.score == max_score:\\n            rank.append(curr_rank)\\n        else:\\n            max_score = row.score\\n            curr_rank += 1\\n            rank.append(curr_rank)\\n            \\n    df[\\'rank\\'] = rank\\n    \\n    return df[[\\'score\\', \\'rank\\']]\\n```\\n\\n**Method 2:**\\n```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    \\n    scores[\\'rank\\'] = scores[\\'score\\'].rank(method=\\'dense\\', ascending=False)\\n    \\n    return scores[[\\'score\\', \\'rank\\']].sort_values(by=\\'score\\', ascending=False)\\n```\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    \\n    df = scores.sort_values(by=\\'score\\', ascending=False)\\n    \\n    rank = []\\n    max_score = 1e9\\n    curr_rank = 0\\n    \\n    for idx, row in df.iterrows():\\n        if row.score == max_score:\\n            rank.append(curr_rank)\\n        else:\\n            max_score = row.score\\n            curr_rank += 1\\n            rank.append(curr_rank)\\n            \\n    df[\\'rank\\'] = rank\\n    \\n    return df[[\\'score\\', \\'rank\\']]\\n```\n```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    \\n    scores[\\'rank\\'] = scores[\\'score\\'].rank(method=\\'dense\\', ascending=False)\\n    \\n    return scores[[\\'score\\', \\'rank\\']].sort_values(by=\\'score\\', ascending=False)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3678531,
                "title": "one-liner-solution-with-explanation",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nThe intuition behind the solution is to use the **dense_rank()** function to assign ranks to the scores in descending order, ensuring that higher scores receive lower ranks.\\n\\n\\n# Approach\\nTo solve the problem, we need to rank the scores in descending order and assign a rank to each score. Here\\'s how your SQL query accomplishes this:\\n\\n1. The SELECT statement is used to select the \"Score\" column from the \"Scores\" table. This retrieves all the scores from the table.\\n\\n1. The **DENSE_RANK() OVER (ORDER BY Score DESC)** function is used to calculate the rank of each score. The DENSE_RANK() function assigns the same rank to scores with the same value, and the ranks are determined based on the score values. The ORDER BY Score DESC part ensures that the scores are sorted in descending order before assigning the ranks.\\n\\n1. The result of the query includes both the \"Score\" and \"Rank\" columns. This means that for each score, you will see its corresponding rank in the output.\\n\\n1. The query handles the ranking and ordering of the scores for us, so we don\\'t need to manually implement any logic to determine the ranks. By using the **DENSE_RANK()** function, the query efficiently assigns ranks to the scores in descending order.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this approach is dependent on the number of scores in the Scores table and the efficiency of the DENSE_RANK() function. The time complexity is typically $$O(n log n)$$ or better, as it involves sorting the scores.\\n\\n- Space complexity:\\nThe space complexity is determined by the size of the input data (the Scores table) and the storage required for the result set. In this case, the space complexity is $$O(n)$$, where n is the number of scores in the table.\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank FROM Scores;\\n\\n```\\n***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/d3db36f0-8de0-4f9d-96d2-b38b6d7bf201_1687639061.1030006.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank FROM Scores;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3534148,
                "title": "direct-by-using-dense-rank-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect Score as score , (dense_rank() over(order by Score desc)) as \"rank\" from Scores;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect Score as score , (dense_rank() over(order by Score desc)) as \"rank\" from Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3171344,
                "title": "mysql-easy-approach",
                "content": "Here is my MYSQL code for this problem.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect score, dense_rank() over(order by score desc) as \"Rank\" from Scores;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect score, dense_rank() over(order by score desc) as \"Rank\" from Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2761644,
                "title": "simple-solution-two-approaches-sql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThanks for the question. I learned about Rank and Dense Rank functions in sql\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitially tried with the regular approach using subquery but came to know we can do quickly using rank function.\\n\\n\\n\\n\\n# Code\\n```\\n#Subquery\\nselect s1.score,(select count(distinct s2.score) from scores s2\\nwhere s2.score>=s1.score) \\'rank\\'\\nfrom scores s1\\norder by score desc\\n\\n#Functions\\nselect score, DENSE_RANK () OVER( Order by score desc ) \\'rank\\' \\nfrom scores \\norder by score desc\\n```\\n\\nPlease upvote if you find the solution useful :) Happy Learning!!",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n#Subquery\\nselect s1.score,(select count(distinct s2.score) from scores s2\\nwhere s2.score>=s1.score) \\'rank\\'\\nfrom scores s1\\norder by score desc\\n\\n#Functions\\nselect score, DENSE_RANK () OVER( Order by score desc ) \\'rank\\' \\nfrom scores \\norder by score desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2581831,
                "title": "simple-solution-mysql",
                "content": "```\\nselect score, dense_rank() over(order by score desc) as \\'Rank\\' from Scores;\\n```",
                "solutionTags": [],
                "code": "```\\nselect score, dense_rank() over(order by score desc) as \\'Rank\\' from Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2567630,
                "title": "using-dense-rank-in-single-select",
                "content": "**Upvote if you feel it easy :)**\\n```\\nSELECT score, DENSE_RANK() OVER(ORDER BY score DESC) as Rank\\nFROM Scores\\nORDER BY score DESC;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT score, DENSE_RANK() OVER(ORDER BY score DESC) as Rank\\nFROM Scores\\nORDER BY score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2555084,
                "title": "mysql-two-apparoches",
                "content": "```\\n-- approach 1 \\n# SELECT score, DENSE_RANK() OVER (ORDER BY score desc) as \"rank\"\\n# FROM scores;\\n\\n\\n-- approach 2 \\nSELECT s1.score,\\n     (SELECT count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\"\\nFROM scores s1\\norder by s1.score desc;",
                "solutionTags": [],
                "code": "```\\n-- approach 1 \\n# SELECT score, DENSE_RANK() OVER (ORDER BY score desc) as \"rank\"\\n# FROM scores;\\n\\n\\n-- approach 2 \\nSELECT s1.score,\\n     (SELECT count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\"\\nFROM scores s1\\norder by s1.score desc;",
                "codeTag": "Unknown"
            },
            {
                "id": 2451783,
                "title": "solution-with-proper-explanation-easy-to-understand",
                "content": "**Please  Press the ^ Star above**\\n\\nThere is RANK() and DENSE_RANK()\\n\\nUnlike the RANK() function, the DENSE_RANK() function returns consecutive rank values. Rows in each partition receive the same ranks if they have the same values.\\n\\n```\\nSELECT score , DENSE_RANK() OVER(ORDER BY score DESC) as \\'rank\\'\\nFROM Scores;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT score , DENSE_RANK() OVER(ORDER BY score DESC) as \\'rank\\'\\nFROM Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2446634,
                "title": "mysql-using-dense-rank-100-fast-solution",
                "content": "Simple, Short, Fast\\n\\n```\\nSELECT score,  \\n       DENSE_RANK() OVER(ORDER BY score DESC) as \\'rank\\'\\nFROM Scores;\\n```\\n\\nDo comment your suggestions!!",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT score,  \\n       DENSE_RANK() OVER(ORDER BY score DESC) as \\'rank\\'\\nFROM Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2397131,
                "title": "sql-server-one-line-dense-rank-easy-understanding",
                "content": "\\tSELECT SCORE , DENSE_RANK() OVER (ORDER BY SCORE DESC) AS RANK FROM Scores",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\tSELECT SCORE , DENSE_RANK() OVER (ORDER BY SCORE DESC) AS RANK FROM Scores",
                "codeTag": "Unknown"
            },
            {
                "id": 2203985,
                "title": "mysql-without-dense-rank-easy",
                "content": "```\\nselect s1.score, (select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\"\\nfrom scores s1 order by s1.score desc\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s1.score, (select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\"\\nfrom scores s1 order by s1.score desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2061067,
                "title": "simple-easy-mysql-solution-using-dense-rank",
                "content": "```\\nSELECT SCORE,\\nDENSE_RANK() OVER(ORDER BY SCORE DESC) AS \\'rank\\'\\nFROM SCORES;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT SCORE,\\nDENSE_RANK() OVER(ORDER BY SCORE DESC) AS \\'rank\\'\\nFROM SCORES;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2012104,
                "title": "ms-sql",
                "content": "Select A.score,B.rank FROM Scores A Inner JOIN \\n(Select score,ROW_NUMBER() OVER (ORDER BY score desc) as rank  FROM Scores A with(nolock) group by score ) B ON A.score = B.score\\norder by B.rank",
                "solutionTags": [],
                "code": "Select A.score,B.rank FROM Scores A Inner JOIN \\n(Select score,ROW_NUMBER() OVER (ORDER BY score desc) as rank  FROM Scores A with(nolock) group by score ) B ON A.score = B.score\\norder by B.rank",
                "codeTag": "Unknown"
            },
            {
                "id": 1974551,
                "title": "a-short-and-clean-solution-through-dense-rank",
                "content": "```\\nselect score, dense_rank() over (order by score desc) \\'rank\\'\\nfrom Scores\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect score, dense_rank() over (order by score desc) \\'rank\\'\\nfrom Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1971713,
                "title": "t-sql-3-ways-dense-rank-groupby-subquery",
                "content": "```\\n/* Write your T-SQL query statement below */\\n--select score, dense_rank() over (order by score desc) as rank from Scores order by 1 desc\\n--select score,  (select count(*) from (select distinct score from Scores) t where t.score>=s.score) rank from Scores s order by 1 desc\\nselect s.score, count(distinct t.score) as rank\\nfrom Scores s join Scores t on s.score<=t.score \\ngroup by s.id,s.score\\norder by 1 desc\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\n--select score, dense_rank() over (order by score desc) as rank from Scores order by 1 desc\\n--select score,  (select count(*) from (select distinct score from Scores) t where t.score>=s.score) rank from Scores s order by 1 desc\\nselect s.score, count(distinct t.score) as rank\\nfrom Scores s join Scores t on s.score<=t.score \\ngroup by s.id,s.score\\norder by 1 desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1860356,
                "title": "easy-to-understand-solution-no-window-function-no-subqueries",
                "content": "```\\nselect a.score , count(distinct b.score) rank\\nfrom scores a inner join scores b on b.score >= a.score\\ngroup by a.id , a.score \\norder by 2 asc\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nselect a.score , count(distinct b.score) rank\\nfrom scores a inner join scores b on b.score >= a.score\\ngroup by a.id , a.score \\norder by 2 asc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1793653,
                "title": "easy-ms-sql-dense-rank",
                "content": "select score, dense_rank() over (order by score desc) as rank from Scores",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "select score, dense_rank() over (order by score desc) as rank from Scores",
                "codeTag": "Unknown"
            },
            {
                "id": 1659612,
                "title": "solution",
                "content": "select score, dense_rank() over (order by score desc) as rank from Scores order by rank",
                "solutionTags": [],
                "code": "select score, dense_rank() over (order by score desc) as rank from Scores order by rank",
                "codeTag": "Unknown"
            },
            {
                "id": 1611930,
                "title": "use-dense-rank-with-mysql-very-simple",
                "content": "```\\nSELECT\\n    score, DENSE_RANK() OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM\\n    Scores\\n;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    score, DENSE_RANK() OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM\\n    Scores\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1600162,
                "title": "short-simple-using-dense-rank-224ms",
                "content": "simple and short answer using dense_rank()\\n```\\nselect score, dense_rank() over (order by score desc ) \"rank\" from scores;\\n```",
                "solutionTags": [],
                "code": "```\\nselect score, dense_rank() over (order by score desc ) \"rank\" from scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1588386,
                "title": "very-easy-solution-using-window-function",
                "content": "SELECT score, DENSE_RANK() OVER (ORDER BY Score DESC) as \\'rank\\' FROM scores",
                "solutionTags": [
                    "MySQL",
                    "Sliding Window"
                ],
                "code": "SELECT score, DENSE_RANK() OVER (ORDER BY Score DESC) as \\'rank\\' FROM scores",
                "codeTag": "Unknown"
            },
            {
                "id": 1581489,
                "title": "3-lines-using-dense-rank-384ms",
                "content": "**** i don\\'t know why the answers provided by y\\'all are so complicated. So complicated that I don\\'t even understand. Here is a simple solution that works.\\n```\\nselect score, \\ndense_rank() over (order by score desc) \\'rank\\'\\nfrom Scores\\n```",
                "solutionTags": [],
                "code": "```\\nselect score, \\ndense_rank() over (order by score desc) \\'rank\\'\\nfrom Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1512713,
                "title": "ms-sql",
                "content": "#### Question\\n````\\nSQL Schema\\nTable: Scores\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| Id          | int     |\\n| Score       | decimal |\\n+-------------+---------+\\nId is the primary key for this table.\\nEach row of this table contains the score of a game. Score is a floating point value with two decimal places.\\n \\n\\nWrite an SQL query to rank the scores. The ranking should be calculated according to the following rules:\\n\\nThe scores should be ranked from the highest to the lowest.\\nIf there is a tie between two scores, both should have the same ranking.\\nAfter a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no holes between ranks.\\nReturn the result table ordered by score in descending order.\\n\\nThe query result format is in the following example.\\n\\n \\n\\nExample 1:\\n\\nInput: \\nScores table:\\n+----+-------+\\n| Id | Score |\\n+----+-------+\\n| 1  | 3.50  |\\n| 2  | 3.65  |\\n| 3  | 4.00  |\\n| 4  | 3.85  |\\n| 5  | 4.00  |\\n| 6  | 3.65  |\\n+----+-------+\\nOutput: \\n+-------+------+\\n| Score | Rank |\\n+-------+------+\\n| 4.00  | 1    |\\n| 4.00  | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.50  | 4    |\\n+-------+------+\\n````\\n#### Answer\\n```\\nselect Score, dense_rank() over (order by Score desc) as Rank from Scores\\norder by Score desc\\n",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "````\\nSQL Schema\\nTable: Scores\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| Id          | int     |\\n| Score       | decimal |\\n+-------------+---------+\\nId is the primary key for this table.\\nEach row of this table contains the score of a game. Score is a floating point value with two decimal places.\\n \\n\\nWrite an SQL query to rank the scores. The ranking should be calculated according to the following rules:\\n\\nThe scores should be ranked from the highest to the lowest.\\nIf there is a tie between two scores, both should have the same ranking.\\nAfter a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no holes between ranks.\\nReturn the result table ordered by score in descending order.\\n\\nThe query result format is in the following example.\\n\\n \\n\\nExample 1:\\n\\nInput: \\nScores table:\\n+----+-------+\\n| Id | Score |\\n+----+-------+\\n| 1  | 3.50  |\\n| 2  | 3.65  |\\n| 3  | 4.00  |\\n| 4  | 3.85  |\\n| 5  | 4.00  |\\n| 6  | 3.65  |\\n+----+-------+\\nOutput: \\n+-------+------+\\n| Score | Rank |\\n+-------+------+\\n| 4.00  | 1    |\\n| 4.00  | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.50  | 4    |\\n+-------+------+\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1487318,
                "title": "without-dense-rank",
                "content": "```\\nSELECT s.score, l.rank \\nFROM scores s\\nLEFT JOIN (\\n    SELECT score, ROW_NUMBER() OVER (ORDER BY score DESC) AS rank \\n    FROM scores \\n    GROUP BY score\\n) l ON l.score=s.score\\nORDER BY s.score DESC;",
                "solutionTags": [],
                "code": "```\\nSELECT s.score, l.rank \\nFROM scores s\\nLEFT JOIN (\\n    SELECT score, ROW_NUMBER() OVER (ORDER BY score DESC) AS rank \\n    FROM scores \\n    GROUP BY score\\n) l ON l.score=s.score\\nORDER BY s.score DESC;",
                "codeTag": "Unknown"
            },
            {
                "id": 1423441,
                "title": "simple-dense-rank",
                "content": "select Score as score,\\n        dense_rank() over(order by Score desc) as \\'Rank\\'\\nfrom Scores\\norder by Score desc\\n",
                "solutionTags": [],
                "code": "select Score as score,\\n        dense_rank() over(order by Score desc) as \\'Rank\\'\\nfrom Scores\\norder by Score desc\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1383076,
                "title": "using-corelated-subqueries",
                "content": "```\\nSELECT score, (select count(distinct score) from scores s2 where s1.score<=s2.score ) AS \"Rank\"\\nFROM Scores s1 ORDER BY score DESC;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT score, (select count(distinct score) from scores s2 where s1.score<=s2.score ) AS \"Rank\"\\nFROM Scores s1 ORDER BY score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1362374,
                "title": "my-sql-sol-dense-rank",
                "content": "\\n\\n    select score , dense_rank() over(order by score desc) as `Rank`\\n    from scores",
                "solutionTags": [],
                "code": "\\n\\n    select score , dense_rank() over(order by score desc) as `Rank`\\n    from scores",
                "codeTag": "Unknown"
            },
            {
                "id": 1359601,
                "title": "steps-by-step-groupby-orderby-simple-and-crisp",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT S.Score, COUNT(S2.Score) as `Rank`\\nFROM Scores S,\\n(SELECT DISTINCT Score FROM Scores) S2\\nWHERE S.Score<=S2.Score\\nGROUP BY S.Id\\nORDER BY S.Score DESC;\\n\\n/*\\nSTEPS : \\n\\n1- create a new table s2 which contains all distinct salaries. ( LINE 3)\\n2- find the number of salaries which is >= entry created in step 1 ( LINE 4 )\\n3- group them on basis of id and sort them in desc order. (LINE 5-6)\\n4- Finally, display score and count of the score. ( Line 2 ).\\n*/",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT S.Score, COUNT(S2.Score) as `Rank`\\nFROM Scores S,\\n(SELECT DISTINCT Score FROM Scores) S2\\nWHERE S.Score<=S2.Score\\nGROUP BY S.Id\\nORDER BY S.Score DESC;\\n\\n/*\\nSTEPS : \\n\\n1- create a new table s2 which contains all distinct salaries. ( LINE 3)\\n2- find the number of salaries which is >= entry created in step 1 ( LINE 4 )\\n3- group them on basis of id and sort them in desc order. (LINE 5-6)\\n4- Finally, display score and count of the score. ( Line 2 ).\\n*/",
                "codeTag": "Unknown"
            },
            {
                "id": 1320960,
                "title": "join-286ms",
                "content": "\\n\\'\\'\\'\\nselect s1.Score, s2.Rank from Scores s1\\nleft join (\\n    select Score, row_number() over (order by Score desc) as \"Rank\" from Scores\\ngroup by Score) as s2 \\non s1.Score = s2.Score\\norder by s1.Score desc \\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\n\\'\\'\\'\\nselect s1.Score, s2.Rank from Scores s1\\nleft join (\\n    select Score, row_number() over (order by Score desc) as \"Rank\" from Scores\\ngroup by Score) as s2 \\non s1.Score = s2.Score\\norder by s1.Score desc \\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1217702,
                "title": "row-number-solution",
                "content": "```\\nselect s.Score, srn.rn as \\'rank\\'\\nfrom Scores s left join (select a.Score, row_number() over (order by a.Score desc) as rn\\n                         from (select distinct Score from Scores) a) srn\\non s.Score = srn.Score\\norder by Score desc\\n```\\n",
                "solutionTags": [],
                "code": "```\\nselect s.Score, srn.rn as \\'rank\\'\\nfrom Scores s left join (select a.Score, row_number() over (order by a.Score desc) as rn\\n                         from (select distinct Score from Scores) a) srn\\non s.Score = srn.Score\\norder by Score desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1158391,
                "title": "easy-2-line-solution-mysql",
                "content": "Select score, Dense_Rank() OVER(order by score DESC) as \\'Rank\\'\\nfrom Scores\\n",
                "solutionTags": [],
                "code": "Select score, Dense_Rank() OVER(order by score DESC) as \\'Rank\\'\\nfrom Scores\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1132103,
                "title": "mysql-subquery-and-inner-join-where-in",
                "content": "```\\nSELECT s.Score, rnk.Rank\\nFROM Scores s, (SELECT *, ROW_NUMBER() OVER (ORDER BY Score DESC) AS \\'Rank\\' FROM (SELECT DISTINCT Score FROM Scores) AS r2) AS rnk \\nWHERE s.Score=rnk.Score\\nORDER BY rnk.Rank ASC\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT s.Score, rnk.Rank\\nFROM Scores s, (SELECT *, ROW_NUMBER() OVER (ORDER BY Score DESC) AS \\'Rank\\' FROM (SELECT DISTINCT Score FROM Scores) AS r2) AS rnk \\nWHERE s.Score=rnk.Score\\nORDER BY rnk.Rank ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1095407,
                "title": "mysql-single-line",
                "content": "SELECT Score,  DENSE_RANK ()  OVER( ORDER BY Score desc) AS \\'Rank\\'\\nFROM Scores\\n",
                "solutionTags": [],
                "code": "SELECT Score,  DENSE_RANK ()  OVER( ORDER BY Score desc) AS \\'Rank\\'\\nFROM Scores\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1075937,
                "title": "simple-solution",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT score,\\nDENSE_RANK() OVER(ORDER BY score DESC) AS \\'Rank\\'\\nFROM Scores\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT score,\\nDENSE_RANK() OVER(ORDER BY score DESC) AS \\'Rank\\'\\nFROM Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1037049,
                "title": "easy-solution-only-use-rank-faster-than-96-memory-less-than-100",
                "content": "The difference in using between **dense_rank** or **rank** is that, the former one would consider the tied numbers only will take one position in the rank, while the later one would consider the tied numbers will take consecutive potitions in the rank, which will leave holes in the rank.\\n\\nEasy to understood coding part:\\n\\n```\\nselect score, dense_rank() over(order by score desc) as Rank\\nfrom scores\\norder by 1 desc\\n```\\nThis is the reference link for SQL RANK functions, very helpful:\\nhttps://www.sqlshack.com/overview-of-sql-rank-functions/",
                "solutionTags": [],
                "code": "```\\nselect score, dense_rank() over(order by score desc) as Rank\\nfrom scores\\norder by 1 desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1023926,
                "title": "dense-rank",
                "content": "```\\nSELECT\\n    score,\\n    DENSE_RANK() OVER(ORDER BY score DESC) AS \"rank\"\\nFROM\\n    scores\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    score,\\n    DENSE_RANK() OVER(ORDER BY score DESC) AS \"rank\"\\nFROM\\n    scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 820791,
                "title": "simple-mysql-solution",
                "content": "```\\nselect score, dense_rank() over(order by score desc) \\'Rank\\' from scores\\n```\\n",
                "solutionTags": [],
                "code": "```\\nselect score, dense_rank() over(order by score desc) \\'Rank\\' from scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 792226,
                "title": "360-ms-simple-solution",
                "content": "```\\nselect Score, \\n    (select count(s2.Score) \\n     from (select distinct Score from Scores) s2 \\n     where s2.Score >= s1.Score\\n    ) \\'Rank\\'\\nfrom Scores s1 \\norder by Score desc;",
                "solutionTags": [],
                "code": "```\\nselect Score, \\n    (select count(s2.Score) \\n     from (select distinct Score from Scores) s2 \\n     where s2.Score >= s1.Score\\n    ) \\'Rank\\'\\nfrom Scores s1 \\norder by Score desc;",
                "codeTag": "Unknown"
            },
            {
                "id": 759504,
                "title": "using-row-number",
                "content": "```\\n\\nSELECT d.score, e.rank FROM scores d INNER JOIN\\n(SELECT e.score, ROW_NUMBER() OVER( ORDER BY score DESC) `rank` \\nFROM (SELECT DISTINCT score FROM scores) e) e \\nON d.score=e.score\\nORDER BY d.score DESC;\\n```",
                "solutionTags": [],
                "code": "```\\n\\nSELECT d.score, e.rank FROM scores d INNER JOIN\\n(SELECT e.score, ROW_NUMBER() OVER( ORDER BY score DESC) `rank` \\nFROM (SELECT DISTINCT score FROM scores) e) e \\nON d.score=e.score\\nORDER BY d.score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 751692,
                "title": "with-out-dense-rank",
                "content": "```\\nselect a.score,count(distinct b.score) as \\'rank\\'\\nfrom scores a, scores b\\nwhere a.score<=b.score\\ngroup by a.id\\norder by 2\\n```",
                "solutionTags": [],
                "code": "```\\nselect a.score,count(distinct b.score) as \\'rank\\'\\nfrom scores a, scores b\\nwhere a.score<=b.score\\ngroup by a.id\\norder by 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 629140,
                "title": "easy-to-understand-mysql-with-explanation",
                "content": "First, we need 2 tables: The original table and another table where we only have distinct scores\\nTable A: `SELECT A.id, A.score FROM Scores A`\\nTable B: `SELECT DISTINCT(score) as score FROM Scores B`\\n\\nThen we JOIN both the tables where the scores from Table A <= Table B:\\n```\\nSELECT A.id, A.score, B.score\\nFROM Scores A JOIN (SELECT DISTINCT(score) as score FROM Scores) B ON A.score<=B.score\\nORDER BY A.id, A.score DESC, B.score ASC\\n```\\nThe trick here is where A.score <= B.score.\\n\\nNow, we GROUP BY A.id, COUNT B.score and lastly order A.score in descending order.\\n```\\nSELECT A.score as Score, COUNT(B.score) as \\'Rank\\'\\nFROM Scores A JOIN (SELECT DISTINCT(score) as score FROM Scores) B ON A.score<=B.score\\nGROUP BY A.id\\nORDER BY A.score DESC\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT A.id, A.score, B.score\\nFROM Scores A JOIN (SELECT DISTINCT(score) as score FROM Scores) B ON A.score<=B.score\\nORDER BY A.id, A.score DESC, B.score ASC\\n```\n```\\nSELECT A.score as Score, COUNT(B.score) as \\'Rank\\'\\nFROM Scores A JOIN (SELECT DISTINCT(score) as score FROM Scores) B ON A.score<=B.score\\nGROUP BY A.id\\nORDER BY A.score DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 619623,
                "title": "mysql-using-subquery",
                "content": "```\\nSELECT \\n    score,\\n    (SELECT COUNT(DISTINCT score) FROM scores WHERE score > s.score) + 1 AS \\'Rank\\'\\nFROM Scores s\\nORDER BY score DESC\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT \\n    score,\\n    (SELECT COUNT(DISTINCT score) FROM scores WHERE score > s.score) + 1 AS \\'Rank\\'\\nFROM Scores s\\nORDER BY score DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 508386,
                "title": "non-dense-rank-solution",
                "content": "\\n```\\nselect Score,\\n    (select COUNT(DISTINCT S2.Score)\\n    from Scores as S2\\n    where S2.Score > S1.Score) +1  as Rank\\nfrom Scores as S1\\norder by Rank\\n```",
                "solutionTags": [],
                "code": "```\\nselect Score,\\n    (select COUNT(DISTINCT S2.Score)\\n    from Scores as S2\\n    where S2.Score > S1.Score) +1  as Rank\\nfrom Scores as S1\\norder by Rank\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 501553,
                "title": "dense-rank",
                "content": "SELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank\\n    FROM Scores \\n    ORDER BY Score DESC",
                "solutionTags": [],
                "code": "SELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank\\n    FROM Scores \\n    ORDER BY Score DESC",
                "codeTag": "Unknown"
            },
            {
                "id": 491921,
                "title": "solution-use-dense-rank-not-rank",
                "content": "```\\nSELECT\\n        Score,\\n        dense_rank() OVER (ORDER BY SCORE DESC) AS Rank\\nfrom Scores\\n```\\n\\nYou want to use `dense_rank()` instead of `rank()` because using `rank()` does not account for ties.\\n\\n![image](https://assets.leetcode.com/users/mahnillas/image_1580162909.png)\\n",
                "solutionTags": [],
                "code": "```\\nSELECT\\n        Score,\\n        dense_rank() OVER (ORDER BY SCORE DESC) AS Rank\\nfrom Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 386393,
                "title": "let-s-just-use-dense-rank-and-call-it-a-day",
                "content": "Hello All!\\nHere\\'s a solution via Dense_Rank():\\n```\\nSELECT\\nScore as Score,\\ndense_rank() over(order by Score desc) as Rank\\nFROM Scores\\nORDER BY 2;\\n```\\nPS. I used MS SQL Server for this one.\\n\\nCheers,\\nGeorge John Jordan Thomas Aquinas Hayward, Optimist <br>\\nhttps://ghayward.github.io\\n\\n[![GJJTAHO](https://i.ibb.co/wBjBb4G/gjjtah.jpg)](https://ghayward.github.io)\\n\\nThe Lord Always Delivers",
                "solutionTags": [],
                "code": "```\\nSELECT\\nScore as Score,\\ndense_rank() over(order by Score desc) as Rank\\nFROM Scores\\nORDER BY 2;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 370393,
                "title": "ms-sql-with-and-without-dense-rank",
                "content": "```\\n\\nselect a.score,\\n        count(distinct b.score)AS rank\\n from Scores a\\n  inner join scores b\\n  on a.score<=b.score\\n group by a.id,a.score\\n order by score desc\\n\\n--with dense rank\\nselect \\n    Score,\\n    dense_rank() over (order by score desc) As Rank\\nfrom Scores\\norder by score desc\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "```\\n\\nselect a.score,\\n        count(distinct b.score)AS rank\\n from Scores a\\n  inner join scores b\\n  on a.score<=b.score\\n group by a.id,a.score\\n order by score desc\\n\\n--with dense rank\\nselect \\n    Score,\\n    dense_rank() over (order by score desc) As Rank\\nfrom Scores\\norder by score desc\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 331532,
                "title": "3-lines-easy-solution",
                "content": "```\\nSELECT Score,DENSE_RANK () OVER (ORDER BY Score DESC) AS Rank\\n  FROM Scores\\n ORDER BY Score DESC;",
                "solutionTags": [],
                "code": "```\\nSELECT Score,DENSE_RANK () OVER (ORDER BY Score DESC) AS Rank\\n  FROM Scores\\n ORDER BY Score DESC;",
                "codeTag": "Unknown"
            },
            {
                "id": 255124,
                "title": "easy-to-understand",
                "content": "```\\nSELECT Score, (\\n    SELECT COUNT(DISTINCT Score)\\n    FROM Scores\\n    WHERE Score >= s.Score\\n) as Rank\\nFROM Scores s\\nORDER BY Score desc\\n```\\n",
                "solutionTags": [],
                "code": "```\\nSELECT Score, (\\n    SELECT COUNT(DISTINCT Score)\\n    FROM Scores\\n    WHERE Score >= s.Score\\n) as Rank\\nFROM Scores s\\nORDER BY Score desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 203972,
                "title": "using-dense-rank",
                "content": "Elegant solution that works in all modern normal systems:\\n```\\nselect Score, \\ndense_rank() over (partition by Id order by Score) as Rank\\nfrom Scores\\n```",
                "solutionTags": [],
                "code": "```\\nselect Score, \\ndense_rank() over (partition by Id order by Score) as Rank\\nfrom Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 181899,
                "title": "ac-mysql-solution",
                "content": "First, we need a table which includes scores and the rank of the score.\\n```\\nSELECT Score, (SELECT COUNT(DISTINCT Score)  AS rank\\nFROM Scores\\nWHERE Score >= S1.Score) AS Rank\\nFROM Scores AS S1\\norder by Score desc\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT Score, (SELECT COUNT(DISTINCT Score)  AS rank\\nFROM Scores\\nWHERE Score >= S1.Score) AS Rank\\nFROM Scores AS S1\\norder by Score desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 179378,
                "title": "my-solution-is-75-ms",
                "content": "```\\nSELECT Score, \\n    (\\n        SELECT COUNT(DISTINCT b.Score) + 1 \\n        FROM Scores AS b \\n        WHERE b.Score > Scores.Score \\n        LIMIT 1\\n    ) AS Rank \\nFROM Scores order by Rank ;",
                "solutionTags": [],
                "code": "```\\nSELECT Score, \\n    (\\n        SELECT COUNT(DISTINCT b.Score) + 1 \\n        FROM Scores AS b \\n        WHERE b.Score > Scores.Score \\n        LIMIT 1\\n    ) AS Rank \\nFROM Scores order by Rank ;",
                "codeTag": "Unknown"
            },
            {
                "id": 172094,
                "title": "oracle-using-dense-rank",
                "content": "worked with Oracle. I just needed to round the decimal part of scores to 2\\n```select ROUND(sc.Score,2) Score, dense_rank() over (order by Score desc) Rank from Scores sc```",
                "solutionTags": [],
                "code": "```select ROUND(sc.Score,2) Score, dense_rank() over (order by Score desc) Rank from Scores sc```",
                "codeTag": "Unknown"
            },
            {
                "id": 136900,
                "title": "simple-approach",
                "content": "The following is an accepted and simple solution to the problem: \\n\\n1. Get a table of distinct scores ordered from highest to lowest. \\n2. Add a serial colum to the table from step 1, the values of the new column are incremented starting from zero and going down.\\n3. Merge the table from step 2 with the Scores table.\\n\\nExecution time < 200 ms. \\n\\n```\\nSELECT      Scores.Score, Rank \\nFROM        Scores \\nLEFT JOIN   (                                       -- Last: Join with original scores table on the score value.\\n                SELECT  Score, @a:=@a+1 Rank        -- Second: Add column of serial values starting from 1 to the ordered scores.\\n                FROM    (                           -- First: Get table of distinct scores ordered from highest to lowers.\\n                            SELECT DISTINCT Score\\n                            FROM Scores\\n                            ORDER BY Score DESC\\n                        ) AS orderedScores, (SELECT @a:= 0) AS a\\n            ) AS rankedScores ON (rankedScores.Score = Scores.Score)\\nORDER BY    Scores.Score DESC\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nSELECT      Scores.Score, Rank \\nFROM        Scores \\nLEFT JOIN   (                                       -- Last: Join with original scores table on the score value.\\n                SELECT  Score, @a:=@a+1 Rank        -- Second: Add column of serial values starting from 1 to the ordered scores.\\n                FROM    (                           -- First: Get table of distinct scores ordered from highest to lowers.\\n                            SELECT DISTINCT Score\\n                            FROM Scores\\n                            ORDER BY Score DESC\\n                        ) AS orderedScores, (SELECT @a:= 0) AS a\\n            ) AS rankedScores ON (rankedScores.Score = Scores.Score)\\nORDER BY    Scores.Score DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 117265,
                "title": "dense-rank-throwing-error",
                "content": "```SELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank FROM Scores ORDER BY Score DESC; ```\n\nTrying to use Dense Rank function but keep getting this error - \"Line 1: SyntaxError: near '(ORDER BY Score DESC) AS Rank FROM Scores ORDER BY Score DESC\". Although the query works fine in sql server.",
                "solutionTags": [],
                "code": "```SELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank FROM Scores ORDER BY Score DESC; ```",
                "codeTag": "Unknown"
            },
            {
                "id": 3860654,
                "title": "pandas-dense-rank",
                "content": "```\\nimport pandas as pd\\n\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    scores[\\'rank\\'] = (\\n        scores\\n        .score\\n        .rank(method=\\'dense\\', ascending=False)\\n        .astype(int)\\n    )\\n\\n    scores.sort_values(\\'score\\', inplace=True, ascending=False)\\n\\n    return scores[[\\'score\\', \\'rank\\']]\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    scores[\\'rank\\'] = (\\n        scores\\n        .score\\n        .rank(method=\\'dense\\', ascending=False)\\n        .astype(int)\\n    )\\n\\n    scores.sort_values(\\'score\\', inplace=True, ascending=False)\\n\\n    return scores[[\\'score\\', \\'rank\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3629436,
                "title": "178-rank-scores-java",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT s1.Score , \\n(SELECT COUNT(DISTINCT score) from Scores s2 where s1.score<=s2.score) as `Rank`\\nfrom Scores s1\\norder by s1.score desc;\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT s1.Score , \\n(SELECT COUNT(DISTINCT score) from Scores s2 where s1.score<=s2.score) as `Rank`\\nfrom Scores s1\\norder by s1.score desc;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3245773,
                "title": "using-different-types-of-window-functions",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\n\\n    SELECT score,\\n    DENSE_RANK() OVER(ORDER BY score DESC) AS \\'rank\\'\\n    FROM Scores\\n```\\n# DENSE_RANK()\\nDENSE_RANK() is a window function in SQL that is used to calculate the rank of each row within a result set. It works similarly to the RANK() function, but unlike RANK(), DENSE_RANK() doesn\\'t leave gaps between the ranks when there are ties.\\n\\nHere\\'s an example to illustrate the difference between RANK() and DENSE_RANK(). Suppose we have the following table:\\n\\n```\\n+------+-------+\\n| id   | score |\\n+------+-------+\\n| 1    | 90    |\\n| 2    | 85    |\\n| 3    | 80    |\\n| 4    | 80    |\\n| 5    | 75    |\\n+------+-------+\\n```\\nIf we use RANK() to calculate the ranks of the scores, we get the following:\\n\\n```\\nSELECT score, RANK() OVER (ORDER BY score DESC) AS \\'rank\\' FROM Scores;\\n```\\n\\n```\\n+-------+------+\\n| score | rank |\\n+-------+------+\\n| 90    | 1    |\\n| 85    | 2    |\\n| 80    | 3    |\\n| 80    | 3    |\\n| 75    | 5    |\\n+-------+------+\\n```\\nAs you can see, there is a gap between ranks 2 and 3 because there is a tie between scores 80 and 80.\\n\\nIf we use DENSE_RANK() instead, we get the following:\\n\\n\\n```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) AS \\'rank\\' FROM Scores;\\n```\\n\\n```\\n+-------+------+\\n| score | rank |\\n+-------+------+\\n| 90    | 1    |\\n| 85    | 2    |\\n| 80    | 3    |\\n| 80    | 3    |\\n| 75    | 4    |\\n+-------+------+\\n```\\nAs you can see, DENSE_RANK() assigns the same rank to the tied scores (80 and 80) and doesn\\'t leave any gaps between ranks.\\n\\nIn summary, DENSE_RANK() is a window function that calculates the rank of each row in a result set, but doesn\\'t leave gaps between the ranks when there are ties.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n    SELECT score,\\n    DENSE_RANK() OVER(ORDER BY score DESC) AS \\'rank\\'\\n    FROM Scores\\n```\n```\\n+------+-------+\\n| id   | score |\\n+------+-------+\\n| 1    | 90    |\\n| 2    | 85    |\\n| 3    | 80    |\\n| 4    | 80    |\\n| 5    | 75    |\\n+------+-------+\\n```\n```\\nSELECT score, RANK() OVER (ORDER BY score DESC) AS \\'rank\\' FROM Scores;\\n```\n```\\n+-------+------+\\n| score | rank |\\n+-------+------+\\n| 90    | 1    |\\n| 85    | 2    |\\n| 80    | 3    |\\n| 80    | 3    |\\n| 75    | 5    |\\n+-------+------+\\n```\n```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) AS \\'rank\\' FROM Scores;\\n```\n```\\n+-------+------+\\n| score | rank |\\n+-------+------+\\n| 90    | 1    |\\n| 85    | 2    |\\n| 80    | 3    |\\n| 80    | 3    |\\n| 75    | 4    |\\n+-------+------+\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2751622,
                "title": "dense-rank-solution",
                "content": "SELECT score, DENSE_RANK() OVER(ORDER BY score DESC) \"rank\"\\nFROM scores\\nORDER BY score DESC\\n\\nHere we just have to mention the rank in the \"\" as the rank word is a keyword and cannot be used as a identifier in MySQL. so to explicitly use it as an identifier we have to mention it in \"\".",
                "solutionTags": [],
                "code": "SELECT score, DENSE_RANK() OVER(ORDER BY score DESC) \"rank\"\\nFROM scores\\nORDER BY score DESC\\n\\nHere we just have to mention the rank in the \"\" as the rank word is a keyword and cannot be used as a identifier in MySQL. so to explicitly use it as an identifier we have to mention it in \"\".",
                "codeTag": "Unknown"
            },
            {
                "id": 2718259,
                "title": "mysql-ranking-functions-implementation-and-explanation",
                "content": "### Ranking functions in MySQL\\n\\n```\\nSELECT score, dense_rank() OVER (\\n                ORDER BY score DESC\\n            ) AS \\'rank\\'\\nFROM Scores;\\n```\\n\\n***REFERENCE***\\n[https://www.sqlshack.com/overview-of-sql-rank-functions/](http://)\\n***about ROWNUMBER(), RANK(), denserank(), NTILE(N)\\n\\nWe use DENSERANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\n\\nIn the SQL RANK function DENSERANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nLet\\u2019s execute the following query with the DENSERANK() function.\\n```\\nSELECT Studentname, \\n       Subject, \\n       Marks, \\n       DENSERANK() OVER(ORDER BY Marks DESC) Rank\\nFROM ExamResult\\nORDER BY Rank;\\n```\\nIn the output, you can see we have the same rank for both Lily and Isabella who scored 70 marks.***\\n\\n![image](https://assets.leetcode.com/users/images/8a8c58ed-64ee-40a5-b59a-efd8a59576d6_1666098734.50629.png)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT score, dense_rank() OVER (\\n                ORDER BY score DESC\\n            ) AS \\'rank\\'\\nFROM Scores;\\n```\n```\\nSELECT Studentname, \\n       Subject, \\n       Marks, \\n       DENSERANK() OVER(ORDER BY Marks DESC) Rank\\nFROM ExamResult\\nORDER BY Rank;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2639499,
                "title": "faster-easy-to-understand-dense-rank",
                "content": "* ***Using dense_rank()***\\n\\n```\\nselect score,\\ndense_rank() over(order by score desc) as \\'rank\\'\\nfrom Scores;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect score,\\ndense_rank() over(order by score desc) as \\'rank\\'\\nfrom Scores;\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1570638,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1567130,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1567547,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1570938,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1567402,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1569773,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1568565,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1568567,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1567902,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1570217,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1570638,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1567130,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1567547,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1570938,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1567402,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1569773,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1568565,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1568567,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1567902,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1570217,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1569713,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1569526,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1729657,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1576958,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1576930,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1576917,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1576809,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1576503,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1576418,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1576323,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1575483,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1575471,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1574629,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1574578,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1574096,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1574066,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1573703,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1576441,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1573457,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1573167,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1573163,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 1572465,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 1572400,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 1572317,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 1572085,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 1570731,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 1575671,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 1573030,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 2045169,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 2036550,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 2030245,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 2012878,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 1937632,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 1921264,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 1880387,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 1812246,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 1811065,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 1787452,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 1774146,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 1773269,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 1773252,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            },
            {
                "id": 1766060,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            },
            {
                "id": 1752287,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            },
            {
                "id": 1751074,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            },
            {
                "id": 1745965,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            },
            {
                "id": 1741770,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            },
            {
                "id": 1722521,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            },
            {
                "id": 1716289,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            },
            {
                "id": 1575697,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            },
            {
                "id": 1576399,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            }
        ]
    }
]