[
    {
        "title": "Letter Case Permutation",
        "question_content": "Given a string s, you&nbsp;can transform every letter individually to be lowercase or uppercase to create another string.\nReturn a list of all possible strings we could create. Return the output in any order.\n&nbsp;\nExample 1:\n\nInput: s = \"a1b2\"\nOutput: [\"a1b2\",\"a1B2\",\"A1b2\",\"A1B2\"]\n\nExample 2:\n\nInput: s = \"3z4\"\nOutput: [\"3z4\",\"3Z4\"]\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 12\n\ts consists of lowercase English letters, uppercase English letters, and digits.",
        "solutions": [
            {
                "id": 115485,
                "title": "java-easy-bfs-dfs-solution-with-explanation",
                "content": "When I saw a problem, my first step is to draw a figure. See the figure below:\\n ` abc`  \\n`  abc  Abc`     0\\n ` abc aBc  Abc ABc`    1\\n`abc abC  aBc  aBC  Abc  AbC  ABc  ABC`   2\\n\\nThere we go! Is that a typical BFS/DFS problem? Yes, you are right!\\nBe careful to check whether a character is a digit or a letter(lower case or upper case).\\n`BFS Solution:`\\n```\\nclass Solution {\\n    public List<String> letterCasePermutation(String S) {\\n        if (S == null) {\\n            return new LinkedList<>();\\n        }\\n        Queue<String> queue = new LinkedList<>();\\n        queue.offer(S);\\n        \\n        for (int i = 0; i < S.length(); i++) {\\n            if (Character.isDigit(S.charAt(i))) continue;            \\n            int size = queue.size();\\n            for (int j = 0; j < size; j++) {\\n                String cur = queue.poll();\\n                char[] chs = cur.toCharArray();\\n                \\n                chs[i] = Character.toUpperCase(chs[i]);\\n                queue.offer(String.valueOf(chs));\\n                \\n                chs[i] = Character.toLowerCase(chs[i]);\\n                queue.offer(String.valueOf(chs));\\n            }\\n        }\\n        \\n        return new LinkedList<>(queue);\\n    }\\n}\\n```\\n\\n`DFS Solution:`\\n```\\nclass Solution {\\n    public List<String> letterCasePermutation(String S) {\\n        if (S == null) {\\n            return new LinkedList<>();\\n        }\\n        \\n        List<String> res = new LinkedList<>();\\n        helper(S.toCharArray(), res, 0);\\n        return res;\\n    }\\n    \\n    public void helper(char[] chs, List<String> res, int pos) {\\n        if (pos == chs.length) {\\n            res.add(new String(chs));\\n            return;\\n        }\\n        if (chs[pos] >= \\'0\\' && chs[pos] <= \\'9\\') {\\n            helper(chs, res, pos + 1);\\n            return;\\n        }\\n        \\n        chs[pos] = Character.toLowerCase(chs[pos]);\\n        helper(chs, res, pos + 1);\\n        \\n        chs[pos] = Character.toUpperCase(chs[pos]);\\n        helper(chs, res, pos + 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> letterCasePermutation(String S) {\\n        if (S == null) {\\n            return new LinkedList<>();\\n        }\\n        Queue<String> queue = new LinkedList<>();\\n        queue.offer(S);\\n        \\n        for (int i = 0; i < S.length(); i++) {\\n            if (Character.isDigit(S.charAt(i))) continue;            \\n            int size = queue.size();\\n            for (int j = 0; j < size; j++) {\\n                String cur = queue.poll();\\n                char[] chs = cur.toCharArray();\\n                \\n                chs[i] = Character.toUpperCase(chs[i]);\\n                queue.offer(String.valueOf(chs));\\n                \\n                chs[i] = Character.toLowerCase(chs[i]);\\n                queue.offer(String.valueOf(chs));\\n            }\\n        }\\n        \\n        return new LinkedList<>(queue);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<String> letterCasePermutation(String S) {\\n        if (S == null) {\\n            return new LinkedList<>();\\n        }\\n        \\n        List<String> res = new LinkedList<>();\\n        helper(S.toCharArray(), res, 0);\\n        return res;\\n    }\\n    \\n    public void helper(char[] chs, List<String> res, int pos) {\\n        if (pos == chs.length) {\\n            res.add(new String(chs));\\n            return;\\n        }\\n        if (chs[pos] >= \\'0\\' && chs[pos] <= \\'9\\') {\\n            helper(chs, res, pos + 1);\\n            return;\\n        }\\n        \\n        chs[pos] = Character.toLowerCase(chs[pos]);\\n        helper(chs, res, pos + 1);\\n        \\n        chs[pos] = Character.toUpperCase(chs[pos]);\\n        helper(chs, res, pos + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 115515,
                "title": "c-backtrack-solution-w-trick",
                "content": "Straightforward recursive solution. Simple trick with case toggling.\nThanks @shiowen for noticing redundant lines.\n```\nclass Solution {\n    void backtrack(string &s, int i, vector<string> &res) {\n        if (i == s.size()) {\n            res.push_back(s);\n            return;\n        }\n        backtrack(s, i + 1, res);\n        if (isalpha(s[i])) {\n            // toggle case\n            s[i] ^= (1 << 5);\n            backtrack(s, i + 1, res);\n        }\n    }\npublic:\n    vector<string> letterCasePermutation(string S) {\n        vector<string> res;\n        backtrack(S, 0, res);\n        return res;\n    }\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    void backtrack(string &s, int i, vector<string> &res) {\n        if (i == s.size()) {\n            res.push_back(s);\n            return;\n        }\n        backtrack(s, i + 1, res);\n        if (isalpha(s[i])) {\n            // toggle case\n            s[i] ^= (1 << 5);\n            backtrack(s, i + 1, res);\n        }\n    }\npublic:\n    vector<string> letterCasePermutation(string S) {\n        vector<string> res;\n        backtrack(S, 0, res);\n        return res;\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 255071,
                "title": "java-detailed-explanation-of-dfs-backtracking-solution",
                "content": "```\\nclass Solution {\\n    /**  \\n            a1b2   i=0, when it\\'s at a, since it\\'s a letter, we have two branches: a, A\\n         /        \\\\\\n       a1b2       A1b2 i=1 when it\\'s at 1, we only have 1 branch which is itself\\n        |          |   \\n       a1b2       A1b2 i=2 when it\\'s at b, we have two branches: b, B\\n       /  \\\\        / \\\\\\n      a1b2 a1B2  A1b2 A1B2 i=3  when it\\'s at 2, we only have one branch.\\n       |    |     |     |\\n      a1b2 a1B2  A1b2  A1B2 i=4 = S.length(). End recursion, add permutation to ans. \\n      \\n      During this process, we are changing the S char array itself\\n    */\\n    public List<String> letterCasePermutation(String S) {\\n        List<String> ans = new ArrayList<>();\\n        backtrack(ans, 0, S.toCharArray());\\n        return ans;\\n    }\\n    public void backtrack(List<String> ans, int i, char[] S){\\n        if(i==S.length)\\n            ans.add(new String(S));\\n        else{\\n            if(Character.isLetter(S[i])){ //If it\\'s letter\\n                S[i] = Character.toUpperCase(S[i]);\\n                backtrack(ans, i+1, S); //Upper case branch\\n                S[i] = Character.toLowerCase(S[i]);\\n                backtrack(ans, i+1, S); //Lower case branch\\n            }\\n            else\\n                backtrack(ans, i+1, S); \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    /**  \\n            a1b2   i=0, when it\\'s at a, since it\\'s a letter, we have two branches: a, A\\n         /        \\\\\\n       a1b2       A1b2 i=1 when it\\'s at 1, we only have 1 branch which is itself\\n        |          |   \\n       a1b2       A1b2 i=2 when it\\'s at b, we have two branches: b, B\\n       /  \\\\        / \\\\\\n      a1b2 a1B2  A1b2 A1B2 i=3  when it\\'s at 2, we only have one branch.\\n       |    |     |     |\\n      a1b2 a1B2  A1b2  A1B2 i=4 = S.length(). End recursion, add permutation to ans. \\n      \\n      During this process, we are changing the S char array itself\\n    */\\n    public List<String> letterCasePermutation(String S) {\\n        List<String> ans = new ArrayList<>();\\n        backtrack(ans, 0, S.toCharArray());\\n        return ans;\\n    }\\n    public void backtrack(List<String> ans, int i, char[] S){\\n        if(i==S.length)\\n            ans.add(new String(S));\\n        else{\\n            if(Character.isLetter(S[i])){ //If it\\'s letter\\n                S[i] = Character.toUpperCase(S[i]);\\n                backtrack(ans, i+1, S); //Upper case branch\\n                S[i] = Character.toLowerCase(S[i]);\\n                backtrack(ans, i+1, S); //Lower case branch\\n            }\\n            else\\n                backtrack(ans, i+1, S); \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 379928,
                "title": "python-clear-solution",
                "content": "```\\nclass Solution(object):\\n    def letterCasePermutation(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: List[str]\\n        \"\"\"\\n        def backtrack(sub=\"\", i=0):\\n            if len(sub) == len(S):\\n                res.append(sub)\\n            else:\\n                if S[i].isalpha():\\n                    backtrack(sub + S[i].swapcase(), i + 1)\\n                backtrack(sub + S[i], i + 1)\\n                \\n        res = []\\n        backtrack()\\n        return res\\n```\\nExample of handling an input \"hey\":\\n![image](https://assets.leetcode.com/users/denyscoder/image_1587071153.png)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def letterCasePermutation(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: List[str]\\n        \"\"\"\\n        def backtrack(sub=\"\", i=0):\\n            if len(sub) == len(S):\\n                res.append(sub)\\n            else:\\n                if S[i].isalpha():\\n                    backtrack(sub + S[i].swapcase(), i + 1)\\n                backtrack(sub + S[i], i + 1)\\n                \\n        res = []\\n        backtrack()\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 115509,
                "title": "python-simple-solution-7-lines",
                "content": "```\ndef letterCasePermutation(self, S):\n        res = ['']\n        for ch in S:\n            if ch.isalpha():\n                res = [i+j for i in res for j in [ch.upper(), ch.lower()]]\n            else:\n                res = [i+ch for i in res]\n        return res\n```",
                "solutionTags": [],
                "code": "```\ndef letterCasePermutation(self, S):\n        res = ['']\n        for ch in S:\n            if ch.isalpha():\n                res = [i+j for i in res for j in [ch.upper(), ch.lower()]]\n            else:\n                res = [i+ch for i in res]\n        return res\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1068157,
                "title": "c-recursion-o-2-n-0ms-beats-100-easy-to-understand",
                "content": "**EXPLANATION**\\nConsider the below **recursion tree** for input string **S=\"a1b2\"**\\nInitially **OUTPUT = \"\"**.\\n![image](https://assets.leetcode.com/users/images/fc249302-67d8-40fb-8b3a-9c88b5ab213e_1613469296.795427.png)\\nBy observing the above recursion tree, we come to the below *conclusion*.\\n\\nThere are two main *cases* which needs to be solved **recursively**:\\n- The element at the given index is a **digit**\\n\\t- Append the digit to the end of ```curr``` and go to *next index(i+1)*.\\n\\t\\n\\t\\t```\\n\\t\\tcurr.push_back(s[i]);\\n\\t\\tsolve(curr,s,i+1);\\n\\t\\t```\\n- The element at the given index is an **alphabet**, this case has two *sub cases*:\\n\\t- Append ```tolower(s[i])``` to ```curr``` and go to *next index (i+1)*.\\n\\t\\n\\t\\t```\\n\\t\\t//sub case 1, considering lower case\\n\\t\\tstring c1=curr;\\n\\t\\tc1.push_back(tolower(s[i]));\\n\\t\\tsolve(c1,s,i+1);\\n\\t\\t```\\n\\t- Append ```toupper(s[i])``` to ```curr``` and go to *next index (i+1)*.\\n\\t\\n\\t\\t```\\n\\t\\t//sub case 2, considering upper case\\n\\t\\tstring c2=curr;\\n\\t\\tc2.push_back(toupper(s[i]));\\n\\t\\tsolve(c2,s,i+1);\\n\\t\\t```\\n\\n- If at any function call, the ```index = S.length()```, then ```curr``` string has one of our **output**, so save it in ```ans``` vector,\\n\\n\\t```\\n\\t// if end of the string is reached\\n\\tif(i==s.length()){\\n\\t\\tans.push_back(curr); // push the current \"curr\" string to ans\\n\\t\\treturn;\\n\\t}\\n\\t```\\n- At the end of the recursion return ```ans```.\\n\\n**COMPLETE CODE**\\n```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    void solve(string curr,string s, int i){\\n        // if end of the string is reached\\n        if(i==s.length()){\\n            ans.push_back(curr); // push the current \"curr\" string to ans\\n            return;\\n        }\\n        \\n        if(isdigit(s[i])){ // case 1\\n            curr.push_back(s[i]);\\n            solve(curr,s,i+1);\\n        }\\n        else{ // case 2\\n            //sub case 1, considering lower case\\n            string c1=curr;\\n            c1.push_back(tolower(s[i]));\\n            solve(c1,s,i+1);\\n            \\n            //sub case 2, considering upper case\\n            string c2=curr;\\n            c2.push_back(toupper(s[i]));\\n            solve(c2,s,i+1);\\n        }\\n    }\\n    \\n    vector<string> letterCasePermutation(string S) {\\n        ans.clear();\\n        solve(\"\",S,0);\\n        return ans;\\n    }\\n};\\n```\\n\\nConsidering n = S.length(), [maximum word length of output]\\nAlso, maximum number of alphabetical characters in the string ```S``` = n.\\n\\n**TIME COMPLEXITY**\\n**O(2^n)** [*From recursion tree, at each level nodes are increasing by power of 2*]\\n\\n**SPACE COMPLEXITY**\\n**O(n)** [*Maximum depth of recursion tree*]",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```curr```\n```\\n\\t\\tcurr.push_back(s[i]);\\n\\t\\tsolve(curr,s,i+1);\\n\\t\\t```\n```tolower(s[i])```\n```curr```\n```\\n\\t\\t//sub case 1, considering lower case\\n\\t\\tstring c1=curr;\\n\\t\\tc1.push_back(tolower(s[i]));\\n\\t\\tsolve(c1,s,i+1);\\n\\t\\t```\n```toupper(s[i])```\n```curr```\n```\\n\\t\\t//sub case 2, considering upper case\\n\\t\\tstring c2=curr;\\n\\t\\tc2.push_back(toupper(s[i]));\\n\\t\\tsolve(c2,s,i+1);\\n\\t\\t```\n```index = S.length()```\n```curr```\n```ans```\n```\\n\\t// if end of the string is reached\\n\\tif(i==s.length()){\\n\\t\\tans.push_back(curr); // push the current \"curr\" string to ans\\n\\t\\treturn;\\n\\t}\\n\\t```\n```ans```\n```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    void solve(string curr,string s, int i){\\n        // if end of the string is reached\\n        if(i==s.length()){\\n            ans.push_back(curr); // push the current \"curr\" string to ans\\n            return;\\n        }\\n        \\n        if(isdigit(s[i])){ // case 1\\n            curr.push_back(s[i]);\\n            solve(curr,s,i+1);\\n        }\\n        else{ // case 2\\n            //sub case 1, considering lower case\\n            string c1=curr;\\n            c1.push_back(tolower(s[i]));\\n            solve(c1,s,i+1);\\n            \\n            //sub case 2, considering upper case\\n            string c2=curr;\\n            c2.push_back(toupper(s[i]));\\n            solve(c2,s,i+1);\\n        }\\n    }\\n    \\n    vector<string> letterCasePermutation(string S) {\\n        ans.clear();\\n        solve(\"\",S,0);\\n        return ans;\\n    }\\n};\\n```\n```S```",
                "codeTag": "Java"
            },
            {
                "id": 115544,
                "title": "python-easy-2-line-solution",
                "content": "```\\n    def letterCasePermutation(self, S):\\n        L = [set([i.lower(), i.upper()]) for i in S]\\n        return map(\\'\\'.join, itertools.product(*L))",
                "solutionTags": [],
                "code": "```\\n    def letterCasePermutation(self, S):\\n        L = [set([i.lower(), i.upper()]) for i in S]\\n        return map(\\'\\'.join, itertools.product(*L))",
                "codeTag": "Python3"
            },
            {
                "id": 115508,
                "title": "java-solution-using-recursion",
                "content": "**Update:** No need to use a set to handle duplicate values. Thanks to @[yik_wai](https://leetcode.com/yik_wai/) for the suggestion :)\n\n1. As soon as you find a letter character at index, check for all its possible combinations by making it a lower case character and an upper case character. \n2. Add the new char array at the at the end of each recursion.\n\nExample: S=\"a1b2\"\nRecursion Tree:\n<img src=\"https://image.ibb.co/dO9vMS/aa.jpg\" alt=\"aa\" border=\"0\" />\n\n```\nclass Solution {\n    public List<String> letterCasePermutation(String S) {\n        List<String> ans=new ArrayList<>();\n        compute(ans,S.toCharArray(),0);\n        return ans;\n    }\n    \n    public void compute(List<String> ans, char[] chars, int index)\n    {\n        if(index==chars.length)\n            ans.add(new String(chars));\n        else\n        {\n            if(Character.isLetter(chars[index]))\n            {\n                chars[index]=Character.toLowerCase(chars[index]);\n                compute(ans,chars,index+1);\n                chars[index]=Character.toUpperCase(chars[index]);\n            }\n            compute(ans,chars,index+1);\n        }\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public List<String> letterCasePermutation(String S) {\n        List<String> ans=new ArrayList<>();\n        compute(ans,S.toCharArray(),0);\n        return ans;\n    }\n    \n    public void compute(List<String> ans, char[] chars, int index)\n    {\n        if(index==chars.length)\n            ans.add(new String(chars));\n        else\n        {\n            if(Character.isLetter(chars[index]))\n            {\n                chars[index]=Character.toLowerCase(chars[index]);\n                compute(ans,chars,index+1);\n                chars[index]=Character.toUpperCase(chars[index]);\n            }\n            compute(ans,chars,index+1);\n        }\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 170083,
                "title": "5-line-iterative-python",
                "content": "```python\\n    def letterCasePermutation(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: List[str]\\n        \"\"\"\\n        res = [S]\\n        for i, c in enumerate(S):\\n            if c.isalpha():\\n                res.extend([s[:i] + s[i].swapcase() + s[i+1:] for s in res])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\n    def letterCasePermutation(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: List[str]\\n        \"\"\"\\n        res = [S]\\n        for i, c in enumerate(S):\\n            if c.isalpha():\\n                res.extend([s[:i] + s[i].swapcase() + s[i+1:] for s in res])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1068812,
                "title": "java-backtracking-with-recursion-tree-diagram-1ms-beats-100",
                "content": "This problem is a good example of one solved using recursion and backtracking. \\nFor every letter that can be transformed (upper case to lower case and vice versa), you have to explore both options (with transformation, and without).\\n\\nSo, we make the change, and start a branch of recursion down that path. Then, we undo the change, to explore options that are possible only if we had not done that change.\\n\\nHere is a visualization of the recursion tree for the string \"a1b2\" (one of the sample test cases).\\nThe text inside each node is what the current instance of the recursion function sees when it is invoked.\\nThe underlined character is the one being considered.\\n![image](https://assets.leetcode.com/users/images/8dfd8110-ff26-43ba-89f5-b51a0a125a3f_1613506588.0345485.png)\\n\\n\\n\\n```java\\nclass Solution {\\n    \\n    void recurse(char[] str, int pos, List<String> result) {\\n        //If we have reached a leaf in the recursion tree, save the result.\\n        if (pos == str.length) {\\n            result.add(new String(str));\\n            return;\\n        }\\n        \\n        //If char is not a letter, no processing required.\\n        if (Character.isLetter(str[pos])) {\\n            //If uppercase char, we make it lower case, and recurse.\\n            if (Character.isUpperCase(str[pos])) {\\n                str[pos] = Character.toLowerCase(str[pos]);\\n                \\n                //Start a new branch in the recursion tree, exploring options that are possible only if we had changed the case.\\n                recurse(str, pos + 1, result);\\n                \\n                //Backtracking. We undo the change so that we can start a new branch in the recursion tree.\\n                str[pos] = Character.toUpperCase(str[pos]);\\n            }\\n            //If lowercase, then we make it upper case, and recurse.\\n            else {\\n                str[pos] = Character.toUpperCase(str[pos]);\\n                recurse(str, pos + 1, result);\\n                //Backtracking as explained above.\\n                str[pos] = Character.toLowerCase(str[pos]);\\n            }\\n        }\\n        //This branch explores options that are possible only if the previously performed change (if any) hadn\\'t happened.\\n        recurse(str, pos + 1,  result);\\n    }\\n    \\n    public List<String> letterCasePermutation(String S) {\\n        List<String> result = new ArrayList<>();\\n        recurse(S.toCharArray(), 0, result);\\n        return result;\\n    }\\n}\\n```\\n\\n**Time Complexity**\\n\\n`O(N * 2^N)`, where `N` is the string length. `2^N` because for each character, we have two choices (whether to transform it or not). The extra `N` factor is because once we reach a leaf, we have to copy the result into a new string (which costs `O(N)`).\\n\\n**Space Complexity**\\n\\n`O(N * 2^N)`. Similar reasoning as above. `2^N` combinations are possible, and we\\'ll need `O(N)` space for each of them. I guess this includes the space required for recursion (`O(2^N)`), as well.\\n\\n**Notes**\\n\\n* Notice that we are passing a `char` array to the recursion function, not a whole `String`. Doing so would consume a lot of extra memory, since `String`s are immutable. Since we need the resultant strings only when we hit the end of recursion, they would be a waste of space anyway. A `StringBuilder` object would also serve the purpose.",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```java\\nclass Solution {\\n    \\n    void recurse(char[] str, int pos, List<String> result) {\\n        //If we have reached a leaf in the recursion tree, save the result.\\n        if (pos == str.length) {\\n            result.add(new String(str));\\n            return;\\n        }\\n        \\n        //If char is not a letter, no processing required.\\n        if (Character.isLetter(str[pos])) {\\n            //If uppercase char, we make it lower case, and recurse.\\n            if (Character.isUpperCase(str[pos])) {\\n                str[pos] = Character.toLowerCase(str[pos]);\\n                \\n                //Start a new branch in the recursion tree, exploring options that are possible only if we had changed the case.\\n                recurse(str, pos + 1, result);\\n                \\n                //Backtracking. We undo the change so that we can start a new branch in the recursion tree.\\n                str[pos] = Character.toUpperCase(str[pos]);\\n            }\\n            //If lowercase, then we make it upper case, and recurse.\\n            else {\\n                str[pos] = Character.toUpperCase(str[pos]);\\n                recurse(str, pos + 1, result);\\n                //Backtracking as explained above.\\n                str[pos] = Character.toLowerCase(str[pos]);\\n            }\\n        }\\n        //This branch explores options that are possible only if the previously performed change (if any) hadn\\'t happened.\\n        recurse(str, pos + 1,  result);\\n    }\\n    \\n    public List<String> letterCasePermutation(String S) {\\n        List<String> result = new ArrayList<>();\\n        recurse(S.toCharArray(), 0, result);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068063,
                "title": "python-honest-backtracking-oneliner-explained",
                "content": "In this problem we need to generate all possible letter case permutations, and let us first underatand how many of them we have. If we have digit, we have only `1` option: we need to choose this digit. If we have letter: we have `2` options: choose either small or capital letter. So, if we have `m` letters, there will be `O(2^m)` different solutions. When you have a lot of different solutions, it is is a good indicator that it is backtracking problem.\\n\\nSo, let us use `dfs(i, built)` function, where:\\n1. `i` is current number of symbols we are processing and \\n2. `built` is string built so far. \\n\\nIf we have next symbols which is letter, we need to consider two options, if it is digit, only one.\\n\\n**Complexity** is `O(2^m*k)`, where `m` is number of letters and `k` is length of all string: we have `2^m` solutions, each of them has length `k`, and what is important we never go to deadend, so all solutions we are trying to build will be added to final answer. Space complexity is `O(2^m*k)` as well.\\n\\n```\\nclass Solution:\\n    def letterCasePermutation(self, S):\\n        def dfs(i, built):\\n            if i == len(S):\\n                self.ans.append(built)\\n                return\\n            if S[i].isalpha():\\n                dfs(i+1, built + S[i].lower())\\n            dfs(i+1, built + S[i].upper())\\n        \\n        self.ans = []\\n        dfs(0, \"\")\\n        return self.ans\\n```\\n\\n### Solution 2: using product\\n\\nAnother solution is to use `product` functionality from python: complexity is the same but it can work a bit faster do to low-level optimizations.\\n```\\nclass Solution:\\n    def letterCasePermutation(self, S):\\n        return map(\\'\\'.join, product(*[set([i.lower(), i.upper()]) for i in S]))\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def letterCasePermutation(self, S):\\n        def dfs(i, built):\\n            if i == len(S):\\n                self.ans.append(built)\\n                return\\n            if S[i].isalpha():\\n                dfs(i+1, built + S[i].lower())\\n            dfs(i+1, built + S[i].upper())\\n        \\n        self.ans = []\\n        dfs(0, \"\")\\n        return self.ans\\n```\n```\\nclass Solution:\\n    def letterCasePermutation(self, S):\\n        return map(\\'\\'.join, product(*[set([i.lower(), i.upper()]) for i in S]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 119529,
                "title": "c-backtrack-solution-with-xor-for-case-toggling",
                "content": "For Toogling the case of letter, xor with 32 beacuse letters are in such a way that toggling the 6th LSB will change its case from lower to upper and vice verse\\n\\n```\\nclass Solution {\\npublic:\\n    void permute (string S, vector<string>& result, int index)\\n    {\\n        \\n      //  cout <<S << \" \";\\n        result.push_back(S);\\n        \\n        if(index >= S.size())\\n            return;      \\n        \\n        for (int i = index ; i < S.size(); i++)\\n        {\\n            if (isalpha(S[i]))\\n            {\\n                S[i] ^= 32;\\n                permute (S, result, i+1);\\n                S[i] ^= 32;\\n            }\\n        }\\n    }\\n    \\n    vector<string> letterCasePermutation(string S) \\n    {\\n        vector<string> result;\\n        permute(S, result, 0);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void permute (string S, vector<string>& result, int index)\\n    {\\n        \\n      //  cout <<S << \" \";\\n        result.push_back(S);\\n        \\n        if(index >= S.size())\\n            return;      \\n        \\n        for (int i = index ; i < S.size(); i++)\\n        {\\n            if (isalpha(S[i]))\\n            {\\n                S[i] ^= 32;\\n                permute (S, result, i+1);\\n                S[i] ^= 32;\\n            }\\n        }\\n    }\\n    \\n    vector<string> letterCasePermutation(string S) \\n    {\\n        vector<string> result;\\n        permute(S, result, 0);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1068215,
                "title": "detailed-c-solution-with-recursion-tree",
                "content": "**Recursion Tree **\\n![image](https://assets.leetcode.com/users/images/7a1f7666-d4f8-405c-9709-10d4c460330a_1613472987.554237.png)\\n==>if we found a current character is alphabet then update that character to upper case\\nand then by backtracking we change the character to lowercase.\\n==> if the current charcter is number than left it as it is\\n*Plz comment if any doubts*\\n```\\nclass Solution {\\npublic:\\n    void solve(string S, vector<string>&ans,int i) {\\n        if(i == S.size()) { // base condition\\n            ans.push_back(S);\\n            return;\\n        }\\n        \\n        if(isalpha(S[i])) { // if the scanned character is alphabet\\n            S[i] = toupper(S[i]);\\n            solve(S,ans,i+1);\\n            S[i] = tolower(S[i]);\\n            solve(S,ans,i+1);\\n        }\\n        else { // if the scanned character is number\\n            solve(S,ans,i+1);\\n        }\\n    }\\n    vector<string> letterCasePermutation(string S) {\\n        vector<string>ans;\\n        solve(S,ans,0);\\n        return ans;\\n    }\\n\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(string S, vector<string>&ans,int i) {\\n        if(i == S.size()) { // base condition\\n            ans.push_back(S);\\n            return;\\n        }\\n        \\n        if(isalpha(S[i])) { // if the scanned character is alphabet\\n            S[i] = toupper(S[i]);\\n            solve(S,ans,i+1);\\n            S[i] = tolower(S[i]);\\n            solve(S,ans,i+1);\\n        }\\n        else { // if the scanned character is number\\n            solve(S,ans,i+1);\\n        }\\n    }\\n    vector<string> letterCasePermutation(string S) {\\n        vector<string>ans;\\n        solve(S,ans,0);\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588867,
                "title": "c-backtracking-with-explanation",
                "content": "```c++\\nclass Solution {\\npublic:\\n    /**  \\n            a1b2   i=0, when it\\'s at a, since it\\'s a letter, we have two branches: a, A\\n         /        \\\\\\n       a1b2       A1b2 i=1 when it\\'s at 1, we only have 1 branch which is itself\\n        |          |   \\n       a1b2       A1b2 i=2 when it\\'s at b, we have two branches: b, B\\n       /  \\\\        / \\\\\\n      a1b2 a1B2  A1b2 A1B2 i=3  when it\\'s at 2, we only have one branch.\\n       |    |     |     |\\n      a1b2 a1B2  A1b2  A1B2 i=4 = S.length(). End recursion, add permutation to ans. \\n      \\n      During this process, we are changing the S char array itself\\n    */\\n    vector<string> letterCasePermutation( string S ) {\\n        vector<string> result;\\n        backtrace( S, 0, result );\\n        return result;\\n    }\\n    \\nprivate:\\n    void backtrace( string S, int i, vector<string> &result ) {\\n        if( i == S.length() ) {\\n            result.push_back( S );\\n            return; \\n        } \\n        if( \\'a\\' <= S[i] && S[i] <= \\'z\\' ) { // two branches if a letter\\n            backtrace( S, i + 1, result );\\n            S[i] = \\'A\\' + S[i] - \\'a\\';\\n            backtrace( S, i + 1, result );\\n        } else if ( \\'A\\' <= S[i] && S[i] <= \\'Z\\' ) { // two branch if a letter \\n            backtrace( S, i + 1, result );\\n            S[i] = \\'a\\' + S[i] - \\'A\\';\\n            backtrace( S, i + 1, result );\\n        } else { // one branch if a digit\\n            backtrace( S, i + 1, result );\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    /**  \\n            a1b2   i=0, when it\\'s at a, since it\\'s a letter, we have two branches: a, A\\n         /        \\\\\\n       a1b2       A1b2 i=1 when it\\'s at 1, we only have 1 branch which is itself\\n        |          |   \\n       a1b2       A1b2 i=2 when it\\'s at b, we have two branches: b, B\\n       /  \\\\        / \\\\\\n      a1b2 a1B2  A1b2 A1B2 i=3  when it\\'s at 2, we only have one branch.\\n       |    |     |     |\\n      a1b2 a1B2  A1b2  A1B2 i=4 = S.length(). End recursion, add permutation to ans. \\n      \\n      During this process, we are changing the S char array itself\\n    */\\n    vector<string> letterCasePermutation( string S ) {\\n        vector<string> result;\\n        backtrace( S, 0, result );\\n        return result;\\n    }\\n    \\nprivate:\\n    void backtrace( string S, int i, vector<string> &result ) {\\n        if( i == S.length() ) {\\n            result.push_back( S );\\n            return; \\n        } \\n        if( \\'a\\' <= S[i] && S[i] <= \\'z\\' ) { // two branches if a letter\\n            backtrace( S, i + 1, result );\\n            S[i] = \\'A\\' + S[i] - \\'a\\';\\n            backtrace( S, i + 1, result );\\n        } else if ( \\'A\\' <= S[i] && S[i] <= \\'Z\\' ) { // two branch if a letter \\n            backtrace( S, i + 1, result );\\n            S[i] = \\'a\\' + S[i] - \\'A\\';\\n            backtrace( S, i + 1, result );\\n        } else { // one branch if a digit\\n            backtrace( S, i + 1, result );\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 115671,
                "title": "java-python-3-9-8-lines-iterative-codes-w-explanation-and-analysis",
                "content": "**Update:** \\n1. toggling letter case changed from **ch[i] += ch[i] < \\'a\\' ? \\'a\\' - \\'A\\' : \\'A\\' - \\'a\\'** to **ch[i] ^= (1 << 5)**, credit to **@tarekd**.\\n2. details of the toggling, credit to **@SnowGeGeGe**\\na bit explanation on how ch[i] ^= (1 << 5) works:\\n\\n\\'a\\' - \\'A\\' = 97 - 65 = 32 = 2 ^ 5\\nchar ^ (1 << 5) means to swap the 6th bit, which also means to +/-32 when the 6th bit is 0/1\\nIn other words\\n\\nif the char is lowercase (6th bit is 1), we subtract 32 to the char value to make it uppercase\\nif the char is uppercase (6th bit is 0), we add 32 to the char value to make it lowercase\\n\\n-----------------------------------------------------------------------------------------------------------------------\\n\\nLet N be the number of letters in input, for each letter, we can toggle its case to get a new string. That is, there are 2 options for each letter: upper and lower cases. Therefore, we can generate 2 ^ N strings totally in worst case.\\n\\nThe details are as follows:\\n1. Add input into list.\\n2. Iterate through input string, when encountering a) a letter, toggle the case of the corresponding letter in all strings in the current list and append all new strings to list; b) a digit, ignore it.\\n\\nLet\\'s use \"a1b2c3\" as an example, and curly braces below indicate the inside part is(are) new string(s) after togglling operation.\\n\\n\"a1b2c3\" ..........................................................................................................................................................................  <= initialization\\n\"**a**1b2c3\" {\"**A**1b2c3\"}................................................................................................................................................ <=  i = 0, a toggled to A\\n\"a**1**b2c3\"  \"A**1**b2c3\".................................................................................................................................................. <=  i = 1, ignore \\'1\\', which is a digit,\\n\"a1**b**2c3\" \"A1**b**2c3\"{\"a1**B**2\" \"A1**B**2\"c3}.................................................................................................................... <= i = 2, b toggled to B\\n\"a1b**2**c3\" \"A1b**2**c3\" \"a1B**2**c3\" \"A1B**2**c3\"................................................................................................................... <=  i = 3, ignore \\'2\\', which is a digit,\\n\"a1b2**c**3\" \"A1b2**c**3\" \"a1B2**c**3\" \"A1B2**c**3\"{\"a1b2**C**3\" \"A1b2**C**3\" \"a1B2**C**3\" \"A1B2**C**3\"}.............................................. <=  i = 4, c toggled to C\\n\"a1b2c**3**\" \"A1b2c**3**\" \"a1B2c**3**\" \"A1B2c**3**\" \"a1b2C**3**\" \"A1b2C**3**\" \"a1B2C**3**\" \"A1B2C**3**\"................................................. <=  i = 5, ignore `3`, which is a digit.\\n```java\\n    public List<String> letterCasePermutation(String S) {\\n        List<String> ans = new ArrayList<>(Arrays.asList(S));\\n        for (int i = 0; i < S.length(); ++i) { // Traverse string S char by char.\\n            for (int j = 0, sz = ans.size(); Character.isLetter(S.charAt(i)) && j < sz; ++j) { // S.charAt(i): letter, not digit.\\n                char[] ch = ans.get(j).toCharArray(); // transform to char[] the string @ j of ans.\\n                ch[i] ^= (1 << 5); // toggle case of charAt(i).\\n                ans.add(String.valueOf(ch)); // append to the end of ans.\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        ans = [S]\\n        for i, c in enumerate(S):\\n            if c.isalpha():\\n                for j in range(len(ans)):\\n                    a = list(ans[j])\\n                    a[i] = a[i].swapcase()\\n                    ans.append(\\'\\'.join(a))\\n        return ans\\n```\\n\\n**Analysis:**\\n\\nIn worst case, the input `S` includes only letters, and hence each letter has `2` options: upper and lower cases. e.g., \\n`S = \"abcd\"`, then the 1st char could be `a` or `A`, the 2nd could be `b` or `B`, the 3rd could be `c` or `C`, the 4th could be `d` or `D`, therefore there are `2 X 2 X 2 X 2 = 2 ^ 4` permutations, and each one cost `S.length() = 4`. The total cost is `4 * 2 ^ 4`. If we substitue `\"abcd\"` with a string of size `n`, then the cost will be `O(n * 2 ^ n)`.\\n\\nTime & space: `O(n * 2 ^ n)`, where `n = S.length()`.",
                "solutionTags": [],
                "code": "```java\\n    public List<String> letterCasePermutation(String S) {\\n        List<String> ans = new ArrayList<>(Arrays.asList(S));\\n        for (int i = 0; i < S.length(); ++i) { // Traverse string S char by char.\\n            for (int j = 0, sz = ans.size(); Character.isLetter(S.charAt(i)) && j < sz; ++j) { // S.charAt(i): letter, not digit.\\n                char[] ch = ans.get(j).toCharArray(); // transform to char[] the string @ j of ans.\\n                ch[i] ^= (1 << 5); // toggle case of charAt(i).\\n                ans.add(String.valueOf(ch)); // append to the end of ans.\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        ans = [S]\\n        for i, c in enumerate(S):\\n            if c.isalpha():\\n                for j in range(len(ans)):\\n                    a = list(ans[j])\\n                    a[i] = a[i].swapcase()\\n                    ans.append(\\'\\'.join(a))\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 276843,
                "title": "java-backtrack-solution-pretty-easy-to-understand-explanation-step-by-step",
                "content": "If you think this post is useful for you, give me a vote, thank you very much~\\n```\\nclass Solution {\\n    public List<String> letterCasePermutation(String S) {\\n        List<String> list = new ArrayList<>(); // for final result\\n        list.add(S); // first add original string\\n        backtrack(S, list, 0);//backtrack, start from the first character of the string\\n        return list;// return final result\\n    }\\n    public void backtrack(String S, List<String> list, int start) {\\n        if (start == S.length()) {// if we reach the tail of the string, just return\\n            return ;\\n        }\\n        for (int i = start; i < S.length(); i++) {// we start from the first character of the string\\n            char c = S.charAt(i); // keep this character for checking later\\n            if (Character.isDigit(c)) {//if it is a digit, continue\\n                continue;\\n            }\\n            StringBuilder sb = new StringBuilder(S);// the reason for using StringBuilder is that we can use the function setCharAt()\\n            if (Character.isUpperCase(c)) {// change uppercase to lowercase or change lower case to upper case\\n                sb.setCharAt(i, Character.toLowerCase(c));\\n            } else {\\n                sb.setCharAt(i, Character.toUpperCase(c));\\n            }\\n            list.add(sb.toString()); // add this modified string to result\\n            backtrack(sb.toString(), list, i + 1);//based on the modified string, keep search\\n\\t\\t\\t//after the funtion backtrack(), we don\\'t change this character at the index i, use the original string, go to next loop, at index i + 1\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> letterCasePermutation(String S) {\\n        List<String> list = new ArrayList<>(); // for final result\\n        list.add(S); // first add original string\\n        backtrack(S, list, 0);//backtrack, start from the first character of the string\\n        return list;// return final result\\n    }\\n    public void backtrack(String S, List<String> list, int start) {\\n        if (start == S.length()) {// if we reach the tail of the string, just return\\n            return ;\\n        }\\n        for (int i = start; i < S.length(); i++) {// we start from the first character of the string\\n            char c = S.charAt(i); // keep this character for checking later\\n            if (Character.isDigit(c)) {//if it is a digit, continue\\n                continue;\\n            }\\n            StringBuilder sb = new StringBuilder(S);// the reason for using StringBuilder is that we can use the function setCharAt()\\n            if (Character.isUpperCase(c)) {// change uppercase to lowercase or change lower case to upper case\\n                sb.setCharAt(i, Character.toLowerCase(c));\\n            } else {\\n                sb.setCharAt(i, Character.toUpperCase(c));\\n            }\\n            list.add(sb.toString()); // add this modified string to result\\n            backtrack(sb.toString(), list, i + 1);//based on the modified string, keep search\\n\\t\\t\\t//after the funtion backtrack(), we don\\'t change this character at the index i, use the original string, go to next loop, at index i + 1\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 369127,
                "title": "python3-backtracking-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef letterCasePermutation(self, S: str) -> List[str]:\\n\\t\\t\\tself.res=[]\\n\\t\\t\\tself.dfs(S,\\'\\',0)\\n\\t\\t\\treturn self.res\\n\\n\\t\\tdef dfs(self,S,path,index):\\n\\t\\t\\tif index==len(S):\\n\\t\\t\\t\\tself.res.append(path)            \\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\tif S[index].isalpha():\\n\\t\\t\\t\\tself.dfs(S,path+S[index].lower(),index+1)\\n\\t\\t\\t\\tself.dfs(S,path+S[index].upper(),index+1)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tself.dfs(S,path+S[index],index+1)",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef letterCasePermutation(self, S: str) -> List[str]:\\n\\t\\t\\tself.res=[]\\n\\t\\t\\tself.dfs(S,\\'\\',0)\\n\\t\\t\\treturn self.res\\n\\n\\t\\tdef dfs(self,S,path,index):\\n\\t\\t\\tif index==len(S):\\n\\t\\t\\t\\tself.res.append(path)            \\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\tif S[index].isalpha():\\n\\t\\t\\t\\tself.dfs(S,path+S[index].lower(),index+1)\\n\\t\\t\\t\\tself.dfs(S,path+S[index].upper(),index+1)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tself.dfs(S,path+S[index],index+1)",
                "codeTag": "Java"
            },
            {
                "id": 471249,
                "title": "dp-backtracking-both-solution-easy-to-understand-simple-faster-mrmagician",
                "content": "**Please do upvote, it motivates me to write more such posts\\uD83D\\uDE05**\\n\\n```\\nvar letterCasePermutation = function(S) {\\n    return permut(S, 0);\\n};\\n\\n\\nfunction permut(str, pos, out = [], curr= \"\"){\\n    if(pos===str.length || curr.length===str.length){\\n        out.push(curr);\\n    }\\n    else{\\n        if(isAlpha(str[pos])){\\n            let up = curr + str[pos].toUpperCase();\\n            let low = curr + str[pos].toLowerCase();\\n            permut(str, pos+1, out, up);\\n            permut(str, pos+1, out, low);\\n        }\\n        else{\\n            permut(str, pos+1, out, curr + str[pos]);\\n        }\\n        \\n    }\\n    return out;\\n}\\n\\nfunction isAlpha(ch){\\n    return /[a-zA-Z]/i.test(ch)\\n}\\n```\\n\\n**Now, the DP based solution**\\n\\n```\\n\\nvar letterCasePermutation = function(S) {\\n    return permut(S);\\n};\\n\\n\\nfunction permut(str, out = []){\\n    str = str.split(\"\");\\n    let till = \"\"\\n    for(let i of str){\\n        if(out.length===0){\\n            if(isAlpha(i)){\\n                out.push(i.toUpperCase());\\n                out.push(i.toLowerCase());\\n            }\\n            else{\\n                out.push(i);\\n            }\\n        }\\n        else{\\n            let alpha = isAlpha(i);\\n            if(alpha){\\n                let up = i.toUpperCase()\\n                let low = i.toLowerCase()\\n                out = attach(out, up).concat(attach(out, low));\\n                out.push(till + up);\\n                out.push(till + low);\\n            }\\n            else{\\n                out = attach(out, i);\\n                out.push(till + i);\\n            }\\n            \\n        }\\n        till += i;\\n    }\\n    let set = new Set(out);\\n    return Array.from(set);\\n}\\n    \\nfunction attach(out, ch){\\n    let newOut = [...out];\\n    for(let i = 0; i<out.length; i++){\\n        newOut[i] += ch;\\n    }\\n    return newOut\\n}\\n\\nfunction isAlpha(ch){\\n    return /[a-zA-Z]/i.test(ch)\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nvar letterCasePermutation = function(S) {\\n    return permut(S, 0);\\n};\\n\\n\\nfunction permut(str, pos, out = [], curr= \"\"){\\n    if(pos===str.length || curr.length===str.length){\\n        out.push(curr);\\n    }\\n    else{\\n        if(isAlpha(str[pos])){\\n            let up = curr + str[pos].toUpperCase();\\n            let low = curr + str[pos].toLowerCase();\\n            permut(str, pos+1, out, up);\\n            permut(str, pos+1, out, low);\\n        }\\n        else{\\n            permut(str, pos+1, out, curr + str[pos]);\\n        }\\n        \\n    }\\n    return out;\\n}\\n\\nfunction isAlpha(ch){\\n    return /[a-zA-Z]/i.test(ch)\\n}\\n```\n```\\n\\nvar letterCasePermutation = function(S) {\\n    return permut(S);\\n};\\n\\n\\nfunction permut(str, out = []){\\n    str = str.split(\"\");\\n    let till = \"\"\\n    for(let i of str){\\n        if(out.length===0){\\n            if(isAlpha(i)){\\n                out.push(i.toUpperCase());\\n                out.push(i.toLowerCase());\\n            }\\n            else{\\n                out.push(i);\\n            }\\n        }\\n        else{\\n            let alpha = isAlpha(i);\\n            if(alpha){\\n                let up = i.toUpperCase()\\n                let low = i.toLowerCase()\\n                out = attach(out, up).concat(attach(out, low));\\n                out.push(till + up);\\n                out.push(till + low);\\n            }\\n            else{\\n                out = attach(out, i);\\n                out.push(till + i);\\n            }\\n            \\n        }\\n        till += i;\\n    }\\n    let set = new Set(out);\\n    return Array.from(set);\\n}\\n    \\nfunction attach(out, ch){\\n    let newOut = [...out];\\n    for(let i = 0; i<out.length; i++){\\n        newOut[i] += ch;\\n    }\\n    return newOut\\n}\\n\\nfunction isAlpha(ch){\\n    return /[a-zA-Z]/i.test(ch)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 498878,
                "title": "python-clear-solution",
                "content": "```\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        ans = [\"\"]\\n        for s in S:\\n            if s.isdigit():\\n                ans = [c+s for c in ans]\\n            else:\\n                tmp1 = [c+s.lower() for c in ans]\\n                tmp2 = [c+s.upper() for c in ans]\\n                ans = tmp1 + tmp2\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        ans = [\"\"]\\n        for s in S:\\n            if s.isdigit():\\n                ans = [c+s for c in ans]\\n            else:\\n                tmp1 = [c+s.lower() for c in ans]\\n                tmp2 = [c+s.upper() for c in ans]\\n                ans = tmp1 + tmp2\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2786208,
                "title": "java-recursion-neat-and-simple",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> letterCasePermutation(String s) {\\n        generate(s.toCharArray(), 0);\\n        return ans;\\n    }\\n\\n    public void generate(char[] arr, int idx) {\\n        if (idx == arr.length) {\\n            ans.add(new String(arr));\\n            return;\\n        }\\n\\n        if (Character.isDigit(arr[idx])) {\\n            generate(arr, idx + 1);\\n            return;\\n        }\\n\\n        arr[idx] = Character.toLowerCase(arr[idx]);\\n        generate(arr, idx + 1);\\n\\n        arr[idx] = Character.toUpperCase(arr[idx]);\\n        generate(arr, idx + 1);\\n    }\\n}\\n\\n// TC: O(n * 2^n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<String> ans = new ArrayList<>();\\n\\n    public List<String> letterCasePermutation(String s) {\\n        generate(s.toCharArray(), 0);\\n        return ans;\\n    }\\n\\n    public void generate(char[] arr, int idx) {\\n        if (idx == arr.length) {\\n            ans.add(new String(arr));\\n            return;\\n        }\\n\\n        if (Character.isDigit(arr[idx])) {\\n            generate(arr, idx + 1);\\n            return;\\n        }\\n\\n        arr[idx] = Character.toLowerCase(arr[idx]);\\n        generate(arr, idx + 1);\\n\\n        arr[idx] = Character.toUpperCase(arr[idx]);\\n        generate(arr, idx + 1);\\n    }\\n}\\n\\n// TC: O(n * 2^n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068160,
                "title": "simple-backtracking-recursion-solution",
                "content": "```\\nvar letterCasePermutation = function(S) {\\n    let n = S.length;\\n    let res = []\\n    let char = /[a-zA-Z]/\\n    let arr = []\\n    \\n    function backtrack(i){\\n        if(i == n){\\n            res.push(arr.join(\\'\\'))\\n            return\\n        }\\n        \\n        if(char.test(S[i])){\\n            arr[i] = S[i].toLowerCase()\\n            backtrack(i+1)\\n            arr[i] = S[i].toUpperCase()\\n            backtrack(i+1)\\n        } else {\\n            arr[i] = S[i]\\n            backtrack(i+1)\\n        }\\n    }\\n    \\n    backtrack(0)\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nvar letterCasePermutation = function(S) {\\n    let n = S.length;\\n    let res = []\\n    let char = /[a-zA-Z]/\\n    let arr = []\\n    \\n    function backtrack(i){\\n        if(i == n){\\n            res.push(arr.join(\\'\\'))\\n            return\\n        }\\n        \\n        if(char.test(S[i])){\\n            arr[i] = S[i].toLowerCase()\\n            backtrack(i+1)\\n            arr[i] = S[i].toUpperCase()\\n            backtrack(i+1)\\n        } else {\\n            arr[i] = S[i]\\n            backtrack(i+1)\\n        }\\n    }\\n    \\n    backtrack(0)\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 147710,
                "title": "python-simple-stack-based",
                "content": "```\\nclass Solution(object):\\n    def letterCasePermutation(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: List[str]\\n        \"\"\"\\n        S = list(S)\\n        solutions = [\\'\\']\\n        while S:\\n            last = S.pop()\\n            if last.isalpha():\\n                solutions = [last.lower() + x for x in solutions] + [last.upper() + x for x in solutions]\\n            else:\\n                solutions = [last + x for x in solutions]\\n        return solutions\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def letterCasePermutation(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: List[str]\\n        \"\"\"\\n        S = list(S)\\n        solutions = [\\'\\']\\n        while S:\\n            last = S.pop()\\n            if last.isalpha():\\n                solutions = [last.lower() + x for x in solutions] + [last.upper() + x for x in solutions]\\n            else:\\n                solutions = [last + x for x in solutions]\\n        return solutions\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909133,
                "title": "python-3-85-56-faster-using-backtracking",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\n```\\ndef letterCasePermutation(self, S: str) -> List[str]:\\n\\tresult = []\\n\\tpartial = []\\n\\n\\tdef permHelper(index, partial):\\n\\t\\tif index==len(S):\\n\\t\\t\\tresult.append(\\'\\'.join(partial))\\n\\t\\t\\treturn\\n\\n\\t\\tif S[index].isalpha():\\n\\t\\t\\tpartial.append(S[index].lower())\\n\\t\\t\\tpermHelper(index+1, partial)\\n\\t\\t\\tpartial.pop()\\n\\t\\t\\tpartial.append(S[index].upper())\\n\\t\\t\\tpermHelper(index+1, partial)\\n\\t\\t\\tpartial.pop()\\n\\t\\telse:\\n\\t\\t\\tpartial.append(S[index])\\n\\t\\t\\tpermHelper(index+1, partial)\\n\\t\\t\\tpartial.pop()\\n\\n\\tpermHelper(0, partial)\\n\\treturn result\\n```\\n\\n**I hope that you\\'ve found this useful.\\nIn that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\ndef letterCasePermutation(self, S: str) -> List[str]:\\n\\tresult = []\\n\\tpartial = []\\n\\n\\tdef permHelper(index, partial):\\n\\t\\tif index==len(S):\\n\\t\\t\\tresult.append(\\'\\'.join(partial))\\n\\t\\t\\treturn\\n\\n\\t\\tif S[index].isalpha():\\n\\t\\t\\tpartial.append(S[index].lower())\\n\\t\\t\\tpermHelper(index+1, partial)\\n\\t\\t\\tpartial.pop()\\n\\t\\t\\tpartial.append(S[index].upper())\\n\\t\\t\\tpermHelper(index+1, partial)\\n\\t\\t\\tpartial.pop()\\n\\t\\telse:\\n\\t\\t\\tpartial.append(S[index])\\n\\t\\t\\tpermHelper(index+1, partial)\\n\\t\\t\\tpartial.pop()\\n\\n\\tpermHelper(0, partial)\\n\\treturn result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 130680,
                "title": "c-6ms-beat-100",
                "content": "```\\nvector<string> letterCasePermutation(string S) {\\n        vector<string> vs;\\n        helper(vs,S,0);\\n        return vs;\\n    }\\n    \\n    void helper(vector<string>& vs,string& S,int p){\\n        if(p == S.size()) {\\n            vs.push_back(S);\\n            return ;\\n        }\\n        if(S[p] >= \\'0\\' && S[p] <= \\'9\\') helper(vs,S,p+1);\\n        else if(S[p] >= \\'a\\' && S[p] <= \\'z\\'){\\n            helper(vs,S,p+1);\\n            S[p] += \\'A\\'-\\'a\\';\\n            helper(vs,S,p+1);\\n        }\\n        else if(S[p] >= \\'A\\' && S[p] <= \\'Z\\'){\\n            helper(vs,S,p+1);\\n            S[p] += \\'a\\'-\\'A\\';\\n            helper(vs,S,p+1);\\n        }\\n    }",
                "solutionTags": [],
                "code": "```\\nvector<string> letterCasePermutation(string S) {\\n        vector<string> vs;\\n        helper(vs,S,0);\\n        return vs;\\n    }\\n    \\n    void helper(vector<string>& vs,string& S,int p){\\n        if(p == S.size()) {\\n            vs.push_back(S);\\n            return ;\\n        }\\n        if(S[p] >= \\'0\\' && S[p] <= \\'9\\') helper(vs,S,p+1);\\n        else if(S[p] >= \\'a\\' && S[p] <= \\'z\\'){\\n            helper(vs,S,p+1);\\n            S[p] += \\'A\\'-\\'a\\';\\n            helper(vs,S,p+1);\\n        }\\n        else if(S[p] >= \\'A\\' && S[p] <= \\'Z\\'){\\n            helper(vs,S,p+1);\\n            S[p] += \\'a\\'-\\'A\\';\\n            helper(vs,S,p+1);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 753118,
                "title": "java-simple-solution-bfs",
                "content": "```\\nclass Solution {\\n    public List<String> letterCasePermutation(String str) {\\n        List<String> permutations = new ArrayList<>();\\n        if (str == null) {\\n            return permutations;\\n        }\\n        \\n        permutations.add(str);\\n        \\n        for (int i=0; i<str.length(); i++) {\\n            if (Character.isLetter(str.charAt(i))) {\\n                int n = permutations.size();\\n                \\n                for (int j=0; j<n; j++) {\\n                    char[] chs = permutations.get(j).toCharArray();\\n                    if (Character.isUpperCase(chs[i])) {\\n                        chs[i] = Character.toLowerCase(chs[i]);\\n                    } else {\\n                        chs[i] = Character.toUpperCase(chs[i]);\\n                    }\\n                    \\n                    permutations.add(String.valueOf(chs));\\n                }\\n            }\\n        }\\n        \\n        return permutations;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> letterCasePermutation(String str) {\\n        List<String> permutations = new ArrayList<>();\\n        if (str == null) {\\n            return permutations;\\n        }\\n        \\n        permutations.add(str);\\n        \\n        for (int i=0; i<str.length(); i++) {\\n            if (Character.isLetter(str.charAt(i))) {\\n                int n = permutations.size();\\n                \\n                for (int j=0; j<n; j++) {\\n                    char[] chs = permutations.get(j).toCharArray();\\n                    if (Character.isUpperCase(chs[i])) {\\n                        chs[i] = Character.toLowerCase(chs[i]);\\n                    } else {\\n                        chs[i] = Character.toUpperCase(chs[i]);\\n                    }\\n                    \\n                    permutations.add(String.valueOf(chs));\\n                }\\n            }\\n        }\\n        \\n        return permutations;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068062,
                "title": "c-simple-backtracking-solution-explained",
                "content": "**Idea:**\\nThis is a simple and typical backtracking solution.\\n`i` keeps the index we are up to in the current string. If we reached `n` - we have another solution and add it to `res`.\\nFirst thing, we call the recursive `backtrack` in any case.\\nNow, if our current character is a letter, we flip it\\'s case - upper to lower and lower to upper - and call `backtrack` again. \\nIn this way, we are checking all possibilities.\\n```\\nclass Solution {\\npublic:\\n    void backtrack(string& curr, int i) {\\n        if (i == n) {\\n            res.push_back(curr);\\n            return;\\n        }\\n        char temp = curr[i];\\n        backtrack(curr, i+1);\\n        if (!isdigit(temp)) {\\n            curr[i] = islower(temp) ? toupper(temp) : tolower(temp);\\n            backtrack(curr, i+1);\\n        }\\n    }\\n    \\n    vector<string> letterCasePermutation(string S) {\\n        n = S.size();\\n        backtrack(S, 0);\\n        return res;\\n    }\\n    \\nprivate:\\n    vector<string> res;\\n    int n;\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void backtrack(string& curr, int i) {\\n        if (i == n) {\\n            res.push_back(curr);\\n            return;\\n        }\\n        char temp = curr[i];\\n        backtrack(curr, i+1);\\n        if (!isdigit(temp)) {\\n            curr[i] = islower(temp) ? toupper(temp) : tolower(temp);\\n            backtrack(curr, i+1);\\n        }\\n    }\\n    \\n    vector<string> letterCasePermutation(string S) {\\n        n = S.size();\\n        backtrack(S, 0);\\n        return res;\\n    }\\n    \\nprivate:\\n    vector<string> res;\\n    int n;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 435824,
                "title": "recursive-java-solution-easy-to-repeat-on-a-whiteboard",
                "content": "Your votes are hugely appreciated! Thanks!\\n\\n```\\n\\tpublic List<String> letterCasePermutation(String S) {\\n        List<String> result = new ArrayList<>();\\n        letterCasePermutation(S, 0, result, \"\");\\n        return result;\\n    }\\n    \\n    private void letterCasePermutation(String s, int idx, List<String> result, String current) {\\n        if (idx == s.length()) {\\n            result.add(current);\\n        } else {\\n            char c = s.charAt(idx);\\n            letterCasePermutation(s, idx + 1, result, current + c);\\n            if (Character.isLetter(c))\\n                letterCasePermutation(s, idx + 1, result,\\n                        current + (Character.isUpperCase(c) ? Character.toLowerCase(c) : Character.toUpperCase(c)));\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n\\tpublic List<String> letterCasePermutation(String S) {\\n        List<String> result = new ArrayList<>();\\n        letterCasePermutation(S, 0, result, \"\");\\n        return result;\\n    }\\n    \\n    private void letterCasePermutation(String s, int idx, List<String> result, String current) {\\n        if (idx == s.length()) {\\n            result.add(current);\\n        } else {\\n            char c = s.charAt(idx);\\n            letterCasePermutation(s, idx + 1, result, current + c);\\n            if (Character.isLetter(c))\\n                letterCasePermutation(s, idx + 1, result,\\n                        current + (Character.isUpperCase(c) ? Character.toLowerCase(c) : Character.toUpperCase(c)));\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 191387,
                "title": "javascript",
                "content": "```\nvar letterCasePermutation = function(S) {\n    let result = [];\n    dfs(\"\", 0);\n    \n    function dfs(current, i){\n        if(current.length == S.length) {\n            result.push(current);\n            return;\n        }\n        if(S.charAt(i) >= '0' && S.charAt(i) <= '9') {\n            current += S.charAt(i);\n            dfs(current, i + 1);\n        } else {\n            dfs(current + S.charAt(i).toLowerCase(), i + 1);\n            dfs(current + S.charAt(i).toUpperCase(), i + 1);\n        }\n    }\n    \n    return result;\n};\n```",
                "solutionTags": [],
                "code": "```\nvar letterCasePermutation = function(S) {\n    let result = [];\n    dfs(\"\", 0);\n    \n    function dfs(current, i){\n        if(current.length == S.length) {\n            result.push(current);\n            return;\n        }\n        if(S.charAt(i) >= '0' && S.charAt(i) <= '9') {\n            current += S.charAt(i);\n            dfs(current, i + 1);\n        } else {\n            dfs(current + S.charAt(i).toLowerCase(), i + 1);\n            dfs(current + S.charAt(i).toUpperCase(), i + 1);\n        }\n    }\n    \n    return result;\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 171720,
                "title": "python-solution",
                "content": "Recursive:\\n```\\nclass Solution(object):\\n    def letterCasePermutation(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: List[str]\\n        \"\"\"\\n        if not S:\\n            return [\"\"]\\n        index = -1\\n        for i in range(len(S)):\\n            if S[i].isalpha():\\n                index = i\\n                break\\n        if index == -1:\\n            return [S]\\n        else:\\n            tmp = self.letterCasePermutation(S[index+1:])\\n            res = []\\n            for s in tmp:\\n                res.append(S[:index]+S[index].lower()+s)\\n                res.append(S[:index]+S[index].upper()+s)\\n            return res\\n```\\nIterative:\\n```\\nclass Solution(object):\\n    def letterCasePermutation(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: List[str]\\n        \"\"\"\\n        res = [\"\"]\\n        for s in S:\\n            if not s.isalpha():\\n                for i in range(len(res)):\\n                    res[i] += s\\n            else:\\n                for i in range(len(res)):\\n                    tmp = res[i]\\n                    res[i] += s.lower()\\n                    res.append(tmp + s.upper())\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def letterCasePermutation(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: List[str]\\n        \"\"\"\\n        if not S:\\n            return [\"\"]\\n        index = -1\\n        for i in range(len(S)):\\n            if S[i].isalpha():\\n                index = i\\n                break\\n        if index == -1:\\n            return [S]\\n        else:\\n            tmp = self.letterCasePermutation(S[index+1:])\\n            res = []\\n            for s in tmp:\\n                res.append(S[:index]+S[index].lower()+s)\\n                res.append(S[:index]+S[index].upper()+s)\\n            return res\\n```\n```\\nclass Solution(object):\\n    def letterCasePermutation(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: List[str]\\n        \"\"\"\\n        res = [\"\"]\\n        for s in S:\\n            if not s.isalpha():\\n                for i in range(len(res)):\\n                    res[i] += s\\n            else:\\n                for i in range(len(res)):\\n                    tmp = res[i]\\n                    res[i] += s.lower()\\n                    res.append(tmp + s.upper())\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414951,
                "title": "c-simplest-backtracking-solution-faster-than-90",
                "content": "**Upvote if you like the approach and leave comments if you have any doubts.**\\n```\\nclass Solution {\\npublic:\\n    vector<string> sans;\\n    void Util(string s, string s1, int index)\\n    {\\n        sans.push_back(s1);\\n        for(int i=index;i<s.length();i++)\\n        {\\n            if(s[i]>=97 && s[i]<=122)\\n            {\\n                s1[i]=s[i]-32;\\n                Util(s,s1,i+1);\\n                s1[i]=s[i];\\n            }\\n            else if(s[i]>=65 && s[i]<=90)\\n            {\\n                s1[i]=s[i]+32;\\n                Util(s,s1,i+1);\\n                s1[i]=s[i];\\n            }\\n        }\\n    }\\n    vector<string> letterCasePermutation(string s) {\\n        Util(s,s,0);\\n        return sans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> sans;\\n    void Util(string s, string s1, int index)\\n    {\\n        sans.push_back(s1);\\n        for(int i=index;i<s.length();i++)\\n        {\\n            if(s[i]>=97 && s[i]<=122)\\n            {\\n                s1[i]=s[i]-32;\\n                Util(s,s1,i+1);\\n                s1[i]=s[i];\\n            }\\n            else if(s[i]>=65 && s[i]<=90)\\n            {\\n                s1[i]=s[i]+32;\\n                Util(s,s1,i+1);\\n                s1[i]=s[i];\\n            }\\n        }\\n    }\\n    vector<string> letterCasePermutation(string s) {\\n        Util(s,s,0);\\n        return sans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068344,
                "title": "python-99-faster-iterative-solution",
                "content": "Explanation:\\nFor every alphabet in `S`, \\n\\t\\t- if it is a number, append it to solution,\\n\\t\\t- else, append both, lower and upper case\\n\\n\\n```\\nclass Solution:\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        ans = [\\'\\']\\n        for i in S:\\n            if i.isalpha():\\n                s, u = i.lower(), i.upper()\\n                n_ans = []\\n                for e in ans:\\n                    n_ans.append(e + s)\\n                    n_ans.append(e + u)\\n            else:\\n                n_ans = [e + i for e in ans]\\n            ans = n_ans\\n        return ans\\n```\\n\\nCleaner implementation by [sarthakkhandelwal](https://leetcode.com/sarthakkhandelwal/)\\n```\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        ans = [\\'\\']\\n        for c in S:\\n            ans = [s+i for i in set([c.upper(), c.lower()]) for s in ans]\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        ans = [\\'\\']\\n        for i in S:\\n            if i.isalpha():\\n                s, u = i.lower(), i.upper()\\n                n_ans = []\\n                for e in ans:\\n                    n_ans.append(e + s)\\n                    n_ans.append(e + u)\\n            else:\\n                n_ans = [e + i for e in ans]\\n            ans = n_ans\\n        return ans\\n```\n```\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        ans = [\\'\\']\\n        for c in S:\\n            ans = [s+i for i in set([c.upper(), c.lower()]) for s in ans]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 555919,
                "title": "c-dfs-and-bfs-solutions",
                "content": "**DFS solution**\\n![image](https://assets.leetcode.com/users/danhuang/image_1586409614.png)\\n\\n\\n```\\npublic class Solution {\\n    public IList<string> LetterCasePermutation(string S) {\\n        \\n        List<string> res = new List<string>();\\n        Helper(S.ToCharArray(), 0, res);\\n        return res;\\n    }\\n    \\n    public void Helper(char[] arr, int index, List<string> res)\\n    {\\n        if(index == arr.Length)\\n            res.Add(new String(arr));\\n        else\\n        {\\n            if(Char.IsDigit(arr[index]))\\n                Helper(arr, index + 1, res);\\n            else\\n            {\\n                arr[index] = Char.ToUpper(arr[index]);\\n                Helper(arr, index + 1, res);\\n                \\n                arr[index] = Char.ToLower(arr[index]);\\n                Helper(arr, index + 1, res);\\n            }\\n        }\\n    }\\n}\\n```\\n\\n**BFS solution**\\n```\\npublic class Solution {\\n    public IList<string> LetterCasePermutation(string S) {\\n        \\n        Queue<string> queue = new Queue<string>();\\n        queue.Enqueue(S);\\n        \\n        for(int i = 0; i < S.Length; i++)\\n        {\\n            if(Char.IsDigit(S[i]))\\n                continue;\\n            else\\n            {\\n                int size = queue.Count;\\n                for(int j = 0; j < size; j++)\\n                {\\n                    var charArr = queue.Dequeue().ToArray();\\n                    \\n                    charArr[i] = Char.ToUpper(charArr[i]);\\n                    queue.Enqueue(new string(charArr));\\n                    \\n                    charArr[i] = Char.ToLower(charArr[i]);\\n                    queue.Enqueue(new string(charArr));\\n                }\\n            }\\n        }\\n        \\n        return queue.ToList();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> LetterCasePermutation(string S) {\\n        \\n        List<string> res = new List<string>();\\n        Helper(S.ToCharArray(), 0, res);\\n        return res;\\n    }\\n    \\n    public void Helper(char[] arr, int index, List<string> res)\\n    {\\n        if(index == arr.Length)\\n            res.Add(new String(arr));\\n        else\\n        {\\n            if(Char.IsDigit(arr[index]))\\n                Helper(arr, index + 1, res);\\n            else\\n            {\\n                arr[index] = Char.ToUpper(arr[index]);\\n                Helper(arr, index + 1, res);\\n                \\n                arr[index] = Char.ToLower(arr[index]);\\n                Helper(arr, index + 1, res);\\n            }\\n        }\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public IList<string> LetterCasePermutation(string S) {\\n        \\n        Queue<string> queue = new Queue<string>();\\n        queue.Enqueue(S);\\n        \\n        for(int i = 0; i < S.Length; i++)\\n        {\\n            if(Char.IsDigit(S[i]))\\n                continue;\\n            else\\n            {\\n                int size = queue.Count;\\n                for(int j = 0; j < size; j++)\\n                {\\n                    var charArr = queue.Dequeue().ToArray();\\n                    \\n                    charArr[i] = Char.ToUpper(charArr[i]);\\n                    queue.Enqueue(new string(charArr));\\n                    \\n                    charArr[i] = Char.ToLower(charArr[i]);\\n                    queue.Enqueue(new string(charArr));\\n                }\\n            }\\n        }\\n        \\n        return queue.ToList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 128585,
                "title": "a-simple-javascript-solution-that-uses-a-common-backtracking-pattern",
                "content": "```\\nconst letterCasePermutation = S => {\\n    const result = [];\\n    backtracking(S, 0, \\'\\', result);\\n    return result;\\n};\\n\\nconst backtracking = (S, i, solution, result) => {\\n    if (i === S.length) {\\n        result.push(solution);\\n        return;\\n    }\\n    \\n    backtracking(S, i + 1, solution + S[i].toLowerCase(), result);\\n    \\n    if (/[a-zA-Z]/.test(S[i])) {\\n        backtracking(S, i + 1, solution + S[i].toUpperCase(), result);\\n    }\\n};\\n```\\nNoticed that in JavaScript, if it\\'s a digit, say \"1\", its lowercase is still \"1\".",
                "solutionTags": [],
                "code": "```\\nconst letterCasePermutation = S => {\\n    const result = [];\\n    backtracking(S, 0, \\'\\', result);\\n    return result;\\n};\\n\\nconst backtracking = (S, i, solution, result) => {\\n    if (i === S.length) {\\n        result.push(solution);\\n        return;\\n    }\\n    \\n    backtracking(S, i + 1, solution + S[i].toLowerCase(), result);\\n    \\n    if (/[a-zA-Z]/.test(S[i])) {\\n        backtracking(S, i + 1, solution + S[i].toUpperCase(), result);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 115630,
                "title": "java-dfs-backtracking-solution",
                "content": "Hello!\n\nHere's a standard DFS/Backtracking solution done in Java. To make it more understandable for beginners, I made the code extremely modularized and made sure to comment out the functions of the methods. I hope you guys like my solution :)\n\nThe idea is to recurse through each individual character in the String and add the changeCase() version of it as well as retaining the original letter. You then loop through each character via recursion until the end condition is satisfied, as described in runCheck(). \n\n\n\tpublic static List<String> letterCasePermutation(String s) {\n        int len = s.length();\n        List<String> list = new ArrayList<>();\n        list.add(s);\n        // BackTrack solution\n        backtrack(s,list, new String(),0);\n        // Lists are passed by reference, so return list in this function\n        return list;\n    }\n\n    public static void backtrack(String s, List<String> list, String curr, int index){\n        if(runCheck(list,curr,s.length())){\n            return;\n        }\n        // StringBuffer to manipulate immutable Strings\n        StringBuffer str = new StringBuffer();\n        str.append(curr);\n        for(int i = index; i<s.length(); i++){\n            int num = (int) s.charAt(i);\n            boolean check = (64<num && num<91) || (96<num && num <123);\n            // If the character is an upper/lower case letter\n            if(check){\n                // Add change-cased letter\n                str.append(changeCase(num));\n                backtrack(s,list,str.toString(),i+1);\n                // Delete new letter and revert (so both permutations included)\n                str.delete(str.length()-1,str.length());\n                str.append(s.charAt(i));\n                // If end conditions are satisfied, add to list\n                if(runCheck(list,str.toString(),s.length())){\n                    return;\n                }\n            }\n            // ELSE accounts for non-letter characters 0-9\n            else {\n\t\t\t\t\t\t\t\t// Appends the number\n                str.append(s.charAt(i));\n                // If end conditions are satisfied, add to list\n                if(runCheck(list,str.toString(),s.length())){\n                    return;\n                }\n            }\n        }\n    }\n    // Passes in ASCII index number\n    // Returns upper case if num is lower case index, vice versa\n    public static char changeCase(int num){\n        char c;\n        // 'A'-'a' = 32\n        if(64<num && num<91){\n            num+=32;\n        }\n        else{\n            num-=32;\n        }\n        c = (char) num;\n        return c;\n    }\n    \n    // Checks if list contains String s and if s is the correct length\n    public static boolean runCheck(List<String> list, String s, int n) {\n        if(!list.contains(s) && s.length() == n) {\n            list.add(s);\n            return true;\n        }\n        return false;\n    }",
                "solutionTags": [],
                "code": "Here's a standard DFS/Backtracking solution done in Java. To make it more understandable for beginners, I made the code extremely modularized and made sure to comment out the functions of the methods. I hope you guys like my solution :)\nThe idea is to recurse through each individual character in the String and add the changeCase() version of it as well as retaining the original letter. You then loop through each character via recursion until the end condition is satisfied, as described in runCheck(). \n\tpublic static List<String> letterCasePermutation(String s) {\n        int len = s.length();\n        List<String> list = new ArrayList<>();\n        list.add(s);\n        backtrack(s,list, new String(),0);\n        return list;\n    }\n    public static void backtrack(String s, List<String> list, String curr, int index){\n        if(runCheck(list,curr,s.length())){\n            return;\n        }\n        StringBuffer str = new StringBuffer();\n        str.append(curr);\n        for(int i = index; i<s.length(); i++){\n            int num = (int) s.charAt(i);\n            boolean check = (64<num && num<91) || (96<num && num <123);\n            if(check){\n                str.append(changeCase(num));\n                backtrack(s,list,str.toString(),i+1);\n                // Delete new letter and revert (so both permutations included)\n                str.delete(str.length()-1,str.length());\n                str.append(s.charAt(i));\n                if(runCheck(list,str.toString(),s.length())){\n                    return;\n                }\n            }\n            else {\n                str.append(s.charAt(i));\n                if(runCheck(list,str.toString(),s.length())){\n                    return;\n                }\n            }\n        }\n    }\n    public static char changeCase(int num){\n        char c;\n        // 'A'-'a' = 32\n        if(64<num && num<91){\n            num+=32;\n        }\n        else{\n            num-=32;\n        }\n        c = (char) num;\n        return c;\n    }\n    public static boolean runCheck(List<String> list, String s, int n) {\n        if(!list.contains(s) && s.length() == n) {\n            list.add(s);\n            return true;\n        }\n        return false;\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3034216,
                "title": "backtracking-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> letterCasePermutation(string S) {\\n        vector<string> ans;\\n        backtrack(S, 0, ans);\\n        return ans;\\n    }\\n    \\n    void backtrack(string &s, int i, vector<string> &ans) {\\n        if (i == s.size()) {\\n            ans.push_back(s);\\n            return;\\n        }\\n        char c = s[i];\\n        s[i] = islower(c) ? toupper(c) : tolower(c);\\n        backtrack(s, i + 1, ans);\\n        if (isalpha(c)) {\\n            s[i] = c;\\n            backtrack(s, i + 1, ans);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> letterCasePermutation(string S) {\\n        vector<string> ans;\\n        backtrack(S, 0, ans);\\n        return ans;\\n    }\\n    \\n    void backtrack(string &s, int i, vector<string> &ans) {\\n        if (i == s.size()) {\\n            ans.push_back(s);\\n            return;\\n        }\\n        char c = s[i];\\n        s[i] = islower(c) ? toupper(c) : tolower(c);\\n        backtrack(s, i + 1, ans);\\n        if (isalpha(c)) {\\n            s[i] = c;\\n            backtrack(s, i + 1, ans);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 711906,
                "title": "c-solution-recursion-and-backtracking-neat-and-clear-solution",
                "content": "Please Upvote if it helped. This motivates\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> result;\\n    \\n    void permutation(string in, string out, int i, int n){\\n        if(i==n){\\n            result.push_back(out);\\n            return;\\n        }\\n        if(in[i]>=\\'0\\' && in[i]<=\\'9\\'){\\n            permutation(in, out+in[i], i+1, n); // No change\\n        } \\n        else if(in[i]>=\\'a\\' && in[i]<=\\'z\\'){\\n            char c = in[i]-32;\\n            permutation(in, out+c, i+1, n); // Toggle the character \\n            permutation(in, out+in[i], i+1, n); // No change\\n        } \\n        else if(in[i]>=\\'A\\' && in[i]<=\\'Z\\'){\\n            char c = in[i]+32;\\n            permutation(in, out+c, i+1, n); // Toggle the character \\n            permutation(in, out+in[i], i+1, n); // No change\\n        }\\n    }\\n    \\n    vector<string> letterCasePermutation(string S) {\\n        \\n        int n = S.size();\\n        permutation(S, \"\", 0, n);\\n        return result;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> result;\\n    \\n    void permutation(string in, string out, int i, int n){\\n        if(i==n){\\n            result.push_back(out);\\n            return;\\n        }\\n        if(in[i]>=\\'0\\' && in[i]<=\\'9\\'){\\n            permutation(in, out+in[i], i+1, n); // No change\\n        } \\n        else if(in[i]>=\\'a\\' && in[i]<=\\'z\\'){\\n            char c = in[i]-32;\\n            permutation(in, out+c, i+1, n); // Toggle the character \\n            permutation(in, out+in[i], i+1, n); // No change\\n        } \\n        else if(in[i]>=\\'A\\' && in[i]<=\\'Z\\'){\\n            char c = in[i]+32;\\n            permutation(in, out+c, i+1, n); // Toggle the character \\n            permutation(in, out+in[i], i+1, n); // No change\\n        }\\n    }\\n    \\n    vector<string> letterCasePermutation(string S) {\\n        \\n        int n = S.size();\\n        permutation(S, \"\", 0, n);\\n        return result;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570442,
                "title": "easy-to-understand-c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> letterCasePermutation(string S) {\\n        vector<string> res({S});\\n        for(int i=0;i<S.size();i++) { // process all strings already present in the queue at index i\\n            if(isdigit(S[i])) continue;\\n            int len = res.size();\\n            for(int j=0; j<len; j++) {\\n                string tmp = res[j];\\n                tmp[i] ^= 32; // toggle case, xor with 32 changes case of character\\n                res.push_back(tmp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> letterCasePermutation(string S) {\\n        vector<string> res({S});\\n        for(int i=0;i<S.size();i++) { // process all strings already present in the queue at index i\\n            if(isdigit(S[i])) continue;\\n            int len = res.size();\\n            for(int j=0; j<len; j++) {\\n                string tmp = res[j];\\n                tmp[i] ^= 32; // toggle case, xor with 32 changes case of character\\n                res.push_back(tmp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 461046,
                "title": "python-3-recursive-backtracking",
                "content": "```\\nclass Solution:\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        \\n        results = []\\n        \\n        def backtrack(S, word, i):\\n            \\n            if i == len(S):\\n                results.append(\"\".join(word))\\n                return\\n\\n            if S[i].isalpha():\\n                backtrack(S, word + (S[i].lower(),), i+1)\\n                backtrack(S, word + (S[i].upper(),), i+1)\\n            else:\\n                backtrack(S, word + (S[i],), i+1)\\n        \\n        backtrack(S, (), 0)\\n        \\n        return results\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        \\n        results = []\\n        \\n        def backtrack(S, word, i):\\n            \\n            if i == len(S):\\n                results.append(\"\".join(word))\\n                return\\n\\n            if S[i].isalpha():\\n                backtrack(S, word + (S[i].lower(),), i+1)\\n                backtrack(S, word + (S[i].upper(),), i+1)\\n            else:\\n                backtrack(S, word + (S[i],), i+1)\\n        \\n        backtrack(S, (), 0)\\n        \\n        return results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149440,
                "title": "c-easy-to-understand-readable-solution-using-recursion-accepted",
                "content": "```\\npublic class Solution {\\n    public IList<string> LetterCasePermutation(string S) {\\n        IList<string> res = new List<string>();\\n        LetterCasePermutationHelper(S, 0, string.Empty, res);\\n        return res;\\n    }\\n    \\n    private static void LetterCasePermutationHelper(string S, int index, string curr, IList<string> res)\\n    {\\n        if (curr.Length == S.Length)\\n            res.Add(curr);\\n        else\\n        {\\n            if (Char.IsDigit(S[index]))\\n                LetterCasePermutationHelper(S, index + 1, curr + S[index], res);\\n            else\\n            {\\n                LetterCasePermutationHelper(S, index + 1, curr + Char.ToLower(S[index]), res);\\n                LetterCasePermutationHelper(S, index + 1, curr + Char.ToUpper(S[index]), res);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> LetterCasePermutation(string S) {\\n        IList<string> res = new List<string>();\\n        LetterCasePermutationHelper(S, 0, string.Empty, res);\\n        return res;\\n    }\\n    \\n    private static void LetterCasePermutationHelper(string S, int index, string curr, IList<string> res)\\n    {\\n        if (curr.Length == S.Length)\\n            res.Add(curr);\\n        else\\n        {\\n            if (Char.IsDigit(S[index]))\\n                LetterCasePermutationHelper(S, index + 1, curr + S[index], res);\\n            else\\n            {\\n                LetterCasePermutationHelper(S, index + 1, curr + Char.ToLower(S[index]), res);\\n                LetterCasePermutationHelper(S, index + 1, curr + Char.ToUpper(S[index]), res);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 115607,
                "title": "very-simple-java-solution-just-using-recursion",
                "content": "```\nclass Solution {\n    public List<String> letterCasePermutation(String S) {\n        List<String> list = new ArrayList<>();\n        if (S == null || S.length() == 0) {\n            list.add(\"\");\n            return list;\n        }\n        List<String> results = letterCasePermutation(S.substring(1));\n        for (String result : results) {\n            if (Character.isLetter(S.charAt(0))) {\n                list.add(S.substring(0, 1).toLowerCase() + result);\n                list.add(S.substring(0, 1).toUpperCase() + result);\n            } else {\n                list.add(S.substring(0, 1) + result);\n            }\n        }\n        return list;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public List<String> letterCasePermutation(String S) {\n        List<String> list = new ArrayList<>();\n        if (S == null || S.length() == 0) {\n            list.add(\"\");\n            return list;\n        }\n        List<String> results = letterCasePermutation(S.substring(1));\n        for (String result : results) {\n            if (Character.isLetter(S.charAt(0))) {\n                list.add(S.substring(0, 1).toLowerCase() + result);\n                list.add(S.substring(0, 1).toUpperCase() + result);\n            } else {\n                list.add(S.substring(0, 1) + result);\n            }\n        }\n        return list;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831800,
                "title": "c-easy-to-understand-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> letterCasePermutation(string s) {\\n        string ip = s;\\n        string op = \"\";\\n        vector<string> res;\\n        solve(ip,op,res);\\n        return res;\\n    }\\n    void solve(string ip,string op,vector<string>& res){\\n        if(ip.length() == 0)\\n        {\\n            res.push_back(op);\\n            return;\\n        }\\n        // if it is alphabet then we need to make two recursion calls \\n        if(isalpha(ip[0])){\\n            string op1 = op;\\n            string op2 = op;\\n            // we will push capital as well as small case letter\\n            op1.push_back(tolower(ip[0]));\\n            op2.push_back(toupper(ip[0]));\\n            // erase the first letter \\n            ip.erase(ip.begin()+0);\\n            // make call for both the different outputs\\n            solve(ip,op1,res);\\n            solve(ip,op2,res);\\n        }\\n        else{\\n            // if it is a digit then we don\\'t have a choice we just need to add it as it is\\n            string op1 = op;\\n            op1.push_back(ip[0]);\\n            ip.erase(ip.begin()+0);\\n            solve(ip,op1,res);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> letterCasePermutation(string s) {\\n        string ip = s;\\n        string op = \"\";\\n        vector<string> res;\\n        solve(ip,op,res);\\n        return res;\\n    }\\n    void solve(string ip,string op,vector<string>& res){\\n        if(ip.length() == 0)\\n        {\\n            res.push_back(op);\\n            return;\\n        }\\n        // if it is alphabet then we need to make two recursion calls \\n        if(isalpha(ip[0])){\\n            string op1 = op;\\n            string op2 = op;\\n            // we will push capital as well as small case letter\\n            op1.push_back(tolower(ip[0]));\\n            op2.push_back(toupper(ip[0]));\\n            // erase the first letter \\n            ip.erase(ip.begin()+0);\\n            // make call for both the different outputs\\n            solve(ip,op1,res);\\n            solve(ip,op2,res);\\n        }\\n        else{\\n            // if it is a digit then we don\\'t have a choice we just need to add it as it is\\n            string op1 = op;\\n            op1.push_back(ip[0]);\\n            ip.erase(ip.begin()+0);\\n            solve(ip,op1,res);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1464233,
                "title": "2-python-solution-iterative-and-recursive",
                "content": "**Iterative**\\n\\n```\\nclass Solution:\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        output = [\"\"]\\n        for ch in S:\\n            for i in range(len(output)):\\n                if ch.isalpha():\\n                    output.append(output[i]+ch.lower())\\n                    output[i] = output[i]+ch.upper()\\n                else:\\n                    output[i] = output[i]+ch\\n        return output\\n```\\n\\n**Recursive**\\n```\\nclass Solution:\\n    def letterCasePermutation(self, s: str) -> List[str]:\\n        return self.helper(s, \"\", [])\\n\\n    def helper(self, s: str, current: str, solution:List[str]) -> List[str]:\\n        if len(s)==0:\\n            solution.append(current)\\n            return solution\\n        if s[0].isalpha():\\n            self.helper(s[1:], current+s[0].lower(), solution)\\n            self.helper(s[1:], current+s[0].upper(), solution)\\n        else:\\n            self.helper(s[1:], current+s[0], solution)\\n        return solution\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        output = [\"\"]\\n        for ch in S:\\n            for i in range(len(output)):\\n                if ch.isalpha():\\n                    output.append(output[i]+ch.lower())\\n                    output[i] = output[i]+ch.upper()\\n                else:\\n                    output[i] = output[i]+ch\\n        return output\\n```\n```\\nclass Solution:\\n    def letterCasePermutation(self, s: str) -> List[str]:\\n        return self.helper(s, \"\", [])\\n\\n    def helper(self, s: str, current: str, solution:List[str]) -> List[str]:\\n        if len(s)==0:\\n            solution.append(current)\\n            return solution\\n        if s[0].isalpha():\\n            self.helper(s[1:], current+s[0].lower(), solution)\\n            self.helper(s[1:], current+s[0].upper(), solution)\\n        else:\\n            self.helper(s[1:], current+s[0], solution)\\n        return solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1090175,
                "title": "java-backtracking-1ms-faster-than-100-00",
                "content": "```\\nclass Solution {\\n    List<String> ans;\\n    public List<String> letterCasePermutation(String S) {\\n        ans = new ArrayList<>();\\n        ans.add(S);\\n        dfs(S.toCharArray(), 0);\\n        return ans;\\n    }\\n    \\n    private void dfs ( char[] s, int index ) {\\n        for ( int i = index; i < s.length; i++ ) {\\n            if ( Character.isAlphabetic(s[i]) ) {\\n                char temp = s[i];\\n                s[i] = ( Character.isLowerCase(s[i]) )? Character.toUpperCase(s[i]) :\\n                        Character.toLowerCase(s[i]);\\n                ans.add( new String(s) );\\n                dfs( s, i+1 );\\n                s[i] = temp;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<String> ans;\\n    public List<String> letterCasePermutation(String S) {\\n        ans = new ArrayList<>();\\n        ans.add(S);\\n        dfs(S.toCharArray(), 0);\\n        return ans;\\n    }\\n    \\n    private void dfs ( char[] s, int index ) {\\n        for ( int i = index; i < s.length; i++ ) {\\n            if ( Character.isAlphabetic(s[i]) ) {\\n                char temp = s[i];\\n                s[i] = ( Character.isLowerCase(s[i]) )? Character.toUpperCase(s[i]) :\\n                        Character.toLowerCase(s[i]);\\n                ans.add( new String(s) );\\n                dfs( s, i+1 );\\n                s[i] = temp;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084219,
                "title": "python-explained-fun-one-liner-without-recursion",
                "content": "Idea here is to get _uppercase_ and _lowercase_ of all of string letters, so in `(set([i.lower(), i.upper()]) for i in S)` we get lowercase and uppercase letters by calling `lower()` and `upper()` and inserting them into `set`, so if letter is _number_ it will be the same and we will not have duplicate, here:\\n`\\'a1B2\\'` will turn into generator with values`([\\'a\\', \\'A\\'], [\\'1\\'], [\\'b\\', \\'B\\'], [\\'2\\'])`\\n\\nAfter we got all of our letters, we need to combine them, and here `product` function becomes handy. It basically takes all arguments you pass and give all possible combinations in order of arguments:\\n`print(list(map(\\'\\'.join, (product(\\'12\\', \\'ab\\', \\'?!\\')))))` -> `[\\'1a?\\', \\'1a!\\', \\'1b?\\', \\'1b!\\', \\'2a?\\', \\'2a!\\', \\'2b?\\', \\'2b!\\']`\\n**ON INTERVIEW YOU MIGHT BE ASKED TO IMPLEMENT itertools.product**\\n\\nSo now we need to pass each of our letter groups as an argument, and this can be done with `*` operator, basically it does this:\\n`args = [[\\'a\\', \\'A\\'], [\\'1\\'], [\\'b\\', \\'B\\'], [\\'2\\']]`\\n`product(args)` -> we passing 1 argument ` [[\\'a\\', \\'A\\'], [\\'1\\'], [\\'b\\', \\'B\\'], [\\'2\\']]`\\n`product(*args)` -> we passing 4 arguments `[\\'a\\', \\'A\\'], [\\'1\\'], [\\'b\\', \\'B\\'], [\\'2\\']`\\ncredits for `*` explanation to [tianjigor](https://leetcode.com/explore/featured/card/february-leetcoding-challenge-2021/586/week-3-february-15th-february-21st/3642/discuss/115544/Python-Easy-2-line-solution)\\n\\n**THIS IS JUST FOR FUN, DON\\'T DO THIS IN PRODUCTION CODE!**\\n```\\nclass Solution:\\n  def letterCasePermutation(self, S: str) -> List[str]:\\n    return map(\\'\\'.join, product(*(set([ch.lower(), ch.upper()]) for ch in S)))\\n```\\n\\nFurther reading: https://docs.python.org/3/library/itertools.html#itertools.product",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n  def letterCasePermutation(self, S: str) -> List[str]:\\n    return map(\\'\\'.join, product(*(set([ch.lower(), ch.upper()]) for ch in S)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 413580,
                "title": "python-concise-dfs-solution",
                "content": "```python\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        res = []\\n        def DFS(S, i):\\n            if i == len(S):\\n                res.append(S)\\n                return\\n            for case in {S[i].upper(), S[i].lower()}:\\n                DFS(S[:i]+case+S[i+1:], i+1)\\n        DFS(S,0)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```python\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        res = []\\n        def DFS(S, i):\\n            if i == len(S):\\n                res.append(S)\\n                return\\n            for case in {S[i].upper(), S[i].lower()}:\\n                DFS(S[:i]+case+S[i+1:], i+1)\\n        DFS(S,0)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 396538,
                "title": "traditional-backtracking-solution",
                "content": "```\\nclass Solution {\\n    private void backtracking(List<String> result, String S, String curr, int n){\\n        if(n == S.length()){\\n            result.add(curr);\\n            return;\\n        }\\n        \\n        char c = S.charAt(n);\\n\\n        if(Character.isLetter(c)){\\n            // Letter has two options ->  lowercase or uppercase\\n            backtracking(result, S, curr + Character.toLowerCase(c), n + 1);\\n            backtracking(result, S, curr + Character.toUpperCase(c), n + 1);\\n        }else{\\n            // Number has only one option -> itself\\n            backtracking(result, S, curr + c, n + 1);\\n        }\\n    }\\n    \\n    public List<String> letterCasePermutation(String S) {\\n        List<String> result = new ArrayList<>();\\n        backtracking(result, S, \"\", 0);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private void backtracking(List<String> result, String S, String curr, int n){\\n        if(n == S.length()){\\n            result.add(curr);\\n            return;\\n        }\\n        \\n        char c = S.charAt(n);\\n\\n        if(Character.isLetter(c)){\\n            // Letter has two options ->  lowercase or uppercase\\n            backtracking(result, S, curr + Character.toLowerCase(c), n + 1);\\n            backtracking(result, S, curr + Character.toUpperCase(c), n + 1);\\n        }else{\\n            // Number has only one option -> itself\\n            backtracking(result, S, curr + c, n + 1);\\n        }\\n    }\\n    \\n    public List<String> letterCasePermutation(String S) {\\n        List<String> result = new ArrayList<>();\\n        backtracking(result, S, \"\", 0);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295975,
                "title": "python-faster-than-99-32-ms",
                "content": "```\\nclass Solution(object):\\n    def letterCasePermutation(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: List[str]\\n        \"\"\"\\n        digits = {str(x) for x in range(10)}\\n        A = [\\'\\']\\n        for c in S:\\n            B = []\\n            if c in digits:\\n                for a in A:\\n                    B.append(a+c)\\n            else:\\n                for a in A:\\n                    B.append(a+c.lower())\\n                    B.append(a+c.upper())\\n            A=B\\n        return A\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def letterCasePermutation(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: List[str]\\n        \"\"\"\\n        digits = {str(x) for x in range(10)}\\n        A = [\\'\\']\\n        for c in S:\\n            B = []\\n            if c in digits:\\n                for a in A:\\n                    B.append(a+c)\\n            else:\\n                for a in A:\\n                    B.append(a+c.lower())\\n                    B.append(a+c.upper())\\n            A=B\\n        return A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 115578,
                "title": "short-python-ruby-c",
                "content": "Ruby:\n```\ndef letter_case_permutation(s)\n  [''].product(*s.chars.map { |c| [c.downcase, c.upcase].uniq }).map(&:join)\nend\n```\nPython 3:\n\n    def letterCasePermutation(self, S):\n        return [*set(map(''.join, itertools.product(*zip(S.lower(), S.upper()))))]\n\nPython 2:\n\n    def letterCasePermutation(self, S):\n        return map(''.join, itertools.product(*map(set, zip(S.lower(), S.upper()))))\n\t\t\t\t\nC++:\n\n    vector<string> letterCasePermutation(string S) {\n        vector<string> result {\"\"};\n        for (char c : S) {\n            vector<string> tmp;\n            for (char b : set<char>{tolower(c), toupper(c)})\n                for (string a : result)\n                    tmp.push_back(a + b);\n            result = tmp;\n        }\n        return result;\n    }\n",
                "solutionTags": [],
                "code": "```\ndef letter_case_permutation(s)\n  [''].product(*s.chars.map { |c| [c.downcase, c.upcase].uniq }).map(&:join)\nend\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1636136,
                "title": "java-simple-recursive-approach-faster-than-100-00",
                "content": "```\\nclass Solution {\\n    List<String> res = new ArrayList<>();\\n    \\n    public List<String> letterCasePermutation(String s) {\\n        permute(s.toCharArray(), 0, s.length());\\n        return res;\\n    }\\n    \\n    public void permute(char[] s, int l, int r) {\\n        if(l >= r) {\\n            res.add(new String(s));\\n            return;\\n        }\\n        \\n\\t\\t// If s[l] is not a alphabet simply increase the l value by 1.\\n        if(!Character.isAlphabetic(s[l])) {\\n            permute(s, l+1, r);\\n            return;\\n        }\\n        \\n        // For lowercase\\n        s[l] = Character.toLowerCase(s[l]);\\n        permute(s, l+1, r);\\n        \\n        // For uppercase\\n        s[l] = Character.toUpperCase(s[l]);\\n        permute(s, l+1, r);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<String> res = new ArrayList<>();\\n    \\n    public List<String> letterCasePermutation(String s) {\\n        permute(s.toCharArray(), 0, s.length());\\n        return res;\\n    }\\n    \\n    public void permute(char[] s, int l, int r) {\\n        if(l >= r) {\\n            res.add(new String(s));\\n            return;\\n        }\\n        \\n\\t\\t// If s[l] is not a alphabet simply increase the l value by 1.\\n        if(!Character.isAlphabetic(s[l])) {\\n            permute(s, l+1, r);\\n            return;\\n        }\\n        \\n        // For lowercase\\n        s[l] = Character.toLowerCase(s[l]);\\n        permute(s, l+1, r);\\n        \\n        // For uppercase\\n        s[l] = Character.toUpperCase(s[l]);\\n        permute(s, l+1, r);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069391,
                "title": "my-first-thought-to-this-problem",
                "content": "I feel this is a backtracking problem, so basically we can search every possible solution and add them to the result list. For me, if I see the current char is a digit, then I will add it to the StringBuilder and move to next char; if it is a letter, then I need to try both upper case and lower case to perform the backtracking again.\\n\\n```\\n    public List<String> letterCasePermutation(String S) {\\n        List<String> res = new ArrayList<>();\\n        char[] arr = S.toCharArray();\\n        StringBuilder sb = new StringBuilder();\\n        int len = arr.length;\\n        dfs(res, arr, sb, 0, len);\\n        return res;\\n    }\\n    \\n    public void dfs(List<String> res, char[] str, StringBuilder temp, int i, int len) {\\n        if (i > len) return;\\n        if (i == len) {\\n            res.add(temp.toString());\\n            return;\\n        }        \\n        if (Character.isDigit(str[i])) {\\n            temp.append(str[i]);\\n            dfs(res, str, temp, i + 1, len);\\n            temp.deleteCharAt(temp.length() - 1); \\n        } else {\\n            temp.append(Character.toLowerCase(str[i]));\\n            dfs(res, str, temp, i + 1, len);\\n            temp.deleteCharAt(temp.length() - 1); \\n            temp.append(Character.toUpperCase(str[i]));\\n            dfs(res, str, temp, i + 1, len);\\n            temp.deleteCharAt(temp.length() - 1); \\n        }\\n                \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<String> letterCasePermutation(String S) {\\n        List<String> res = new ArrayList<>();\\n        char[] arr = S.toCharArray();\\n        StringBuilder sb = new StringBuilder();\\n        int len = arr.length;\\n        dfs(res, arr, sb, 0, len);\\n        return res;\\n    }\\n    \\n    public void dfs(List<String> res, char[] str, StringBuilder temp, int i, int len) {\\n        if (i > len) return;\\n        if (i == len) {\\n            res.add(temp.toString());\\n            return;\\n        }        \\n        if (Character.isDigit(str[i])) {\\n            temp.append(str[i]);\\n            dfs(res, str, temp, i + 1, len);\\n            temp.deleteCharAt(temp.length() - 1); \\n        } else {\\n            temp.append(Character.toLowerCase(str[i]));\\n            dfs(res, str, temp, i + 1, len);\\n            temp.deleteCharAt(temp.length() - 1); \\n            temp.append(Character.toUpperCase(str[i]));\\n            dfs(res, str, temp, i + 1, len);\\n            temp.deleteCharAt(temp.length() - 1); \\n        }\\n                \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1069231,
                "title": "swift-simple-solution-with-array-map",
                "content": "```\\nclass Solution {\\n    func letterCasePermutation(_ S: String) -> [String] {\\n        var result: [String] = [\"\"]\\n        \\n        for c in S {\\n            if c.isLetter {\\n                result = result.flatMap { [\"\\\\($0)\\\\(c.lowercased())\", \"\\\\($0)\\\\(c.uppercased())\"] }\\n            } else {\\n                result = result.map { \"\\\\($0)\\\\(c)\" }\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func letterCasePermutation(_ S: String) -> [String] {\\n        var result: [String] = [\"\"]\\n        \\n        for c in S {\\n            if c.isLetter {\\n                result = result.flatMap { [\"\\\\($0)\\\\(c.lowercased())\", \"\\\\($0)\\\\(c.uppercased())\"] }\\n            } else {\\n                result = result.map { \"\\\\($0)\\\\(c)\" }\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069003,
                "title": "js-python-java-c-recursive-dfs-solution-w-explanation-beats-100-100",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n***Idea:***\\n\\nWhen the problem asks us to deal with permutations, one of the obvious approaches is via **recursion** because recursion will allow us to fire off our helper function down each  branching possibility.\\n\\nRecursion also naturally favors a **DFS** approach, which is also good because it ensures that our recursion stack never gets too deep.\\n\\nOur recursive helper function (**dfs**) is actually quite simple. If we start with the input string (**S**) fully lowercased, then we just need to make sure that each version of dfs calls itself down two branches: one in which the current character is left unchanged, and a second in which the character has been uppercased, but only if the character is a letter.\\n\\nThen, whenever we reach the end of **S**, we can add the permutation to our answer array (**ans**).\\n\\n---\\n\\n***Implementation:***\\n\\nJavascript and Python deal with string copies faster than character arrays, so **dfs** will maintain a string (**res**) that it will build up as the function is called recursively.\\n\\nJava deals with char arrays faster than it does strings, so we can pass a reference to a singular central char array (**chArr**) and modify it as we go. This also means that we have to remember to undo our **toUpperCase** after the second **dfs** is fired off so that later recursions reaching this character start with it in lower case.\\n\\nC++ alone out of the four languages has mutable strings, so we can just pass a full copy of **S** down and modify each char individually, rather than having to build out a **res**.\\n\\n---\\n\\n***Javascript Code:***\\n\\nThe best result for the code below is **76ms / 40.8MB** (beats 100% / 100%).\\n```javascript\\nvar letterCasePermutation = function(S) {\\n    S = S.toLowerCase()\\n    let len = S.length, ans = []\\n    const dfs = (i, res=\\'\\') => {\\n        if (i < len) {\\n            dfs(i+1, res + S[i])\\n            if (S[i] >= \\'a\\') dfs(i+1, res + S[i].toUpperCase())\\n        } else ans.push(res)\\n    }\\n    dfs(0)\\n    return ans\\n};\\n```\\n\\n---\\n\\n***Python Code:***\\n\\nThe best result for the code below is **40ms / 15.2MB** (beats 96% / 38%).\\n```python\\nclass Solution:\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        S = S.lower()\\n        lenS, ans = len(S), []\\n        def dfs(i, res=\\'\\'):\\n            if i < lenS:\\n                dfs(i+1, res + S[i])\\n                if S[i].islower(): dfs(i+1, res + S[i].upper())\\n            else: ans.append(res)\\n        dfs(0)\\n        return ans\\n```\\n\\n---\\n\\n***Java Code:***\\n\\nThe best result for the code below is **1ms / 39.3MB** (beats 100% / 99%).\\n```java\\nclass Solution {\\n    public List<String> letterCasePermutation(String S) {\\n        List ans = new ArrayList();\\n        dfs(S.toLowerCase().toCharArray(), ans, 0, S.length());\\n        return ans;\\n    }\\n    public void dfs(char[] chArr, List ans, int i, int len) {\\n        if (i < len) {\\n            dfs(chArr, ans, i+1, len);\\n            if (Character.isLetter(chArr[i])) {\\n                chArr[i] = Character.toUpperCase(chArr[i]);\\n                dfs(chArr, ans, i+1, len);\\n                chArr[i] = Character.toLowerCase(chArr[i]);\\n            }\\n        } else ans.add(new String(chArr));\\n    }\\n}\\n```\\n\\n---\\n\\n***C++ Code:***\\n\\nThe best result for the code below is **0ms / 9.8MB** (beats 100% / 81%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<string> letterCasePermutation(string S) {\\n        for (int i = 0; i < S.size(); i++) S[i] = tolower(S[i]);\\n        vector<string> ans;\\n        dfs(S, ans, 0, S.size());\\n        return ans;\\n    }\\n    void dfs(string S, vector<string> &ans, int i, int len) {\\n        if (i < len) {\\n            dfs(S, ans, i+1, len);\\n            if (isalpha(S[i])) {\\n                S[i] = toupper(S[i]);\\n                dfs(S, ans, i+1, len);\\n            }\\n        } else ans.push_back(S);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar letterCasePermutation = function(S) {\\n    S = S.toLowerCase()\\n    let len = S.length, ans = []\\n    const dfs = (i, res=\\'\\') => {\\n        if (i < len) {\\n            dfs(i+1, res + S[i])\\n            if (S[i] >= \\'a\\') dfs(i+1, res + S[i].toUpperCase())\\n        } else ans.push(res)\\n    }\\n    dfs(0)\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        S = S.lower()\\n        lenS, ans = len(S), []\\n        def dfs(i, res=\\'\\'):\\n            if i < lenS:\\n                dfs(i+1, res + S[i])\\n                if S[i].islower(): dfs(i+1, res + S[i].upper())\\n            else: ans.append(res)\\n        dfs(0)\\n        return ans\\n```\n```java\\nclass Solution {\\n    public List<String> letterCasePermutation(String S) {\\n        List ans = new ArrayList();\\n        dfs(S.toLowerCase().toCharArray(), ans, 0, S.length());\\n        return ans;\\n    }\\n    public void dfs(char[] chArr, List ans, int i, int len) {\\n        if (i < len) {\\n            dfs(chArr, ans, i+1, len);\\n            if (Character.isLetter(chArr[i])) {\\n                chArr[i] = Character.toUpperCase(chArr[i]);\\n                dfs(chArr, ans, i+1, len);\\n                chArr[i] = Character.toLowerCase(chArr[i]);\\n            }\\n        } else ans.add(new String(chArr));\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<string> letterCasePermutation(string S) {\\n        for (int i = 0; i < S.size(); i++) S[i] = tolower(S[i]);\\n        vector<string> ans;\\n        dfs(S, ans, 0, S.size());\\n        return ans;\\n    }\\n    void dfs(string S, vector<string> &ans, int i, int len) {\\n        if (i < len) {\\n            dfs(S, ans, i+1, len);\\n            if (isalpha(S[i])) {\\n                S[i] = toupper(S[i]);\\n                dfs(S, ans, i+1, len);\\n            }\\n        } else ans.push_back(S);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068070,
                "title": "java-backtracking",
                "content": "```\\nclass Solution {\\n    public List<String> letterCasePermutation(String S) {\\n        List<String> result = new ArrayList<>();\\n        char[] ch = S.toCharArray();\\n        permute(ch, result, 0);\\n        return result;\\n    }\\n    \\n    public void permute(char[] ch, List<String> result, int index) {\\n        result.add(new String(ch));\\n        for(int i=index; i< ch.length; i++) {\\n            char c = ch[i];\\n            if(Character.isLetter(c)) {\\n                ch[i] = getModifiedLetter(c);\\n                permute(ch, result, i+1);\\n                ch[i] = c;\\n            }\\n        }\\n    }\\n    \\n    public char getModifiedLetter(char c){\\n        return Character.isUpperCase(c) ? Character.toLowerCase(c) : Character.toUpperCase(c);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> letterCasePermutation(String S) {\\n        List<String> result = new ArrayList<>();\\n        char[] ch = S.toCharArray();\\n        permute(ch, result, 0);\\n        return result;\\n    }\\n    \\n    public void permute(char[] ch, List<String> result, int index) {\\n        result.add(new String(ch));\\n        for(int i=index; i< ch.length; i++) {\\n            char c = ch[i];\\n            if(Character.isLetter(c)) {\\n                ch[i] = getModifiedLetter(c);\\n                permute(ch, result, i+1);\\n                ch[i] = c;\\n            }\\n        }\\n    }\\n    \\n    public char getModifiedLetter(char c){\\n        return Character.isUpperCase(c) ? Character.toLowerCase(c) : Character.toUpperCase(c);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 535774,
                "title": "c-using-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> letterCasePermutation(string& S) {\\n        vector<string>sol;\\n        permutations(sol,S,0);\\n        return sol;\\n    }\\n    void permutations(vector<string>&sol,string s,int pos){\\n        if(pos==s.size()){\\n            sol.push_back(s);\\n            return;\\n        }\\n        if(isalpha(s[pos])){\\n            s[pos]=tolower(s[pos]);\\n            permutations(sol,s,pos+1);\\n            s[pos]=toupper(s[pos]);\\n            permutations(sol,s,pos+1);\\n        }else{\\n            permutations(sol,s,pos+1);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> letterCasePermutation(string& S) {\\n        vector<string>sol;\\n        permutations(sol,S,0);\\n        return sol;\\n    }\\n    void permutations(vector<string>&sol,string s,int pos){\\n        if(pos==s.size()){\\n            sol.push_back(s);\\n            return;\\n        }\\n        if(isalpha(s[pos])){\\n            s[pos]=tolower(s[pos]);\\n            permutations(sol,s,pos+1);\\n            s[pos]=toupper(s[pos]);\\n            permutations(sol,s,pos+1);\\n        }else{\\n            permutations(sol,s,pos+1);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 508080,
                "title": "javascript-iterative-bfs-solution",
                "content": "```javascript\\n/**\\n * @param {string} S\\n * @return {string[]}\\n */\\nvar letterCasePermutation = function(S) {\\n  const queue = [S];\\n  for (let i = 0; i < S.length; i++) {\\n    if (/[0-9]/.test(S[i])) continue;\\n    const size = queue.length;\\n    for (let j = 0; j < size; j++) {\\n      const node = queue.shift();\\n      queue.push(node.slice(0, i) + node[i].toLowerCase() + node.slice(i + 1));\\n      queue.push(node.slice(0, i) + node[i].toUpperCase() + node.slice(i + 1));\\n    }\\n  }\\n  return queue;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {string} S\\n * @return {string[]}\\n */\\nvar letterCasePermutation = function(S) {\\n  const queue = [S];\\n  for (let i = 0; i < S.length; i++) {\\n    if (/[0-9]/.test(S[i])) continue;\\n    const size = queue.length;\\n    for (let j = 0; j < size; j++) {\\n      const node = queue.shift();\\n      queue.push(node.slice(0, i) + node[i].toLowerCase() + node.slice(i + 1));\\n      queue.push(node.slice(0, i) + node[i].toUpperCase() + node.slice(i + 1));\\n    }\\n  }\\n  return queue;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 493070,
                "title": "java-backtrack-simple",
                "content": "```\\nclass Solution {\\n    public List<String> letterCasePermutation(String S) {\\n        List<String> res = new ArrayList<String>();\\n        char[] chars = S.toCharArray();\\n        backtrack(0, res, chars);\\n        return res;\\n    }\\n    \\n    private void backtrack(int i, List<String> res, char[] chars) {\\n        if (i == chars.length) \\n            res.add(String.valueOf(chars));\\n        else if (!Character.isLetter(chars[i])) \\n            backtrack(i + 1, res, chars);  \\n        else {\\n            backtrack(i + 1, res, chars);\\n            if (Character.isUpperCase(chars[i])) {\\n                chars[i] = Character.toLowerCase(chars[i]);\\n                backtrack(i + 1, res, chars);\\n                chars[i] = Character.toUpperCase(chars[i]);\\n            } else if (Character.isLowerCase(chars[i])) {\\n                chars[i] = Character.toUpperCase(chars[i]);\\n                backtrack(i + 1, res, chars);\\n                chars[i] = Character.toLowerCase(chars[i]);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> letterCasePermutation(String S) {\\n        List<String> res = new ArrayList<String>();\\n        char[] chars = S.toCharArray();\\n        backtrack(0, res, chars);\\n        return res;\\n    }\\n    \\n    private void backtrack(int i, List<String> res, char[] chars) {\\n        if (i == chars.length) \\n            res.add(String.valueOf(chars));\\n        else if (!Character.isLetter(chars[i])) \\n            backtrack(i + 1, res, chars);  \\n        else {\\n            backtrack(i + 1, res, chars);\\n            if (Character.isUpperCase(chars[i])) {\\n                chars[i] = Character.toLowerCase(chars[i]);\\n                backtrack(i + 1, res, chars);\\n                chars[i] = Character.toUpperCase(chars[i]);\\n            } else if (Character.isLowerCase(chars[i])) {\\n                chars[i] = Character.toUpperCase(chars[i]);\\n                backtrack(i + 1, res, chars);\\n                chars[i] = Character.toLowerCase(chars[i]);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 342024,
                "title": "python3-recursive-solution-beats-98-with-explanation",
                "content": "Starting from an empty string, we incrementally go through the entire string `S`. \\n\\nIn each backtracking step, we check whether that character is alphabetic or not. \\nIf `True`, there are two cases should be considered: (1) upper case and (2) lower case.\\nIf `False`, only one backtracking case.\\n\\nThe program stops until we go through the entire string, `step == len(S)`.\\n\\nPlease let me know if there is somewhere can be improved.\\n\\n```\\nclass Solution:\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        def backtrack(S, step, curr, res):\\n            # already go through the entire string, S\\n            if step == len(S):\\n                res.append(curr)\\n                return\\n            \\n            # not alphabets => one backtrack case\\n            if S[step].lower() == S[step].upper():\\n                backtrack(S, step+1, curr+S[step], res)\\n            \\n            # having upper and lower letters => two backtrack cases\\n            else:\\n                backtrack(S, step+1, curr+S[step].lower(), res)\\n                backtrack(S, step+1, curr+S[step].upper(), res)\\n        \\n        res = []\\n        backtrack(S, 0, \"\", res)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        def backtrack(S, step, curr, res):\\n            # already go through the entire string, S\\n            if step == len(S):\\n                res.append(curr)\\n                return\\n            \\n            # not alphabets => one backtrack case\\n            if S[step].lower() == S[step].upper():\\n                backtrack(S, step+1, curr+S[step], res)\\n            \\n            # having upper and lower letters => two backtrack cases\\n            else:\\n                backtrack(S, step+1, curr+S[step].lower(), res)\\n                backtrack(S, step+1, curr+S[step].upper(), res)\\n        \\n        res = []\\n        backtrack(S, 0, \"\", res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 320802,
                "title": "golang-60ms",
                "content": "```\\nfunc letterCasePermutation(S string) []string {\\n\\tif len(S) == 0 {\\n\\t\\treturn []string{\"\"}\\n\\t}\\n\\tvar res []string\\n\\tc := S[len(S)-1]\\n\\tfor _, str := range letterCasePermutation(S[:len(S)-1]) {\\n\\t\\tres = append(res, str+string(c))\\n\\t\\tif c >= \\'a\\' && c <= \\'z\\' {\\n\\t\\t\\tres = append(res, str+string(c-32))\\n\\t\\t} else if c >= \\'A\\' && c <= \\'Z\\' {\\n\\t\\t\\tres = append(res, str+string(c+32))\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nfunc letterCasePermutation(S string) []string {\\n\\tif len(S) == 0 {\\n\\t\\treturn []string{\"\"}\\n\\t}\\n\\tvar res []string\\n\\tc := S[len(S)-1]\\n\\tfor _, str := range letterCasePermutation(S[:len(S)-1]) {\\n\\t\\tres = append(res, str+string(c))\\n\\t\\tif c >= \\'a\\' && c <= \\'z\\' {\\n\\t\\t\\tres = append(res, str+string(c-32))\\n\\t\\t} else if c >= \\'A\\' && c <= \\'Z\\' {\\n\\t\\t\\tres = append(res, str+string(c+32))\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 151015,
                "title": "c-iterative-solution-4ms-beat-100",
                "content": "Algorithm:\\nAdd S to strings. For each index i within S, if index i in S is alpha switch the case of each string within strings up to stop. Add each new string back into strings.\\n\\n```\\nclass Solution {\\npublic:\\n    char switchCase(const char& c) {\\n        if(c >= \\'A\\' && c <= \\'Z\\')\\n            return tolower(c);\\n        else\\n            return toupper(c);\\n    }\\n    \\n    vector<string> letterCasePermutation(string S) {\\n        vector<string> strings;\\n        strings.push_back(S);\\n        for(int i = 0; i < S.length(); i++) {\\n            if(isalpha(S[i])) {\\n                int stop = strings.size();\\n                for(int j = 0; j < stop; j++) {\\n                    string s = strings[j];\\n                    s[i] = switchCase(s[i]);\\n                    strings.push_back(s);\\n                }\\n            }\\n        }\\n        return strings;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    char switchCase(const char& c) {\\n        if(c >= \\'A\\' && c <= \\'Z\\')\\n            return tolower(c);\\n        else\\n            return toupper(c);\\n    }\\n    \\n    vector<string> letterCasePermutation(string S) {\\n        vector<string> strings;\\n        strings.push_back(S);\\n        for(int i = 0; i < S.length(); i++) {\\n            if(isalpha(S[i])) {\\n                int stop = strings.size();\\n                for(int j = 0; j < stop; j++) {\\n                    string s = strings[j];\\n                    s[i] = switchCase(s[i]);\\n                    strings.push_back(s);\\n                }\\n            }\\n        }\\n        return strings;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631245,
                "title": "brute-force-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,string &s,vector<string> &ans){\\n        if(i>=n){\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(s[i]>=\\'0\\'&&s[i]<=\\'9\\'){\\n            solve(i+1,n,s,ans);\\n        }else{\\n            if(s[i]>=\\'A\\'&&s[i]<=\\'Z\\'){\\n                solve(i+1,n,s,ans);\\n                s[i] = s[i]-\\'A\\'+\\'a\\';\\n                solve(i+1,n,s,ans);\\n                s[i] = s[i]-\\'a\\'+\\'A\\';\\n            }else{\\n                solve(i+1,n,s,ans);\\n                s[i] = s[i]+\\'A\\'-\\'a\\';\\n                solve(i+1,n,s,ans);\\n                s[i] = s[i]+\\'a\\'-\\'A\\';\\n            }\\n        }\\n    }\\n    vector<string> letterCasePermutation(string s) {\\n        vector<string> ans;\\n        int n = s.length();\\n        solve(0,n,s,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,string &s,vector<string> &ans){\\n        if(i>=n){\\n            ans.push_back(s);\\n            return;\\n        }\\n        if(s[i]>=\\'0\\'&&s[i]<=\\'9\\'){\\n            solve(i+1,n,s,ans);\\n        }else{\\n            if(s[i]>=\\'A\\'&&s[i]<=\\'Z\\'){\\n                solve(i+1,n,s,ans);\\n                s[i] = s[i]-\\'A\\'+\\'a\\';\\n                solve(i+1,n,s,ans);\\n                s[i] = s[i]-\\'a\\'+\\'A\\';\\n            }else{\\n                solve(i+1,n,s,ans);\\n                s[i] = s[i]+\\'A\\'-\\'a\\';\\n                solve(i+1,n,s,ans);\\n                s[i] = s[i]+\\'a\\'-\\'A\\';\\n            }\\n        }\\n    }\\n    vector<string> letterCasePermutation(string s) {\\n        vector<string> ans;\\n        int n = s.length();\\n        solve(0,n,s,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274320,
                "title": "python3-very-easy-solution-uwu",
                "content": "```\\nclass Solution:\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        res = []\\n        def backtrack(i, curr):\\n            if i == len(S):\\n                res.append(curr)\\n                return\\n            if S[i].isalpha():\\n                backtrack(i+1, curr+S[i].upper())\\n                backtrack(i+1, curr+S[i].lower())\\n            else:\\n                backtrack(i+1, curr+S[i])\\n        backtrack(0, \"\")\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        res = []\\n        def backtrack(i, curr):\\n            if i == len(S):\\n                res.append(curr)\\n                return\\n            if S[i].isalpha():\\n                backtrack(i+1, curr+S[i].upper())\\n                backtrack(i+1, curr+S[i].lower())\\n            else:\\n                backtrack(i+1, curr+S[i])\\n        backtrack(0, \"\")\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764477,
                "title": "backtracking-easy-short-fast",
                "content": "\\n\\n```Approach 1:```\\n\\n**Using Backtracking**\\n\\ncode:\\n```\\n\\nclass Solution {\\npublic:\\n    vector<string> letterCasePermutation( string s ) {\\n        vector<string> result;\\n        combination( s, 0, result );\\n        return result;\\n    }\\n    \\nprivate:\\n    void combination( string s, int i, vector<string> &result ) {\\n        if( i == s.length() ) {\\n            result.push_back( s );\\n            return; \\n        } \\n        if( \\'a\\' <= s[i] && s[i] <= \\'z\\' ) { \\n            combination( s, i + 1, result );\\n            s[i] = \\'A\\' + s[i] - \\'a\\';\\n            combination( s, i + 1, result );\\n        } else if ( \\'A\\' <= s[i] && s[i] <= \\'Z\\' ) { \\n            combination( s, i + 1, result );\\n            s[i] = \\'a\\' + s[i] - \\'A\\';\\n            combination( s, i + 1, result );\\n        } else { \\n            combination( s, i + 1, result );\\n        }\\n        \\n    }\\n};\\n```\\nHope it will help you \\uD83D\\uDE4C.\\nThank you!",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```Approach 1:```\n```\\n\\nclass Solution {\\npublic:\\n    vector<string> letterCasePermutation( string s ) {\\n        vector<string> result;\\n        combination( s, 0, result );\\n        return result;\\n    }\\n    \\nprivate:\\n    void combination( string s, int i, vector<string> &result ) {\\n        if( i == s.length() ) {\\n            result.push_back( s );\\n            return; \\n        } \\n        if( \\'a\\' <= s[i] && s[i] <= \\'z\\' ) { \\n            combination( s, i + 1, result );\\n            s[i] = \\'A\\' + s[i] - \\'a\\';\\n            combination( s, i + 1, result );\\n        } else if ( \\'A\\' <= s[i] && s[i] <= \\'Z\\' ) { \\n            combination( s, i + 1, result );\\n            s[i] = \\'a\\' + s[i] - \\'A\\';\\n            combination( s, i + 1, result );\\n        } else { \\n            combination( s, i + 1, result );\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730288,
                "title": "c-recursion-solution",
                "content": "```class Solution {\\npublic:\\n     void solve(string ip,string op,vector<string> &v){\\n            if(ip.length()==0){\\n                v.push_back(op);\\n                return;\\n            }\\n            if(isalpha(ip[0])){\\n                string op1=op,op2=op;\\n                op1.push_back(tolower(ip[0]));\\n                op2.push_back(toupper(ip[0]));\\n                ip.erase(ip.begin()+0);\\n                solve(ip,op1,v);\\n                solve(ip,op2,v);\\n            }\\n            else\\n            {\\n                string op1=op;\\n                op1.push_back(ip[0]);\\n                ip.erase(ip.begin()+0);\\n                solve(ip,op1,v);\\n                \\n            }\\n            return;\\n        }\\n    vector<string> letterCasePermutation(string s) {\\n        \\n        string ip=s;\\n        string op=\"\";\\n        vector<string> v;\\n        \\n        solve(ip,op,v);\\n        return v;\\n    }\\n};\\n\\n\\nSmaller Input & Recurisve Tree\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n     void solve(string ip,string op,vector<string> &v){\\n            if(ip.length()==0){\\n                v.push_back(op);\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2541197,
                "title": "cpp-simple-backtracking-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    void findPer(vector<string> &ans, string s, int id, int n)\\n    {\\n        if (id == n)\\n        {\\n            ans.push_back(s);\\n            return;\\n        }\\n\\n        if (isdigit(s[id]))\\n        {\\n            findPer(ans, s, id + 1, n);\\n            return;\\n        }\\n\\n        else\\n        {\\n            s[id] = tolower(s[id]);\\n            findPer(ans, s, id + 1, n);\\n\\n            s[id] = toupper(s[id]);\\n            findPer(ans, s, id + 1, n);\\n        }\\n    }\\n\\n    vector<string> letterCasePermutation(string s)\\n    {\\n        vector<string> ans;\\n\\t\\tint n = s.size();\\n        findPer(ans, s, 0,n);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    void findPer(vector<string> &ans, string s, int id, int n)\\n    {\\n        if (id == n)\\n        {\\n            ans.push_back(s);\\n            return;\\n        }\\n\\n        if (isdigit(s[id]))\\n        {\\n            findPer(ans, s, id + 1, n);\\n            return;\\n        }\\n\\n        else\\n        {\\n            s[id] = tolower(s[id]);\\n            findPer(ans, s, id + 1, n);\\n\\n            s[id] = toupper(s[id]);\\n            findPer(ans, s, id + 1, n);\\n        }\\n    }\\n\\n    vector<string> letterCasePermutation(string s)\\n    {\\n        vector<string> ans;\\n\\t\\tint n = s.size();\\n        findPer(ans, s, 0,n);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2228106,
                "title": "c-recursion-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> v;\\n    void answer(int i, string s, int n, string cur){\\n        if(i==n)\\n        {\\n            v.push_back(cur);\\n            return;\\n        }\\n        if(isdigit(s[i])){\\n            cur.push_back(s[i]);\\n            answer(i+1, s, n, cur);\\n        }\\n        else{\\n        string s1 = cur;\\n        s1.push_back(tolower(s[i]));\\n        answer(i+1, s, n, s1);\\n        string s2 = cur;\\n        s2.push_back(toupper(s[i]));\\n        answer(i+1, s, n, s2);\\n        }\\n    }\\n\\n    vector<string> letterCasePermutation(string s) {\\n        int n = s.size();\\n        answer(0, s, n, \"\");\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> v;\\n    void answer(int i, string s, int n, string cur){\\n        if(i==n)\\n        {\\n            v.push_back(cur);\\n            return;\\n        }\\n        if(isdigit(s[i])){\\n            cur.push_back(s[i]);\\n            answer(i+1, s, n, cur);\\n        }\\n        else{\\n        string s1 = cur;\\n        s1.push_back(tolower(s[i]));\\n        answer(i+1, s, n, s1);\\n        string s2 = cur;\\n        s2.push_back(toupper(s[i]));\\n        answer(i+1, s, n, s2);\\n        }\\n    }\\n\\n    vector<string> letterCasePermutation(string s) {\\n        int n = s.size();\\n        answer(0, s, n, \"\");\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1574316,
                "title": "c-100-faster-solution-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(vector<string> &ans, string ip, string op){\\n        if(ip.length()==0){\\n            ans.push_back(op);\\n            return ;\\n        }\\n        if(ip[0]>=\\'0\\' && ip[0]<=\\'9\\'){\\n            string opx = op;\\n            opx.push_back(ip[0]);\\n            ip.erase(ip.begin()+0);\\n            solve(ans,ip,opx);\\n        }\\n        else{\\n        string op1 =op;\\n        string op2 =op;\\n        op1.push_back(tolower(ip[0]));\\n        op2.push_back(toupper(ip[0]));\\n        ip.erase(ip.begin()+0);\\n        solve(ans,ip,op1);\\n        solve(ans,ip,op2);\\n        }\\n    }\\n    vector<string> letterCasePermutation(string s) {\\n         vector<string> ans;\\n        solve(ans,s,\"\");\\n         return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<string> &ans, string ip, string op){\\n        if(ip.length()==0){\\n            ans.push_back(op);\\n            return ;\\n        }\\n        if(ip[0]>=\\'0\\' && ip[0]<=\\'9\\'){\\n            string opx = op;\\n            opx.push_back(ip[0]);\\n            ip.erase(ip.begin()+0);\\n            solve(ans,ip,opx);\\n        }\\n        else{\\n        string op1 =op;\\n        string op2 =op;\\n        op1.push_back(tolower(ip[0]));\\n        op2.push_back(toupper(ip[0]));\\n        ip.erase(ip.begin()+0);\\n        solve(ans,ip,op1);\\n        solve(ans,ip,op2);\\n        }\\n    }\\n    vector<string> letterCasePermutation(string s) {\\n         vector<string> ans;\\n        solve(ans,s,\"\");\\n         return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1459372,
                "title": "python-dfs-with-memoization-clean-concise",
                "content": "```python\\nclass Solution:\\n    def letterCasePermutation(self, s: str) -> List[str]:\\n        n = len(s)\\n        s = s.lower()\\n        \\n        @lru_cache(None)\\n        def dfs(i):\\n            if i == n:\\n                return [\"\"]\\n            \\n            c = s[i]\\n            ans = []\\n            per = [c]\\n            if ord(\\'a\\') <= ord(c) <= ord(\\'z\\'):\\n                per.append(c.upper())\\n                \\n            for sub in dfs(i+1):\\n                for ch in per:\\n                    ans.append(ch + sub)\\n                    \\n            return ans\\n        \\n        return dfs(0)\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def letterCasePermutation(self, s: str) -> List[str]:\\n        n = len(s)\\n        s = s.lower()\\n        \\n        @lru_cache(None)\\n        def dfs(i):\\n            if i == n:\\n                return [\"\"]\\n            \\n            c = s[i]\\n            ans = []\\n            per = [c]\\n            if ord(\\'a\\') <= ord(c) <= ord(\\'z\\'):\\n                per.append(c.upper())\\n                \\n            for sub in dfs(i+1):\\n                for ch in per:\\n                    ans.append(ch + sub)\\n                    \\n            return ans\\n        \\n        return dfs(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074229,
                "title": "c-no-backtrack-no-recursion-simple-solution-by-thinking-this-problem-in-terms-of-bits",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> letterCasePermutation(string S) {\\n        // find the index of alphabets and store them into vector called index\\n        // let\\'s take n is the size of index vector \\n        // here in our case \"a1b2\" has two alphabets a and b\\n        // we store their indices in our index vector, now index contains = {0,2} => indices of alphabets\\n        // size of index vector is 2\\n        // we have 2^2 = 4 possible combinations of strings\\n\\t\\t// Now we generate these 4 combinations using bit representation.\\n\\t\\t// We can assume that, bit 1 represents lower case and 0 represents upper case\\n        // 00, 01, 10, 11\\n        // Generated strings from this bit representation are => A1B2, A1b2, a1B2, a1b2\\n\\t\\t// Which is our ans \\n        \\n        vector <string> ans;\\n        vector <int> index;\\n        \\n        for(int i=0;i<S.size();i++)\\n        {\\n            if(isalpha(S[i]))\\n                index.push_back(i);\\n        }\\n        // generating all possible combinations => 2^index.size() = 1<<index.size()\\n        for(int i=0;i<1<<index.size();i++)\\n        {\\n            string temp=S;\\n            int num=i;\\n            for(int j:index)\\n            {\\n\\t\\t\\t// iterating through index of every alphabet and covert it in lower or upper case according to bit\\n                if(num&1)\\n                    temp[j]=tolower(temp[j]);\\n                else\\n                    temp[j]=toupper(temp[j]);\\n                num>>=1;\\n            }\\n\\t\\t\\t\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> letterCasePermutation(string S) {\\n        // find the index of alphabets and store them into vector called index\\n        // let\\'s take n is the size of index vector \\n        // here in our case \"a1b2\" has two alphabets a and b\\n        // we store their indices in our index vector, now index contains = {0,2} => indices of alphabets\\n        // size of index vector is 2\\n        // we have 2^2 = 4 possible combinations of strings\\n\\t\\t// Now we generate these 4 combinations using bit representation.\\n\\t\\t// We can assume that, bit 1 represents lower case and 0 represents upper case\\n        // 00, 01, 10, 11\\n        // Generated strings from this bit representation are => A1B2, A1b2, a1B2, a1b2\\n\\t\\t// Which is our ans \\n        \\n        vector <string> ans;\\n        vector <int> index;\\n        \\n        for(int i=0;i<S.size();i++)\\n        {\\n            if(isalpha(S[i]))\\n                index.push_back(i);\\n        }\\n        // generating all possible combinations => 2^index.size() = 1<<index.size()\\n        for(int i=0;i<1<<index.size();i++)\\n        {\\n            string temp=S;\\n            int num=i;\\n            for(int j:index)\\n            {\\n\\t\\t\\t// iterating through index of every alphabet and covert it in lower or upper case according to bit\\n                if(num&1)\\n                    temp[j]=tolower(temp[j]);\\n                else\\n                    temp[j]=toupper(temp[j]);\\n                num>>=1;\\n            }\\n\\t\\t\\t\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068067,
                "title": "python-easy-and-simple-solution-without-recursion",
                "content": "```\\nclass Solution:\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        letter_indexes = [i for i in range(len(S)) if not S[i].isdigit()]\\n        my_set = set()\\n        res = [S]\\n        for index in letter_indexes:\\n            for word in res:\\n                i = index\\n                for i in range(index, len(word)):\\n                    if not word[i].isdigit():\\n                        my_set.add(word[:i]+word[i].upper()+word[i+1:])\\n                        my_set.add(word[:i]+word[i].lower()+word[i+1:])\\n    \\n            res += list(my_set)\\n            res = list(set(res))\\n        return res\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        letter_indexes = [i for i in range(len(S)) if not S[i].isdigit()]\\n        my_set = set()\\n        res = [S]\\n        for index in letter_indexes:\\n            for word in res:\\n                i = index\\n                for i in range(index, len(word)):\\n                    if not word[i].isdigit():\\n                        my_set.add(word[:i]+word[i].upper()+word[i+1:])\\n                        my_set.add(word[:i]+word[i].lower()+word[i+1:])\\n    \\n            res += list(my_set)\\n            res = list(set(res))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 913906,
                "title": "easy-to-understand-fast-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> letterCasePermutation(string S) {\\n        \\n        vector<string>sol;\\n        string temp=\"\";\\n        int i=0;\\n        bc(S,sol,temp,i);\\n        return sol;\\n    }\\n    \\n    void bc(string s, vector<string>& sol, string temp, int j)\\n    {\\n\\t   //push the answer to result set when you have completed iterating over the whole string\\n        if(temp.size()==s.size())\\n        {\\n            sol.push_back(temp);\\n            return;\\n        }\\n        else\\n        {\\n\\t\\t      // if the string char is a digit you just need to push it to your temp string and move ahead\\n                if(s[j]>=\\'0\\' && s[j]<=\\'9\\')\\n                {\\n                    temp.push_back(s[j]);\\n                    bc(s,sol,temp,j+1);\\n                    temp.pop_back();\\n                }\\n\\t\\t\\t\\t//if string char is a letter you need to explore both upper and lower case possibilities.\\n                else\\n                \\n                    temp.push_back(toupper(s[j]));\\n                    bc(s,sol,temp,j+1);\\n                    temp.pop_back();\\n                    temp.push_back(tolower(s[j]));\\n                    bc(s,sol,temp,j+1);\\n                    temp.pop_back();   \\n                }\\n                return;\\n        } \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> letterCasePermutation(string S) {\\n        \\n        vector<string>sol;\\n        string temp=\"\";\\n        int i=0;\\n        bc(S,sol,temp,i);\\n        return sol;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 907487,
                "title": "c-make-it-quick-and-easy-to-write",
                "content": "Oct. 22, 2020\\n784. Letter Case Permutation\\n**Case study**\\nReturn a list of all possible strings we could create. You can return the output in any order. \\n\\nExample 1:\\n\\nInput: S = \"a1b2\"\\nOutput: [\"a1b2\",\"a1B2\",\"A1b2\",\"A1B2\"]\\n\\nWhat I did is to go over all C# discussion posts, and then selected a few posts with better ideas first, and then I practiced as well. \\n\\nHere are highlights:\\n1. Using C# char array, and it is easy to make change on any index position.\\n2. Get familiar with C# char class API, ToLower, ToUpper, IsNumber. Go over C# source code for char class. [Here](https://referencesource.microsoft.com/#mscorlib/system/char.cs) is the code. \\n3. Convert an array to another array, char.ToList().ToArray(). \\n4. Default one will be saved in result list first, and then find next char starting from given position: start, change to upper or lower case. \\n\\n```\\npublic class Solution {\\n    public IList<string> LetterCasePermutation(string S) {\\n       var result = new List<string>();\\n               \\n        runDFS(S.ToCharArray(), 0, result);\\n        \\n        return result;\\n    }\\n    \\n    private void runDFS(char[] arr, int start, List<string> result)\\n    {\\n        result.Add(new string(arr));\\n        \\n        for(var i= start; i< arr.Length; i++)\\n        {\\n            if(char.IsNumber(arr[i]))\\n                continue;\\n            \\n\\t\\t\\t//deep copy - smart tip to make a copy of array using C#\\n            var next    = arr.ToList().ToArray();\\n            var current = arr[i];\\n            \\n            if(char.IsUpper(current))\\n            {\\n                next[i] = char.ToLower(current);\\n            }\\n            else\\n            {\\n                next[i] = char.ToUpper(current);\\n            }\\n            \\n            runDFS(next, i+1, result); \\n        }                          \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> LetterCasePermutation(string S) {\\n       var result = new List<string>();\\n               \\n        runDFS(S.ToCharArray(), 0, result);\\n        \\n        return result;\\n    }\\n    \\n    private void runDFS(char[] arr, int start, List<string> result)\\n    {\\n        result.Add(new string(arr));\\n        \\n        for(var i= start; i< arr.Length; i++)\\n        {\\n            if(char.IsNumber(arr[i]))\\n                continue;\\n            \\n\\t\\t\\t//deep copy - smart tip to make a copy of array using C#\\n            var next    = arr.ToList().ToArray();\\n            var current = arr[i];\\n            \\n            if(char.IsUpper(current))\\n            {\\n                next[i] = char.ToLower(current);\\n            }\\n            else\\n            {\\n                next[i] = char.ToUpper(current);\\n            }\\n            \\n            runDFS(next, i+1, result); \\n        }                          \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 784741,
                "title": "python-easy-and-simple-solution-without-recursion-fixed-to-be-quicker",
                "content": "```\\nclass Solution:\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        letter_indexes = [i for i in range(len(S)) if not S[i].isdigit()]\\n        my_set = set()\\n        res = [S]\\n        for index in letter_indexes:\\n            for word in res:\\n                i = index\\n                for i in range(index, len(word)):\\n                    if not word[i].isdigit():\\n                        my_set.add(word[:i]+word[i].upper()+word[i+1:])\\n                        my_set.add(word[:i]+word[i].lower()+word[i+1:])\\n    \\n            res += list(my_set)\\n            res = list(set(res))\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        letter_indexes = [i for i in range(len(S)) if not S[i].isdigit()]\\n        my_set = set()\\n        res = [S]\\n        for index in letter_indexes:\\n            for word in res:\\n                i = index\\n                for i in range(index, len(word)):\\n                    if not word[i].isdigit():\\n                        my_set.add(word[:i]+word[i].upper()+word[i+1:])\\n                        my_set.add(word[:i]+word[i].lower()+word[i+1:])\\n    \\n            res += list(my_set)\\n            res = list(set(res))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731209,
                "title": "c-simple-efficient-100-time-100-space-bitmask-solution-explained",
                "content": "So, in my approach I decided to play a bit with the bitmask trick I just lernt to get good, efficient combinatorics.\\n\\nBut first a bit of preparation: I need to know how many letters I have and in which position they are stored; to do so, I do an initial simple loop and, while at it, I also make sure that their initial status if for all of them to be lowercase.\\n\\nThe base idea is that once you know you have to do a given amount of combinations (`2` raised to the number of letters in the code - `combos` in my code), you can just loop and for each number you get, you will get to know how to generate your next permutations.\\n\\nI know, sounds complex, but a simple example might help: when, say, in my main loop `i` is equal to `6`, that in binary is `1101` and bearing in mind that I read my bits starting from the least significant (ie: from the left), it means that I will have to generate a new string taking `tmp`, my copy of `s`, and turning to uppercase the character in `position[0]`, `position[2]`, `position[4]` (this might be the least intuitive step, but check again how `6` is `1101` in binary, read from left, check my inner `while (n)` loop and you should get it!).\\n\\nThat said, I append the newly generated and modified `tmp` string to `res` and, at the end of the outer loop, I just `return res`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> letterCasePermutation(string s) {\\n        vector<int> positions;\\n        // getting all the positions and turning all alpha chars to lower case\\n        for (int i = 0; i < s.size(); i++) if (isalpha(s[i])) {\\n            positions.push_back(i);\\n            s[i] = tolower(s[i]);\\n        }\\n        int combos = pow(2, positions.size());\\n        vector<string> res(combos);\\n        for (int i = 0, j, n; i < combos; i++) {\\n            string tmp = s;\\n            // using bitmap mask here\\n            n = i;\\n            j = 0;\\n            while (n) {\\n                // flipping the positions of tmp matching the bitmask to uppercase\\n                if (n % 2) tmp[positions[j]] = toupper(tmp[positions[j]]);\\n                j++;\\n                n >>= 1;\\n            }\\n            res[i] = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Combinatorics",
                    "Bitmask"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<string> letterCasePermutation(string s) {\\n        vector<int> positions;\\n        // getting all the positions and turning all alpha chars to lower case\\n        for (int i = 0; i < s.size(); i++) if (isalpha(s[i])) {\\n            positions.push_back(i);\\n            s[i] = tolower(s[i]);\\n        }\\n        int combos = pow(2, positions.size());\\n        vector<string> res(combos);\\n        for (int i = 0, j, n; i < combos; i++) {\\n            string tmp = s;\\n            // using bitmap mask here\\n            n = i;\\n            j = 0;\\n            while (n) {\\n                // flipping the positions of tmp matching the bitmask to uppercase\\n                if (n % 2) tmp[positions[j]] = toupper(tmp[positions[j]]);\\n                j++;\\n                n >>= 1;\\n            }\\n            res[i] = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693027,
                "title": "backtrack-ascii-magic-trick-binary-xor-22-lines-illustration",
                "content": "**Idea:**\\nBacktrack with ASCII table magic:\\nAccording to http://www.asciitable.com/\\nI prepared the following table:\\n\\n![image](https://assets.leetcode.com/users/codedayday/image_1592449900.png)\\n\\n\\n\\n\\nHats off to the creaters or ASCII table. What a wonderful orgnization of the chars!\\n\\n```\\nclass Solution {// DFS backtracking + ASCII magic trick\\npublic: // Time/Space: O(n*2^m),  O(n) + O(n*2^m), where m is #letters in string\\n    vector<string> letterCasePermutation(string S) {\\n        vector<string> ans;\\n        dfs(S, 0, ans);\\n        return ans;\\n    }\\n    \\nprivate:\\n    void dfs(string& S, int start, vector<string>& ans){\\n        if(start == S.size()){\\n            ans.push_back(S);\\n            return;\\n        }        \\n\\t\\t\\n\\t\\t// case1: handle current char, which maybe letter or digit\\n        dfs(S, start + 1, ans);  \\n\\t\\t\\n        if(!isalpha(S[start])) return; //do not forget  if(isdigit(S[start])) return\\n        //case 2: if current char is letter, then change S[start] to opposite \\n        S[start] ^= (1<<5);     // choose:  change a->A or A->a\\n        dfs(S, start + 1, ans);  // explore\\n        S[start] ^= (1<<5);    // unchoose: change A->a or a->A \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {// DFS backtracking + ASCII magic trick\\npublic: // Time/Space: O(n*2^m),  O(n) + O(n*2^m), where m is #letters in string\\n    vector<string> letterCasePermutation(string S) {\\n        vector<string> ans;\\n        dfs(S, 0, ans);\\n        return ans;\\n    }\\n    \\nprivate:\\n    void dfs(string& S, int start, vector<string>& ans){\\n        if(start == S.size()){\\n            ans.push_back(S);\\n            return;\\n        }        \\n\\t\\t\\n\\t\\t// case1: handle current char, which maybe letter or digit\\n        dfs(S, start + 1, ans);  \\n\\t\\t\\n        if(!isalpha(S[start])) return; //do not forget  if(isdigit(S[start])) return\\n        //case 2: if current char is letter, then change S[start] to opposite \\n        S[start] ^= (1<<5);     // choose:  change a->A or A->a\\n        dfs(S, start + 1, ans);  // explore\\n        S[start] ^= (1<<5);    // unchoose: change A->a or a->A \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 541903,
                "title": "javascript-solution-backtracking",
                "content": "```\\nvar letterCasePermutation = function(S) {\\n    const arr = []\\n    \\n    backtrack(S, arr, \"\", 0)\\n    \\n    return arr\\n};\\n\\n\\nfunction backtrack(S, arr, str, index) {\\n    // base case - we reached the length of the string S\\n    if (index === S.length) {\\n        arr.push(str)\\n        return;\\n    }\\n    \\n    // in the case the current character is an upper alphabet, we want a permutation with a lower alphabet\\n    if (S.charAt(index) >= \\'A\\' && S.charAt(index) <= \\'Z\\') {\\n       backtrack(S, arr, str + S.charAt(index).toLowerCase(), index + 1) \\n    }\\n    // in the case the current character is a lower alphabet we want a permutation with an upper alphabet\\n    if (S.charAt(index) >= \\'a\\' && S.charAt(index) <= \\'z\\') {\\n        backtrack(S, arr, str + S.charAt(index).toUpperCase(), index + 1)\\n    }\\n    // no matter what we proceed with the original permutation\\n    backtrack(S, arr, str + S.charAt(index), index + 1)\\n    \\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar letterCasePermutation = function(S) {\\n    const arr = []\\n    \\n    backtrack(S, arr, \"\", 0)\\n    \\n    return arr\\n};\\n\\n\\nfunction backtrack(S, arr, str, index) {\\n    // base case - we reached the length of the string S\\n    if (index === S.length) {\\n        arr.push(str)\\n        return;\\n    }\\n    \\n    // in the case the current character is an upper alphabet, we want a permutation with a lower alphabet\\n    if (S.charAt(index) >= \\'A\\' && S.charAt(index) <= \\'Z\\') {\\n       backtrack(S, arr, str + S.charAt(index).toLowerCase(), index + 1) \\n    }\\n    // in the case the current character is a lower alphabet we want a permutation with an upper alphabet\\n    if (S.charAt(index) >= \\'a\\' && S.charAt(index) <= \\'z\\') {\\n        backtrack(S, arr, str + S.charAt(index).toUpperCase(), index + 1)\\n    }\\n    // no matter what we proceed with the original permutation\\n    backtrack(S, arr, str + S.charAt(index), index + 1)\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 282061,
                "title": "clean-java-solution",
                "content": "```\\n\\nclass Solution {\\n    public List<String> letterCasePermutation(String S) {\\n        if (S == null || S.length() == 0) return new ArrayList<>();\\n        List<String> ret = new LinkedList<>();\\n        helper(S.toCharArray(), 0, ret);\\n        return ret;\\n    }\\n\\n    public void helper(char[] chars, int pos, List<String> ret) {\\n        if (pos == chars.length) {\\n            ret.add(new String(chars));\\n            return;\\n        }\\n        if (Character.isDigit(chars[pos])) {\\n            helper(chars, pos + 1, ret);\\n            return;\\n        }\\n        chars[pos] = Character.toLowerCase(chars[pos]);\\n        helper(chars, pos + 1, ret);\\n        chars[pos] = Character.toUpperCase(chars[pos]);\\n        helper(chars, pos + 1, ret);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public List<String> letterCasePermutation(String S) {\\n        if (S == null || S.length() == 0) return new ArrayList<>();\\n        List<String> ret = new LinkedList<>();\\n        helper(S.toCharArray(), 0, ret);\\n        return ret;\\n    }\\n\\n    public void helper(char[] chars, int pos, List<String> ret) {\\n        if (pos == chars.length) {\\n            ret.add(new String(chars));\\n            return;\\n        }\\n        if (Character.isDigit(chars[pos])) {\\n            helper(chars, pos + 1, ret);\\n            return;\\n        }\\n        chars[pos] = Character.toLowerCase(chars[pos]);\\n        helper(chars, pos + 1, ret);\\n        chars[pos] = Character.toUpperCase(chars[pos]);\\n        helper(chars, pos + 1, ret);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187729,
                "title": "python-easy-3-liner-w-only-lower-upper-methods",
                "content": "```\\nclass Solution:\\n    def letterCasePermutation(self, S, ret = {\"\"}):\\n        for s in S:\\n            ret = {r + t for r in ret for t in (s.lower(), s.upper())}\\n        return list(ret)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def letterCasePermutation(self, S, ret = {\"\"}):\\n        for s in S:\\n            ret = {r + t for r in ret for t in (s.lower(), s.upper())}\\n        return list(ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819380,
                "title": "easy-c-solution",
                "content": "# PLS UPVOTE MY SOLUTION IF YOPU LIKE AND COMMENT FOR ANY DISCUSSION\\n# Approach\\nThe function letterCasePermutation takes a string s as input.\\n\\nIt transforms all characters in the input string to lowercase using the transform function from the algorithm library.\\n\\nIt initializes the output vector with the lowercase version of the input string s.\\n\\nIt then iterates through the characters of the input string using a for loop. For each character at position i, it checks if it is an alphabet (letter) using the isalpha function.\\n\\nIf the character is an alphabet, the add function is called, which creates additional permutations by changing the case of the character at position i to uppercase. The add function works by taking a character n and the position pos, then it duplicates the existing permutations in the output vector, modifies the character at position pos to n in each duplicated permutation, and appends the modified permutations to the output.\\n\\nThe add function uses the count variable to control the number of times the existing permutations are duplicated and modified.\\n\\nFinally, the function returns the output vector containing all possible letter case permutations of the input string.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<string>output;\\nint count=1;\\nvoid add(char n , int pos)\\n{\\n    int i =0;\\n    while(i<count)\\n    {\\n        string x= output[i];\\n        x[pos]=n;\\n        output.push_back(x);\\n        i++;\\n    }\\n    count+=count;\\n}\\n    vector<string> letterCasePermutation(string s) {\\n        //  first we change all character to lower letter\\n        transform(s.begin(),s.end(),s.begin(),:: tolower);\\n        output.push_back(s);\\n        for(int i =0;i<s.length();i++)\\n        {\\n            // check if i is alphabet or not \\n            if(isalpha(s[i]))\\n            {\\n                add(toupper(s[i]),i);\\n            }\\n        }\\n    return output; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<string>output;\\nint count=1;\\nvoid add(char n , int pos)\\n{\\n    int i =0;\\n    while(i<count)\\n    {\\n        string x= output[i];\\n        x[pos]=n;\\n        output.push_back(x);\\n        i++;\\n    }\\n    count+=count;\\n}\\n    vector<string> letterCasePermutation(string s) {\\n        //  first we change all character to lower letter\\n        transform(s.begin(),s.end(),s.begin(),:: tolower);\\n        output.push_back(s);\\n        for(int i =0;i<s.length();i++)\\n        {\\n            // check if i is alphabet or not \\n            if(isalpha(s[i]))\\n            {\\n                add(toupper(s[i]),i);\\n            }\\n        }\\n    return output; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375318,
                "title": "python-backtracking-and-bitman-beats-75-89",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo generate all possible strings from the input string `s`, we need to consider every character in `s` and make a decision for each character: whether to convert it to uppercase or lowercase. This suggests using a backtracking approach where we make a decision for each character and backtrack when all possible combinations have been considered.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a backtrack function that takes two parameters: `start` and `subset`. `start` represents the starting index of the string to consider and `subset` represents the current string we are building.\\n1. Base case: If the length of `subset` equals the length of `s`, add the `subset` to the result list and return.\\n1. For every character starting from `start` to the end of `s`, make a decision to either keep it as it is if it is a digit or convert it to either uppercase or lowercase if it is a letter.\\n1. Recurse with the updated `subset` and `start` values for the next character.\\n1. Backtrack by removing the last character from `subset` to try other combinations.\\n\\n1. Return the result list.\\n# Complexity\\n- Time complexity:  $O(2^n)$, where n is the length of the input string s. For each character in s, we have two choices: keep it as it is or convert it to either uppercase or lowercase. Since there are n characters in s, there are a total of $2^n$ possible combinations of strings.\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $O(n)$, where n is the length of the input string s. The space required to store the result list and the recursion stack is proportional to the length of the input string s.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def letterCasePermutation(self, s: str) -> List[str]:\\n        def backtrack(start,subset):\\n            if len(subset)==len(s):\\n                res.append(subset[:])\\n                return\\n\\n            for i in range(start,len(s)):\\n                if s[i].isdigit():\\n                    backtrack(i+1,subset+s[i])\\n                else:\\n                    lower_subset = subset+s[i].lower()\\n                    backtrack(i+1,lower_subset)\\n                    upper_subset = subset+s[i].upper()\\n                    backtrack(i+1,upper_subset)\\n        res = []\\n        backtrack(0,\"\")\\n        return res\\n\\n```\\n\\n# Approach 2\\n- To generate all possible permutations of the string, we can use a binary representation of a number from `0 to 2^n` (`n` being the length of the string).\\n- For each number, we can set a bit to represent whether a character in the string should be uppercase or lowercase.\\n- Then, we can iterate through the string and construct a new string based on the binary representation of the number.\\n- If the bit is set to 1, we uppercase the corresponding character, and if it\\'s set to 0, we lowercase it.\\n- We add this new string to a set to keep track of unique strings and append it to our final result if it hasn\\'t been added before.\\n# Complexity\\n- **Time complexity:**\\n\\nGenerating all possible permutations takes `2^n` iterations (for a string of length n)\\nChecking if a string has been added to the result takes $$O(1)$$ time with a set\\nOverall time complexity is $$O(n * 2^n)$$\\n\\n- **Space complexity:**\\n\\nWe use a set to store unique strings, which takes up to $$O(2^n)$$ space in the worst case\\nThe final result can have up to `2^n` strings, each with a length of n\\nOverall space complexity is $$O(n * 2^n)$$\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def letterCasePermutation(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        seen = set()  # Set to keep track of unique strings\\n        for i in range(2 ** n):\\n            temp = \"\"\\n            for j in range(n):\\n                if (i >> j) & 1:\\n                    temp += s[j].upper()\\n                else:\\n                    temp += s[j].lower()\\n            if temp not in seen:  # Add string to output only if it hasn\\'t been added before\\n                res.append(temp)\\n                seen.add(temp)\\n        return res\\n```\\n### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def letterCasePermutation(self, s: str) -> List[str]:\\n        def backtrack(start,subset):\\n            if len(subset)==len(s):\\n                res.append(subset[:])\\n                return\\n\\n            for i in range(start,len(s)):\\n                if s[i].isdigit():\\n                    backtrack(i+1,subset+s[i])\\n                else:\\n                    lower_subset = subset+s[i].lower()\\n                    backtrack(i+1,lower_subset)\\n                    upper_subset = subset+s[i].upper()\\n                    backtrack(i+1,upper_subset)\\n        res = []\\n        backtrack(0,\"\")\\n        return res\\n\\n```\n```\\nclass Solution:\\n    def letterCasePermutation(self, s: str) -> List[str]:\\n        res = []\\n        n = len(s)\\n        seen = set()  # Set to keep track of unique strings\\n        for i in range(2 ** n):\\n            temp = \"\"\\n            for j in range(n):\\n                if (i >> j) & 1:\\n                    temp += s[j].upper()\\n                else:\\n                    temp += s[j].lower()\\n            if temp not in seen:  # Add string to output only if it hasn\\'t been added before\\n                res.append(temp)\\n                seen.add(temp)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351574,
                "title": "brute-force-2-n-c-easy-to-understand",
                "content": "````\\nclass Solution {\\npublic:\\n    void solve(int i,string str,vector<string> &ans){\\n        if(i>=str.length()){\\n            ans.push_back(str);\\n            return;\\n        }\\n        if(!(str[i]<=\\'9\\'&&str[i]>=\\'0\\')){\\n            str[i] = tolower(str[i]);\\n            solve(i+1,str,ans);\\n            str[i] = toupper(str[i]);\\n            solve(i+1,str,ans);\\n        }else{\\n            solve(i+1,str,ans);\\n        }\\n    }\\n    vector<string> letterCasePermutation(string s) {\\n        vector<string> ans;\\n        solve(0,s,ans);\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    void solve(int i,string str,vector<string> &ans){\\n        if(i>=str.length()){\\n            ans.push_back(str);\\n            return;\\n        }\\n        if(!(str[i]<=\\'9\\'&&str[i]>=\\'0\\')){\\n            str[i] = tolower(str[i]);\\n            solve(i+1,str,ans);\\n            str[i] = toupper(str[i]);\\n            solve(i+1,str,ans);\\n        }else{\\n            solve(i+1,str,ans);\\n        }\\n    }\\n    vector<string> letterCasePermutation(string s) {\\n        vector<string> ans;\\n        solve(0,s,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241724,
                "title": "python3-clean-w-explain-o-2-n-beats-94-11-thanks-for-reading-upvt",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe see a `number`, we add it to every string in the `permutation[]`.\\n\\nWe see a `letter`, we add it 1st time **(lowercase)** to every string `permutation[]`  + 2nd time **(uppercase)** to every string `permutation[]`.\\n\\n---\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\n> Case: \"a1b2\", permutation[] = [\"\"]\\n\\n-> a = alphabet\\n[\"\"] * 2 \\n-> [\"\", \"\"] -> (+a 1st half, +A 2nd half)\\n-> [\"a\", \"A\"] \\n\\n-> 1 = number\\n[\"a\", \"A\"] \\n-> [\"a1\", \"A1\"]\\n\\n-> b = alphabet\\n[\"a1\", \"A1\"] * 2 \\n-> [\"a1\", \"A1\", \"a1\", \"A1\"] -> (+b 1st half, +B 2nd half)\\n-> [\"a1b\", \"A1b\", \"a1B\", \"A1B\"] \\n\\n-> 2 = number\\n[\"a1b\", \"A1b\", \"a1B\", \"A1B\"]  \\n-> [\"a1b2\", \"A1b2\", \"a1B2\", \"A1B2\"]\\n\\n```\\n1. For every character in `s` we check if it is a `number` or a `letter`.\\n2. If `s[i]` = `number`, we replace original string `permutation[p] = permutation[p] + (s[i])`in the `permutation[]`\\n3. If `s[i]` = `letter`, we double the `permutation[]`: 1 - replace 1st half `permutation[p] = permutation[p] + (s[i].lower())` 2 - replace 2nd half `permutation[p] = permutation[p] + (s[i].upper())`\\n\\n# Complexity\\n- \\u2705\\u231B Time complexity: $$O(2^N)$$\\u231B --> The worst case scenario is where every character is a `letter`, as you double the `permutation[]`, you will have `2x` more permutations = adding (`1x` for lowercase + `1x` for uppercase).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- \\u2705\\uD83D\\uDCBE Space complexity: $$O(2^N)$$ \\uD83D\\uDCBE --> Storing `2^N` all letters of different permutations.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/1b33bbfe-2802-475a-a358-6694372f0856_1677627468.049654.png)\\n\\n# \\uD83E\\uDDFCCode\\uD83E\\uDDFC\\n```\\nclass Solution:\\n    def letterCasePermutation(self, s: str) -> List[str]:\\n        permutation = [\"\"]\\n\\n        for i in range(len(s)):\\n            # number #\\n            if s[i].isnumeric():\\n                for p in range(len(permutation)):\\n                    permutation[p] = permutation[p] + (s[i])\\n        \\n            # alphabet #\\n            if s[i].isalpha():\\n                permutation = permutation * 2\\n                \\n                for p in range(len(permutation)):\\n                    if (p*2 < len(permutation)):\\n                        permutation[p] = permutation[p] + (s[i].lower())\\n                    else:\\n                        permutation[p] = permutation[p] + (s[i].upper())\\n                \\n        return permutation\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\n> Case: \"a1b2\", permutation[] = [\"\"]\\n\\n-> a = alphabet\\n[\"\"] * 2 \\n-> [\"\", \"\"] -> (+a 1st half, +A 2nd half)\\n-> [\"a\", \"A\"] \\n\\n-> 1 = number\\n[\"a\", \"A\"] \\n-> [\"a1\", \"A1\"]\\n\\n-> b = alphabet\\n[\"a1\", \"A1\"] * 2 \\n-> [\"a1\", \"A1\", \"a1\", \"A1\"] -> (+b 1st half, +B 2nd half)\\n-> [\"a1b\", \"A1b\", \"a1B\", \"A1B\"] \\n\\n-> 2 = number\\n[\"a1b\", \"A1b\", \"a1B\", \"A1B\"]  \\n-> [\"a1b2\", \"A1b2\", \"a1B2\", \"A1B2\"]\\n\\n```\n```\\nclass Solution:\\n    def letterCasePermutation(self, s: str) -> List[str]:\\n        permutation = [\"\"]\\n\\n        for i in range(len(s)):\\n            # number #\\n            if s[i].isnumeric():\\n                for p in range(len(permutation)):\\n                    permutation[p] = permutation[p] + (s[i])\\n        \\n            # alphabet #\\n            if s[i].isalpha():\\n                permutation = permutation * 2\\n                \\n                for p in range(len(permutation)):\\n                    if (p*2 < len(permutation)):\\n                        permutation[p] = permutation[p] + (s[i].lower())\\n                    else:\\n                        permutation[p] = permutation[p] + (s[i].upper())\\n                \\n        return permutation\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230594,
                "title": "easy-to-understand-c-solution-every-line-described",
                "content": "# Intuition\\n###### We can divide the problem by making two cases. First when our first letter is uppercase and second when it\\'s lowercase. We will be left with the problem to find all combinations of other letters for these two cases. So if we repeat this for each letter, we will solve the problem.\\n\\n# Approach\\n###### In the main function we create a vector which we fill with indexes of letters in the string. Then we create a function that makes two cases, when the first letter is left lowercase and when it\\'s made uppercase. If the function was called for each letter in the string it means that the permutation was done and it pushes it to the answer vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic :\\n    vector<string> ans;\\n    void permutator(string s,vector<int>& lets ,int n ,int l){\\n        // if we called this function n times it means that we called it for every letter in the string\\n        if(n==l){\\n            ans.push_back(s);\\n            return ;\\n        }\\n        //call the function with the next letter(in the position lets[n+1])\\n        permutator(s,lets ,n+1,l );\\n        //make the letter in the posittion lets[n] uppercase\\n        s[lets[n]] = toupper(s[lets[n]]);\\n        permutator(s,lets ,n+1,l );\\n    }\\n    \\n    vector<string> letterCasePermutation(string s) {\\n        //vector of letters in the string\\n        vector<int> lets;\\n        for(int i =0; i < s.size();i++){\\n            //checking if char is a letter\\n            if (isalpha(s[i])){\\n                //making every letter lowercase\\n                s[i] = tolower(s[i]);\\n                lets.push_back(i);\\n            }\\n        }\\n        int l =lets.size();\\n        permutator(s,lets ,0, l );\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic :\\n    vector<string> ans;\\n    void permutator(string s,vector<int>& lets ,int n ,int l){\\n        // if we called this function n times it means that we called it for every letter in the string\\n        if(n==l){\\n            ans.push_back(s);\\n            return ;\\n        }\\n        //call the function with the next letter(in the position lets[n+1])\\n        permutator(s,lets ,n+1,l );\\n        //make the letter in the posittion lets[n] uppercase\\n        s[lets[n]] = toupper(s[lets[n]]);\\n        permutator(s,lets ,n+1,l );\\n    }\\n    \\n    vector<string> letterCasePermutation(string s) {\\n        //vector of letters in the string\\n        vector<int> lets;\\n        for(int i =0; i < s.size();i++){\\n            //checking if char is a letter\\n            if (isalpha(s[i])){\\n                //making every letter lowercase\\n                s[i] = tolower(s[i]);\\n                lets.push_back(i);\\n            }\\n        }\\n        int l =lets.size();\\n        permutator(s,lets ,0, l );\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2624185,
                "title": "truth-table-terminology-to-solve-this-problem-loop-only-99-beats-memory",
                "content": "# ***Truth Table terminology ***\\nIf have three variables x,y and z the truth table of them\\nx y z\\n1 1 1 \\n1 1 0\\n1 0 1\\n1 0 0\\n0 1 1\\n0 1 0\\n0 0 1 \\n0 0 0\\nfrom this thought if in string s (**aBC12**) have length 5 and 3 of them are charachers,then size of result vector 2^3=8\\nthen \\nA B C 1 2\\nA B c 1 2 \\nA b C 1 2\\nA b c 1 2\\na B C 1 2\\na B c 1 2\\na b C 1 2\\na b c 1 2\\nand return the vector result with no order\\nand using only loops for that it save memory but not the best in time\\n# ***Time Complexity  (N \\\\* 2^N)***\\n![image](https://assets.leetcode.com/users/images/da7bdf3a-2a63-46ef-a9e3-1b83d5e4a755_1664133451.6174865.png)\\n# ***Space Complexity (N \\\\* 2^N)****\\n![image](https://assets.leetcode.com/users/images/72fad6c6-e0a1-40ff-9974-fe5cf82b0f23_1664133465.7103157.png)\\n\\n**N represent number of charaters non numeric in string.**\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    vector<string> letterCasePermutation(string s) {\\n        vector<int>ch;\\n        for(int i=0;i<s.size();i++){\\n            if(isalpha(s[i]))ch.push_back(i);\\n        }\\n        int sizeofvectorstring=(int)pow(2,ch.size());\\n        vector<string>res(sizeofvectorstring,s);\\n        for(int i=0;i<ch.size();i++){\\n            sizeofvectorstring=sizeofvectorstring/2;\\n            for(int j=0;j<res.size();j++){\\n                if((j/sizeofvectorstring)%2==0){\\n                    res[j][ch[i]]=tolower(res[j][ch[i]]);\\n                }else{\\n                    res[j][ch[i]]=toupper(res[j][ch[i]]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> letterCasePermutation(string s) {\\n        vector<int>ch;\\n        for(int i=0;i<s.size();i++){\\n            if(isalpha(s[i]))ch.push_back(i);\\n        }\\n        int sizeofvectorstring=(int)pow(2,ch.size());\\n        vector<string>res(sizeofvectorstring,s);\\n        for(int i=0;i<ch.size();i++){\\n            sizeofvectorstring=sizeofvectorstring/2;\\n            for(int j=0;j<res.size();j++){\\n                if((j/sizeofvectorstring)%2==0){\\n                    res[j][ch[i]]=tolower(res[j][ch[i]]);\\n                }else{\\n                    res[j][ch[i]]=toupper(res[j][ch[i]]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589863,
                "title": "java-beats-97-simple-backtracking-recursion-fast-easy",
                "content": "If you find my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community,\\nif you have any queries or any improvements please feel free to comment and share your views.\\n\\n    class Solution {\\n     public List<String> letterCasePermutation(String s) {\\n      List<String> ans = new ArrayList<>();\\n      permuate(0,s,s.toCharArray(),ans);\\n      return ans;\\n      }\\n        private void permuate(int i,String s,char[] arr,List<String> ans) {\\n    \\n    if(i==s.length() ) {\\n        ans.add(new String(arr));\\n        return ;\\n    }\\n        char c = arr[i];\\n    \\n        if(Character.isLetter(c)) {\\n         \\n            arr[i] = Character.toUpperCase(c);\\n            permuate(i+1,s,arr,ans);\\n            arr[i] = Character.toLowerCase(c);\\n            permuate(i+1,s,arr,ans);\\n        }\\n        else \\n            permuate(i+1,s,arr,ans);        \\n      }\\n      }",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n     public List<String> letterCasePermutation(String s) {\\n      List<String> ans = new ArrayList<>();\\n      permuate(0,s,s.toCharArray(),ans);\\n      return ans;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1993522,
                "title": "c-basic-maths-easy-time-and-memory-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> letterCasePermutation(string s) {\\n        int c=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]>=48 && s[i]<=57)\\n                continue;\\n            else\\n                c++;\\n        }\\n         c=pow(2,c);\\n        int d=1;\\n        vector<string> a(c,\"\");\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]>=48 && s[i]<=57){\\n                for(int j=0;j<c;j++){\\n                    a[j]+=s[i];\\n                }\\n                continue;\\n            }\\n            char x=s[i];\\n            int j=0;\\n            int m=pow(2,d-1);\\n            while(m--){\\n                int l=c/(pow(2,d));\\n                if(s[i]>=97){\\n                while(l--){\\n                    a[j]+=s[i];\\n                    j++;\\n                }\\n                l=c/(pow(2,d));\\n                while(l--){\\n                    a[j]+=(s[i]-32);\\n                    j++;\\n                }}\\n                else{\\n                    while(l--){\\n                    a[j]+=s[i];\\n                    j++;\\n                }\\n                l=c/(pow(2,d));\\n                while(l--){\\n                    a[j]+=(s[i]+32);\\n                    j++;\\n                }    \\n                }   \\n            }\\n            d++;\\n        }\\n        return a; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> letterCasePermutation(string s) {\\n        int c=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]>=48 && s[i]<=57)\\n                continue;\\n            else\\n                c++;\\n        }\\n         c=pow(2,c);\\n        int d=1;\\n        vector<string> a(c,\"\");\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]>=48 && s[i]<=57){\\n                for(int j=0;j<c;j++){\\n                    a[j]+=s[i];\\n                }\\n                continue;\\n            }\\n            char x=s[i];\\n            int j=0;\\n            int m=pow(2,d-1);\\n            while(m--){\\n                int l=c/(pow(2,d));\\n                if(s[i]>=97){\\n                while(l--){\\n                    a[j]+=s[i];\\n                    j++;\\n                }\\n                l=c/(pow(2,d));\\n                while(l--){\\n                    a[j]+=(s[i]-32);\\n                    j++;\\n                }}\\n                else{\\n                    while(l--){\\n                    a[j]+=s[i];\\n                    j++;\\n                }\\n                l=c/(pow(2,d));\\n                while(l--){\\n                    a[j]+=(s[i]+32);\\n                    j++;\\n                }    \\n                }   \\n            }\\n            d++;\\n        }\\n        return a; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944408,
                "title": "python-faster-than-99",
                "content": "Success\\nDetails \\nRuntime: 48 ms, faster than **98.81%** of Python3 online submissions for Letter Case Permutation.\\nMemory Usage: 14.6 MB, less than **83.87%** of Python3 online submissions for Letter Case Permutation.\\n\\nI am maintaining an output list which will contain the result.\\nInitially, it contains an empty string. Note (length of list is not zero)\\n Then I am looping through the each character of the input string\\n If the character is an alphabet, then I add the upper and lower value of the current character with every value present in the result list.\\n\\n```\\nclass Solution:\\n    def letterCasePermutation(self, s: str) -> List[str]:\\n        output=[\"\"]\\n        for c in s:\\n            temp=[]\\n            for o in output:\\n                if c.isalpha():\\n                    temp.append(o+c.lower())\\n                    temp.append(o+c.upper())\\n                else:\\n                    temp.append(o+c)\\n            print(output)\\n            output=temp\\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def letterCasePermutation(self, s: str) -> List[str]:\\n        output=[\"\"]\\n        for c in s:\\n            temp=[]\\n            for o in output:\\n                if c.isalpha():\\n                    temp.append(o+c.lower())\\n                    temp.append(o+c.upper())\\n                else:\\n                    temp.append(o+c)\\n            print(output)\\n            output=temp\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1917524,
                "title": "simple-and-easy-python-solution",
                "content": "**PLEASE UPVOTE**\\n\\t\\n\\tclass Solution:\\n\\t\\tdef letterCasePermutation(self, string: str) -> List[str]:\\n\\n\\t\\t\\tans = []\\n\\n\\t\\t\\tif not string:\\n\\t\\t\\t\\treturn ans\\n\\n\\t\\t\\tdef letter_case_perm(s, index=0, res=\\'\\'):\\n\\n\\t\\t\\t\\twhile index <= len(s) - 1 and s[index].isdigit():\\n\\t\\t\\t\\t\\tres += s[index]\\n\\t\\t\\t\\t\\tindex += 1\\n\\n\\t\\t\\t\\tif index >= len(s):\\n\\t\\t\\t\\t\\tans.append(res)\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tletter_case_perm(s, index+1, res + s[index].lower())\\n\\t\\t\\t\\tletter_case_perm(s, index+1, res + s[index].upper())\\n\\t\\t\\tletter_case_perm(string)\\n\\t\\t\\treturn ans\\n**PLEASE UPVOTE**",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "**PLEASE UPVOTE**\\n\\t\\n\\tclass Solution:\\n\\t\\tdef letterCasePermutation(self, string: str) -> List[str]:\\n\\n\\t\\t\\tans = []\\n\\n\\t\\t\\tif not string:\\n\\t\\t\\t\\treturn ans\\n\\n\\t\\t\\tdef letter_case_perm(s, index=0, res=\\'\\'):\\n\\n\\t\\t\\t\\twhile index <= len(s) - 1 and s[index].isdigit():\\n\\t\\t\\t\\t\\tres += s[index]\\n\\t\\t\\t\\t\\tindex += 1\\n\\n\\t\\t\\t\\tif index >= len(s):\\n\\t\\t\\t\\t\\tans.append(res)\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tletter_case_perm(s, index+1, res + s[index].lower())\\n\\t\\t\\t\\tletter_case_perm(s, index+1, res + s[index].upper())\\n\\t\\t\\tletter_case_perm(string)\\n\\t\\t\\treturn ans\\n**PLEASE UPVOTE**",
                "codeTag": "Java"
            },
            {
                "id": 1893979,
                "title": "easy-solution-o-n-simple-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void permute(string s,vector<string> &res,int i){\\n        if(i==s.length()){\\n            res.push_back(s);\\n            return;\\n        }\\n        if(isalpha(s[i])){\\n            s[i]=toupper(s[i]);\\n            permute(s,res,i+1);\\n            s[i]=tolower(s[i]);\\n            permute(s,res,i+1);\\n        }else{\\n            permute(s,res,i+1);\\n        }\\n    }\\n    vector<string> letterCasePermutation(string s) {\\n        vector<string> res;\\n        permute(s,res,0);\\n        return res;\\n        \\n    }\\n};\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    void permute(string s,vector<string> &res,int i){\\n        if(i==s.length()){\\n            res.push_back(s);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1791038,
                "title": "python-3-60ms-simple-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def letterCasePermutation(self, s: str) -> List[str]:\\n        res = [\\'\\']\\n        for ch in s:\\n            if ch.isalpha():\\n                res = [i+j for i in res for j in [ch.upper(), ch.lower()]]\\n            else:\\n                res = [i+ch for i in res]\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def letterCasePermutation(self, s: str) -> List[str]:\\n        res = [\\'\\']\\n        for ch in s:\\n            if ch.isalpha():\\n                res = [i+j for i in res for j in [ch.upper(), ch.lower()]]\\n            else:\\n                res = [i+ch for i in res]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737542,
                "title": "c-recursive-most-common-type-on-arrays",
                "content": "Solved using exact concept of [78. Subsets](https://leetcode.com/problems/subsets/), that is, to pick and not pick.\\nJust that here, we need to take care of indices at which alphabet appears and backtrack also accordingly.\\nHere, pick represents to toggle its case whereas, not pick represents case is unchanged.\\n```\\nvoid perm(int idx, string ds, vector<string> &ans, string s){\\n        while(idx<s.size()&&isalpha(s[idx])==false){  //reach index of alphabet\\n            ds.push_back(s[idx]);\\n            idx++;\\n        }\\n        if(idx>=s.size()){   //add string to answer\\n            ans.push_back(ds);\\n            return;\\n        }\\n        \\n        if(islower(s[idx])) ds.push_back(toupper(s[idx]));\\n        else ds.push_back(tolower(s[idx]));\\n        perm(idx+1, ds, ans, s);  //pick case\\n        while(isalpha(ds[idx])==false){  //backtrack to the last added alphabet\\n            ds.pop_back();\\n            idx--;\\n        }\\n        ds.pop_back();\\n        ds.push_back(s[idx]);\\n        perm(idx+1, ds, ans, s); //not pick case\\n    }\\n    vector<string> letterCasePermutation(string s) {\\n        vector<string> ans;\\n        string ds;\\n        perm(0, ds, ans, s);\\n        return ans;\\n    }",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "Solved using exact concept of [78. Subsets](https://leetcode.com/problems/subsets/), that is, to pick and not pick.\\nJust that here, we need to take care of indices at which alphabet appears and backtrack also accordingly.\\nHere, pick represents to toggle its case whereas, not pick represents case is unchanged.\\n```\\nvoid perm(int idx, string ds, vector<string> &ans, string s){\\n        while(idx<s.size()&&isalpha(s[idx])==false){  //reach index of alphabet\\n            ds.push_back(s[idx]);\\n            idx++;\\n        }\\n        if(idx>=s.size()){   //add string to answer\\n            ans.push_back(ds);\\n            return;\\n        }\\n        \\n        if(islower(s[idx])) ds.push_back(toupper(s[idx]));\\n        else ds.push_back(tolower(s[idx]));\\n        perm(idx+1, ds, ans, s);  //pick case\\n        while(isalpha(ds[idx])==false){  //backtrack to the last added alphabet\\n            ds.pop_back();\\n            idx--;\\n        }\\n        ds.pop_back();\\n        ds.push_back(s[idx]);\\n        perm(idx+1, ds, ans, s); //not pick case\\n    }\\n    vector<string> letterCasePermutation(string s) {\\n        vector<string> ans;\\n        string ds;\\n        perm(0, ds, ans, s);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1727093,
                "title": "c-iterative-solution",
                "content": "The idea is to get the number of alphabets in the string (let\\'s say n). The number of permutations generated would be 2^n as each alphabet can either be uppercase or lowercase and there are n alphabets. If we represent uppercase as 1 and lowercase as 0, we can number the permutations from 0 ... 2^n - 1 where the binary representation of each number represents which alphabets are uppercase or lowercase.\\n\\n```\\nFor example: \\ns = \"a1b2\"\\nn = 2 as there are 2 alphabets, \\'a\\' and \\'b\\'\\nPossible permutations: \\n\\t0 -> 00 -> \"ab\"\\n\\t1 -> 01 -> \"aB\"\\n\\t2 -> 10 -> \"Ab\"\\n\\t3 -> 11 -> \"AB\"\\n  ```\\n```\\n/*\\n    Time Complexity: O(n * 2^n) [n = s.length]\\n*/\\nclass Solution {\\npublic:\\n    vector<string> letterCasePermutation(string s) {\\n        vector<int> letters;\\n        // Store the index of all alphabets, so we know where to update the \\n        // case of the alphabet in the given string\\n        for(int i = 0; i < s.size(); i++){\\n            if(isalpha(s[i])){\\n                letters.push_back(i);    \\n            }\\n        }\\n        /* Total number of permutations possible is 2 ^ number of alphabets\\n           Each alphabet can either be uppercase or lowercase\\n           Let\\'s represent uppercase by 1 and lowercase by 0\\n           Then each number from 0 ... 2 ^ numAlphas is a unique permutation \\n           whose binary representation tells us exactly which letters will be \\n           uppercase and which will be lower.\\n        */\\n        int totalPermutations = pow(2, letters.size());\\n        \\n        vector<string> ans;\\n        for(int i = 0; i < totalPermutations; i++){\\n            // for each letter update its state to either uppercase or lowercase\\n            // depending on whether the jth position in its binary representation\\n            // is 0(lowercase) or 1(uppercase)\\n            for(int j = 0; j < letters.size(); j++){\\n                int index = letters[j];\\n                /* \\n                    Extracting whether the jth bit is 1 or 0 by creating a mask (1 << j)\\n                    and taking a bitwise and with the current permutation number\\n                    Example: n = 5, i = 26\\n                    i = \"11010\"\\n                    For j = 4,\\n                        11010\\n                    &   01000\\n                    ----------\\n                        01000 = True => The 4th alphabet will be uppercase \\n                */\\n                s[index] = i & (1 << j) ? toupper(s[index]) : tolower(s[index]);\\n            }\\n            // the resulting string is then stored as part of the answer\\n            ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Time Complexity:** **O(n * 2^n)** [n = s.length]\\nMemory better than **96%** of submissions\\nRuntime better than **64%** of submissions",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nFor example: \\ns = \"a1b2\"\\nn = 2 as there are 2 alphabets, \\'a\\' and \\'b\\'\\nPossible permutations: \\n\\t0 -> 00 -> \"ab\"\\n\\t1 -> 01 -> \"aB\"\\n\\t2 -> 10 -> \"Ab\"\\n\\t3 -> 11 -> \"AB\"\\n  ```\n```\\n/*\\n    Time Complexity: O(n * 2^n) [n = s.length]\\n*/\\nclass Solution {\\npublic:\\n    vector<string> letterCasePermutation(string s) {\\n        vector<int> letters;\\n        // Store the index of all alphabets, so we know where to update the \\n        // case of the alphabet in the given string\\n        for(int i = 0; i < s.size(); i++){\\n            if(isalpha(s[i])){\\n                letters.push_back(i);    \\n            }\\n        }\\n        /* Total number of permutations possible is 2 ^ number of alphabets\\n           Each alphabet can either be uppercase or lowercase\\n           Let\\'s represent uppercase by 1 and lowercase by 0\\n           Then each number from 0 ... 2 ^ numAlphas is a unique permutation \\n           whose binary representation tells us exactly which letters will be \\n           uppercase and which will be lower.\\n        */\\n        int totalPermutations = pow(2, letters.size());\\n        \\n        vector<string> ans;\\n        for(int i = 0; i < totalPermutations; i++){\\n            // for each letter update its state to either uppercase or lowercase\\n            // depending on whether the jth position in its binary representation\\n            // is 0(lowercase) or 1(uppercase)\\n            for(int j = 0; j < letters.size(); j++){\\n                int index = letters[j];\\n                /* \\n                    Extracting whether the jth bit is 1 or 0 by creating a mask (1 << j)\\n                    and taking a bitwise and with the current permutation number\\n                    Example: n = 5, i = 26\\n                    i = \"11010\"\\n                    For j = 4,\\n                        11010\\n                    &   01000\\n                    ----------\\n                        01000 = True => The 4th alphabet will be uppercase \\n                */\\n                s[index] = i & (1 << j) ? toupper(s[index]) : tolower(s[index]);\\n            }\\n            // the resulting string is then stored as part of the answer\\n            ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493867,
                "title": "java-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\n    /*\\n    Dedicated to Aditya for his master explanation on various topics\\n    \\n    I/p O/p methods OR Recurrence tree solution\\n    */\\n    List<String> res;\\n    public List<String> letterCasePermutation(String s) {\\n        res = new ArrayList<>();\\n        \\n        solve(s, \"\", 0);\\n        \\n        return res;\\n    }\\n    \\n    void solve(String input, String output, int n){\\n        if(input.length()==n){\\n            res.add(output);\\n            return;\\n        }\\n        \\n        String output1 = new String(output);\\n        String output2 = new String(output);\\n        char c = input.charAt(n);\\n        \\n        if (Character.isAlphabetic(c)){\\n            output1 = output1 + c; // taking character as it is\\n            c ^= (1 << 5); // converts lower-case to upper and upper to lower\\n            output2 = output2 + c; // taking character after converting \\n            \\n            solve(input, output1, n+1);\\n            solve(input, output2, n+1);\\n        }else{\\n            output1 = output1 + c;\\n            solve(input, output1, n+1);\\n        }\\n        \\n        return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    Dedicated to Aditya for his master explanation on various topics\\n    \\n    I/p O/p methods OR Recurrence tree solution\\n    */\\n    List<String> res;\\n    public List<String> letterCasePermutation(String s) {\\n        res = new ArrayList<>();\\n        \\n        solve(s, \"\", 0);\\n        \\n        return res;\\n    }\\n    \\n    void solve(String input, String output, int n){\\n        if(input.length()==n){\\n            res.add(output);\\n            return;\\n        }\\n        \\n        String output1 = new String(output);\\n        String output2 = new String(output);\\n        char c = input.charAt(n);\\n        \\n        if (Character.isAlphabetic(c)){\\n            output1 = output1 + c; // taking character as it is\\n            c ^= (1 << 5); // converts lower-case to upper and upper to lower\\n            output2 = output2 + c; // taking character after converting \\n            \\n            solve(input, output1, n+1);\\n            solve(input, output2, n+1);\\n        }else{\\n            output1 = output1 + c;\\n            solve(input, output1, n+1);\\n        }\\n        \\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1139910,
                "title": "easy-c-recursion-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    void per(vector<string>& str,string ip,string op){\\n        if(ip.length()==0){\\n            str.push_back(op);  //inserting output to vector\\n            return;\\n        }\\n        string op1=op;\\n        string op2=op;\\n        if(isdigit(ip[0])){\\n            op1.push_back(ip[0]); //for digit directly push in output.\\n            ip.erase(ip.begin()+0); //delete digit\\n            per(str,ip,op1); //calling recursive function\\n        }\\n        else{\\n            op1.push_back(tolower(ip[0])); //converting char to lowerCase and pushing into output\\n            op2.push_back(toupper(ip[0])); //converting char to upperCase and pushing into output\\n            ip.erase(ip.begin()+0); //erasing char\\n            per(str,ip,op1); //calling recursive function for lowerCase char\\n            per(str,ip,op2); //calling recursive function for upperCase char\\n        }\\n        return;\\n    }\\n    vector<string> letterCasePermutation(string s) {\\n        vector<string>str;\\n        string ip=s; \\n        string op;\\n        \\n        per(str,ip,op); //calling recursive function\\n        return str;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    void per(vector<string>& str,string ip,string op){\\n        if(ip.length()==0){\\n            str.push_back(op);  //inserting output to vector\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1093972,
                "title": "python-dfs-for-beginners",
                "content": "A widely used template... where \\'path\\' record what we previously have encoutered \\n```\\nclass Solution:\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        path =\"\"\\n        paths = []\\n        self.dfs(S, path, paths, 0)\\n        return paths\\n    \\n    \\n    def dfs(self, S, path, paths, start):\\n        # path: str\\n        # paths: list of str\\n        if start == len(S):\\n            paths.append(path)\\n            return\\n        if S[start].isalpha():\\n            self.dfs(S, path+S[start].lower(), paths, start+1)\\n            self.dfs(S, path+S[start].upper(), paths, start+1)\\n        else:\\n            self.dfs(S, path+S[start], paths, start+1)",
                "solutionTags": [],
                "code": "A widely used template... where \\'path\\' record what we previously have encoutered \\n```\\nclass Solution:\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        path =\"\"\\n        paths = []\\n        self.dfs(S, path, paths, 0)\\n        return paths\\n    \\n    \\n    def dfs(self, S, path, paths, start):\\n        # path: str\\n        # paths: list of str\\n        if start == len(S):\\n            paths.append(path)\\n            return\\n        if S[start].isalpha():\\n            self.dfs(S, path+S[start].lower(), paths, start+1)\\n            self.dfs(S, path+S[start].upper(), paths, start+1)\\n        else:\\n            self.dfs(S, path+S[start], paths, start+1)",
                "codeTag": "C++"
            },
            {
                "id": 1069006,
                "title": "python-level-order-traversal-with-bfs",
                "content": "```py\\n\\'\\'\\'\\nw: level order traversal\\nh: treat an empty string as the root, for each element in the string,\\n\\tif it is a letter, we only have two option, it is like left and right child of a node\\n\\tso for each level:\\n\\t\\t1) if it is a letter, we append lowercase and uppercase to current node and then append the queue\\n\\t\\t2) if it is a number, we directly append to the current node and then append to the queue\\n\\t\\t3) iterate along the string\\n\\'\\'\\'\\nimport collections\\n\\nclass Solution:\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        queue = collections.deque([\\'\\'])\\n        \\n        for s in S:\\n            size = len(queue)\\n            if s.isdigit():\\n                for _ in range(size):\\n                    curr = queue.popleft()\\n                    queue.append(curr + s)\\n            else:\\n                for _ in range(size):\\n                    curr = queue.popleft()\\n                    queue.append(curr + s.lower())\\n                    queue.append(curr + s.upper())\\n        \\n        return list(queue)\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```py\\n\\'\\'\\'\\nw: level order traversal\\nh: treat an empty string as the root, for each element in the string,\\n\\tif it is a letter, we only have two option, it is like left and right child of a node\\n\\tso for each level:\\n\\t\\t1) if it is a letter, we append lowercase and uppercase to current node and then append the queue\\n\\t\\t2) if it is a number, we directly append to the current node and then append to the queue\\n\\t\\t3) iterate along the string\\n\\'\\'\\'\\nimport collections\\n\\nclass Solution:\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        queue = collections.deque([\\'\\'])\\n        \\n        for s in S:\\n            size = len(queue)\\n            if s.isdigit():\\n                for _ in range(size):\\n                    curr = queue.popleft()\\n                    queue.append(curr + s)\\n            else:\\n                for _ in range(size):\\n                    curr = queue.popleft()\\n                    queue.append(curr + s.lower())\\n                    queue.append(curr + s.upper())\\n        \\n        return list(queue)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068328,
                "title": "java-easy-and-with-for-loop",
                "content": "if you like it pls upvote\\n\\nJava\\n\\n```\\nclass Solution {\\n  public List<String> letterCasePermutation(String S) {\\n    List<String> list = new ArrayList<>();\\n    permutation(S, new char[S.length()], 0, list);\\n    return list;\\n  }\\n  private void permutation(String S, char[] result, int p, List<String> list) {\\n    if (p == S.length()) {\\n      list.add(new String(result));\\n      return;\\n    }\\n    char c = S.charAt(p);\\n    result[p] = c;\\n    permutation(S, result, p + 1, list);\\n    if (c >= 65 && c <= 90) {  // uppercase\\n      result[p] = (char) (c + 32);\\n      permutation(S, result, p + 1, list);\\n    }\\n    if (c >= 97 && c <= 122) { // lowercase\\n      result[p] = (char) (c - 32);\\n      permutation(S, result, p + 1, list);\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public List<String> letterCasePermutation(String S) {\\n    List<String> list = new ArrayList<>();\\n    permutation(S, new char[S.length()], 0, list);\\n    return list;\\n  }\\n  private void permutation(String S, char[] result, int p, List<String> list) {\\n    if (p == S.length()) {\\n      list.add(new String(result));\\n      return;\\n    }\\n    char c = S.charAt(p);\\n    result[p] = c;\\n    permutation(S, result, p + 1, list);\\n    if (c >= 65 && c <= 90) {  // uppercase\\n      result[p] = (char) (c + 32);\\n      permutation(S, result, p + 1, list);\\n    }\\n    if (c >= 97 && c <= 122) { // lowercase\\n      result[p] = (char) (c - 32);\\n      permutation(S, result, p + 1, list);\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853236,
                "title": "c-backtracking-clean-solution",
                "content": "\\'\\'\\'\\n\\nclass Solution \\n{\\npublic:\\n\\n    char changecase(char ch)\\n    {\\n        if(islower(ch))\\n            return toupper(ch);\\n        return tolower(ch);\\n    }\\n    void dfs(int i,string &s,vector<string> &ans)\\n    {\\n        if(i==s.length())\\n        {\\n            ans.push_back(s);\\n            return ;\\n        }\\n\\t\\t\\n        if(isalpha(s[i]))\\n        {\\n            dfs(i+1,s,ans);\\n            s[i]=changecase(s[i]);\\n            dfs(i+1,s,ans);\\n            return ;\\n        }\\n        else\\n            dfs(i+1,s,ans);\\n        return ;\\n    }\\n    \\n    vector<string> letterCasePermutation(string S) {\\n        vector<string > ans;\\n        string temp=S;\\n        dfs(0,temp,ans);\\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution \\n{\\npublic:\\n\\n    char changecase(char ch)\\n    {\\n        if(islower(ch))\\n            return toupper(ch);\\n        return tolower(ch);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 785739,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        tmp = set()\\n        result = set()\\n        result.add(S)\\n        \\n        for i in range(len(S)):\\n            for word in result:\\n                    tmp.add(word[:i] + word[i].lower() + word[i + 1:])\\n                    tmp.add(word[:i] + word[i].upper() + word[i + 1:])\\n\\t\\t\\t\\t\\t\\n            # union\\n            result |= tmp\\n\\n        return result\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        tmp = set()\\n        result = set()\\n        result.add(S)\\n        \\n        for i in range(len(S)):\\n            for word in result:\\n                    tmp.add(word[:i] + word[i].lower() + word[i + 1:])\\n                    tmp.add(word[:i] + word[i].upper() + word[i + 1:])\\n\\t\\t\\t\\t\\t\\n            # union\\n            result |= tmp\\n\\n        return result\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 769547,
                "title": "c-solution-using-bit-masks-8-ms-runtime-with-explanation",
                "content": "*Please upvote if this post is useful to you :)*\\n\\n**Lets first look into the easier version of the problem.**\\n\\nThe easier version of the problem would be, to calculate permutations when all characters are letters only(no digit).\\n\\nThis could be done easily by building a mask from 0 to (1<<n) - 1, where 1 would represent letter is in uppercase and 0 would represent letter is in lowercase.\\n```\\nvector<string> ans;\\n// n is the length of the string.\\nfor(int mask=0;mask<(1<<n);mask++) {\\n\\tstring str=\"\";\\n\\tfor(int i=n-1;i>=0;i--) {\\n\\t\\tif(mask & (1<<i)) {\\n\\t\\t\\t// if bit is set we will change to uppercase. \\n\\t\\t\\tstr += toupper(s[i]);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t// if bit is set we will change to lowercase.\\n\\t\\t\\tstr += tolower(s[i]);\\n\\t\\t}\\n\\t}\\n\\tans.push_back(str);\\n}\\n```\\n\\n\\n---\\n\\nThe same concept can be used to solve this problem. We need to care only about the letters and not digit. So, in this case we can build a mask from 0 to (1<<c) - 1, where c is the number of letters in the string.\\n\\nWe need to create a vector that will store the index of the letters.\\n\\n**CPP Code :-**\\n```\\nclass Solution {\\npublic:\\n    vector<string> letterCasePermutation(string s) {\\n        int n = s.length();\\n        vector<string> ans;\\n        int c = 0;\\n\\t\\t// creating a vector to store the index of alphabets.\\n        vector<int> letters;\\n        for(int i=0;i<n;i++) {\\n            if(isalpha(s[i])) {\\n                c++;\\n                letters.push_back(i);\\n            }\\n        }\\n\\t\\t// mask if from 0 to pow(2,c) - 1;\\n        for(int mask=0;mask<(1<<c);mask++) {\\n            string str = s;\\n            int p = 0;\\n            for(int i=c-1;i>=0;i--) {\\n                if(mask & (1<<i)) {\\n\\t\\t\\t\\t\\t// if bit is set we will change the first alphabet (which is not a digit) to uppercase. \\n                    str[letters[p]] = toupper(s[letters[p]]);\\n                }\\n                else {\\n\\t\\t\\t\\t\\t// if bit is set we will change the first alphabet (which is not a digit) to lowercase.\\n                    str[letters[p]] = tolower(s[letters[p]]);\\n                }\\n                p++;\\n            }\\n            ans.push_back(str);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bitmask"
                ],
                "code": "```\\nvector<string> ans;\\n// n is the length of the string.\\nfor(int mask=0;mask<(1<<n);mask++) {\\n\\tstring str=\"\";\\n\\tfor(int i=n-1;i>=0;i--) {\\n\\t\\tif(mask & (1<<i)) {\\n\\t\\t\\t// if bit is set we will change to uppercase. \\n\\t\\t\\tstr += toupper(s[i]);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t// if bit is set we will change to lowercase.\\n\\t\\t\\tstr += tolower(s[i]);\\n\\t\\t}\\n\\t}\\n\\tans.push_back(str);\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> letterCasePermutation(string s) {\\n        int n = s.length();\\n        vector<string> ans;\\n        int c = 0;\\n\\t\\t// creating a vector to store the index of alphabets.\\n        vector<int> letters;\\n        for(int i=0;i<n;i++) {\\n            if(isalpha(s[i])) {\\n                c++;\\n                letters.push_back(i);\\n            }\\n        }\\n\\t\\t// mask if from 0 to pow(2,c) - 1;\\n        for(int mask=0;mask<(1<<c);mask++) {\\n            string str = s;\\n            int p = 0;\\n            for(int i=c-1;i>=0;i--) {\\n                if(mask & (1<<i)) {\\n\\t\\t\\t\\t\\t// if bit is set we will change the first alphabet (which is not a digit) to uppercase. \\n                    str[letters[p]] = toupper(s[letters[p]]);\\n                }\\n                else {\\n\\t\\t\\t\\t\\t// if bit is set we will change the first alphabet (which is not a digit) to lowercase.\\n                    str[letters[p]] = tolower(s[letters[p]]);\\n                }\\n                p++;\\n            }\\n            ans.push_back(str);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 692183,
                "title": "python-2-liner",
                "content": "```python\\nclass Solution:\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        ls = [s.lower() + s.upper() if s.isalpha() else s for s in S ]\\n        return [\\'\\'.join(s) for s in product(*ls)]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        ls = [s.lower() + s.upper() if s.isalpha() else s for s in S ]\\n        return [\\'\\'.join(s) for s in product(*ls)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 621603,
                "title": "c-recursive-solution",
                "content": "```csharp\\npublic IList<string> LetterCasePermutation(string S) \\n{\\n\\treturn generatePermutation(S.ToCharArray(), 0);\\n}\\n\\nprivate List<string> generatePermutation(char[] s, int index)\\n{\\n\\tList<string> result = new List<string>();\\n\\tresult.Add(new string(s));\\n\\n\\tfor(int i = index; i < s.Length; i++)\\n\\t{\\n\\t\\tchar c = s[i];\\n\\t\\tif(char.IsLetter(c))\\n\\t\\t{\\n\\t\\t\\tif(char.IsLower(c))\\n\\t\\t\\t{\\n\\t\\t\\t\\ts[i] = char.ToUpper(c);\\n\\t\\t\\t\\tresult.AddRange(generatePermutation(s, i + 1));\\n\\t\\t\\t\\ts[i] = char.ToLower(c);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\ts[i] = char.ToLower(c);\\n\\t\\t\\t\\tresult.AddRange(generatePermutation(s, i + 1));\\n\\t\\t\\t\\ts[i] = char.ToUpper(c);\\n\\t\\t\\t}               \\n\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic IList<string> LetterCasePermutation(string S) \\n{\\n\\treturn generatePermutation(S.ToCharArray(), 0);\\n}\\n\\nprivate List<string> generatePermutation(char[] s, int index)\\n{\\n\\tList<string> result = new List<string>();\\n\\tresult.Add(new string(s));\\n\\n\\tfor(int i = index; i < s.Length; i++)\\n\\t{\\n\\t\\tchar c = s[i];\\n\\t\\tif(char.IsLetter(c))\\n\\t\\t{\\n\\t\\t\\tif(char.IsLower(c))\\n\\t\\t\\t{\\n\\t\\t\\t\\ts[i] = char.ToUpper(c);\\n\\t\\t\\t\\tresult.AddRange(generatePermutation(s, i + 1));\\n\\t\\t\\t\\ts[i] = char.ToLower(c);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\ts[i] = char.ToLower(c);\\n\\t\\t\\t\\tresult.AddRange(generatePermutation(s, i + 1));\\n\\t\\t\\t\\ts[i] = char.ToUpper(c);\\n\\t\\t\\t}               \\n\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 589792,
                "title": "clean-recursive-java-solution-beats-100",
                "content": "```\\nclass Solution {\\n\\t    List<String> result = new ArrayList<String>();\\n\\t\\tpublic List<String> letterCasePermutation(String S) {\\n\\t        char[] sArr = S.toCharArray();\\n\\t        getLetterCasePermutation(sArr, 0);\\n\\t        return result;\\n\\t    }\\n\\t\\t\\n\\t\\tprivate void getLetterCasePermutation(char[] arr, int i) {\\n\\t\\t\\tif(i == arr.length) {\\n\\t            result.add(new String(arr));\\n\\t            return;\\n\\t        }\\n\\t\\t\\tif(Character.isDigit(arr[i])) {\\n\\t\\t\\t\\tgetLetterCasePermutation(arr, i+1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tchar c = arr[i];\\n\\t\\t\\t\\tarr[i] = Character.toLowerCase(c);\\n\\t\\t\\t\\tgetLetterCasePermutation(arr, i+1);\\n\\t\\t\\t\\tarr[i] = Character.toUpperCase(c);\\n\\t\\t\\t\\tgetLetterCasePermutation(arr, i+1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t    List<String> result = new ArrayList<String>();\\n\\t\\tpublic List<String> letterCasePermutation(String S) {\\n\\t        char[] sArr = S.toCharArray();\\n\\t        getLetterCasePermutation(sArr, 0);\\n\\t        return result;\\n\\t    }\\n\\t\\t\\n\\t\\tprivate void getLetterCasePermutation(char[] arr, int i) {\\n\\t\\t\\tif(i == arr.length) {\\n\\t            result.add(new String(arr));\\n\\t            return;\\n\\t        }\\n\\t\\t\\tif(Character.isDigit(arr[i])) {\\n\\t\\t\\t\\tgetLetterCasePermutation(arr, i+1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tchar c = arr[i];\\n\\t\\t\\t\\tarr[i] = Character.toLowerCase(c);\\n\\t\\t\\t\\tgetLetterCasePermutation(arr, i+1);\\n\\t\\t\\t\\tarr[i] = Character.toUpperCase(c);\\n\\t\\t\\t\\tgetLetterCasePermutation(arr, i+1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 537612,
                "title": "c-backtracking-readable",
                "content": "```\\npublic class Solution {\\n    public IList<string> LetterCasePermutation(string S) {\\n        List<string> result=new List<string>();\\n        BackTrack( result, S,\"\",0);\\n        return result;\\n            \\n    }\\n    public void BackTrack(List<string> result, string s,string temp,int index)\\n    {\\n        if(temp.Length==s.Length)\\n        {\\n            result.Add(temp.ToString());\\n            return;\\n        }\\n      \\n          if(char.IsDigit(s[index]))\\n          {\\n           BackTrack( result, s,temp+s[index],index+1);\\n          }\\n            else\\n            {\\n            BackTrack( result, s,temp+Char.ToLower(s[index]),index+1);\\n            BackTrack( result, s,temp+char.ToUpper(s[index]),index+1);\\n            }\\n           \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public IList<string> LetterCasePermutation(string S) {\\n        List<string> result=new List<string>();\\n        BackTrack( result, S,\"\",0);\\n        return result;\\n            \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 389399,
                "title": "c-kinda-like-finding-subset",
                "content": "```\\npublic class Solution {\\n    public IList<string> LetterCasePermutation(string S) {\\n        var result = new List<string>();\\n               \\n        Helper(S.ToCharArray(), 0, result);\\n        \\n        return result;\\n    }\\n    \\n    private void Helper(char[] arr, int start, List<string> result)\\n    {\\n        result.Add(new string(arr));\\n        \\n        for(var i= start; i< arr.Length; i++)\\n        {\\n            if(char.IsNumber(arr[i]))\\n                continue;\\n            \\n\\t\\t\\t//deep copy\\n            var temp = arr.ToList().ToArray();\\n            \\n            if(char.IsUpper(arr[i]))\\n                temp[i] = char.ToLower(arr[i]);\\n            else\\n                temp[i] = char.ToUpper(arr[i]);\\n            \\n            Helper(temp, i+1, result);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<string> LetterCasePermutation(string S) {\\n        var result = new List<string>();\\n               \\n        Helper(S.ToCharArray(), 0, result);\\n        \\n        return result;\\n    }\\n    \\n    private void Helper(char[] arr, int start, List<string> result)\\n    {\\n        result.Add(new string(arr));\\n        \\n        for(var i= start; i< arr.Length; i++)\\n        {\\n            if(char.IsNumber(arr[i]))\\n                continue;\\n            \\n\\t\\t\\t//deep copy\\n            var temp = arr.ToList().ToArray();\\n            \\n            if(char.IsUpper(arr[i]))\\n                temp[i] = char.ToLower(arr[i]);\\n            else\\n                temp[i] = char.ToUpper(arr[i]);\\n            \\n            Helper(temp, i+1, result);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372703,
                "title": "python-recursive-solution-easy-to-understand",
                "content": "I am a Leetcode rookie so I struggled a lot to understand this problem. But after a while I think I was able to come up to a fairly straight forward solution using recursion. Beats 99% runtime of Python3.\\n\\nIdea: consider that a subproblem means that we are given the \"base\" of the string (that won\\'t be altered anymore for the rest of that recursive branch) and the remaining portion of the string to be processed.\\nOur job is to shrink the problem (```remaining``` in this case) at least by one character at a time. So we can check the first character of ```remaining``` and make a decision:\\n\\n- If it is a number we just append it to the base and continue with one branch of the recursion.\\n- If it is a letter, we have to create two branches of recursion, one where we add to the base a lower case letter and another where we add an upper case letter.\\n\\nIn either case we still have shrunk the problem and we can continue with recursion.\\n\\nAt the end, in the base case, we\\'ll be at a leaf of the recursion and therefore we are ready to add the string we\\'ve built to the solution.\\n\\nThis is kind of what the recursion tree/graph will look like when the input is ```\"a1b2\"```:\\n\\n\\t\\t\\t\\t\\t \"\"\\n\\t\\t\\t\\t   /    \\\\\\n\\t\\t\\t\\t  a       A\\n\\t\\t\\t\\t |         |\\n\\t\\t\\t    a1         A1\\n\\t\\t\\t   /  \\\\        /  \\\\\\n\\t\\t\\t a1b  a1B    A1b  A1B \\n\\t\\t\\t |     |      |    |\\n\\t\\t   a1b2   a1B2   A1b2  A1B2\\n\\t\\t   \\nNote that the nodes of the tree represent the value for ```base``` at each step of the recursion.\\n.\\n.\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.res = []\\n    \\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        # edge case: empty input\\n        if S == \"\":\\n            return [\"\"]\\n        \\n\\t\\t# start recursion at root of tree\\n        self.funct(\"\", S)\\n        return self.res\\n        \\n        \\n    def funct(self, base, remaining):\\n        # base case: we arrived to a leaf of the tree\\n        if len(remaining) == 1:\\n            if remaining.isdigit():\\n                self.res.append(base + remaining)\\n            else:\\n                self.res.append(base + remaining)\\n                self.res.append(base + remaining.swapcase())\\n                \\n        # average case:       \\n        else:   \\n            if remaining[0].isdigit():\\n                self.funct(base + remaining[0], remaining[1:])\\n            else:\\n                self.funct(base + remaining[0], remaining[1:])\\n                self.funct(base + remaining[0].swapcase(), remaining[1:])\\n```\\n\\nI believe the runtime of this is about O(2^m) where m is the number of letters in string S. But correct me if I am wrong.",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```remaining```\n```remaining```\n```\"a1b2\"```\n```base```\n```\\nclass Solution:\\n    def __init__(self):\\n        self.res = []\\n    \\n    def letterCasePermutation(self, S: str) -> List[str]:\\n        # edge case: empty input\\n        if S == \"\":\\n            return [\"\"]\\n        \\n\\t\\t# start recursion at root of tree\\n        self.funct(\"\", S)\\n        return self.res\\n        \\n        \\n    def funct(self, base, remaining):\\n        # base case: we arrived to a leaf of the tree\\n        if len(remaining) == 1:\\n            if remaining.isdigit():\\n                self.res.append(base + remaining)\\n            else:\\n                self.res.append(base + remaining)\\n                self.res.append(base + remaining.swapcase())\\n                \\n        # average case:       \\n        else:   \\n            if remaining[0].isdigit():\\n                self.funct(base + remaining[0], remaining[1:])\\n            else:\\n                self.funct(base + remaining[0], remaining[1:])\\n                self.funct(base + remaining[0].swapcase(), remaining[1:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 355092,
                "title": "solution-in-python-3-beats-97-four-lines",
                "content": "```\\nclass Solution:\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n    \\tT, a = [S.lower()], [i for i, j in enumerate(S) if j.isalpha()]\\n    \\tfor i in range(len(a)):\\n    \\t\\tfor j in range(2**i): T.append(T[j][:a[i]]+T[j][a[i]].upper()+T[j][a[i]+1:])\\n    \\treturn T\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def letterCasePermutation(self, S: str) -> List[str]:\\n    \\tT, a = [S.lower()], [i for i, j in enumerate(S) if j.isalpha()]\\n    \\tfor i in range(len(a)):\\n    \\t\\tfor j in range(2**i): T.append(T[j][:a[i]]+T[j][a[i]].upper()+T[j][a[i]+1:])\\n    \\treturn T\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "codeTag": "Java"
            },
            {
                "id": 155299,
                "title": "javascript-simple-recursion",
                "content": "This is a modification of the subset problem from this PDF: https://see.stanford.edu/materials/icspacs106b/H19-RecBacktrackExamples.pdf.\\n\\n```\\n/**\\n * @param {string} S\\n * @return {string[]}\\n */\\nconst permute = (soFar, rest, output) => {\\n    if (rest.length === 0) {\\n        output.add(soFar);\\n    } else {\\n        const ch = rest.charAt(0);\\n        \\n        permute(soFar + ch.toLowerCase(), rest.substr(1), output);\\n        permute(soFar + ch.toUpperCase(), rest.substr(1), output);\\n    }\\n}\\n\\nconst letterCasePermutation = (s) => {\\n    const output = new Set();\\n    permute(\\'\\', s, output);\\n    return [...output];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} S\\n * @return {string[]}\\n */\\nconst permute = (soFar, rest, output) => {\\n    if (rest.length === 0) {\\n        output.add(soFar);\\n    } else {\\n        const ch = rest.charAt(0);\\n        \\n        permute(soFar + ch.toLowerCase(), rest.substr(1), output);\\n        permute(soFar + ch.toUpperCase(), rest.substr(1), output);\\n    }\\n}\\n\\nconst letterCasePermutation = (s) => {\\n    const output = new Set();\\n    permute(\\'\\', s, output);\\n    return [...output];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 118896,
                "title": "python-80-ms-with-simple-logic",
                "content": "Track every character in S and double result items with swapped case for the character in new item.\\n\\n\\tclass Solution:\\n    def letterCasePermutation(self, S):\\n        out, curr = [str(S)], 0\\n        while curr<len(S):\\n            if S[curr].isalpha(): \\n                mx, i = len(out), 0\\n                while i<mx: \\n                    out.append(str(out[i][:curr]+out[i][curr].swapcase()+out[i][curr+1:]))\\n                    i+=1\\n            curr+=1\\n        return out",
                "solutionTags": [],
                "code": "Track every character in S and double result items with swapped case for the character in new item.\\n\\n\\tclass Solution:\\n    def letterCasePermutation(self, S):\\n        out, curr = [str(S)], 0\\n        while curr<len(S):\\n            if S[curr].isalpha(): \\n                mx, i = len(out), 0\\n                while i<mx: \\n                    out.append(str(out[i][:curr]+out[i][curr].swapcase()+out[i][curr+1:]))\\n                    i+=1\\n            curr+=1\\n        return out",
                "codeTag": "Java"
            },
            {
                "id": 115692,
                "title": "three-python-iterative-and-recursive-solutions",
                "content": "```\nclass Solution(object):\n    def letterCasePermutation(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: List[str]\n        \"\"\"\n        res = ['']\n        for char in S:\n            if char.isalpha():\n                res = [x+y for x in res for y in [char.upper(), char.lower()]]\n            else:\n                res = [x+char for x in res]\n        return res\n```\n\n```\nclass Solution(object):\n    def letterCasePermutation(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        stack = [('', 0)]\n        while stack:\n            output, index = stack.pop()\n            if index == len(S):\n                res.append(output)\n            else:\n                if ord('a') <= ord(S[index]) <= ord('z'):\n                    stack.append((output+chr(ord(S[index])-ord('a')+ord('A')), index+1))\n                if ord('A') <= ord(S[index]) <= ord('Z'):\n                    stack.append((output+chr(ord(S[index])-ord('A')+ord('a')), index+1))\n                stack.append((output+S[index], index+1))\n        return res\n```\n\n```\nclass Solution(object):\n    def letterCasePermutation(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(output, index, res):\n            if index == len(S):\n                res.append(output)\n                return\n            else:\n                if ord('a') <= ord(S[index]) <= ord('z'):\n                    dfs(output+chr(ord(S[index])-ord('a')+ord('A')), index+1, res)\n                if ord('A') <= ord(S[index]) <= ord('Z'):\n                    dfs(output+chr(ord(S[index])-ord('A')+ord('a')), index+1, res)\n                dfs(output+S[index], index+1, res) \n                return\n                \n        res = []\n        dfs('', 0, res)\n        return res\n```",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def letterCasePermutation(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: List[str]\n        \"\"\"\n        res = ['']\n        for char in S:\n            if char.isalpha():\n                res = [x+y for x in res for y in [char.upper(), char.lower()]]\n            else:\n                res = [x+char for x in res]\n        return res\n```\n```\nclass Solution(object):\n    def letterCasePermutation(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        stack = [('', 0)]\n        while stack:\n            output, index = stack.pop()\n            if index == len(S):\n                res.append(output)\n            else:\n                if ord('a') <= ord(S[index]) <= ord('z'):\n                    stack.append((output+chr(ord(S[index])-ord('a')+ord('A')), index+1))\n                if ord('A') <= ord(S[index]) <= ord('Z'):\n                    stack.append((output+chr(ord(S[index])-ord('A')+ord('a')), index+1))\n                stack.append((output+S[index], index+1))\n        return res\n```\n```\nclass Solution(object):\n    def letterCasePermutation(self, S):\n        \"\"\"\n        :type S: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(output, index, res):\n            if index == len(S):\n                res.append(output)\n                return\n            else:\n                if ord('a') <= ord(S[index]) <= ord('z'):\n                    dfs(output+chr(ord(S[index])-ord('a')+ord('A')), index+1, res)\n                if ord('A') <= ord(S[index]) <= ord('Z'):\n                    dfs(output+chr(ord(S[index])-ord('A')+ord('a')), index+1, res)\n                dfs(output+S[index], index+1, res) \n                return\n                \n        res = []\n        dfs('', 0, res)\n        return res\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393379,
                "title": "c-using-recursion-backtracking-t-c-o-2-n-s-c-o-n",
                "content": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(2^n)\\n        Space Complexity : O(n)\\n    */\\n    \\nprivate:\\n    vector<string> res;\\n    string temp = \"\";\\n    \\n    void solve(int i, string s){\\n        if(i >= s.length()){\\n            res.push_back(temp);\\n            return;\\n        }\\n        \\n        // Take as it is or digit\\n        temp.push_back(s[i]);\\n        solve(i+1, s);\\n        temp.pop_back();\\n        \\n        // If char take upper or lowercase\\n        if(isalpha(s[i])){\\n            if(isupper(s[i])){\\n                temp.push_back(tolower(s[i]));\\n            }else{\\n                temp.push_back(toupper(s[i]));\\n            }\\n            \\n            solve(i+1, s);\\n            temp.pop_back();\\n        }\\n    }\\n    \\npublic:\\n    vector<string> letterCasePermutation(string s) {\\n        solve(0, s);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(2^n)\\n        Space Complexity : O(n)\\n    */\\n    \\nprivate:\\n    vector<string> res;\\n    string temp = \"\";\\n    \\n    void solve(int i, string s){\\n        if(i >= s.length()){\\n            res.push_back(temp);\\n            return;\\n        }\\n        \\n        // Take as it is or digit\\n        temp.push_back(s[i]);\\n        solve(i+1, s);\\n        temp.pop_back();\\n        \\n        // If char take upper or lowercase\\n        if(isalpha(s[i])){\\n            if(isupper(s[i])){\\n                temp.push_back(tolower(s[i]));\\n            }else{\\n                temp.push_back(toupper(s[i]));\\n            }\\n            \\n            solve(i+1, s);\\n            temp.pop_back();\\n        }\\n    }\\n    \\npublic:\\n    vector<string> letterCasePermutation(string s) {\\n        solve(0, s);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358500,
                "title": "100-beats-backtracking-java-easy-solution-pick-and-don-t-pick-condition",
                "content": "\\n> # Approach\\nBacktracking algorithm with pick and don\\'t pick condition we can skip digits case is only for alphabets.\\n<!-- Describe your approach to solving the problem. -->\\n\\n> # Complexity\\n- Time complexity: O(N * 2^N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2^N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n> # Code\\n```\\nclass Solution {\\n    List<String> list = new LinkedList<>();\\n    int size = 0;\\n    private void backtrack(char arr[],char str[],int curr){\\n        if(curr==size){\\n            list.add(new String(arr));\\n            return;\\n        }\\n        if(Character.isDigit(str[curr])){\\n            arr[curr]=str[curr];\\n            backtrack(arr,str,curr+1);\\n            return ;\\n        }\\n        arr[curr]=str[curr];\\n        backtrack(arr,str,curr+1);\\n        arr[curr]=Character.toUpperCase(str[curr]);\\n        backtrack(arr,str,curr+1);\\n    }\\n    public List<String> letterCasePermutation(String s) {\\n        size = s.length();\\n        s = s.toLowerCase();\\n        backtrack(new char[size],s.toCharArray(),0);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<String> list = new LinkedList<>();\\n    int size = 0;\\n    private void backtrack(char arr[],char str[],int curr){\\n        if(curr==size){\\n            list.add(new String(arr));\\n            return;\\n        }\\n        if(Character.isDigit(str[curr])){\\n            arr[curr]=str[curr];\\n            backtrack(arr,str,curr+1);\\n            return ;\\n        }\\n        arr[curr]=str[curr];\\n        backtrack(arr,str,curr+1);\\n        arr[curr]=Character.toUpperCase(str[curr]);\\n        backtrack(arr,str,curr+1);\\n    }\\n    public List<String> letterCasePermutation(String s) {\\n        size = s.length();\\n        s = s.toLowerCase();\\n        backtrack(new char[size],s.toCharArray(),0);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276393,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Backtracking\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(2^N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N * 2^N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    string st;\\n    void solve(int i) {\\n        if(i == st.size()) {\\n            ans.push_back(st);\\n            return;\\n        }\\n        if(isalpha(st[i])) {\\n            st[i] = toupper(st[i]);\\n            solve(i + 1);\\n            st[i] = tolower(st[i]);\\n            solve(i + 1);\\n        }\\n        else {\\n            solve(i + 1);\\n        }\\n    }\\n    vector<string> letterCasePermutation(string s) {\\n        st = s;\\n        solve(0);\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    string st;\\n    void solve(int i) {\\n        if(i == st.size()) {\\n            ans.push_back(st);\\n            return;\\n        }\\n        if(isalpha(st[i])) {\\n            st[i] = toupper(st[i]);\\n            solve(i + 1);\\n            st[i] = tolower(st[i]);\\n            solve(i + 1);\\n        }\\n        else {\\n            solve(i + 1);\\n        }\\n    }\\n    vector<string> letterCasePermutation(string s) {\\n        st = s;\\n        solve(0);\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124429,
                "title": "c-solution-with-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    \\n    void help(int i,string temp,string s){\\n        if(i==s.size()){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        if(s[i]>=\\'0\\' && s[i]<= \\'9\\'){\\n            temp+= s[i];\\n            help(i+1, temp, s);\\n        }\\n        else{\\n            temp+= toupper(s[i]);\\n            help(i+1,temp,s);\\n            temp.pop_back();\\n            temp+= tolower(s[i]);\\n            help(i+1,temp,s);\\n        }\\n    }\\n    \\n    \\n    vector<string> letterCasePermutation(string s) {\\n        string temp=\"\";\\n        help(0,temp,s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    \\n    void help(int i,string temp,string s){\\n        if(i==s.size()){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        if(s[i]>=\\'0\\' && s[i]<= \\'9\\'){\\n            temp+= s[i];\\n            help(i+1, temp, s);\\n        }\\n        else{\\n            temp+= toupper(s[i]);\\n            help(i+1,temp,s);\\n            temp.pop_back();\\n            temp+= tolower(s[i]);\\n            help(i+1,temp,s);\\n        }\\n    }\\n    \\n    \\n    vector<string> letterCasePermutation(string s) {\\n        string temp=\"\";\\n        help(0,temp,s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106797,
                "title": "easy-and-optimized-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    List<String>ans=new ArrayList<>();\\n    HashMap<String,Boolean>mp=new HashMap<>();\\n\\n    void count(char[] s,int index){\\n\\n    if(index==s.length){\\n    String temp=new String(s);  \\n    if(!mp.containsKey(temp)){\\n        ans.add(temp);\\n        mp.put(temp,true);\\n    }\\n    return;\\n    }\\n\\n    String temp=new String(s);\\n    //not change index character\\n    if(!mp.containsKey(temp))\\n    count(s,index+1);\\n    //change index character\\n    s[index]=Character.toUpperCase(s[index]);\\n    temp=new String(s);\\n    if(!mp.containsKey(temp))\\n    count(s,index+1);\\n    s[index]=Character.toLowerCase(s[index]);\\n    }\\n\\n    public List<String> letterCasePermutation(String s) {\\n\\n    s=s.toLowerCase();\\n\\n    char[]store=s.toCharArray();\\n\\n    count(store,0);\\n\\n    return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n\\n    List<String>ans=new ArrayList<>();\\n    HashMap<String,Boolean>mp=new HashMap<>();\\n\\n    void count(char[] s,int index){\\n\\n    if(index==s.length){\\n    String temp=new String(s);  \\n    if(!mp.containsKey(temp)){\\n        ans.add(temp);\\n        mp.put(temp,true);\\n    }\\n    return;\\n    }\\n\\n    String temp=new String(s);\\n    //not change index character\\n    if(!mp.containsKey(temp))\\n    count(s,index+1);\\n    //change index character\\n    s[index]=Character.toUpperCase(s[index]);\\n    temp=new String(s);\\n    if(!mp.containsKey(temp))\\n    count(s,index+1);\\n    s[index]=Character.toLowerCase(s[index]);\\n    }\\n\\n    public List<String> letterCasePermutation(String s) {\\n\\n    s=s.toLowerCase();\\n\\n    char[]store=s.toCharArray();\\n\\n    count(store,0);\\n\\n    return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014784,
                "title": "simple-and-easy-to-understand-java-solution",
                "content": "```\\nclass Solution {\\n      public List<String> permutationSpace(String p, String up, ArrayList<String> list){\\n        if(up.length()==0){\\n            list.add(p);\\n            return list;\\n        }\\n\\n        char c = up.charAt(0);\\n\\n        if(Character.isDigit(c)){\\n            permutationSpace(p+c,up.substring(1),list);\\n        }else{\\n                permutationSpace(p+Character.toLowerCase(c),up.substring(1),list);\\n                permutationSpace(p+Character.toUpperCase(c),up.substring(1),list); \\n        }\\n            \\n          return list;\\n    }\\n    \\n    public List<String> letterCasePermutation(String s) {\\n        \\n        return permutationSpace(\"\",s,new ArrayList<>());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n      public List<String> permutationSpace(String p, String up, ArrayList<String> list){\\n        if(up.length()==0){\\n            list.add(p);\\n            return list;\\n        }\\n\\n        char c = up.charAt(0);\\n\\n        if(Character.isDigit(c)){\\n            permutationSpace(p+c,up.substring(1),list);\\n        }else{\\n                permutationSpace(p+Character.toLowerCase(c),up.substring(1),list);\\n                permutationSpace(p+Character.toUpperCase(c),up.substring(1),list); \\n        }\\n            \\n          return list;\\n    }\\n    \\n    public List<String> letterCasePermutation(String s) {\\n        \\n        return permutationSpace(\"\",s,new ArrayList<>());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818238,
                "title": "dfs-solution",
                "content": "# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar letterCasePermutation = function (s) {\\n    let output = [];\\n    dfs(\"\", 0);\\n    return output;\\n\\n\\n    function dfs(str, i) {\\n        if (str.length === s.length) {\\n            output.push(str);\\n            return;\\n        }\\n        if (s[i].toLowerCase() === s[i].toUpperCase()) {\\n            dfs(str + s[i], i + 1);\\n            return;\\n        }\\n\\n        dfs(str + s[i].toLowerCase(), i + 1);\\n        dfs(str + s[i].toUpperCase(), i + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar letterCasePermutation = function (s) {\\n    let output = [];\\n    dfs(\"\", 0);\\n    return output;\\n\\n\\n    function dfs(str, i) {\\n        if (str.length === s.length) {\\n            output.push(str);\\n            return;\\n        }\\n        if (s[i].toLowerCase() === s[i].toUpperCase()) {\\n            dfs(str + s[i], i + 1);\\n            return;\\n        }\\n\\n        dfs(str + s[i].toLowerCase(), i + 1);\\n        dfs(str + s[i].toUpperCase(), i + 1);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2816452,
                "title": "beats-99-submissions-easiest-iterative-solution-fastest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nITERATIVE APPROACH\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nITERATE AND ADD THE CHARACTERS TO THE ANS, IF CHARACTER THEN BOTH LOWER AND UPPER CASE IF NUMERIC THEN ONLY ADD THE NUMBER.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n==>EXPONENTIAL\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n==>O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def letterCasePermutation(self, s: str) -> List[str]:\\n        output=[\"\"]\\n        for c in s:\\n            t=[]\\n            if c.isalpha():\\n                for o in output:\\n                    t.append(o+c.upper())\\n                    t.append(o+c.lower())\\n            else:\\n                for o in output:\\n                    t.append(o+c)\\n            output=t\\n        return output\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def letterCasePermutation(self, s: str) -> List[str]:\\n        output=[\"\"]\\n        for c in s:\\n            t=[]\\n            if c.isalpha():\\n                for o in output:\\n                    t.append(o+c.upper())\\n                    t.append(o+c.lower())\\n            else:\\n                for o in output:\\n                    t.append(o+c)\\n            output=t\\n        return output\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796991,
                "title": "easy-python",
                "content": "def solve(s,out,res):\\n            if(len(s)==0):\\n                res.append(out)\\n                return \\n            if(s[0].isalpha()):\\n                out1=s[0].lower()\\n                out2=s[0].upper()\\n                solve(s[1:],out+out1,res)\\n                solve(s[1:],out+out2,res)\\n            else:\\n                out1=s[0]\\n                solve(s[1:],out+out1,res) \\n            return res\\n        return solve(s,\"\",[])",
                "solutionTags": [],
                "code": "def solve(s,out,res):\\n            if(len(s)==0):\\n                res.append(out)\\n                return \\n            if(s[0].isalpha()):\\n                out1=s[0].lower()\\n                out2=s[0].upper()\\n                solve(s[1:],out+out1,res)\\n                solve(s[1:],out+out2,res)\\n            else:\\n                out1=s[0]\\n                solve(s[1:],out+out1,res) \\n            return res\\n        return solve(s,\"\",[])",
                "codeTag": "Python3"
            },
            {
                "id": 2794577,
                "title": "simple-c-recursion-backtracking",
                "content": "```\\n\\nclass Solution\\n{\\n  void permutation (string s, string output, int i, vector < string > &ans)\\n  {\\n    //base case\\n    if (s.length () == i)\\n      {\\n\\tans.push_back (output);\\n\\treturn;\\n      }\\n\\n    if (isdigit (s[i]))\\n      {\\n     output.push_back (s[i]);\\n\\tpermutation (s, output, i + 1, ans);\\n      }\\n    else\\n      {\\n\\toutput.push_back (s[i]);\\n\\tpermutation (s, output, i + 1, ans);\\n\\toutput.pop_back ();\\n\\t\\n\\tchar a = s[i];\\n\\tif (islower (a))\\n\\t  {\\n\\t    output.push_back (toupper (s[i]));\\n\\t    permutation (s, output, i + 1, ans);\\n\\t  }\\n\\telse\\n\\t  {\\n\\t    char b = s[i];\\n\\t    output.push_back (tolower (s[i]));\\n\\t    permutation (s, output, i + 1, ans);\\n  }\\n  }\\n  }\\npublic:\\n  vector < string > letterCasePermutation (string s)\\n  {\\n    vector < string > ans;\\n    string output = \"\";\\n    int i = 0;\\n    permutation (s, output, i, ans);\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution\\n{\\n  void permutation (string s, string output, int i, vector < string > &ans)\\n  {\\n    //base case\\n    if (s.length () == i)\\n      {\\n\\tans.push_back (output);\\n\\treturn;\\n      }\\n\\n    if (isdigit (s[i]))\\n      {\\n     output.push_back (s[i]);\\n\\tpermutation (s, output, i + 1, ans);\\n      }\\n    else\\n      {\\n\\toutput.push_back (s[i]);\\n\\tpermutation (s, output, i + 1, ans);\\n\\toutput.pop_back ();\\n\\t\\n\\tchar a = s[i];\\n\\tif (islower (a))\\n\\t  {\\n\\t    output.push_back (toupper (s[i]));\\n\\t    permutation (s, output, i + 1, ans);\\n\\t  }\\n\\telse\\n\\t  {\\n\\t    char b = s[i];\\n\\t    output.push_back (tolower (s[i]));\\n\\t    permutation (s, output, i + 1, ans);\\n  }\\n  }\\n  }\\npublic:\\n  vector < string > letterCasePermutation (string s)\\n  {\\n    vector < string > ans;\\n    string output = \"\";\\n    int i = 0;\\n    permutation (s, output, i, ans);\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2626214,
                "title": "c-backtrack-solution",
                "content": "class Solution {\\npublic:\\n    vector<string>ans;\\n    void ok(string &s,string curr,int ind)\\n    {\\n        if((int)curr.size()==((int)s.size()))\\n        {\\n            ans.push_back(curr);\\n            return ;\\n        }\\n        if(s[ind]>=\\'0\\'&&s[ind]<=\\'9\\')\\n            ok(s,curr+s[ind],ind+1);\\n        else\\n        {\\n            ok(s,curr+(char)(toupper(s[ind])),ind+1);\\n            ok(s,curr+(char)(tolower(s[ind])),ind+1);\\n        }\\n        return ;\\n    }\\n    vector<string> letterCasePermutation(string s)\\n    {\\n        int n=s.size();\\n        string curr=\"\";\\n        ok(s,curr,0);\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string>ans;\\n    void ok(string &s,string curr,int ind)\\n    {\\n        if((int)curr.size()==((int)s.size()))\\n        {\\n            ans.push_back(curr);\\n            return ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2626207,
                "title": "c-solution-using-backtracking",
                "content": "class Solution {\\n    void permute(string v,string s,vector<string>&ans,int i)\\n    {\\n        if(i==s.length())\\n        {\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(isdigit(s[i]))\\n        { \\n             permute(v+s[i],s,ans,i+1);  \\n        }\\n        else\\n        {\\n          char ch=toupper(s[i]);\\n            char c=tolower(s[i]);\\n        permute(v+c,s,ans,i+1);\\n        permute(v+ch,s,ans,i+1);   \\n        }\\n    }\\npublic:\\n    vector<string> letterCasePermutation(string s)\\n    { \\n           vector<string>ans;\\n        string v=\"\";\\n        permute(v,s,ans,0);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    void permute(string v,string s,vector<string>&ans,int i)\\n    {\\n        if(i==s.length())\\n        {\\n            ans.push_back(v);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2608134,
                "title": "python-no-bfs-no-dfs-no-backtracking-with-explanation",
                "content": "Writing this because most solutions use backtracking, DFS, or BFS. There are some crazy 1-liner solutions or others that use a the same approach in generating the cartesian product of all permutations. However, none of them are intuitive or easy to follow. So hopefully this can help explain the process  and offer a different perspective.\\n\\n\\n**Intuition**\\n\\n\\nCapitalizing a letter is a binary decision, either we capitalize or don\\'t capitalize - each letter essentially has two choices.\\n\\nSince we can\\'t capitalize numbers, we ignore them. Now each string is essentially a series of binary choices.\\n\\nExample: \\n* \"a1b2\" --> ignore numbers --> \"a - b -\" --> \"ab\" --> 2 * 2 choices\\n* \"ddgj2ck4\" --> \"ddgj-ck-\" --> \"ddgjck\" --> 2 * 6 choices\\n\\n\\n**Problem conversion**\\n\\n\\nWe\\'ve now converted the problem into finding all possible binary strings of `n` bits (or decisions). To do so, we can use `itertools.product()` to compute the cartesian product with the parameter `repeat = n` to choose the length of the binary string to geneate. This may look familiar...\\n\\n**Cartesian product of binary variables of size `n`**\\n```\\nimport itertools\\n\\n[\"\".join(x) for x in itertools.product(\"01\", repeat = 1)]\\n>> [\\'0\\', \\'1\\']\\n\\n[\"\".join(x) for x in itertools.product(\"01\", repeat = 2)]\\n>> [\\'00\\', \\'01\\', \\'10\\', \\'11\\']\\n\\n[\"\".join(x) for x in itertools.product(\"01\", repeat = 3)]\\n>> [\\'000\\', \\'001\\', \\'010\\', \\'011\\', \\'100\\', \\'101\\', \\'110\\', \\'111\\']\\n\\n[\"\".join(x) for x in itertools.product(\"01\", repeat = 4)]\\n>> [\\'0000\\', \\'0001\\', \\'0010\\', \\'0011\\', \\'0100\\', \\'0101\\', \\'0110\\', \\'0111\\', \\'1000\\', \\'1001\\', \\'1010\\', \\'1011\\', \\'1100\\', \\'1101\\', \\'1110\\', \\'1111\\']\\n```\\n\\n\\n**Back to the problem**\\n\\n\\nNow that we have a better picture of the new problem (hopefully I didn\\'t butcher the explanation), we can apply it to this question. There are 1-liner solutions that do this exact same thing, but those violate many software engineering principles, especially being readable and maintainable. \\n\\nHere\\'s a readable version (you can probably optimize this further, lmk if there\\'s a pythonic way to do the inner for loop!)\\n\\n```\\nimport itertools\\nimport re\\n\\nclass Solution:\\n    def letterCasePermutation(self, s: str) -> List[str]:\\n        all_strings = []\\n        \\n        mapping = re.sub(\"[a-zA-Z]\", \"*\", s)    # replace all letters with *, choice of * is arbitrary\\n        pool = re.sub(\"\\\\d\", \"\", s)              # pool of available letters in order\\n                                                # len(pool) == number of * in mapping\\n            \\n        n = sum([char.isalpha() for char in s]) # finding n\\n\\t\\t\\n\\t\\t# choice of <> here is arbitrary, any other symbols work\\n\\t\\t# we just need to pick which represents lowercase/uppercase\\n        cartesian_product = [\"\".join(x) for x in itertools.product(\"<>\", repeat = n)] \\n        \\n        for comb in cartesian_product:\\n            new_str = mapping\\n\\t\\t\\t\\n\\t\\t\\t# replace each * one at a time with the appropriate letter in pool, \\n\\t\\t\\t# capitalizing it based on the specific combination (comb) indicated\\n            for i, c in enumerate(comb):\\n                char = pool[i].lower() if c == \"<\" else pool[i].upper()\\n                new_str = new_str.replace(\"*\", char, 1) # replace first occurrence\\n\\t\\t\\t\\t\\n            all_strings.append(new_str)\\n            \\n        return all_strings\\n```\\n\\nWe create a `mapping` of the string `s` so that we eventually replace every `*` in `mapping`. The `pool` of available characters are the letters that we initially replaced. Note that the size of `pool` should be the same as the number of `*`.\\n\\nThe inner for loop just maps all the generated binary strings of size `n` back to the original string.\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport itertools\\n\\n[\"\".join(x) for x in itertools.product(\"01\", repeat = 1)]\\n>> [\\'0\\', \\'1\\']\\n\\n[\"\".join(x) for x in itertools.product(\"01\", repeat = 2)]\\n>> [\\'00\\', \\'01\\', \\'10\\', \\'11\\']\\n\\n[\"\".join(x) for x in itertools.product(\"01\", repeat = 3)]\\n>> [\\'000\\', \\'001\\', \\'010\\', \\'011\\', \\'100\\', \\'101\\', \\'110\\', \\'111\\']\\n\\n[\"\".join(x) for x in itertools.product(\"01\", repeat = 4)]\\n>> [\\'0000\\', \\'0001\\', \\'0010\\', \\'0011\\', \\'0100\\', \\'0101\\', \\'0110\\', \\'0111\\', \\'1000\\', \\'1001\\', \\'1010\\', \\'1011\\', \\'1100\\', \\'1101\\', \\'1110\\', \\'1111\\']\\n```\n```\\nimport itertools\\nimport re\\n\\nclass Solution:\\n    def letterCasePermutation(self, s: str) -> List[str]:\\n        all_strings = []\\n        \\n        mapping = re.sub(\"[a-zA-Z]\", \"*\", s)    # replace all letters with *, choice of * is arbitrary\\n        pool = re.sub(\"\\\\d\", \"\", s)              # pool of available letters in order\\n                                                # len(pool) == number of * in mapping\\n            \\n        n = sum([char.isalpha() for char in s]) # finding n\\n\\t\\t\\n\\t\\t# choice of <> here is arbitrary, any other symbols work\\n\\t\\t# we just need to pick which represents lowercase/uppercase\\n        cartesian_product = [\"\".join(x) for x in itertools.product(\"<>\", repeat = n)] \\n        \\n        for comb in cartesian_product:\\n            new_str = mapping\\n\\t\\t\\t\\n\\t\\t\\t# replace each * one at a time with the appropriate letter in pool, \\n\\t\\t\\t# capitalizing it based on the specific combination (comb) indicated\\n            for i, c in enumerate(comb):\\n                char = pool[i].lower() if c == \"<\" else pool[i].upper()\\n                new_str = new_str.replace(\"*\", char, 1) # replace first occurrence\\n\\t\\t\\t\\t\\n            all_strings.append(new_str)\\n            \\n        return all_strings\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598293,
                "title": "c-easy-backtrack-recursion-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void helper(string s, int index)\\n    {\\n        // Base Case\\n        if(index >= s.length())\\n        {\\n            ans.push_back(s);\\n            return;\\n        }\\n        // If s[index] is uppercase, convert to lower and call for helper again\\n        if(s[index] >= 65 and s[index] <= 90)\\n        {\\n            s[index] = (int)tolower(s[index]);\\n            helper(s, index + 1);\\n            s[index] = (int)toupper(s[index]);\\n        }\\n        // if(s[index]) is lowercase, convert to uppercase and call for helper\\n        else if(s[index] >= 97 and s[index] <= 122)\\n        {\\n            s[index] = (int)toupper(s[index]);\\n            helper(s, index + 1);\\n            s[index] = (int)tolower(s[index]);\\n        }\\n        // if s[index] is not a letter, ie a digit or something else\\n        helper(s, index + 1);\\n    }\\n    \\n    vector<string> letterCasePermutation(string s) {\\n        helper(s, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    void helper(string s, int index)\\n    {\\n        // Base Case\\n        if(index >= s.length())\\n        {\\n            ans.push_back(s);\\n            return;\\n        }\\n        // If s[index] is uppercase, convert to lower and call for helper again\\n        if(s[index] >= 65 and s[index] <= 90)\\n        {\\n            s[index] = (int)tolower(s[index]);\\n            helper(s, index + 1);\\n            s[index] = (int)toupper(s[index]);\\n        }\\n        // if(s[index]) is lowercase, convert to uppercase and call for helper\\n        else if(s[index] >= 97 and s[index] <= 122)\\n        {\\n            s[index] = (int)toupper(s[index]);\\n            helper(s, index + 1);\\n            s[index] = (int)tolower(s[index]);\\n        }\\n        // if s[index] is not a letter, ie a digit or something else\\n        helper(s, index + 1);\\n    }\\n    \\n    vector<string> letterCasePermutation(string s) {\\n        helper(s, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2523067,
                "title": "cpp-recursion-bactracking-simple-solution",
                "content": "\\tclass Solution {\\n\\tprivate:\\n\\t\\tvoid  help(vector<string>&ans,string s,int i=0){\\n\\t\\t\\t//base case\\n\\t\\t\\tif(i==s.size()){\\n\\t\\t\\t\\tans.push_back(s);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\t//everytime we have two choices\\n\\t\\t\\t//without changing\\n\\t\\t\\t//with changing\\n\\n\\t\\t\\t//withoug changing\\n\\t\\t\\thelp(ans,s,i+1);\\n\\n\\t\\t\\t//with changing\\n\\t\\t\\tif(s[i]>=\\'a\\' && s[i]<=\\'z\\'){\\n\\t\\t\\t\\ts[i]=toupper(s[i]);\\n\\t\\t\\t\\thelp(ans,s,i+1);\\n\\t\\t\\t\\ts[i]=tolower(s[i]);\\n\\t\\t\\t}\\n\\t\\t\\telse if(s[i]>=\\'A\\' && s[i]<=\\'Z\\'){\\n\\t\\t\\t\\ts[i]=tolower(s[i]);\\n\\t\\t\\t\\thelp(ans,s,i+1);\\n\\t\\t\\t\\ts[i]=toupper(s[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\tpublic:\\n\\t\\tvector<string> letterCasePermutation(string s) {\\n\\t\\t\\tvector<string>v;\\n\\t\\t\\thelp(v,s);\\n\\t\\t\\treturn v;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tprivate:\\n\\t\\tvoid  help(vector<string>&ans,string s,int i=0){\\n\\t\\t\\t//base case\\n\\t\\t\\tif(i==s.size()){\\n\\t\\t\\t\\tans.push_back(s);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2520866,
                "title": "typescript-javascript-dfs-with-comments",
                "content": "```\\nfunction letterCasePermutation(s: string): string[] {\\n  const result = [];\\n  dfs([...s], result, 0);\\n  return result;\\n};\\n\\nfunction dfs(str, result, index){\\n  if(index === str.length){\\n    result.push(str.join(\"\"));\\n    return;\\n  }\\n  \\n  if(isNaN(Number(str[index])))\\n  {\\n    // we have two options if it is a character\\n    // try with character being uppercase\\n    str[index] = str[index].toUpperCase();\\n    dfs(str, result, index + 1);\\n    \\n    // try with character being lowercase\\n    str[index] = str[index].toLowerCase();\\n    dfs(str, result, index + 1);\\n  }\\n  else // if it is a number\\n    dfs(str, result, index + 1);\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nfunction letterCasePermutation(s: string): string[] {\\n  const result = [];\\n  dfs([...s], result, 0);\\n  return result;\\n};\\n\\nfunction dfs(str, result, index){\\n  if(index === str.length){\\n    result.push(str.join(\"\"));\\n    return;\\n  }\\n  \\n  if(isNaN(Number(str[index])))\\n  {\\n    // we have two options if it is a character\\n    // try with character being uppercase\\n    str[index] = str[index].toUpperCase();\\n    dfs(str, result, index + 1);\\n    \\n    // try with character being lowercase\\n    str[index] = str[index].toLowerCase();\\n    dfs(str, result, index + 1);\\n  }\\n  else // if it is a number\\n    dfs(str, result, index + 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2516707,
                "title": "c-easy-solution-using-recursion-easy-to-understand",
                "content": "**if my code help  you then pls upvote**\\n\\n```\\n void permute(string s, int i, string temp, vector<string> &ans){\\n    \\n    // Base case\\n    if(i >= s.length()){\\n        ans.push_back(temp);\\n        return;\\n    }\\n    \\n    if(s[i] >= \\'0\\' && s[i] <= \\'9\\'){\\n        temp.push_back(s[i]);\\n        permute(s, i+1, temp, ans);\\n    }\\n    else{\\n        temp.push_back(tolower(s[i]));\\n        permute(s, i+1, temp, ans);\\n        \\n        // backtrack\\n        temp.pop_back();\\n        \\n        temp.push_back(toupper(s[i]));\\n        permute(s, i+1, temp, ans);\\n    }\\n}\\n\\n    \\n    vector<string> letterCasePermutation(string s) {\\n        \\n        vector<string>ans;\\n        \\n        permute(s, 0, \"\", ans);\\n        \\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n void permute(string s, int i, string temp, vector<string> &ans){\\n    \\n    // Base case\\n    if(i >= s.length()){\\n        ans.push_back(temp);\\n        return;\\n    }\\n    \\n    if(s[i] >= \\'0\\' && s[i] <= \\'9\\'){\\n        temp.push_back(s[i]);\\n        permute(s, i+1, temp, ans);\\n    }\\n    else{\\n        temp.push_back(tolower(s[i]));\\n        permute(s, i+1, temp, ans);\\n        \\n        // backtrack\\n        temp.pop_back();\\n        \\n        temp.push_back(toupper(s[i]));\\n        permute(s, i+1, temp, ans);\\n    }\\n}\\n\\n    \\n    vector<string> letterCasePermutation(string s) {\\n        \\n        vector<string>ans;\\n        \\n        permute(s, 0, \"\", ans);\\n        \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2349918,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public List<String> letterCasePermutation(String s) {\\n        List<String> ans = new ArrayList<>();\\n        findPermutations(s, \"\", ans);\\n        return ans;\\n    }\\n    public void findPermutations(String input, String temp, List<String> ans) {\\n        if(input.length() == 0) {\\n            ans.add(temp);\\n            return;\\n        }\\n        char ch = input.charAt(0);\\n        if(Character.isDigit(ch)){\\n            findPermutations(input.substring(1), temp + ch, ans);\\n        }else{\\n            findPermutations(input.substring(1), temp + Character.toLowerCase(ch), ans);\\n            findPermutations(input.substring(1), temp + Character.toUpperCase(ch), ans);\\n        }\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> letterCasePermutation(String s) {\\n        List<String> ans = new ArrayList<>();\\n        findPermutations(s, \"\", ans);\\n        return ans;\\n    }\\n    public void findPermutations(String input, String temp, List<String> ans) {\\n        if(input.length() == 0) {\\n            ans.add(temp);\\n            return;\\n        }\\n        char ch = input.charAt(0);\\n        if(Character.isDigit(ch)){\\n            findPermutations(input.substring(1), temp + ch, ans);\\n        }else{\\n            findPermutations(input.substring(1), temp + Character.toLowerCase(ch), ans);\\n            findPermutations(input.substring(1), temp + Character.toUpperCase(ch), ans);\\n        }\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322896,
                "title": "straightforward-python-backtracking-solution",
                "content": "At every position in the string: \\n- check whether the character is a numeric or an alphabet\\n- if alpha: convert the character at this position in the string to uppercase and lowercase and recursion at the next in these two new string\\n- if numeric: skip the character at this position and recursion at the next position of the same string\\n- append the words to the result list when reached at the end of the list\\n```\\nclass Solution:\\n    def letterCasePermutation(self, s: str) -> List[str]:\\n        res = []\\n        def backtrack(i, word):\\n            if i == len(word): \\n                res.append(word)\\n                return\\n            if word[i].isalpha():\\n                W1 = word[:i] + word[i].lower() + word[i+1:]\\n                backtrack(i+1, W1)\\n                W2 = word[:i] + word[i].upper() + word[i+1:]\\n                backtrack(i+1, W2)\\n            else: backtrack(i+1, word)\\n        backtrack(0, s)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def letterCasePermutation(self, s: str) -> List[str]:\\n        res = []\\n        def backtrack(i, word):\\n            if i == len(word): \\n                res.append(word)\\n                return\\n            if word[i].isalpha():\\n                W1 = word[:i] + word[i].lower() + word[i+1:]\\n                backtrack(i+1, W1)\\n                W2 = word[:i] + word[i].upper() + word[i+1:]\\n                backtrack(i+1, W2)\\n            else: backtrack(i+1, word)\\n        backtrack(0, s)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319139,
                "title": "simple-backtracking-c",
                "content": "```\\nclass Solution {\\n    void dfs(int i, string &s, vector<string> &ans) {\\n        ans.push_back(s);\\n        if(i == s.size()) return;\\n        \\n        for(int j=i; j<s.size(); j++) {\\n            if(s[j] >= \\'0\\' && s[j] <= \\'9\\') continue;\\n            if(isupper(s[j])) {\\n                s[j] += 32;\\n                dfs(j + 1, s, ans);\\n                s[j] -= 32;\\n            }\\n            else {\\n                s[j] -= 32;\\n                dfs(j + 1, s, ans);\\n                s[j] += 32;\\n            }\\n        }\\n    }\\npublic:\\n    vector<string> letterCasePermutation(string s) {\\n        vector<string> ans;\\n        dfs(0, s, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int i, string &s, vector<string> &ans) {\\n        ans.push_back(s);\\n        if(i == s.size()) return;\\n        \\n        for(int j=i; j<s.size(); j++) {\\n            if(s[j] >= \\'0\\' && s[j] <= \\'9\\') continue;\\n            if(isupper(s[j])) {\\n                s[j] += 32;\\n                dfs(j + 1, s, ans);\\n                s[j] -= 32;\\n            }\\n            else {\\n                s[j] -= 32;\\n                dfs(j + 1, s, ans);\\n                s[j] += 32;\\n            }\\n        }\\n    }\\npublic:\\n    vector<string> letterCasePermutation(string s) {\\n        vector<string> ans;\\n        dfs(0, s, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260751,
                "title": "java-backtracking",
                "content": "```\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\npublic class LetterCasePermutation {\\n    List<String> results = new ArrayList<>();\\n    String s;\\n\\n    public List<String> letterCasePermutation(String s) {\\n        this.s = s;\\n        backtrack(new StringBuilder(), 0);\\n        return results;\\n\\n    }\\n\\n    private void backtrack(StringBuilder sb, int index) {\\n        if (index == s.length()) {\\n            results.add(sb.toString());\\n            return;\\n        }\\n        char c = s.charAt(index);\\n        if (Character.isDigit(c)) {\\n            sb.append(c);\\n            backtrack(new StringBuilder(sb), index + 1);\\n        } else {\\n            sb.append(Character.toLowerCase(c));\\n            backtrack(new StringBuilder(sb), index + 1);\\n            sb.deleteCharAt(sb.length() - 1);\\n            sb.append(Character.toUpperCase(c));\\n            backtrack(new StringBuilder(sb), index + 1);\\n        }\\n\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\npublic class LetterCasePermutation {\\n    List<String> results = new ArrayList<>();\\n    String s;\\n\\n    public List<String> letterCasePermutation(String s) {\\n        this.s = s;\\n        backtrack(new StringBuilder(), 0);\\n        return results;\\n\\n    }\\n\\n    private void backtrack(StringBuilder sb, int index) {\\n        if (index == s.length()) {\\n            results.add(sb.toString());\\n            return;\\n        }\\n        char c = s.charAt(index);\\n        if (Character.isDigit(c)) {\\n            sb.append(c);\\n            backtrack(new StringBuilder(sb), index + 1);\\n        } else {\\n            sb.append(Character.toLowerCase(c));\\n            backtrack(new StringBuilder(sb), index + 1);\\n            sb.deleteCharAt(sb.length() - 1);\\n            sb.append(Character.toUpperCase(c));\\n            backtrack(new StringBuilder(sb), index + 1);\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241582,
                "title": "python-easy-recursion-solution-with-explanation",
                "content": "[](http:https://youtu.be/4eOPYDOiwFo//)\\n```\\nclass Solution(object):\\n    def letterCasePermutation(self, s):\\n        def permutationFind(  inputs,output,arr):\\n            if len(inputs)==0:\\n                arr.append(output)\\n                return\\n        \\n            if inputs[0].isalpha()==True:\\n                out1 = output\\n                out2 = output\\n                out1+=inputs[0].lower()\\n                out2 += inputs[0].upper()\\n                inputs = inputs[1:] \\n                permutationFind(inputs,out1,arr) \\n                permutationFind(inputs,out2,arr)\\n            else:\\n                out1=output\\n                out1+=inputs[0]\\n                inputs=inputs[1:]\\n                permutationFind(inputs,out1,arr)\\n                \\n            return\\n        \\n        s2=\"\"\\n        arr=[]\\n        permutationFind(s,s2,arr)\\n        return arr\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def letterCasePermutation(self, s):\\n        def permutationFind(  inputs,output,arr):\\n            if len(inputs)==0:\\n                arr.append(output)\\n                return\\n        \\n            if inputs[0].isalpha()==True:\\n                out1 = output\\n                out2 = output\\n                out1+=inputs[0].lower()\\n                out2 += inputs[0].upper()\\n                inputs = inputs[1:] \\n                permutationFind(inputs,out1,arr) \\n                permutationFind(inputs,out2,arr)\\n            else:\\n                out1=output\\n                out1+=inputs[0]\\n                inputs=inputs[1:]\\n                permutationFind(inputs,out1,arr)\\n                \\n            return\\n        \\n        s2=\"\"\\n        arr=[]\\n        permutationFind(s,s2,arr)\\n        return arr\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240981,
                "title": "100-faster-simplest-recursive-solution-ever",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(string ip,string op,set<string>&ans){\\n       if(ip.length()==0){\\n           ans.insert(op);\\n           return;\\n       } \\n       string op1=op;\\n        char b=tolower(ip[0]);\\n        op1+=b;\\n       string op2=op;\\n        char a=toupper(ip[0]);\\n        op2+=a;\\n        ip.erase(ip.begin()+0);\\n        solve(ip,op1,ans);\\n        solve(ip,op2,ans);\\n    }\\n    vector<string> letterCasePermutation(string s) {\\n        vector<string>res;\\n        set<string>ans;\\n        solve(s,\"\",ans);\\n        for(auto x:ans){\\n            res.push_back(x);\\n        }\\n        // reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(string ip,string op,set<string>&ans){\\n       if(ip.length()==0){\\n           ans.insert(op);\\n           return;\\n       } \\n       string op1=op;\\n        char b=tolower(ip[0]);\\n        op1+=b;\\n       string op2=op;\\n        char a=toupper(ip[0]);\\n        op2+=a;\\n        ip.erase(ip.begin()+0);\\n        solve(ip,op1,ans);\\n        solve(ip,op2,ans);\\n    }\\n    vector<string> letterCasePermutation(string s) {\\n        vector<string>res;\\n        set<string>ans;\\n        solve(s,\"\",ans);\\n        for(auto x:ans){\\n            res.push_back(x);\\n        }\\n        // reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2236234,
                "title": "python3-bitmasking-with-comment",
                "content": "```\\nclass Solution:\\n    def letterCasePermutation(self, s: str) -> List[str]:\\n        def bitmasking(output):\\n            # number of character bits\\n            b = sum([a.isalpha() for a in s])            \\n            for n in range(2**b, 2**(b+1)):\\n                # generagte example bit mask \\n                # 0 0\\n                # 0 1\\n                # 1 0 \\n                # 1 1\\n                bitmask = bin(n)[3:]\\n                st = []\\n                # to keep track which bitmask we looking at\\n                bt = 0\\n                for i in range(len(s)):\\n                    c = s[i]\\n                    if c.isalpha():\\n                        # if character if \\'0\\' mean lower else upper\\n                        if bitmask[bt] == \\'0\\':\\n                            st.append(c.lower())\\n                        elif bitmask[bt] == \\'1\\':\\n                            st.append(c.upper())\\n                        bt += 1\\n                    else:\\n                        # for numbe just append\\n                        st.append(c)\\n                output.append(\\'\\'.join(st))\\n        output = []\\n        bitmasking(output)\\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def letterCasePermutation(self, s: str) -> List[str]:\\n        def bitmasking(output):\\n            # number of character bits\\n            b = sum([a.isalpha() for a in s])            \\n            for n in range(2**b, 2**(b+1)):\\n                # generagte example bit mask \\n                # 0 0\\n                # 0 1\\n                # 1 0 \\n                # 1 1\\n                bitmask = bin(n)[3:]\\n                st = []\\n                # to keep track which bitmask we looking at\\n                bt = 0\\n                for i in range(len(s)):\\n                    c = s[i]\\n                    if c.isalpha():\\n                        # if character if \\'0\\' mean lower else upper\\n                        if bitmask[bt] == \\'0\\':\\n                            st.append(c.lower())\\n                        elif bitmask[bt] == \\'1\\':\\n                            st.append(c.upper())\\n                        bt += 1\\n                    else:\\n                        # for numbe just append\\n                        st.append(c)\\n                output.append(\\'\\'.join(st))\\n        output = []\\n        bitmasking(output)\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219038,
                "title": "go-simple-easy-to-understand",
                "content": "```\\n\\nfunc letterCasePermutation(s string) []string {\\n\\tvar res []string\\n    \\n\\tres = append(res, s)\\n\\n\\tfor i := 0; i < len(s); i++ {\\n        if isDigit(s[i]) {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n        length := len(res)\\n\\n\\t\\tfor j := 0; j < length; j++ {\\n            var newChar byte\\n\\t\\t\\tvar newStr string\\n            \\n\\t\\t\\toldStr := res[j]\\n\\n\\t\\t\\tif oldStr[i] >= \\'a\\' && oldStr[i] <= \\'z\\' {\\n\\t\\t\\t\\tnewChar = oldStr[i] - 32\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tnewChar = oldStr[i] + 32\\n\\t\\t\\t}\\n\\n\\t\\t\\tnewStr = oldStr[:i] + fmt.Sprintf(\"%c\", newChar) + oldStr[i+1:]\\n            \\n\\t\\t\\tres = append(res, newStr)\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n\\nfunc isDigit(i byte) bool {\\n\\treturn i == 48 || i == 49 || i == 50 || i == 51 || i == 52 || i == 53 || i == 54 || i == 55 || i == 56 || i == 57\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```\\n\\nfunc letterCasePermutation(s string) []string {\\n\\tvar res []string\\n    \\n\\tres = append(res, s)\\n\\n\\tfor i := 0; i < len(s); i++ {\\n        if isDigit(s[i]) {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n        length := len(res)\\n\\n\\t\\tfor j := 0; j < length; j++ {\\n            var newChar byte\\n\\t\\t\\tvar newStr string\\n            \\n\\t\\t\\toldStr := res[j]\\n\\n\\t\\t\\tif oldStr[i] >= \\'a\\' && oldStr[i] <= \\'z\\' {\\n\\t\\t\\t\\tnewChar = oldStr[i] - 32\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tnewChar = oldStr[i] + 32\\n\\t\\t\\t}\\n\\n\\t\\t\\tnewStr = oldStr[:i] + fmt.Sprintf(\"%c\", newChar) + oldStr[i+1:]\\n            \\n\\t\\t\\tres = append(res, newStr)\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n\\nfunc isDigit(i byte) bool {\\n\\treturn i == 48 || i == 49 || i == 50 || i == 51 || i == 52 || i == 53 || i == 54 || i == 55 || i == 56 || i == 57\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2192437,
                "title": "letter-case-permutation",
                "content": "```\\nclass Solution {\\n    void f(string&s, int i, vector<string>&ans){\\n        if(i==s.size()){\\n            ans.push_back(s);\\n            return;\\n        }\\n        \\n        \\n        if(s[i]>=\\'0\\' && s[i]<=\\'9\\')f(s, i+1, ans);\\n        else{\\n            s[i]=toupper(s[i]);\\n            f(s, i+1, ans);\\n            s[i]=tolower(s[i]);\\n            f(s, i+1, ans);\\n        }\\n    }\\npublic:\\n    vector<string> letterCasePermutation(string s) {\\n        vector<string> ans;\\n        \\n        f(s, 0, ans);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    void f(string&s, int i, vector<string>&ans){\\n        if(i==s.size()){\\n            ans.push_back(s);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2189641,
                "title": "easy-to-understand-backtracking-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void solve(vector<string> &ans,string s,string tem,int i){\\n        if(s[i] == \\'\\\\0\\'){\\n            ans.push_back(tem);\\n            return;\\n        }\\n        //if s[i] is digit\\n        if(s[i] >= \\'0\\' && s[i] <= \\'9\\'){\\n            tem += s[i];\\n            solve(ans,s,tem,i+1);\\n            tem.pop_back();\\n        }\\n        //if s[i] is lowercase\\n        if(s[i] >= \\'a\\' && s[i] <= \\'z\\'){\\n            //call for lower case\\n            tem += (s[i]);\\n            solve(ans,s,tem,i+1);\\n            tem.pop_back();\\n            //call for uppercase\\n            tem += (s[i] - 32);\\n            solve(ans,s,tem,i+1);\\n            tem.pop_back();\\n        }else if(s[i] >= \\'A\\' && s[i] <= \\'Z\\'){\\n            //call for lower case\\n            tem += (s[i]);\\n            solve(ans,s,tem,i+1);\\n            tem.pop_back();\\n            //call for uppercase\\n            tem += (s[i] + 32);\\n            solve(ans,s,tem,i+1);\\n            tem.pop_back();\\n        }\\n        return ;\\n    }\\n    \\n    vector<string> letterCasePermutation(string s) {\\n        vector<string> ans;\\n        string tem;\\n        solve(ans,s,tem,0);\\n        return ans;\\n    }\\n};\\n\\tif(you like my solution) return upvote;\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void solve(vector<string> &ans,string s,string tem,int i){\\n        if(s[i] == \\'\\\\0\\'){\\n            ans.push_back(tem);\\n            return;\\n        }\\n        //if s[i] is digit\\n        if(s[i] >= \\'0\\' && s[i] <= \\'9\\'){\\n            tem += s[i];\\n            solve(ans,s,tem,i+1);\\n            tem.pop_back();\\n        }\\n        //if s[i] is lowercase\\n        if(s[i] >= \\'a\\' && s[i] <= \\'z\\'){\\n            //call for lower case\\n            tem += (s[i]);\\n            solve(ans,s,tem,i+1);\\n            tem.pop_back();\\n            //call for uppercase\\n            tem += (s[i] - 32);\\n            solve(ans,s,tem,i+1);\\n            tem.pop_back();\\n        }else if(s[i] >= \\'A\\' && s[i] <= \\'Z\\'){\\n            //call for lower case\\n            tem += (s[i]);\\n            solve(ans,s,tem,i+1);\\n            tem.pop_back();\\n            //call for uppercase\\n            tem += (s[i] + 32);\\n            solve(ans,s,tem,i+1);\\n            tem.pop_back();\\n        }\\n        return ;\\n    }\\n    \\n    vector<string> letterCasePermutation(string s) {\\n        vector<string> ans;\\n        string tem;\\n        solve(ans,s,tem,0);\\n        return ans;\\n    }\\n};\\n\\tif(you like my solution) return upvote;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2182767,
                "title": "c-recursion-easy-to-understand",
                "content": "This problem can be solved using recursion\\n\\n\\n```\\n void solve(int index,int n,string s,vector<string> &ans){\\n        \\n\\t\\t// If we are at the last index push string into a vector\\n        if(index==n){\\n            ans.push_back(s);\\n            return;\\n        }\\n        \\n\\t\\t// store current char for further use\\n        char c=s[index];\\n        isupper(s[index])? c=tolower(s[index]) : c=toupper(s[index]); // Change from lower to upper (vice versa)\\n        solve(index+1,n,s,ans);\\n\\t\\t\\n        if(isalpha(s[index])){\\n            s[index]=c;\\n            solve(index+1,n,s,ans);\\n        }\\n    }\\n    \\n    vector<string> letterCasePermutation(string s) {\\n       vector<string> ans;\\n        int n=s.size();\\n        solve(0,n,s,ans);\\n        return ans;\\n    }\\n```\\nConsider n is the length of  a string\\n**Time complexity: O(2^n)**\\n**Space Complexity: O(n)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n void solve(int index,int n,string s,vector<string> &ans){\\n        \\n\\t\\t// If we are at the last index push string into a vector\\n        if(index==n){\\n            ans.push_back(s);\\n            return;\\n        }\\n        \\n\\t\\t// store current char for further use\\n        char c=s[index];\\n        isupper(s[index])? c=tolower(s[index]) : c=toupper(s[index]); // Change from lower to upper (vice versa)\\n        solve(index+1,n,s,ans);\\n\\t\\t\\n        if(isalpha(s[index])){\\n            s[index]=c;\\n            solve(index+1,n,s,ans);\\n        }\\n    }\\n    \\n    vector<string> letterCasePermutation(string s) {\\n       vector<string> ans;\\n        int n=s.size();\\n        solve(0,n,s,ans);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2169554,
                "title": "java-backtrack-3ms",
                "content": "\\tclass Solution {\\n\\t\\tpublic List<String> letterCasePermutation(String S) {\\n\\t\\t   List<String> ans = new ArrayList<>();\\n\\t\\t\\tif(S.length() == 0){\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t\\thelper(S.toCharArray(), ans, 0);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tprivate void helper(char[] str, List<String> ans, int index){\\n\\t\\t\\tif(index == str.length){\\n\\t\\t\\t\\tans.add(new String(str));\\n\\t\\t\\t\\treturn ;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(Character.isDigit(str[index])){\\n\\t\\t\\t\\thelper(str, ans, index+1);\\n\\t\\t\\t\\treturn ;\\n\\t\\t\\t} else{\\n\\t\\t\\t\\tstr[index] = Character.toLowerCase(str[index]);\\n\\t\\t\\t\\thelper(str, ans, index+1);\\n\\n\\t\\t\\t\\tstr[index] = Character.toUpperCase(str[index]);\\n\\t\\t\\t\\thelper(str, ans, index+1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\tpublic List<String> letterCasePermutation(String S) {\\n\\t\\t   List<String> ans = new ArrayList<>();\\n\\t\\t\\tif(S.length() == 0){\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2136072,
                "title": "784-letter-case-permutation-easy-recursion-explain",
                "content": "Approach : Recursion\\n-----\\nwhat is problem :- problem is that in given input we have to generate possible combinations of small case and upper case characters\\n\\nStep 1: let under stand first cases three cases if char is an integer so just push it no need to convert upper case and lower\\nstep 2 : if it is an char then pass 2 output it can be upper case and lower case  \\nstep 3 : make 2 string input and output and pass to helper\\nstep 4 : if input become empty then push the output in answer vector\\nstep 5 : check cases if input value is int just push into output and pass to solver function again\\nstep 6 : if it is an char then 2 output will generate lower and upper and pass them to solver function \\nstep 7 : easyy pessy....\\n\\nif it helps don\\'t forget to upvote\\uD83D\\uDC46\\n------\\n\\n\\uD83D\\uDC27 What is a dying programmer\\'s last program?\\n\\t\\tGoodbye, world!\\n\\t\\tdefinitely not hello world ....\\n\\n    \\n    vector<string> ans;\\n        \\n    void solver(string input,string output){\\n        \\n        //base case\\n        if(input.length()==0){\\n            ans.push_back(output);\\n            return;\\n        }\\n        //if it it an integer so dont recurse just skip \\n        if(isdigit(input[0])){\\n            \\n            //string op1=output;\\n            output.push_back(input[0]);\\n            input.erase(input.begin()+0);\\n            solver(input,output);\\n        }\\n        \\n        else{    \\n        //two outputs 1 upper 1 lower\\n         string op1=output;\\n         string op2=output;\\n        op1.push_back(toupper(input[0]));\\n        op2.push_back(tolower(input[0]));\\n        \\n        input.erase(input.begin()+0);\\n        \\n        solver(input,op1);\\n        solver(input,op2);\\n       // return;\\n        }\\n    }\\n    \\n    vector<string> letterCasePermutation(string s) {\\n        \\n        string input=s;\\n        string output=\"\";\\n        \\n        solver(input,output);\\n        return ans;\\n    }\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "Approach : Recursion\\n-----\\nwhat is problem :- problem is that in given input we have to generate possible combinations of small case and upper case characters\\n\\nStep 1: let under stand first cases three cases if char is an integer so just push it no need to convert upper case and lower\\nstep 2 : if it is an char then pass 2 output it can be upper case and lower case  \\nstep 3 : make 2 string input and output and pass to helper\\nstep 4 : if input become empty then push the output in answer vector\\nstep 5 : check cases if input value is int just push into output and pass to solver function again\\nstep 6 : if it is an char then 2 output will generate lower and upper and pass them to solver function \\nstep 7 : easyy pessy....\\n\\nif it helps don\\'t forget to upvote\\uD83D\\uDC46\\n------\\n\\n\\uD83D\\uDC27 What is a dying programmer\\'s last program?\\n\\t\\tGoodbye, world!\\n\\t\\tdefinitely not hello world ....\\n\\n    \\n    vector<string> ans;\\n        \\n    void solver(string input,string output){\\n        \\n        //base case\\n        if(input.length()==0){\\n            ans.push_back(output);\\n            return;\\n        }\\n        //if it it an integer so dont recurse just skip \\n        if(isdigit(input[0])){\\n            \\n            //string op1=output;\\n            output.push_back(input[0]);\\n            input.erase(input.begin()+0);\\n            solver(input,output);\\n        }\\n        \\n        else{    \\n        //two outputs 1 upper 1 lower\\n         string op1=output;\\n         string op2=output;\\n        op1.push_back(toupper(input[0]));\\n        op2.push_back(tolower(input[0]));\\n        \\n        input.erase(input.begin()+0);\\n        \\n        solver(input,op1);\\n        solver(input,op2);\\n       // return;\\n        }\\n    }\\n    \\n    vector<string> letterCasePermutation(string s) {\\n        \\n        string input=s;\\n        string output=\"\";\\n        \\n        solver(input,output);\\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2120026,
                "title": "easy-recursive-solution-with-python",
                "content": "Similar to questions on \"combination\" and \"permutation\", we recursively check whether the string obtained (denoted by variable \"path\" in my code) is eligible to add to the result. The only key difference is that instead of enumerating every element in the remaining letters (denoted by \"options\"), **we take only ONE element at each recursive call**.\\n![image](https://assets.leetcode.com/users/images/66f99ca8-2fa2-4818-a483-c235a2bc2180_1654555317.6563108.png)\\n\\n\\n```\\nclass Solution(object):\\n    def letterCasePermutation(self, s):\\n        res = []\\n        \\n        def helper(res, path, options):\\n            if len(options) == 0:\\n                res.append(path)\\n            else:\\n\\t\\t\\t\\t#Take one element from string and update remaining options\\n                num = options[0]\\n                options = options[1:]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t#If the element is number, simply append it and continue\\n\\t\\t\\t\\t#otherwise append both the upper and lower case of the letter\\n                if num.isdigit():\\n                    helper(res, path+num, options)\\n                else:\\n                    helper(res, path+num.lower(), options)\\n                    helper(res, path+num.upper(), options)\\n                    \\n        helper(res, \"\", s)\\n        return res\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def letterCasePermutation(self, s):\\n        res = []\\n        \\n        def helper(res, path, options):\\n            if len(options) == 0:\\n                res.append(path)\\n            else:\\n\\t\\t\\t\\t#Take one element from string and update remaining options\\n                num = options[0]\\n                options = options[1:]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t#If the element is number, simply append it and continue\\n\\t\\t\\t\\t#otherwise append both the upper and lower case of the letter\\n                if num.isdigit():\\n                    helper(res, path+num, options)\\n                else:\\n                    helper(res, path+num.lower(), options)\\n                    helper(res, path+num.upper(), options)\\n                    \\n        helper(res, \"\", s)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093184,
                "title": "easy-understanding-very-fast-small-code-aditya-verma",
                "content": "\\n\\t vector<string>ans;\\n    void letter(string ip,int i,string op)\\n    {\\n        if(ip.size()==i)\\n        {\\n            ans.push_back(op);\\n            return ;\\n        }\\n        op.push_back(ip[i]); //including without coverting\\n        letter(ip,i+1,op);\\n        op.pop_back();  \\n        if(ip[i]>=65 && ip[i] <= 90)\\n        {\\n            op.push_back(ip[i] + 32); //if char is upper case converting into lower case\\n            letter(ip,i+1,op);\\n        }\\n        else if(ip[i]>=97 && ip[i] <= 122)\\n        {\\n            op.push_back(ip[i]-32); //if char is lower case converting into upper case\\n            letter(ip,i+1,op);\\n        }\\n        return ;\\n    }\\n    vector<string> letterCasePermutation(string s) {\\n        string s1;\\n        letter(s,0,s1);\\n        return ans;``\\n    }",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "\\n\\t vector<string>ans;\\n    void letter(string ip,int i,string op)\\n    {\\n        if(ip.size()==i)\\n        {\\n            ans.push_back(op);\\n            return ;\\n        }\\n        op.push_back(ip[i]); //including without coverting\\n        letter(ip,i+1,op);\\n        op.pop_back();  \\n        if(ip[i]>=65 && ip[i] <= 90)\\n        {\\n            op.push_back(ip[i] + 32); //if char is upper case converting into lower case\\n            letter(ip,i+1,op);\\n        }\\n        else if(ip[i]>=97 && ip[i] <= 122)\\n        {\\n            op.push_back(ip[i]-32); //if char is lower case converting into upper case\\n            letter(ip,i+1,op);\\n        }\\n        return ;\\n    }\\n    vector<string> letterCasePermutation(string s) {\\n        string s1;\\n        letter(s,0,s1);\\n        return ans;``\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2046718,
                "title": "simple-python-recursive-solution",
                "content": "```\\nclass Solution:\\n    def letterCasePermutation(self, s: str) -> List[str]:\\n      res = []\\n      \\n      def combi(s, i, curr):\\n        if len(curr) == len(s):\\n          res.append(curr)\\n          return\\n        \\n        if not s[i].isdigit():\\n          val = s[i].lower()\\n          combi(s, i+1, curr+ val)\\n          val = s[i].upper()\\n          combi(s, i+1, curr+ val)\\n        else:\\n          combi(s, i+1, curr+s[i])\\n          \\n      combi(s, 0, \"\")\\n      return res  \\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def letterCasePermutation(self, s: str) -> List[str]:\\n      res = []\\n      \\n      def combi(s, i, curr):\\n        if len(curr) == len(s):\\n          res.append(curr)\\n          return\\n        \\n        if not s[i].isdigit():\\n          val = s[i].lower()\\n          combi(s, i+1, curr+ val)\\n          val = s[i].upper()\\n          combi(s, i+1, curr+ val)\\n        else:\\n          combi(s, i+1, curr+s[i])\\n          \\n      combi(s, 0, \"\")\\n      return res  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997463,
                "title": "c-easy-code-recursion-understandable-approach-efficient-approach",
                "content": "#Diff Approaches:-\\na) Backtracking \\nb) Bit manipulation\\n\\n#Variations :-\\na) In this question if the output was sorted then -> Sort the Input String \\nb) If there were no Repetations -> skip the same letter or Maintain a stack \\n```\\nclass Solution {\\npublic:\\n    void helper(string s, vector<string> &v, string op)\\n    {\\n        if(!s.size())\\n        {\\n\\t\\t// Jab Input String Empty ho jaaye -> Base Case (When the input is empty)\\n            v.push_back(op);\\n            return;\\n        }\\n\\t\\t// -> Two output strings to store diff outputs\\n        auto op1 = op;\\n        auto op2 = op;\\n        auto c = s[0];\\n        s.erase(s.begin()+0);\\n\\t\\t// Checking if the character is an alphabet or not\\n        if(c>=\\'a\\'&&c<=\\'z\\'||c>=\\'A\\'&&c<=\\'Z\\')\\n        {   op1.push_back(tolower(c));\\n            op2.push_back(toupper(c));\\n            helper(s,v,op1);\\n            helper(s,v,op2);\\n        }\\n\\t\\t// if not\\n        else{\\n            op.push_back(c);\\n            helper(s,v,op);\\n        }\\n    }\\n    \\n    vector<string> letterCasePermutation(string s) {\\n        vector<string> v;\\n        string op = \"\";\\n        helper(s,v,op);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(string s, vector<string> &v, string op)\\n    {\\n        if(!s.size())\\n        {\\n\\t\\t// Jab Input String Empty ho jaaye -> Base Case (When the input is empty)\\n            v.push_back(op);\\n            return;\\n        }\\n\\t\\t// -> Two output strings to store diff outputs\\n        auto op1 = op;\\n        auto op2 = op;\\n        auto c = s[0];\\n        s.erase(s.begin()+0);\\n\\t\\t// Checking if the character is an alphabet or not\\n        if(c>=\\'a\\'&&c<=\\'z\\'||c>=\\'A\\'&&c<=\\'Z\\')\\n        {   op1.push_back(tolower(c));\\n            op2.push_back(toupper(c));\\n            helper(s,v,op1);\\n            helper(s,v,op2);\\n        }\\n\\t\\t// if not\\n        else{\\n            op.push_back(c);\\n            helper(s,v,op);\\n        }\\n    }\\n    \\n    vector<string> letterCasePermutation(string s) {\\n        vector<string> v;\\n        string op = \"\";\\n        helper(s,v,op);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1923437,
                "title": "java-backtracking-faster-than-94-26",
                "content": "```\\nclass Solution {\\n    private final int diff = (int)\\'A\\' - (int)\\'a\\';\\n    private final int a = (int)\\'a\\';\\n    private final int z = (int)\\'z\\';\\n    private final int A = (int)\\'A\\';\\n    private final int Z = (int)\\'Z\\';\\n    List<String> result;\\n    char[] chars;\\n    public List<String> letterCasePermutation(String s) {\\n        chars = s.toCharArray();\\n        result = new ArrayList<>();\\n        dfs(0);\\n        return result;\\n    }\\n    \\n    public void dfs(int i) {\\n        if(i == chars.length) {\\n            result.add(new String(chars));\\n            return;\\n        }\\n        if (Character.isDigit(chars[i])) {\\n            dfs(i + 1);\\n        } else {\\n            chars[i] = toUpper(chars[i]);  \\n            dfs(i + 1);\\n            chars[i] = toLower(chars[i]);  \\n            dfs(i + 1);\\n        }\\n    }\\n    public char toLower(char c) {\\n        if(c >= A && c <= Z) {\\n            return (char)(c - diff);\\n        } else {\\n            return c;\\n        }\\n    }\\n    public char toUpper(char c) {\\n        if(c >= A && c <= Z) {\\n            return c;\\n        } else {\\n            return (char)(c + diff);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    private final int diff = (int)\\'A\\' - (int)\\'a\\';\\n    private final int a = (int)\\'a\\';\\n    private final int z = (int)\\'z\\';\\n    private final int A = (int)\\'A\\';\\n    private final int Z = (int)\\'Z\\';\\n    List<String> result;\\n    char[] chars;\\n    public List<String> letterCasePermutation(String s) {\\n        chars = s.toCharArray();\\n        result = new ArrayList<>();\\n        dfs(0);\\n        return result;\\n    }\\n    \\n    public void dfs(int i) {\\n        if(i == chars.length) {\\n            result.add(new String(chars));\\n            return;\\n        }\\n        if (Character.isDigit(chars[i])) {\\n            dfs(i + 1);\\n        } else {\\n            chars[i] = toUpper(chars[i]);  \\n            dfs(i + 1);\\n            chars[i] = toLower(chars[i]);  \\n            dfs(i + 1);\\n        }\\n    }\\n    public char toLower(char c) {\\n        if(c >= A && c <= Z) {\\n            return (char)(c - diff);\\n        } else {\\n            return c;\\n        }\\n    }\\n    public char toUpper(char c) {\\n        if(c >= A && c <= Z) {\\n            return c;\\n        } else {\\n            return (char)(c + diff);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894895,
                "title": "simple-python-backtracking-solution",
                "content": "```\\nclass Solution(object):\\n    def letterCasePermutation(self, s):\\n        arr = []\\n        \\n        def backTracking(subString):\\n            \\n            count = len(subString)\\n            \\n            if (count== len(s)):\\n                arr.append(subString)\\n                return\\n                \\n            if(s[count].isalpha()):\\n                backTracking(subString+s[count].swapcase())\\n                \\n            backTracking(subString +s[count])\\n            \\n        backTracking(\"\")\\n        return arr\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def letterCasePermutation(self, s):\\n        arr = []\\n        \\n        def backTracking(subString):\\n            \\n            count = len(subString)\\n            \\n            if (count== len(s)):\\n                arr.append(subString)\\n                return\\n                \\n            if(s[count].isalpha()):\\n                backTracking(subString+s[count].swapcase())\\n                \\n            backTracking(subString +s[count])\\n            \\n        backTracking(\"\")\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863840,
                "title": "simple-java-solution-backtracking",
                "content": "```\\nclass Solution {\\n    public List<String> letterCasePermutation(String s) {\\n        \\n        List<String> ans=new ArrayList<>();\\n        permutation(s,0,ans,\"\");\\n        \\n        return ans;\\n    }\\n    \\n    void permutation(String s,int index,List<String> ans,String curr){\\n        if(index==s.length()){\\n            ans.add(curr);\\n            return;\\n        }\\n        \\n        if(s.charAt(index)>=\\'0\\' && s.charAt(index)<=\\'9\\'){\\n            permutation(s,index+1,ans,curr+String.valueOf(s.charAt(index)));\\n        }\\n        else{\\n            permutation(s,index+1,ans,curr+String.valueOf(s.charAt(index)).toLowerCase());\\n            permutation(s,index+1,ans,curr+String.valueOf(s.charAt(index)).toUpperCase());\\n            \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> letterCasePermutation(String s) {\\n        \\n        List<String> ans=new ArrayList<>();\\n        permutation(s,0,ans,\"\");\\n        \\n        return ans;\\n    }\\n    \\n    void permutation(String s,int index,List<String> ans,String curr){\\n        if(index==s.length()){\\n            ans.add(curr);\\n            return;\\n        }\\n        \\n        if(s.charAt(index)>=\\'0\\' && s.charAt(index)<=\\'9\\'){\\n            permutation(s,index+1,ans,curr+String.valueOf(s.charAt(index)));\\n        }\\n        else{\\n            permutation(s,index+1,ans,curr+String.valueOf(s.charAt(index)).toLowerCase());\\n            permutation(s,index+1,ans,curr+String.valueOf(s.charAt(index)).toUpperCase());\\n            \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863660,
                "title": "backtracking-python",
                "content": "```\\nclass Solution:\\n    def letterCasePermutation(self, s: str) -> List[str]:\\n        \\n        res = []\\n\\n        def helper(per):\\n            \\n            i = len(per)\\n            \\n            if i == len(s):\\n                res.append(per)\\n                return\\n            \\n            if s[i].isalpha():\\n                helper(per + s[i].swapcase())\\n            helper(per + s[i])\\n        \\n        helper(\\'\\')\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def letterCasePermutation(self, s: str) -> List[str]:\\n        \\n        res = []\\n\\n        def helper(per):\\n            \\n            i = len(per)\\n            \\n            if i == len(s):\\n                res.append(per)\\n                return\\n            \\n            if s[i].isalpha():\\n                helper(per + s[i].swapcase())\\n            helper(per + s[i])\\n        \\n        helper(\\'\\')\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1813048,
                "title": "python-very-easy-to-understand-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def letterCasePermutation(self, s: str) -> List[str]:\\n        # Purpose: show all letter permutations of a string\\n        # Method: Backtracking (Recursion)\\n        # Intuition: slice the string till end. For alpha, append lower and upper. For num, append.\\n        \\n        # init\\n        string = s\\n        word = \\'\\'\\n        res = []\\n        \\n        # find \\n        self.backtrack(string, word, res)\\n        \\n        # return\\n        return res\\n        \\n    \\n    def backtrack(self, string, word, res):\\n        # corner case: end of string \\n        if not string:\\n            res.append(word)\\n            return None\\n        \\n        # For alpha, append lower and upper\\n        if string[0].isalpha():\\n            self.backtrack(string[1:], word + string[0].upper(), res)\\n            self.backtrack(string[1:], word + string[0].lower(), res)\\n        \\n        # For num, append\\n        else:\\n            self.backtrack(string[1:], word + string[0], res)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def letterCasePermutation(self, s: str) -> List[str]:\\n        # Purpose: show all letter permutations of a string\\n        # Method: Backtracking (Recursion)\\n        # Intuition: slice the string till end. For alpha, append lower and upper. For num, append.\\n        \\n        # init\\n        string = s\\n        word = \\'\\'\\n        res = []\\n        \\n        # find \\n        self.backtrack(string, word, res)\\n        \\n        # return\\n        return res\\n        \\n    \\n    def backtrack(self, string, word, res):\\n        # corner case: end of string \\n        if not string:\\n            res.append(word)\\n            return None\\n        \\n        # For alpha, append lower and upper\\n        if string[0].isalpha():\\n            self.backtrack(string[1:], word + string[0].upper(), res)\\n            self.backtrack(string[1:], word + string[0].lower(), res)\\n        \\n        # For num, append\\n        else:\\n            self.backtrack(string[1:], word + string[0], res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1795202,
                "title": "javascript-using-set",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nconst DIGIT_REGEX = /[0-9]+/g;\\nvar letterCasePermutation = function(s) {\\n    \\n\\t/* Original string itself is a one of the valid combination. */\\n    let set = new Set([s]);\\n    let copyS;\\n    let index = 0, values;\\n    \\n    while(index < s.length) {\\n\\t    /* Skip digit to keep them in place, while moving forward refer original string */\\n        if (s[index].match(DIGIT_REGEX)) {\\n            index++;\\n            continue;\\n        }\\n        \\n\\t\\t/* Get all combinations generated so far */\\n        values = [...set.values()];\\n        \\n        for(let i = 0; i < values.length; i++) {\\n            copyS = [...values[i]];\\n            \\n\\t\\t\\t/*\\n\\t\\t\\t * Take every combination generated so far and manipulate the `index`\\n\\t\\t\\t * to lowercase and uppercase to generate new pair \\n\\t\\t\\t*/\\n            copyS[index] = copyS[index].toLowerCase();\\n            set.add(copyS.join(\\'\\'));\\n            \\n            copyS[index] = copyS[index].toUpperCase();\\n            set.add(copyS.join(\\'\\'));        \\n        }\\n        \\n        index++;\\n    }\\n    \\n    return [...set.values()];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nconst DIGIT_REGEX = /[0-9]+/g;\\nvar letterCasePermutation = function(s) {\\n    \\n\\t/* Original string itself is a one of the valid combination. */\\n    let set = new Set([s]);\\n    let copyS;\\n    let index = 0, values;\\n    \\n    while(index < s.length) {\\n\\t    /* Skip digit to keep them in place, while moving forward refer original string */\\n        if (s[index].match(DIGIT_REGEX)) {\\n            index++;\\n            continue;\\n        }\\n        \\n\\t\\t/* Get all combinations generated so far */\\n        values = [...set.values()];\\n        \\n        for(let i = 0; i < values.length; i++) {\\n            copyS = [...values[i]];\\n            \\n\\t\\t\\t/*\\n\\t\\t\\t * Take every combination generated so far and manipulate the `index`\\n\\t\\t\\t * to lowercase and uppercase to generate new pair \\n\\t\\t\\t*/\\n            copyS[index] = copyS[index].toLowerCase();\\n            set.add(copyS.join(\\'\\'));\\n            \\n            copyS[index] = copyS[index].toUpperCase();\\n            set.add(copyS.join(\\'\\'));        \\n        }\\n        \\n        index++;\\n    }\\n    \\n    return [...set.values()];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1768669,
                "title": "easy-recursive-java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> letterCasePermutation(String s) {\\n        List<String> ans = new ArrayList<>();\\n        solve(s, 0, ans);\\n        return ans;\\n    }\\n    \\n    private void solve(String s, int index, List<String> ans){\\n        ans.add(s);\\n        for(int i = index; i<s.length(); i++){\\n            if(isAlphabet(s, i)){\\n                String newStr = changeCase(s, i);\\n                solve(newStr, i+1, ans);\\n            }\\n        }\\n    }\\n    \\n    private boolean isAlphabet(String s, int i){\\n        return Character.isLetter(s.charAt(i));\\n    }\\n    \\n    private String changeCase(String s, int i){\\n        char[] arr = s.toCharArray();\\n        if (Character.isUpperCase(arr[i]))\\n            arr[i] = Character.toLowerCase(arr[i]);\\n        else \\n            arr[i] = Character.toUpperCase(arr[i]);\\n        return String.valueOf(arr);\\n    }\\n} \\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> letterCasePermutation(String s) {\\n        List<String> ans = new ArrayList<>();\\n        solve(s, 0, ans);\\n        return ans;\\n    }\\n    \\n    private void solve(String s, int index, List<String> ans){\\n        ans.add(s);\\n        for(int i = index; i<s.length(); i++){\\n            if(isAlphabet(s, i)){\\n                String newStr = changeCase(s, i);\\n                solve(newStr, i+1, ans);\\n            }\\n        }\\n    }\\n    \\n    private boolean isAlphabet(String s, int i){\\n        return Character.isLetter(s.charAt(i));\\n    }\\n    \\n    private String changeCase(String s, int i){\\n        char[] arr = s.toCharArray();\\n        if (Character.isUpperCase(arr[i]))\\n            arr[i] = Character.toLowerCase(arr[i]);\\n        else \\n            arr[i] = Character.toUpperCase(arr[i]);\\n        return String.valueOf(arr);\\n    }\\n} \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1821734,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "A basic approach to generating all possible permutations of a string where each letter can be either lowercase or uppercase is to use a recursive approach that generates a search tree with two branches at each level of recursion, one for the lowercase letter and one for the uppercase letter.\\n\\nThe recursion should start with the first character of the input string, and recursively generate all possible combinations of the rest of the string by calling the function recursively with the remaining part of the string. The base case for the recursion is when there are no more characters left in the input string, at which point the current permutation can be added to a result list.\\n\\nTo avoid modifying the original input string, it is recommended to convert the input string into a character array before passing it to the recursive function. At each level of recursion, the function should create a new character array to represent the current state of the string. The current character should then be added to the new array in lowercase and uppercase form, and the recursion should be called with the remaining part of the string and the new character array.\\n\\nThe final result will be a list of all possible permutations of the input string with the desired case variations."
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Shouldnt be an hard problem?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "No lol, get your recursion basics clear"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Navie approach could be traverse each element from string s and copy replica with upper case into another string\nvoid permutation(String s, String o)\n  `{\n    if(s.length() == 0){\n      //result.add(o)\n      return;\n    }\n    String ch1 = (\"\" + s.charAt(0)).toLowerCase();\n    String ch2 = (\"\" + s.charAt(0)).toUpperCase();\n    s= s.substring(1, s.length()) ;\n \n    permutation(s, o+ ch1);\n    permutation(s, o+ ch2);\n  }`"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "We are asked to find the subsets of strings where character at index `i` is lowercase and uppercase. Which diverges into two subsets at each decision.\\n\\nRecurrence relation: Set of permutations with letter at index `i` being lowercase + Set of permutations with letter at index `i` being uppercase."
                    },
                    {
                        "username": "norainsingh",
                        "content": "Heads Up All C# users, if you are using List<char> to store your partial Solutions you need to understand List.Remove(someChar) in c# removes the first occurence, not the last occurence in the list. Which will give you some very surprising results. Use a stack instead and use Push and Pop. The only change you will still need to make is to reverse the stack before you copy it to your result list. This issue wasted a lot of my time, hope this comment saves you time."
                    },
                    {
                        "username": "Saket1209",
                        "content": "You told to return in any order but it isn\\'t the case."
                    },
                    {
                        "username": "prakhar432",
                        "content": "Approach is similar to the subset problem. However, some changes will be made because of the given conditions in the problem."
                    },
                    {
                        "username": "smbody",
                        "content": "Do keep in mind that the sample test cases provided do not end with a letter. "
                    }
                ]
            },
            {
                "id": 1799458,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "A basic approach to generating all possible permutations of a string where each letter can be either lowercase or uppercase is to use a recursive approach that generates a search tree with two branches at each level of recursion, one for the lowercase letter and one for the uppercase letter.\\n\\nThe recursion should start with the first character of the input string, and recursively generate all possible combinations of the rest of the string by calling the function recursively with the remaining part of the string. The base case for the recursion is when there are no more characters left in the input string, at which point the current permutation can be added to a result list.\\n\\nTo avoid modifying the original input string, it is recommended to convert the input string into a character array before passing it to the recursive function. At each level of recursion, the function should create a new character array to represent the current state of the string. The current character should then be added to the new array in lowercase and uppercase form, and the recursion should be called with the remaining part of the string and the new character array.\\n\\nThe final result will be a list of all possible permutations of the input string with the desired case variations."
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Shouldnt be an hard problem?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "No lol, get your recursion basics clear"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Navie approach could be traverse each element from string s and copy replica with upper case into another string\nvoid permutation(String s, String o)\n  `{\n    if(s.length() == 0){\n      //result.add(o)\n      return;\n    }\n    String ch1 = (\"\" + s.charAt(0)).toLowerCase();\n    String ch2 = (\"\" + s.charAt(0)).toUpperCase();\n    s= s.substring(1, s.length()) ;\n \n    permutation(s, o+ ch1);\n    permutation(s, o+ ch2);\n  }`"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "We are asked to find the subsets of strings where character at index `i` is lowercase and uppercase. Which diverges into two subsets at each decision.\\n\\nRecurrence relation: Set of permutations with letter at index `i` being lowercase + Set of permutations with letter at index `i` being uppercase."
                    },
                    {
                        "username": "norainsingh",
                        "content": "Heads Up All C# users, if you are using List<char> to store your partial Solutions you need to understand List.Remove(someChar) in c# removes the first occurence, not the last occurence in the list. Which will give you some very surprising results. Use a stack instead and use Push and Pop. The only change you will still need to make is to reverse the stack before you copy it to your result list. This issue wasted a lot of my time, hope this comment saves you time."
                    },
                    {
                        "username": "Saket1209",
                        "content": "You told to return in any order but it isn\\'t the case."
                    },
                    {
                        "username": "prakhar432",
                        "content": "Approach is similar to the subset problem. However, some changes will be made because of the given conditions in the problem."
                    },
                    {
                        "username": "smbody",
                        "content": "Do keep in mind that the sample test cases provided do not end with a letter. "
                    }
                ]
            },
            {
                "id": 1799459,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "A basic approach to generating all possible permutations of a string where each letter can be either lowercase or uppercase is to use a recursive approach that generates a search tree with two branches at each level of recursion, one for the lowercase letter and one for the uppercase letter.\\n\\nThe recursion should start with the first character of the input string, and recursively generate all possible combinations of the rest of the string by calling the function recursively with the remaining part of the string. The base case for the recursion is when there are no more characters left in the input string, at which point the current permutation can be added to a result list.\\n\\nTo avoid modifying the original input string, it is recommended to convert the input string into a character array before passing it to the recursive function. At each level of recursion, the function should create a new character array to represent the current state of the string. The current character should then be added to the new array in lowercase and uppercase form, and the recursion should be called with the remaining part of the string and the new character array.\\n\\nThe final result will be a list of all possible permutations of the input string with the desired case variations."
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Shouldnt be an hard problem?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "No lol, get your recursion basics clear"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Navie approach could be traverse each element from string s and copy replica with upper case into another string\nvoid permutation(String s, String o)\n  `{\n    if(s.length() == 0){\n      //result.add(o)\n      return;\n    }\n    String ch1 = (\"\" + s.charAt(0)).toLowerCase();\n    String ch2 = (\"\" + s.charAt(0)).toUpperCase();\n    s= s.substring(1, s.length()) ;\n \n    permutation(s, o+ ch1);\n    permutation(s, o+ ch2);\n  }`"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "We are asked to find the subsets of strings where character at index `i` is lowercase and uppercase. Which diverges into two subsets at each decision.\\n\\nRecurrence relation: Set of permutations with letter at index `i` being lowercase + Set of permutations with letter at index `i` being uppercase."
                    },
                    {
                        "username": "norainsingh",
                        "content": "Heads Up All C# users, if you are using List<char> to store your partial Solutions you need to understand List.Remove(someChar) in c# removes the first occurence, not the last occurence in the list. Which will give you some very surprising results. Use a stack instead and use Push and Pop. The only change you will still need to make is to reverse the stack before you copy it to your result list. This issue wasted a lot of my time, hope this comment saves you time."
                    },
                    {
                        "username": "Saket1209",
                        "content": "You told to return in any order but it isn\\'t the case."
                    },
                    {
                        "username": "prakhar432",
                        "content": "Approach is similar to the subset problem. However, some changes will be made because of the given conditions in the problem."
                    },
                    {
                        "username": "smbody",
                        "content": "Do keep in mind that the sample test cases provided do not end with a letter. "
                    }
                ]
            },
            {
                "id": 2014548,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "A basic approach to generating all possible permutations of a string where each letter can be either lowercase or uppercase is to use a recursive approach that generates a search tree with two branches at each level of recursion, one for the lowercase letter and one for the uppercase letter.\\n\\nThe recursion should start with the first character of the input string, and recursively generate all possible combinations of the rest of the string by calling the function recursively with the remaining part of the string. The base case for the recursion is when there are no more characters left in the input string, at which point the current permutation can be added to a result list.\\n\\nTo avoid modifying the original input string, it is recommended to convert the input string into a character array before passing it to the recursive function. At each level of recursion, the function should create a new character array to represent the current state of the string. The current character should then be added to the new array in lowercase and uppercase form, and the recursion should be called with the remaining part of the string and the new character array.\\n\\nThe final result will be a list of all possible permutations of the input string with the desired case variations."
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Shouldnt be an hard problem?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "No lol, get your recursion basics clear"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Navie approach could be traverse each element from string s and copy replica with upper case into another string\nvoid permutation(String s, String o)\n  `{\n    if(s.length() == 0){\n      //result.add(o)\n      return;\n    }\n    String ch1 = (\"\" + s.charAt(0)).toLowerCase();\n    String ch2 = (\"\" + s.charAt(0)).toUpperCase();\n    s= s.substring(1, s.length()) ;\n \n    permutation(s, o+ ch1);\n    permutation(s, o+ ch2);\n  }`"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "We are asked to find the subsets of strings where character at index `i` is lowercase and uppercase. Which diverges into two subsets at each decision.\\n\\nRecurrence relation: Set of permutations with letter at index `i` being lowercase + Set of permutations with letter at index `i` being uppercase."
                    },
                    {
                        "username": "norainsingh",
                        "content": "Heads Up All C# users, if you are using List<char> to store your partial Solutions you need to understand List.Remove(someChar) in c# removes the first occurence, not the last occurence in the list. Which will give you some very surprising results. Use a stack instead and use Push and Pop. The only change you will still need to make is to reverse the stack before you copy it to your result list. This issue wasted a lot of my time, hope this comment saves you time."
                    },
                    {
                        "username": "Saket1209",
                        "content": "You told to return in any order but it isn\\'t the case."
                    },
                    {
                        "username": "prakhar432",
                        "content": "Approach is similar to the subset problem. However, some changes will be made because of the given conditions in the problem."
                    },
                    {
                        "username": "smbody",
                        "content": "Do keep in mind that the sample test cases provided do not end with a letter. "
                    }
                ]
            },
            {
                "id": 1997885,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "A basic approach to generating all possible permutations of a string where each letter can be either lowercase or uppercase is to use a recursive approach that generates a search tree with two branches at each level of recursion, one for the lowercase letter and one for the uppercase letter.\\n\\nThe recursion should start with the first character of the input string, and recursively generate all possible combinations of the rest of the string by calling the function recursively with the remaining part of the string. The base case for the recursion is when there are no more characters left in the input string, at which point the current permutation can be added to a result list.\\n\\nTo avoid modifying the original input string, it is recommended to convert the input string into a character array before passing it to the recursive function. At each level of recursion, the function should create a new character array to represent the current state of the string. The current character should then be added to the new array in lowercase and uppercase form, and the recursion should be called with the remaining part of the string and the new character array.\\n\\nThe final result will be a list of all possible permutations of the input string with the desired case variations."
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Shouldnt be an hard problem?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "No lol, get your recursion basics clear"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Navie approach could be traverse each element from string s and copy replica with upper case into another string\nvoid permutation(String s, String o)\n  `{\n    if(s.length() == 0){\n      //result.add(o)\n      return;\n    }\n    String ch1 = (\"\" + s.charAt(0)).toLowerCase();\n    String ch2 = (\"\" + s.charAt(0)).toUpperCase();\n    s= s.substring(1, s.length()) ;\n \n    permutation(s, o+ ch1);\n    permutation(s, o+ ch2);\n  }`"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "We are asked to find the subsets of strings where character at index `i` is lowercase and uppercase. Which diverges into two subsets at each decision.\\n\\nRecurrence relation: Set of permutations with letter at index `i` being lowercase + Set of permutations with letter at index `i` being uppercase."
                    },
                    {
                        "username": "norainsingh",
                        "content": "Heads Up All C# users, if you are using List<char> to store your partial Solutions you need to understand List.Remove(someChar) in c# removes the first occurence, not the last occurence in the list. Which will give you some very surprising results. Use a stack instead and use Push and Pop. The only change you will still need to make is to reverse the stack before you copy it to your result list. This issue wasted a lot of my time, hope this comment saves you time."
                    },
                    {
                        "username": "Saket1209",
                        "content": "You told to return in any order but it isn\\'t the case."
                    },
                    {
                        "username": "prakhar432",
                        "content": "Approach is similar to the subset problem. However, some changes will be made because of the given conditions in the problem."
                    },
                    {
                        "username": "smbody",
                        "content": "Do keep in mind that the sample test cases provided do not end with a letter. "
                    }
                ]
            },
            {
                "id": 1971562,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "A basic approach to generating all possible permutations of a string where each letter can be either lowercase or uppercase is to use a recursive approach that generates a search tree with two branches at each level of recursion, one for the lowercase letter and one for the uppercase letter.\\n\\nThe recursion should start with the first character of the input string, and recursively generate all possible combinations of the rest of the string by calling the function recursively with the remaining part of the string. The base case for the recursion is when there are no more characters left in the input string, at which point the current permutation can be added to a result list.\\n\\nTo avoid modifying the original input string, it is recommended to convert the input string into a character array before passing it to the recursive function. At each level of recursion, the function should create a new character array to represent the current state of the string. The current character should then be added to the new array in lowercase and uppercase form, and the recursion should be called with the remaining part of the string and the new character array.\\n\\nThe final result will be a list of all possible permutations of the input string with the desired case variations."
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Shouldnt be an hard problem?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "No lol, get your recursion basics clear"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Navie approach could be traverse each element from string s and copy replica with upper case into another string\nvoid permutation(String s, String o)\n  `{\n    if(s.length() == 0){\n      //result.add(o)\n      return;\n    }\n    String ch1 = (\"\" + s.charAt(0)).toLowerCase();\n    String ch2 = (\"\" + s.charAt(0)).toUpperCase();\n    s= s.substring(1, s.length()) ;\n \n    permutation(s, o+ ch1);\n    permutation(s, o+ ch2);\n  }`"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "We are asked to find the subsets of strings where character at index `i` is lowercase and uppercase. Which diverges into two subsets at each decision.\\n\\nRecurrence relation: Set of permutations with letter at index `i` being lowercase + Set of permutations with letter at index `i` being uppercase."
                    },
                    {
                        "username": "norainsingh",
                        "content": "Heads Up All C# users, if you are using List<char> to store your partial Solutions you need to understand List.Remove(someChar) in c# removes the first occurence, not the last occurence in the list. Which will give you some very surprising results. Use a stack instead and use Push and Pop. The only change you will still need to make is to reverse the stack before you copy it to your result list. This issue wasted a lot of my time, hope this comment saves you time."
                    },
                    {
                        "username": "Saket1209",
                        "content": "You told to return in any order but it isn\\'t the case."
                    },
                    {
                        "username": "prakhar432",
                        "content": "Approach is similar to the subset problem. However, some changes will be made because of the given conditions in the problem."
                    },
                    {
                        "username": "smbody",
                        "content": "Do keep in mind that the sample test cases provided do not end with a letter. "
                    }
                ]
            },
            {
                "id": 1826583,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "A basic approach to generating all possible permutations of a string where each letter can be either lowercase or uppercase is to use a recursive approach that generates a search tree with two branches at each level of recursion, one for the lowercase letter and one for the uppercase letter.\\n\\nThe recursion should start with the first character of the input string, and recursively generate all possible combinations of the rest of the string by calling the function recursively with the remaining part of the string. The base case for the recursion is when there are no more characters left in the input string, at which point the current permutation can be added to a result list.\\n\\nTo avoid modifying the original input string, it is recommended to convert the input string into a character array before passing it to the recursive function. At each level of recursion, the function should create a new character array to represent the current state of the string. The current character should then be added to the new array in lowercase and uppercase form, and the recursion should be called with the remaining part of the string and the new character array.\\n\\nThe final result will be a list of all possible permutations of the input string with the desired case variations."
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Shouldnt be an hard problem?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "No lol, get your recursion basics clear"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Navie approach could be traverse each element from string s and copy replica with upper case into another string\nvoid permutation(String s, String o)\n  `{\n    if(s.length() == 0){\n      //result.add(o)\n      return;\n    }\n    String ch1 = (\"\" + s.charAt(0)).toLowerCase();\n    String ch2 = (\"\" + s.charAt(0)).toUpperCase();\n    s= s.substring(1, s.length()) ;\n \n    permutation(s, o+ ch1);\n    permutation(s, o+ ch2);\n  }`"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "We are asked to find the subsets of strings where character at index `i` is lowercase and uppercase. Which diverges into two subsets at each decision.\\n\\nRecurrence relation: Set of permutations with letter at index `i` being lowercase + Set of permutations with letter at index `i` being uppercase."
                    },
                    {
                        "username": "norainsingh",
                        "content": "Heads Up All C# users, if you are using List<char> to store your partial Solutions you need to understand List.Remove(someChar) in c# removes the first occurence, not the last occurence in the list. Which will give you some very surprising results. Use a stack instead and use Push and Pop. The only change you will still need to make is to reverse the stack before you copy it to your result list. This issue wasted a lot of my time, hope this comment saves you time."
                    },
                    {
                        "username": "Saket1209",
                        "content": "You told to return in any order but it isn\\'t the case."
                    },
                    {
                        "username": "prakhar432",
                        "content": "Approach is similar to the subset problem. However, some changes will be made because of the given conditions in the problem."
                    },
                    {
                        "username": "smbody",
                        "content": "Do keep in mind that the sample test cases provided do not end with a letter. "
                    }
                ]
            },
            {
                "id": 1824150,
                "content": [
                    {
                        "username": "cOde_Ranvir25",
                        "content": "A basic approach to generating all possible permutations of a string where each letter can be either lowercase or uppercase is to use a recursive approach that generates a search tree with two branches at each level of recursion, one for the lowercase letter and one for the uppercase letter.\\n\\nThe recursion should start with the first character of the input string, and recursively generate all possible combinations of the rest of the string by calling the function recursively with the remaining part of the string. The base case for the recursion is when there are no more characters left in the input string, at which point the current permutation can be added to a result list.\\n\\nTo avoid modifying the original input string, it is recommended to convert the input string into a character array before passing it to the recursive function. At each level of recursion, the function should create a new character array to represent the current state of the string. The current character should then be added to the new array in lowercase and uppercase form, and the recursion should be called with the remaining part of the string and the new character array.\\n\\nThe final result will be a list of all possible permutations of the input string with the desired case variations."
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Shouldnt be an hard problem?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "No lol, get your recursion basics clear"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Navie approach could be traverse each element from string s and copy replica with upper case into another string\nvoid permutation(String s, String o)\n  `{\n    if(s.length() == 0){\n      //result.add(o)\n      return;\n    }\n    String ch1 = (\"\" + s.charAt(0)).toLowerCase();\n    String ch2 = (\"\" + s.charAt(0)).toUpperCase();\n    s= s.substring(1, s.length()) ;\n \n    permutation(s, o+ ch1);\n    permutation(s, o+ ch2);\n  }`"
                    },
                    {
                        "username": "zhibin-wang09",
                        "content": "We are asked to find the subsets of strings where character at index `i` is lowercase and uppercase. Which diverges into two subsets at each decision.\\n\\nRecurrence relation: Set of permutations with letter at index `i` being lowercase + Set of permutations with letter at index `i` being uppercase."
                    },
                    {
                        "username": "norainsingh",
                        "content": "Heads Up All C# users, if you are using List<char> to store your partial Solutions you need to understand List.Remove(someChar) in c# removes the first occurence, not the last occurence in the list. Which will give you some very surprising results. Use a stack instead and use Push and Pop. The only change you will still need to make is to reverse the stack before you copy it to your result list. This issue wasted a lot of my time, hope this comment saves you time."
                    },
                    {
                        "username": "Saket1209",
                        "content": "You told to return in any order but it isn\\'t the case."
                    },
                    {
                        "username": "prakhar432",
                        "content": "Approach is similar to the subset problem. However, some changes will be made because of the given conditions in the problem."
                    },
                    {
                        "username": "smbody",
                        "content": "Do keep in mind that the sample test cases provided do not end with a letter. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Is Graph Bipartite?",
        "question_content": "<p>There is an <strong>undirected</strong> graph with <code>n</code> nodes, where each node is numbered between <code>0</code> and <code>n - 1</code>. You are given a 2D array <code>graph</code>, where <code>graph[u]</code> is an array of nodes that node <code>u</code> is adjacent to. More formally, for each <code>v</code> in <code>graph[u]</code>, there is an undirected edge between node <code>u</code> and node <code>v</code>. The graph has the following properties:</p>\n\n<ul>\n\t<li>There are no self-edges (<code>graph[u]</code> does not contain <code>u</code>).</li>\n\t<li>There are no parallel edges (<code>graph[u]</code> does not contain duplicate values).</li>\n\t<li>If <code>v</code> is in <code>graph[u]</code>, then <code>u</code> is in <code>graph[v]</code> (the graph is undirected).</li>\n\t<li>The graph may not be connected, meaning there may be two nodes <code>u</code> and <code>v</code> such that there is no path between them.</li>\n</ul>\n\n<p>A graph is <strong>bipartite</strong> if the nodes can be partitioned into two independent sets <code>A</code> and <code>B</code> such that <strong>every</strong> edge in the graph connects a node in set <code>A</code> and a node in set <code>B</code>.</p>\n\n<p>Return <code>true</code><em> if and only if it is <strong>bipartite</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg\" style=\"width: 222px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg\" style=\"width: 222px; height: 222px;\" />\n<pre>\n<strong>Input:</strong> graph = [[1,3],[0,2],[1,3],[0,2]]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> We can partition the nodes into two sets: {0, 2} and {1, 3}.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>graph.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>0 &lt;= graph[u].length &lt; n</code></li>\n\t<li><code>0 &lt;= graph[u][i] &lt;= n - 1</code></li>\n\t<li><code>graph[u]</code>&nbsp;does not contain&nbsp;<code>u</code>.</li>\n\t<li>All the values of <code>graph[u]</code> are <strong>unique</strong>.</li>\n\t<li>If <code>graph[u]</code> contains <code>v</code>, then <code>graph[v]</code> contains <code>u</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 115487,
                "title": "java-clean-dfs-solution-with-explanation",
                "content": "`Our goal` is trying to use two colors to color the graph and see if there are any adjacent nodes having the same color.\\nInitialize a color[] array for each node. Here are three states for `colors[]` array:\\n`0: Haven\\'t been colored yet.`\\n`1: Blue.`\\n`-1: Red.`\\nFor each node, \\n1. If it hasn\\'t been colored, use a color to color it. Then use the other color to color all its adjacent nodes (DFS).\\n2. If it has been colored, check if the current color is the same as the color that is going to be used to color it. (Please forgive my english... Hope you can understand it.)\\n\\n`DFS Solution:`\\n```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int n = graph.length;\\n        int[] colors = new int[n];\\t\\t\\t\\n\\t\\t\\t\\t\\n        for (int i = 0; i < n; i++) {              //This graph might be a disconnected graph. So check each unvisited node.\\n            if (colors[i] == 0 && !validColor(graph, colors, 1, i)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public boolean validColor(int[][] graph, int[] colors, int color, int node) {\\n        if (colors[node] != 0) {\\n            return colors[node] == color;\\n        }       \\n        colors[node] = color;       \\n        for (int next : graph[node]) {\\n            if (!validColor(graph, colors, -color, next)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n`BFS Solution:`\\n```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int len = graph.length;\\n        int[] colors = new int[len];\\n        \\n        for (int i = 0; i < len; i++) {\\n            if (colors[i] != 0) continue;\\n            Queue<Integer> queue = new LinkedList<>();\\n            queue.offer(i);\\n            colors[i] = 1;   // Blue: 1; Red: -1.\\n            \\n            while (!queue.isEmpty()) {\\n                int cur = queue.poll();\\n                for (int next : graph[cur]) {\\n                    if (colors[next] == 0) {          // If this node hasn\\'t been colored;\\n                        colors[next] = -colors[cur];  // Color it with a different color;\\n                        queue.offer(next);\\n                    } else if (colors[next] != -colors[cur]) {   // If it is colored and its color is different, return false;\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int n = graph.length;\\n        int[] colors = new int[n];\\t\\t\\t\\n\\t\\t\\t\\t\\n        for (int i = 0; i < n; i++) {              //This graph might be a disconnected graph. So check each unvisited node.\\n            if (colors[i] == 0 && !validColor(graph, colors, 1, i)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public boolean validColor(int[][] graph, int[] colors, int color, int node) {\\n        if (colors[node] != 0) {\\n            return colors[node] == color;\\n        }       \\n        colors[node] = color;       \\n        for (int next : graph[node]) {\\n            if (!validColor(graph, colors, -color, next)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int len = graph.length;\\n        int[] colors = new int[len];\\n        \\n        for (int i = 0; i < len; i++) {\\n            if (colors[i] != 0) continue;\\n            Queue<Integer> queue = new LinkedList<>();\\n            queue.offer(i);\\n            colors[i] = 1;   // Blue: 1; Red: -1.\\n            \\n            while (!queue.isEmpty()) {\\n                int cur = queue.poll();\\n                for (int next : graph[cur]) {\\n                    if (colors[next] == 0) {          // If this node hasn\\'t been colored;\\n                        colors[next] = -colors[cur];  // Color it with a different color;\\n                        queue.offer(next);\\n                    } else if (colors[next] != -colors[cur]) {   // If it is colored and its color is different, return false;\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 115543,
                "title": "java-python-dfs-solution",
                "content": "**Java**\\n```java\\n    public boolean isBipartite(int[][] G) {        \\n        int n = G.length, colors[] = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            if (colors[i] == 0 && !dfs(G, colors, i, 1)) \\n                return false;            \\n        }\\n        return true;\\n    }\\n    \\n    private boolean dfs(int[][] G, int[] colors, int i, int color) {\\n        colors[i] = color;\\n        for (int j = 0; j < G[i].length; j++) {\\n            int k = G[i][j]; // adjacent node\\n            if (colors[k] == -color) continue;\\n            if (colors[k] == color || !dfs(G, colors, k, -color)) return false;\\n        }\\n        return true;\\n    }\\n```\\n**Python**\\n```py\\n    def isBipartite(self, graph):\\n        color = {}\\n        def dfs(pos):\\n            for i in graph[pos]:\\n                if i in color:\\n                    if color[i] == color[pos]:\\n                        return False\\n                else:\\n                    color[i] = 1 - color[pos]\\n                    if not dfs(i):\\n                        return False\\n            return True\\n        for i in range(len(graph)):\\n            if i not in color:\\n                color[i] = 0\\n                if not dfs(i):\\n                    return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```java\\n    public boolean isBipartite(int[][] G) {        \\n        int n = G.length, colors[] = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            if (colors[i] == 0 && !dfs(G, colors, i, 1)) \\n                return false;            \\n        }\\n        return true;\\n    }\\n    \\n    private boolean dfs(int[][] G, int[] colors, int i, int color) {\\n        colors[i] = color;\\n        for (int j = 0; j < G[i].length; j++) {\\n            int k = G[i][j]; // adjacent node\\n            if (colors[k] == -color) continue;\\n            if (colors[k] == color || !dfs(G, colors, k, -color)) return false;\\n        }\\n        return true;\\n    }\\n```\n```py\\n    def isBipartite(self, graph):\\n        color = {}\\n        def dfs(pos):\\n            for i in graph[pos]:\\n                if i in color:\\n                    if color[i] == color[pos]:\\n                        return False\\n                else:\\n                    color[i] = 1 - color[pos]\\n                    if not dfs(i):\\n                        return False\\n            return True\\n        for i in range(len(graph)):\\n            if i not in color:\\n                color[i] = 0\\n                if not dfs(i):\\n                    return False\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 409594,
                "title": "clean-c-bfs-with-explanation-and-comments",
                "content": "To be able to split the node set `{0, 1, 2, ..., (n-1)}` into sets A and B, we will try to color nodes in set A with color A (i.e., value 1) and nodes in set B with color B (i.e., value -1), respectively.\\n\\nIf so, ***the graph is bipartite if and only if the two ends of each edge must have opposite colors***. Therefore, we could just start with standard BFS to traverse the entire graph and \\n* color neighbors with opposite color if not colored, yet;\\n* ignore neighbors already colored with oppsite color;\\n* annouce the graph can\\'t be bipartite if any neighbor is already colored with the same color.\\n\\n**NOTE:** The given graph might not be connected, so we will need to loop over all nodes before BFS.\\n\\n```cpp\\n  bool isBipartite(vector<vector<int>>& graph) {\\n    int n = graph.size();\\n    vector<int> color(n); // 0: uncolored; 1: color A; -1: color B\\n        \\n    queue<int> q; // queue, resusable for BFS    \\n\\t\\n    for (int i = 0; i < n; i++) {\\n      if (color[i]) continue; // skip already colored nodes\\n      \\n      // BFS with seed node i to color neighbors with opposite color\\n      color[i] = 1; // color seed i to be A (doesn\\'t matter A or B) \\n      for (q.push(i); !q.empty(); q.pop()) {\\n        int cur = q.front();\\n        for (int neighbor : graph[cur]) \\n\\t\\t{\\n          if (!color[neighbor]) // if uncolored, color with opposite color\\n          { color[neighbor] = -color[cur]; q.push(neighbor); } \\n\\t\\t  \\n          else if (color[neighbor] == color[cur]) \\n            return false; // if already colored with same color, can\\'t be bipartite!\\n        }        \\n      }\\n    }\\n    \\n    return true;\\n  }\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```cpp\\n  bool isBipartite(vector<vector<int>>& graph) {\\n    int n = graph.size();\\n    vector<int> color(n); // 0: uncolored; 1: color A; -1: color B\\n        \\n    queue<int> q; // queue, resusable for BFS    \\n\\t\\n    for (int i = 0; i < n; i++) {\\n      if (color[i]) continue; // skip already colored nodes\\n      \\n      // BFS with seed node i to color neighbors with opposite color\\n      color[i] = 1; // color seed i to be A (doesn\\'t matter A or B) \\n      for (q.push(i); !q.empty(); q.pop()) {\\n        int cur = q.front();\\n        for (int neighbor : graph[cur]) \\n\\t\\t{\\n          if (!color[neighbor]) // if uncolored, color with opposite color\\n          { color[neighbor] = -color[cur]; q.push(neighbor); } \\n\\t\\t  \\n          else if (color[neighbor] == color[cur]) \\n            return false; // if already colored with same color, can\\'t be bipartite!\\n        }        \\n      }\\n    }\\n    \\n    return true;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1065074,
                "title": "c-super-simple-easy-bfs",
                "content": "We are trying to split the graph into two groups of edges.\\nSo we color the edges, 1 = red, -1 = blue, 0 = not colored yet.\\n**A graph is bipartite if and only if the two ends of each edge have different colors.**\\n```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<int> colors(n, 0);\\n        queue<int> q;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (colors[i]) continue;\\n            \\n            colors[i] = 1;\\n            q.push(i);\\n            \\n            while (!q.empty()) {\\n                int temp = q.front();\\n                \\n                for (auto neighbor : graph[temp]) {\\n                    \\n\\t\\t\\t\\t\\t// Color neighbor with opposite color\\n                    if (!colors[neighbor]){\\n                        colors[neighbor] = -colors[temp];\\n                        q.push(neighbor);\\n                    }\\n                    \\n\\t\\t\\t\\t\\t// If the neighbor has the same color - can\\'t bipartite.\\n                    else if (colors[neighbor] == colors[temp]) \\n                        return false;\\n                }\\n                q.pop();\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<int> colors(n, 0);\\n        queue<int> q;\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (colors[i]) continue;\\n            \\n            colors[i] = 1;\\n            q.push(i);\\n            \\n            while (!q.empty()) {\\n                int temp = q.front();\\n                \\n                for (auto neighbor : graph[temp]) {\\n                    \\n\\t\\t\\t\\t\\t// Color neighbor with opposite color\\n                    if (!colors[neighbor]){\\n                        colors[neighbor] = -colors[temp];\\n                        q.push(neighbor);\\n                    }\\n                    \\n\\t\\t\\t\\t\\t// If the neighbor has the same color - can\\'t bipartite.\\n                    else if (colors[neighbor] == colors[temp]) \\n                        return false;\\n                }\\n                q.pop();\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 115503,
                "title": "java-bfs",
                "content": "just want to provide another type of solution\n\nwe need to check each if each cluster(edges linked together) is Bipartite.\n\n\n```\n\nclass Solution {\n    public boolean isBipartite(int[][] graph) {\n        //BFS\n        // 0(not meet), 1(black), 2(white)\n        int[] visited = new int[graph.length];\n        \n        for (int i = 0; i < graph.length; i++) {\n            if (graph[i].length != 0 && visited[i] == 0) {\n                visited[i] = 1;\n                Queue<Integer> q = new LinkedList<>();\n                q.offer(i);\n                while(! q.isEmpty()) {\n                    int current = q.poll();\n                    for (int c: graph[current]) {\n\n                            if (visited[c] == 0) {\n                                visited[c] = (visited[current] == 1) ? 2 : 1;\n                                q.offer(c);\n                            } else {\n                                if (visited[c] == visited[current]) return false;\n                            }\n                    }\n                }                        \n                \n            }\n        }\n        \n        return true;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\n\nclass Solution {\n    public boolean isBipartite(int[][] graph) {\n        //BFS\n        // 0(not meet), 1(black), 2(white)\n        int[] visited = new int[graph.length];\n        \n        for (int i = 0; i < graph.length; i++) {\n            if (graph[i].length != 0 && visited[i] == 0) {\n                visited[i] = 1;\n                Queue<Integer> q = new LinkedList<>();\n                q.offer(i);\n                while(! q.isEmpty()) {\n                    int current = q.poll();\n                    for (int c: graph[current]) {\n\n                            if (visited[c] == 0) {\n                                visited[c] = (visited[current] == 1) ? 2 : 1;\n                                q.offer(c);\n                            } else {\n                                if (visited[c] == visited[current]) return false;\n                            }\n                    }\n                }                        \n                \n            }\n        }\n        \n        return true;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065709,
                "title": "c-dfs-o-n-8ms-beats-100-explanation",
                "content": "**EXPLANATION**\\n\\n![image](https://assets.leetcode.com/users/images/335dc44e-965c-4779-9757-40ffad537f5a_1613330997.6753454.png)\\n\\n**A.** Traverse each node of the graph and try to assign a color to them such that **alternating nodes** are of **same color**.\\n**B.** If at any step, the **child node color** matches with the **parent node color**, then the graph is **not bipartite**.\\n**C.** If no **B** found, then the graph is bipartite. So, return **true** at the end.\\n**D.** Here, the two colors are represented by ```0``` and ```1```.\\n\\n**CODE IMPLEMENTATION**\\n```\\nclass Solution {\\npublic:\\n    vector<int>vis,col;\\n    bool dfs(int v, int c, vector<vector<int>>& graph){\\n        vis[v]=1;\\n        col[v]=c;\\n        for(int child:graph[v]){\\n            if(vis[child]==0){\\n                // here c^1 is for flipping 1 by 0 or 0 by 1, that is flip the current color\\n                if(dfs(child,c^1,graph)==false) \\n                    return false;\\n            }\\n            else{\\n                if(col[v]==col[child])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        vis.resize(n);\\n        col.resize(n);\\n\\n        for(int i=0;i<n;++i){\\n            if(vis[i]==0 && dfs(i,0,graph)==false){ \\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n\\n**TIME COMPLEXITY**\\n**O(n)** [*Since each node of the graph is traversed exactly once*]\\n**SPACE COMPLEXITY**\\n**O(n+n)** [*vis and col vectors are of size n each*]",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```0```\n```1```\n```\\nclass Solution {\\npublic:\\n    vector<int>vis,col;\\n    bool dfs(int v, int c, vector<vector<int>>& graph){\\n        vis[v]=1;\\n        col[v]=c;\\n        for(int child:graph[v]){\\n            if(vis[child]==0){\\n                // here c^1 is for flipping 1 by 0 or 0 by 1, that is flip the current color\\n                if(dfs(child,c^1,graph)==false) \\n                    return false;\\n            }\\n            else{\\n                if(col[v]==col[child])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        vis.resize(n);\\n        col.resize(n);\\n\\n        for(int i=0;i<n;++i){\\n            if(vis[i]==0 && dfs(i,0,graph)==false){ \\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 119514,
                "title": "python-3-bfs-dfs-solutions",
                "content": "**DFS solution:**\\nJust like what we do in DFS traversal for an undirected graph, a colored node should have ALL connected neighbors in different colors.   \\n```\\n    def isBipartite(self, graph):\\n        \"\"\"\\n        :type graph: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        n, colored = len(graph), {}\\n        def dfs_color(color, idx, graph, colored):\\n            if idx in colored:\\n                return color == colored[idx]\\n            colored[idx] = color                            \\n            return all(dfs_color(-color, nb, graph, colored) for nb in graph[idx])\\n    \\n        return all(i in colored or dfs_color(1, i, graph, colored) for i in range(n)) \\t\\t\\t\\t\\n```\\n\\t\\t\\n**BFS solution:**\\nJust like what we do in BFS traversal for an undirected graph, a colored node should have ALL connected neighbors in different colors.   \\n```\\ndef isBipartite(self, graph):\\n        \"\"\"\\n        :type graph: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        n, colored = len(graph), {}\\n        for i in range(n):\\n            if i not in colored and graph[i]:\\n                colored[i] = 1\\n                q = collections.deque([i])\\n                while q:\\n                    cur = q.popleft()\\n                    for nb in graph[cur]:\\n                        if nb not in colored:\\n                            colored[nb] = -colored[cur]\\n                            q.append(nb)\\n                        elif colored[nb] == colored[cur]:\\n                            return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\n    def isBipartite(self, graph):\\n        \"\"\"\\n        :type graph: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        n, colored = len(graph), {}\\n        def dfs_color(color, idx, graph, colored):\\n            if idx in colored:\\n                return color == colored[idx]\\n            colored[idx] = color                            \\n            return all(dfs_color(-color, nb, graph, colored) for nb in graph[idx])\\n    \\n        return all(i in colored or dfs_color(1, i, graph, colored) for i in range(n)) \\t\\t\\t\\t\\n```\n```\\ndef isBipartite(self, graph):\\n        \"\"\"\\n        :type graph: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        n, colored = len(graph), {}\\n        for i in range(n):\\n            if i not in colored and graph[i]:\\n                colored[i] = 1\\n                q = collections.deque([i])\\n                while q:\\n                    cur = q.popleft()\\n                    for nb in graph[cur]:\\n                        if nb not in colored:\\n                            colored[nb] = -colored[cur]\\n                            q.append(nb)\\n                        elif colored[nb] == colored[cur]:\\n                            return False\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1065302,
                "title": "3-solutions-bfs-dfs-dsu-union-find-graph-coloring",
                "content": "**BFS**\\n\\n```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int N = graph.length;\\n        int[] colors = new int[N]; // 0 not colored, 1 = Red, -1 = Blue\\n        for(int vertex = 0; vertex < N; vertex++) { // handle forest\\n            if(colors[vertex] == 0) {\\n                colors[vertex] = 1;\\n                Queue<Integer> queue = new LinkedList();\\n                queue.add(vertex);\\n                \\n                while(!queue.isEmpty()) {\\n                    int currVert = queue.poll();\\n                    for(int adjVert : graph[currVert]) {\\n                        if(colors[adjVert] == colors[currVert])\\n                            return false;\\n                        if(colors[adjVert] == 0) {\\n                            colors[adjVert] = -colors[currVert];\\n                            queue.add(adjVert);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\\n\\n\\n****************\\n**DFS**\\n\\n```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int N = graph.length;\\n        int[] colors = new int[N]; // 0 not colored, 1 = Red, -1 = Blue\\n        for(int vertex = 0; vertex < N; vertex++)\\n            if(colors[vertex] == 0 && !dfs(graph, vertex, 1, colors))\\n                return false;\\n        \\n        return true;\\n    }\\n    \\n    private boolean dfs(int[][] graph, int vertex, int color, int[] colors) {\\n        if(colors[vertex] != 0)\\n            return colors[vertex] == color;\\n            \\n        colors[vertex] = color;\\n        for(int adjVert : graph[vertex])\\n            if(!dfs(graph, adjVert, -color, colors)) \\n                return false;\\n        \\n        return true;\\n    }\\n}\\n```\\n\\n\\n********************\\n**DSU - Union Find**\\n\\n```\\nclass Solution {\\n    int[] parent;\\n    public boolean isBipartite(int[][] graph) {\\n        int N = graph.length;\\n        parent = new int[N];\\n        for(int i = 0; i < N; i++)\\n            parent[i] = i;\\n        \\n        for(int i = 0; i < N; i++) {\\n            for(int j = 0; j < graph[i].length; j++) {\\n                if(find(i) == find(graph[i][j]))\\n                    return false;\\n                union(graph[i][0], graph[i][j]);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private int find(int x) {\\n        while(x != parent[x])\\n            x = parent[x];  \\n        return x;\\n    }\\n    \\n    private void union(int x, int y) {\\n        int parentX = find(x);\\n        int parentY = find(y);\\n        parent[parentY] = parentX;\\n    }\\n}\\n```\\n\\n\\n\\n****************\\n\\nIn DSU code we can add path compression and rank array to optimize more.\\n\\nIf you like **upvote**.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int N = graph.length;\\n        int[] colors = new int[N]; // 0 not colored, 1 = Red, -1 = Blue\\n        for(int vertex = 0; vertex < N; vertex++) { // handle forest\\n            if(colors[vertex] == 0) {\\n                colors[vertex] = 1;\\n                Queue<Integer> queue = new LinkedList();\\n                queue.add(vertex);\\n                \\n                while(!queue.isEmpty()) {\\n                    int currVert = queue.poll();\\n                    for(int adjVert : graph[currVert]) {\\n                        if(colors[adjVert] == colors[currVert])\\n                            return false;\\n                        if(colors[adjVert] == 0) {\\n                            colors[adjVert] = -colors[currVert];\\n                            queue.add(adjVert);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int N = graph.length;\\n        int[] colors = new int[N]; // 0 not colored, 1 = Red, -1 = Blue\\n        for(int vertex = 0; vertex < N; vertex++)\\n            if(colors[vertex] == 0 && !dfs(graph, vertex, 1, colors))\\n                return false;\\n        \\n        return true;\\n    }\\n    \\n    private boolean dfs(int[][] graph, int vertex, int color, int[] colors) {\\n        if(colors[vertex] != 0)\\n            return colors[vertex] == color;\\n            \\n        colors[vertex] = color;\\n        for(int adjVert : graph[vertex])\\n            if(!dfs(graph, adjVert, -color, colors)) \\n                return false;\\n        \\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int[] parent;\\n    public boolean isBipartite(int[][] graph) {\\n        int N = graph.length;\\n        parent = new int[N];\\n        for(int i = 0; i < N; i++)\\n            parent[i] = i;\\n        \\n        for(int i = 0; i < N; i++) {\\n            for(int j = 0; j < graph[i].length; j++) {\\n                if(find(i) == find(graph[i][j]))\\n                    return false;\\n                union(graph[i][0], graph[i][j]);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private int find(int x) {\\n        while(x != parent[x])\\n            x = parent[x];  \\n        return x;\\n    }\\n    \\n    private void union(int x, int y) {\\n        int parentX = find(x);\\n        int parentY = find(y);\\n        parent[parentY] = parentX;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540122,
                "title": "image-explanation-both-bfs-dfs-ways-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Is Graph Bipartite?` by `Aryan Mittal`\\n![meta4.png](https://assets.leetcode.com/users/images/022c0a47-17c1-4b1c-bf64-3361f24fd593_1684461035.6874602.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/a25fea11-a1fd-4a52-a359-5717282ca33b_1684460285.0267549.png)\\n![image.png](https://assets.leetcode.com/users/images/ac87a243-e805-47bd-8417-a9c33f197ba5_1684460291.1384854.png)\\n![image.png](https://assets.leetcode.com/users/images/d8b0b662-63fb-48be-9764-90ec6ef502f3_1684460298.7157168.png)\\n![image.png](https://assets.leetcode.com/users/images/e6f6a925-2b01-4f68-be3b-617d153adc07_1684460308.4144142.png)\\n![image.png](https://assets.leetcode.com/users/images/778ec245-1295-4136-9515-274a7a1c84b2_1684460317.2321572.png)\\n![image.png](https://assets.leetcode.com/users/images/1d5d5e46-40af-42e8-ae7e-59893ac10fd0_1684460333.1783485.png)\\n![image.png](https://assets.leetcode.com/users/images/f722d7e0-e7f8-47ab-9db3-7f384fbbd308_1684460342.6557012.png)\\n![image.png](https://assets.leetcode.com/users/images/12f6a704-e8f5-4f9b-b541-263b7d34fef2_1684460350.9815671.png)\\n![image.png](https://assets.leetcode.com/users/images/0326455d-63a7-4bd3-a5cd-1be02fd61e2a_1684460359.111465.png)\\n![image.png](https://assets.leetcode.com/users/images/88eaba90-ce3e-49c9-b4e4-08a7702b814c_1684460367.3610544.png)\\n![image.png](https://assets.leetcode.com/users/images/ee7af066-d8b3-45d9-b01b-6996aea0d677_1684460372.910481.png)\\n\\n\\n\\n# BFS Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& gr) {\\n        int n = gr.size();\\n        vector<int> colour(n, 0);\\n\\n        for(int node = 0; node < n; node++){\\n            if(colour[node] != 0) continue;\\n\\n            queue<int> q;\\n            q.push(node);\\n            colour[node] = 1;\\n\\n            while(!q.empty()){\\n                int cur = q.front();\\n                q.pop();\\n\\n                for(int ne : gr[cur]){\\n                    if(colour[ne] == 0){\\n                        colour[ne] = -colour[cur];\\n                        q.push(ne);\\n                    }else if(colour[ne] != -colour[cur]){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```\\n```Java []\\nimport java.util.ArrayDeque;\\nimport java.util.Queue;\\n\\nclass Solution {\\n    public boolean isBipartite(int[][] gr) {\\n        int n = gr.length;\\n        int[] colour = new int[n];\\n\\n        for (int node = 0; node < n; node++) {\\n            if (colour[node] != 0) {\\n                continue;\\n            }\\n\\n            Queue<Integer> q = new ArrayDeque<>();\\n            q.add(node);\\n            colour[node] = 1;\\n\\n            while (!q.isEmpty()) {\\n                int cur = q.poll();\\n\\n                for (int ne : gr[cur]) {\\n                    if (colour[ne] == 0) {\\n                        colour[ne] = -colour[cur];\\n                        q.add(ne);\\n                    } else if (colour[ne] != -colour[cur]) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n```Python []\\nfrom typing import List\\nfrom collections import deque\\n\\nclass Solution:\\n    def isBipartite(self, gr: List[List[int]]) -> bool:\\n        n = len(gr)\\n        colour = [0] * n\\n\\n        for node in range(n):\\n            if colour[node] != 0:\\n                continue\\n\\n            q = deque()\\n            q.append(node)\\n            colour[node] = 1\\n\\n            while q:\\n                cur = q.popleft()\\n\\n                for ne in gr[cur]:\\n                    if colour[ne] == 0:\\n                        colour[ne] = -colour[cur]\\n                        q.append(ne)\\n                    elif colour[ne] != -colour[cur]:\\n                        return False\\n\\n        return True\\n```\\n\\n# DFS Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool validColouring(vector<vector<int>>& gr, vector<int>& colour, int node, int col){\\n        if(colour[node] != 0)\\n            return (colour[node] == col);\\n\\n        colour[node] = col;\\n        for(int ne : gr[node]){\\n            if(!validColouring(gr, colour, ne, -col))\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    bool isBipartite(vector<vector<int>>& gr) {\\n        int n = gr.size();\\n        vector<int> colour(n, 0);\\n\\n        for(int node = 0; node < n; node++){\\n            if(colour[node]==0 && !validColouring(gr, colour, node, 1))\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean validColouring(int[][] gr, int[] colour, int node, int col) {\\n        if (colour[node] != 0)\\n            return colour[node] == col;\\n\\n        colour[node] = col;\\n        for (int ne : gr[node]) {\\n            if (!validColouring(gr, colour, ne, -col))\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    public boolean isBipartite(int[][] gr) {\\n        int n = gr.length;\\n        int[] colour = new int[n];\\n\\n        for (int node = 0; node < n; node++) {\\n            if (colour[node] == 0 && !validColouring(gr, colour, node, 1))\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def validColouring(self, gr, colour, node, col):\\n        if colour[node] != 0:\\n            return colour[node] == col\\n\\n        colour[node] = col\\n        for ne in gr[node]:\\n            if not self.validColouring(gr, colour, ne, -col):\\n                return False\\n\\n        return True\\n\\n    def isBipartite(self, gr):\\n        n = len(gr)\\n        colour = [0] * n\\n\\n        for node in range(n):\\n            if colour[node] == 0 and not self.validColouring(gr, colour, node, 1):\\n                return False\\n\\n        return True\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Graph"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& gr) {\\n        int n = gr.size();\\n        vector<int> colour(n, 0);\\n\\n        for(int node = 0; node < n; node++){\\n            if(colour[node] != 0) continue;\\n\\n            queue<int> q;\\n            q.push(node);\\n            colour[node] = 1;\\n\\n            while(!q.empty()){\\n                int cur = q.front();\\n                q.pop();\\n\\n                for(int ne : gr[cur]){\\n                    if(colour[ne] == 0){\\n                        colour[ne] = -colour[cur];\\n                        q.push(ne);\\n                    }else if(colour[ne] != -colour[cur]){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```\n```Java []\\nimport java.util.ArrayDeque;\\nimport java.util.Queue;\\n\\nclass Solution {\\n    public boolean isBipartite(int[][] gr) {\\n        int n = gr.length;\\n        int[] colour = new int[n];\\n\\n        for (int node = 0; node < n; node++) {\\n            if (colour[node] != 0) {\\n                continue;\\n            }\\n\\n            Queue<Integer> q = new ArrayDeque<>();\\n            q.add(node);\\n            colour[node] = 1;\\n\\n            while (!q.isEmpty()) {\\n                int cur = q.poll();\\n\\n                for (int ne : gr[cur]) {\\n                    if (colour[ne] == 0) {\\n                        colour[ne] = -colour[cur];\\n                        q.add(ne);\\n                    } else if (colour[ne] != -colour[cur]) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\n```Python []\\nfrom typing import List\\nfrom collections import deque\\n\\nclass Solution:\\n    def isBipartite(self, gr: List[List[int]]) -> bool:\\n        n = len(gr)\\n        colour = [0] * n\\n\\n        for node in range(n):\\n            if colour[node] != 0:\\n                continue\\n\\n            q = deque()\\n            q.append(node)\\n            colour[node] = 1\\n\\n            while q:\\n                cur = q.popleft()\\n\\n                for ne in gr[cur]:\\n                    if colour[ne] == 0:\\n                        colour[ne] = -colour[cur]\\n                        q.append(ne)\\n                    elif colour[ne] != -colour[cur]:\\n                        return False\\n\\n        return True\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool validColouring(vector<vector<int>>& gr, vector<int>& colour, int node, int col){\\n        if(colour[node] != 0)\\n            return (colour[node] == col);\\n\\n        colour[node] = col;\\n        for(int ne : gr[node]){\\n            if(!validColouring(gr, colour, ne, -col))\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    bool isBipartite(vector<vector<int>>& gr) {\\n        int n = gr.size();\\n        vector<int> colour(n, 0);\\n\\n        for(int node = 0; node < n; node++){\\n            if(colour[node]==0 && !validColouring(gr, colour, node, 1))\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean validColouring(int[][] gr, int[] colour, int node, int col) {\\n        if (colour[node] != 0)\\n            return colour[node] == col;\\n\\n        colour[node] = col;\\n        for (int ne : gr[node]) {\\n            if (!validColouring(gr, colour, ne, -col))\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    public boolean isBipartite(int[][] gr) {\\n        int n = gr.length;\\n        int[] colour = new int[n];\\n\\n        for (int node = 0; node < n; node++) {\\n            if (colour[node] == 0 && !validColouring(gr, colour, node, 1))\\n                return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def validColouring(self, gr, colour, node, col):\\n        if colour[node] != 0:\\n            return colour[node] == col\\n\\n        colour[node] = col\\n        for ne in gr[node]:\\n            if not self.validColouring(gr, colour, ne, -col):\\n                return False\\n\\n        return True\\n\\n    def isBipartite(self, gr):\\n        n = len(gr)\\n        colour = [0] * n\\n\\n        for node in range(n):\\n            if colour[node] == 0 and not self.validColouring(gr, colour, node, 1):\\n                return False\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 176266,
                "title": "clean-and-easy-unionfind-in-java",
                "content": "```\\n    public boolean isBipartite(int[][] graph) {\\n        UnionFind uf = new UnionFind(graph.length);\\n\\t// traverse all vertex\\n        for (int i=0; i<graph.length; i++) {\\n            int[] adjs = graph[i];\\n\\t    // for a given vertex graph[i], if it\\'s connected with its any adj vertex, it\\'s not bipartite\\n            for (int j=0; j<adjs.length; j++) {\\n                if (uf.find(i) == uf.find(adjs[j])) return false;\\n                uf.union(adjs[0], adjs[j]);\\n            }\\n        }\\n        return true;\\n    }\\n    // standard union find\\n    class UnionFind {\\n        int[] parent;\\n        UnionFind(int n) {\\n            parent = new int[n];\\n            for (int i=0; i<n; i++) {\\n                parent[i] = i;\\n            }\\n        }\\n        \\n        int find(int i) {\\n            if (parent[i] == i) {\\n                return parent[i];\\n            }\\n            parent[i] = find(parent[i]);\\n            return parent[i];\\n        }\\n        \\n        void union(int i, int j) {\\n            int parentI = find(i);\\n            int parentJ = find(j);\\n            if (parentI != parentJ) {\\n                parent[parentI] = parentJ;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isBipartite(int[][] graph) {\\n        UnionFind uf = new UnionFind(graph.length);\\n\\t// traverse all vertex\\n        for (int i=0; i<graph.length; i++) {\\n            int[] adjs = graph[i];\\n\\t    // for a given vertex graph[i], if it\\'s connected with its any adj vertex, it\\'s not bipartite\\n            for (int j=0; j<adjs.length; j++) {\\n                if (uf.find(i) == uf.find(adjs[j])) return false;\\n                uf.union(adjs[0], adjs[j]);\\n            }\\n        }\\n        return true;\\n    }\\n    // standard union find\\n    class UnionFind {\\n        int[] parent;\\n        UnionFind(int n) {\\n            parent = new int[n];\\n            for (int i=0; i<n; i++) {\\n                parent[i] = i;\\n            }\\n        }\\n        \\n        int find(int i) {\\n            if (parent[i] == i) {\\n                return parent[i];\\n            }\\n            parent[i] = find(parent[i]);\\n            return parent[i];\\n        }\\n        \\n        void union(int i, int j) {\\n            int parentI = find(i);\\n            int parentJ = find(j);\\n            if (parentI != parentJ) {\\n                parent[parentI] = parentJ;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350852,
                "title": "java-2-methods-with-video-explanation",
                "content": "* Based off here: https://www.youtube.com/watch?v=FofydiwP5YQ\\n* Duplicate problem: [886. Possible Bipartition](https://leetcode.com/problems/possible-bipartition/discuss/2934508/Java-or-Reuse-LC-785-or-3-methods)\\n\\n**Method 1:** BFS\\n>**T/S:** O(V+E) / O(V), where V = number of vertices, E = number of edges\\n```\\npublic boolean isBipartite(int[][] graph) {\\n\\tvar color = new int[graph.length];\\n\\tArrays.fill(color, -1);\\n\\n\\tfor (var i = 0; i < graph.length; i++)\\n\\t\\tif (color[i] == -1 && !bfs(i, graph, color))\\n\\t\\t\\treturn false;\\n\\t\\t\\t\\n\\treturn true;\\n}\\n\\nprivate boolean bfs(int node, int[][] graph, int[] color) {\\n\\tcolor[node] = 0;\\n\\n\\tfor (var q = new ArrayDeque<>(List.of(node)); !q.isEmpty();) {\\n\\t\\tvar curr = q.poll();\\n\\t\\t\\n\\t\\tfor (var neighbor : graph[curr]) {\\n\\t\\t\\tif (color[neighbor] == color[curr])\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tif (color[neighbor] == -1) {\\n\\t\\t\\t\\tcolor[neighbor] = 1 - color[curr];\\n\\t\\t\\t\\tq.add(neighbor);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn true;\\n}\\n```\\n\\n**Method 2:** DFS\\n```\\npublic boolean isBipartite(int[][] graph) {\\n\\tvar colors = new int[graph.length];\\n\\t\\n\\tfor (var i = 0; i < graph.length; i++)\\n\\t\\tif (colors[i] == 0 && !dfs(graph, colors, 1, i))\\n\\t\\t\\treturn false;\\n\\t\\n\\treturn true;\\n}\\n\\nprivate boolean dfs(int[][] graph, int[] colors, int color, int node) {\\n\\tif (colors[node] != 0)\\n\\t\\treturn colors[node] == color; // is the node the same color it was about to be colored with?\\n\\t\\t\\n\\tcolors[node] = color;\\n\\n\\tfor (var nei : graph[node])\\n\\t\\tif (!dfs(graph, colors, -color, nei))\\n\\t\\t\\treturn false;\\n\\t\\n\\treturn true;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic boolean isBipartite(int[][] graph) {\\n\\tvar color = new int[graph.length];\\n\\tArrays.fill(color, -1);\\n\\n\\tfor (var i = 0; i < graph.length; i++)\\n\\t\\tif (color[i] == -1 && !bfs(i, graph, color))\\n\\t\\t\\treturn false;\\n\\t\\t\\t\\n\\treturn true;\\n}\\n\\nprivate boolean bfs(int node, int[][] graph, int[] color) {\\n\\tcolor[node] = 0;\\n\\n\\tfor (var q = new ArrayDeque<>(List.of(node)); !q.isEmpty();) {\\n\\t\\tvar curr = q.poll();\\n\\t\\t\\n\\t\\tfor (var neighbor : graph[curr]) {\\n\\t\\t\\tif (color[neighbor] == color[curr])\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tif (color[neighbor] == -1) {\\n\\t\\t\\t\\tcolor[neighbor] = 1 - color[curr];\\n\\t\\t\\t\\tq.add(neighbor);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn true;\\n}\\n```\n```\\npublic boolean isBipartite(int[][] graph) {\\n\\tvar colors = new int[graph.length];\\n\\t\\n\\tfor (var i = 0; i < graph.length; i++)\\n\\t\\tif (colors[i] == 0 && !dfs(graph, colors, 1, i))\\n\\t\\t\\treturn false;\\n\\t\\n\\treturn true;\\n}\\n\\nprivate boolean dfs(int[][] graph, int[] colors, int color, int node) {\\n\\tif (colors[node] != 0)\\n\\t\\treturn colors[node] == color; // is the node the same color it was about to be colored with?\\n\\t\\t\\n\\tcolors[node] = color;\\n\\n\\tfor (var nei : graph[node])\\n\\t\\tif (!dfs(graph, colors, -color, nei))\\n\\t\\t\\treturn false;\\n\\t\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3539984,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers. This is only for first 10,000 Subscribers.  **DON\\'T FORGET** to Subscribe\\n\\n# Search \\uD83D\\uDC49 `Tech Wired Leetcode` to Subscribe\\n\\n# Video Solution\\n\\n# or\\n\\n\\n# Click the Link in my Profile\\n\\n# Approach:\\nThe problem is to determine if a given graph is bipartite or not. A graph is bipartite if we can divide its vertices into two disjoint sets such that every edge connects a vertex from one set to a vertex from the other set.\\n\\nWe can solve this problem using a depth-first search (DFS) approach. The idea is to assign colors to the nodes of the graph such that adjacent nodes have different colors. We start by initializing an array to keep track of the colors assigned to each node. Then, for each unvisited node in the graph, we perform a DFS to explore its neighbors. During the DFS, we assign alternating colors to the current node and its neighbors. If we encounter a neighbor that already has a color assigned and it is the same as the current node\\'s color, then the graph is not bipartite. If we successfully color all the nodes without conflicts, the graph is bipartite.\\n\\n# Intuition:\\nThe key intuition behind the solution is that if a graph is bipartite, we can divide its vertices into two independent sets such that there are no edges within the same set. In other words, all edges in the graph should go from one set to the other. We can exploit this property by assigning colors to the vertices during the DFS traversal. By assigning alternating colors to adjacent vertices, we ensure that edges connect vertices of different colors. If, during the traversal, we encounter an edge that connects two vertices of the same color, it means the graph is not bipartite.\\n\\nBy traversing the graph using DFS and assigning colors, we can determine whether the graph is bipartite or not. This approach allows us to efficiently check the bipartiteness of the graph by visiting each node only once and propagating the colors to its neighbors.\\n\\n\\n\\n\\n\\n\\n```Python []\\nclass Solution:\\n    def isBipartite(self, graph):\\n        n = len(graph)\\n        colors = [0] * n\\n\\n        for i in range(n):\\n            if colors[i] == 0:\\n                if not self.dfs(graph, colors, i, 1):\\n                    return False\\n\\n        return True\\n\\n    def dfs(self, graph, colors, node, color):\\n        if colors[node] != 0:\\n            return colors[node] == color\\n\\n        colors[node] = color\\n\\n        for neighbor in graph[node]:\\n            if not self.dfs(graph, colors, neighbor, -color):\\n                return False\\n\\n        return True\\n\\n```\\n```Java []\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int n = graph.length;\\n        int[] colors = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            if (colors[i] == 0 && !dfs(graph, colors, i, 1)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    private boolean dfs(int[][] graph, int[] colors, int node, int color) {\\n        if (colors[node] != 0) {\\n            return colors[node] == color;\\n        }\\n\\n        colors[node] = color;\\n\\n        for (int neighbor : graph[node]) {\\n            if (!dfs(graph, colors, neighbor, -color)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<int> colors(n, 0);\\n\\n        for (int i = 0; i < n; i++) {\\n            if (colors[i] == 0 && !dfs(graph, colors, i, 1)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\nprivate:\\n    bool dfs(vector<vector<int>>& graph, vector<int>& colors, int node, int color) {\\n        if (colors[node] != 0) {\\n            return colors[node] == color;\\n        }\\n\\n        colors[node] = color;\\n\\n        for (int neighbor : graph[node]) {\\n            if (!dfs(graph, colors, neighbor, -color)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n\\n```\\n# An Upvote will be encouraging \\uD83D\\uDC4D\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```Python []\\nclass Solution:\\n    def isBipartite(self, graph):\\n        n = len(graph)\\n        colors = [0] * n\\n\\n        for i in range(n):\\n            if colors[i] == 0:\\n                if not self.dfs(graph, colors, i, 1):\\n                    return False\\n\\n        return True\\n\\n    def dfs(self, graph, colors, node, color):\\n        if colors[node] != 0:\\n            return colors[node] == color\\n\\n        colors[node] = color\\n\\n        for neighbor in graph[node]:\\n            if not self.dfs(graph, colors, neighbor, -color):\\n                return False\\n\\n        return True\\n\\n```\n```Java []\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int n = graph.length;\\n        int[] colors = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            if (colors[i] == 0 && !dfs(graph, colors, i, 1)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    private boolean dfs(int[][] graph, int[] colors, int node, int color) {\\n        if (colors[node] != 0) {\\n            return colors[node] == color;\\n        }\\n\\n        colors[node] = color;\\n\\n        for (int neighbor : graph[node]) {\\n            if (!dfs(graph, colors, neighbor, -color)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<int> colors(n, 0);\\n\\n        for (int i = 0; i < n; i++) {\\n            if (colors[i] == 0 && !dfs(graph, colors, i, 1)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\nprivate:\\n    bool dfs(vector<vector<int>>& graph, vector<int>& colors, int node, int color) {\\n        if (colors[node] != 0) {\\n            return colors[node] == color;\\n        }\\n\\n        colors[node] = color;\\n\\n        for (int neighbor : graph[node]) {\\n            if (!dfs(graph, colors, neighbor, -color)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 120218,
                "title": "java-short-iterative-solution",
                "content": "```\\npublic boolean isBipartite(int[][] g) {\\n        int[] colors = new int[g.length];\\n        for (int i = 0; i < g.length; i++)\\n            if (colors[i] == 0) {\\n                Queue<Integer> q = new LinkedList<>();\\n                q.add(i);\\n                colors[i] = 1;\\n                while (!q.isEmpty()) {\\n                    Integer node = q.poll();\\n                    for (int adjacent : g[node])\\n                        if (colors[adjacent] == colors[node])\\n                            return false;\\n                        else if (colors[adjacent] == 0) {\\n                            q.add(adjacent);\\n                            colors[adjacent] = -colors[node];\\n                        }\\n                }\\n            }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic boolean isBipartite(int[][] g) {\\n        int[] colors = new int[g.length];\\n        for (int i = 0; i < g.length; i++)\\n            if (colors[i] == 0) {\\n                Queue<Integer> q = new LinkedList<>();\\n                q.add(i);\\n                colors[i] = 1;\\n                while (!q.isEmpty()) {\\n                    Integer node = q.poll();\\n                    for (int adjacent : g[node])\\n                        if (colors[adjacent] == colors[node])\\n                            return false;\\n                        else if (colors[adjacent] == 0) {\\n                            q.add(adjacent);\\n                            colors[adjacent] = -colors[node];\\n                        }\\n                }\\n            }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1990409,
                "title": "very-simple-c-solution",
                "content": "**Bipartite** means no two adjacent nodes have same colour.\\n**Idea ->Colour each node with 1 or -1** and if two adjacent node have same colour then we simply **return false** and if we traverse all nodes and not found any two adjacent node having same colour then we **return true.**\\nHere we are using breadth first traversal to traverse in graph\\n```\\nbool isBipartite(vector<vector<int>>& graph) \\n    {\\n        int n=graph.size();\\n        vector<int> color(n,0);    \\n        for(int i=0;i<n;i++)                 // traverse each component\\n        {\\n            if(color[i]) continue;          // if already coloured then continue\\n            queue<int> q;\\n            q.push(i);\\n            color[i]=1;\\n            while(!q.empty())\\n            {\\n                int parent=q.front();\\n                q.pop();\\n                for(int child:graph[parent])\\n                {\\n                    if(color[child]==0)\\n                    {\\n                        color[child]=-color[parent];\\n                        q.push(child);\\n                    }\\n                    else\\n                    {\\n                        if(color[parent]==color[child]) return false;    \\n                        // if parent and child have same colour then return false;\\n                    }\\n                }\\n            }\\n\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nbool isBipartite(vector<vector<int>>& graph) \\n    {\\n        int n=graph.size();\\n        vector<int> color(n,0);    \\n        for(int i=0;i<n;i++)                 // traverse each component\\n        {\\n            if(color[i]) continue;          // if already coloured then continue\\n            queue<int> q;\\n            q.push(i);\\n            color[i]=1;\\n            while(!q.empty())\\n            {\\n                int parent=q.front();\\n                q.pop();\\n                for(int child:graph[parent])\\n                {\\n                    if(color[child]==0)\\n                    {\\n                        color[child]=-color[parent];\\n                        q.push(child);\\n                    }\\n                    else\\n                    {\\n                        if(color[parent]==color[child]) return false;    \\n                        // if parent and child have same colour then return false;\\n                    }\\n                }\\n            }\\n\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1065041,
                "title": "python-odd-loop-detection-explained",
                "content": "This problem is very similar to problem **886. Possible Bipartition** and it happens that I already solved this problem previously, you can see my solution here: https://leetcode.com/problems/possible-bipartition/discuss/654840/Python-Simple-dfs-traversal-O(E%2BV)-detailed-explanations\\n\\nHere I do absolutely the same idea, but with a bit more clear coding style and also we do not need to create adjacency list here, it is already given in this way. The idea is the following: we traverse our graph and color our nodes int two colors `0` and `1`: first one for nodes which can be reached with even number of steps and `1` for odd number of steps. Also we keep `self.loop` flag, which is true if we found `odd` loop, that is our graph is not bipartite. \\n\\nWe define `dist` array with `-1` inside and then we start dfs from every node, and color our graph (note, that graph can have several connected components, so we need to start dfs from all nodes).\\n\\n**Complexity**: time complexity is `O(E+V)`, because it is complexity of classical `dfs` we are using. Space complexity is `O(V)` to keep `dist` array. Here `E` is number of edges and `V` is number of vertices.\\n\\n\\n```\\nclass Solution:\\n    def isBipartite(self, graph):\\n        def dfs(start):\\n            if self.loop: return     #early stop if we found odd cycle\\n\\n            for neib in graph[start]:\\n                if dist[neib] >= 0 and dist[neib] == dist[start]:\\n                    self.loop = True\\n                elif dist[neib] < 0:\\n                    dist[neib] = dist[start]^1\\n                    dfs(neib)\\n            \\n        n = len(graph) \\n        self.loop, dist = False, [-1] *(n)\\n        \\n        for i in range(n):\\n            if self.loop: return False     #early stop if we found odd cycle\\n            if dist[i] == -1:\\n                dist[i] = 0\\n                dfs(i)\\n                \\n        return True\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def isBipartite(self, graph):\\n        def dfs(start):\\n            if self.loop: return     #early stop if we found odd cycle\\n\\n            for neib in graph[start]:\\n                if dist[neib] >= 0 and dist[neib] == dist[start]:\\n                    self.loop = True\\n                elif dist[neib] < 0:\\n                    dist[neib] = dist[start]^1\\n                    dfs(neib)\\n            \\n        n = len(graph) \\n        self.loop, dist = False, [-1] *(n)\\n        \\n        for i in range(n):\\n            if self.loop: return False     #early stop if we found odd cycle\\n            if dist[i] == -1:\\n                dist[i] = 0\\n                dfs(i)\\n                \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 115493,
                "title": "python-7-lines-dfs-graph-coloring-w-graph-and-explanation",
                "content": "The idea is to carry out the graph coloring algorithm through DFS.\nWe start coloring an uncolored root node with Blue/0, and start the DFS, where if a node is colored Blue, all its neighbors are colored Yellow/1 and vice versa.  \n\nA succesful completion of the 2-coloring of a bipartite graph will look like the following:\n\n<a href=\"https://imgbb.com/\"><img src=\"https://image.ibb.co/mGTTCc/d1.jpg\" alt=\"d1\" border=\"0\"></a>\n\n\nIf at any point, we find that the node we are about to color with Yellow is already colored with Blue (or vice versa), this essentially means that the following non-bipartiteness exists:\n\n<a href=\"https://imgbb.com/\"><img src=\"https://image.ibb.co/i3o6yH/d2.jpg\" alt=\"d2\" border=\"0\"></a><br />\n\nWe see that there is an offending edge F--->E that tries to color E in Blue, because F is Yellow, but E is already colored Yellow due to edge A ---->E and hence the graph cannot be bipartite.\n\n\n\n\n```\n    def isBipartite(self, graph):\n        color = defaultdict(lambda: -1)\n        return all(self.dfs(graph, v, edges, 0, color) for v, edges in enumerate(graph) if color[v] == -1)\n\n    def dfs(self, graph, v, edges, cur_color, color):\n        if color[v] != -1: return color[v] == cur_color\n        color[v] = cur_color\n        return all(self.dfs(graph, e, graph[e], int(not cur_color), color) for e in edges)\n```",
                "solutionTags": [],
                "code": "```\n    def isBipartite(self, graph):\n        color = defaultdict(lambda: -1)\n        return all(self.dfs(graph, v, edges, 0, color) for v, edges in enumerate(graph) if color[v] == -1)\n\n    def dfs(self, graph, v, edges, cur_color, color):\n        if color[v] != -1: return color[v] == cur_color\n        color[v] = cur_color\n        return all(self.dfs(graph, e, graph[e], int(not cur_color), color) for e in edges)\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1484708,
                "title": "python-bfs-graph-coloring-simple-solution",
                "content": "```\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        colors = [None] * len(graph)\\n        for i in range(len(graph)):\\n            if colors[i] is None:\\n                colors[i] = 1\\n                queue = [i]\\n                while queue:\\n                    currentNode = queue.pop(0)\\n                    for node in graph[currentNode]:\\n                        if colors[node] is None:\\n                            colors[node] = 1 - colors[currentNode]\\n                            queue.append(node)\\n                        elif colors[node] == colors[currentNode]:\\n                            return False\\n        return True\\n```\\n\\n***If you liked the above solution then please upvote***!",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        colors = [None] * len(graph)\\n        for i in range(len(graph)):\\n            if colors[i] is None:\\n                colors[i] = 1\\n                queue = [i]\\n                while queue:\\n                    currentNode = queue.pop(0)\\n                    for node in graph[currentNode]:\\n                        if colors[node] is None:\\n                            colors[node] = 1 - colors[currentNode]\\n                            queue.append(node)\\n                        elif colors[node] == colors[currentNode]:\\n                            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065932,
                "title": "what-is-a-good-thing-to-do-on-valentine-s-day-finish-a-daily-challenge-on-leetcode-sad-story",
                "content": "```\\n\\'\\'\\'\\nw: Bipartite --> BFS + coloring\\nh: Use regular BFS manner to traverse the graph:\\n    1) each pair of connected nodes A--B cannot have same color\\n        we use 1 to mark A and -1 to mark B\\n    2) if we a node was seen before and the color does not match, \\n        this means this node violate the bipartite condition\\n    3) repeat this process for all nodes since not all the nodes are connected, \\n\\t\\tin other words, the graph may have different disjoint components\\n\\'\\'\\'\\nimport collections\\n\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        \\n        seen = {}\\n        for i in range(len(graph)):\\n            if i not in seen:\\n                queue  = collections.deque([(i, 1)])\\n                while queue:\\n                    node, color = queue.popleft()\\n                    if node in seen:\\n                        if color == seen[node]:\\n                            continue\\n                        else:\\n                            return False\\n                    seen[node] = color\\n\\n                    for nei in graph[node]:\\n                        queue.append((nei, color * (-1)))\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\'\\'\\'\\nw: Bipartite --> BFS + coloring\\nh: Use regular BFS manner to traverse the graph:\\n    1) each pair of connected nodes A--B cannot have same color\\n        we use 1 to mark A and -1 to mark B\\n    2) if we a node was seen before and the color does not match, \\n        this means this node violate the bipartite condition\\n    3) repeat this process for all nodes since not all the nodes are connected, \\n\\t\\tin other words, the graph may have different disjoint components\\n\\'\\'\\'\\nimport collections\\n\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        \\n        seen = {}\\n        for i in range(len(graph)):\\n            if i not in seen:\\n                queue  = collections.deque([(i, 1)])\\n                while queue:\\n                    node, color = queue.popleft()\\n                    if node in seen:\\n                        if color == seen[node]:\\n                            continue\\n                        else:\\n                            return False\\n                    seen[node] = color\\n\\n                    for nei in graph[node]:\\n                        queue.append((nei, color * (-1)))\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 636227,
                "title": "graph-coloring-solution-explanation-with-python-3",
                "content": "Since we know that a graph is bipartite if and only if it is 2-colorable (meaning that we can color the graph such that no two adjacent verticies are of the same color with only 2 colors), we can attempt to 2-color the graph by traversing the graph and marking the neighbors of a node to be a different color than the color of the node. If we successfully 2-color the graph, we can return true, but if we come across two adjacent verticies of the same colors, we must return false. \\n\\nWe can implement this algorithm by running BFS search starting from every node in the graph (remember, there is no guarantee that the input graph is connected), while keeping a single visited set across BFS searches to prevent redundent searches. This algorithm is in O(|E|+|V|) time, where |E| is the number of edges and |V| is the number of verticies in the input graph.\\n\\n```\\ndef isBipartite(self, graph: List[List[int]]) -> bool:\\n        visited = set()\\n        two_color = [set(), set()]\\n        for i in range(len(graph)):\\n            if i not in visited:\\n                \\n                queue = [(i, 0)]\\n                while queue:\\n                    node, level = queue.pop()\\n                    visited.add(node)\\n                    two_color[level].add(node)\\n                \\n                    for neighbor in graph[node]:\\n                        if neighbor in two_color[level]:\\n                            return False\\n                        if neighbor not in visited:\\n                            queue.append((neighbor, 1 if level == 0 else 0))\\n                    \\n        return True\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue",
                    "Ordered Set"
                ],
                "code": "```\\ndef isBipartite(self, graph: List[List[int]]) -> bool:\\n        visited = set()\\n        two_color = [set(), set()]\\n        for i in range(len(graph)):\\n            if i not in visited:\\n                \\n                queue = [(i, 0)]\\n                while queue:\\n                    node, level = queue.pop()\\n                    visited.add(node)\\n                    two_color[level].add(node)\\n                \\n                    for neighbor in graph[node]:\\n                        if neighbor in two_color[level]:\\n                            return False\\n                        if neighbor not in visited:\\n                            queue.append((neighbor, 1 if level == 0 else 0))\\n                    \\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1991013,
                "title": "c-bfs-graph-coloring-daily-leetcoding-challenge-april-day-29",
                "content": "![image](https://assets.leetcode.com/users/images/cedd003b-00b0-4f05-b15e-304fc63f5a0d_1651214094.2801042.png)\\n* A **Bipartite Graph** is one in which the vertices may be separated into two distinct sets, U and V, and each edge (u, v) connects either a vertex from U to V or a vertex from V to U.\\n* There should be no edge between vertices of the same set.\\n* This type of graph conceivable if the graph can be coloured with two colours so that vertices in a set are all the same colour.\\n* The solution can be implemented using both BFS and DFS approach.\\n* Below is the BFS approach with T.C : O(V + E).\\n* Start with any node giving it any of the two colours from {1, -1}. Then alternatively give colors to its neighbors which are not colored yet i.e. `color[node] == 0`.\\n* Also the graph may not be a connected graph so process every node for BFS.\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isBipartiteHelper(vector<vector<int>>& graph, vector<int>& color, int startNode){\\n        \\n        bool ans = true;\\n        int n = graph.size();\\n        queue<int> q;        \\n        int currentColor = -1;\\n        q.push(startNode);\\n        color[startNode] = currentColor;\\n        \\n        while(!q.empty()){\\n            \\n            int frontNode = q.front();            \\n            \\n            for(int i = 0; i < graph[frontNode].size(); i++){\\n                \\n                if(color[graph[frontNode][i]] == 0){\\n                    \\n                    q.push(graph[frontNode][i]);\\n                    color[graph[frontNode][i]] = -1*color[frontNode];\\n                    \\n                }else if(color[graph[frontNode][i]] == color[frontNode]){\\n                    return false;\\n                }\\n                \\n            }\\n            q.pop();\\n            currentColor = -1*currentColor;\\n            \\n            \\n        }\\n        \\n        return true;\\n        \\n    }\\n    \\n    bool isBipartite(vector<vector<int>>& graph){\\n        \\n        int n = graph.size();\\n        int ans = true;\\n        vector<int> color(n, 0);\\n        \\n        for(int i = 0; i < n; i++){\\n            \\n            if(color[i] == 0){\\n                ans = (ans && isBipartiteHelper(graph, color, i));\\n                if(!ans) break;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isBipartiteHelper(vector<vector<int>>& graph, vector<int>& color, int startNode){\\n        \\n        bool ans = true;\\n        int n = graph.size();\\n        queue<int> q;        \\n        int currentColor = -1;\\n        q.push(startNode);\\n        color[startNode] = currentColor;\\n        \\n        while(!q.empty()){\\n            \\n            int frontNode = q.front();            \\n            \\n            for(int i = 0; i < graph[frontNode].size(); i++){\\n                \\n                if(color[graph[frontNode][i]] == 0){\\n                    \\n                    q.push(graph[frontNode][i]);\\n                    color[graph[frontNode][i]] = -1*color[frontNode];\\n                    \\n                }else if(color[graph[frontNode][i]] == color[frontNode]){\\n                    return false;\\n                }\\n                \\n            }\\n            q.pop();\\n            currentColor = -1*currentColor;\\n            \\n            \\n        }\\n        \\n        return true;\\n        \\n    }\\n    \\n    bool isBipartite(vector<vector<int>>& graph){\\n        \\n        int n = graph.size();\\n        int ans = true;\\n        vector<int> color(n, 0);\\n        \\n        for(int i = 0; i < n; i++){\\n            \\n            if(color[i] == 0){\\n                ans = (ans && isBipartiteHelper(graph, color, i));\\n                if(!ans) break;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 322574,
                "title": "concise-c-solution-using-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool bfs(int src,vector<vector<int>>& graph,vector<int> &color){\\n        color[src]=1;\\n        queue<int> q;\\n        q.push(src);\\n        \\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            \\n            \\n            for(auto i:graph[u]){\\n                if( color[i]==-1){\\n\\t\\t\\t\\t\\t//Assign alternate color to its neighbors.\\n                    color[i]=1-color[u];\\n                    q.push(i);\\n                }\\n                else if(color[i]==color[u])return false; // If neighbor is of same color returnn false.\\n            }\\n        }\\n        return true;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        \\n        int v=graph.size();\\n\\t\\t// Create a color array to store colors assigned to all \\n\\t\\t// veritces. Vertex/ number is used as index in this \\n\\t\\t// array. The value \\'-1\\' of colorArr[i] is used to \\n\\t\\t// indicate that no color is assigned to vertex \\'i\\'. \\n\\t\\t// The value 1 is used to indicate first color is \\n\\t\\t// assigned and value 0 indicates second color is \\n\\t\\t// assigned. \\n        vector<int> color(v,-1);//for(int i=0;i<v;i++)color[i]=-1;\\n\\t\\t//Handles if graph is disconnected.\\n        for(int i=0;i<v;i++){\\n            if(color[i]==-1){\\n                if(!bfs(i,graph,color))return false;\\n            }\\n        }\\n        return true;\\n        \\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool bfs(int src,vector<vector<int>>& graph,vector<int> &color){\\n        color[src]=1;\\n        queue<int> q;\\n        q.push(src);\\n        \\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            \\n            \\n            for(auto i:graph[u]){\\n                if( color[i]==-1){\\n\\t\\t\\t\\t\\t//Assign alternate color to its neighbors.\\n                    color[i]=1-color[u];\\n                    q.push(i);\\n                }\\n                else if(color[i]==color[u])return false; // If neighbor is of same color returnn false.\\n            }\\n        }\\n        return true;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        \\n        int v=graph.size();\\n\\t\\t// Create a color array to store colors assigned to all \\n\\t\\t// veritces. Vertex/ number is used as index in this \\n\\t\\t// array. The value \\'-1\\' of colorArr[i] is used to \\n\\t\\t// indicate that no color is assigned to vertex \\'i\\'. \\n\\t\\t// The value 1 is used to indicate first color is \\n\\t\\t// assigned and value 0 indicates second color is \\n\\t\\t// assigned. \\n        vector<int> color(v,-1);//for(int i=0;i<v;i++)color[i]=-1;\\n\\t\\t//Handles if graph is disconnected.\\n        for(int i=0;i<v;i++){\\n            if(color[i]==-1){\\n                if(!bfs(i,graph,color))return false;\\n            }\\n        }\\n        return true;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990681,
                "title": "python3-union-find",
                "content": "class Solution:\\n\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        length = len(graph)\\n        parent = [i for i in range(length)]\\n        \\n        def find(x):\\n            if x!=parent[x]:\\n                parent[x]=find(parent[x])#rank compression\\n            return parent[x]\\n        \\n        def union(x,y):\\n            px,py=find(x),find(y)\\n            if px!=py:\\n                parent[px]=py\\n               \\n        for i in range(length):\\n            pari=find(i)\\n            for j in graph[i]:\\n                if find(j)==pari:\\n                    return False\\n                union(graph[i][0],j)\\n                \\n        return True",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        length = len(graph)\\n        parent = [i for i in range(length)]\\n        \\n        def find(x):\\n            if x!=parent[x]:\\n                parent[x]=find(parent[x])#rank compression\\n            return parent[x]\\n        \\n        def union(x,y):\\n            px,py=find(x),find(y)\\n            if px!=py:\\n                parent[px]=py\\n               \\n        for i in range(length):\\n            pari=find(i)\\n            for j in graph[i]:\\n                if find(j)==pari:\\n                    return False\\n                union(graph[i][0],j)\\n                \\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 1111433,
                "title": "java-100-tc-both-dfs-bfs-with-explanation-of-bipartite",
                "content": "The idea is to take two colors and color adjacent neighbours differently, if any of the neighbour is already colored and is **not a different color**, **but same color**, then return **false** else **true**.\\n\\nA bipartite graph is Special graph in which vertices are split into 2 different sets, lets say A & B. and each vertex in A talks to (has an edge) to every vertex in B. \\nHowever, vertices in the same set do not have an edge amongst each other.\\n\\nSet A: {a,b,c}    Set B: {d,e,f}\\n\\n```\\na->d,e,f    b-> d,e,f  c-> d,e,f\\nd-> a,b,c  e->a,b,c  f->a,b,c\\n```\\n\\nIf at all `a-> a,b c` (meaning vertices in same set have an edge, then it is not a bipartitie graph, we return false).\\n\\nIn the below code` 0 is not yet colored`, `1 is blue color`,  `-1 is red `(or some other color)\\n\\nBFS:\\n```\\nclass Solution{\\n    public boolean isBipartite(int[][] graph) {\\n        int n = graph.length;\\n        int[] colors = new int[n];\\n\\n        //take two colors and color adjacent neighbours differently, if any of the neighbour is already colored and is not a different color, but same color, then return false else true.\\n        for (int i = 0; i < n; i++) {\\n            if (colors[i] == 0) { //if not yet coloured.\\n                Queue<Integer> q = new LinkedList<>();\\n                q.add(i);\\n                colors[i] = 1; //color it with blue\\n\\n                while (!q.isEmpty()) {\\n                    int cur = q.poll(); //start polling the current node\\n\\n                    for (int x : graph[cur]) {\\n                        if (colors[x] == 0) { //if not yet colored\\n                            colors[x] = -colors[cur]; // Use a different color for the adjacent node\\n                            q.offer(x);\\n                        } else if (colors[x] != -colors[cur])//if the adjacent node/neighbour is already coloured and not a different colour, we return false, as no two adjacent vertices must have same colors.\\n                            return false;\\n                    }\\n                }\\n\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\nDFS Implementation:\\n\\n```\\nclass Solution {\\n        public boolean isBipartite(int[][] graph) {\\n\\n            int n = graph.length;\\n            int colors[] = new int[n];\\n\\n            //take two colors and color adjacent neighbours differently, if any of the neighbour is already colored and is not a different color, but same color, then return false else true.\\n            for (int i = 0; i < n; i++) {\\n                if (colors[i] == 0 && !dfs(i, colors, graph, 1))\\n                    return false;\\n            }\\n            return true;\\n        }\\n\\n\\n        boolean dfs(int i, int[] colors, int[][] graph, int color) {\\n            if (colors[i] == 0) { // if no color added perform below steps\\n                colors[i] = color;//add color;\\n                for (int x : graph[i]) {\\n                    if (!dfs(x, colors, graph, -color)) //change color for adjacent vertex.\\n                        return false;\\n                }\\n            } else { //if a color is present, check if it is same color or different color, depending on  that return the result\\n                return colors[i] == color;\\n            }\\n            return true;\\n        }\\n}\\n\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\na->d,e,f    b-> d,e,f  c-> d,e,f\\nd-> a,b,c  e->a,b,c  f->a,b,c\\n```\n```\\nclass Solution{\\n    public boolean isBipartite(int[][] graph) {\\n        int n = graph.length;\\n        int[] colors = new int[n];\\n\\n        //take two colors and color adjacent neighbours differently, if any of the neighbour is already colored and is not a different color, but same color, then return false else true.\\n        for (int i = 0; i < n; i++) {\\n            if (colors[i] == 0) { //if not yet coloured.\\n                Queue<Integer> q = new LinkedList<>();\\n                q.add(i);\\n                colors[i] = 1; //color it with blue\\n\\n                while (!q.isEmpty()) {\\n                    int cur = q.poll(); //start polling the current node\\n\\n                    for (int x : graph[cur]) {\\n                        if (colors[x] == 0) { //if not yet colored\\n                            colors[x] = -colors[cur]; // Use a different color for the adjacent node\\n                            q.offer(x);\\n                        } else if (colors[x] != -colors[cur])//if the adjacent node/neighbour is already coloured and not a different colour, we return false, as no two adjacent vertices must have same colors.\\n                            return false;\\n                    }\\n                }\\n\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n        public boolean isBipartite(int[][] graph) {\\n\\n            int n = graph.length;\\n            int colors[] = new int[n];\\n\\n            //take two colors and color adjacent neighbours differently, if any of the neighbour is already colored and is not a different color, but same color, then return false else true.\\n            for (int i = 0; i < n; i++) {\\n                if (colors[i] == 0 && !dfs(i, colors, graph, 1))\\n                    return false;\\n            }\\n            return true;\\n        }\\n\\n\\n        boolean dfs(int i, int[] colors, int[][] graph, int color) {\\n            if (colors[i] == 0) { // if no color added perform below steps\\n                colors[i] = color;//add color;\\n                for (int x : graph[i]) {\\n                    if (!dfs(x, colors, graph, -color)) //change color for adjacent vertex.\\n                        return false;\\n                }\\n            } else { //if a color is present, check if it is same color or different color, depending on  that return the result\\n                return colors[i] == color;\\n            }\\n            return true;\\n        }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383521,
                "title": "easy-c-solution-using-bfs-and-dfs",
                "content": "****For graph colouring I\\'ve taken -1 as green colour and 1 as blue colour and 0 as uncoloured.****\\n# **BFS solution**\\n```\\nclass Solution \\n{\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) \\n    {\\n        int n=graph.size();\\n        vector<int>colour(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(colour[i]==0)\\n            {\\n                colour[i]=-1;\\n                queue<int>q;\\n                q.push(i);\\n                while(!q.empty())\\n                {\\n                    int x=q.front();\\n                    q.pop();\\n                    for(auto it:graph[x])\\n                    {\\n                        if(colour[it]==colour[x])\\n                        {\\n                            return false;\\n                        }\\n                        else if(colour[it]==0)\\n                        {\\n                            colour[it]=-colour[x];\\n                            q.push(it);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n# **DFS solution**\\n```\\nclass Solution \\n{\\npublic:\\n    bool helper(vector<vector<int>>&graph,vector<int>&colour,int curr)\\n    {\\n        for(auto it:graph[curr])\\n        {\\n            if(colour[it]==colour[curr])\\n            {\\n                return false;\\n            }\\n            else if(colour[it]==0)\\n            {\\n                colour[it]=-colour[curr];\\n                if(!helper(graph,colour,it))\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) \\n    {\\n        int n=graph.size();\\n        vector<int>colour(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(colour[i]==0) \\n            {\\n                colour[i]=-1;\\n                if(!helper(graph,colour,i))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n***Please upvote if you\\'ve found my code useful. Thank you.***",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) \\n    {\\n        int n=graph.size();\\n        vector<int>colour(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(colour[i]==0)\\n            {\\n                colour[i]=-1;\\n                queue<int>q;\\n                q.push(i);\\n                while(!q.empty())\\n                {\\n                    int x=q.front();\\n                    q.pop();\\n                    for(auto it:graph[x])\\n                    {\\n                        if(colour[it]==colour[x])\\n                        {\\n                            return false;\\n                        }\\n                        else if(colour[it]==0)\\n                        {\\n                            colour[it]=-colour[x];\\n                            q.push(it);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    bool helper(vector<vector<int>>&graph,vector<int>&colour,int curr)\\n    {\\n        for(auto it:graph[curr])\\n        {\\n            if(colour[it]==colour[curr])\\n            {\\n                return false;\\n            }\\n            else if(colour[it]==0)\\n            {\\n                colour[it]=-colour[curr];\\n                if(!helper(graph,colour,it))\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) \\n    {\\n        int n=graph.size();\\n        vector<int>colour(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(colour[i]==0) \\n            {\\n                colour[i]=-1;\\n                if(!helper(graph,colour,i))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1992743,
                "title": "python-simple-dfs-clean-concise",
                "content": "**Idea**\\n- We color nodes by rule:\\n\\t- If the color of current node is `1` then the next node (which shares the same edge) must have color `0`.\\n\\t- If the color of current node is `0` then the next node (which shares the same edge) must have color `1`.\\n- If the next node is already colored and that color violates the rule then it\\'s not bipartite.\\n```python\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        n = len(graph)\\n        colors = [None] * n\\n        \\n        def isBipartite(u, color):\\n            if colors[u] != None and colors[u] != color: # if node `u` is already colored and the color is different with what we expect -> Invalid\\n                return False\\n            if colors[u] != None: return True  # node `u` is already processed -> skip\\n            colors[u] = color\\n            for v in graph[u]:\\n                if not isBipartite(v, 1 - color):\\n                    return False\\n            return True\\n        \\n        for u in range(n):\\n            if colors[u] == None and not isBipartite(u, 0):\\n                return False\\n        \\n        return True\\n```\\nComplexity:\\n- Time: `O(E + V)`, where `E` is number of edges, `V = N` is number of nodes in the graph.\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        n = len(graph)\\n        colors = [None] * n\\n        \\n        def isBipartite(u, color):\\n            if colors[u] != None and colors[u] != color: # if node `u` is already colored and the color is different with what we expect -> Invalid\\n                return False\\n            if colors[u] != None: return True  # node `u` is already processed -> skip\\n            colors[u] = color\\n            for v in graph[u]:\\n                if not isBipartite(v, 1 - color):\\n                    return False\\n            return True\\n        \\n        for u in range(n):\\n            if colors[u] == None and not isBipartite(u, 0):\\n                return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299390,
                "title": "union-find-java-with-explanation",
                "content": "Union find can be used to solve this problem because we are essentially trying to see if a node is connected to a node in the same component. Union find helps us connect components together and figure out what nodes belong in the same component. If we ever find a node is part of the same component as any of its neighbors, we know the graph is not bipartite.\\n\\n```\\nclass Solution {\\n  public boolean isBipartite(int[][] graph) {\\n    UnionFind uf = new UnionFind(graph.length);\\n    for(int i = 0; i < graph.length; i++) {\\n      \\n      for(int j = 0; j < graph[i].length; j++) {\\n        // If the node is in the same component as its neighbors, then they are in the same set and the graph is not bipartite.\\n        // Bipartite means each node can only be connected to a node in another set/component\\n        if(uf.isConnected(i, graph[i][j])) return false;\\n        \\n        // We union all the neighbors together\\n        uf.union(graph[i][0], graph[i][j]);\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  public class UnionFind {\\n    private int[] parent;\\n    private int[] rank;\\n\\n    public UnionFind(int n) {\\n      parent = new int[n];\\n      rank = new int[n];\\n\\n      for (int i = 0; i < n; i++) {\\n        parent[i] = i;\\n      }\\n    }\\n\\n    public int find(int x) {\\n      if(parent[x] == x) return x;\\n\\n      int root = find(parent[x]);\\n      parent[x] = root; // path compression\\n      return root;\\n    }\\n\\n    public void union(int x, int y) {\\n      int rootx = find(x);\\n      int rooty = find(y);\\n\\n      if (rootx == rooty) return;\\n\\n      if (rank[rootx] > rank[rooty]) {\\n        parent[rooty] = rootx;\\n        rank[rootx]++;\\n      } else {\\n        parent[rootx] = rooty;\\n        rank[rooty]++;\\n      }\\n    }\\n\\n    public boolean isConnected(int p, int q) {\\n      return find(p) == find(q);\\n    }\\n  }\\n}\\n```\\nUpvote if this helped you \\uD83D\\uDC4D",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n  public boolean isBipartite(int[][] graph) {\\n    UnionFind uf = new UnionFind(graph.length);\\n    for(int i = 0; i < graph.length; i++) {\\n      \\n      for(int j = 0; j < graph[i].length; j++) {\\n        // If the node is in the same component as its neighbors, then they are in the same set and the graph is not bipartite.\\n        // Bipartite means each node can only be connected to a node in another set/component\\n        if(uf.isConnected(i, graph[i][j])) return false;\\n        \\n        // We union all the neighbors together\\n        uf.union(graph[i][0], graph[i][j]);\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  public class UnionFind {\\n    private int[] parent;\\n    private int[] rank;\\n\\n    public UnionFind(int n) {\\n      parent = new int[n];\\n      rank = new int[n];\\n\\n      for (int i = 0; i < n; i++) {\\n        parent[i] = i;\\n      }\\n    }\\n\\n    public int find(int x) {\\n      if(parent[x] == x) return x;\\n\\n      int root = find(parent[x]);\\n      parent[x] = root; // path compression\\n      return root;\\n    }\\n\\n    public void union(int x, int y) {\\n      int rootx = find(x);\\n      int rooty = find(y);\\n\\n      if (rootx == rooty) return;\\n\\n      if (rank[rootx] > rank[rooty]) {\\n        parent[rooty] = rootx;\\n        rank[rootx]++;\\n      } else {\\n        parent[rootx] = rooty;\\n        rank[rooty]++;\\n      }\\n    }\\n\\n    public boolean isConnected(int p, int q) {\\n      return find(p) == find(q);\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158856,
                "title": "javascript-dfs-and-bfs-solutions",
                "content": "**DFS Solution**\\n```javascript\\nconst isBipartite = graph => {\\n  const colors = new Map();\\n\\n  for (let u = 0; u < graph.length; u++) {\\n    if (!dfs(graph, colors, u, 0)) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n};\\n\\nconst dfs = (graph, colors, u, color) => {\\n  if (!colors.has(u)) {\\n    colors.set(u, color);\\n\\n    for (const v of graph[u]) {\\n      if (!dfs(graph, colors, v, 1 - color) || colors.get(v) === color) {\\n        return false;\\n      }\\n    }\\n  }\\n\\n  return true;\\n};\\n```\\n**BFS Solution**\\n```javascript\\nconst isBipartite = graph => {\\n  const colors = new Map();\\n\\n  for (let u = 0; u < graph.length; u++) {\\n    if (!bfs(graph, colors, u)) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n};\\n\\nconst bfs = (graph, colors, u) => {\\n  if (!colors.has(u)) {\\n    const queue = [u];\\n    colors.set(u, 0);\\n\\n    while (queue.length > 0) {\\n      u = queue.shift();\\n\\n      for (const v of graph[u]) {\\n        if (colors.get(v) === colors.get(u)) {\\n          return false;\\n        }\\n\\n        if (!colors.has(v)) {\\n          queue.push(v);\\n          colors.set(v, 1 - colors.get(u));\\n        }\\n      }\\n    }\\n  }\\n\\n  return true;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nconst isBipartite = graph => {\\n  const colors = new Map();\\n\\n  for (let u = 0; u < graph.length; u++) {\\n    if (!dfs(graph, colors, u, 0)) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n};\\n\\nconst dfs = (graph, colors, u, color) => {\\n  if (!colors.has(u)) {\\n    colors.set(u, color);\\n\\n    for (const v of graph[u]) {\\n      if (!dfs(graph, colors, v, 1 - color) || colors.get(v) === color) {\\n        return false;\\n      }\\n    }\\n  }\\n\\n  return true;\\n};\\n```\n```javascript\\nconst isBipartite = graph => {\\n  const colors = new Map();\\n\\n  for (let u = 0; u < graph.length; u++) {\\n    if (!bfs(graph, colors, u)) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n};\\n\\nconst bfs = (graph, colors, u) => {\\n  if (!colors.has(u)) {\\n    const queue = [u];\\n    colors.set(u, 0);\\n\\n    while (queue.length > 0) {\\n      u = queue.shift();\\n\\n      for (const v of graph[u]) {\\n        if (colors.get(v) === colors.get(u)) {\\n          return false;\\n        }\\n\\n        if (!colors.has(v)) {\\n          queue.push(v);\\n          colors.set(v, 1 - colors.get(u));\\n        }\\n      }\\n    }\\n  }\\n\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3539989,
                "title": "diagram-image-best-explaination-most-optimized-c-python-java",
                "content": "# Approach \\n<!-- Describe your first thoughts on how to solve this problem. -->Initialize a vector colors of length n to all 0\\'s, where n is the number of nodes in the graph.\\n\\nFor each uncolored node in the graph, initialize a queue q, push the node onto it, and assign it a color of 1.\\n\\nBegin a BFS traversal of the graph using the following steps:\\nPop a node curr from the queue.\\n\\nFor each uncolored neighbor of curr, assign a color of the opposite sign (-1) and push it onto the queue.\\n\\nIf a neighbor has already been assigned a color and it is the same as the current node\\'s color, then the graph is not bipartite and return false.\\n\\nIf the traversal completes without finding any conflicts, then the graph is bipartite and return true.\\n\\n# Diagram\\n<!-- Describe your approach to solving the problem. -->\\n![code2flow_4fd67K.png](https://assets.leetcode.com/users/images/8d9c4f22-dcb3-429f-a491-6c47bbff867e_1684454922.678456.png)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(V+E)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(V+E)\\n# C++\\n```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<int> colors(n);\\n\\n        for (int i = 0; i < n; i++) {\\n            if (colors[i]) continue;\\n            queue<int> q{{i}};\\n            colors[i] = 1;\\n\\n            while (!q.empty()) {\\n                int curr = q.front();\\n                q.pop();\\n                for (int neighbor : graph[curr]) {\\n                    if (colors[neighbor] == colors[curr]) return false;\\n                    if (colors[neighbor] == 0) {\\n                        colors[neighbor] = -colors[curr];\\n                        q.push(neighbor);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n# JAVA\\n```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int n = graph.length;\\n        int[] colors = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            if (colors[i] != 0) {\\n                continue;\\n            }\\n\\n            Queue<Integer> q = new LinkedList<>();\\n            q.offer(i);\\n            colors[i] = 1;\\n\\n            while (!q.isEmpty()) {\\n                int curr = q.poll();\\n\\n                for (int neighbor : graph[curr]) {\\n                    if (colors[neighbor] == 0) {\\n                        colors[neighbor] = -colors[curr];\\n                        q.offer(neighbor);\\n                    }\\n                    else if (colors[neighbor] == colors[curr]) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n\\n# Python\\n```\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        n = len(graph)\\n        colors = [0] * n\\n\\n        for i in range(n):\\n            if colors[i] != 0:\\n                continue\\n\\n            q = collections.deque([i])\\n            colors[i] = 1\\n\\n            while q:\\n                curr = q.popleft()\\n                for neighbor in graph[curr]:\\n                    if colors[neighbor] == 0:\\n                        colors[neighbor] = -colors[curr]\\n                        q.append(neighbor)\\n                    elif colors[neighbor] == colors[curr]:\\n                        return False\\n\\n        return True\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/2f5e6840-37b8-4bec-a7e8-b5a6f7c34ad3_1684455026.5260978.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<int> colors(n);\\n\\n        for (int i = 0; i < n; i++) {\\n            if (colors[i]) continue;\\n            queue<int> q{{i}};\\n            colors[i] = 1;\\n\\n            while (!q.empty()) {\\n                int curr = q.front();\\n                q.pop();\\n                for (int neighbor : graph[curr]) {\\n                    if (colors[neighbor] == colors[curr]) return false;\\n                    if (colors[neighbor] == 0) {\\n                        colors[neighbor] = -colors[curr];\\n                        q.push(neighbor);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int n = graph.length;\\n        int[] colors = new int[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            if (colors[i] != 0) {\\n                continue;\\n            }\\n\\n            Queue<Integer> q = new LinkedList<>();\\n            q.offer(i);\\n            colors[i] = 1;\\n\\n            while (!q.isEmpty()) {\\n                int curr = q.poll();\\n\\n                for (int neighbor : graph[curr]) {\\n                    if (colors[neighbor] == 0) {\\n                        colors[neighbor] = -colors[curr];\\n                        q.offer(neighbor);\\n                    }\\n                    else if (colors[neighbor] == colors[curr]) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        n = len(graph)\\n        colors = [0] * n\\n\\n        for i in range(n):\\n            if colors[i] != 0:\\n                continue\\n\\n            q = collections.deque([i])\\n            colors[i] = 1\\n\\n            while q:\\n                curr = q.popleft()\\n                for neighbor in graph[curr]:\\n                    if colors[neighbor] == 0:\\n                        colors[neighbor] = -colors[curr]\\n                        q.append(neighbor)\\n                    elif colors[neighbor] == colors[curr]:\\n                        return False\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707796,
                "title": "javascript-bfs-solution",
                "content": "```\\nvar isBipartite = function(graph) {\\n    const colors = new Map();\\n    const stack = [];\\n    \\n    for (let i = 0; i < graph.length; i++) {\\n        if (colors.has(i)) continue;\\n        \\n        colors.set(i, true);\\n        stack.push(i);\\n\\n        while (stack.length > 0) {\\n            let current = stack.pop();\\n\\n            for (let neighbour of graph[current]) {\\n                if (!colors.has(neighbour)) {\\n                    colors.set(neighbour, !colors.get(current));\\n                    stack.push(neighbour);\\n                    continue;\\n                }\\n                \\n                if (colors.get(neighbour) === colors.get(current)) return false;\\n            }\\n        }\\n    }\\n    \\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar isBipartite = function(graph) {\\n    const colors = new Map();\\n    const stack = [];\\n    \\n    for (let i = 0; i < graph.length; i++) {\\n        if (colors.has(i)) continue;\\n        \\n        colors.set(i, true);\\n        stack.push(i);\\n\\n        while (stack.length > 0) {\\n            let current = stack.pop();\\n\\n            for (let neighbour of graph[current]) {\\n                if (!colors.has(neighbour)) {\\n                    colors.set(neighbour, !colors.get(current));\\n                    stack.push(neighbour);\\n                    continue;\\n                }\\n                \\n                if (colors.get(neighbour) === colors.get(current)) return false;\\n            }\\n        }\\n    }\\n    \\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 480343,
                "title": "python-2-dfs-2-bfs",
                "content": "In all solution I use 1 and -1 to mark nodes to check their belonging to one or another set.\\n\\nSolution 1 DFS with stack:\\n```\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n\\n        colors = {}\\n        \\n        for from_node in range(len(graph)):\\n            if from_node in colors:\\n                continue\\n\\n            stack = [from_node]\\n            colors[from_node] = 1  # 1 is just starting color, could be -1 also\\n\\n            while stack:\\n                from_node = stack.pop()\\n\\n                for to_node in graph[from_node]:\\n                    if to_node in colors:\\n                        if colors[to_node] == colors[from_node]:\\n                            return False\\n                    else:\\n                        stack.append(to_node)                        \\n                        colors[to_node] = colors[from_node] * -1\\n        return True\\n```\\n\\nSolution2 - explicit DFS: \\n```\\n\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        colors = {}\\n        for node_from in range(len(graph)):\\n            if node_from not in colors and not self.dfs(graph, node_from, colors, 1):\\n                return False\\n\\n        return True\\n\\n    def dfs(self, graph, node, colors, color):\\n\\n        colors[node] = color\\n\\n        for node_to in graph[node]:\\n            if node_to in colors:\\n                if colors[node_to] == colors[node]:\\n                    return False\\n            else:\\n                if not self.dfs(graph, node_to, colors, color * -1):\\n                    return False\\n\\n        return True\\n```\\n\\nSolution 3 - BFS with queue:\\n```\\n\\nfrom collections import deque\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n\\n        colors = {}\\n\\n        for from_node in range(len(graph)):\\n            if from_node in colors:\\n                continue\\n            queue = deque([from_node])\\n            colors[from_node] = 1 # 1 is just starting color, could be -1 also\\n\\n            while queue:\\n                from_node = queue.popleft()\\n                for to_node in graph[from_node]:\\n                    if to_node in colors:\\n                        if colors[to_node] == colors[from_node]:\\n                            return False\\n                    else:\\n                        queue.append(to_node)\\n                        colors[to_node] = colors[from_node] * -1\\n\\n        return True\\n```\\n\\nSolution 4 - explicit BFS:\\n```\\nfrom collections import deque\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        colors = {}\\n        for node_from in range(len(graph)):\\n            if node_from not in colors and not self.bfs(graph, node_from, colors):\\n                return False\\n        return True\\n\\n    def bfs(self, graph, node, colors):\\n        queue = deque([node])\\n        colors[node] = 1\\n        while queue:\\n            node_from = queue.popleft()\\n            for node_to in graph[node_from]:\\n                if node_to in colors:\\n                    if colors[node_to] == colors[node_from]:\\n                        return False\\n                else:\\n                    colors[node_to] = colors[node_from] * -1\\n                    queue.append(node_to)\\n        return True\\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n\\n        colors = {}\\n        \\n        for from_node in range(len(graph)):\\n            if from_node in colors:\\n                continue\\n\\n            stack = [from_node]\\n            colors[from_node] = 1  # 1 is just starting color, could be -1 also\\n\\n            while stack:\\n                from_node = stack.pop()\\n\\n                for to_node in graph[from_node]:\\n                    if to_node in colors:\\n                        if colors[to_node] == colors[from_node]:\\n                            return False\\n                    else:\\n                        stack.append(to_node)                        \\n                        colors[to_node] = colors[from_node] * -1\\n        return True\\n```\n```\\n\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        colors = {}\\n        for node_from in range(len(graph)):\\n            if node_from not in colors and not self.dfs(graph, node_from, colors, 1):\\n                return False\\n\\n        return True\\n\\n    def dfs(self, graph, node, colors, color):\\n\\n        colors[node] = color\\n\\n        for node_to in graph[node]:\\n            if node_to in colors:\\n                if colors[node_to] == colors[node]:\\n                    return False\\n            else:\\n                if not self.dfs(graph, node_to, colors, color * -1):\\n                    return False\\n\\n        return True\\n```\n```\\n\\nfrom collections import deque\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n\\n        colors = {}\\n\\n        for from_node in range(len(graph)):\\n            if from_node in colors:\\n                continue\\n            queue = deque([from_node])\\n            colors[from_node] = 1 # 1 is just starting color, could be -1 also\\n\\n            while queue:\\n                from_node = queue.popleft()\\n                for to_node in graph[from_node]:\\n                    if to_node in colors:\\n                        if colors[to_node] == colors[from_node]:\\n                            return False\\n                    else:\\n                        queue.append(to_node)\\n                        colors[to_node] = colors[from_node] * -1\\n\\n        return True\\n```\n```\\nfrom collections import deque\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        colors = {}\\n        for node_from in range(len(graph)):\\n            if node_from not in colors and not self.bfs(graph, node_from, colors):\\n                return False\\n        return True\\n\\n    def bfs(self, graph, node, colors):\\n        queue = deque([node])\\n        colors[node] = 1\\n        while queue:\\n            node_from = queue.popleft()\\n            for node_to in graph[node_from]:\\n                if node_to in colors:\\n                    if colors[node_to] == colors[node_from]:\\n                        return False\\n                else:\\n                    colors[node_to] = colors[node_from] * -1\\n                    queue.append(node_to)\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 115492,
                "title": "java-dfs-two-colorability-o-n-easy-clean-illustrated-informally-proved",
                "content": "Try to color all nodes with alternating colors. If we came back to an already-colored node with a different color, then we return false. This is a typical application of DFS/BFS cycle detection described in Robert Sedgwick's *Algorithms (4th ed.)* book.\n```java\nclass Solution {\n    public boolean isBipartite(int[][] graph) {\n        int V = graph.length;\n        if (V <= 1)\n            return true;    // no illegal edges since no edges;\n        Boolean[] colors = new Boolean[V];\n        for (int i = 0; i < V; i++) if (colors[i] == null && !color (graph, colors, true, i))\n            return false;\n        return true;\n    }\n\n    boolean color (int[][] graph, Boolean[] colors, Boolean color, int node) {\n        if (colors[node] != null)\n            return colors[node] == color;\n        colors[node] = color;\n        color = !color;\n        int[] neighbors = graph[node];\n        for (int neighbor : neighbors) {\n            if (!color (graph, colors, color, neighbor))\n                return false;\n        }\n        return true;\n    }\n}\n```\nSlight explanation of correctness: why is it that we can be sure that as long as we have a cycle, where we try to color one node with a different color the second time, we know for sure the graph is bad? This is because the node just prior to the conflicting node must have the same color as the conflicting node itself. And as long as such a cycle exists, there is no way you can bipartite-partition all nodes within this cycle because, well, these two just won't do. What if there are no cycles? Well, cycle-free graphs are always bipartite.\n<img src=\"https://www.dropbox.com/s/6imsrxyqjl382gt/Screenshot%202018-02-17%2023.12.07.png?raw=1\" width=\"500\">\nMultiple DFS is required since the nodes might not be fully connected. Each DFS will color one independent subgraph. If one DFS discovers that one subgraph is okay, we can safely move on: it does not matter anymore because this subgraph and its consisting nodes won't further affect any other independent subgraph.",
                "solutionTags": [],
                "code": "```java\nclass Solution {\n    public boolean isBipartite(int[][] graph) {\n        int V = graph.length;\n        if (V <= 1)\n            return true;    // no illegal edges since no edges;\n        Boolean[] colors = new Boolean[V];\n        for (int i = 0; i < V; i++) if (colors[i] == null && !color (graph, colors, true, i))\n            return false;\n        return true;\n    }\n\n    boolean color (int[][] graph, Boolean[] colors, Boolean color, int node) {\n        if (colors[node] != null)\n            return colors[node] == color;\n        colors[node] = color;\n        color = !color;\n        int[] neighbors = graph[node];\n        for (int neighbor : neighbors) {\n            if (!color (graph, colors, color, neighbor))\n                return false;\n        }\n        return true;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540244,
                "title": "dfs-bfs-coloring",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        // {-1, 0, 1}\\n        // -1: uncoloured\\n        // 0: red\\n        // 1: blue\\n        vector<int> vis(n, -1); \\n        function<int(int,int)> dfs = [&](int u, int colour) -> int {\\n            // check if it is coloured or not\\n            if (vis[u] != -1) {\\n                // if the colour is same as previous one -> return 1\\n                if (vis[u] == (colour ^ 1)) return 1;\\n                // the colour is correct -> return 0 \\n                else return 0;\\n            }\\n            // set the colour\\n            vis[u] = colour;\\n            // iterate each neighbours\\n            for (auto& v : graph[u]) {\\n                // the expected colour for neighbours would be colour ^ 1\\n                // i.e. 0 -> 1 or 1 -> 0\\n                if (dfs(v, colour ^ 1)) {\\n                    return 1;\\n                }\\n            }\\n            return 0;\\n        };\\n        // iterate each node\\n        for (int i = 0; i < n; i++) {\\n            // check if it is coloured\\n            if (vis[i] == -1) {\\n                // if not, then colour it\\n                // set 0 by default\\n                if (dfs(i, 0)) {\\n                    // found neighbours also have the same colour\\n                    // then return 0 \\n                    return 0;\\n                }\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```\\n\\nSame Idea but using BFS\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<int> vis(n, -1);\\n        queue<int> q; \\n        for (int i = 0; i < n; i++) {\\n            if (vis[i] == -1) {\\n                vis[i] = 0;\\n                q.push(i);\\n                while (!q.empty()) {\\n                    int u = q.front(); q.pop();\\n                    for (int v : graph[u])  {\\n                        if (vis[v] == -1) { \\n                            vis[v] = vis[u] ^ 1; \\n                            q.push(v); \\n                        }  else if (vis[v] == vis[u]) {\\n                            return false;\\n                        }\\n                    }\\n                }\\n            } \\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n\\n**p.s. Join us on the LeetCode The Hard Way Discord Study Group for timely discussion! Link in bio.**",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        // {-1, 0, 1}\\n        // -1: uncoloured\\n        // 0: red\\n        // 1: blue\\n        vector<int> vis(n, -1); \\n        function<int(int,int)> dfs = [&](int u, int colour) -> int {\\n            // check if it is coloured or not\\n            if (vis[u] != -1) {\\n                // if the colour is same as previous one -> return 1\\n                if (vis[u] == (colour ^ 1)) return 1;\\n                // the colour is correct -> return 0 \\n                else return 0;\\n            }\\n            // set the colour\\n            vis[u] = colour;\\n            // iterate each neighbours\\n            for (auto& v : graph[u]) {\\n                // the expected colour for neighbours would be colour ^ 1\\n                // i.e. 0 -> 1 or 1 -> 0\\n                if (dfs(v, colour ^ 1)) {\\n                    return 1;\\n                }\\n            }\\n            return 0;\\n        };\\n        // iterate each node\\n        for (int i = 0; i < n; i++) {\\n            // check if it is coloured\\n            if (vis[i] == -1) {\\n                // if not, then colour it\\n                // set 0 by default\\n                if (dfs(i, 0)) {\\n                    // found neighbours also have the same colour\\n                    // then return 0 \\n                    return 0;\\n                }\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<int> vis(n, -1);\\n        queue<int> q; \\n        for (int i = 0; i < n; i++) {\\n            if (vis[i] == -1) {\\n                vis[i] = 0;\\n                q.push(i);\\n                while (!q.empty()) {\\n                    int u = q.front(); q.pop();\\n                    for (int v : graph[u])  {\\n                        if (vis[v] == -1) { \\n                            vis[v] = vis[u] ^ 1; \\n                            q.push(v); \\n                        }  else if (vis[v] == vis[u]) {\\n                            return false;\\n                        }\\n                    }\\n                }\\n            } \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990619,
                "title": "c-easy-solution-using-union-find",
                "content": "```\\n\\nclass Solution {\\npublic:\\n// using union find so we created two maps for storing parent and rank\\n    unordered_map<int,int> par;\\n    unordered_map<int,int> rank;\\n\\t// finding parent of nodes\\n    int find(int x)\\n    {\\n        if(par.find(x)==par.end())\\n        {\\n            par[x]=x;\\n            return x;\\n        }\\n        else if(par[x]!=x)\\n        {\\n            par[x] = find(par[x]);\\n        }\\n        return par[x];\\n    }\\n\\t// doing their union\\n    void uni(int x, int y)\\n    {\\n        int xp = find(x);\\n        int yp = find(y);\\n        if(xp==yp)\\n            return;\\n        if(rank[xp]<rank[yp])\\n        {\\n            par[xp] = yp;\\n        }\\n        else if(rank[xp]>rank[yp])\\n        {\\n            par[yp] = xp;\\n        }\\n        else\\n        {\\n            par[xp] = yp;\\n            rank[yp]++;\\n        }\\n        return;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<graph[i].size();j++)\\n            {\\n\\t\\t\\t// if parent node and current child node have same parent means they were reachable to someother node in the graph thus biparitite is not possible\\n                if(find(i)==find(graph[i][j]))\\n                {\\n                     return false;\\n                }\\n\\t\\t\\t\\t// create union of reachable nodes by parent node -- dont involve the parent node in the group\\n                uni(graph[i][j],graph[i][0]);\\n            }\\n        }\\n\\t\\t// if we didnt get same parent for a parent and child node then it means graph is completely bipartite\\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n// using union find so we created two maps for storing parent and rank\\n    unordered_map<int,int> par;\\n    unordered_map<int,int> rank;\\n\\t// finding parent of nodes\\n    int find(int x)\\n    {\\n        if(par.find(x)==par.end())\\n        {\\n            par[x]=x;\\n            return x;\\n        }\\n        else if(par[x]!=x)\\n        {\\n            par[x] = find(par[x]);\\n        }\\n        return par[x];\\n    }\\n\\t// doing their union\\n    void uni(int x, int y)\\n    {\\n        int xp = find(x);\\n        int yp = find(y);\\n        if(xp==yp)\\n            return;\\n        if(rank[xp]<rank[yp])\\n        {\\n            par[xp] = yp;\\n        }\\n        else if(rank[xp]>rank[yp])\\n        {\\n            par[yp] = xp;\\n        }\\n        else\\n        {\\n            par[xp] = yp;\\n            rank[yp]++;\\n        }\\n        return;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<graph[i].size();j++)\\n            {\\n\\t\\t\\t// if parent node and current child node have same parent means they were reachable to someother node in the graph thus biparitite is not possible\\n                if(find(i)==find(graph[i][j]))\\n                {\\n                     return false;\\n                }\\n\\t\\t\\t\\t// create union of reachable nodes by parent node -- dont involve the parent node in the group\\n                uni(graph[i][j],graph[i][0]);\\n            }\\n        }\\n\\t\\t// if we didnt get same parent for a parent and child node then it means graph is completely bipartite\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990538,
                "title": "clear-and-easy-commented-solution-of-dfs-bfs",
                "content": "***DFS***\\n```\\nclass Solution {\\n    int [] groups,adjList[];\\n    boolean completed[];//completed[i]=true indicates that dfs is already performed for index i \\n    public boolean isBipartite(int[][] graph) {\\n        int n=graph.length;\\n        groups=new int[n];\\n        completed=new boolean[n];\\n        adjList=graph;\\n        for(int i=0;i<n;i++)\\n            if(!completed[i]&&!dfs(i,1))//perform dfs only for i which is not yet added into any group\\n               return false;\\n        return true;\\n    }\\n    boolean dfs(int i,int group)\\n    {\\n        if(groups[i]==group) //if it is already in same group\\n            return true;\\n        if(groups[i]==-group)//if it was put in other group before(mismatch)\\n            return false;\\n        groups[i]=group;  //put it in this group and mark it completed(completed[i]=true)\\n        completed[i]=true;\\n        for(int j:adjList[i])\\n        {\\n            if(!dfs(j,-group))//since neighbors should be in different groups pass -group in dfs call\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n***BFS***\\n```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int length = graph.length;\\n        //maintain a colors array with the graph length\\n        int[] colors = new int[length];\\n        //fill the array with 0 (Not colored)\\n        Arrays.fill(colors, 0);\\n        //loop through the length of the graph\\n        for (int i= 0;i<length;i++){\\n            //process only if the color is 0, skip if its anything other than 0\\n            if (colors[i] == 0){\\n                //add to the q\\n                Queue<Integer> q = new LinkedList<>();\\n                q.offer(i);\\n                //set the color to 1 (Blue)\\n                colors[i] = 1;\\n                // loop until q is empty\\n                while (!q.isEmpty()){\\n                    int n = q.poll();\\n                    //for each element in the graph of i\\n                    for (int j: graph[n]){\\n                        //process only for 0 (Not colored)\\n                        if (colors[j] == 0){\\n                            //set the color to negative for the vertex j\\n                            colors[j] = -colors[n]; // -1 (Red) flip to opposite color\\n                            //add the vertex to the queue\\n                            q.offer(j);\\n                        }\\n                        // if the color of the vertex is a different color return false\\n                        else if(colors[j] != -colors[n]) return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int [] groups,adjList[];\\n    boolean completed[];//completed[i]=true indicates that dfs is already performed for index i \\n    public boolean isBipartite(int[][] graph) {\\n        int n=graph.length;\\n        groups=new int[n];\\n        completed=new boolean[n];\\n        adjList=graph;\\n        for(int i=0;i<n;i++)\\n            if(!completed[i]&&!dfs(i,1))//perform dfs only for i which is not yet added into any group\\n               return false;\\n        return true;\\n    }\\n    boolean dfs(int i,int group)\\n    {\\n        if(groups[i]==group) //if it is already in same group\\n            return true;\\n        if(groups[i]==-group)//if it was put in other group before(mismatch)\\n            return false;\\n        groups[i]=group;  //put it in this group and mark it completed(completed[i]=true)\\n        completed[i]=true;\\n        for(int j:adjList[i])\\n        {\\n            if(!dfs(j,-group))//since neighbors should be in different groups pass -group in dfs call\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int length = graph.length;\\n        //maintain a colors array with the graph length\\n        int[] colors = new int[length];\\n        //fill the array with 0 (Not colored)\\n        Arrays.fill(colors, 0);\\n        //loop through the length of the graph\\n        for (int i= 0;i<length;i++){\\n            //process only if the color is 0, skip if its anything other than 0\\n            if (colors[i] == 0){\\n                //add to the q\\n                Queue<Integer> q = new LinkedList<>();\\n                q.offer(i);\\n                //set the color to 1 (Blue)\\n                colors[i] = 1;\\n                // loop until q is empty\\n                while (!q.isEmpty()){\\n                    int n = q.poll();\\n                    //for each element in the graph of i\\n                    for (int j: graph[n]){\\n                        //process only for 0 (Not colored)\\n                        if (colors[j] == 0){\\n                            //set the color to negative for the vertex j\\n                            colors[j] = -colors[n]; // -1 (Red) flip to opposite color\\n                            //add the vertex to the queue\\n                            q.offer(j);\\n                        }\\n                        // if the color of the vertex is a different color return false\\n                        else if(colors[j] != -colors[n]) return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990404,
                "title": "c-dfs",
                "content": "dfs and keep track of what color we\\'ve colored every node.\\n\\nflip the color everytime we visit a node\\'s children\\n\\nif the colors dont match, it is not bipartite.\\n\\n**Solved live on stream.  I stream everyday 6pm PT.  Link in profile.**\\n\\n```\\nclass Solution {\\n    \\n    void dfs(vector<vector<int>>& graph, int x, int color, unordered_map<int, int>& colors, bool& ans) {\\n        if(!ans) return;\\n        if(colors.find(x) != colors.end()) {\\n            if(colors[x] != color) {\\n                ans = false;\\n            }\\n            return;\\n        }\\n        colors[x] = color;\\n        auto& children = graph[x];\\n        for(auto child : children) {\\n            dfs(graph, child, color^1, colors, ans);\\n        }\\n        \\n        return;\\n    }\\n    \\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        unordered_map<int, int> colors;\\n        bool ans = true;\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(colors.find(i) == colors.end()) {\\n                dfs(graph, i, 0, colors, ans);\\n                if(!ans) return ans;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    void dfs(vector<vector<int>>& graph, int x, int color, unordered_map<int, int>& colors, bool& ans) {\\n        if(!ans) return;\\n        if(colors.find(x) != colors.end()) {\\n            if(colors[x] != color) {\\n                ans = false;\\n            }\\n            return;\\n        }\\n        colors[x] = color;\\n        auto& children = graph[x];\\n        for(auto child : children) {\\n            dfs(graph, child, color^1, colors, ans);\\n        }\\n        \\n        return;\\n    }\\n    \\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        unordered_map<int, int> colors;\\n        bool ans = true;\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(colors.find(i) == colors.end()) {\\n                dfs(graph, i, 0, colors, ans);\\n                if(!ans) return ans;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629980,
                "title": "java-solution-with-custom-class",
                "content": "```\\nclass Solution {\\n    class Pair{\\n       int v;\\n       int level;\\n       \\n       Pair(int v ,int level){\\n           this.v=v;//for vertex\\n           this.level=level;\\n       }\\n   }\\n    \\n    public boolean isBipartite(int[][] graph) {\\n       ArrayList<Integer> [] graph1=new ArrayList[graph.length];\\n        for(int i =0;i<graph1.length;i++){\\n            graph1[i]=new ArrayList<>();\\n        }\\n       \\n        for(int i =0;i<graph.length;i++){\\n            for(int j =0;j<graph[i].length;j++){\\n                graph1[i].add(graph[i][j]);\\n            }\\n        }\\n        \\n        int [] visited=new int[graph1.length];\\n        Arrays.fill(visited,-1);\\n        \\n        for(int i =0;i<graph1.length;i++){\\n            if(visited[i]==-1){\\n                boolean res=checkComponentForBipartiteness(graph1,i,visited);\\n                if(res==false){\\n                    return false;//if result is false then it will return false\\n                }\\n            }\\n        }\\n        return true;\\n      \\n    }\\n    \\n     public boolean checkComponentForBipartiteness(ArrayList<Integer> [] graph1,int v,int [] visited){\\n      ArrayDeque <Pair> q=new ArrayDeque<>();\\n         q.addFirst(new Pair(v,0));//v-->vertex,0-->level\\n         while(q.size()!=0){\\n             Pair rem=q.remove();\\n             if(visited[rem.v]!=-1){\\n//                  that means it is visited and we have to make sure now the levels of that element which is currently visited and the one which has visited it before are not same.If not same then we will return false\\n                 if(visited[rem.v]!=rem.level){\\n                     return false;\\n                 }\\n                 \\n             }\\n             else{\\n                 visited[rem.v]=rem.level;\\n             }\\n             \\n             for(Integer e:graph1[rem.v]){\\n                 if(visited[e]==-1 ){// that means not visited \\n                     q.add(new Pair(e,rem.level+1));//adding its children(i.e. neighbour)\\n                 }\\n             }\\n         }\\n         return true;\\n   }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n       int v;\\n       int level;\\n       \\n       Pair(int v ,int level){\\n           this.v=v;//for vertex\\n           this.level=level;\\n       }\\n   }\\n    \\n    public boolean isBipartite(int[][] graph) {\\n       ArrayList<Integer> [] graph1=new ArrayList[graph.length];\\n        for(int i =0;i<graph1.length;i++){\\n            graph1[i]=new ArrayList<>();\\n        }\\n       \\n        for(int i =0;i<graph.length;i++){\\n            for(int j =0;j<graph[i].length;j++){\\n                graph1[i].add(graph[i][j]);\\n            }\\n        }\\n        \\n        int [] visited=new int[graph1.length];\\n        Arrays.fill(visited,-1);\\n        \\n        for(int i =0;i<graph1.length;i++){\\n            if(visited[i]==-1){\\n                boolean res=checkComponentForBipartiteness(graph1,i,visited);\\n                if(res==false){\\n                    return false;//if result is false then it will return false\\n                }\\n            }\\n        }\\n        return true;\\n      \\n    }\\n    \\n     public boolean checkComponentForBipartiteness(ArrayList<Integer> [] graph1,int v,int [] visited){\\n      ArrayDeque <Pair> q=new ArrayDeque<>();\\n         q.addFirst(new Pair(v,0));//v-->vertex,0-->level\\n         while(q.size()!=0){\\n             Pair rem=q.remove();\\n             if(visited[rem.v]!=-1){\\n//                  that means it is visited and we have to make sure now the levels of that element which is currently visited and the one which has visited it before are not same.If not same then we will return false\\n                 if(visited[rem.v]!=rem.level){\\n                     return false;\\n                 }\\n                 \\n             }\\n             else{\\n                 visited[rem.v]=rem.level;\\n             }\\n             \\n             for(Integer e:graph1[rem.v]){\\n                 if(visited[e]==-1 ){// that means not visited \\n                     q.add(new Pair(e,rem.level+1));//adding its children(i.e. neighbour)\\n                 }\\n             }\\n         }\\n         return true;\\n   }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 225867,
                "title": "python-straightforward-bfs",
                "content": "```\\nclass Solution:\\n    def isBipartite(self, graph):\\n        \"\"\"\\n        :type graph: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        party = [set(), set()]\\n        \\n        for node in range(len(graph)):\\n            if node not in party[0] and node not in party[1]:\\n                queue = collections.deque([(node, 0)])\\n                while queue:\\n                    node, p = queue.popleft()\\n                    for nei in graph[node]:\\n                        if nei in party[p]:\\n                            return False\\n                        elif nei not in party[1-p]:\\n                            party[1-p].add(nei)\\n                            queue.append((nei, 1-p))\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isBipartite(self, graph):\\n        \"\"\"\\n        :type graph: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        party = [set(), set()]\\n        \\n        for node in range(len(graph)):\\n            if node not in party[0] and node not in party[1]:\\n                queue = collections.deque([(node, 0)])\\n                while queue:\\n                    node, p = queue.popleft()\\n                    for nei in graph[node]:\\n                        if nei in party[p]:\\n                            return False\\n                        elif nei not in party[1-p]:\\n                            party[1-p].add(nei)\\n                            queue.append((nei, 1-p))\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 179117,
                "title": "c-concise-disjoint-set-solution-99",
                "content": "```c++\\nclass DisjointSet {\\nprivate:\\n    vector<int> parent;\\n    vector<int> rank;\\npublic:\\n    DisjointSet(int n) {\\n        parent = vector<int>(n);\\n        for (int i = 0; i < n; i++)\\n            parent[i] = i;\\n        rank = vector<int>(n, 1);\\n    }\\n    \\n    int findSet(int p) {\\n        int t = p;\\n        while (t != parent[t])\\n            t = parent[t];\\n        parent[p] = t;\\n        return t;\\n    }\\n    \\n    void unionSets(int a, int b) {\\n        int setA = findSet(a), setB = findSet(b);\\n        if (setA == setB)\\n            return;\\n        if (rank[setA] < rank[setB])\\n            swap(setA, setB);\\n        rank[setA] += rank[setB];\\n        parent[setB] = setA;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        if (!n)\\n            return 0;\\n        DisjointSet ds(n);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < graph[i].size(); j++) {\\n                if (ds.findSet(i) == ds.findSet(graph[i][j]))\\n                    return 0;\\n                if (j)\\n                    ds.unionSets(graph[i][j], graph[i][j - 1]);\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass DisjointSet {\\nprivate:\\n    vector<int> parent;\\n    vector<int> rank;\\npublic:\\n    DisjointSet(int n) {\\n        parent = vector<int>(n);\\n        for (int i = 0; i < n; i++)\\n            parent[i] = i;\\n        rank = vector<int>(n, 1);\\n    }\\n    \\n    int findSet(int p) {\\n        int t = p;\\n        while (t != parent[t])\\n            t = parent[t];\\n        parent[p] = t;\\n        return t;\\n    }\\n    \\n    void unionSets(int a, int b) {\\n        int setA = findSet(a), setB = findSet(b);\\n        if (setA == setB)\\n            return;\\n        if (rank[setA] < rank[setB])\\n            swap(setA, setB);\\n        rank[setA] += rank[setB];\\n        parent[setB] = setA;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        if (!n)\\n            return 0;\\n        DisjointSet ds(n);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < graph[i].size(); j++) {\\n                if (ds.findSet(i) == ds.findSet(graph[i][j]))\\n                    return 0;\\n                if (j)\\n                    ds.unionSets(graph[i][j], graph[i][j - 1]);\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065215,
                "title": "c-bfs-vs-dfs-solution-explained-100-time-95-space",
                "content": "Tough problem if you do not know graph theory that well (as it turns out it was my case, after a couple of wrong assumptions), more doable once you get the hang of it and it basically boils down to the approach I used with the double ended  BFS of [this other problem](https://leetcode.com/problems/shortest-path-in-binary-matrix/discuss/1063734/).\\n\\nTo solve this problem, you might think of colouring a starting node black (group A, if you wish) and all its direct neighbours white (group B); rinse and repeat with a BFS approach and if you meet any 2 adjacent nodes with the same colour, then you return `false`; when you finished going through all the connected nodes and no such occurrence ever happened, you can return `true`.\\n\\nNow, consider that you cannot know in advance which node is okay to test, so you need to start exploring the graph from each node, in order to ascertain that you can build 2 separate groups from each one of them.\\n\\nWhich is what we do in our code: in our main function, we will invoke `exploreFromNode` from each node from `0` up to the size of `graph` and return `false` if that helper function returns `false` too.\\n\\n`exploreFromNode` will take 2 parametrs - our initial input `graph` and `startNode`, then declare a few support variables:\\n* `colours` is an array of integers, initially all set to `0`;\\n* `len` will measure the length of our queue, initially set to `1` since we will always have at least one element in;\\n* `currNode` will help up parse the nodes during our BFS routine;\\n* the boolean `isGroupA` will tell us which colour we are using at each round - initially set to `true`;\\n* `q` is our queue of integers, backbone of our BFS approach.\\n\\nWe will then initialise the process adding `startNode` to `q` and marking it as black (`1`) in `colours`.\\n\\nTime to start with our actual BFS! We will loop as long as we have elements in the queue (ie: `len > 0`) and, internally:\\n* have another loop that will run `len` times to parse the current level of our BFS and:\\n\\t* extract the front of the queue and assign its value to `currNode`;\\n\\t* pop it from the queue;\\n\\t* for all the neighbours `n` of `currNode`, as they are provided in `graph[currNode]`, we will:\\n\\t\\t* check if already visited (ie: `colours[n] != 0`) and if so:\\n\\t\\t\\t* check if said neighbour `n` has the same colour of the current node - if so we return `false`;\\n\\t\\t* otherwise, we mark is as visited with the opposite colour and push it into `q` for the next iteration;\\n* prepare for the next loop, updating `len` and flipping `isGroupA`.\\n\\nOnce done, if we are out of this loop, we can conclude that you can bisect the graph starting from that node, so we retur `true` :)\\n\\nOnce we are done looping through all the possible entry points in our graph, we can confidently return `true` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\nprivate:\\n    bool exploreFromNode(vector<vector<int>>& graph, int startNode = 0) {\\n        // support variables\\n        int colours[100] = {}, len = 1, currNode;\\n        bool isGroupA = true;\\n        queue<int> q;\\n        // adding and marking the start node\\n        q.push(startNode);\\n        colours[startNode] = 1;\\n        while (len) {\\n            while(len--) {\\n                // extracting and popping the next element of the queue\\n                currNode = q.front();\\n                q.pop();\\n                // parsing all its neighbours\\n                for (int n: graph[currNode]) {\\n                    // checking if we already visited neighbour n\\n                    if (colours[n]) {\\n                        // if it is the same colour as the current one, we return false\\n                        if (colours[n] == (isGroupA ? 1 : -1)) return false;\\n                    }\\n                    // if not, we mark and push it in our queue\\n                    else {\\n                        colours[n] = isGroupA ? -1 : 1;\\n                        q.push(n);\\n                    }\\n                }\\n            }\\n            // preparing for the next loop\\n            len = q.size();\\n            isGroupA = !isGroupA;\\n        }\\n        return true;\\n    }\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        for (int i = 0, lmt = graph.size(); i < lmt; i++) {\\n            if (!exploreFromNode(graph, i)) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\nVery similar logic with a backtracking DFS approach, working per se, but sadly TLEing with larger graphs:\\n\\n```cpp\\nclass Solution {\\nprivate:\\n    int colours[100] = {};\\n    bool exploreFromNode(vector<vector<int>>& graph, int startNode = 0, bool isGroupA = true) {\\n        // marking the start node\\n        colours[startNode] = isGroupA ? 1 : -1;\\n        // parsing all of startNode neighbours\\n        for (int n: graph[startNode]) {\\n            // checking if we already visited neighbour n\\n            if (colours[n]) {\\n                // if it is the same colour as the current one, we return false\\n                if (colours[n] == (isGroupA ? 1 : -1)) return false;\\n            }\\n            // if not, we recurse from it\\n            else {\\n                if (!exploreFromNode(graph, n, !isGroupA)) return false;\\n            }\\n        }\\n        // backtracking startNode marking\\n        colours[startNode] = 0;\\n        return true;\\n    }\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        for (int i = 0, lmt = graph.size(); i < lmt; i++) {\\n            if (!exploreFromNode(graph, i)) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\nThe solution?\\n\\nTo remove the backtracking feature and stop checking nodes more than once; it works blazingly fast (8ms) and with much less memory (~95% vs. ~20% with a BFS):\\n\\n```cpp\\nclass Solution {\\nprivate:\\n    int colours[100] = {};\\n    bool exploreFromNode(vector<vector<int>>& graph, int startNode = 0, bool isGroupA = true) {\\n        // marking the start node\\n        colours[startNode] = isGroupA ? 1 : -1;\\n        // parsing all of startNode neighbours\\n        for (int n: graph[startNode]) {\\n            // checking if we already visited neighbour n\\n            if (colours[n]) {\\n                // if it is the same colour as the current one, we return false\\n                if (colours[n] == (isGroupA ? 1 : -1)) return false;\\n            }\\n            // if not, we recurse from it\\n            else {\\n                if (!exploreFromNode(graph, n, !isGroupA)) return false;\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        for (int i = 0, lmt = graph.size(); i < lmt; i++) {\\n            // checking unexplored nodes only for bipartition\\n            if (!colours[i] && !exploreFromNode(graph, i)) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\nTurns out the same fine tuned logic could improve also my BFS approach, soooo... Here it is:\\n\\n```cpp\\nclass Solution {\\nprivate:\\n    int colours[100] = {};\\n    bool exploreFromNode(vector<vector<int>>& graph, int startNode = 0) {\\n        // support variables\\n        int len = 1, currNode;\\n        bool isGroupA = true;\\n        queue<int> q;\\n        // adding and marking the start node\\n        q.push(startNode);\\n        colours[startNode] = 1;\\n        while (len) {\\n            while(len--) {\\n                // extracting and popping the next element of the queue\\n                currNode = q.front();\\n                q.pop();\\n                // parsing all its neighbours\\n                for (int n: graph[currNode]) {\\n                    // checking if we already visited neighbour n\\n                    if (colours[n]) {\\n                        // if it is the same colour as the current one, we return false\\n                        if (colours[n] == (isGroupA ? 1 : -1)) return false;\\n                    }\\n                    // if not, we mark and push it in our queue\\n                    else {\\n                        colours[n] = isGroupA ? -1 : 1;\\n                        q.push(n);\\n                    }\\n                }\\n            }\\n            // preparing for the next loop\\n            len = q.size();\\n            isGroupA = !isGroupA;\\n        }\\n        return true;\\n    }\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        for (int i = 0, lmt = graph.size(); i < lmt; i++) {\\n            // checking unexplored nodes only for bipartition\\n            if (!colours[i] && !exploreFromNode(graph, i)) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```cpp\\nclass Solution {\\nprivate:\\n    bool exploreFromNode(vector<vector<int>>& graph, int startNode = 0) {\\n        // support variables\\n        int colours[100] = {}, len = 1, currNode;\\n        bool isGroupA = true;\\n        queue<int> q;\\n        // adding and marking the start node\\n        q.push(startNode);\\n        colours[startNode] = 1;\\n        while (len) {\\n            while(len--) {\\n                // extracting and popping the next element of the queue\\n                currNode = q.front();\\n                q.pop();\\n                // parsing all its neighbours\\n                for (int n: graph[currNode]) {\\n                    // checking if we already visited neighbour n\\n                    if (colours[n]) {\\n                        // if it is the same colour as the current one, we return false\\n                        if (colours[n] == (isGroupA ? 1 : -1)) return false;\\n                    }\\n                    // if not, we mark and push it in our queue\\n                    else {\\n                        colours[n] = isGroupA ? -1 : 1;\\n                        q.push(n);\\n                    }\\n                }\\n            }\\n            // preparing for the next loop\\n            len = q.size();\\n            isGroupA = !isGroupA;\\n        }\\n        return true;\\n    }\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        for (int i = 0, lmt = graph.size(); i < lmt; i++) {\\n            if (!exploreFromNode(graph, i)) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\nprivate:\\n    int colours[100] = {};\\n    bool exploreFromNode(vector<vector<int>>& graph, int startNode = 0, bool isGroupA = true) {\\n        // marking the start node\\n        colours[startNode] = isGroupA ? 1 : -1;\\n        // parsing all of startNode neighbours\\n        for (int n: graph[startNode]) {\\n            // checking if we already visited neighbour n\\n            if (colours[n]) {\\n                // if it is the same colour as the current one, we return false\\n                if (colours[n] == (isGroupA ? 1 : -1)) return false;\\n            }\\n            // if not, we recurse from it\\n            else {\\n                if (!exploreFromNode(graph, n, !isGroupA)) return false;\\n            }\\n        }\\n        // backtracking startNode marking\\n        colours[startNode] = 0;\\n        return true;\\n    }\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        for (int i = 0, lmt = graph.size(); i < lmt; i++) {\\n            if (!exploreFromNode(graph, i)) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\nprivate:\\n    int colours[100] = {};\\n    bool exploreFromNode(vector<vector<int>>& graph, int startNode = 0, bool isGroupA = true) {\\n        // marking the start node\\n        colours[startNode] = isGroupA ? 1 : -1;\\n        // parsing all of startNode neighbours\\n        for (int n: graph[startNode]) {\\n            // checking if we already visited neighbour n\\n            if (colours[n]) {\\n                // if it is the same colour as the current one, we return false\\n                if (colours[n] == (isGroupA ? 1 : -1)) return false;\\n            }\\n            // if not, we recurse from it\\n            else {\\n                if (!exploreFromNode(graph, n, !isGroupA)) return false;\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        for (int i = 0, lmt = graph.size(); i < lmt; i++) {\\n            // checking unexplored nodes only for bipartition\\n            if (!colours[i] && !exploreFromNode(graph, i)) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\nprivate:\\n    int colours[100] = {};\\n    bool exploreFromNode(vector<vector<int>>& graph, int startNode = 0) {\\n        // support variables\\n        int len = 1, currNode;\\n        bool isGroupA = true;\\n        queue<int> q;\\n        // adding and marking the start node\\n        q.push(startNode);\\n        colours[startNode] = 1;\\n        while (len) {\\n            while(len--) {\\n                // extracting and popping the next element of the queue\\n                currNode = q.front();\\n                q.pop();\\n                // parsing all its neighbours\\n                for (int n: graph[currNode]) {\\n                    // checking if we already visited neighbour n\\n                    if (colours[n]) {\\n                        // if it is the same colour as the current one, we return false\\n                        if (colours[n] == (isGroupA ? 1 : -1)) return false;\\n                    }\\n                    // if not, we mark and push it in our queue\\n                    else {\\n                        colours[n] = isGroupA ? -1 : 1;\\n                        q.push(n);\\n                    }\\n                }\\n            }\\n            // preparing for the next loop\\n            len = q.size();\\n            isGroupA = !isGroupA;\\n        }\\n        return true;\\n    }\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        for (int i = 0, lmt = graph.size(); i < lmt; i++) {\\n            // checking unexplored nodes only for bipartition\\n            if (!colours[i] && !exploreFromNode(graph, i)) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 640326,
                "title": "python-dfs-bfs-using-graph-coloring",
                "content": "The problem can be translated into graph (two-)coloring problem.\\n### DFS solution\\n```\\ndef isBipartite(self, graph: List[List[int]]) -> bool:\\n\\tdef dfs_color(i):\\n\\t\\tfor nb in graph[i]:\\n\\t\\t\\tif nb in color:\\n\\t\\t\\t\\tif color[nb] == color[i]:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcolor[nb] = 1 - color[i]\\n\\t\\t\\t\\tif not dfs_color(nb):\\n\\t\\t\\t\\t\\treturn False\\n\\t\\treturn True\\n\\tcolor = {}\\n\\tfor i in range(len(graph)):\\n\\t\\tif i not in color:\\n\\t\\t\\tcolor[i] = 0\\n\\t\\t\\tif not dfs_color(i):\\n\\t\\t\\t\\treturn False\\n\\treturn True\\n```\\n### BFS solution\\n```\\ndef isBipartite(self, graph: List[List[int]]) -> bool:\\n\\tfrom collections import deque\\n\\tqueue = deque()\\n\\tcolor = {}\\n\\tfor i in range(len(graph)):\\n\\t\\tif i not in color:\\n\\t\\t\\tcolor[i] = 0\\n\\t\\t\\tqueue.append(i)\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\tnode = queue.popleft()\\n\\t\\t\\t\\tfor nb in graph[node]:\\n\\t\\t\\t\\t\\tif nb in color:\\n\\t\\t\\t\\t\\t\\tif color[nb] == color[node]:\\n\\t\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tcolor[nb] = 1 - color[node]\\n\\t\\t\\t\\t\\t\\tqueue.append(nb)\\n\\treturn True\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef isBipartite(self, graph: List[List[int]]) -> bool:\\n\\tdef dfs_color(i):\\n\\t\\tfor nb in graph[i]:\\n\\t\\t\\tif nb in color:\\n\\t\\t\\t\\tif color[nb] == color[i]:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcolor[nb] = 1 - color[i]\\n\\t\\t\\t\\tif not dfs_color(nb):\\n\\t\\t\\t\\t\\treturn False\\n\\t\\treturn True\\n\\tcolor = {}\\n\\tfor i in range(len(graph)):\\n\\t\\tif i not in color:\\n\\t\\t\\tcolor[i] = 0\\n\\t\\t\\tif not dfs_color(i):\\n\\t\\t\\t\\treturn False\\n\\treturn True\\n```\n```\\ndef isBipartite(self, graph: List[List[int]]) -> bool:\\n\\tfrom collections import deque\\n\\tqueue = deque()\\n\\tcolor = {}\\n\\tfor i in range(len(graph)):\\n\\t\\tif i not in color:\\n\\t\\t\\tcolor[i] = 0\\n\\t\\t\\tqueue.append(i)\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\tnode = queue.popleft()\\n\\t\\t\\t\\tfor nb in graph[node]:\\n\\t\\t\\t\\t\\tif nb in color:\\n\\t\\t\\t\\t\\t\\tif color[nb] == color[node]:\\n\\t\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tcolor[nb] = 1 - color[node]\\n\\t\\t\\t\\t\\t\\tqueue.append(nb)\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 556542,
                "title": "3-ways-union-find-dfs-bfs-java",
                "content": "```\\nclass Solution {\\n    //DFS\\n    public boolean isBipartite(int[][] graph) {\\n        int nodes = graph.length;\\n        int[] color = new int[nodes];\\n        for(int i=0; i<nodes; i++){\\n            if(color[i]==0 && !dfs(i, color, 1, graph)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private boolean dfs(int n, int[] color, int c, int[][] graph){\\n        if(color[n]!=0 && color[n]!=c){\\n            return false;\\n        }\\n        if(color[n]!=0 && color[n]==c){\\n            return true;\\n        }\\n        color[n] = c;\\n        for(int nei: graph[n]){\\n            if(!dfs(nei, color, -1*c, graph)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    // Union Find - union all nodes connected a single node. Check if both nodes of an edge have same parent\\n    public boolean isBipartiteUnionFind(int[][] graph) {\\n        UnionFind uf = new UnionFind(graph.length);\\n        for (int i=0; i<graph.length; i++) {\\n            int[] adjs = graph[i];\\n            for (int j=0; j<adjs.length; j++) {\\n                if (uf.find(i) == uf.find(adjs[j])) return false;   //both vertices of edge in same set\\n                uf.union(adjs[0], adjs[j]); // put all edges of a vertex in a single set\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    class UnionFind {\\n        int[] parent;\\n        int[] rank;\\n        UnionFind(int n) {\\n            parent = new int[n];\\n            rank = new int[n];\\n            for (int i=0; i<n; i++) {\\n                parent[i] = i;\\n            }\\n        }\\n        \\n        int find(int i) {\\n            if (parent[i] == i) {\\n                return parent[i];\\n            }\\n            parent[i] = find(parent[i]);\\n            return parent[i];\\n        }\\n        \\n        void union(int i, int j) {\\n            int parentI = find(i);\\n            int parentJ = find(j);\\n            if (parentI < parentJ) {\\n                parent[parentI] = parentJ;\\n                rank[parentI]++;\\n            }\\n            else{\\n                parent[parentJ] = parentI;\\n                rank[parentJ]++;\\n            }\\n        }\\n    }\\n    \\n    //BFS\\n    public boolean isBipartiteBFS(int[][] graph) {\\n        //BFS\\n        // 0(not visited), 1(black), 2(white)\\n        int[] color = new int[graph.length];\\n        \\n        for (int i = 0; i < graph.length; i++) {\\n            if (graph[i].length != 0 && color[i] == 0) {\\n                color[i] = 1;\\n                Queue<Integer> q = new LinkedList<>();\\n                q.offer(i);\\n                while(! q.isEmpty()) {\\n                    int current = q.poll();\\n                    for (int c: graph[current]) {\\n\\n                            if (color[c] == 0) {\\n                                color[c] = (color[current] == 1) ? 2 : 1;\\n                                q.offer(c);\\n                            } else {\\n                                if (color[c] == color[current]) return false;\\n                            }\\n                    }\\n                }                        \\n                \\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    //DFS\\n    public boolean isBipartite(int[][] graph) {\\n        int nodes = graph.length;\\n        int[] color = new int[nodes];\\n        for(int i=0; i<nodes; i++){\\n            if(color[i]==0 && !dfs(i, color, 1, graph)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private boolean dfs(int n, int[] color, int c, int[][] graph){\\n        if(color[n]!=0 && color[n]!=c){\\n            return false;\\n        }\\n        if(color[n]!=0 && color[n]==c){\\n            return true;\\n        }\\n        color[n] = c;\\n        for(int nei: graph[n]){\\n            if(!dfs(nei, color, -1*c, graph)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    // Union Find - union all nodes connected a single node. Check if both nodes of an edge have same parent\\n    public boolean isBipartiteUnionFind(int[][] graph) {\\n        UnionFind uf = new UnionFind(graph.length);\\n        for (int i=0; i<graph.length; i++) {\\n            int[] adjs = graph[i];\\n            for (int j=0; j<adjs.length; j++) {\\n                if (uf.find(i) == uf.find(adjs[j])) return false;   //both vertices of edge in same set\\n                uf.union(adjs[0], adjs[j]); // put all edges of a vertex in a single set\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    class UnionFind {\\n        int[] parent;\\n        int[] rank;\\n        UnionFind(int n) {\\n            parent = new int[n];\\n            rank = new int[n];\\n            for (int i=0; i<n; i++) {\\n                parent[i] = i;\\n            }\\n        }\\n        \\n        int find(int i) {\\n            if (parent[i] == i) {\\n                return parent[i];\\n            }\\n            parent[i] = find(parent[i]);\\n            return parent[i];\\n        }\\n        \\n        void union(int i, int j) {\\n            int parentI = find(i);\\n            int parentJ = find(j);\\n            if (parentI < parentJ) {\\n                parent[parentI] = parentJ;\\n                rank[parentI]++;\\n            }\\n            else{\\n                parent[parentJ] = parentI;\\n                rank[parentJ]++;\\n            }\\n        }\\n    }\\n    \\n    //BFS\\n    public boolean isBipartiteBFS(int[][] graph) {\\n        //BFS\\n        // 0(not visited), 1(black), 2(white)\\n        int[] color = new int[graph.length];\\n        \\n        for (int i = 0; i < graph.length; i++) {\\n            if (graph[i].length != 0 && color[i] == 0) {\\n                color[i] = 1;\\n                Queue<Integer> q = new LinkedList<>();\\n                q.offer(i);\\n                while(! q.isEmpty()) {\\n                    int current = q.poll();\\n                    for (int c: graph[current]) {\\n\\n                            if (color[c] == 0) {\\n                                color[c] = (color[current] == 1) ? 2 : 1;\\n                                q.offer(c);\\n                            } else {\\n                                if (color[c] == color[current]) return false;\\n                            }\\n                    }\\n                }                        \\n                \\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359217,
                "title": "both-easiest-bfs-dfs-approach-bipartite-graph-coloring-100-faster",
                "content": "**Approach-1 : BFS**\\n```\\n// Simple Definition of Bipartite : \\n// Acyclic - yes bipartite\\n// Cyclic - even length (yes bipartite)\\n// Cyclic - odd length (Not bipartite)\\nclass Solution {\\npublic:\\n    \\n    bool BFS(int i, vector<vector<int>>&g, vector<int>&color) \\n    {\\n        int n=g.size(); // no. of nodes\\n        \\n        queue<int>q;\\n        q.push(i);\\n        \\n        while(!q.empty())\\n        {\\n            auto cur = q.front();\\n            q.pop();\\n            \\n            for(auto &nbr : g[cur])\\n            {\\n                if(color[nbr]==-1)\\n                {\\n                    color[nbr] = color[cur] ? 0 : 1;\\n                    q.push(nbr);\\n                }\\n                else if(color[nbr] == color[cur])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool isBipartite(vector<vector<int>>&g) \\n    {\\n        int n=g.size(); // no. of nodes\\n        vector<int>color(n,-1);\\n        \\n        // The graph may not be connected, meaning there may be two nodes u and v such that there \\n        // is no path between them.\\n        for(int i=0;i<n;i++){\\n            \\n            if(color[i]==-1)\\n            {\\n                if(BFS(i,g,color)==false){ // check for all the components of graph\\n                    return false;\\n                }\\n            }   \\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n----\\n**Approach-2 : DFS**\\n```\\nclass Solution {\\npublic:\\n    \\n    bool DFS(int cur, vector<vector<int>>&g, vector<int>&color) \\n    {\\n        if(color[cur]==-1) color[cur] = 1;\\n        \\n        for(auto &nbr : g[cur])\\n        {\\n            if(color[nbr]==-1)\\n            {\\n                color[nbr] = 1-color[cur];\\n                if(DFS(nbr,g,color)==false)\\n                    return false;\\n            }\\n            else if(color[nbr] == color[cur])\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    bool isBipartite(vector<vector<int>>&g) \\n    {\\n        int n=g.size(); // no. of nodes\\n        vector<int>color(n,-1);\\n\\n        // The graph may not be connected, meaning there may be two nodes u and v such that there \\n        // is no path between them.\\n        for(int i=0;i<n;i++){\\n\\n            if(color[i]==-1)\\n            {\\n                if(DFS(i,g,color)==false){ // check for all the components of graph\\n                    return false;\\n                }\\n            }   \\n        }\\n        return true;\\n    }\\n};\\n```\\n***Thanks for Upvoting !***\\n\\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n// Simple Definition of Bipartite : \\n// Acyclic - yes bipartite\\n// Cyclic - even length (yes bipartite)\\n// Cyclic - odd length (Not bipartite)\\nclass Solution {\\npublic:\\n    \\n    bool BFS(int i, vector<vector<int>>&g, vector<int>&color) \\n    {\\n        int n=g.size(); // no. of nodes\\n        \\n        queue<int>q;\\n        q.push(i);\\n        \\n        while(!q.empty())\\n        {\\n            auto cur = q.front();\\n            q.pop();\\n            \\n            for(auto &nbr : g[cur])\\n            {\\n                if(color[nbr]==-1)\\n                {\\n                    color[nbr] = color[cur] ? 0 : 1;\\n                    q.push(nbr);\\n                }\\n                else if(color[nbr] == color[cur])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool isBipartite(vector<vector<int>>&g) \\n    {\\n        int n=g.size(); // no. of nodes\\n        vector<int>color(n,-1);\\n        \\n        // The graph may not be connected, meaning there may be two nodes u and v such that there \\n        // is no path between them.\\n        for(int i=0;i<n;i++){\\n            \\n            if(color[i]==-1)\\n            {\\n                if(BFS(i,g,color)==false){ // check for all the components of graph\\n                    return false;\\n                }\\n            }   \\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool DFS(int cur, vector<vector<int>>&g, vector<int>&color) \\n    {\\n        if(color[cur]==-1) color[cur] = 1;\\n        \\n        for(auto &nbr : g[cur])\\n        {\\n            if(color[nbr]==-1)\\n            {\\n                color[nbr] = 1-color[cur];\\n                if(DFS(nbr,g,color)==false)\\n                    return false;\\n            }\\n            else if(color[nbr] == color[cur])\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    bool isBipartite(vector<vector<int>>&g) \\n    {\\n        int n=g.size(); // no. of nodes\\n        vector<int>color(n,-1);\\n\\n        // The graph may not be connected, meaning there may be two nodes u and v such that there \\n        // is no path between them.\\n        for(int i=0;i<n;i++){\\n\\n            if(color[i]==-1)\\n            {\\n                if(DFS(i,g,color)==false){ // check for all the components of graph\\n                    return false;\\n                }\\n            }   \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164560,
                "title": "python-well-explained-bfs-solution-with-comments",
                "content": "```\\n\\'\\'\\'\\nA graph is bipartite if the nodes can be partitioned into two independent sets A and B such that \\nall the edges are connected across A and B. If there is a edge within A or B then that graph is Not bipartite.\\n            0\\n          /   \\\\\\n         1     2\\n         |     |\\n         3-----4\\nA = {0, 3, 4}; B = {1, 2}    => node 3 and 4 are connected within set A. so not bipartite\\n\\n1. All acyclic graphs are Bipartite.\\n2. Cyclic graph of elven length is Bipartite.\\n3. Acyclic graph of odd lenght is Not Bipartite.\\n\\nTo find cyclic and acyclic we will keep a dictionay with key as node and value as it\\'s colour. \\nIf current node is seen previously and it\\'s previous colour is different then it is a cyclic graph with Odd lenght.\\n\\'\\'\\'\\n\\nimport collections\\n\\nclass Solution:\\n    def isBipartite(self, graph):\\n        seen = {}  # dictionay with key as node and value as it\\'s colour\\n        \\n        for node in range(len(graph)):          # graph may have different disjoint components\\n            if node not in seen:\\n                q = collections.deque([(node, 1)])\\n                while q:\\n                    node, color = q.popleft()\\n                    \\n                    if node in seen:            # graph is cyclic\\n                        if seen[node] == color: # previour color is same as current color\\n                            continue            # cyclic graph with EVEN length\\n                        else:                   # previour color diffrent with current color\\n                            return False        # cyclic graph with ODD length\\n                    \\n                    seen[node] = color\\n                    # store neighbors nodes with opposit color\\n                    for nei in graph[node]:\\n                        q.append((nei, color * (-1)))\\n\\n        return True  \\n    \\n\\n# Time = number of nodes + number of edges\\n# Time: O(n) + O(n)\\n# Space: O(n) + o(n)  \\n# Auxiliary Space: O(n)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Graph",
                    "Iterator"
                ],
                "code": "```\\n\\'\\'\\'\\nA graph is bipartite if the nodes can be partitioned into two independent sets A and B such that \\nall the edges are connected across A and B. If there is a edge within A or B then that graph is Not bipartite.\\n            0\\n          /   \\\\\\n         1     2\\n         |     |\\n         3-----4\\nA = {0, 3, 4}; B = {1, 2}    => node 3 and 4 are connected within set A. so not bipartite\\n\\n1. All acyclic graphs are Bipartite.\\n2. Cyclic graph of elven length is Bipartite.\\n3. Acyclic graph of odd lenght is Not Bipartite.\\n\\nTo find cyclic and acyclic we will keep a dictionay with key as node and value as it\\'s colour. \\nIf current node is seen previously and it\\'s previous colour is different then it is a cyclic graph with Odd lenght.\\n\\'\\'\\'\\n\\nimport collections\\n\\nclass Solution:\\n    def isBipartite(self, graph):\\n        seen = {}  # dictionay with key as node and value as it\\'s colour\\n        \\n        for node in range(len(graph)):          # graph may have different disjoint components\\n            if node not in seen:\\n                q = collections.deque([(node, 1)])\\n                while q:\\n                    node, color = q.popleft()\\n                    \\n                    if node in seen:            # graph is cyclic\\n                        if seen[node] == color: # previour color is same as current color\\n                            continue            # cyclic graph with EVEN length\\n                        else:                   # previour color diffrent with current color\\n                            return False        # cyclic graph with ODD length\\n                    \\n                    seen[node] = color\\n                    # store neighbors nodes with opposit color\\n                    for nei in graph[node]:\\n                        q.append((nei, color * (-1)))\\n\\n        return True  \\n    \\n\\n# Time = number of nodes + number of edges\\n# Time: O(n) + O(n)\\n# Space: O(n) + o(n)  \\n# Auxiliary Space: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1608826,
                "title": "java-union-find-solution-with-comments",
                "content": "Apart from BFS, DFSthis problem can also be solved using union find. The idea here is if we are visiting a node we will check if any of it\\'s adjecent is in same set i.e parent of current node is equivalent to parent of any of it\\'s adjecent node then graph is not bipartite. If both are not in the same set then we will try to put all of it\\'s adjecent node in same set( taking union) and continue.\\n\\n```\\nclass Solution {\\n    int[] parent;\\n    int[] rank;\\n\\t\\n//find parent for a node\\n    public int findParent(int u){\\n        if(u==parent[u])\\n            return u;\\n        return parent[u] = findParent(parent[u]);\\n    }\\n\\n//union of two nodes\\n    public void union(int u, int v){\\n        u = findParent(u);\\n        v = findParent(v);\\n        if(u==v)\\n            return;\\n        if(rank[u]>rank[v]){\\n            parent[v]=u;\\n        }else if(rank[u]<rank[v]){\\n            parent[u]=v;\\n        }else{\\n            parent[u] = v;\\n            rank[v]++;\\n        }\\n    }\\n\\n    public boolean isBipartite(int[][] graph) {\\n        int n = graph.length;\\n        parent = new int[n];\\n        rank = new int[n];\\n\\t\\t\\n\\t\\t//initializing parent of a node to it\\'s own\\n        for(int i=0; i<n; i++)\\n            parent[i]=i;\\n\\n        for(int i=0; i<n; i++){\\n\\t\\t\\n            int u = findParent(i);                   //current node parent\\n            for(int j=0; j<graph[i].length; j++){\\n                int v = findParent(graph[i][j]);\\t//adjecent node parent\\n                if(u==v)                           // checking if both are in same set i.e can they be color with different color or not\\n                    return false;\\n                union(graph[i][0], graph[i][j]);   // taking union of all the nodes which are adjecent to current node\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n```\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    int[] parent;\\n    int[] rank;\\n\\t\\n//find parent for a node\\n    public int findParent(int u){\\n        if(u==parent[u])\\n            return u;\\n        return parent[u] = findParent(parent[u]);\\n    }\\n\\n//union of two nodes\\n    public void union(int u, int v){\\n        u = findParent(u);\\n        v = findParent(v);\\n        if(u==v)\\n            return;\\n        if(rank[u]>rank[v]){\\n            parent[v]=u;\\n        }else if(rank[u]<rank[v]){\\n            parent[u]=v;\\n        }else{\\n            parent[u] = v;\\n            rank[v]++;\\n        }\\n    }\\n\\n    public boolean isBipartite(int[][] graph) {\\n        int n = graph.length;\\n        parent = new int[n];\\n        rank = new int[n];\\n\\t\\t\\n\\t\\t//initializing parent of a node to it\\'s own\\n        for(int i=0; i<n; i++)\\n            parent[i]=i;\\n\\n        for(int i=0; i<n; i++){\\n\\t\\t\\n            int u = findParent(i);                   //current node parent\\n            for(int j=0; j<graph[i].length; j++){\\n                int v = findParent(graph[i][j]);\\t//adjecent node parent\\n                if(u==v)                           // checking if both are in same set i.e can they be color with different color or not\\n                    return false;\\n                union(graph[i][0], graph[i][j]);   // taking union of all the nodes which are adjecent to current node\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550526,
                "title": "c-easy-solution-dfs-time-o-n-e-space-o-n-e-o-n-o-n",
                "content": "# DFS\\nTIME:-O(N+E)\\nSPACE:-O(N+E) {for storing the graph} +O(N) {for Color array } + O(N) {for Auxiliary space}\\n```\\n class Solution {\\npublic:\\n    bool isBipartiteDFS(int src,vector<vector<int>>& graph,vector<int>& color)\\n    {\\n        if(color[src]==-1)\\n        {\\n            color[src]=1;   \\n        }\\n        for(auto it:graph[src])\\n        {\\n          if(color[it]==-1)\\n           {\\n                color[it]=1-color[src];\\n             if(!isBipartiteDFS(it,graph,color))\\n              {\\n                return false;\\n               }\\n            }\\n            else if(color[it]==color[src])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        vector<int> color(n,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(color[i]==-1)\\n            {\\n                if(!isBipartiteDFS(i,graph,color))\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isBipartiteDFS(int src,vector<vector<int>>& graph,vector<int>& color)\\n    {\\n        if(color[src]==-1)\\n        {\\n            color[src]=1;   \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1133053,
                "title": "clear-comments-dfs-solution-java",
                "content": "IDEA -> when we connect all the elements of graph, if there is a odd numbered cycle then it is not a bipartite graph. Using this analogy, we use 2 colors, where for each node if the adjecent nodes are of different color (even numbered cycle) then its bipartite else it is not.\\n\\nColors:\\n0 -> uncolored\\n1 -> red\\n-1 -> blue\\n\\n```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        // Array representing the colors\\n        int[] colors = new int[graph.length];\\n        \\n        // DFS of each node\\n        for(int i=0; i<graph.length; i++) {\\n            // If uncolored, then perform DFS\\n            if(colors[i] == 0 && !hasEvenCycle(graph, colors, i, 1))\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    // Return true when graph is bipartite\\n    public boolean hasEvenCycle(int[][] g, int[] colors, int node, int c) {\\n        // if node is colored, node color is same as sent in func definition, return true\\n        if(colors[node] != 0)\\n            return colors[node] == c;\\n        \\n        // Color the current node with color sent in func definition\\n        colors[node] = c;\\n        \\n        // Check for all the adjecent nodes of the current node \"node\"\\n        for(int n : g[node]) {\\n            if(!hasEvenCycle(g, colors, n, -c))\\n                return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        // Array representing the colors\\n        int[] colors = new int[graph.length];\\n        \\n        // DFS of each node\\n        for(int i=0; i<graph.length; i++) {\\n            // If uncolored, then perform DFS\\n            if(colors[i] == 0 && !hasEvenCycle(graph, colors, i, 1))\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    // Return true when graph is bipartite\\n    public boolean hasEvenCycle(int[][] g, int[] colors, int node, int c) {\\n        // if node is colored, node color is same as sent in func definition, return true\\n        if(colors[node] != 0)\\n            return colors[node] == c;\\n        \\n        // Color the current node with color sent in func definition\\n        colors[node] = c;\\n        \\n        // Check for all the adjecent nodes of the current node \"node\"\\n        for(int n : g[node]) {\\n            if(!hasEvenCycle(g, colors, n, -c))\\n                return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 435569,
                "title": "python-unionfind-solution",
                "content": "\\n```\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        def find(i):\\n            if roots[i] != i:\\n                roots[i] = find(roots[i])\\n            return roots[i]\\n\\n        if not graph:\\n            return False\\n        roots = [i for i in range(len(graph))]\\n        for i in range(len(graph)):\\n            if graph[i]:\\n                ri = find(i)\\n                rj = find(graph[i][0])\\n                if ri == rj:\\n                    return False\\n                for k in range(1, len(graph[i])):\\n                    rk = find(graph[i][k])\\n                    if ri == rk:\\n                        return False\\n                    roots[graph[i][k]] = rj\\n        return True\\n\\t\\t```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        def find(i):\\n            if roots[i] != i:\\n                roots[i] = find(roots[i])\\n            return roots[i]\\n\\n        if not graph:\\n            return False\\n        roots = [i for i in range(len(graph))]\\n        for i in range(len(graph)):\\n            if graph[i]:\\n                ri = find(i)\\n                rj = find(graph[i][0])\\n                if ri == rj:\\n                    return False\\n                for k in range(1, len(graph[i])):\\n                    rk = find(graph[i][k])\\n                    if ri == rk:\\n                        return False\\n                    roots[graph[i][k]] = rj\\n        return True\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 357422,
                "title": "java-1ms-bfs-solution-from-sedgewick-s-book",
                "content": "```\\npublic boolean isBipartite(int[][] graph) {\\n        boolean[] visited = new boolean[100];\\n        boolean[] color = new boolean[100];\\n        \\n        LinkedList<Integer> queue = new LinkedList<>();\\n        for (int i = 0; i < graph.length; i++) {\\n            if (graph[i].length == 0 || visited[i]) {\\n                continue;\\n            }\\n            queue.add(i);\\n            visited[i] = true;\\n            color[i] = true;\\n            while (!queue.isEmpty()) {\\n                Integer node = queue.poll();\\n                for (int neighbor : graph[node]) {\\n                    if (!visited[neighbor]) {\\n                        queue.add(neighbor);\\n                        visited[neighbor] = true;\\n                        color[neighbor] = !color[node];\\n                    } else if (color[neighbor] == color[node]) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic boolean isBipartite(int[][] graph) {\\n        boolean[] visited = new boolean[100];\\n        boolean[] color = new boolean[100];\\n        \\n        LinkedList<Integer> queue = new LinkedList<>();\\n        for (int i = 0; i < graph.length; i++) {\\n            if (graph[i].length == 0 || visited[i]) {\\n                continue;\\n            }\\n            queue.add(i);\\n            visited[i] = true;\\n            color[i] = true;\\n            while (!queue.isEmpty()) {\\n                Integer node = queue.poll();\\n                for (int neighbor : graph[node]) {\\n                    if (!visited[neighbor]) {\\n                        queue.add(neighbor);\\n                        visited[neighbor] = true;\\n                        color[neighbor] = !color[node];\\n                    } else if (color[neighbor] == color[node]) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 115528,
                "title": "java-bfs-with-explanation",
                "content": "```\nclass Solution {\n    public boolean isBipartite(int[][] graph) {\n        if(graph==null || graph.length==0) return true;\n        int color[]=new int[graph.length];\n        LinkedList<Integer> q=new LinkedList();\n        for (int i=0;i<graph.length;i++){\n            if(color[i]==0)\n            {\n                q.add(i);\n                color[i]=1;\n            while(q.size()!=0){\n            int node=q.removeFirst();\n            for (int child:graph[node]){\n            if(color[child]==0) \n            {\n                color[child]=color[node]==2?1:2;\n                q.add(child);\n            }\n             else if(color[child]==color[node]) return false;\n        }\n    }\n            }\n        }\n        return true;\n    }\n}\n```\n\nCan we divide the node in two sets such that no two nodes in same set are linked. This was the problem. But sometimes, graph can be a forest. So, we need to check if every node has been processed/colored/discovered or not. O(E)",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public boolean isBipartite(int[][] graph) {\n        if(graph==null || graph.length==0) return true;\n        int color[]=new int[graph.length];\n        LinkedList<Integer> q=new LinkedList();\n        for (int i=0;i<graph.length;i++){\n            if(color[i]==0)\n            {\n                q.add(i);\n                color[i]=1;\n            while(q.size()!=0){\n            int node=q.removeFirst();\n            for (int child:graph[node]){\n            if(color[child]==0) \n            {\n                color[child]=color[node]==2?1:2;\n                q.add(child);\n            }\n             else if(color[child]==color[node]) return false;\n        }\n    }\n            }\n        }\n        return true;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540725,
                "title": "3-methods-bfs-dfs-union-find-easy-and-concise-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor the bfs and dfs is intuition is  simple -\\n1. If node\\'s adjacent nodes are not colored, colored them with differnt color.\\n2. If it\\' adjacent node is colored and it has same color as node return false.\\n \\nFor Union find-\\n1. Group all adjacent nodes.\\n2. if  at any point node and adjacent node happen to be in same group return false.\\n\\n# DFS Code\\n```\\n bool dfs(int node, vector<vector<int>>&adj, vector<int>&colors){\\n        for(auto it: adj[node]){\\n            if(colors[it]==-1){\\n                colors[it] = !colors[node];\\n                if(dfs(it, adj, colors)==false)return false;\\n            }else if(colors[it]==colors[node])return false;\\n        }\\n        return true;\\n    }\\n```\\n\\n# BFS Code\\n```\\nbool bfs(int src, vector<vector<int>>&adj, vector<int>&colors){\\n        colors[src] =0;\\n        queue<int> q;\\n        q.push(src);\\n        while(!q.empty()){\\n            int node = q.front();q.pop();\\n            for(auto it: adj[node]){\\n                if(colors[it]==-1){\\n                    colors[it]= !colors[node];\\n                    q.push(it);\\n                }else if(colors[it]==colors[node])return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\\n# Code For DFS AND BFS\\n```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n= graph.size();\\n        vector<int> colors(n,-1);\\n        for(int i=0;i<n;i++){\\n            if(colors[i]==-1){\\n               colors[i] =0;\\n               //if(bfs(i,graph, colors)==false)return false;            \\n               if(dfs(i,graph, colors)==false)return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(V)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n O(V)\\n# Union Find (DisjointSet Class) Template\\n```\\nclass DisjointSet{\\n    vector<int> parent,size;\\n   public:\\n       DisjointSet(int n){\\n           parent.resize(n+1);\\n           size.resize(n+1,1);\\n           for(int i=0;i<=n;i++) parent[i] =i;\\n       }\\n    int findUPar(int node){\\n        if(parent[node] ==node)return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n    void unionBySize(int u, int v){\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if(ulp_u==ulp_v)return;\\n        if(size[ulp_u]<size[ulp_v]){\\n            size[ulp_v]+=size[ulp_u];\\n            parent[ulp_u] = ulp_v;\\n        }else {\\n            size[ulp_u]+=size[ulp_v];\\n            parent[ulp_v] = ulp_u ;\\n        }\\n    }\\n};\\n\\n```\\n\\n\\n# Code\\n```\\nclass DisjointSet{\\n    vector<int> parent,size;\\n   public:\\n       DisjointSet(int n){\\n           parent.resize(n+1);\\n           size.resize(n+1,1);\\n           for(int i=0;i<=n;i++) parent[i] =i;\\n       }\\n    int findUPar(int node){\\n        if(parent[node] ==node)return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n    void unionBySize(int u, int v){\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if(ulp_u==ulp_v)return;\\n        if(size[ulp_u]<size[ulp_v]){\\n            size[ulp_v]+=size[ulp_u];\\n            parent[ulp_u] = ulp_v;\\n        }else {\\n            size[ulp_u]+=size[ulp_v];\\n            parent[ulp_v] = ulp_u ;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n= graph.size();\\n        DisjointSet ds(n);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<graph[i].size();j++){\\n                if(ds.findUPar(i)==ds.findUPar(graph[i][j]))return false;\\n                ds.unionBySize(graph[i][0], graph[i][j]);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n# Complexity \\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(E) \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n O(V)\\n\\n# Please upvote if you find it helpful!\\n\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\n bool dfs(int node, vector<vector<int>>&adj, vector<int>&colors){\\n        for(auto it: adj[node]){\\n            if(colors[it]==-1){\\n                colors[it] = !colors[node];\\n                if(dfs(it, adj, colors)==false)return false;\\n            }else if(colors[it]==colors[node])return false;\\n        }\\n        return true;\\n    }\\n```\n```\\nbool bfs(int src, vector<vector<int>>&adj, vector<int>&colors){\\n        colors[src] =0;\\n        queue<int> q;\\n        q.push(src);\\n        while(!q.empty()){\\n            int node = q.front();q.pop();\\n            for(auto it: adj[node]){\\n                if(colors[it]==-1){\\n                    colors[it]= !colors[node];\\n                    q.push(it);\\n                }else if(colors[it]==colors[node])return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n= graph.size();\\n        vector<int> colors(n,-1);\\n        for(int i=0;i<n;i++){\\n            if(colors[i]==-1){\\n               colors[i] =0;\\n               //if(bfs(i,graph, colors)==false)return false;            \\n               if(dfs(i,graph, colors)==false)return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```\n```\\nclass DisjointSet{\\n    vector<int> parent,size;\\n   public:\\n       DisjointSet(int n){\\n           parent.resize(n+1);\\n           size.resize(n+1,1);\\n           for(int i=0;i<=n;i++) parent[i] =i;\\n       }\\n    int findUPar(int node){\\n        if(parent[node] ==node)return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n    void unionBySize(int u, int v){\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if(ulp_u==ulp_v)return;\\n        if(size[ulp_u]<size[ulp_v]){\\n            size[ulp_v]+=size[ulp_u];\\n            parent[ulp_u] = ulp_v;\\n        }else {\\n            size[ulp_u]+=size[ulp_v];\\n            parent[ulp_v] = ulp_u ;\\n        }\\n    }\\n};\\n\\n```\n```\\nclass DisjointSet{\\n    vector<int> parent,size;\\n   public:\\n       DisjointSet(int n){\\n           parent.resize(n+1);\\n           size.resize(n+1,1);\\n           for(int i=0;i<=n;i++) parent[i] =i;\\n       }\\n    int findUPar(int node){\\n        if(parent[node] ==node)return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n    void unionBySize(int u, int v){\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if(ulp_u==ulp_v)return;\\n        if(size[ulp_u]<size[ulp_v]){\\n            size[ulp_v]+=size[ulp_u];\\n            parent[ulp_u] = ulp_v;\\n        }else {\\n            size[ulp_u]+=size[ulp_v];\\n            parent[ulp_v] = ulp_u ;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n= graph.size();\\n        DisjointSet ds(n);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<graph[i].size();j++){\\n                if(ds.findUPar(i)==ds.findUPar(graph[i][j]))return false;\\n                ds.unionBySize(graph[i][0], graph[i][j]);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540034,
                "title": "easy-java-solution-with-explanation-and-intuition",
                "content": "# PLEASE UPVOTE!!!\\n\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing BFS and Graph Coloring Approach.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\nN is no of edges\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\nN is no of edges\\n\\n# Code\\n```\\nclass Solution {\\n\\tint[] colors;\\n    public boolean isBipartite(int[][] graph) {\\n        HashMap<Integer, ArrayList<Integer>> adj = new HashMap<Integer, ArrayList<Integer>>();\\n\\t\\tcolors = new int[graph.length];\\n\\t\\t\\n\\t\\tfor (int i = 0; i < graph.length; i++) {\\n\\t\\t\\tadj.putIfAbsent(i, new ArrayList<Integer>());\\n\\t\\t\\tfor(int j=0;j<graph[i].length;j++){\\n                adj.get(i).add(graph[i][j]);\\n            }\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int i = 0; i < colors.length; i++) {\\n\\t\\t\\tif(colors[i]==0 && adj.get(i)==null) {\\n\\t\\t\\t\\tcolors[i]=1;\\n\\t\\t\\t}\\n\\t\\t\\telse if(colors[i]==0 && !(adj.get(i)==null)) {\\n\\t\\t\\t\\tif(!bfs(adj, i)) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\t\\n\\tprivate boolean bfs(HashMap<Integer, ArrayList<Integer>> adj, int node) {\\n\\t\\tArrayList<Integer> que = new ArrayList<Integer>();\\n\\t\\tque.add(node);\\n\\t\\tcolors[node] = 1;\\n\\t\\tint c =0;\\n\\t\\twhile(que.size()>0) {\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<adj.get(que.get(0)).size();i++) {\\n\\t\\t\\t\\tif(colors[adj.get(que.get(0)).get(i)]==0) {\\n\\t\\t\\t\\t\\tif(colors[que.get(0)]==1) {\\n\\t\\t\\t\\t\\t\\tcolors[adj.get(que.get(0)).get(i)] = 2;\\n\\t\\t\\t\\t\\t\\tque.add(adj.get(que.get(0)).get(i));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(colors[que.get(0)]==2) {\\n\\t\\t\\t\\t\\t\\tcolors[adj.get(que.get(0)).get(i)] = 1;\\n\\t\\t\\t\\t\\t\\tque.add(adj.get(que.get(0)).get(i));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif(colors[que.get(0)]==colors[adj.get(que.get(0)).get(i)]) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n            }\\n\\t\\t\\tque.remove(0);\\n\\t\\t}\\n\\t\\treturn true\\t;\\n\\t}\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tint[] colors;\\n    public boolean isBipartite(int[][] graph) {\\n        HashMap<Integer, ArrayList<Integer>> adj = new HashMap<Integer, ArrayList<Integer>>();\\n\\t\\tcolors = new int[graph.length];\\n\\t\\t\\n\\t\\tfor (int i = 0; i < graph.length; i++) {\\n\\t\\t\\tadj.putIfAbsent(i, new ArrayList<Integer>());\\n\\t\\t\\tfor(int j=0;j<graph[i].length;j++){\\n                adj.get(i).add(graph[i][j]);\\n            }\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int i = 0; i < colors.length; i++) {\\n\\t\\t\\tif(colors[i]==0 && adj.get(i)==null) {\\n\\t\\t\\t\\tcolors[i]=1;\\n\\t\\t\\t}\\n\\t\\t\\telse if(colors[i]==0 && !(adj.get(i)==null)) {\\n\\t\\t\\t\\tif(!bfs(adj, i)) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\t\\n\\tprivate boolean bfs(HashMap<Integer, ArrayList<Integer>> adj, int node) {\\n\\t\\tArrayList<Integer> que = new ArrayList<Integer>();\\n\\t\\tque.add(node);\\n\\t\\tcolors[node] = 1;\\n\\t\\tint c =0;\\n\\t\\twhile(que.size()>0) {\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<adj.get(que.get(0)).size();i++) {\\n\\t\\t\\t\\tif(colors[adj.get(que.get(0)).get(i)]==0) {\\n\\t\\t\\t\\t\\tif(colors[que.get(0)]==1) {\\n\\t\\t\\t\\t\\t\\tcolors[adj.get(que.get(0)).get(i)] = 2;\\n\\t\\t\\t\\t\\t\\tque.add(adj.get(que.get(0)).get(i));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(colors[que.get(0)]==2) {\\n\\t\\t\\t\\t\\t\\tcolors[adj.get(que.get(0)).get(i)] = 1;\\n\\t\\t\\t\\t\\t\\tque.add(adj.get(que.get(0)).get(i));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif(colors[que.get(0)]==colors[adj.get(que.get(0)).get(i)]) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n            }\\n\\t\\t\\tque.remove(0);\\n\\t\\t}\\n\\t\\treturn true\\t;\\n\\t}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104522,
                "title": "accepted-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool dfs(int node,vector<int>&vis,vector<vector<int>>graph,int a)\\n{\\n    vis[node]=a;\\n\\n    for(auto it:graph[node])\\n    {\\n      if(vis[it]==-1)\\n      {\\n        if(dfs(it,vis,graph,1-a)==false)\\n          return false;\\n      }\\n        else if(vis[node]==vis[it])\\n          return false;\\n    }\\n    return true; \\n}\\n    \\nbool isBipartite(vector<vector<int>>& graph)\\n{\\n  vector<int>vis(graph.size(),-1);\\n  for(int i=0;i<graph.size();i++)\\n  {\\n    if(vis[i]==-1)\\n    {\\n      if(!dfs(i,vis,graph,1))\\n      return false;\\n    }\\n\\n  }\\n  return true;\\n}\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool dfs(int node,vector<int>&vis,vector<vector<int>>graph,int a)\\n{\\n    vis[node]=a;\\n\\n    for(auto it:graph[node])\\n    {\\n      if(vis[it]==-1)\\n      {\\n        if(dfs(it,vis,graph,1-a)==false)\\n          return false;\\n      }\\n        else if(vis[node]==vis[it])\\n          return false;\\n    }\\n    return true; \\n}\\n    \\nbool isBipartite(vector<vector<int>>& graph)\\n{\\n  vector<int>vis(graph.size(),-1);\\n  for(int i=0;i<graph.size();i++)\\n  {\\n    if(vis[i]==-1)\\n    {\\n      if(!dfs(i,vis,graph,1))\\n      return false;\\n    }\\n\\n  }\\n  return true;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990727,
                "title": "c-bfs-implementation",
                "content": "```\\n// A graph is said to be bipartite if we can divide all its vertices into two mutually \\n// exclusive and exhaustive sets such that none of the edge is within the set(i.e. all the \\n//  edges of graph are across the sets)\\n\\n/*\\n    1) A acyclic graph is always bipartite because we can easily put all the connected vertices\\n        into different sets.\\n    2) A cyclic graph with even number of vertices in the cycle is bipartite. This is because when we visit the cycle detection vertex, it would be at the same level in BFS.\\n    3) a cyclic graph with odd number of vertices in the cycle is always non-bipartite because in a BFS, we would visit the cycle detection vertex twice and each time this vertex would be at different levels in BFS.\\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    // Simple BFS modification.\\n    bool checkComponentsForBipartiteness(vector<vector<int>>& graph, int src, vector<int>&marked_levels){\\n        queue<pair<int,int>> q; // stores the vertex and its corresponding level .\\n        q.push({src,0});\\n        while(q.size() > 0){\\n            pair<int,int> vertex = q.front();\\n            q.pop();\\n            \\n            // if the vertex is already visited that means there exists a cycle.\\n            // If the level stored in marked_levels and the level of popped vertex differ, that means the cycle is odd. hence, return false;\\n            if(marked_levels[vertex.first] != -1){\\n                if(marked_levels[vertex.first] != vertex.second){\\n                    return false;\\n                }\\n            }\\n            \\n            // else simply store the level of vertex into marked levels.\\n            else{\\n                marked_levels[vertex.first] = vertex.second;\\n            }\\n            \\n            \\n            // add all the connected vertices of vertex into the queue as they are the next level in BFS.\\n            for(int v : graph[vertex.first]){\\n                if(marked_levels[v] == -1){\\n                    q.push({v,vertex.second+1});\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool isBipartite(vector<vector<int>>& graph) {\\n        // define a vector say marked_levels that stores/marks the level at which the vertex was visited during BFS at the corresponding vertex index.\\n        vector<int> marked_levels(graph.size(), -1);\\n        \\n        // even if a single component of a graph is non-bipartite the entire graph will be non-bipartite . Hence, checking bipartiteness for all the components.\\n        for(int i=0;i<graph.size();i++){\\n            if(marked_levels[i] == -1){\\n                bool bipartite = checkComponentsForBipartiteness(graph, i, marked_levels);\\n                if(bipartite == false){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n/*\\nAnalysis:\\n1) TC :-  O(N + E)   as we are doing a simple BFS.\\n2) SC :-  O(N)       we are using a queue which will store at max N vertices.\\n\\n\\n*/\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n// A graph is said to be bipartite if we can divide all its vertices into two mutually \\n// exclusive and exhaustive sets such that none of the edge is within the set(i.e. all the \\n//  edges of graph are across the sets)\\n\\n/*\\n    1) A acyclic graph is always bipartite because we can easily put all the connected vertices\\n        into different sets.\\n    2) A cyclic graph with even number of vertices in the cycle is bipartite. This is because when we visit the cycle detection vertex, it would be at the same level in BFS.\\n    3) a cyclic graph with odd number of vertices in the cycle is always non-bipartite because in a BFS, we would visit the cycle detection vertex twice and each time this vertex would be at different levels in BFS.\\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    // Simple BFS modification.\\n    bool checkComponentsForBipartiteness(vector<vector<int>>& graph, int src, vector<int>&marked_levels){\\n        queue<pair<int,int>> q; // stores the vertex and its corresponding level .\\n        q.push({src,0});\\n        while(q.size() > 0){\\n            pair<int,int> vertex = q.front();\\n            q.pop();\\n            \\n            // if the vertex is already visited that means there exists a cycle.\\n            // If the level stored in marked_levels and the level of popped vertex differ, that means the cycle is odd. hence, return false;\\n            if(marked_levels[vertex.first] != -1){\\n                if(marked_levels[vertex.first] != vertex.second){\\n                    return false;\\n                }\\n            }\\n            \\n            // else simply store the level of vertex into marked levels.\\n            else{\\n                marked_levels[vertex.first] = vertex.second;\\n            }\\n            \\n            \\n            // add all the connected vertices of vertex into the queue as they are the next level in BFS.\\n            for(int v : graph[vertex.first]){\\n                if(marked_levels[v] == -1){\\n                    q.push({v,vertex.second+1});\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool isBipartite(vector<vector<int>>& graph) {\\n        // define a vector say marked_levels that stores/marks the level at which the vertex was visited during BFS at the corresponding vertex index.\\n        vector<int> marked_levels(graph.size(), -1);\\n        \\n        // even if a single component of a graph is non-bipartite the entire graph will be non-bipartite . Hence, checking bipartiteness for all the components.\\n        for(int i=0;i<graph.size();i++){\\n            if(marked_levels[i] == -1){\\n                bool bipartite = checkComponentsForBipartiteness(graph, i, marked_levels);\\n                if(bipartite == false){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n/*\\nAnalysis:\\n1) TC :-  O(N + E)   as we are doing a simple BFS.\\n2) SC :-  O(N)       we are using a queue which will store at max N vertices.\\n\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1652200,
                "title": "clean-simple-c-super-easy",
                "content": "We are trying to split the graph into two groups of edges.\\n\\nSo we color the edges,1 = red, 0 = blue, -1 = not colored yet.\\n\\nA graph is bipartite if and only if the two ends of each edge have different colors.\\n\\n**If edge is not coloured then, We colour it with a color which is opposite from it\\'s parent OR\\nIf a edge is already coloured then we check that it\\'s different from it\\'s parent colour ,\\nIf it\\'s found that it is same color then RETURN FALSE**\\n \\n \\n ```\\n \\n  bool isBipartite(vector<vector<int>>&v) \\n    {\\n          int n=v.size();\\n          vector<int> color(n,-1);\\n          color[0]=0;\\n          for(int i=0;i<n;i++)\\n        {\\n           for(auto x:v[i])\\n           {\\n               if(color[x]==-1)\\n               {\\n                   color[x]=1-color[i];\\n               }\\n               else if(color[x]==color[i])\\n               {\\n                   return 0;\\n               }\\n               \\n           }\\n       }\\n        return 1;\\n  }\\n\\t\\n",
                "solutionTags": [
                    "C",
                    "Graph",
                    "Iterator"
                ],
                "code": "We are trying to split the graph into two groups of edges.\\n\\nSo we color the edges,1 = red, 0 = blue, -1 = not colored yet.\\n\\nA graph is bipartite if and only if the two ends of each edge have different colors.\\n\\n**If edge is not coloured then, We colour it with a color which is opposite from it\\'s parent OR\\nIf a edge is already coloured then we check that it\\'s different from it\\'s parent colour ,\\nIf it\\'s found that it is same color then RETURN FALSE**\\n \\n \\n ```\\n \\n  bool isBipartite(vector<vector<int>>&v) \\n    {\\n          int n=v.size();\\n          vector<int> color(n,-1);\\n          color[0]=0;\\n          for(int i=0;i<n;i++)\\n        {\\n           for(auto x:v[i])\\n           {\\n               if(color[x]==-1)\\n               {\\n                   color[x]=1-color[i];\\n               }\\n               else if(color[x]==color[i])\\n               {\\n                   return 0;\\n               }\\n               \\n           }\\n       }\\n        return 1;\\n  }\\n\\t\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1523684,
                "title": "bfs-c",
                "content": "```cpp\\nclass Solution {\\nprivate:\\n    bool bipartiteBFS(int node,vector<vector<int>>&graph,vector<int>&color){\\n        queue<int>q;\\n        q.push(node);\\n        color[node]=1;\\n        while(!q.empty()){\\n            int adjacent = q.front();\\n            q.pop();\\n\\n            for(auto it:graph[adjacent]){\\n                if(color[it]==-1){\\n                    color[it] = 1 - color[adjacent];\\n                    q.push(it);\\n                }\\n                else if(color[it]==color[adjacent]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        vector<int>color(n,-1);\\n        for(int i=0;i<n;i++){\\n            if(color[i]==-1){\\n                if(!bipartiteBFS(i,graph,color)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\nprivate:\\n    bool bipartiteBFS(int node,vector<vector<int>>&graph,vector<int>&color){\\n        queue<int>q;\\n        q.push(node);\\n        color[node]=1;\\n        while(!q.empty()){\\n            int adjacent = q.front();\\n            q.pop();\\n\\n            for(auto it:graph[adjacent]){\\n                if(color[it]==-1){\\n                    color[it] = 1 - color[adjacent];\\n                    q.push(it);\\n                }\\n                else if(color[it]==color[adjacent]){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        vector<int>color(n,-1);\\n        for(int i=0;i<n;i++){\\n            if(color[i]==-1){\\n                if(!bipartiteBFS(i,graph,color)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249076,
                "title": "java-clean-concise-optimal-code-depth-first-search-algorithm-100-faster-solution",
                "content": "```\\nclass Solution {\\n    \\n    public boolean dfs (int[][] graph, int[] colour, int node) {\\n        \\n        for (int newNode : graph[node]) {\\n            if (colour[node] == colour[newNode]) {\\n                return false;\\n            }\\n            else if (colour[newNode] == -1) {\\n                colour[newNode] = 1 - colour[node];\\n                if (!dfs (graph, colour, newNode)) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    public boolean isBipartite(int[][] graph) {\\n        \\n        int[] colour = new int[graph.length];\\n        Arrays.fill (colour, -1);\\n        \\n        for (int node = 0; node < graph.length; node++) {\\n            if (colour[node] == -1) {\\n                colour[node] = 1;\\n                if (!dfs (graph, colour, node)) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public boolean dfs (int[][] graph, int[] colour, int node) {\\n        \\n        for (int newNode : graph[node]) {\\n            if (colour[node] == colour[newNode]) {\\n                return false;\\n            }\\n            else if (colour[newNode] == -1) {\\n                colour[newNode] = 1 - colour[node];\\n                if (!dfs (graph, colour, newNode)) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    public boolean isBipartite(int[][] graph) {\\n        \\n        int[] colour = new int[graph.length];\\n        Arrays.fill (colour, -1);\\n        \\n        for (int node = 0; node < graph.length; node++) {\\n            if (colour[node] == -1) {\\n                colour[node] = 1;\\n                if (!dfs (graph, colour, node)) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065394,
                "title": "is-a-graph-bipartite-python-linear-algebra-solution",
                "content": "A graph is bipartite if and only if the largest and smallest eigenvalues of its adjacency matrix are the same in absolute value.\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        n = len(graph)\\n        adj = np.zeros((n, n))\\n        for i, node in enumerate(graph):\\n            for j in node:\\n                adj[i, j] = 1\\n        eigs, _ = np.linalg.eigh(adj)\\n        return (eigs[-1] + eigs[0]) < 1e-10\\n\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nimport numpy as np\\n\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        n = len(graph)\\n        adj = np.zeros((n, n))\\n        for i, node in enumerate(graph):\\n            for j in node:\\n                adj[i, j] = 1\\n        eigs, _ = np.linalg.eigh(adj)\\n        return (eigs[-1] + eigs[0]) < 1e-10\\n\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 756965,
                "title": "python-bfs-and-dfs",
                "content": "```\\n# BFS\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        n,color = len(graph), {}\\n        for i in range(n):\\n            if i not in color and graph[i]:\\n                color[i] = 1\\n                Q = collections.deque([i])\\n                while Q:\\n                    u = Q.popleft()\\n                    for v in graph[u]:\\n                        if v not in color:\\n                            color[v] = 1 - color[u]\\n                            Q.append(v)\\n                        elif color[v] == color[u]:\\n                            return False\\n        return True\\n\\n# DFS\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        n,color = len(graph),{}\\n        def dfs(u):\\n            for v in graph[u]:\\n                if v not in color:\\n                    color[v] = 1 - color[u]\\n                    if not dfs(v): return False\\n                elif color[v] == color[u]:\\n                    return False\\n            return True\\n        for i in range(n):\\n            if i not in color and graph[i]:\\n                color[i] = 1\\n                if not dfs(i): return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n# BFS\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        n,color = len(graph), {}\\n        for i in range(n):\\n            if i not in color and graph[i]:\\n                color[i] = 1\\n                Q = collections.deque([i])\\n                while Q:\\n                    u = Q.popleft()\\n                    for v in graph[u]:\\n                        if v not in color:\\n                            color[v] = 1 - color[u]\\n                            Q.append(v)\\n                        elif color[v] == color[u]:\\n                            return False\\n        return True\\n\\n# DFS\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        n,color = len(graph),{}\\n        def dfs(u):\\n            for v in graph[u]:\\n                if v not in color:\\n                    color[v] = 1 - color[u]\\n                    if not dfs(v): return False\\n                elif color[v] == color[u]:\\n                    return False\\n            return True\\n        for i in range(n):\\n            if i not in color and graph[i]:\\n                color[i] = 1\\n                if not dfs(i): return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 664545,
                "title": "java-simple-dfs-solution-both-code-and-reference-video-attached-for-better-understanding",
                "content": "Java simple solution , here is the video for the concept beind the code.\\n\\nhttps://youtu.be/2_e--EjacOc\\n\\nHere is the video for code - \\n\\nhttps://youtu.be/dR1lAnxuJ3A\\n\\nhere goes my code- \\n\"class graph{\\n    \\n    int v;\\n    HashMap<Integer, LinkedList<Integer>> adj;\\n    // int ans[];\\n    \\n    graph(int x)\\n    {\\n        v=x;\\n        adj=new HashMap<>();\\n        for(int i=0;i<v;i++)\\n        {\\n            adj.put(i,new LinkedList<Integer>());\\n        }\\n      //   ans=new int[v];\\n    }\\n    \\n    public void add(int x,int y)\\n    {\\n        adj.get(x).add(y);\\n    }\\n    \\n    \\n    public boolean bip()\\n    {\\n        \\n        int vis[]=new int[v];\\n        for(int i=0;i<v;i++)\\n        {\\n            if(vis[i]==0)\\n            {\\n                boolean ans=bip_helper(i,-1,1,vis);\\n                if(ans==false)\\n                    return false;\\n                    \\n            }\\n        }\\n        \\n        return true;\\n        \\n    }\\n    \\n    public boolean bip_helper(int s,int par,int col,int vis[])\\n    {\\n        vis[s]=col;\\n        \\n        for(int nbr:adj.get(s))\\n        {\\n            \\n            if(vis[nbr]==0)\\n            {\\n               boolean ans=bip_helper(nbr,s,3-col,vis); \\n                if(ans==false)\\n                    return false;\\n            }\\n            \\n            if(par!=nbr&&vis[nbr]==col)\\n            {\\n                return false;\\n            }\\n            \\n        }\\n        \\n        return true;\\n        \\n        \\n    }\\n \\n    \\n    \\n}\\n\\n\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        \\n        graph g=new graph(graph.length);\\n        \\n        for(int i=0;i<graph.length;i++)\\n        {\\n            for(int j=0;j<graph[i].length;j++)\\n            {\\n                g.add(i,graph[i][j]);\\n            }\\n        }\\n        \\n        return g.bip();\\n    }\\n} \"\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        \\n        graph g=new graph(graph.length);\\n        \\n        for(int i=0;i<graph.length;i++)\\n        {\\n            for(int j=0;j<graph[i].length;j++)\\n            {\\n                g.add(i,graph[i][j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 656319,
                "title": "c-using-bfs-beginners-code",
                "content": "***Pls upvote if you find this helpful  :)***\\nI\\'m new to graph theory ,so kindly mention better/new ways to optimize this code in the comments.\\n\\nBasically here the first issue was to understand the question i.e how the graph is made using graph vector. Basically if graph=[[1,2] , .....] it means 0 is connected with 1 and 2. So therefore we can make an adjacency list of size of graph and update it from the graph matrix.**(Remember the size of each graph[i] can be diffferent).**\\nAfter this we can use normal bfs and give different colors to the nodes and if any edge has same color on both of its nodes then return false.\\n```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        if(n<2)return true;\\n        vector<int> adj[n];\\n        vector<int> setColor(n,0);   \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<graph[i].size();j++)\\n            adj[i].push_back(graph[i][j]);     \\n        }\\n       for(int i=0;i<n;i++){\\n           if(setColor[i]==0){\\n           queue<int>q1;\\n           q1.push(i);\\n           setColor[i]=1;\\n               while(!q1.empty()){\\n               int cur=q1.front();\\n               q1.pop();\\n               for(auto j:adj[cur]){\\n                   if(setColor[j]==0){\\n                       q1.push(j);\\n                       setColor[j]=-setColor[cur];\\n                   }\\n                   else{\\n                       if(setColor[j]==setColor[cur])return false;\\n                   }\\n               }\\n             }\\n           }\\n          \\n       }\\n        return true;  \\n    }\\n};\\n```\\n\\n**EDIT**: I have created adjacency list in the previous solution which wasn,t needed and it can be done with the help of input itself.Couldn\\'t visualise it as adjacency list.Refer the updated code below. Sorry for the edit  :)\\n```\\n\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        if(n<2)return true;\\n        vector<int> setColor(n,0);   \\n       for(int i=0;i<n;i++){\\n           if(setColor[i]==0){\\n           queue<int>q1;\\n           q1.push(i);\\n           setColor[i]=1;\\n               while(!q1.empty()){\\n               int cur=q1.front();\\n               q1.pop();\\n               for(auto j:graph[cur]){\\n                   if(setColor[j]==0){\\n                       q1.push(j);\\n                       setColor[j]=-setColor[cur];\\n                   }\\n                   else{\\n                       if(setColor[j]==setColor[cur])return false;\\n                   }\\n               }\\n             }\\n           }\\n          \\n       }\\n        return true;  \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        if(n<2)return true;\\n        vector<int> adj[n];\\n        vector<int> setColor(n,0);   \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<graph[i].size();j++)\\n            adj[i].push_back(graph[i][j]);     \\n        }\\n       for(int i=0;i<n;i++){\\n           if(setColor[i]==0){\\n           queue<int>q1;\\n           q1.push(i);\\n           setColor[i]=1;\\n               while(!q1.empty()){\\n               int cur=q1.front();\\n               q1.pop();\\n               for(auto j:adj[cur]){\\n                   if(setColor[j]==0){\\n                       q1.push(j);\\n                       setColor[j]=-setColor[cur];\\n                   }\\n                   else{\\n                       if(setColor[j]==setColor[cur])return false;\\n                   }\\n               }\\n             }\\n           }\\n          \\n       }\\n        return true;  \\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        if(n<2)return true;\\n        vector<int> setColor(n,0);   \\n       for(int i=0;i<n;i++){\\n           if(setColor[i]==0){\\n           queue<int>q1;\\n           q1.push(i);\\n           setColor[i]=1;\\n               while(!q1.empty()){\\n               int cur=q1.front();\\n               q1.pop();\\n               for(auto j:graph[cur]){\\n                   if(setColor[j]==0){\\n                       q1.push(j);\\n                       setColor[j]=-setColor[cur];\\n                   }\\n                   else{\\n                       if(setColor[j]==setColor[cur])return false;\\n                   }\\n               }\\n             }\\n           }\\n          \\n       }\\n        return true;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 339145,
                "title": "python-dfs-and-bfs-solution",
                "content": "DFS solution:\\n```\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        def dfs(i):\\n            for j in graph[i]:\\n                if group[j] != -1:\\n                    if group[j] == group[i]:\\n                        return False\\n                else:\\n                    group[j] = 1 - group[i]\\n                    if not dfs(j):\\n                        return False\\n            return True\\n                \\n        n = len(graph)\\n        group = n * [-1]\\n        for i in range(n):\\n            if group[i] == -1:\\n                group[i] = 0\\n                if not dfs(i):\\n                    return False\\n        return True\\n```\\n\\nBFS solution:\\n```\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        def bfs(i):\\n            curr_level = [i]\\n            while curr_level:\\n                next_level = []\\n                for i in curr_level:\\n                    for j in graph[i]:\\n                        if group[j] != -1:\\n                            if group[j] == group[i]:\\n                                return False\\n                        else:\\n                            group[j] = 1 - group[i]\\n                            next_level.append(j)\\n                curr_level = next_level\\n            return True\\n                \\n        n = len(graph)\\n        group = n * [-1]\\n        for i in range(n):\\n            if group[i] == -1:\\n                group[i] = 0\\n                if not bfs(i):\\n                    return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        def dfs(i):\\n            for j in graph[i]:\\n                if group[j] != -1:\\n                    if group[j] == group[i]:\\n                        return False\\n                else:\\n                    group[j] = 1 - group[i]\\n                    if not dfs(j):\\n                        return False\\n            return True\\n                \\n        n = len(graph)\\n        group = n * [-1]\\n        for i in range(n):\\n            if group[i] == -1:\\n                group[i] = 0\\n                if not dfs(i):\\n                    return False\\n        return True\\n```\n```\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        def bfs(i):\\n            curr_level = [i]\\n            while curr_level:\\n                next_level = []\\n                for i in curr_level:\\n                    for j in graph[i]:\\n                        if group[j] != -1:\\n                            if group[j] == group[i]:\\n                                return False\\n                        else:\\n                            group[j] = 1 - group[i]\\n                            next_level.append(j)\\n                curr_level = next_level\\n            return True\\n                \\n        n = len(graph)\\n        group = n * [-1]\\n        for i in range(n):\\n            if group[i] == -1:\\n                group[i] = 0\\n                if not bfs(i):\\n                    return False\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 337668,
                "title": "c-concise-dfs",
                "content": "We place each node into a group (A or B) and then attempt to put all of its adjacent nodes into the opposite group. If this pattern fails, we return `false`.\\n\\nThe vector `vis` tracks the position of each node:\\n* `0` : We havn\\'t yet visited this node.\\n* `1` : Group \\'A\\'.\\n* `2` : Group \\'B\\'.\\n\\nIn the `dfs` function, `i` represents the node we are currently at and `pos` represents the group we must place the current node into. If `pos == 0`, we don\\'t care where the node goes, so we just place it into group A.\\n```cpp\\nbool isBipartite(vector<vector<int>>& graph) {\\n\\tvector<int> vis(graph.size());\\n\\tfor(int i = 0; i < graph.size(); i++)\\n\\t\\tif(!dfs(graph, vis, i, vis[i]))\\n\\t\\t\\treturn false;\\n\\treturn true;\\n}\\n\\nbool dfs(vector<vector<int>> &graph, vector<int> &vis, int i, int pos) {\\n\\tif(!vis[i]) {\\n\\t\\tvis[i] = pos == 2 ? 2 : 1;\\n\\t\\tfor(int j : graph[i])\\n\\t\\t\\tif(!dfs(graph, vis, j, pos == 2 ? 1 : 2))\\n\\t\\t\\t\\treturn false;\\n\\t}\\n\\treturn !pos || pos == vis[i];\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nbool isBipartite(vector<vector<int>>& graph) {\\n\\tvector<int> vis(graph.size());\\n\\tfor(int i = 0; i < graph.size(); i++)\\n\\t\\tif(!dfs(graph, vis, i, vis[i]))\\n\\t\\t\\treturn false;\\n\\treturn true;\\n}\\n\\nbool dfs(vector<vector<int>> &graph, vector<int> &vis, int i, int pos) {\\n\\tif(!vis[i]) {\\n\\t\\tvis[i] = pos == 2 ? 2 : 1;\\n\\t\\tfor(int j : graph[i])\\n\\t\\t\\tif(!dfs(graph, vis, j, pos == 2 ? 1 : 2))\\n\\t\\t\\t\\treturn false;\\n\\t}\\n\\treturn !pos || pos == vis[i];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 161001,
                "title": "java-graph-coloring-bfs-with-explanation",
                "content": "A bipartite graph can be colored using only two colors. Luckily our input is a list of edges for each node, otherwise we would have to make our own array or a hashmap.  In my case, I use 1 for the first uncolor node, then try to color all of the connected nodes with the opposite color of the previous alternating between 1 and -1. If it\\'s not consistent and we encounter a color that is colored and is not the opposite color, it means a coloring is not possible so we return false.  If we encounter an uncolored node we color it then push it into the bfs queue.\\n```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        //try to color with two colors\\n        int [] color = new int[graph.length];\\n        for(int i=0; i<color.length;++i){\\n            if(color[i]==0){\\n                Queue<Integer> bfs = new LinkedList<>();\\n                bfs.add(i);\\n                color[i]=1;\\n                while(!bfs.isEmpty()){\\n                    int prev = bfs.remove();\\n                    int nextColor = -color[prev];\\n                    int[] children = graph[prev];\\n                    for(int j=0; j<children.length;++j){\\n                        int next = children[j];\\n                        if(color[next]==0){\\n                            bfs.add(next);\\n                            color[next]=nextColor;\\n                        }\\n                        else if(color[next]!=nextColor){\\n                            return false;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        //try to color with two colors\\n        int [] color = new int[graph.length];\\n        for(int i=0; i<color.length;++i){\\n            if(color[i]==0){\\n                Queue<Integer> bfs = new LinkedList<>();\\n                bfs.add(i);\\n                color[i]=1;\\n                while(!bfs.isEmpty()){\\n                    int prev = bfs.remove();\\n                    int nextColor = -color[prev];\\n                    int[] children = graph[prev];\\n                    for(int j=0; j<children.length;++j){\\n                        int next = children[j];\\n                        if(color[next]==0){\\n                            bfs.add(next);\\n                            color[next]=nextColor;\\n                        }\\n                        else if(color[next]!=nextColor){\\n                            return false;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641738,
                "title": "dfs-cpp",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic: \\n    void dfs(int node , vector<vector<int>>& graph , bool &b , vector<int> &color)\\n    {\\n        for(auto adj:graph[node])\\n        {\\n            if(color[adj]==-1)\\n            {\\n                color[adj] = !color[node];\\n                dfs(adj,graph,b,color);\\n            }\\n            else if(color[adj]==color[node])\\n            {\\n                b=0;\\n                return;\\n            }\\n        }\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) \\n    {\\n        vector<int> color(graph.size(),-1);\\n        bool b;\\n        for(int i=0;i<graph.size();i++)\\n        {\\n            if(color[i]==-1)\\n            {\\n                color[i]=0; b = 1;\\n                dfs(i,graph,b,color);\\n                if(!b)\\n                {\\n                    return false;\\n                }\\n            }\\n        }   \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    void dfs(int node , vector<vector<int>>& graph , bool &b , vector<int> &color)\\n    {\\n        for(auto adj:graph[node])\\n        {\\n            if(color[adj]==-1)\\n            {\\n                color[adj] = !color[node];\\n                dfs(adj,graph,b,color);\\n            }\\n            else if(color[adj]==color[node])\\n            {\\n                b=0;\\n                return;\\n            }\\n        }\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) \\n    {\\n        vector<int> color(graph.size(),-1);\\n        bool b;\\n        for(int i=0;i<graph.size();i++)\\n        {\\n            if(color[i]==-1)\\n            {\\n                color[i]=0; b = 1;\\n                dfs(i,graph,b,color);\\n                if(!b)\\n                {\\n                    return false;\\n                }\\n            }\\n        }   \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541963,
                "title": "optimised-solution-using-graph-coloring-algorithm",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<int> nodeColors(n, 0);  // Initialize all nodes with color 0\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (nodeColors[i] == 0 && !dfs(graph, i, 1, nodeColors)) {\\n                return false;  // Found an inconsistency, graph is not bipartite\\n            }\\n        }\\n        \\n        return true;  // All nodes are successfully colored, graph is bipartite\\n    }\\n    \\nprivate:\\n    bool dfs(vector<vector<int>>& graph, int node, int color, vector<int>& nodeColors) {\\n        nodeColors[node] = color;  // Color the current node\\n        \\n        for (int neighbor : graph[node]) {\\n            if (nodeColors[neighbor] == color) {\\n                return false;  // Found an inconsistency in the coloring\\n            }\\n            \\n            if (nodeColors[neighbor] == 0 && !dfs(graph, neighbor, -color, nodeColors)) {\\n                return false;  // Found an inconsistency, graph is not bipartite\\n            }\\n        }\\n        \\n        return true;  // Successfully colored all neighbors\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<int> nodeColors(n, 0);  // Initialize all nodes with color 0\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (nodeColors[i] == 0 && !dfs(graph, i, 1, nodeColors)) {\\n                return false;  // Found an inconsistency, graph is not bipartite\\n            }\\n        }\\n        \\n        return true;  // All nodes are successfully colored, graph is bipartite\\n    }\\n    \\nprivate:\\n    bool dfs(vector<vector<int>>& graph, int node, int color, vector<int>& nodeColors) {\\n        nodeColors[node] = color;  // Color the current node\\n        \\n        for (int neighbor : graph[node]) {\\n            if (nodeColors[neighbor] == color) {\\n                return false;  // Found an inconsistency in the coloring\\n            }\\n            \\n            if (nodeColors[neighbor] == 0 && !dfs(graph, neighbor, -color, nodeColors)) {\\n                return false;  // Found an inconsistency, graph is not bipartite\\n            }\\n        }\\n        \\n        return true;  // Successfully colored all neighbors\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540966,
                "title": "easy-approach-c-bfs-o-v-e",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn order to navigate the graph and assign colours to the nodes, the algorithm use a breadth-first search (BFS) method. It keeps a queue v where the nodes that need to be processed are kept. The BFS investigates the nodes that are close to the source node B.\\n\\nThe nodes\\' colours are assigned using the colour vector. All nodes are initially colourless, represented by -1 in the colour vector. A node\\'s colour is initially assigned as the complement of its parent\\'s colour (expressed by!color[node]) when it is visited for the first time. The function returns false if the nearby node already has the same colour as its parent, indicating that the graph is not bipartite.\\n\\nThe BFS keeps going until either all nodes have been visited or a colour conflict is found. The BFS returns true if it completes with no conflicts, indicating that the graph is bipartite.\\n\\nFor each node in the graph, the isBipartite function calls the bfs function to determine whether it is bipartite. The overall function returns false if any of the calls to bfs return false, indicating that the related subgraph is not bipartite. If not, it returns true, indicating that the graph is entirely bipartite.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBFS Traversal: Each node in the graph is used as the beginning point for a BFS traversal by the code. The temporal complexity for traversing all the edges from a node is O(deg(v)), where deg(v) is the degree of vertex v, and the graph is represented using an adjacency list. In the worst situation, every edge is only visited once, giving the entire BFS traversal a total time complexity of O(V + E).\\n\\nExamining Colour Conflicts: The code examines whether there is a colour conflict between the source node and the nearby node for each edge in the graph. Due to the straightforward comparison of colour values involved, this check is completed in constant time O(1).\\n\\n# Complexity\\n- Time complexity: O(V+E) \\nV -> number of vertices\\nE -> number of edges\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n          int n = graph.size();\\n          vector<int> color(n,-1);\\n           for(int i = 0; i < n; i++){\\n               if(!bfs(0, i, color, graph))\\n                return false;\\n           }\\n        return true;\\n    }\\n\\n    bool bfs(int A, int B, vector<int>& color , vector<vector<int>>& graph){\\n          queue<int> v;\\n          v.push(B);\\n          while(!v.empty()){\\n              int node = v.front();\\n              v.pop();\\n              for(auto edge:graph[node]){\\n                  if(color[edge] == -1){\\n                      color[edge] = !color[node];\\n                      v.push(edge);\\n                  }\\n                  else if(color[edge] == color[node])\\n                   return false;\\n              }\\n          }\\n        return true;  \\n    }\\n};\\n```\\n\\n# An Upvote will be encouraging \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n          int n = graph.size();\\n          vector<int> color(n,-1);\\n           for(int i = 0; i < n; i++){\\n               if(!bfs(0, i, color, graph))\\n                return false;\\n           }\\n        return true;\\n    }\\n\\n    bool bfs(int A, int B, vector<int>& color , vector<vector<int>>& graph){\\n          queue<int> v;\\n          v.push(B);\\n          while(!v.empty()){\\n              int node = v.front();\\n              v.pop();\\n              for(auto edge:graph[node]){\\n                  if(color[edge] == -1){\\n                      color[edge] = !color[node];\\n                      v.push(edge);\\n                  }\\n                  else if(color[edge] == color[node])\\n                   return false;\\n              }\\n          }\\n        return true;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540590,
                "title": "simple-two-hash-set-solution-c",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n*Given a graph, it can be said it is Bipartite if the nodes/vertices can divided into two groups such that no two noded/vertices in same group has an edge between them.*\\n\\n***We\\'ll use two hashsets to indicate two groups, left-nodes and right-nodes and use DFS approach for adding nodes to these hashsets alternatively*** and check if the current node and next node are in same hashset or not.. to decide if the graph is bi-partite or not.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) - as we need to visit all the nodes in the graph\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) - as we use hashsets to store the nodes\\n\\n![Screenshot 2023-05-19 110734.png](https://assets.leetcode.com/users/images/71eb9219-c30a-46c0-8bb3-749af2fb9936_1684474668.648534.png)\\n\\n\\n## Please upvote if you like the simple explaination and approach\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool IsBipartite(int[][] graph) {\\n        //let\\'s have two set of nodes, left and right\\n        HashSet<int> left = new HashSet<int>();\\n        HashSet<int> right = new HashSet<int>();\\n\\n        //to check if node is already visited or not.\\n        HashSet<int> visited = new HashSet<int>();\\n\\n        for (int i = 0; i < graph.Length; i++)\\n        {\\n            if (!visited.Contains(i))\\n            {\\n                visited.Add(i);\\n                left.Add(i);\\n                if (!DFS(i, graph, visited, left, right))\\n                    return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    private bool DFS(int node, int[][] graph, HashSet<int> visited, HashSet<int> h1, HashSet<int> h2)\\n    {\\n        for (int i = 0; i < graph[node].Length; i++)\\n        {\\n            //check if the next node is already present in same set as current node\\n            //return if present in same set\\n            if (h1.Contains(graph[node][i]))\\n                return false;\\n\\n            if (!visited.Contains(graph[node][i]))\\n            {\\n                visited.Add(graph[node][i]);\\n                h2.Add(graph[node][i]);\\n                //reversing h1 and h2 params here...\\n                bool result = DFS(graph[node][i], graph, visited, h2, h1);\\n                if (!result)\\n                    return result;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n\\n## Please upvote if you like the simple explaination and approach\\n![Upvote please.jpg](https://assets.leetcode.com/users/images/a18e90b3-a14d-4b6a-a7d1-f2b310fd5a78_1684474633.840097.jpeg)\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsBipartite(int[][] graph) {\\n        //let\\'s have two set of nodes, left and right\\n        HashSet<int> left = new HashSet<int>();\\n        HashSet<int> right = new HashSet<int>();\\n\\n        //to check if node is already visited or not.\\n        HashSet<int> visited = new HashSet<int>();\\n\\n        for (int i = 0; i < graph.Length; i++)\\n        {\\n            if (!visited.Contains(i))\\n            {\\n                visited.Add(i);\\n                left.Add(i);\\n                if (!DFS(i, graph, visited, left, right))\\n                    return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    private bool DFS(int node, int[][] graph, HashSet<int> visited, HashSet<int> h1, HashSet<int> h2)\\n    {\\n        for (int i = 0; i < graph[node].Length; i++)\\n        {\\n            //check if the next node is already present in same set as current node\\n            //return if present in same set\\n            if (h1.Contains(graph[node][i]))\\n                return false;\\n\\n            if (!visited.Contains(graph[node][i]))\\n            {\\n                visited.Add(graph[node][i]);\\n                h2.Add(graph[node][i]);\\n                //reversing h1 and h2 params here...\\n                bool result = DFS(graph[node][i], graph, visited, h2, h1);\\n                if (!result)\\n                    return result;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291467,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nUsing BFS\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool bfs(int node, int color, vector<vector<int>>& graph, vector <int>& visited) {\\n        queue <int> q;\\n        q.push(node);\\n        visited[node] = color;\\n        while (!q.empty()) {\\n            int curr = q.front();\\n            q.pop();\\n            for (auto adjNode: graph[curr]) {\\n                if (visited[adjNode] == -1) {\\n                    q.push(adjNode);\\n                    visited[adjNode] = !visited[curr];\\n                } else if (visited[adjNode] == visited[curr]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    } \\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector <int> visited(n, -1);\\n        for (int i = 0; i < n; i++) {\\n            if (visited[i] == -1) {\\n                if (bfs(i, 0, graph, visited) == false)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n# Approach 2\\nUsing DFS\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool dfs(int node, int color, vector<vector<int>>& graph, vector <int>& visited) {\\n        visited[node] = color;\\n        for (auto adjNode: graph[node]) {\\n            if (visited[adjNode] == -1) {\\n                if (dfs(adjNode, !color, graph, visited) == false)\\n                    return false;\\n            } else if (visited[adjNode] == color) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    } \\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector <int> visited(n, -1);\\n        for (int i = 0; i < n; i++) {\\n            if (visited[i] == -1) {\\n                if (dfs(i, 0, graph, visited) == false)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool bfs(int node, int color, vector<vector<int>>& graph, vector <int>& visited) {\\n        queue <int> q;\\n        q.push(node);\\n        visited[node] = color;\\n        while (!q.empty()) {\\n            int curr = q.front();\\n            q.pop();\\n            for (auto adjNode: graph[curr]) {\\n                if (visited[adjNode] == -1) {\\n                    q.push(adjNode);\\n                    visited[adjNode] = !visited[curr];\\n                } else if (visited[adjNode] == visited[curr]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    } \\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector <int> visited(n, -1);\\n        for (int i = 0; i < n; i++) {\\n            if (visited[i] == -1) {\\n                if (bfs(i, 0, graph, visited) == false)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    bool dfs(int node, int color, vector<vector<int>>& graph, vector <int>& visited) {\\n        visited[node] = color;\\n        for (auto adjNode: graph[node]) {\\n            if (visited[adjNode] == -1) {\\n                if (dfs(adjNode, !color, graph, visited) == false)\\n                    return false;\\n            } else if (visited[adjNode] == color) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    } \\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector <int> visited(n, -1);\\n        for (int i = 0; i < n; i++) {\\n            if (visited[i] == -1) {\\n                if (dfs(i, 0, graph, visited) == false)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719420,
                "title": "java-dfs-and-bfs-solution-easy-clean-code-with-comments",
                "content": "Upvote if you like!!!\\n\\nA graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B. As shown in the given below examples:\\n\\n![image](https://assets.leetcode.com/users/images/830b6318-f4d1-4d84-b423-81784c4c27a9_1666117733.194978.png)\\n\\n![image](https://assets.leetcode.com/users/images/b316b249-1419-456b-aaeb-2c8636f634e0_1666117760.3731892.png)\\n\\n\\n\\nSo this check for the bipartite graph can be done through both DFS and BFS on the given graph as shown below:\\n\\n\\n```\\nclass Solution {\\n    \\n    //this function is using BFS travesal to check bipartite\\n    private boolean isbfs(int[][] graph,int i,int[] color){\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(i);\\n        color[i]=1;\\n        while(!q.isEmpty()){\\n            Integer node = q.poll();\\n            for(int it : graph[node]){\\n                if(color[it]==-1){\\n                    q.add(it);\\n                    color[it]=1-color[node];\\n                }\\n                else{\\n                    if(color[it]==color[node]) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    //this function is using DFS travesal to check bipartite\\n    private boolean isdfs(int[][] graph,int node,int[] color){\\n        if(color[node]==-1) color[node]=1;\\n        for(int it: graph[node]){\\n            if(color[it]==-1){\\n                color[it]=1-color[node];\\n                if(!isdfs(graph,it,color)) return false;\\n            }\\n            else{\\n                if(color[it]==color[node]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    \\n    //function to check bipartite\\n    public boolean isBipartite(int[][] graph) {\\n        int n = graph.length;\\n        int color[] = new int[n];\\n        Arrays.fill(color,-1);\\n        for(int i=0;i<n;i++){\\n            if(color[i]==-1){\\n            // if(!isdfs(graph,i,color)) return false;  //bfs\\n                if(!isdfs(graph,i,color)) return false; //dfs\\n                \\n            }\\n        }\\n        return true;\\n    }\\n    \\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //this function is using BFS travesal to check bipartite\\n    private boolean isbfs(int[][] graph,int i,int[] color){\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(i);\\n        color[i]=1;\\n        while(!q.isEmpty()){\\n            Integer node = q.poll();\\n            for(int it : graph[node]){\\n                if(color[it]==-1){\\n                    q.add(it);\\n                    color[it]=1-color[node];\\n                }\\n                else{\\n                    if(color[it]==color[node]) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    //this function is using DFS travesal to check bipartite\\n    private boolean isdfs(int[][] graph,int node,int[] color){\\n        if(color[node]==-1) color[node]=1;\\n        for(int it: graph[node]){\\n            if(color[it]==-1){\\n                color[it]=1-color[node];\\n                if(!isdfs(graph,it,color)) return false;\\n            }\\n            else{\\n                if(color[it]==color[node]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    \\n    //function to check bipartite\\n    public boolean isBipartite(int[][] graph) {\\n        int n = graph.length;\\n        int color[] = new int[n];\\n        Arrays.fill(color,-1);\\n        for(int i=0;i<n;i++){\\n            if(color[i]==-1){\\n            // if(!isdfs(graph,i,color)) return false;  //bfs\\n                if(!isdfs(graph,i,color)) return false; //dfs\\n                \\n            }\\n        }\\n        return true;\\n    }\\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1992143,
                "title": "1ms-runtime-java-solution-non-recursive-easy-to-understand-graph-coloring-clean-code",
                "content": "This can be solved using graph coloring. A graph is bipartitie if nodes inside graph can be divivded into 2 sets in such a way  there is no edge between nodes within the same set.\\n\\nOr\\n\\nThere does not exists a cycle with odd number of vertex.\\n\\nBoth of the above condition can be verified by checking the posiblity to color each vertex in such a way that no\\n2 adjecent vertex have same color.\\n\\nPlease have a look at the following code which is a variation of bfs traversal.\\n\\nWe are trying to color nodes level by level and in doing so if some vertex is already colored then it should have value other then the one assigned for current level.\\n\\n\\n```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        \\n        int color[] = new int[graph.length];\\n        Arrays.fill(color,-1);\\n        \\n        for(int i=0;i<color.length;i++) {\\n            if(color[i]==-1) {\\n                boolean isBipartite = fillcolor(i,color,graph);\\n                if(!isBipartite)\\n                    return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n    \\n    public boolean fillcolor(int i,int color[],int graph[][]) {        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(i);\\n        color[i] = 0;\\n        \\n        while(!queue.isEmpty()) {\\n            int nodeCount = queue.size();\\n            \\n            while(nodeCount>0) {\\n             int u = queue.remove();\\n             int adjArray[] = graph[u];\\n                \\n             for(int v:adjArray) {\\n                 if(color[v]==-1) {\\n                     color[v]=1-color[u];\\n                     queue.add(v);\\n                 }else {\\n                     if(color[v]==color[u])\\n                         return false;                     \\n                 }\\n             }\\n                \\n             nodeCount--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```\\n\\nT(n) =. O(V+E)\\nS(n)=   O(V)\\n\\nCheers!!!!!",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        \\n        int color[] = new int[graph.length];\\n        Arrays.fill(color,-1);\\n        \\n        for(int i=0;i<color.length;i++) {\\n            if(color[i]==-1) {\\n                boolean isBipartite = fillcolor(i,color,graph);\\n                if(!isBipartite)\\n                    return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n    \\n    public boolean fillcolor(int i,int color[],int graph[][]) {        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(i);\\n        color[i] = 0;\\n        \\n        while(!queue.isEmpty()) {\\n            int nodeCount = queue.size();\\n            \\n            while(nodeCount>0) {\\n             int u = queue.remove();\\n             int adjArray[] = graph[u];\\n                \\n             for(int v:adjArray) {\\n                 if(color[v]==-1) {\\n                     color[v]=1-color[u];\\n                     queue.add(v);\\n                 }else {\\n                     if(color[v]==color[u])\\n                         return false;                     \\n                 }\\n             }\\n                \\n             nodeCount--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1991184,
                "title": "java-clean-union-find",
                "content": "```\\npublic boolean isBipartite(int[][] graph) {\\n        UnionFind uf = new UnionFind(graph.length);\\n\\n        for (int i = 0; i < graph.length; i++) {\\n            int[] edges = graph[i];\\n            for (int node : edges) {\\n                if (uf.find(i) == uf.find(node))\\n                    return false;\\n                uf.union(edges[0], node);\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    public static class UnionFind {\\n\\n        private final int[] root;\\n\\n        public UnionFind(int size) {\\n            this.root = new int[size];\\n            for (int i = 0; i < size; i++) {\\n                root[i] = i;\\n            }\\n        }\\n\\n        public int find(int node) {\\n            if (root[node] == node)\\n                return node;\\n            return find(root[node]);\\n        }\\n\\n        public void union(int node1, int node2) {\\n            int root1 = find(node1);\\n            int root2 = find(node2);\\n\\n            if (root1 != root2) {\\n                root[root1] = root2;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\npublic boolean isBipartite(int[][] graph) {\\n        UnionFind uf = new UnionFind(graph.length);\\n\\n        for (int i = 0; i < graph.length; i++) {\\n            int[] edges = graph[i];\\n            for (int node : edges) {\\n                if (uf.find(i) == uf.find(node))\\n                    return false;\\n                uf.union(edges[0], node);\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    public static class UnionFind {\\n\\n        private final int[] root;\\n\\n        public UnionFind(int size) {\\n            this.root = new int[size];\\n            for (int i = 0; i < size; i++) {\\n                root[i] = i;\\n            }\\n        }\\n\\n        public int find(int node) {\\n            if (root[node] == node)\\n                return node;\\n            return find(root[node]);\\n        }\\n\\n        public void union(int node1, int node2) {\\n            int root1 = find(node1);\\n            int root2 = find(node2);\\n\\n            if (root1 != root2) {\\n                root[root1] = root2;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1991166,
                "title": "100-faster-java-two-method-dfs-bfs",
                "content": "```\\n//Graph Coloring - DFS\\n//0==no color\\n//1=blue\\n//-1=red color\\nclass Solution {\\n    public boolean isBipartite(int[][] g) {\\n        int[] colors = new int[g.length];\\n        for (int i = 0; i < g.length; i++)\\n            if (colors[i] == 0 && !validColor(g, colors, 1, i))\\n                return false;\\n        return true;\\n    }\\n\\n    boolean validColor(int[][] g, int[] colors, int color, int node) {\\n        if (colors[node] != 0)\\n            return colors[node] == color;\\n        colors[node] = color;\\n        for (int adjacent : g[node])\\n            if (!validColor(g, colors, -color, adjacent))\\n                return false;\\n        return true;\\n    }\\n    \\n}\\n\\n\\n\\n//Graph Coloring - BFS\\n\\nclass Solution {\\n    public boolean isBipartite(int[][] g) {\\n        int[] colors = new int[g.length];\\n        for (int i = 0; i < g.length; i++)\\n            if (colors[i] == 0) {\\n                Queue<Integer> q = new LinkedList<>();\\n                q.add(i);\\n                colors[i] = 1;\\n                while (!q.isEmpty()) {\\n                    Integer node = q.poll();\\n                    for (int adjacent : g[node])\\n                        if (colors[adjacent] == colors[node])\\n                            return false;\\n                        else if (colors[adjacent] == 0) {\\n                            q.add(adjacent);\\n                            colors[adjacent] = -colors[node];\\n                        }\\n                }\\n            }\\n        return true;\\n    }\\n}\\n\\n```\\n\\nif it is helpful upvote please",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\n//Graph Coloring - DFS\\n//0==no color\\n//1=blue\\n//-1=red color\\nclass Solution {\\n    public boolean isBipartite(int[][] g) {\\n        int[] colors = new int[g.length];\\n        for (int i = 0; i < g.length; i++)\\n            if (colors[i] == 0 && !validColor(g, colors, 1, i))\\n                return false;\\n        return true;\\n    }\\n\\n    boolean validColor(int[][] g, int[] colors, int color, int node) {\\n        if (colors[node] != 0)\\n            return colors[node] == color;\\n        colors[node] = color;\\n        for (int adjacent : g[node])\\n            if (!validColor(g, colors, -color, adjacent))\\n                return false;\\n        return true;\\n    }\\n    \\n}\\n\\n\\n\\n//Graph Coloring - BFS\\n\\nclass Solution {\\n    public boolean isBipartite(int[][] g) {\\n        int[] colors = new int[g.length];\\n        for (int i = 0; i < g.length; i++)\\n            if (colors[i] == 0) {\\n                Queue<Integer> q = new LinkedList<>();\\n                q.add(i);\\n                colors[i] = 1;\\n                while (!q.isEmpty()) {\\n                    Integer node = q.poll();\\n                    for (int adjacent : g[node])\\n                        if (colors[adjacent] == colors[node])\\n                            return false;\\n                        else if (colors[adjacent] == 0) {\\n                            q.add(adjacent);\\n                            colors[adjacent] = -colors[node];\\n                        }\\n                }\\n            }\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990803,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n***Java***\\n```\\nclass Solution{\\n    public boolean isBipartite(int[][] graph) {\\n        int n = graph.length;\\n        int[] colors = new int[n];\\n\\n        //take two colors and color adjacent neighbours differently, if any of the neighbour is already colored and is not a different color, but same color, then return false else true.\\n        for (int i = 0; i < n; i++) {\\n            if (colors[i] == 0) { //if not yet coloured.\\n                Queue<Integer> q = new LinkedList<>();\\n                q.add(i);\\n                colors[i] = 1; //color it with blue\\n\\n                while (!q.isEmpty()) {\\n                    int cur = q.poll(); //start polling the current node\\n\\n                    for (int x : graph[cur]) {\\n                        if (colors[x] == 0) { //if not yet colored\\n                            colors[x] = -colors[cur]; // Use a different color for the adjacent node\\n                            q.offer(x);\\n                        } else if (colors[x] != -colors[cur])//if the adjacent node/neighbour is already coloured and not a different colour, we return false, as no two adjacent vertices must have same colors.\\n                            return false;\\n                    }\\n                }\\n\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n***C++***\\n```\\nclass Solution {\\npublic:\\n    vector<int>vis,col;\\n    bool dfs(int v, int c, vector<vector<int>>& graph){\\n        vis[v]=1;\\n        col[v]=c;\\n        for(int child:graph[v]){\\n            if(vis[child]==0){\\n                // here c^1 is for flipping 1 by 0 or 0 by 1, that is flip the current color\\n                if(dfs(child,c^1,graph)==false) \\n                    return false;\\n            }\\n            else{\\n                if(col[v]==col[child])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        vis.resize(n);\\n        col.resize(n);\\n\\n        for(int i=0;i<n;++i){\\n            if(vis[i]==0 && dfs(i,0,graph)==false){ \\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n\\n***Python***\\n```\\nclass Solution:\\n\\n    def isBipartite(self, graph: list[list[int]]) -> bool:\\n\\t\\n        vis = [False for n in range(0, len(graph))]\\n        \\n        while sum(vis) != len(graph): # Since graph isn\\'t required to be connected this process needs to be repeated\\n\\n            ind = vis.index(False) # Find the first entry in the visited list that is false\\n            vis[ind] = True\\n            grp = {ind:True} # initialize first node as part of group 1\\n            q = [ind] # Add current index to queue\\n            \\n            while q: # Go to each node in the graph\\n                u = q.pop(0)\\n\\n                for v in graph[u]: # Go to each vertice connected to the current node\\n\\n                    if vis[v] == True: #  If visited check that it is in the opposite group of the current node\\n                        if grp[u] == grp[v]:\\n                            return False # If a single edge does not lead to a group change return false\\n\\n                    else: # If not visited put v in opposite group of u, set to visited, and append to q\\n                        vis[v] = True\\n                        grp[v] = not grp[u]\\n                        q.append(v)\\n        \\n        return True\\n```\\n\\n***JavaScript***\\n```\\nvar isBipartite = function(graph) {\\n    const n = graph.length;\\n    const color = Array(n).fill(0);\\n    \\n    for(let i = 0; i < n; i++) {\\n        if(color[i]) continue;\\n        const queue = [i];\\n        color[i] = 1;\\n        \\n        while(queue.length) {\\n            const curr = queue.shift();\\n\\n            for(let next of graph[curr]) {\\n                if(color[next] === color[curr]) return false;\\n                if(!color[next]) {\\n                    color[next] = color[curr] === 1 ? 2 : 1;\\n                    queue.push(next);\\n                }\\n            }\\n        }\\n    }\\n    return true;    \\n};\\n```\\n\\n***Kotlin***\\n```\\nclass Solution {\\n    val check = IntArray(101) { -1 }\\n    var ans = true\\n\\n    fun isBipartite(graph: Array<IntArray>): Boolean {\\n        for(i in graph.indices) {\\n            if (check[i] == -1) dfs(graph, i, 0)\\n        }\\n\\n        return ans\\n    }\\n    fun dfs(graph: Array<IntArray>, node: Int, type: Int) {\\n        if (check[node] != -1) return \\n        check[node] = type\\n        \\n        for(n in graph[node]) {\\n            if (check[n] == -1) {\\n                dfs(graph, n, type xor 1)\\n            } else if (check[n] == check[node]) {\\n                ans = false\\n            }\\n        }\\n    }\\n}\\n```\\n\\n***Swift***\\n```\\nclass Solution {\\n    func isBipartite(_ graph: [[Int]]) -> Bool {\\n        guard !graph.isEmpty else { return false }\\n        let len = graph.count\\n        var colors = [Int](repeating: -1, count: len)\\n        \\n        func dfs(_ graph: [[Int]], _ color: Int, _ i: Int) -> Bool {\\n            if colors[i] != -1 { return colors[i] == color }\\n            colors[i] = color\\n            for n in graph[i] where !dfs(graph, 1 - color, n) {\\n                return false\\n            }\\n            return true\\n        }\\n        for i in 0..<len where colors[i] == -1 && !dfs(graph, 0, i) {\\n            return false\\n        }\\n        return true\\n    }\\n}\\n```\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***\\n***\"Open your eyes.\"***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution{\\n    public boolean isBipartite(int[][] graph) {\\n        int n = graph.length;\\n        int[] colors = new int[n];\\n\\n        //take two colors and color adjacent neighbours differently, if any of the neighbour is already colored and is not a different color, but same color, then return false else true.\\n        for (int i = 0; i < n; i++) {\\n            if (colors[i] == 0) { //if not yet coloured.\\n                Queue<Integer> q = new LinkedList<>();\\n                q.add(i);\\n                colors[i] = 1; //color it with blue\\n\\n                while (!q.isEmpty()) {\\n                    int cur = q.poll(); //start polling the current node\\n\\n                    for (int x : graph[cur]) {\\n                        if (colors[x] == 0) { //if not yet colored\\n                            colors[x] = -colors[cur]; // Use a different color for the adjacent node\\n                            q.offer(x);\\n                        } else if (colors[x] != -colors[cur])//if the adjacent node/neighbour is already coloured and not a different colour, we return false, as no two adjacent vertices must have same colors.\\n                            return false;\\n                    }\\n                }\\n\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int>vis,col;\\n    bool dfs(int v, int c, vector<vector<int>>& graph){\\n        vis[v]=1;\\n        col[v]=c;\\n        for(int child:graph[v]){\\n            if(vis[child]==0){\\n                // here c^1 is for flipping 1 by 0 or 0 by 1, that is flip the current color\\n                if(dfs(child,c^1,graph)==false) \\n                    return false;\\n            }\\n            else{\\n                if(col[v]==col[child])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        vis.resize(n);\\n        col.resize(n);\\n\\n        for(int i=0;i<n;++i){\\n            if(vis[i]==0 && dfs(i,0,graph)==false){ \\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution:\\n\\n    def isBipartite(self, graph: list[list[int]]) -> bool:\\n\\t\\n        vis = [False for n in range(0, len(graph))]\\n        \\n        while sum(vis) != len(graph): # Since graph isn\\'t required to be connected this process needs to be repeated\\n\\n            ind = vis.index(False) # Find the first entry in the visited list that is false\\n            vis[ind] = True\\n            grp = {ind:True} # initialize first node as part of group 1\\n            q = [ind] # Add current index to queue\\n            \\n            while q: # Go to each node in the graph\\n                u = q.pop(0)\\n\\n                for v in graph[u]: # Go to each vertice connected to the current node\\n\\n                    if vis[v] == True: #  If visited check that it is in the opposite group of the current node\\n                        if grp[u] == grp[v]:\\n                            return False # If a single edge does not lead to a group change return false\\n\\n                    else: # If not visited put v in opposite group of u, set to visited, and append to q\\n                        vis[v] = True\\n                        grp[v] = not grp[u]\\n                        q.append(v)\\n        \\n        return True\\n```\n```\\nvar isBipartite = function(graph) {\\n    const n = graph.length;\\n    const color = Array(n).fill(0);\\n    \\n    for(let i = 0; i < n; i++) {\\n        if(color[i]) continue;\\n        const queue = [i];\\n        color[i] = 1;\\n        \\n        while(queue.length) {\\n            const curr = queue.shift();\\n\\n            for(let next of graph[curr]) {\\n                if(color[next] === color[curr]) return false;\\n                if(!color[next]) {\\n                    color[next] = color[curr] === 1 ? 2 : 1;\\n                    queue.push(next);\\n                }\\n            }\\n        }\\n    }\\n    return true;    \\n};\\n```\n```\\nclass Solution {\\n    val check = IntArray(101) { -1 }\\n    var ans = true\\n\\n    fun isBipartite(graph: Array<IntArray>): Boolean {\\n        for(i in graph.indices) {\\n            if (check[i] == -1) dfs(graph, i, 0)\\n        }\\n\\n        return ans\\n    }\\n    fun dfs(graph: Array<IntArray>, node: Int, type: Int) {\\n        if (check[node] != -1) return \\n        check[node] = type\\n        \\n        for(n in graph[node]) {\\n            if (check[n] == -1) {\\n                dfs(graph, n, type xor 1)\\n            } else if (check[n] == check[node]) {\\n                ans = false\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func isBipartite(_ graph: [[Int]]) -> Bool {\\n        guard !graph.isEmpty else { return false }\\n        let len = graph.count\\n        var colors = [Int](repeating: -1, count: len)\\n        \\n        func dfs(_ graph: [[Int]], _ color: Int, _ i: Int) -> Bool {\\n            if colors[i] != -1 { return colors[i] == color }\\n            colors[i] = color\\n            for n in graph[i] where !dfs(graph, 1 - color, n) {\\n                return false\\n            }\\n            return true\\n        }\\n        for i in 0..<len where colors[i] == -1 && !dfs(graph, 0, i) {\\n            return false\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990528,
                "title": "java-dfs-easy-solution-100-faster",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int len = graph.length;\\n        boolean[] set1 = new boolean[len];\\n        boolean[] set2 = new boolean[len];\\n        \\n        for (int i = 0; i < len; ++i) {\\n            if (set1[i] || set2[i]) continue;\\n            if (!dfs(i, set1, set2, graph)) return false;\\n        }\\n        return true;\\n    }\\n    \\n    private boolean dfs(int index, boolean[] set1, boolean[] set2, int[][] graph) {\\n        if (set1[index]) return !set2[index];\\n        set1[index] = true;\\n        for (int n : graph[index]) {\\n            if (!dfs(n, set2, set1, graph)) return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int len = graph.length;\\n        boolean[] set1 = new boolean[len];\\n        boolean[] set2 = new boolean[len];\\n        \\n        for (int i = 0; i < len; ++i) {\\n            if (set1[i] || set2[i]) continue;\\n            if (!dfs(i, set1, set2, graph)) return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1094052,
                "title": "c-dfs-graph-coloring",
                "content": "**Note:**  Graph color is represented in 0 and 1.\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>> &graph, int cur, int clr, vector<int> &color){\\n        color[cur] = clr;\\n        for(auto &child : graph[cur]){\\n            if(color[child] != -1){\\n                if(clr == color[child]) return false;\\n            }else{\\n                if(dfs(graph, child, abs(clr-1), color) == false) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<int> color(n,-1);\\n        \\n        for(int i=0; i<n; ++i){\\n            if(color[i]==-1){\\n                if(dfs(graph,i,0,color) == false) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>> &graph, int cur, int clr, vector<int> &color){\\n        color[cur] = clr;\\n        for(auto &child : graph[cur]){\\n            if(color[child] != -1){\\n                if(clr == color[child]) return false;\\n            }else{\\n                if(dfs(graph, child, abs(clr-1), color) == false) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<int> color(n,-1);\\n        \\n        for(int i=0; i<n; ++i){\\n            if(color[i]==-1){\\n                if(dfs(graph,i,0,color) == false) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065181,
                "title": "c-unionfind-dsu",
                "content": "```\\nclass Solution {\\npublic:\\n    class UnionFind;\\n    \\n    bool isBipartite(vector<vector<int>>& graph) {\\n        UnionFind uf(graph.size());\\n        // All nodes from graph[i] should be in one union.\\n        // And this union should be different from the union for i node.\\n        for (int i = 0; i < graph.size(); ++i){\\n            for (int j = 0; j + 1 < graph[i].size(); ++j){\\n                uf.Union(graph[i][j], graph[i][j + 1]);\\n            }\\n        }\\n        \\n        // Check that each edge contains nodes from different unions\\n        for (int i = 0; i < graph.size(); ++i){\\n            for (int j = 0; j < graph[i].size(); ++j){\\n                if(uf.Connected(i, graph[i][j]))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    class UnionFind {\\n        public:\\n            UnionFind(int n) : id(n), sz(n, 1) {\\n                iota(id.begin(), id.end(), 0);\\n            }\\n            \\n            int Root(int i){\\n                if (id[i] == i){\\n                    return i;\\n                }\\n                return id[i] = Root(id[i]);\\n            }\\n        \\n            bool Connected(int i, int j){\\n                return Root(i) == Root(j);\\n            }\\n        \\n            void Union(int i, int j){\\n                i = Root(i);\\n                j = Root(j);\\n                if (i != j){\\n                    if (sz[i] < sz[j])\\n                        swap(i, j);\\n                    id[j] = i;\\n                    sz[i] += sz[j];\\n                }\\n            }\\n        \\n        private:\\n            vector<int> id;\\n            vector<int> sz;\\n    };\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    class UnionFind;\\n    \\n    bool isBipartite(vector<vector<int>>& graph) {\\n        UnionFind uf(graph.size());\\n        // All nodes from graph[i] should be in one union.\\n        // And this union should be different from the union for i node.\\n        for (int i = 0; i < graph.size(); ++i){\\n            for (int j = 0; j + 1 < graph[i].size(); ++j){\\n                uf.Union(graph[i][j], graph[i][j + 1]);\\n            }\\n        }\\n        \\n        // Check that each edge contains nodes from different unions\\n        for (int i = 0; i < graph.size(); ++i){\\n            for (int j = 0; j < graph[i].size(); ++j){\\n                if(uf.Connected(i, graph[i][j]))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    class UnionFind {\\n        public:\\n            UnionFind(int n) : id(n), sz(n, 1) {\\n                iota(id.begin(), id.end(), 0);\\n            }\\n            \\n            int Root(int i){\\n                if (id[i] == i){\\n                    return i;\\n                }\\n                return id[i] = Root(id[i]);\\n            }\\n        \\n            bool Connected(int i, int j){\\n                return Root(i) == Root(j);\\n            }\\n        \\n            void Union(int i, int j){\\n                i = Root(i);\\n                j = Root(j);\\n                if (i != j){\\n                    if (sz[i] < sz[j])\\n                        swap(i, j);\\n                    id[j] = i;\\n                    sz[i] += sz[j];\\n                }\\n            }\\n        \\n        private:\\n            vector<int> id;\\n            vector<int> sz;\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 852593,
                "title": "c-submission-beats-100",
                "content": "I barely see any discussion of \\'C\\' code. So, posting mine. Hope it helps someone.\\n\\n```\\nbool\\nisBipartite(int **G, int n, int *cols)\\n{\\n    int u = 0, v = 0;\\n    int top = 0;\\n    int *Q = calloc(n, sizeof(int));\\n    int *color = calloc(n, sizeof(int));\\n    int *visited = calloc(n, sizeof(int));\\n    int *enqueued = calloc(n, sizeof(int));\\n    \\n\\t/* Run a BFS from every node that is still unvisited. */\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (visited[i]) continue;\\n        color[i] = 1;\\n        Q[top++] = i;\\n        \\n        while (top)\\n        {\\n            u = Q[--top];\\n            enqueued[u] = 0;\\n            visited[u] = 1;\\n\\t\\t\\t\\n\\t\\t\\t/* Visit each neighbor of u. */\\n            for (int j = 0; j < cols[u]; j++)\\n            {\\n                v = G[u][j];\\n                if (visited[v]) continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t/* If u and v are the same color, then the graph is not bipartite. */\\n                if (color[u] == color[v]) return false;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t/* Else set v to the opposite color of u. */\\n                color[v] = -color[u];\\n\\t\\t\\t\\t\\n                /* Check if a node has been already enqueued. If we don\\'t check, our Q might have\\n\\t\\t\\t\\t * to hold many nodes multiple times increasing our memory requirement.\\n\\t\\t\\t\\t */\\n\\t\\t\\t\\tif (enqueued[v]) continue;\\n\\t\\t\\t\\t\\n                Q[top++] = v;\\n                enqueued[v] = 1;\\n            }\\n        }\\n    }\\n    \\n\\treturn true;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nbool\\nisBipartite(int **G, int n, int *cols)\\n{\\n    int u = 0, v = 0;\\n    int top = 0;\\n    int *Q = calloc(n, sizeof(int));\\n    int *color = calloc(n, sizeof(int));\\n    int *visited = calloc(n, sizeof(int));\\n    int *enqueued = calloc(n, sizeof(int));\\n    \\n\\t/* Run a BFS from every node that is still unvisited. */\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (visited[i]) continue;\\n        color[i] = 1;\\n        Q[top++] = i;\\n        \\n        while (top)\\n        {\\n            u = Q[--top];\\n            enqueued[u] = 0;\\n            visited[u] = 1;\\n\\t\\t\\t\\n\\t\\t\\t/* Visit each neighbor of u. */\\n            for (int j = 0; j < cols[u]; j++)\\n            {\\n                v = G[u][j];\\n                if (visited[v]) continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t/* If u and v are the same color, then the graph is not bipartite. */\\n                if (color[u] == color[v]) return false;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t/* Else set v to the opposite color of u. */\\n                color[v] = -color[u];\\n\\t\\t\\t\\t\\n                /* Check if a node has been already enqueued. If we don\\'t check, our Q might have\\n\\t\\t\\t\\t * to hold many nodes multiple times increasing our memory requirement.\\n\\t\\t\\t\\t */\\n\\t\\t\\t\\tif (enqueued[v]) continue;\\n\\t\\t\\t\\t\\n                Q[top++] = v;\\n                enqueued[v] = 1;\\n            }\\n        }\\n    }\\n    \\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 723147,
                "title": "simple-c-solution-is-graph-bipartite",
                "content": "```\\n// For Bipartite graph if we color the whole graph with 2 different colors with each adjacent vertex with diffent color\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        vector<int> color(n);                          // 0: uncolored, 1: color A, -1: color B\\n        queue<int> q; \\n        for(int i=0;i<n;i++) {\\n            if(color[i]) continue;  // skip already colored nodes with(1 or -1)\\n            color[i]=1;                                // color i with A \\n            q.push(i);\\n            while(!q.empty()) {\\n                int cur=q.front();\\n                q.pop();\\n                for(int child: graph[cur]) {\\n                    if(!color[child]) {                // if uncolored \\n                        color[child]=-color[cur];      // color with the opposite color\\n                        q.push(child); \\n                    } \\n                    else if(color[child]==color[cur]) { // if already colored with same color\\n                        return false;\\n                    }\\n                }        \\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n// For Bipartite graph if we color the whole graph with 2 different colors with each adjacent vertex with diffent color\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        vector<int> color(n);                          // 0: uncolored, 1: color A, -1: color B\\n        queue<int> q; \\n        for(int i=0;i<n;i++) {\\n            if(color[i]) continue;  // skip already colored nodes with(1 or -1)\\n            color[i]=1;                                // color i with A \\n            q.push(i);\\n            while(!q.empty()) {\\n                int cur=q.front();\\n                q.pop();\\n                for(int child: graph[cur]) {\\n                    if(!color[child]) {                // if uncolored \\n                        color[child]=-color[cur];      // color with the opposite color\\n                        q.push(child); \\n                    } \\n                    else if(color[child]==color[cur]) { // if already colored with same color\\n                        return false;\\n                    }\\n                }        \\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 558363,
                "title": "c-short-clear-dfs-solution-97-100",
                "content": "```\\nclass Solution {\\n    public:\\n        bool isBipartite(vector<vector<int>>& graph) \\n        {\\n            vector<int> groups(graph.size()); // two groups are 1 and -1 (0 - unassigned)\\n            for(int i = 0; i < graph.size(); ++i)\\n                if(groups[i] == 0 && !assign_group(graph, i, 1, groups)) \\n                    return false;\\n            return true;\\n        }\\n    \\n    protected:\\n        bool assign_group(vector<vector<int>>& graph, int i, int group, vector<int>& groups)\\n        {\\n            if(groups[i] == -group) return false; // cannot assign\\n            if(groups[i] == group) return true; // already correctly assigned\\n            groups[i] = group;\\n            for(int n : graph[i]) // assign all \\'children\\' to the opposite group\\n                if(!assign_group(graph, n, -group, groups)) return false; \\n            return true;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n        bool isBipartite(vector<vector<int>>& graph) \\n        {\\n            vector<int> groups(graph.size()); // two groups are 1 and -1 (0 - unassigned)\\n            for(int i = 0; i < graph.size(); ++i)\\n                if(groups[i] == 0 && !assign_group(graph, i, 1, groups)) \\n                    return false;\\n            return true;\\n        }\\n    \\n    protected:\\n        bool assign_group(vector<vector<int>>& graph, int i, int group, vector<int>& groups)\\n        {\\n            if(groups[i] == -group) return false; // cannot assign\\n            if(groups[i] == group) return true; // already correctly assigned\\n            groups[i] = group;\\n            for(int n : graph[i]) // assign all \\'children\\' to the opposite group\\n                if(!assign_group(graph, n, -group, groups)) return false; \\n            return true;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 380846,
                "title": "10-lines-simple-c-solution-using-node-coloring-technique-o-v-e-time-o-v-space",
                "content": "\\n\\tbool isBipartite (vector<vector<int>>& graph) {\\n        int color[graph.size()] = {0};   \\n        color[0] = 1;\\n        \\n        for(int i = 0; i < graph.size(); ++i){\\n            for(int j = 0 ; j < graph[i].size(); ++j){\\n                if(color[graph[i][j]] == 0){\\n                    color[graph[i][j]] = ~color[i];\\n                }else if(color[graph[i][j]] == color[i]){\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n\\t\\n",
                "solutionTags": [],
                "code": "\\n\\tbool isBipartite (vector<vector<int>>& graph) {\\n        int color[graph.size()] = {0};   \\n        color[0] = 1;\\n        \\n        for(int i = 0; i < graph.size(); ++i){\\n            for(int j = 0 ; j < graph[i].size(); ++j){\\n                if(color[graph[i][j]] == 0){\\n                    color[graph[i][j]] = ~color[i];\\n                }else if(color[graph[i][j]] == color[i]){\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n\\t\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 364424,
                "title": "java-dfs-detect-odd-number-of-nodes-in-a-ring",
                "content": "# **Conclusion:**\\n**If a ring has odd number of nodes, it must can\\'t be seperate into two parts.**\\n\\nUsing an array to save the depth of all parent nodes.\\nThen use dfs to detect all rings in the graph.\\nIf we get one ring with odd nodes return false immediately.\\n\\n```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int[] count = new int[graph.length];\\n        for(int i = 0; i < graph.length; i++) {\\n            if(count[i] == 0 && !dfs(graph, count, i, 1)) return false;\\n        }\\n        return true;\\n    }\\n    \\n    public boolean dfs(int[][] graph, int[] count, int point, int deep) {\\n        count[point] = deep;\\n        int[] cur = graph[point];\\n        for(int i : cur) {\\n            if(count[i] != 0) {\\n                if((count[i] - deep)%2 == 0) return false;\\n            } else {\\n                if(!dfs(graph, count, i, deep + 1)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int[] count = new int[graph.length];\\n        for(int i = 0; i < graph.length; i++) {\\n            if(count[i] == 0 && !dfs(graph, count, i, 1)) return false;\\n        }\\n        return true;\\n    }\\n    \\n    public boolean dfs(int[][] graph, int[] count, int point, int deep) {\\n        count[point] = deep;\\n        int[] cur = graph[point];\\n        for(int i : cur) {\\n            if(count[i] != 0) {\\n                if((count[i] - deep)%2 == 0) return false;\\n            } else {\\n                if(!dfs(graph, count, i, deep + 1)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 269084,
                "title": "python-concise-dfs",
                "content": "Similiar as #886, a typical bipartite problem.\\nWe use DFS to check each node. In each DFS path, any two neighboring nodes can\\'t be in the same group. \\nE.g. suppose there are two groups {0,1}. If x is in group g, all of its children nodes should be in group 1-g.\\nIf there is any group conflict, the graph can\\'t be bipartite.\\n```\\ndef isBipartite(graph):\\n\\tgroup = {}\\n\\tdef dfs(x, g):\\n\\t\\tif x in group: \\n\\t\\t\\treturn g == group[x]\\n\\t\\tgroup[x] = g\\n\\t\\treturn all(dfs(y, 1-g) for y in graph[x])\\n\\treturn all(dfs(x, 0) for x in range(len(graph)) if x not in group)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef isBipartite(graph):\\n\\tgroup = {}\\n\\tdef dfs(x, g):\\n\\t\\tif x in group: \\n\\t\\t\\treturn g == group[x]\\n\\t\\tgroup[x] = g\\n\\t\\treturn all(dfs(y, 1-g) for y in graph[x])\\n\\treturn all(dfs(x, 0) for x in range(len(graph)) if x not in group)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 176366,
                "title": "concise-dfs-solution-java",
                "content": "```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        if (graph == null) return true;\\n        boolean[] A = new boolean[graph.length];\\n        boolean[] B = new boolean[graph.length];\\n        \\n        for (int x = 0; x < graph.length; x++) {\\n            if (!A[x] && !B[x] && !helpMe(graph, x, A, B)) return false; \\n        }\\n        return true;\\n    }\\n    \\n    private boolean helpMe(int[][] graph, int x, boolean[] A, boolean[] B) {\\n        if (A[x]) return true;\\n        if (B[x]) return false;\\n        \\n        A[x] = true;\\n        for (int y : graph[x]) {\\n            if (!helpMe(graph, y, B, A)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        if (graph == null) return true;\\n        boolean[] A = new boolean[graph.length];\\n        boolean[] B = new boolean[graph.length];\\n        \\n        for (int x = 0; x < graph.length; x++) {\\n            if (!A[x] && !B[x] && !helpMe(graph, x, A, B)) return false; \\n        }\\n        return true;\\n    }\\n    \\n    private boolean helpMe(int[][] graph, int x, boolean[] A, boolean[] B) {\\n        if (A[x]) return true;\\n        if (B[x]) return false;\\n        \\n        A[x] = true;\\n        for (int y : graph[x]) {\\n            if (!helpMe(graph, y, B, A)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 156544,
                "title": "c-union-find-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    map<int,int>m;\\n    int parent(int a)\\n    {\\n        if(m.count(a)==0)return -1;\\n        if(m[a]==a)return a;\\n        return parent(m[a]);\\n    }\\n    \\n    bool isBipartite(vector<vector<int>>& graph) {\\n \\n        int n=graph.size();\\n        int parenta,parentb;\\n        int x,y;// x,y denote the head vertices which represent the 2 sets\\n        for(int i=0;i<n;i++)\\n        {\\n            parenta=parent(i);\\n            for(int j:graph[i])\\n            {\\n                parentb=parent(j);\\n                if(parenta==-1 && parentb==-1)//for the first edge\\n                {\\n                    m[i]=i;\\n                    m[j]=j;\\n                    parenta=i;\\n                    parentb=j;\\n                    x=i;y=j;\\n                }\\n                else if(parenta==parentb)\\n                {\\n                    return false;\\n                }\\n                else if(parenta==-1)\\n                {\\n                    if(parentb==x)m[i]=y;\\n                    else m[i]=x;\\n                }\\n                else if(parentb==-1)\\n                {\\n                    if(parenta==x)m[j]=y;\\n                    else m[j]=x;\\n                }\\n                else\\n                {\\n                    m[i]=parenta;\\n                    m[j]=parentb;\\n                }\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,int>m;\\n    int parent(int a)\\n    {\\n        if(m.count(a)==0)return -1;\\n        if(m[a]==a)return a;\\n        return parent(m[a]);\\n    }\\n    \\n    bool isBipartite(vector<vector<int>>& graph) {\\n \\n        int n=graph.size();\\n        int parenta,parentb;\\n        int x,y;// x,y denote the head vertices which represent the 2 sets\\n        for(int i=0;i<n;i++)\\n        {\\n            parenta=parent(i);\\n            for(int j:graph[i])\\n            {\\n                parentb=parent(j);\\n                if(parenta==-1 && parentb==-1)//for the first edge\\n                {\\n                    m[i]=i;\\n                    m[j]=j;\\n                    parenta=i;\\n                    parentb=j;\\n                    x=i;y=j;\\n                }\\n                else if(parenta==parentb)\\n                {\\n                    return false;\\n                }\\n                else if(parenta==-1)\\n                {\\n                    if(parentb==x)m[i]=y;\\n                    else m[i]=x;\\n                }\\n                else if(parentb==-1)\\n                {\\n                    if(parenta==x)m[j]=y;\\n                    else m[j]=x;\\n                }\\n                else\\n                {\\n                    m[i]=parenta;\\n                    m[j]=parentb;\\n                }\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589930,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(int s,int x,vector<int> &v,vector<vector<int>> &g)\\n    {\\n        if(v[s]!=-1)\\n        {\\n            if(v[s] != x)return false;\\n            return true;\\n        }\\n        v[s] = x;\\n        bool ans = true;\\n        for(auto &i: g[s])\\n        {\\n            ans &= solve(i,x^1,v,g);\\n        }\\n        return ans;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) \\n    {\\n        int n = graph.size(),i;\\n        vector<int> v(n,-1);\\n        vector<vector<int>> g(n);\\n        for(i = 0; i < n; i++)\\n        {\\n            for(auto &j: graph[i])\\n            {\\n                g[i].push_back(j);\\n            }\\n        }\\n        bool ans = true;\\n        for(i = 0; i < n; i++)\\n        {\\n            if(v[i]==-1)\\n            {\\n                ans &= solve(i,0,v,g);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int s,int x,vector<int> &v,vector<vector<int>> &g)\\n    {\\n        if(v[s]!=-1)\\n        {\\n            if(v[s] != x)return false;\\n            return true;\\n        }\\n        v[s] = x;\\n        bool ans = true;\\n        for(auto &i: g[s])\\n        {\\n            ans &= solve(i,x^1,v,g);\\n        }\\n        return ans;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) \\n    {\\n        int n = graph.size(),i;\\n        vector<int> v(n,-1);\\n        vector<vector<int>> g(n);\\n        for(i = 0; i < n; i++)\\n        {\\n            for(auto &j: graph[i])\\n            {\\n                g[i].push_back(j);\\n            }\\n        }\\n        bool ans = true;\\n        for(i = 0; i < n; i++)\\n        {\\n            if(v[i]==-1)\\n            {\\n                ans &= solve(i,0,v,g);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541672,
                "title": "simple-solution-using-two-hashset-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thought that came to my mind is whenever i get an edge, then the nodes connected to this edge should belong to two different set.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used two data structure one is Queue and second is Hashset.\\nStack is to traverse through the node and Set is to store the node into two different set.\\n\\nstep1 -> created a visited array of size n.\\nstep2 -> iterating in a loop to traverse non-visited node.\\nstep2 -> at every edge i check that is this possible to add these nodes to two different set or not.\\nif yes then i continued my traversal.\\nIf not then i returned \\'false\\'.\\n\\natep4 -> At the end of this code i returned \\'true\\'.\\n\\n# Complexity\\n- Time complexity:\\n- O(e+n)  e --> Number of edges  n --> Number of nodes\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)  n --> Number of nodes\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        HashSet<Integer> set1 = new HashSet<Integer> ();\\n        HashSet<Integer> set2 = new HashSet<Integer> ();\\n\\n        int n = graph.length;\\n        Queue<Integer> s = new LinkedList<>();\\n\\n        int visited[] = new int[n];\\n        for(int k = 0 ; k < n ; k++){\\n            if(visited[k] == 0){\\n                visited[k] = 1;\\n                s.add(k);\\n            }\\n            while(!s.isEmpty()){\\n                int i = s.poll();\\n                for(int j = 0 ; j < graph[i].length ; j++){\\n                    if(set1.contains(i)){\\n                        if(set1.contains(graph[i][j])){\\n                            return false;\\n                        }\\n                        else{\\n                            set2.add(graph[i][j]);\\n                        }\\n                    }\\n                    else if(set2.contains(i)){\\n                        if(set2.contains(graph[i][j])){\\n                            return false;\\n                        }\\n                        else{\\n                            set1.add(graph[i][j]);\\n                            \\n                        }\\n                    }\\n                    else{\\n                        if(set1.contains(graph[i][j])){\\n                            set2.add(i);\\n                        }\\n                        else if(set2.contains(graph[i][j])){\\n                            set1.add(i);\\n                        }\\n                        else{\\n                            set1.add(i);\\n                            set2.add(graph[i][j]);\\n                        }\\n                    }\\n\\n                    if(visited[graph[i][j]] == 0){\\n                        visited[graph[i][j]] = 1;\\n                        s.add(graph[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n\\nplease upvote only if you understand the solution.",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        HashSet<Integer> set1 = new HashSet<Integer> ();\\n        HashSet<Integer> set2 = new HashSet<Integer> ();\\n\\n        int n = graph.length;\\n        Queue<Integer> s = new LinkedList<>();\\n\\n        int visited[] = new int[n];\\n        for(int k = 0 ; k < n ; k++){\\n            if(visited[k] == 0){\\n                visited[k] = 1;\\n                s.add(k);\\n            }\\n            while(!s.isEmpty()){\\n                int i = s.poll();\\n                for(int j = 0 ; j < graph[i].length ; j++){\\n                    if(set1.contains(i)){\\n                        if(set1.contains(graph[i][j])){\\n                            return false;\\n                        }\\n                        else{\\n                            set2.add(graph[i][j]);\\n                        }\\n                    }\\n                    else if(set2.contains(i)){\\n                        if(set2.contains(graph[i][j])){\\n                            return false;\\n                        }\\n                        else{\\n                            set1.add(graph[i][j]);\\n                            \\n                        }\\n                    }\\n                    else{\\n                        if(set1.contains(graph[i][j])){\\n                            set2.add(i);\\n                        }\\n                        else if(set2.contains(graph[i][j])){\\n                            set1.add(i);\\n                        }\\n                        else{\\n                            set1.add(i);\\n                            set2.add(graph[i][j]);\\n                        }\\n                    }\\n\\n                    if(visited[graph[i][j]] == 0){\\n                        visited[graph[i][j]] = 1;\\n                        s.add(graph[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541532,
                "title": "c-optimized-version-array-based-circular-queue",
                "content": "# Using Simple Queue\\n```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int len =graph.size();\\n        vector<int>v(len,0);\\n        for(int i=0;i<len;i++){\\n            if(v[i]==1 ||v[i]==-1)continue;\\n            queue<int>q;\\n            q.push(i);\\n            v[i]=1;\\n            while(!q.empty()){\\n                int curr=q.front();\\n                q.pop();\\n                for(int next:graph[curr]){\\n                    if(v[next]==0){\\n                        v[next]=-v[curr];\\n                        q.push(next);\\n                    }\\n                    if(v[next]==v[curr])return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n# Using Deque\\n```\\nclass Solution {\\npublic:\\n    bool isBipartite(const vector<vector<int>>& graph) {\\n    int dim = graph.size();\\n    vector<int> grouping(dim, 0);  \\n    std::deque<int> nextLevel;   \\n    int group = 1; \\n    while (true) {\\n      for (int i=0; i<dim; ++i) {\\n        if (grouping[i] == 0) {\\n          nextLevel.push_back(i);\\n          grouping[i] = group;\\n          break;\\n        }\\n      }\\n      if (nextLevel.empty())\\n        break;\\n\\n      int levelSize = 1;\\n      while (!nextLevel.empty()) {\\n        int next = nextLevel.front();\\n        nextLevel.pop_front();\\n        int otherGroup = group%2+1;\\n        for (int linked : graph[next]) {\\n          if (grouping[linked] == 0) {\\n            nextLevel.push_back(linked);\\n            grouping[linked] = otherGroup;\\n          }\\n          else if (grouping[linked] != otherGroup)\\n            return false;\\n        }\\n        if (--levelSize == 0) {\\n          levelSize = nextLevel.size();\\n          group = otherGroup;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n};\\n```\\n\\n# Using Circular Queue (Array based)\\n```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int len =graph.size();\\n        vector<int>v(len,0);\\n        int Q[101] = {0};\\n        for(int i=0;i<len;i++){\\n            if(v[i]==1 ||v[i]==-1)continue;\\n            int head = 0;\\n            int tail = 0;\\n            Q[tail++] = i;\\n            v[i]=1;\\n            while(head != tail){\\n                int curr = Q[head];\\n                head++;\\n                for(int next:graph[curr]){\\n                    if(v[next]==0){\\n                        v[next]=-v[curr];\\n                        Q[tail++] = next;\\n                    }\\n                    if(v[next]==v[curr])return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n# Using Circular Queue (Array based) - Most Optimized\\n```\\nclass Solution {\\npublic:\\n    int v[101] = {0};\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int len =graph.size();\\n        int Q[101] = {0};\\n        for(int i=0;i<len;i++){\\n            if(v[i]==1 ||v[i]==-1)continue;\\n            int head = 0;\\n            int tail = 0;\\n            Q[tail++] = i;\\n            v[i]=1;\\n            while(head != tail){\\n                int curr = Q[head];\\n                head++;\\n                for(int next:graph[curr]){\\n                    if(v[next]==0){\\n                        v[next]=-v[curr];\\n                        Q[tail++] = next;\\n                    }\\n                    if(v[next]==v[curr])return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**Please Upvote If You Like The Solution**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int len =graph.size();\\n        vector<int>v(len,0);\\n        for(int i=0;i<len;i++){\\n            if(v[i]==1 ||v[i]==-1)continue;\\n            queue<int>q;\\n            q.push(i);\\n            v[i]=1;\\n            while(!q.empty()){\\n                int curr=q.front();\\n                q.pop();\\n                for(int next:graph[curr]){\\n                    if(v[next]==0){\\n                        v[next]=-v[curr];\\n                        q.push(next);\\n                    }\\n                    if(v[next]==v[curr])return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isBipartite(const vector<vector<int>>& graph) {\\n    int dim = graph.size();\\n    vector<int> grouping(dim, 0);  \\n    std::deque<int> nextLevel;   \\n    int group = 1; \\n    while (true) {\\n      for (int i=0; i<dim; ++i) {\\n        if (grouping[i] == 0) {\\n          nextLevel.push_back(i);\\n          grouping[i] = group;\\n          break;\\n        }\\n      }\\n      if (nextLevel.empty())\\n        break;\\n\\n      int levelSize = 1;\\n      while (!nextLevel.empty()) {\\n        int next = nextLevel.front();\\n        nextLevel.pop_front();\\n        int otherGroup = group%2+1;\\n        for (int linked : graph[next]) {\\n          if (grouping[linked] == 0) {\\n            nextLevel.push_back(linked);\\n            grouping[linked] = otherGroup;\\n          }\\n          else if (grouping[linked] != otherGroup)\\n            return false;\\n        }\\n        if (--levelSize == 0) {\\n          levelSize = nextLevel.size();\\n          group = otherGroup;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int len =graph.size();\\n        vector<int>v(len,0);\\n        int Q[101] = {0};\\n        for(int i=0;i<len;i++){\\n            if(v[i]==1 ||v[i]==-1)continue;\\n            int head = 0;\\n            int tail = 0;\\n            Q[tail++] = i;\\n            v[i]=1;\\n            while(head != tail){\\n                int curr = Q[head];\\n                head++;\\n                for(int next:graph[curr]){\\n                    if(v[next]==0){\\n                        v[next]=-v[curr];\\n                        Q[tail++] = next;\\n                    }\\n                    if(v[next]==v[curr])return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int v[101] = {0};\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int len =graph.size();\\n        int Q[101] = {0};\\n        for(int i=0;i<len;i++){\\n            if(v[i]==1 ||v[i]==-1)continue;\\n            int head = 0;\\n            int tail = 0;\\n            Q[tail++] = i;\\n            v[i]=1;\\n            while(head != tail){\\n                int curr = Q[head];\\n                head++;\\n                for(int next:graph[curr]){\\n                    if(v[next]==0){\\n                        v[next]=-v[curr];\\n                        Q[tail++] = next;\\n                    }\\n                    if(v[next]==v[curr])return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540866,
                "title": "easy-c-code-with-full-explanation-very-easy-to-understand",
                "content": "# Intuition\\n\\nThe code uses a breadth-first search (BFS) approach to traverse the graph and assigns colors to the nodes. It maintains a queue q to store the nodes to be processed. The BFS starts from a source node s and explores its adjacent nodes.\\n\\nThe color vector is used to assign colors to the nodes. Initially, all nodes are uncolored, indicated by -1 in the color vector. When a node is visited for the first time, its color is assigned as the complement of its parent\\'s color (represented by !color[node]). If the adjacent node already has the same color as its parent, it means the graph is not bipartite, and the function returns false.\\n\\nThe BFS continues until all nodes have been visited or until a conflict in colors is detected. If the BFS completes without any conflicts, it means the graph is bipartite, and the function returns true.\\n\\nThe isBipartite function calls the bfs function for each node in the graph to check bipartiteness. If any of the calls to bfs returns false, indicating that the corresponding subgraph is not bipartite, the overall function returns false. Otherwise, it returns true, indicating that the entire graph is bipartite\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n\\n- The time complexity \\n\\nConstructing the Graph: The time complexity for constructing the graph represented by an adjacency list is typically O(V + E), where V is the number of vertices and E is the number of edges. This step is not explicitly mentioned in the given code, but assuming the graph is already provided, we can consider it as a preprocessing step.\\n\\nBFS Traversal: The code performs a BFS traversal starting from each node in the graph. Since the graph is represented using an adjacency list, the time complexity for traversing all the edges from a node is O(deg(v)), where deg(v) is the degree of vertex v. In the worst case, each edge is visited once, resulting in a total time complexity of O(V + E) for the entire BFS traversal.\\n\\nChecking Color Conflicts: For each edge in the graph, the code checks if there is a color conflict between the source node and the adjacent node. This check is performed in constant time O(1) since it involves a simple comparison of color values.\\n\\nTherefore, the overall time complexity of the given code can be expressed as O(V + E), where V is the number of vertices and E is the number of edges in the graph.\\n\\n- Space complexity:O(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\nprivate :\\n    bool bfs(int c,int s,vector<int>& color , vector<vector<int>>& graph){\\n          queue<int> q;\\n          q.push(s);\\n\\n          while(!q.empty()){\\n              int node = q.front();\\n              q.pop();\\n              for(auto it:graph[node]){\\n\\n                  if(color[it] == -1){\\n                      color[it] = !color[node];\\n                      q.push(it);\\n                  }\\n                  else if(color[it] == color[node])\\n                   return false;\\n              }\\n          }\\n\\n        return true;  \\n    }\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n\\n          int n = graph.size();\\n          vector<int> color(n,-1);\\n\\n           for(int i=0;i<n;i++){\\n               if(!bfs(0,i,color,graph))\\n                return false;\\n           }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\nprivate :\\n    bool bfs(int c,int s,vector<int>& color , vector<vector<int>>& graph){\\n          queue<int> q;\\n          q.push(s);\\n\\n          while(!q.empty()){\\n              int node = q.front();\\n              q.pop();\\n              for(auto it:graph[node]){\\n\\n                  if(color[it] == -1){\\n                      color[it] = !color[node];\\n                      q.push(it);\\n                  }\\n                  else if(color[it] == color[node])\\n                   return false;\\n              }\\n          }\\n\\n        return true;  \\n    }\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n\\n          int n = graph.size();\\n          vector<int> color(n,-1);\\n\\n           for(int i=0;i<n;i++){\\n               if(!bfs(0,i,color,graph))\\n                return false;\\n           }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540461,
                "title": "c-dfs-bfs-solutions-beats-94-92-in-19-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse the same method can solve the problem 886. Possible Bipartition\\n [https://leetcode.com/problems/possible-bipartition/solutions/3541884/c-bfs-solution/](https://leetcode.com/problems/possible-bipartition/solutions/3541884/c-bfs-solution/)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool ans=1;\\n    vector<int> color;\\n    void dfs(int i,  int c, vector<vector<int>>& graph){\\n        if (color[i]!=-1) return ;\\n        color[i]=c;\\n        for(int j: graph[i]){\\n            if( color[j]==color[i]){\\n                ans=0;\\n                return;\\n            }\\n            else{\\n                dfs(j, (c+1)&1, graph);\\n            }\\n        }\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        color.assign(n, -1);\\n        for (int i=0; i<n; i++)\\n            dfs(i, 1, graph);\\n        return ans;\\n    }\\n};\\n```\\nbfs solution beats 94.92% in 19 ms\\n```\\nclass Solution {\\npublic:\\n    bool ans=1;\\n    vector<int> color;\\n    void bfs(int i, vector<vector<int>>& graph){\\n        queue<int> q;\\n        q.push(i);\\n        color[i]=1;\\n        while(!q.empty()){\\n            int k=q.front();\\n            q.pop();\\n            for(int j: graph[k]){\\n                int c=color[j];\\n                int c_k=color[k];\\n                if (c==-1){\\n                    color[j]=(c_k+1)&1;\\n                    q.push(j);\\n                }\\n                else if( c==c_k){\\n                    ans=0;\\n                    return;\\n                }\\n            }\\n        }\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        color.assign(n, -1);\\n        for (int i=0; i<n; i++)\\n            if (color[i]==-1)\\n                bfs(i, graph);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ans=1;\\n    vector<int> color;\\n    void dfs(int i,  int c, vector<vector<int>>& graph){\\n        if (color[i]!=-1) return ;\\n        color[i]=c;\\n        for(int j: graph[i]){\\n            if( color[j]==color[i]){\\n                ans=0;\\n                return;\\n            }\\n            else{\\n                dfs(j, (c+1)&1, graph);\\n            }\\n        }\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        color.assign(n, -1);\\n        for (int i=0; i<n; i++)\\n            dfs(i, 1, graph);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool ans=1;\\n    vector<int> color;\\n    void bfs(int i, vector<vector<int>>& graph){\\n        queue<int> q;\\n        q.push(i);\\n        color[i]=1;\\n        while(!q.empty()){\\n            int k=q.front();\\n            q.pop();\\n            for(int j: graph[k]){\\n                int c=color[j];\\n                int c_k=color[k];\\n                if (c==-1){\\n                    color[j]=(c_k+1)&1;\\n                    q.push(j);\\n                }\\n                else if( c==c_k){\\n                    ans=0;\\n                    return;\\n                }\\n            }\\n        }\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        color.assign(n, -1);\\n        for (int i=0; i<n; i++)\\n            if (color[i]==-1)\\n                bfs(i, graph);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540339,
                "title": "c-easy-understanding-simple-approach-dfs-bfs",
                "content": "#### **Approach:**\\nIn this question we just need to check whether the graph is **Bipartite** or not (i.e. whether the graph can be colored with **two colors** or not with condition **no two adjacent vertices have same color**).\\n\\nTo check this we can traverse the graph and put one color to one vertex and other color to all the vertices adjacent to it and if we are able to color the whole graph then return true else we need to return false-- We can use either dfs or bfs to do the above operations.\\nBut In the question it is mentioned ***that the graph may be disconnected***. So, we first need to find out the no of components of a graph and assign one color to the starting node of each component.\\n\\nI have first finded **all the starting node of each component using dfs** and pushed the node in queue with color 0. After that I have traversed the graph using *bfs* checking the condition whether the adjacent node is of same color--Returned false and finally returned true if everything satisfied.\\n\\nTime complexity: **O(n)**\\n\\n\\nCode implementation:\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&graph, vector<int>&vis, int node)\\n    {\\n        if(vis[node])return;\\n        \\n        vis[node]=1;\\n        for(auto it:graph[node])\\n        {\\n            dfs(graph,vis,it);\\n        }\\n    }\\n    \\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        vector<int>vis(n,0);\\n        \\n        vector<int>color(n,-1);//stored color of all the node as -1(initially)\\n        \\n        queue<pair<int,int>>q;//node& color of the node\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                dfs(graph,vis,i);\\n                q.push({i,0});//pushed the starting node of each component with color 0\\n                color[i]=0;//storing the color of node in a vector to be used further\\n            }\\n        }\\n        \\n        \\n        while(!q.empty())\\n        {\\n            int node=q.front().first;\\n            int node_color=q.front().second;//color of the current node\\n            q.pop();\\n            \\n            for(auto it:graph[node])\\n            {\\n                if(color[it]==-1)//condition when the node has not been visited yet\\n                {\\n                    q.push({it,!node_color});//pushed the noode in queue with opposite color\\n                    color[it]=!node_color;\\n                }\\n                \\n                else if(color[it]==node_color)return false;//founded adjacent nodes with same color\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n\\n\\n**cout<<Please Upvote\\uD83D\\uDE00<<endl;**\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>&graph, vector<int>&vis, int node)\\n    {\\n        if(vis[node])return;\\n        \\n        vis[node]=1;\\n        for(auto it:graph[node])\\n        {\\n            dfs(graph,vis,it);\\n        }\\n    }\\n    \\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        vector<int>vis(n,0);\\n        \\n        vector<int>color(n,-1);//stored color of all the node as -1(initially)\\n        \\n        queue<pair<int,int>>q;//node& color of the node\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(!vis[i])\\n            {\\n                dfs(graph,vis,i);\\n                q.push({i,0});//pushed the starting node of each component with color 0\\n                color[i]=0;//storing the color of node in a vector to be used further\\n            }\\n        }\\n        \\n        \\n        while(!q.empty())\\n        {\\n            int node=q.front().first;\\n            int node_color=q.front().second;//color of the current node\\n            q.pop();\\n            \\n            for(auto it:graph[node])\\n            {\\n                if(color[it]==-1)//condition when the node has not been visited yet\\n                {\\n                    q.push({it,!node_color});//pushed the noode in queue with opposite color\\n                    color[it]=!node_color;\\n                }\\n                \\n                else if(color[it]==node_color)return false;//founded adjacent nodes with same color\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540248,
                "title": "java-solution-for-is-graph-bipartite-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to use graph coloring and perform a breadth-first search (BFS) traversal. The goal is to assign colors to the nodes in such a way that no two adjacent nodes have the same color. If it is possible to color all the nodes without any conflicts, the graph is bipartite.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize an array, colors, to store the colors of nodes. Initially, all nodes are assigned no color, represented by -1.\\n1. Iterate through each node in the graph.\\n1. For each uncolored node, perform a BFS traversal to assign colors to its neighbors.\\n1. During the BFS traversal, assign the first color (e.g., 0) to the starting node and alternate colors for its neighbors. If a neighbor already has a color and it is the same as the current node\\'s color, then the graph is not bipartite.\\n1. Continue the BFS traversal until all nodes are visited or a conflict is detected.\\n1. If all nodes are successfully colored without conflicts, return true (indicating that the graph is bipartite).\\n1. If a conflict occurs during coloring, return false (indicating that the graph is not bipartite).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(V + E), where V is the number of vertices (nodes) and E is the number of edges in the graph. In the worst case, each node and each edge is visited once during the BFS traversal.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(V), where V is the number of vertices (nodes) in the graph. This is due to the usage of the colors array to store the color assignments for each node.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int n = graph.length;\\n        int[] colors = new int[n]; // Array to store the colors of nodes\\n        Arrays.fill(colors, -1); // Initialize all nodes with no color\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (colors[i] == -1 && !isBipartiteUtil(graph, colors, i)) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    private boolean isBipartiteUtil(int[][] graph, int[] colors, int node) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(node);\\n        colors[node] = 0; // Assign the first color to the starting node\\n        \\n        while (!queue.isEmpty()) {\\n            int currNode = queue.poll();\\n            \\n            for (int neighbor : graph[currNode]) {\\n                if (colors[neighbor] == colors[currNode]) {\\n                    return false; // If adjacent nodes have the same color, the graph is not bipartite\\n                } else if (colors[neighbor] == -1) {\\n                    colors[neighbor] = 1 - colors[currNode]; // Assign the opposite color to the neighbor node\\n                    queue.offer(neighbor);\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int n = graph.length;\\n        int[] colors = new int[n]; // Array to store the colors of nodes\\n        Arrays.fill(colors, -1); // Initialize all nodes with no color\\n        \\n        for (int i = 0; i < n; i++) {\\n            if (colors[i] == -1 && !isBipartiteUtil(graph, colors, i)) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    private boolean isBipartiteUtil(int[][] graph, int[] colors, int node) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(node);\\n        colors[node] = 0; // Assign the first color to the starting node\\n        \\n        while (!queue.isEmpty()) {\\n            int currNode = queue.poll();\\n            \\n            for (int neighbor : graph[currNode]) {\\n                if (colors[neighbor] == colors[currNode]) {\\n                    return false; // If adjacent nodes have the same color, the graph is not bipartite\\n                } else if (colors[neighbor] == -1) {\\n                    colors[neighbor] = 1 - colors[currNode]; // Assign the opposite color to the neighbor node\\n                    queue.offer(neighbor);\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540157,
                "title": "c-simple-bfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& a) {\\n        int n = a.size();\\n        vector<int> c(n);\\n        for (int i = 0; i < n; ++i) {\\n            if (c[i]) continue;\\n            c[i] = 1;\\n            queue<int> Q;\\n            Q.push(i);\\n            while (!Q.empty()) {\\n                int u = Q.front();\\n                Q.pop();\\n                for (auto& v : a[u]) {\\n                    if (c[v]) {\\n                        if (c[u] + c[v] != 0) return false;\\n                    } else {\\n                        c[v] = -c[u];\\n                        Q.push(v);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& a) {\\n        int n = a.size();\\n        vector<int> c(n);\\n        for (int i = 0; i < n; ++i) {\\n            if (c[i]) continue;\\n            c[i] = 1;\\n            queue<int> Q;\\n            Q.push(i);\\n            while (!Q.empty()) {\\n                int u = Q.front();\\n                Q.pop();\\n                for (auto& v : a[u]) {\\n                    if (c[v]) {\\n                        if (c[u] + c[v] != 0) return false;\\n                    } else {\\n                        c[v] = -c[u];\\n                        Q.push(v);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540150,
                "title": "very-easy-fast-c-soln-beginner-friendly",
                "content": "**Please upVote if it helps.**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(V+E)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(V)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=1;\\n    void solve(vector<vector<int>> &graph,int i,vector<int> &vis,vector<int> &color,int flag){\\n        vis[i]=1;\\n        for(auto itr : graph[i]){\\n            if(vis[itr] == 0)\\n            {\\n                color[itr]=!flag;\\n                solve(graph,itr,vis,color,!flag);\\n            }\\n            if(vis[itr]==1){\\n                if(color[itr]==flag){\\n                    ans=0;\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        \\n        int n=graph.size();\\n        vector<int> vis(n,0);\\n        vector<int> color(n,-1);\\n        int flag=0;\\n        color[0]=0;\\n        int count=0;\\n        for(int i=0; i<n; i++){\\n            if(vis[i]==0)\\n                solve(graph,i,vis,color,flag);\\n        }\\n        \\n        if(ans==0)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=1;\\n    void solve(vector<vector<int>> &graph,int i,vector<int> &vis,vector<int> &color,int flag){\\n        vis[i]=1;\\n        for(auto itr : graph[i]){\\n            if(vis[itr] == 0)\\n            {\\n                color[itr]=!flag;\\n                solve(graph,itr,vis,color,!flag);\\n            }\\n            if(vis[itr]==1){\\n                if(color[itr]==flag){\\n                    ans=0;\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        \\n        int n=graph.size();\\n        vector<int> vis(n,0);\\n        vector<int> color(n,-1);\\n        int flag=0;\\n        color[0]=0;\\n        int count=0;\\n        for(int i=0; i<n; i++){\\n            if(vis[i]==0)\\n                solve(graph,i,vis,color,flag);\\n        }\\n        \\n        if(ans==0)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540121,
                "title": "785-is-graph-bipartite",
                "content": "class Solution {\\npublic:\\n    void dfs(int curr, vector<vector<int>> &adj, vector<bool> &visited, vector<int> &color, int c, int &ans) {\\n        if(ans != -1) return;\\n        visited[curr] = true;\\n        color[curr] = c;\\n        for(int next: adj[curr]) {\\n            if(color[next] != -1 && color[next] == c) {\\n                ans = 0;\\n                return;\\n            }\\n            if(visited[next] == false) {\\n                dfs(next, adj, visited, color, 1 - c, ans);\\n            }\\n        }\\n    }\\n    bool isBipartite(vector<vector<int>>& adj) {\\n        int ans = -1;\\n        int V = adj.size();\\n\\t    vector<bool> visited(V, false);\\n\\t    vector<int> color(V, -1);\\n\\t    for(int i = 0; i < V; i++) {\\n\\t        if(visited[i] == false) {\\n\\t            dfs(i, adj, visited, color, 0, ans);\\n\\t        }\\n\\t    }\\n\\t    return -ans;\\n    }\\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void dfs(int curr, vector<vector<int>> &adj, vector<bool> &visited, vector<int> &color, int c, int &ans) {\\n        if(ans != -1) return;\\n        visited[curr] = true;\\n        color[curr] = c;\\n        for(int next: adj[curr]) {\\n            if(color[next] != -1 && color[next] == c) {\\n                ans = 0;\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3540060,
                "title": "java-bfs-maintaining-2-sets-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can maintain two different sets and try to map each node to one of the sets. Nodes within the same set should not have edges between them.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Maintain a `seen` boolean map so that we process each node only once.\\n2. Use BFS, start from any node that hasn\\'t been set yet.\\n3. As part of processing a node, find out which set it is part of and check whether any of its neighbors are part of the same set. If yes, then we must return `false`.\\n4. If not, we continue to add all the other neighboring nodes to the other set and also queue them up in the BFS queue.\\n5. If we successfully process all the nodes, we\\'ve been able to map all nodes into two distinct sets. Hence we return `true`.\\n\\n# Complexity\\n- Time complexity: $$O(N + E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public boolean isBipartite(int[][] graph) {\\n    var n = graph.length;\\n    boolean[] seen = new boolean[n], setA = new boolean[n], setB = new boolean[n];\\n    var queue = new ArrayDeque<Integer>();\\n    \\n    for (var i=0; i<n; i++) {\\n      if (seen[i]) continue;\\n      \\n      queue.offer(i);\\n      setA[i] = true;\\n\\n      while (!queue.isEmpty()) {\\n        var node = queue.poll();\\n        seen[node] = true;\\n\\n        var a = setA[node] ? setA : setB;\\n        var b = setA[node] ? setB : setA;\\n\\n        for (var neighbor : graph[node]) {\\n          if (a[neighbor]) return false;\\n          b[neighbor] = true;\\n\\n          if (!seen[neighbor]) queue.offer(neighbor);\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n  public boolean isBipartite(int[][] graph) {\\n    var n = graph.length;\\n    boolean[] seen = new boolean[n], setA = new boolean[n], setB = new boolean[n];\\n    var queue = new ArrayDeque<Integer>();\\n    \\n    for (var i=0; i<n; i++) {\\n      if (seen[i]) continue;\\n      \\n      queue.offer(i);\\n      setA[i] = true;\\n\\n      while (!queue.isEmpty()) {\\n        var node = queue.poll();\\n        seen[node] = true;\\n\\n        var a = setA[node] ? setA : setB;\\n        var b = setA[node] ? setB : setA;\\n\\n        for (var neighbor : graph[node]) {\\n          if (a[neighbor]) return false;\\n          b[neighbor] = true;\\n\\n          if (!seen[neighbor]) queue.offer(neighbor);\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131877,
                "title": "bfs-dfs-easy-to-understand-well-commented-c",
                "content": "# Complexity\\n- Time complexity:\\n  $$O(V+2E)$$ , where V is no of vertices(or node) and E is no. of edges.\\n\\n- Space complexity:\\n  $$O(V)$$ , for keeping track of colors.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool bfscheck(int start,vector<int>&colour,vector<vector<int>>& adj){\\n        queue<int>q;\\n        q.push(start);\\n        //colour that node \\n        //assuming two colour 0&1 and starting with 0 \\n        colour[start]=0;\\n        \\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n        for(auto adjacentNode:adj[node]){\\n           \\n           //colour adjacentNode with opposite colour of node if not yet coloured \\n           if(colour[adjacentNode]==-1){\\n           colour[adjacentNode]=(!colour[node]) ; //i.e opposite of node colour \\n           //push in queue \\n           q.push(adjacentNode);\\n           }\\n           //else when both neighbours have same colour not a bipartite graph \\n           else if(colour[adjacentNode]==colour[node]) {\\n               return false;\\n           }\\n        }\\n    }\\n    return true;//else bipartite graph\\n    }\\n     bool dfscheck(int start , int colourVal , vector<int>&colour , vector<vector<int>>& adj){\\n        //colour the node \\n        colour[start]=colourVal;//initially colourVal is 0 \\n        for(auto adjacentNode:adj[start]){\\n            \\n            //colour adjacentNode with opposite colour of node if not yet coloured \\n           if(colour[adjacentNode]==-1){\\n               //dfs call with opposite colourVal i.e !colourVal\\n               //if while calling it returned false return false\\n            if (dfscheck(adjacentNode,!colourVal,colour,adj)==false) {\\n                return false;\\n            }\\n           }\\n           //else when both neighbours have same colour not a bipartite graph \\n           else if(colour[adjacentNode]==colourVal) {\\n               return false;\\n           }\\n        }\\n     return true;//else bipartite graph\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) { \\n         int V= graph.size();\\n        vector<int>colour(V,-1);//-1 indicates not yet coloured\\n\\t    //for multiple component\\n\\t    for(int i=0;i<V;i++){\\n\\t        //if not coloured\\n\\t        if(colour[i]==-1){ \\n\\t            //while calling if at any time it returned falsed that means not a bipartite graph \\n\\t            \\n                 /*using BFS */\\n\\t       //     if(bfscheck(i,colour,graph)==false){\\n\\t       //         return false;\\n\\t       //    }\\n                /*using DFS */\\n\\t           //initially,colourVal is 0 \\n\\t           if(dfscheck(i,0,colour,graph)==false){\\n\\t                return false;\\n\\t            }\\n\\t         }\\n\\t    }\\n\\t    return true;//else bipartite graph\\n\\n    }\\n};\\n```\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool bfscheck(int start,vector<int>&colour,vector<vector<int>>& adj){\\n        queue<int>q;\\n        q.push(start);\\n        //colour that node \\n        //assuming two colour 0&1 and starting with 0 \\n        colour[start]=0;\\n        \\n        while(!q.empty()){\\n            int node = q.front();\\n            q.pop();\\n        for(auto adjacentNode:adj[node]){\\n           \\n           //colour adjacentNode with opposite colour of node if not yet coloured \\n           if(colour[adjacentNode]==-1){\\n           colour[adjacentNode]=(!colour[node]) ; //i.e opposite of node colour \\n           //push in queue \\n           q.push(adjacentNode);\\n           }\\n           //else when both neighbours have same colour not a bipartite graph \\n           else if(colour[adjacentNode]==colour[node]) {\\n               return false;\\n           }\\n        }\\n    }\\n    return true;//else bipartite graph\\n    }\\n     bool dfscheck(int start , int colourVal , vector<int>&colour , vector<vector<int>>& adj){\\n        //colour the node \\n        colour[start]=colourVal;//initially colourVal is 0 \\n        for(auto adjacentNode:adj[start]){\\n            \\n            //colour adjacentNode with opposite colour of node if not yet coloured \\n           if(colour[adjacentNode]==-1){\\n               //dfs call with opposite colourVal i.e !colourVal\\n               //if while calling it returned false return false\\n            if (dfscheck(adjacentNode,!colourVal,colour,adj)==false) {\\n                return false;\\n            }\\n           }\\n           //else when both neighbours have same colour not a bipartite graph \\n           else if(colour[adjacentNode]==colourVal) {\\n               return false;\\n           }\\n        }\\n     return true;//else bipartite graph\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) { \\n         int V= graph.size();\\n        vector<int>colour(V,-1);//-1 indicates not yet coloured\\n\\t    //for multiple component\\n\\t    for(int i=0;i<V;i++){\\n\\t        //if not coloured\\n\\t        if(colour[i]==-1){ \\n\\t            //while calling if at any time it returned falsed that means not a bipartite graph \\n\\t            \\n                 /*using BFS */\\n\\t       //     if(bfscheck(i,colour,graph)==false){\\n\\t       //         return false;\\n\\t       //    }\\n                /*using DFS */\\n\\t           //initially,colourVal is 0 \\n\\t           if(dfscheck(i,0,colour,graph)==false){\\n\\t                return false;\\n\\t            }\\n\\t         }\\n\\t    }\\n\\t    return true;//else bipartite graph\\n\\n    }\\n};\\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123299,
                "title": "java-easy-solution-bfs-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int n=graph.length;\\n        ArrayList<ArrayList<Integer>>adj=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<graph[i].length;j++){\\n                adj.get(i).add(graph[i][j]);\\n            }\\n        }\\n        \\n        int color[]=new int[n+1];\\n        Arrays.fill(color,-1);\\n\\n        for(int i=0;i<n;i++){\\n            if(color[i]==-1){\\n                if(checkBipartite(i,adj,color)==false){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public boolean checkBipartite(int i,ArrayList<ArrayList<Integer>>adj,int color[]){\\n        Queue<Integer>q=new LinkedList<>();\\n        q.add(i);\\n        color[i]=0;\\n\\n        while(!q.isEmpty()){\\n            int node=q.poll();\\n            \\n            for(int e:adj.get(node)){\\n                if(color[e]==-1){\\n                    color[e]=1-color[node];\\n                    q.add(e);\\n                }\\n                else if(color[e]==color[node]){\\n                    return false;\\n                }\\n            }\\n            \\n        }\\n        return true;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int n=graph.length;\\n        ArrayList<ArrayList<Integer>>adj=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<graph[i].length;j++){\\n                adj.get(i).add(graph[i][j]);\\n            }\\n        }\\n        \\n        int color[]=new int[n+1];\\n        Arrays.fill(color,-1);\\n\\n        for(int i=0;i<n;i++){\\n            if(color[i]==-1){\\n                if(checkBipartite(i,adj,color)==false){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public boolean checkBipartite(int i,ArrayList<ArrayList<Integer>>adj,int color[]){\\n        Queue<Integer>q=new LinkedList<>();\\n        q.add(i);\\n        color[i]=0;\\n\\n        while(!q.isEmpty()){\\n            int node=q.poll();\\n            \\n            for(int e:adj.get(node)){\\n                if(color[e]==-1){\\n                    color[e]=1-color[node];\\n                    q.add(e);\\n                }\\n                else if(color[e]==color[node]){\\n                    return false;\\n                }\\n            }\\n            \\n        }\\n        return true;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933345,
                "title": "bfs-dfs-c-sol-easy-to-understand",
                "content": "*Please upvote the solution*\\n\\nThe color array with unvisited values as -1 while 0 & 1 is used for the adjacent values. \\n\\n*Bipartite graph: \\nadjacent colors should not be the same and we have to color the graph using 2 colors*\\n\\n# BFS\\n```\\n// BFS Sol\\nclass Solution {\\nprivate:\\n    bool bfsCheck(int start, vector<int>& color, int col, vector<vector<int>>& graph){\\n        queue<int> q;\\n        q.push(start);\\n        color[start]=0;\\n        while(!q.empty()){\\n            int node= q.front();        \\n            q.pop();    // remove the node from queue\\n\\n            for(auto adjNode: graph[node]){\\n                if(color[adjNode]==-1){     // check if it is previously not colored\\n                    color[adjNode]= !color[node];   // changing color as per color of node\\n                    q.push(adjNode);\\n                }\\n                else if(color[adjNode]==color[node])    return false; // if it is previously colored and have the same color as of col then it cannot be bipartite graph\\n            }\\n        }\\n        return true;    // if we have reached here then all the nodes have been colored with 2 colors so it is bipartite graph thus return true\\n    }\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int V= graph.size();\\n        vector<int> color(V,-1);\\n        for(int i=0;i<V;i++){   // running for multiple components\\n            if(color[i]==-1){\\n                if(bfsCheck(i, color, 0, graph)==false)    return false;\\n            }\\n        }\\n\\n// if we reach here it means dfs calls were true for all components and all nodes were colored using 2 colors with adjacent nodes having different colors\\n        return true;\\n    }\\n};\\n```\\n\\n\\n# DFS\\n```\\n// DFS Sol\\nclass Solution {\\nprivate:\\n    int dfs(int node, int col, vector<int>& color, vector<vector<int>>& graph){\\n        color[node]=col;\\n        for(auto adjNode: graph[node]){\\n            if(color[adjNode]==-1){     // check if it is previously not colored\\n                if(dfs(adjNode, !col, color, graph)==false) return false;   // changing color using !col\\n            }\\n            else if(color[adjNode]==col)    return false;   // if it is previously colored and have the same color as of col then it cannot be bipartite graph\\n        }\\n        return true;    // if we have reached here then all the nodes have been colored with 2 colors so it is bipartite graph thus return true\\n    }\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int V= graph.size();\\n        vector<int> color(V,-1);     // unvisited color is -1\\n        for(int i=0;i<V;i++){        // running for multiple components\\n            if(color[i]==-1){       // we call dfs if it is unvisited\\n                if(dfs(i, 0, color, graph)==false)    return false;\\n            }\\n        }\\n        // if we reach here it means dfs calls were true for all components and all nodes were colored using 2 colors with adjacent nodes having different colors\\n\\n        return true;\\n    }\\n};\\n```\\n\\n`Feel free to ask doubts!!`\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n// BFS Sol\\nclass Solution {\\nprivate:\\n    bool bfsCheck(int start, vector<int>& color, int col, vector<vector<int>>& graph){\\n        queue<int> q;\\n        q.push(start);\\n        color[start]=0;\\n        while(!q.empty()){\\n            int node= q.front();        \\n            q.pop();    // remove the node from queue\\n\\n            for(auto adjNode: graph[node]){\\n                if(color[adjNode]==-1){     // check if it is previously not colored\\n                    color[adjNode]= !color[node];   // changing color as per color of node\\n                    q.push(adjNode);\\n                }\\n                else if(color[adjNode]==color[node])    return false; // if it is previously colored and have the same color as of col then it cannot be bipartite graph\\n            }\\n        }\\n        return true;    // if we have reached here then all the nodes have been colored with 2 colors so it is bipartite graph thus return true\\n    }\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int V= graph.size();\\n        vector<int> color(V,-1);\\n        for(int i=0;i<V;i++){   // running for multiple components\\n            if(color[i]==-1){\\n                if(bfsCheck(i, color, 0, graph)==false)    return false;\\n            }\\n        }\\n\\n// if we reach here it means dfs calls were true for all components and all nodes were colored using 2 colors with adjacent nodes having different colors\\n        return true;\\n    }\\n};\\n```\n```\\n// DFS Sol\\nclass Solution {\\nprivate:\\n    int dfs(int node, int col, vector<int>& color, vector<vector<int>>& graph){\\n        color[node]=col;\\n        for(auto adjNode: graph[node]){\\n            if(color[adjNode]==-1){     // check if it is previously not colored\\n                if(dfs(adjNode, !col, color, graph)==false) return false;   // changing color using !col\\n            }\\n            else if(color[adjNode]==col)    return false;   // if it is previously colored and have the same color as of col then it cannot be bipartite graph\\n        }\\n        return true;    // if we have reached here then all the nodes have been colored with 2 colors so it is bipartite graph thus return true\\n    }\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int V= graph.size();\\n        vector<int> color(V,-1);     // unvisited color is -1\\n        for(int i=0;i<V;i++){        // running for multiple components\\n            if(color[i]==-1){       // we call dfs if it is unvisited\\n                if(dfs(i, 0, color, graph)==false)    return false;\\n            }\\n        }\\n        // if we reach here it means dfs calls were true for all components and all nodes were colored using 2 colors with adjacent nodes having different colors\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2904132,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<int> color(105, -1);\\n\\t    for(int s=0; s<n; s++) {\\n            if(color[s] == -1) {\\n                color[s] = 1;\\n                queue<int> q;\\n                q.push(s);\\n                while(!q.empty()) {\\n                    int u = q.front();\\n                    q.pop();\\n                    for(int v: graph[u]) {\\n                        if(color[v] == -1) {\\n                            color[v] = color[u] ^ 1;\\n                            q.push(v);\\n                        }\\n                        else {\\n                            if(color[u] == color[v]) return false;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\t    return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<int> color(105, -1);\\n\\t    for(int s=0; s<n; s++) {\\n            if(color[s] == -1) {\\n                color[s] = 1;\\n                queue<int> q;\\n                q.push(s);\\n                while(!q.empty()) {\\n                    int u = q.front();\\n                    q.pop();\\n                    for(int v: graph[u]) {\\n                        if(color[v] == -1) {\\n                            color[v] = color[u] ^ 1;\\n                            q.push(v);\\n                        }\\n                        else {\\n                            if(color[u] == color[v]) return false;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\t    return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829773,
                "title": "using-queues-approach-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    \\n    \\n    bool isBipartite(vector<vector<int>>& graph) {\\n        //number of vertices in the graph\\n        int n=graph.size();\\n        //no node is currently coloured\\n        vector<int> colour(n,-1);\\n        //initialize a queue\\n        queue<pair<int,int>> q;\\n        //try to assign colours to all vertices\\n        for(int i=0;i<n;i++){\\n            //if node is not coloured\\n            if(colour[i]==-1){\\n                //insert the node and colour in the queue\\n                q.push({i,0});\\n                while(q.size()>0){\\n                   //obtaining the topmost element\\n                   pair<int,int> p=q.front();\\n                   q.pop();\\n                   int ind=p.first;\\n                   int cl=p.second;\\n                   colour[ind]=cl;\\n                    \\n                   for(int j=0;j<graph[ind].size();j++){\\n                       //if neighbour is not coloured\\n                       if(colour[graph[ind][j]]==-1){\\n                            q.push({graph[ind][j],1-cl});\\n                       }\\n                       //if neighbour is of same colour\\n                       else if(colour[graph[ind][j]]==cl){\\n                            return false;\\n                       }\\n                   }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    bool isBipartite(vector<vector<int>>& graph) {\\n        //number of vertices in the graph\\n        int n=graph.size();\\n        //no node is currently coloured\\n        vector<int> colour(n,-1);\\n        //initialize a queue\\n        queue<pair<int,int>> q;\\n        //try to assign colours to all vertices\\n        for(int i=0;i<n;i++){\\n            //if node is not coloured\\n            if(colour[i]==-1){\\n                //insert the node and colour in the queue\\n                q.push({i,0}",
                "codeTag": "Java"
            },
            {
                "id": 2725542,
                "title": "c-striver-approach-bfs",
                "content": "\\tbool bfs(int value , vector<vector<int>> grid , vector<int> &visited)\\n    {\\n        queue<int> q;\\n        q.push(value);\\n        visited[value] = 0;\\n        \\n        while(!q.empty())\\n        {\\n            vector<int> temp = grid[q.front()];\\n            int val = q.front();\\n            q.pop();\\n            \\n            for(int i=0 ;i<temp.size() ;i++)\\n            {\\n                    if(visited[temp[i]] == -1)\\n                    {\\n                        visited[temp[i]] = !visited[val];\\n                        q.push(temp[i]);\\n                    }\\n                else if(visited[temp[i]]  == visited[val])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    \\n    \\n    \\n    bool isBipartite(vector<vector<int>>& graph) {\\n       int node = graph.size();\\n        vector<int> visited(node ,-1);\\n        for(int i= 0; i<node ;i++)\\n        {\\n            if(visited[i] == -1)\\n            {\\n                if(bfs(i , graph , visited) == false)\\n                    return false;\\n                \\n            }\\n        }\\n        return true;\\n    \\n    }\\n\\t\\n# \\t**hope you understand , consider upvote   happy coding : )**",
                "solutionTags": [],
                "code": "\\tbool bfs(int value , vector<vector<int>> grid , vector<int> &visited)\\n    {\\n        queue<int> q;\\n        q.push(value);\\n        visited[value] = 0;\\n        \\n        while(!q.empty())\\n        {\\n            vector<int> temp = grid[q.front()];\\n            int val = q.front();\\n            q.pop();\\n            \\n            for(int i=0 ;i<temp.size() ;i++)\\n            {\\n                    if(visited[temp[i]] == -1)\\n                    {\\n                        visited[temp[i]] = !visited[val];\\n                        q.push(temp[i]);\\n                    }\\n                else if(visited[temp[i]]  == visited[val])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    \\n    \\n    \\n    bool isBipartite(vector<vector<int>>& graph) {\\n       int node = graph.size();\\n        vector<int> visited(node ,-1);\\n        for(int i= 0; i<node ;i++)\\n        {\\n            if(visited[i] == -1)\\n            {\\n                if(bfs(i , graph , visited) == false)\\n                    return false;\\n                \\n            }\\n        }\\n        return true;\\n    \\n    }\\n\\t\\n# \\t**hope you understand , consider upvote   happy coding : )**",
                "codeTag": "Unknown"
            },
            {
                "id": 2355960,
                "title": "python-3-dfs",
                "content": "We use standard dfs algorithm, but instead of using used array to store visited nodes, we use color array and try to color vertexes. 0 color means that we haven\\'t visit this node yet. 1 or 2 colors in which we colored the nodes. It doesn\\'t matter from which color to start. \\n\\nAlso the graph can have different connected components so we need to call dfs for each.\\n\\n```\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        def dfs(i, c):\\n            if color[i] != 0:\\n                if color[i] != c:\\n                    return False\\n                return True\\n            color[i] = c\\n            for v in graph[i]:\\n                if not dfs(v, 3 - c):\\n                    return False\\n            return True\\n             \\n        n = len(graph)\\n        color = [0] * n\\n        for i in range(n):\\n            if color[i] == 0:\\n                if not dfs(i, 1):\\n                    return False\\n        return True\\n```\\nTime complexity: O(V + E), V = n, E - number of edges\\nMemory complexity: O(V), V = n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        def dfs(i, c):\\n            if color[i] != 0:\\n                if color[i] != c:\\n                    return False\\n                return True\\n            color[i] = c\\n            for v in graph[i]:\\n                if not dfs(v, 3 - c):\\n                    return False\\n            return True\\n             \\n        n = len(graph)\\n        color = [0] * n\\n        for i in range(n):\\n            if color[i] == 0:\\n                if not dfs(i, 1):\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240403,
                "title": "python-both-bfs-and-dfs-technique-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/a3c22eaa-8437-4050-96f7-953bb19143bb_1657009308.0998313.jpeg)\\n\\nRead in Details: https://www.theconfusedtechie.com/post/is-graph-bipartite\\n**BFS:**\\n```\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        # initialize a list named sets with all -1\\n        sets=[-1]*len(graph)\\n\\n        # define bfs\\n        def bfs(i,mark):\\n            # initialize a queue\\n            queue=[(i,mark)]\\n            # while queue is not empty\\n            while queue:\\n                # pop first element from queue\\n                node,mark=queue.pop(0)\\n                # the the node is already marked, skip\\n                if sets[node]!=-1: continue\\n                # else mark the current node in sets\\n                sets[node]=mark\\n                # for all adjacent nodes\\n                for adj in graph[node]:\\n                    # if the marker of the current node is same as the adjacent node\\n                    # return false\\n                    if sets[adj]==mark: return False\\n                    # else add the adjacent node and the opposite marker to queue\\n                    queue.append((adj,1-mark))\\n            # return True        \\n            return True\\n        # for each unvisited node, run bfs to mark it \\n        for i in range(len(graph)):\\n            if sets[i]==-1 and not bfs(i,0): return False\\n               \\n        return True    \\n```\\n\\n**DFS:**\\n\\n```\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        # initialize a list named sets with all -1\\n        sets=[-1]*len(graph)\\n        # initialize a variable canMarked to decide if the graph can be marked(coloured)\\n        self.canMarked=True\\n        \\n        # define dfs\\n        def dfs(i,mark):\\n            # if the graph is already decided as not markeble return\\n            if not self.canMarked: return\\n            # if the node is already marked, return\\n            if sets[i]!=-1: return \\n            # else mark the node\\n            sets[i]=mark\\n            # for each adjacent nodes\\n            for adj in graph[i]:\\n                # if the mark of the current node is same as it\\'s adjacent node, return False\\n                if sets[i]==sets[adj]: \\n                    self.canMarked=False\\n                    return \\n                # else run dfs on the adjacent nodes for marking\\n                dfs(adj,1-mark)\\n           \\n        \\n        # for each unvisited node, run dfs to mark it \\n        for i in range(len(graph)):\\n            if sets[i]==-1 : dfs(i,0)\\n               \\n        return self.canMarked\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        # initialize a list named sets with all -1\\n        sets=[-1]*len(graph)\\n\\n        # define bfs\\n        def bfs(i,mark):\\n            # initialize a queue\\n            queue=[(i,mark)]\\n            # while queue is not empty\\n            while queue:\\n                # pop first element from queue\\n                node,mark=queue.pop(0)\\n                # the the node is already marked, skip\\n                if sets[node]!=-1: continue\\n                # else mark the current node in sets\\n                sets[node]=mark\\n                # for all adjacent nodes\\n                for adj in graph[node]:\\n                    # if the marker of the current node is same as the adjacent node\\n                    # return false\\n                    if sets[adj]==mark: return False\\n                    # else add the adjacent node and the opposite marker to queue\\n                    queue.append((adj,1-mark))\\n            # return True        \\n            return True\\n        # for each unvisited node, run bfs to mark it \\n        for i in range(len(graph)):\\n            if sets[i]==-1 and not bfs(i,0): return False\\n               \\n        return True    \\n```\n```\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        # initialize a list named sets with all -1\\n        sets=[-1]*len(graph)\\n        # initialize a variable canMarked to decide if the graph can be marked(coloured)\\n        self.canMarked=True\\n        \\n        # define dfs\\n        def dfs(i,mark):\\n            # if the graph is already decided as not markeble return\\n            if not self.canMarked: return\\n            # if the node is already marked, return\\n            if sets[i]!=-1: return \\n            # else mark the node\\n            sets[i]=mark\\n            # for each adjacent nodes\\n            for adj in graph[i]:\\n                # if the mark of the current node is same as it\\'s adjacent node, return False\\n                if sets[i]==sets[adj]: \\n                    self.canMarked=False\\n                    return \\n                # else run dfs on the adjacent nodes for marking\\n                dfs(adj,1-mark)\\n           \\n        \\n        # for each unvisited node, run dfs to mark it \\n        for i in range(len(graph)):\\n            if sets[i]==-1 : dfs(i,0)\\n               \\n        return self.canMarked\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2161638,
                "title": "easy-explaination-uderstanding-guaranteed-dfs",
                "content": "```c++\\n                           *************~~Easy Explaination~~************ \\n/*\\nEXPLAINATION : \\nBIPARTITE GRAPH : \\n    1. wo graph jisme parent node aur child node ka color same nhi hona chahiye ( baap aur bete ka color agar same he to graph biparte nhi hoga )\\n    2. graph me ODD cycle nhi hona chahiye (agar odd cycle hoga to kisi na kisi parent node aur child node ka color same ho jayega )\\n\\nSimply hme 1 conditions check karna he :-\\n\\t\\t   1. baap(parent) aur bete(child) ka color same nhi hona chahiye. agar same he to Family(Graph) Bipartite NHI he.\\n\\n    NOTE : ham code me color ko 0 aur 1 se represent kar rahe he \\n    Approach : using dfs\\n        --> create a visited vector(jisme initially saare Node Unvisited rahege )\\n        --> create a color vector (jisme initially saare nodes ka color 0 hoga)\\n        --> if node is not visited to dfs krke check krlo\\n        -->DFS : \\n              --> pahle curr node ko visited mark kardo \\n              --> abb uske neighbour(child) par traverse krO \\n                --> child ka color baap ke color ka opposite mark karo (Baap gora beta KALA (Racism hogya ji)\\n                --> agar beta visited nhi he to uske liye dfs call karke check karlo \\n                        --> kya bete(child) aur baap(parent) ka color same he\\n                                --> if Yess return False (Graph se not Bipartite)\\n\\n*/```\\n\\n                          ****DILL aur DIMAAG se HINDI***** \\n\\n    bool DFSisBipartite(int node, vector<vector<int>>& adj, vector<bool> &visited, vector<int> &color){\\n        visited[node] = true;\\n        \\n        for (auto nbr : adj[node])\\n        {\\n            if (!visited[nbr]){\\n                color[nbr] = !color[node];      //child ka color parent se alag hoga \\n                if (!DFSisBipartite(nbr, adj, visited, color))\\n                    return false;\\n            }\\n            else {\\n                if (node != nbr && color[node] == color[nbr])       //agar baap aur bete ka color same he matlab Graph is not Bipartite \\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int V = graph.size() ; \\n        vector<bool> visited(V , 0) ;   \\n\\t    vector<int> color(V , 0) ;      //ye node ka color store karega \\n\\t    \\n\\t    for(int i=0 ; i<V ; i++)\\n\\t    {\\n\\t        if( !visited[i] ) {\\n\\t            if( !DFSisBipartite( i , graph , visited , color) ) \\n\\t                return false ; \\n\\t        }\\n\\t    }\\n\\t    return true ;\\n    }",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```c++\\n                           *************~~Easy Explaination~~************ \\n/*\\nEXPLAINATION : \\nBIPARTITE GRAPH : \\n    1. wo graph jisme parent node aur child node ka color same nhi hona chahiye ( baap aur bete ka color agar same he to graph biparte nhi hoga )\\n    2. graph me ODD cycle nhi hona chahiye (agar odd cycle hoga to kisi na kisi parent node aur child node ka color same ho jayega )\\n\\nSimply hme 1 conditions check karna he :-\\n\\t\\t   1. baap(parent) aur bete(child) ka color same nhi hona chahiye. agar same he to Family(Graph) Bipartite NHI he.\\n\\n    NOTE : ham code me color ko 0 aur 1 se represent kar rahe he \\n    Approach : using dfs\\n        --> create a visited vector(jisme initially saare Node Unvisited rahege )\\n        --> create a color vector (jisme initially saare nodes ka color 0 hoga)\\n        --> if node is not visited to dfs krke check krlo\\n        -->DFS : \\n              --> pahle curr node ko visited mark kardo \\n              --> abb uske neighbour(child) par traverse krO \\n                --> child ka color baap ke color ka opposite mark karo (Baap gora beta KALA (Racism hogya ji)\\n                --> agar beta visited nhi he to uske liye dfs call karke check karlo \\n                        --> kya bete(child) aur baap(parent) ka color same he\\n                                --> if Yess return False (Graph se not Bipartite)\\n\\n*/```",
                "codeTag": "Unknown"
            },
            {
                "id": 1992027,
                "title": "py-unionfind-faster-80-path-compression-rank-heuristics",
                "content": "If its **helps** u, pls **like** this post :) \\n```\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        UF = UnionFind(len(graph))\\n        for v in range(len(graph)):\\n            classv = UF.find(v)\\n            for u in graph[v]:\\n                classu = UF.find(u)\\n                if classv==classu:\\n                    return False\\n                UF.union(classu,graph[v][0])\\n        return True\\n     \\nclass UnionFind():\\n    def __init__(self,size):\\n        self.roots = list(range(size))\\n        self.ranks = [1]*size\\n    def find(self, id):\\n        if id==self.roots[id]:\\n            return id\\n        self.roots[id]=self.find(self.roots[id])\\n        return self.roots[id]\\n    def union(self, id1, id2):\\n        root1=self.find(id1)\\n        root2=self.find(id2)\\n        if root1!=root2:\\n            if self.ranks[root1]>self.ranks[root2]:\\n                self.roots[root2]=root1\\n                self.ranks[root1]+=self.ranks[root2]\\n            else:\\n                self.roots[root1]=root2\\n                self.ranks[root2]+=self.ranks[root1]\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        UF = UnionFind(len(graph))\\n        for v in range(len(graph)):\\n            classv = UF.find(v)\\n            for u in graph[v]:\\n                classu = UF.find(u)\\n                if classv==classu:\\n                    return False\\n                UF.union(classu,graph[v][0])\\n        return True\\n     \\nclass UnionFind():\\n    def __init__(self,size):\\n        self.roots = list(range(size))\\n        self.ranks = [1]*size\\n    def find(self, id):\\n        if id==self.roots[id]:\\n            return id\\n        self.roots[id]=self.find(self.roots[id])\\n        return self.roots[id]\\n    def union(self, id1, id2):\\n        root1=self.find(id1)\\n        root2=self.find(id2)\\n        if root1!=root2:\\n            if self.ranks[root1]>self.ranks[root2]:\\n                self.roots[root2]=root1\\n                self.ranks[root1]+=self.ranks[root2]\\n            else:\\n                self.roots[root1]=root2\\n                self.ranks[root2]+=self.ranks[root1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990536,
                "title": "c-dfs-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(int node,vector<vector<int>>& graph, vector<int>& color){\\n        for(auto x:graph[node]){\\n            if(color[x]==-1){ // not coloured yet\\n                color[x]=1-color[node]; //reverse the color\\n                if(dfs(x,graph,color)==false)\\n                    return false;\\n            }\\n            else if(color[x]==color[node]) // already coloured and same colour\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        vector<int> color(n,-1);\\n        for(int i=0;i<n;i++){\\n            if(color[i]==-1){\\n                color[i]=1;\\n                if(dfs(i,graph,color)==false)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int node,vector<vector<int>>& graph, vector<int>& color){\\n        for(auto x:graph[node]){\\n            if(color[x]==-1){ // not coloured yet\\n                color[x]=1-color[node]; //reverse the color\\n                if(dfs(x,graph,color)==false)\\n                    return false;\\n            }\\n            else if(color[x]==color[node]) // already coloured and same colour\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        vector<int> color(n,-1);\\n        for(int i=0;i<n;i++){\\n            if(color[i]==-1){\\n                color[i]=1;\\n                if(dfs(i,graph,color)==false)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491035,
                "title": "c-bfs-solution-graph-coloring-with-explanation",
                "content": "\\t// Color all the nodes of the graph using 2 colors such that no two adjacent node are of same color then, the graph is bipartite graph.\\n\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tbool bfs(int i, int col[], vector<vector<int>>&graph){\\n\\t\\t\\tqueue<int>q; \\n\\t\\t\\tq.push(i);            //push the first node in queue\\n\\n\\t\\t\\tcol[i] = 0;           //color the first node\\n\\n\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\tint t = q.front();\\n\\t\\t\\t\\tq.pop();\\n\\n\\t\\t\\t\\tfor(auto x : graph[t]){                   \\n\\t\\t\\t\\t\\tif(col[x]==-1){                 // if the adjacent node is uncolored\\n\\t\\t\\t\\t\\t\\tcol[x] = 1-col[t];         //color it with opposite color\\n\\t\\t\\t\\t\\t\\tq.push(x);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(col[x]==col[t]){         // return false if any adjacent node is colored with the same node color\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tbool isBipartite(vector<vector<int>>& graph) {\\n\\t\\t\\tint n = graph.size();\\n\\t\\t\\tint col[n];\\n\\t\\t\\tmemset(col, -1, sizeof(col)); //all the nodes are uncolored\\n\\t\\t\\t\\n\\t\\t\\t//check for all the nodes\\n\\t\\t\\tfor(int i = 0; i<n; i++){\\n\\t\\t\\t\\tif(col[i]==-1){\\n\\t\\t\\t\\t\\tif(!bfs(i, col, graph))\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tbool bfs(int i, int col[], vector<vector<int>>&graph){\\n\\t\\t\\tqueue<int>q; \\n\\t\\t\\tq.push(i);            //push the first node in queue\\n\\n\\t\\t\\tcol[i] = 0;           //color the first node\\n\\n\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\tint t = q.front();\\n\\t\\t\\t\\tq.pop();\\n\\n\\t\\t\\t\\tfor(auto x : graph[t]){                   \\n\\t\\t\\t\\t\\tif(col[x]==-1){                 // if the adjacent node is uncolored\\n\\t\\t\\t\\t\\t\\tcol[x] = 1-col[t];         //color it with opposite color\\n\\t\\t\\t\\t\\t\\tq.push(x);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1479440,
                "title": "c-solution-for-785-is-graph-bipartite",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkBipartite(int node, vector<int>& color, vector<vector<int>>& graph)\\n    {\\n        for(auto it : graph[node])\\n        {\\n            if(color[it] == -1)\\n            {\\n                color[it] = 1 - color[node] ;\\n                if(checkBipartite(it, color, graph)==false)\\n                {return false;}\\n            }\\n            else if(color[it] == color[node]){return false;}\\n        }\\n        return true;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) \\n    {\\n        int sz = graph.size(); vector<int> vis(sz,-1);\\n        for(int i=0; i<sz; i++)\\n        {\\n            if(vis[i] == -1)\\n            {   vis[i] = 1 ;\\n                if(checkBipartite(i, vis, graph) == false){return false;}\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkBipartite(int node, vector<int>& color, vector<vector<int>>& graph)\\n    {\\n        for(auto it : graph[node])\\n        {\\n            if(color[it] == -1)\\n            {\\n                color[it] = 1 - color[node] ;\\n                if(checkBipartite(it, color, graph)==false)\\n                {return false;}\\n            }\\n            else if(color[it] == color[node]){return false;}\\n        }\\n        return true;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) \\n    {\\n        int sz = graph.size(); vector<int> vis(sz,-1);\\n        for(int i=0; i<sz; i++)\\n        {\\n            if(vis[i] == -1)\\n            {   vis[i] = 1 ;\\n                if(checkBipartite(i, vis, graph) == false){return false;}\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1296630,
                "title": "generic-union-find-templete-solution",
                "content": "```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        UnionFind uf = new UnionFind(graph.length);\\n        for(int i = 0; i < graph.length; i++) {\\n            for(int j = 0; j < graph[i].length; j++) {\\n                if(uf.find(i) == uf.find(graph[i][j]))\\n                    return false;\\n                uf.union(graph[i][0], graph[i][j]);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    public class UnionFind {\\n        private int size;\\n        private int numComponents; // number of connected components\\n        private int[] parent;\\n        private int[] rank;\\n\\n        public UnionFind(int n) {\\n            if (n <= 0) throw new IllegalArgumentException(\"Size <= 0 is not allowed\");\\n            size = numComponents = n;\\n            parent = new int[n];\\n            rank = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n            }\\n        }\\n\\n        public int find(int p) {\\n            while (p != parent[p]) {\\n                parent[p] = parent[parent[p]];    // path compression by halving\\n                p = parent[p];\\n            }\\n            return p;\\n        }\\n\\n        public void union(int p, int q) {\\n            int rootP = find(p);\\n            int rootQ = find(q);\\n\\n            // These elements are already in the same group!\\n            if (rootP == rootQ)\\n                return;\\n\\n            // Merge smaller component/set into the larger one.\\n            if (rank[rootQ] > rank[rootP]) {\\n                parent[rootP] = rootQ;\\n            } else {\\n                parent[rootQ] = rootP;\\n                if (rank[rootP] == rank[rootQ]) {\\n                    rank[rootP]++;\\n                }\\n            }\\n\\n            // Since the roots found are different we know that the number of components/sets has decreased by one\\n            numComponents--;\\n        }\\n\\n        // Return whether or not the elements \\'p\\' and \\'q\\' are in the same components/set.\\n        public boolean connected(int p, int q) {\\n            return find(p) == find(q);\\n        }\\n\\n        // Returns the number of remaining components/sets\\n        public int components() {\\n            return numComponents;\\n        }\\n\\n        // Return the number of elements in this UnionFind/Disjoint set\\n        public int size() {\\n            return size;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        UnionFind uf = new UnionFind(graph.length);\\n        for(int i = 0; i < graph.length; i++) {\\n            for(int j = 0; j < graph[i].length; j++) {\\n                if(uf.find(i) == uf.find(graph[i][j]))\\n                    return false;\\n                uf.union(graph[i][0], graph[i][j]);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    public class UnionFind {\\n        private int size;\\n        private int numComponents; // number of connected components\\n        private int[] parent;\\n        private int[] rank;\\n\\n        public UnionFind(int n) {\\n            if (n <= 0) throw new IllegalArgumentException(\"Size <= 0 is not allowed\");\\n            size = numComponents = n;\\n            parent = new int[n];\\n            rank = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n            }\\n        }\\n\\n        public int find(int p) {\\n            while (p != parent[p]) {\\n                parent[p] = parent[parent[p]];    // path compression by halving\\n                p = parent[p];\\n            }\\n            return p;\\n        }\\n\\n        public void union(int p, int q) {\\n            int rootP = find(p);\\n            int rootQ = find(q);\\n\\n            // These elements are already in the same group!\\n            if (rootP == rootQ)\\n                return;\\n\\n            // Merge smaller component/set into the larger one.\\n            if (rank[rootQ] > rank[rootP]) {\\n                parent[rootP] = rootQ;\\n            } else {\\n                parent[rootQ] = rootP;\\n                if (rank[rootP] == rank[rootQ]) {\\n                    rank[rootP]++;\\n                }\\n            }\\n\\n            // Since the roots found are different we know that the number of components/sets has decreased by one\\n            numComponents--;\\n        }\\n\\n        // Return whether or not the elements \\'p\\' and \\'q\\' are in the same components/set.\\n        public boolean connected(int p, int q) {\\n            return find(p) == find(q);\\n        }\\n\\n        // Returns the number of remaining components/sets\\n        public int components() {\\n            return numComponents;\\n        }\\n\\n        // Return the number of elements in this UnionFind/Disjoint set\\n        public int size() {\\n            return size;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1273318,
                "title": "0-1-colouring-method-dfs-based-with-explanation",
                "content": "\\n**LOGIC :-** If graph is bipartite you can colour all the nodes with starting from ( 0 or 1) such that no two adjacent    nodes have same colour.<br/>\\n\\n**WORKING :-** We will colour the source as 1 and all its adjacent nodes with 0 ,and while doing this if we found that if any two adjacent nodes have same colour we will return false ***(means the graph couldn\\'t be coloured so it can\\'t be a bipartite graph)*** else return true means graph is bipartite beacause we have succesfully colored acoording to logic stated above.\\n\\n``` \\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>>& adj,vector<int>&colour, int src) // function to perform dfs\\n    {\\n        \\n        for(auto node:adj[src]) //checking adjacent nodes of given source or starting node or parent\\n        {\\n            if(colour[node]==-1) // if they are not coloured\\n            {\\n                colour[node]=colour[src]^1; //colour it with opposite colour of that of parent or (starting node) (xor operator is used for fliiping 0 to 1 or vice versa)\\n                if(dfs(adj,colour,node)==false) // call  dfs for its adjacent nodes if found false return false\\n                    return false;\\n                    \\n            }\\n            else if(colour[node]==colour[src]) // if same colour is found for two adjacent nodes return false (because it is not allowed according to the above logic)\\n             return false;\\n        }\\n        \\n        return true; // if everything is OK return true\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        \\n        int n=graph.size();\\n        vector<int>colour(n,-1); // all nodes have -1 means they are not coloured\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            if(colour[i]==-1) // check if node is not coloured\\n            {\\n               colour[i]=1;     // colour the source or starting node as 1        \\n               if(dfs(graph,colour,i)==false) // call  dfs for its adjacent nodes if found false return false\\n                  return false;\\n            }\\n        }\\n        \\n        return true; // if everything is OK return true\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>>& adj,vector<int>&colour, int src) // function to perform dfs\\n    {\\n        \\n        for(auto node:adj[src]) //checking adjacent nodes of given source or starting node or parent\\n        {\\n            if(colour[node]==-1) // if they are not coloured\\n            {\\n                colour[node]=colour[src]^1; //colour it with opposite colour of that of parent or (starting node) (xor operator is used for fliiping 0 to 1 or vice versa)\\n                if(dfs(adj,colour,node)==false) // call  dfs for its adjacent nodes if found false return false\\n                    return false;\\n                    \\n            }\\n            else if(colour[node]==colour[src]) // if same colour is found for two adjacent nodes return false (because it is not allowed according to the above logic)\\n             return false;\\n        }\\n        \\n        return true; // if everything is OK return true\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        \\n        int n=graph.size();\\n        vector<int>colour(n,-1); // all nodes have -1 means they are not coloured\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            if(colour[i]==-1) // check if node is not coloured\\n            {\\n               colour[i]=1;     // colour the source or starting node as 1        \\n               if(dfs(graph,colour,i)==false) // call  dfs for its adjacent nodes if found false return false\\n                  return false;\\n            }\\n        }\\n        \\n        return true; // if everything is OK return true\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245676,
                "title": "java-dfs-solution-without-coloring-concept",
                "content": "```\\nclass Solution {\\n    class Pair{\\n        int node;\\n        int level;\\n        Pair(int n,int l){\\n            node=n;\\n            level=l;\\n        }\\n    }\\n    public boolean isBipartite(int[][] graph) {\\n        int visited[] = new int[graph.length];\\n        Arrays.fill(visited,-1);\\n         for(int i =0; i < graph.length; i++){\\n             if(visited[i]==-1){\\n                if(!checkBipartite(graph,visited,i))\\n                return false;\\n             }\\n         }        \\n       return true;       \\n    }\\n    boolean checkBipartite(int[][] graph,int visited[],int node){\\n       ArrayDeque<Pair> q = new ArrayDeque<Pair>();\\n        q.add(new Pair(node,0));\\n        while(q.size()>0){\\n            Pair rem = q.poll();\\n            if(visited[rem.node]!=-1){\\n                if(visited[rem.node]!=rem.level) {\\n                    return false;\\n                }\\n            }else{\\n               visited[rem.node]=rem.level; \\n            }\\n            for(int j=0;j<graph[rem.node].length;j++){\\n                if(visited[graph[rem.node][j]]==-1){\\n                  q.add(new Pair(graph[rem.node][j],rem.level+1));   \\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int node;\\n        int level;\\n        Pair(int n,int l){\\n            node=n;\\n            level=l;\\n        }\\n    }\\n    public boolean isBipartite(int[][] graph) {\\n        int visited[] = new int[graph.length];\\n        Arrays.fill(visited,-1);\\n         for(int i =0; i < graph.length; i++){\\n             if(visited[i]==-1){\\n                if(!checkBipartite(graph,visited,i))\\n                return false;\\n             }\\n         }        \\n       return true;       \\n    }\\n    boolean checkBipartite(int[][] graph,int visited[],int node){\\n       ArrayDeque<Pair> q = new ArrayDeque<Pair>();\\n        q.add(new Pair(node,0));\\n        while(q.size()>0){\\n            Pair rem = q.poll();\\n            if(visited[rem.node]!=-1){\\n                if(visited[rem.node]!=rem.level) {\\n                    return false;\\n                }\\n            }else{\\n               visited[rem.node]=rem.level; \\n            }\\n            for(int j=0;j<graph[rem.node].length;j++){\\n                if(visited[graph[rem.node][j]]==-1){\\n                  q.add(new Pair(graph[rem.node][j],rem.level+1));   \\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065185,
                "title": "js-python-java-c-bfs-solution-w-explanation-beats-100",
                "content": "*(Note: This is part of a series of Leetcode solution explanations ([**index**](https://dev.to/seanpgallivan/leetcode-solutions-index-57fl)). If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n***Idea:***\\n\\nThe easy solution here is just to run a **breadth first search** approach using a **stack** (or **queue**). We can pick a random starting node and assign it to a group. We then need to check each **next** node connected to our current node (**curr**); if it\\'s been assigned to a group and that group is the same as **curr**, then this graph is not bipartite and we should **return false**. If it hasn\\'t been assigned, we should assign it to the opposite group of **curr** and move it onto the stack to check.\\n\\nBut what if the graph is made up of several disconnected sections? In that case, we need to perform the previous step several times, so we\\'ll need to iterate through the entire graph and skip any nodes that have already been assigned in a  previous segment.\\n\\nIf we reach the end without error, then we can **return true**.\\n\\n---\\n\\n***Implementation:***\\n\\nIn order to keep track of assignments, we can use a \"visited\" array (**vis**). In this case, **0** means that this node hasn\\'t been visited, and **1** or **2** are the assigned groups. To quickly assign **next** to the opposite of **curr**, we can use a **bitwise XOR** with **3**.\\n```js\\n     base 10:             base 2:\\n   1 ^ 3  =  2         01 ^ 11  =  10\\n   2 ^ 3  =  1         10 ^ 11  =  01\\n```\\n\\n---\\n\\n***Javascript Code:***\\n\\nThe best result for the code below is **76ms / 41.0MB** (beats 100% / 94%).\\n```javascript\\nvar isBipartite = function(graph) {\\n    let len = graph.length, s = [], vis = new Uint8Array(len)\\n    for (let i = 0; i < len; i++) {\\n        if (vis[i]) continue\\n        vis[i] = 1, s.push(i)\\n        while (s.length) {\\n            let curr = s.pop(), edges = graph[curr]\\n            for (let j = 0; j < edges.length; j++) {\\n                let next = edges[j]\\n                if (!vis[next]) vis[next] = vis[curr] ^ 3, s.push(next)\\n                else if (vis[curr] === vis[next]) return false\\n            }\\n        }\\n    }\\n    return true\\n};\\n```\\n\\n---\\n\\n***Python Code:***\\n\\nThe best result for the code below is **160ms / 14.6MB** (beats 99% / 92%).\\n```python\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        glen = len(graph)\\n        s = []\\n        vis = [0] * glen\\n        for i in range(glen):\\n            if vis[i]: continue\\n            vis[i] = 1\\n            s.append(i)\\n            while len(s):\\n                curr = s.pop()\\n                edges = graph[curr]\\n                for next in edges:\\n                    if not vis[next]:\\n                        vis[next] = vis[curr] ^ 3\\n                        s.append(next)\\n                    elif vis[curr] == vis[next]:\\n                        return False\\n        return True\\n```\\n\\n---\\n\\n***Java Code:***\\n\\nThe best result for the code below is **1ms / 39.3MB** (beats 72% / 85%).\\n```java\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int len = graph.length;\\n        Stack<Integer> s = new Stack<Integer>();\\n        int[] vis = new int[len];\\n        for (int i = 0; i < len; i++) {\\n            if (vis[i] > 0) continue;\\n            vis[i] = 1;\\n            s.push(i);\\n            while (s.size() > 0) {\\n                int curr = s.pop();\\n                int[] edges = graph[curr];\\n                for (int next:edges)\\n                    if (vis[next] == 0) {\\n                        vis[next] = vis[curr] ^ 3;\\n                        s.push(next);\\n                    } else if (vis[curr] == vis[next]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n---\\n\\n***C++ Code:***\\n\\nThe best result for the code below is **12ms / 13.6MB** (beats 100% / 65%).\\n```c++\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int len = graph.size();\\n        stack<int> s;\\n        vector<int> vis(len);\\n        for (int i = 0; i < len; i++) {\\n            if (vis[i] > 0) continue;\\n            vis[i] = 1;\\n            s.push(i);\\n            while (s.size() > 0) {\\n                int curr = s.top();\\n                s.pop();\\n                vector<int> edges = graph[curr];\\n                for (int next:edges)\\n                    if (vis[next] == 0) {\\n                        vis[next] = vis[curr] ^ 3;\\n                        s.push(next);\\n                    } else if (vis[curr] == vis[next]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\n     base 10:             base 2:\\n   1 ^ 3  =  2         01 ^ 11  =  10\\n   2 ^ 3  =  1         10 ^ 11  =  01\\n```\n```javascript\\nvar isBipartite = function(graph) {\\n    let len = graph.length, s = [], vis = new Uint8Array(len)\\n    for (let i = 0; i < len; i++) {\\n        if (vis[i]) continue\\n        vis[i] = 1, s.push(i)\\n        while (s.length) {\\n            let curr = s.pop(), edges = graph[curr]\\n            for (let j = 0; j < edges.length; j++) {\\n                let next = edges[j]\\n                if (!vis[next]) vis[next] = vis[curr] ^ 3, s.push(next)\\n                else if (vis[curr] === vis[next]) return false\\n            }\\n        }\\n    }\\n    return true\\n};\\n```\n```python\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        glen = len(graph)\\n        s = []\\n        vis = [0] * glen\\n        for i in range(glen):\\n            if vis[i]: continue\\n            vis[i] = 1\\n            s.append(i)\\n            while len(s):\\n                curr = s.pop()\\n                edges = graph[curr]\\n                for next in edges:\\n                    if not vis[next]:\\n                        vis[next] = vis[curr] ^ 3\\n                        s.append(next)\\n                    elif vis[curr] == vis[next]:\\n                        return False\\n        return True\\n```\n```java\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int len = graph.length;\\n        Stack<Integer> s = new Stack<Integer>();\\n        int[] vis = new int[len];\\n        for (int i = 0; i < len; i++) {\\n            if (vis[i] > 0) continue;\\n            vis[i] = 1;\\n            s.push(i);\\n            while (s.size() > 0) {\\n                int curr = s.pop();\\n                int[] edges = graph[curr];\\n                for (int next:edges)\\n                    if (vis[next] == 0) {\\n                        vis[next] = vis[curr] ^ 3;\\n                        s.push(next);\\n                    } else if (vis[curr] == vis[next]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int len = graph.size();\\n        stack<int> s;\\n        vector<int> vis(len);\\n        for (int i = 0; i < len; i++) {\\n            if (vis[i] > 0) continue;\\n            vis[i] = 1;\\n            s.push(i);\\n            while (s.size() > 0) {\\n                int curr = s.top();\\n                s.pop();\\n                vector<int> edges = graph[curr];\\n                for (int next:edges)\\n                    if (vis[next] == 0) {\\n                        vis[next] = vis[curr] ^ 3;\\n                        s.push(next);\\n                    } else if (vis[curr] == vis[next]) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 789967,
                "title": "java-bfs-clear-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    // bfs\\n    // each node will only be colored once\\n    // When do we color it? We color it when we enqueue it!\\n    \\n    public boolean isBipartite(int[][] graph) {\\n        if(graph == null || graph.length == 0) {\\n            return false;\\n        }\\n        int[] colors = new int[graph.length];\\n        // 0 : uncolored \\n        // 1 : black\\n        //-1 : red\\n            \\n        // use a for loop to ensure that all disconnected vertices will be processed\\n        for(int i = 0; i < graph.length; i++) {\\n            if(colors[i] != 0) {\\n                continue;\\n            }\\n            \\n            int color = 1;\\n            Queue<Integer> queue = new LinkedList<>();\\n            queue.offer(i);\\n            colors[i] = color;\\n            \\n            while(!queue.isEmpty()) {\\n                int cur = queue.poll();\\n                color = - colors[cur];\\n                int[] children = graph[cur];\\n                for(int c : children) {\\n                    if(colors[c] == 0) {\\n                        colors[c] = color;\\n                        queue.offer(c);\\n                    } else if(colors[c] != color) {\\n                        return false;\\n                    }\\n                }       \\n            }\\n        }\\n        return true; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // bfs\\n    // each node will only be colored once\\n    // When do we color it? We color it when we enqueue it!\\n    \\n    public boolean isBipartite(int[][] graph) {\\n        if(graph == null || graph.length == 0) {\\n            return false;\\n        }\\n        int[] colors = new int[graph.length];\\n        // 0 : uncolored \\n        // 1 : black\\n        //-1 : red\\n            \\n        // use a for loop to ensure that all disconnected vertices will be processed\\n        for(int i = 0; i < graph.length; i++) {\\n            if(colors[i] != 0) {\\n                continue;\\n            }\\n            \\n            int color = 1;\\n            Queue<Integer> queue = new LinkedList<>();\\n            queue.offer(i);\\n            colors[i] = color;\\n            \\n            while(!queue.isEmpty()) {\\n                int cur = queue.poll();\\n                color = - colors[cur];\\n                int[] children = graph[cur];\\n                for(int c : children) {\\n                    if(colors[c] == 0) {\\n                        colors[c] = color;\\n                        queue.offer(c);\\n                    } else if(colors[c] != color) {\\n                        return false;\\n                    }\\n                }       \\n            }\\n        }\\n        return true; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 681336,
                "title": "clean-union-find-python-solution",
                "content": "The idea is that each node has to be in a different set than its neighbors, and all its neighbors should be in the same set. \\n\\n```\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        def union(x: int, y: int):\\n            parent_x = find(x)\\n            parent_y = find(y)\\n            parents[parent_x] = parent_y\\n\\n        def find(x: int) -> int:\\n            if parents[x] != x:\\n                parents[x] = find(parents[x])\\n            return parents[x]\\n        \\n\\t\\t# initialize the disjoint sets so each node is in the same set with only itself\\n        parents = [i for i in range(len(graph))]\\n        \\n        for i, neighbors in enumerate(graph):\\n            for j in neighbors:\\n                if find(i) == find(j):\\n                    return False\\n            for j, k in zip(neighbors, neighbors[1:]):\\n                union(j, k)\\n        return True\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        def union(x: int, y: int):\\n            parent_x = find(x)\\n            parent_y = find(y)\\n            parents[parent_x] = parent_y\\n\\n        def find(x: int) -> int:\\n            if parents[x] != x:\\n                parents[x] = find(parents[x])\\n            return parents[x]\\n        \\n\\t\\t# initialize the disjoint sets so each node is in the same set with only itself\\n        parents = [i for i in range(len(graph))]\\n        \\n        for i, neighbors in enumerate(graph):\\n            for j in neighbors:\\n                if find(i) == find(j):\\n                    return False\\n            for j, k in zip(neighbors, neighbors[1:]):\\n                union(j, k)\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 658822,
                "title": "clean-vertex-colouring-approach-with-input-type-explanation",
                "content": "Well The input type may seem a bit Confusing but here\\'s the deal.\\nLet\\'s look at sample input [[1,2,3], [0,2], [0,1,3], [0,2]]. It says that Vertex 0 is coonected with nodes [1,2,3]. Vertex 1 is connected to vertex 0 and 2, vertex 2 is connected to vertex 0,1,3 and so on.\\n\\nFor a better understanding\\n0->[1,2,3]\\n1->[0,2]                      \\n2->[0,1,3]\\n3->[0,2].\\n\\nA more closer look tell us that this is a map<int,vector<int>> type of input \\n\\n```\\nclass Solution {\\npublic:\\n    bool vertexColouring(vector<vector<int>>& graph, vector<int> &color,int src){\\n        \\n        color[src]=1;\\n        queue<int> q;\\n        q.push(src);\\n        \\n        while(!q.empty()){\\n            \\n            int u=q.front();\\n            q.pop();\\n            \\n            vector<int> temp=graph[u];\\n            \\n            for(int i=0;i<temp.size();i++){\\n                \\n                if(color[temp[i]]==-1){\\n                    \\n                    color[temp[i]]=1-color[u];\\n                    q.push(temp[i]);\\n                }\\n                \\n                if(color[temp[i]]==color[u])\\n                    return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        \\n        int n=graph.size();\\n        if(n==0)\\n            return true;\\n        vector<int> color(n,-1);\\n        \\n        for(int i=0;i<n;i++){\\n            if(color[i]==-1){\\n                if(vertexColouring(graph,color,i)==false){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool vertexColouring(vector<vector<int>>& graph, vector<int> &color,int src){\\n        \\n        color[src]=1;\\n        queue<int> q;\\n        q.push(src);\\n        \\n        while(!q.empty()){\\n            \\n            int u=q.front();\\n            q.pop();\\n            \\n            vector<int> temp=graph[u];\\n            \\n            for(int i=0;i<temp.size();i++){\\n                \\n                if(color[temp[i]]==-1){\\n                    \\n                    color[temp[i]]=1-color[u];\\n                    q.push(temp[i]);\\n                }\\n                \\n                if(color[temp[i]]==color[u])\\n                    return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        \\n        int n=graph.size();\\n        if(n==0)\\n            return true;\\n        vector<int> color(n,-1);\\n        \\n        for(int i=0;i<n;i++){\\n            if(color[i]==-1){\\n                if(vertexColouring(graph,color,i)==false){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 444764,
                "title": "c-union-find",
                "content": "OK, coloring is intuitive, but I wanted to solve this problem using a disjoint set. Two observations:\\n-  If the maximum connectivity index of the graph is `1`, the graph is always bipartite.\\n- If a node has two or more neighbors, we join these neighbors into the same group.\\n\\nWith these observations, if we find two connected nodes that are in the same group, the graph is not bipartite.\\n\\n```\\nint ds_find(vector<int> &ds, int i) {\\n    return ds[i] < 0 ? i : ds[i] = ds_find(ds, ds[i]);\\n}\\nbool isBipartite(vector<vector<int>>& graph) {\\n    vector<int> ds(graph.size(), -1);\\n    for (auto i = 0; i < graph.size(); ++i) {\\n        auto sibling_group = -1, node_group = ds_find(ds, i);\\n        for (auto j = 0; j < graph[i].size(); ++j) {\\n            auto prev_group = exchange(sibling_group, ds_find(ds, graph[i][j]));\\n            if (node_group == sibling_group) return false;\\n            if (prev_group >= 0 && prev_group != sibling_group) ds[prev_group] = sibling_group;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint ds_find(vector<int> &ds, int i) {\\n    return ds[i] < 0 ? i : ds[i] = ds_find(ds, ds[i]);\\n}\\nbool isBipartite(vector<vector<int>>& graph) {\\n    vector<int> ds(graph.size(), -1);\\n    for (auto i = 0; i < graph.size(); ++i) {\\n        auto sibling_group = -1, node_group = ds_find(ds, i);\\n        for (auto j = 0; j < graph[i].size(); ++j) {\\n            auto prev_group = exchange(sibling_group, ds_find(ds, graph[i][j]));\\n            if (node_group == sibling_group) return false;\\n            if (prev_group >= 0 && prev_group != sibling_group) ds[prev_group] = sibling_group;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 349830,
                "title": "cpp-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool DFS(int i, vector<int>& visited, vector<vector<int>>& graph){\\n        bool res = true;\\n        for(int j: graph[i]){\\n            if(visited[j] == 0){\\n                visited[j] = -visited[i];\\n                res = DFS(j, visited, graph);\\n            }\\n            else if(visited[j] == visited[i])\\n                return false;\\n            if(!res)\\n                break;\\n        }\\n        return res;\\n    }\\n    \\n    bool isBipartite(vector<vector<int>>& graph) {\\n        vector<int> visited(graph.size());\\n        bool res = true;\\n        for(int i = 0; i < graph.size(); ++ i){\\n            if(visited[i] == 0){\\n                visited[i] = 1;\\n                res = DFS(i, visited, graph);\\n            }\\n            if(!res)\\n                break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool DFS(int i, vector<int>& visited, vector<vector<int>>& graph){\\n        bool res = true;\\n        for(int j: graph[i]){\\n            if(visited[j] == 0){\\n                visited[j] = -visited[i];\\n                res = DFS(j, visited, graph);\\n            }\\n            else if(visited[j] == visited[i])\\n                return false;\\n            if(!res)\\n                break;\\n        }\\n        return res;\\n    }\\n    \\n    bool isBipartite(vector<vector<int>>& graph) {\\n        vector<int> visited(graph.size());\\n        bool res = true;\\n        for(int i = 0; i < graph.size(); ++ i){\\n            if(visited[i] == 0){\\n                visited[i] = 1;\\n                res = DFS(i, visited, graph);\\n            }\\n            if(!res)\\n                break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 169083,
                "title": "python-dfs-solution",
                "content": "Graph dyeing problem which color= 2;\\n```python\\n# -*- coding: utf-8 -*-\\n# @Date    : 2018/9/11\\n\\nclass Solution:\\n    def isBipartite(self, graph):\\n        \"\"\"\\n        :type graph: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        n = len(graph)\\n        color = [0] * n\\n        \\n        def dfs(u, c):\\n            color[u] = c\\n            for v in graph[u]:\\n                if color[v] == c: return False\\n                elif not color[v] and not dfs(v, -c): return False\\n            return True\\n\\n        for i in range(n):\\n            if not color[i]:\\n                if not dfs(i, 1):\\n                    return False\\n        return True\\n\\n```",
                "solutionTags": [],
                "code": "```python\\n# -*- coding: utf-8 -*-\\n# @Date    : 2018/9/11\\n\\nclass Solution:\\n    def isBipartite(self, graph):\\n        \"\"\"\\n        :type graph: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        n = len(graph)\\n        color = [0] * n\\n        \\n        def dfs(u, c):\\n            color[u] = c\\n            for v in graph[u]:\\n                if color[v] == c: return False\\n                elif not color[v] and not dfs(v, -c): return False\\n            return True\\n\\n        for i in range(n):\\n            if not color[i]:\\n                if not dfs(i, 1):\\n                    return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165529,
                "title": "eigenvalues-to-solve-this-problem",
                "content": "```\\n    # The spectrum of a graph is symmetric if and only if it\\'s a bipartite graph.\\n    # We can get that a connected graph G is bipartite if and only if eig_max(G) = -eig_min(G)\\n    def isBipartite(self, graph):\\n        \"\"\"\\n        :type graph: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n\\timport numpy as np\\n        n = len(graph)\\n        adjMatrix = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n):\\n            for j in graph[i]:\\n                adjMatrix[i][j] = 1\\n        \\n        adjMatrix = np.array(adjMatrix)\\n        w, _ = np.linalg.eig(adjMatrix)\\n        return abs(float(max(w) + min(w))) < 0.00001\\n```",
                "solutionTags": [],
                "code": "```\\n    # The spectrum of a graph is symmetric if and only if it\\'s a bipartite graph.\\n    # We can get that a connected graph G is bipartite if and only if eig_max(G) = -eig_min(G)\\n    def isBipartite(self, graph):\\n        \"\"\"\\n        :type graph: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n\\timport numpy as np\\n        n = len(graph)\\n        adjMatrix = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n):\\n            for j in graph[i]:\\n                adjMatrix[i][j] = 1\\n        \\n        adjMatrix = np.array(adjMatrix)\\n        w, _ = np.linalg.eig(adjMatrix)\\n        return abs(float(max(w) + min(w))) < 0.00001\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3968834,
                "title": "easy-c-striver-s-approach-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing DFS graph\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Bipartite Graph means -> no adjacent nodes should have same color.\\n* Make color array to store color either 0 / 1.\\n* Pass 0 color in DFS call of components.\\n* If any node found which has same adjacent node color then return false. simple!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n+2E)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    private:\\n    bool dfs(int node, int col, int color[], vector<vector<int>>& graph)\\n    {\\n        color[node]=col;\\n        \\n        for(auto i: graph[node])\\n        {\\n            if(color[i]==-1)\\n            {\\n                if(dfs(i, !col, color, graph)==false)\\n                {\\n                    return false;\\n                }\\n            }\\n            else if(color[i]==col)\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        \\n        int n=graph.size();\\n\\n        int color[n];\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            color[i]=-1;\\n        }\\n\\n        // components of graph\\n        for(int i=0;i<n;i++)\\n        {\\n            if(color[i]==-1)\\n            {\\n                if(dfs(i, 0, color, graph)==false)\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private:\\n    bool dfs(int node, int col, int color[], vector<vector<int>>& graph)\\n    {\\n        color[node]=col;\\n        \\n        for(auto i: graph[node])\\n        {\\n            if(color[i]==-1)\\n            {\\n                if(dfs(i, !col, color, graph)==false)\\n                {\\n                    return false;\\n                }\\n            }\\n            else if(color[i]==col)\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        \\n        int n=graph.size();\\n\\n        int color[n];\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            color[i]=-1;\\n        }\\n\\n        // components of graph\\n        for(int i=0;i<n;i++)\\n        {\\n            if(color[i]==-1)\\n            {\\n                if(dfs(i, 0, color, graph)==false)\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962570,
                "title": "easy-c-striver-s-approach-using-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing BFS graph\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Bipartite Graph means -> no adjacent nodes should have same color.\\n* Make color array to store color either 0 / 1.\\n* Put first node in queue with color 0, then pop it out and check for it\\'s neighbours node\\n* If any node found which has same adjacent node color then return false. simple!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n+2E)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    private:\\n    bool bfs(int start, int color[], vector<vector<int>>& graph, int n)\\n    {\\n        queue<int> q;\\n        q.push(start);\\n\\n        color[start]=0;\\n\\n        while(!q.empty())\\n        {\\n            int node=q.front();\\n            q.pop();\\n\\n            for(auto i: graph[node])\\n            {\\n                if(color[i]==-1)\\n                {\\n                    color[i]=!color[node];\\n                    q.push(i);\\n                }\\n                else if(color[i]==color[node])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        \\n        int n=graph.size();\\n\\n        int color[n];\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            color[i]=-1;\\n        }\\n\\n        // components of graph\\n        for(int i=0;i<n;i++)\\n        {\\n            if(color[i]==-1)\\n            {\\n                if(bfs(i, color, graph, n)==false)\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private:\\n    bool bfs(int start, int color[], vector<vector<int>>& graph, int n)\\n    {\\n        queue<int> q;\\n        q.push(start);\\n\\n        color[start]=0;\\n\\n        while(!q.empty())\\n        {\\n            int node=q.front();\\n            q.pop();\\n\\n            for(auto i: graph[node])\\n            {\\n                if(color[i]==-1)\\n                {\\n                    color[i]=!color[node];\\n                    q.push(i);\\n                }\\n                else if(color[i]==color[node])\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        \\n        int n=graph.size();\\n\\n        int color[n];\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            color[i]=-1;\\n        }\\n\\n        // components of graph\\n        for(int i=0;i<n;i++)\\n        {\\n            if(color[i]==-1)\\n            {\\n                if(bfs(i, color, graph, n)==false)\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905087,
                "title": "c-bipartite-graph-check-using-bfs-and-color-marking-graph",
                "content": "Method 1\\nBFS\\n*_Time Complexity: O(V + E)\\nSpace Complexity: O(V)_*\\n```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size(); \\n        vector<int> color(n, -1); // Array to store the color of each vertex \\n        queue<int> q;\\n\\n        for(int i = 0; i < n; i++) {\\n            if(color[i] == -1) { // If the current vertex is uncolored\\n                q.push(i); // Enqueue current vertex\\n                color[i] = 0; // Color it with 0\\n                \\n                // Start BFS traversal from the current vertex\\n                while(!q.empty()) {\\n                    int x = q.front(); // Dequeue a vertex\\n                    q.pop();\\n                    \\n                    // Visit all neighbors of the dequeued vertex\\n                    for(auto it : graph[x]) {\\n                        if(color[it] == -1) { // If the neighbor is uncolored\\n                            color[it] = 1 - color[x]; //if color[it] is -1 then there is not color mark the opposite color\\n                            q.push(it);\\n                        }\\n                        else if(color[it] == color[x]) { // If the neighbor has the same color as the current vertex\\n                            return false; // The graph is not bipartite\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return true; \\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/169ada74-2d60-4cca-8565-bd22e7537d53_1691944697.0681944.webp)\\n\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size(); \\n        vector<int> color(n, -1); // Array to store the color of each vertex \\n        queue<int> q;\\n\\n        for(int i = 0; i < n; i++) {\\n            if(color[i] == -1) { // If the current vertex is uncolored\\n                q.push(i); // Enqueue current vertex\\n                color[i] = 0; // Color it with 0\\n                \\n                // Start BFS traversal from the current vertex\\n                while(!q.empty()) {\\n                    int x = q.front(); // Dequeue a vertex\\n                    q.pop();\\n                    \\n                    // Visit all neighbors of the dequeued vertex\\n                    for(auto it : graph[x]) {\\n                        if(color[it] == -1) { // If the neighbor is uncolored\\n                            color[it] = 1 - color[x]; //if color[it] is -1 then there is not color mark the opposite color\\n                            q.push(it);\\n                        }\\n                        else if(color[it] == color[x]) { // If the neighbor has the same color as the current vertex\\n                            return false; // The graph is not bipartite\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return true; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666636,
                "title": "c-easy-dfs-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int i,int col, int color[], vector<vector<int>>& graph){\\n        color[i]=col;\\n        for(auto it:graph[i]){\\n            if(color[it]==-1){\\n                if(dfs(it,!col,color,graph)==false) return false;\\n            }\\n            else if(color[it]==color[i]) return false;\\n        }\\n        return true;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        int color[n];\\n        for (int i=0;i<n;i++) color[i]=-1;\\n        for(int i=0;i<n;i++){\\n            if(color[i]==-1) {\\n                if(dfs(i,0,color,graph)==false) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int i,int col, int color[], vector<vector<int>>& graph){\\n        color[i]=col;\\n        for(auto it:graph[i]){\\n            if(color[it]==-1){\\n                if(dfs(it,!col,color,graph)==false) return false;\\n            }\\n            else if(color[it]==color[i]) return false;\\n        }\\n        return true;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        int color[n];\\n        for (int i=0;i<n;i++) color[i]=-1;\\n        for(int i=0;i<n;i++){\\n            if(color[i]==-1) {\\n                if(dfs(i,0,color,graph)==false) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589932,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(int s,int x,vector<int> &v,vector<vector<int>> &g)\\n    {\\n        if(v[s]!=-1)\\n        {\\n            if(v[s] != x)return false;\\n            return true;\\n        }\\n        v[s] = x;\\n        bool ans = true;\\n        for(auto &i: g[s])\\n        {\\n            ans &= solve(i,x^1,v,g);\\n        }\\n        return ans;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) \\n    {\\n        int n = graph.size(),i;\\n        vector<int> v(n,-1);\\n        vector<vector<int>> g(n);\\n        for(i = 0; i < n; i++)\\n        {\\n            for(auto &j: graph[i])\\n            {\\n                g[i].push_back(j);\\n            }\\n        }\\n        bool ans = true;\\n        for(i = 0; i < n; i++)\\n        {\\n            if(v[i]==-1)\\n            {\\n                ans &= solve(i,0,v,g);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int s,int x,vector<int> &v,vector<vector<int>> &g)\\n    {\\n        if(v[s]!=-1)\\n        {\\n            if(v[s] != x)return false;\\n            return true;\\n        }\\n        v[s] = x;\\n        bool ans = true;\\n        for(auto &i: g[s])\\n        {\\n            ans &= solve(i,x^1,v,g);\\n        }\\n        return ans;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) \\n    {\\n        int n = graph.size(),i;\\n        vector<int> v(n,-1);\\n        vector<vector<int>> g(n);\\n        for(i = 0; i < n; i++)\\n        {\\n            for(auto &j: graph[i])\\n            {\\n                g[i].push_back(j);\\n            }\\n        }\\n        bool ans = true;\\n        for(i = 0; i < n; i++)\\n        {\\n            if(v[i]==-1)\\n            {\\n                ans &= solve(i,0,v,g);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542831,
                "title": "python-simple-and-clean-beats-88",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n# Intuition\\nA graph is bipartite if its nodes can be partitioned into two independent sets such that every edge connects a node in one set with a node in the other set. One way to check if a graph is bipartite is to try to color its nodes using two colors, say red and blue, such that no two adjacent nodes have the same color. If it is possible to color the graph in this way, then it is bipartite.\\n\\n# Approach\\n1. Initialize a dictionary `group` to keep track of the color of each node. The value 0 means that the node has not been colored yet, 1 means that the node has been colored red, and -1 means that the node has been colored blue.\\n2. Iterate over all nodes in the graph. For each unvisited node, start a breadth-first search (BFS) from that node.\\n3. Color the starting node red and add it to a queue.\\n4. While the queue is not empty, remove the first node from the queue.\\n5. For each neighbor of the removed node, check if it has the same color as the removed node. If it does, then return `False` because the graph is not bipartite.\\n6. If the neighbor has not been colored yet, color it with the opposite color of the removed node and add it to the queue.\\n7. If all nodes have been visited and no conflicts were found, return `True` because the graph is bipartite.\\n\\n# Complexity\\n- Time complexity: $$O(n + e)$$ where $$n$$ is the number of nodes in the graph and $$e$$ is the number of edges in the graph.\\n- Space complexity: $$O(n)$$ where $$n$$ is the number of nodes in the graph.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        group = defaultdict(lambda:0)\\n        for i in range(len(graph)):\\n            if not group[i]:\\n                queue = deque()\\n                queue.append(i)\\n                group[i] = 1\\n                while len(queue)>0:\\n                    curr = queue.popleft()\\n                    nodes = graph[curr]\\n                    for node in nodes:\\n                        if group[node]==group[curr]:\\n                            return False\\n                        elif not group[node]:\\n                            group[node] = -1*group[curr]\\n                            queue.append(node)\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        group = defaultdict(lambda:0)\\n        for i in range(len(graph)):\\n            if not group[i]:\\n                queue = deque()\\n                queue.append(i)\\n                group[i] = 1\\n                while len(queue)>0:\\n                    curr = queue.popleft()\\n                    nodes = graph[curr]\\n                    for node in nodes:\\n                        if group[node]==group[curr]:\\n                            return False\\n                        elif not group[node]:\\n                            group[node] = -1*group[curr]\\n                            queue.append(node)\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542765,
                "title": "python-short-and-clean-dfs-functional-programming",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere, `n is number of nodes in graph`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def isBipartite(self, graph: list[list[int]]) -> bool:\\n        T = Hashable\\n        def is_bi(u: T, ga: set[T], gb: set[T]) -> bool:\\n            return u not in gb and (ga.add(u) or all(is_bi(v, gb, ga) for v in graph[u] if v not in gb))\\n        \\n        \\n        group_a, group_b = set(), set()\\n        return all(u in group_a or u in group_b or is_bi(u, group_a, group_b) for u in range(len(graph)))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```python\\nclass Solution:\\n    def isBipartite(self, graph: list[list[int]]) -> bool:\\n        T = Hashable\\n        def is_bi(u: T, ga: set[T], gb: set[T]) -> bool:\\n            return u not in gb and (ga.add(u) or all(is_bi(v, gb, ga) for v in graph[u] if v not in gb))\\n        \\n        \\n        group_a, group_b = set(), set()\\n        return all(u in group_a or u in group_b or is_bi(u, group_a, group_b) for u in range(len(graph)))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542752,
                "title": "java-easy-solution-dfs-beginner-friendly",
                "content": "**Note :**\\nFirst Go Through the Defination of BipartiteGraph then See the solution then You might understand why I have used Color over there in the solution.\\n[check out the link here defination of BipartiteGraph](https://mathworld.wolfram.com/BipartiteGraph.html)\\n# Complexity\\n- Space complexity: O(V), where V is the number of vertices in the graph.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Time complexity:  O(V + E), where V is the number of vertices and E is the number of edges in the graph. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for(int i = 0 ; i < graph.length; i ++){\\n            List<Integer> al = new ArrayList<>();\\n            for(int j = 0 ; j < graph[i].length; j ++){\\n                al.add(graph[i][j]);\\n            }\\n            adj.add(new ArrayList<>(al));\\n        }\\n        boolean visited[] = new boolean[graph.length];\\n        int color[] = new int[graph.length];\\n        Arrays.fill(color,-1);\\n        for(int i = 0 ; i < graph.length; i ++){\\n            if(!visited[i] && !dfs(adj,visited,color,i,0)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean dfs(List<List<Integer>> adj,boolean visited[],int color[],int i,int currColor){\\n        visited[i] = true;\\n        color[i] = currColor;\\n        for(Integer it : adj.get(i)){\\n            if(!visited[it]){\\n                if(!dfs(adj,visited,color,it,currColor == 0 ? 1 : 0)){\\n                    return false;\\n                }\\n            }else if(color[i] == color[it]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n**Please UpVote If you like it Happy Coding :)\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for(int i = 0 ; i < graph.length; i ++){\\n            List<Integer> al = new ArrayList<>();\\n            for(int j = 0 ; j < graph[i].length; j ++){\\n                al.add(graph[i][j]);\\n            }\\n            adj.add(new ArrayList<>(al));\\n        }\\n        boolean visited[] = new boolean[graph.length];\\n        int color[] = new int[graph.length];\\n        Arrays.fill(color,-1);\\n        for(int i = 0 ; i < graph.length; i ++){\\n            if(!visited[i] && !dfs(adj,visited,color,i,0)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean dfs(List<List<Integer>> adj,boolean visited[],int color[],int i,int currColor){\\n        visited[i] = true;\\n        color[i] = currColor;\\n        for(Integer it : adj.get(i)){\\n            if(!visited[it]){\\n                if(!dfs(adj,visited,color,it,currColor == 0 ? 1 : 0)){\\n                    return false;\\n                }\\n            }else if(color[i] == color[it]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542386,
                "title": "c-bipartite-graph-dfs-0-1-color-tc-o-n-sc-o-n",
                "content": "# Intuition\\nwe need to check all nodes by coloring 0 or 1 if it is possible.\\n\\n# Approach\\nif current node is not colored then we will color it with any red or white and than do the dfs in that node and will do coloring of neighbour accordingly to the current node.\\n\\nif coloring is not possible or we found a node with different color than return false otherwise return true.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        \\n        int n=graph.size();\\n        vector<int> color(n+1,-1);\\n        for(int i=0;i<n;i++){\\n            if(color[i]==-1){\\n                queue<int> q;\\n                q.push(i);\\n                color[i]=0;\\n                \\n                while(!q.empty()){\\n                    \\n                    int ele=q.front();\\n                    q.pop();\\n                    \\n                    for(auto it : graph[ele]){\\n                        if(color[it]==-1){\\n                            q.push(it);\\n                            color[it]=1-color[ele];\\n                        }else if(color[it]==color[ele]){\\n                            return false;\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        \\n        int n=graph.size();\\n        vector<int> color(n+1,-1);\\n        for(int i=0;i<n;i++){\\n            if(color[i]==-1){\\n                queue<int> q;\\n                q.push(i);\\n                color[i]=0;\\n                \\n                while(!q.empty()){\\n                    \\n                    int ele=q.front();\\n                    q.pop();\\n                    \\n                    for(auto it : graph[ele]){\\n                        if(color[it]==-1){\\n                            q.push(it);\\n                            color[it]=1-color[ele];\\n                        }else if(color[it]==color[ele]){\\n                            return false;\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542155,
                "title": "simple-java-solution-is-graph-bipartite",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo determine if a graph is bipartite, we can use a graph coloring algorithm. The basic idea is to assign colors to the nodes of the graph in such a way that no two adjacent nodes have the same color. If we can successfully color all the nodes of the graph using only two colors, then the graph is bipartite.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can solve this problem using a breadth-first search (BFS) algorithm. We start by initializing an array colors to store the color of each node. We also initialize a queue queue to perform the BFS traversal.\\n\\nWe iterate over all the nodes in the graph. For each uncolored node, we add it to the queue and assign it a color, such as 0. Then, while the queue is not empty, we dequeue a node and process its neighbors. For each neighbor, if it is uncolored, we assign it the opposite color of its parent node and enqueue it. If it is already colored and has the same color as its parent node, we return false because the graph is not bipartite.\\n\\nIf we finish processing all the nodes without any conflicts, we return true because the graph is bipartite.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity: O(V + E), where V is the number of nodes (vertices) and E is the number of edges in the graph. We visit each node and each edge exactly once during the BFS traversal.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity: O(V), where V is the number of nodes (vertices) in the graph. We use additional space to store the colors and the queue.\\n\\n![24c9fd5a6107b11c01e34e564c8bce0c00dc19924473b055da989c32d1454336.jpg](https://assets.leetcode.com/users/images/57e24d55-9069-4d02-b040-962a1f2dbf93_1684574368.6827009.jpeg)\\n\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int n = graph.length;\\n        int[] colors = new int[n]; // Array to store the color of each node\\n        \\n        // Initialize all nodes with no color (-1)\\n        Arrays.fill(colors, -1);\\n        \\n        // Process each node\\n        for (int i = 0; i < n; i++) {\\n            // If the node is not colored yet, start the coloring process\\n            if (colors[i] == -1) {\\n                if (!dfs(graph, i, 0, colors)) {\\n                    return false; // Graph is not bipartite\\n                }\\n            }\\n        }\\n        \\n        return true; // Graph is bipartite\\n    }\\n    \\n    private boolean dfs(int[][] graph, int node, int color, int[] colors) {\\n        // Color the current node\\n        colors[node] = color;\\n        \\n        // Get the adjacent nodes\\n        int[] neighbors = graph[node];\\n        \\n        // Process each neighbor\\n        for (int neighbor : neighbors) {\\n            // If the neighbor is not colored yet, color it with the opposite color and continue the DFS\\n            if (colors[neighbor] == -1) {\\n                if (!dfs(graph, neighbor, 1 - color, colors)) {\\n                    return false; // Graph is not bipartite\\n                }\\n            }\\n            // If the neighbor is already colored and has the same color as the current node, the graph is not bipartite\\n            else if (colors[neighbor] == color) {\\n                return false;\\n            }\\n        }\\n        \\n        return true; // Graph is bipartite\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int n = graph.length;\\n        int[] colors = new int[n]; // Array to store the color of each node\\n        \\n        // Initialize all nodes with no color (-1)\\n        Arrays.fill(colors, -1);\\n        \\n        // Process each node\\n        for (int i = 0; i < n; i++) {\\n            // If the node is not colored yet, start the coloring process\\n            if (colors[i] == -1) {\\n                if (!dfs(graph, i, 0, colors)) {\\n                    return false; // Graph is not bipartite\\n                }\\n            }\\n        }\\n        \\n        return true; // Graph is bipartite\\n    }\\n    \\n    private boolean dfs(int[][] graph, int node, int color, int[] colors) {\\n        // Color the current node\\n        colors[node] = color;\\n        \\n        // Get the adjacent nodes\\n        int[] neighbors = graph[node];\\n        \\n        // Process each neighbor\\n        for (int neighbor : neighbors) {\\n            // If the neighbor is not colored yet, color it with the opposite color and continue the DFS\\n            if (colors[neighbor] == -1) {\\n                if (!dfs(graph, neighbor, 1 - color, colors)) {\\n                    return false; // Graph is not bipartite\\n                }\\n            }\\n            // If the neighbor is already colored and has the same color as the current node, the graph is not bipartite\\n            else if (colors[neighbor] == color) {\\n                return false;\\n            }\\n        }\\n        \\n        return true; // Graph is bipartite\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542131,
                "title": "c-easy-solution-detailed-approach-bfs-traversal-graph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* The algorithm works by assigning each vertex in the graph a color, either 1 or -1. Vertices that are connected by an edge must have different colors. If the algorithm is able to assign a color to every vertex without finding any vertices that are connected by an edge with the same color, then the graph is bipartite.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* The algorithm works as follows:\\n\\n1) Start at any vertex in the graph.\\n2) Assign the vertex the color 1.\\n3) Add the vertex to a queue.\\n4) While the queue is not empty:\\ni) Remove the first vertex from the queue.\\nii) For each neighbor of the removed vertex:\\n--  If the neighbor has not been assigned a color:\\n-> Assign the neighbor the opposite color of the removed vertex.\\n-> Add the neighbor to the queue.\\n-- If the neighbor has been assigned a color and the color is the same as the removed vertex:\\n-> Return false.\\n* Return true.\\n# Complexity\\n- Time complexity: $$O(V+E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(V)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) \\n    {\\n        int n=graph.size();\\n        vector<int> color(n,0);\\n\\n        for(int node=0; node<n; node++)\\n        {\\n            if(color[node] != 0){\\n                continue;\\n            }\\n            queue<int> q;\\n            q.push(node);\\n            color[node] = 1;\\n            \\n            while(!q.empty()){\\n                int curr = q.front();\\n                q.pop();\\n\\n                for(auto nbr : graph[curr]){\\n                    if(color[nbr] == 0){\\n                        color[nbr] = -color[curr];\\n                        q.push(nbr);\\n                    }\\n                    else if(color[nbr] != -color[curr]){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }  \\n        return true;        \\n    }\\n   \\n};\\n```\\n![UpvoteLeetcode.jpeg](https://assets.leetcode.com/users/images/df68ee3a-8d40-4afc-9049-67b59320f883_1684509648.1239114.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) \\n    {\\n        int n=graph.size();\\n        vector<int> color(n,0);\\n\\n        for(int node=0; node<n; node++)\\n        {\\n            if(color[node] != 0){\\n                continue;\\n            }\\n            queue<int> q;\\n            q.push(node);\\n            color[node] = 1;\\n            \\n            while(!q.empty()){\\n                int curr = q.front();\\n                q.pop();\\n\\n                for(auto nbr : graph[curr]){\\n                    if(color[nbr] == 0){\\n                        color[nbr] = -color[curr];\\n                        q.push(nbr);\\n                    }\\n                    else if(color[nbr] != -color[curr]){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }  \\n        return true;        \\n    }\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540819,
                "title": "c-0-1-approach-99-5-memory-limit",
                "content": "# Intuition\\nBefore Moving we should be clear what is **Bipartite Graph?**\\nAny graph which can be divided into two sets such that there exists zero edges between the elements of same set then that will be known as bipartite graph.\\n\\n**Example**: *Let\\'s say there exist two colors 0 and 1. So, Bipartite graph is a graph such that we can give one color out of the two colors two each of the nodes of the graph such that no two nodes with the same color has an edge between them.*\\n\\n# Approach\\nWe\\'ll make a color array which will store color of two forms 0 and 1. and we\\'ll start moving from the 0th node of the graph and mark its color as 0 then we\\'ll mark the color of all the neighbourhood nodes of the 0th node as 1 and similarly we\\'ll move upto the end of the graph till we complete all the nodes of the graph.\\n\\nIf at any point of time there **exist a node which already has a color that doesn\\'t gets matched with the colorind of the node then we\\'ll return false.**\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool ans= true;\\n    int color[105];\\n    \\n    void check(vector<vector<int>>& graph, int itr, int colorind)\\n    {\\n\\n        if(color[itr]!=-1)\\n        {\\n// Checking the condition that if the older color of the node matches with the current color or not.\\n            if(color[itr]==colorind) return;\\n            ans=false;\\n            return;\\n        }\\n        color[itr]=colorind;\\n        for(int i=0;i<graph[itr].size();i++)\\n        check(graph,graph[itr][i],colorind^1);//Everytime reversing the color by using XOR Operator\\n        return;\\n    }\\n    \\n    bool isBipartite(vector<vector<int>>& graph) {\\n        memset(color,-1,sizeof(color));\\n\\n// Since the graph can maybe not connected completely therefore we\\'ll have to use this for loop to reach all the nodes.\\n        for(int i=0;i<graph.size();i++)\\n        {\\n            if(color[i]==-1)\\n            check(graph,i,1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ans= true;\\n    int color[105];\\n    \\n    void check(vector<vector<int>>& graph, int itr, int colorind)\\n    {\\n\\n        if(color[itr]!=-1)\\n        {\\n// Checking the condition that if the older color of the node matches with the current color or not.\\n            if(color[itr]==colorind) return;\\n            ans=false;\\n            return;\\n        }\\n        color[itr]=colorind;\\n        for(int i=0;i<graph[itr].size();i++)\\n        check(graph,graph[itr][i],colorind^1);//Everytime reversing the color by using XOR Operator\\n        return;\\n    }\\n    \\n    bool isBipartite(vector<vector<int>>& graph) {\\n        memset(color,-1,sizeof(color));\\n\\n// Since the graph can maybe not connected completely therefore we\\'ll have to use this for loop to reach all the nodes.\\n        for(int i=0;i<graph.size();i++)\\n        {\\n            if(color[i]==-1)\\n            check(graph,i,1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540767,
                "title": "python-java-c-bfs-dfs-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to use Graph coloring and perform a Breadth-First-Search (BFS) and Depth-First-Search (DFS) traversals.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize an array, vis, to store the colors of nodes. Initially, all nodes are assigned as -1.\\n- Iterate through graph.\\n- For each uncolored node, perform a BFS/DFS traversal to assign colors to its neighbors.\\n- During the BFS/DFS traversal, assign the first color (e.g., 0) to the starting node and alternate colors for its neighbors. If a neighbor already has a color and it is the same as the current node\\'s color, then the graph is not bipartite and return false then and there.\\n- Continue the BFS/DFS traversal until all nodes are visited or a conflict is detected.\\n- If all nodes are successfully colored without conflicts, return true indicating that the graph is bipartite.\\n- If a conflict occurs during coloring, return false (indicating that the graph is not bipartite).\\n\\n# Complexity\\n- Time complexity: O(V+E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(V)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# UPVOTE Please!!\\n# Code\\n- Python : DFS Approach\\n```\\nclass Solution:\\n    def dfs(self, node, graph, vis, color):\\n        vis[node] = color\\n\\n        for  nod in graph[node]:\\n            if vis[nod] == -1:\\n                if not self.dfs(nod, graph, vis, 1-color):\\n                    return False\\n            elif vis[nod] == vis[node]:\\n                return False\\n        return True\\n    \\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        n = len(graph)\\n        vis = [-1] * n\\n        for i in range(n):\\n            if vis[i] == -1:\\n                if not self.dfs(i, graph, vis, 0):\\n                    return False\\n        \\n        return True\\n```\\n- Python : BFS Approach\\n```\\nfrom collections import deque\\nclass Solution:\\n    def bfs(self, node, graph, vis, color):\\n        que = deque([node])\\n        vis[node] = 0\\n        while que:\\n            node = que.popleft()\\n\\n            for nod in graph[node]:\\n                if vis[nod] == -1:\\n                    vis[nod] = 1 - vis[node]\\n                    que.append(nod)\\n                elif vis[nod] == vis[node]:\\n                    return False\\n        return True\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        n = len(graph)\\n        vis = [-1] * n\\n        for i in range(n):\\n            if vis[i] == -1:\\n                if not self.bfs(i, graph, vis, 0):\\n                    return False\\n        \\n        return True\\n```\\n- Java : DFS Approach\\n```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int n = graph.length;\\n        int vis[] = new int[n];\\n\\n        for(int i = 0; i < n; i++) vis[i] = -1;\\n\\n        for(int i = 0; i < n; i++){\\n            if(vis[i] == -1){\\n                if(!dfs(i, graph, vis, 0)) return false;\\n            }\\n        }\\n        return true;        \\n    }\\n\\n    public boolean dfs(int node, int[][] graph, int[] vis, int color){\\n        vis[node] = color;\\n        for(int j = 0; j < graph[node].length; j++){\\n            int nod = graph[node][j];\\n            if(vis[nod] == -1){\\n                if(!dfs(nod, graph, vis, 1-color)) return false;\\n            }\\n            else if(vis[nod] == color) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n- Java : BFS Approach\\n```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int n = graph.length;\\n        int vis[] = new int[n];\\n\\n        for(int i = 0; i < n; i++) vis[i] = -1;\\n\\n        for(int i = 0; i < n; i++){\\n            if(vis[i] == -1){\\n                if(!bfs(i, graph, vis, 0)) return false;\\n            }\\n        }\\n        return true;        \\n    }\\n\\n    public boolean bfs(int root, int[][] graph, int[] vis, int color){\\n        Deque<Integer> que = new ArrayDeque<>();\\n        que.add(root);\\n        vis[root] = color;\\n        while(que.peek() != null){\\n            int node = que.poll();\\n            for(int nod: graph[node]){\\n                if(vis[nod] == -1){\\n                    vis[nod] = 1 - vis[node];\\n                    que.add(nod);\\n                }\\n                else if(vis[nod] == vis[node]) return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```\\n- C++ : DFS Approach\\n```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<int> vis (n, -1);\\n\\n        for(int i = 0; i < n; i++){\\n            if(vis[i] == -1){\\n                if(!dfs(i, graph, vis, 0)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool dfs(int node, vector<vector<int>> &graph, vector<int> &vis, int color){\\n        vis[node] = color;\\n        for(int nod: graph[node]){\\n            if(vis[nod] == -1){\\n                if(!dfs(nod, graph, vis, 1-color)) return false;\\n            }\\n            else if(vis[nod] == vis[node]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n- C++ : BFS Approach\\n```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<int> vis (n, -1);\\n\\n        for(int i = 0; i < n; i++){\\n            if(vis[i] == -1){\\n                if(!bfs(i, graph, vis, 0)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool bfs(int node, vector<vector<int>> &graph, vector<int> &vis, int color){\\n        queue<int> que;\\n        que.push(node);\\n        vis[node] = color;\\n        while(!que.empty()){\\n            node = que.front(); que.pop();\\n            for(int nod: graph[node]){\\n                if(vis[nod] == -1){\\n                    vis[nod] = 1 - vis[node];\\n                    que.push(nod);\\n                }\\n                else if(vis[nod] == vis[node]) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```\\n# UPVOTE Please!!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def dfs(self, node, graph, vis, color):\\n        vis[node] = color\\n\\n        for  nod in graph[node]:\\n            if vis[nod] == -1:\\n                if not self.dfs(nod, graph, vis, 1-color):\\n                    return False\\n            elif vis[nod] == vis[node]:\\n                return False\\n        return True\\n    \\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        n = len(graph)\\n        vis = [-1] * n\\n        for i in range(n):\\n            if vis[i] == -1:\\n                if not self.dfs(i, graph, vis, 0):\\n                    return False\\n        \\n        return True\\n```\n```\\nfrom collections import deque\\nclass Solution:\\n    def bfs(self, node, graph, vis, color):\\n        que = deque([node])\\n        vis[node] = 0\\n        while que:\\n            node = que.popleft()\\n\\n            for nod in graph[node]:\\n                if vis[nod] == -1:\\n                    vis[nod] = 1 - vis[node]\\n                    que.append(nod)\\n                elif vis[nod] == vis[node]:\\n                    return False\\n        return True\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        n = len(graph)\\n        vis = [-1] * n\\n        for i in range(n):\\n            if vis[i] == -1:\\n                if not self.bfs(i, graph, vis, 0):\\n                    return False\\n        \\n        return True\\n```\n```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int n = graph.length;\\n        int vis[] = new int[n];\\n\\n        for(int i = 0; i < n; i++) vis[i] = -1;\\n\\n        for(int i = 0; i < n; i++){\\n            if(vis[i] == -1){\\n                if(!dfs(i, graph, vis, 0)) return false;\\n            }\\n        }\\n        return true;        \\n    }\\n\\n    public boolean dfs(int node, int[][] graph, int[] vis, int color){\\n        vis[node] = color;\\n        for(int j = 0; j < graph[node].length; j++){\\n            int nod = graph[node][j];\\n            if(vis[nod] == -1){\\n                if(!dfs(nod, graph, vis, 1-color)) return false;\\n            }\\n            else if(vis[nod] == color) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int n = graph.length;\\n        int vis[] = new int[n];\\n\\n        for(int i = 0; i < n; i++) vis[i] = -1;\\n\\n        for(int i = 0; i < n; i++){\\n            if(vis[i] == -1){\\n                if(!bfs(i, graph, vis, 0)) return false;\\n            }\\n        }\\n        return true;        \\n    }\\n\\n    public boolean bfs(int root, int[][] graph, int[] vis, int color){\\n        Deque<Integer> que = new ArrayDeque<>();\\n        que.add(root);\\n        vis[root] = color;\\n        while(que.peek() != null){\\n            int node = que.poll();\\n            for(int nod: graph[node]){\\n                if(vis[nod] == -1){\\n                    vis[nod] = 1 - vis[node];\\n                    que.add(nod);\\n                }\\n                else if(vis[nod] == vis[node]) return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<int> vis (n, -1);\\n\\n        for(int i = 0; i < n; i++){\\n            if(vis[i] == -1){\\n                if(!dfs(i, graph, vis, 0)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool dfs(int node, vector<vector<int>> &graph, vector<int> &vis, int color){\\n        vis[node] = color;\\n        for(int nod: graph[node]){\\n            if(vis[nod] == -1){\\n                if(!dfs(nod, graph, vis, 1-color)) return false;\\n            }\\n            else if(vis[nod] == vis[node]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<int> vis (n, -1);\\n\\n        for(int i = 0; i < n; i++){\\n            if(vis[i] == -1){\\n                if(!bfs(i, graph, vis, 0)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool bfs(int node, vector<vector<int>> &graph, vector<int> &vis, int color){\\n        queue<int> que;\\n        que.push(node);\\n        vis[node] = color;\\n        while(!que.empty()){\\n            node = que.front(); que.pop();\\n            for(int nod: graph[node]){\\n                if(vis[nod] == -1){\\n                    vis[nod] = 1 - vis[node];\\n                    que.push(nod);\\n                }\\n                else if(vis[nod] == vis[node]) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540722,
                "title": "bfs-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing graph color with 2 colors blue and red. where for blue we will take 1 and for red we will take -1 and 0 for uncolored graph.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is simple we first going to traverse the graph with help of BFS and color node with 1 and -1. And if we ancounter a node with colored node which is not oposite to our color we will return false as we need to change the color and it is no longer Bipartite graph.\\n# Complexity\\n- Time complexity: \\n1 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n44 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) \\n    {\\n        int n=graph.length;\\n        int [] color = new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(color[i]!=0)\\n            {\\n                continue;\\n            }\\n            Queue<Integer> q = new LinkedList<>();\\n            q.add(i);\\n            color[i]=1;\\n            \\n            while(!q.isEmpty())\\n                {\\n                    int cur=q.peek();\\n                    q.remove();\\n\\n                        for(int x : graph[cur])\\n                        {\\n                                if(color[x]==0)\\n                                {\\n                                    color[x]=-color[cur];\\n                                    q.add(x);\\n                                }\\n                                else if(color[x]!=-color[cur])\\n                                {\\n                                    return false;\\n                                }\\n                        }\\n                }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) \\n    {\\n        int n=graph.length;\\n        int [] color = new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(color[i]!=0)\\n            {\\n                continue;\\n            }\\n            Queue<Integer> q = new LinkedList<>();\\n            q.add(i);\\n            color[i]=1;\\n            \\n            while(!q.isEmpty())\\n                {\\n                    int cur=q.peek();\\n                    q.remove();\\n\\n                        for(int x : graph[cur])\\n                        {\\n                                if(color[x]==0)\\n                                {\\n                                    color[x]=-color[cur];\\n                                    q.add(x);\\n                                }\\n                                else if(color[x]!=-color[cur])\\n                                {\\n                                    return false;\\n                                }\\n                        }\\n                }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540354,
                "title": "beats-100-java-c-python-elegant-solution-with-dfs",
                "content": "> \\u26A0\\uFE0F **Disclaimer**: The original solution was crafted in Java. Thus, when we mention \"Beats 100%\" it applies specifically to Java submissions. The performance may vary for other languages.\\n# TL;DR\\n``` java []\\nclass Solution {\\n    private static boolean isBipartite(int[][] graph, int[] parts, int i) {\\n        for (var next : graph[i]) {\\n            if (parts[next] == 0) {\\n                parts[next] = -parts[i];\\n                if (!isBipartite(graph, parts, next)) return false;\\n            } else if (parts[next] == parts[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public boolean isBipartite(int[][] graph) {\\n        var parts = new int[graph.length];\\n        for (int i = 0; i < graph.length; i++) {\\n            if (parts[i] != 0) continue;\\n            parts[i] = 1;\\n            if (!isBipartite(graph, parts, i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n``` cpp []\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        vector<int> parts(graph.size(), 0);\\n        for (size_t i = 0; i < graph.size(); i++) {\\n            if (parts[i] != 0) continue;\\n            parts[i] = 1;\\n            if (!isBipartite(graph, parts, i)) return false;\\n        }\\n        return true;\\n    }\\n    \\nprivate:\\n    bool isBipartite(vector<vector<int>>& graph, vector<int>& parts, size_t i) {\\n        for (int next : graph[i]) {\\n            if (parts[next] == 0) {\\n                parts[next] = -parts[i];\\n                if (!isBipartite(graph, parts, next)) return false;\\n            } else if (parts[next] == parts[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```\\n``` python []\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        parts = [0] * len(graph)\\n        for i in range(len(graph)):\\n            if parts[i] != 0:\\n                continue\\n            parts[i] = 1\\n            if not self.dfs(graph, parts, i):\\n                return False\\n        return True\\n    \\n    def dfs(self, graph: List[List[int]], parts: List[int], i: int) -> bool:\\n        for next in graph[i]:\\n            if parts[next] == 0:\\n                parts[next] = -parts[i]\\n                if not self.dfs(graph, parts, next):\\n                    return False\\n            elif parts[next] == parts[i]:\\n                return False\\n        return True\\n``` \\n---\\n#### \\u26A0\\uFE0F Please upvote if you like this solution. \\uD83D\\uDE43\\n---\\n\\n# Approach\\n\\nA graph is bipartite if and only if it is 2-colorable. This means that we can assign one of two colors to each vertex of the graph such that no two adjacent vertices have the same color.\\n\\nTo check if a graph is bipartite, we can perform a depth-first search (DFS) on the graph and try to color the nodes using two colors (represented as `1` and `-1` in the code). \\n\\nFor each node `u` in the graph, we initiate a DFS from `u` only if it has not already been colored, i.e., `parts[u]` is `0`. This is to ensure that all nodes are checked, even if they are part of a disconnected graph.\\n\\nDuring the DFS traversal, if we find an uncolored node, we color it with the opposite color to its predecessor. If we encounter a node that has already been colored, we check if the current color is the same as the color assigned to this node. If it is, then the graph is not bipartite, as two adjacent nodes have the same color, and we return `false`.\\n\\nThe initial call to DFS is made from the `isBipartite` function. This function iterates over all the nodes in the graph, and for each uncolored node, it assigns a color and initiates a DFS from that node.\\n\\nIf no conflicts occur during the coloring process, we return `true` indicating that the graph is bipartite. If a conflict occurs at any point, the DFS function will return `false`, and this result will be propagated up to the `isBipartite` function, causing it to also return `false`.\\n\\n# Complexity \\n- Time complexity: The time complexity of the algorithm is $$O(n + e)$$, where $$n$$ is the number of nodes and $$e$$ is the number of edges in the graph. This is because in the worst case, we might have to visit each node and each edge once when we perform the depth-first search.\\n- Space complexity: The space complexity of the algorithm is $$O(n)$$. This is mainly due to the auxiliary space used by the `parts` array and the recursion stack for the depth-first search. The `parts` array is used to store the color assigned to each node, and it has a size of $$n$$. The DFS is a recursive function, and in the worst case, when the graph is a single line, it might go as deep as $$n$$ levels, using $$O(n)$$ space on the stack.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "``` java []\\nclass Solution {\\n    private static boolean isBipartite(int[][] graph, int[] parts, int i) {\\n        for (var next : graph[i]) {\\n            if (parts[next] == 0) {\\n                parts[next] = -parts[i];\\n                if (!isBipartite(graph, parts, next)) return false;\\n            } else if (parts[next] == parts[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public boolean isBipartite(int[][] graph) {\\n        var parts = new int[graph.length];\\n        for (int i = 0; i < graph.length; i++) {\\n            if (parts[i] != 0) continue;\\n            parts[i] = 1;\\n            if (!isBipartite(graph, parts, i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n``` cpp []\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        vector<int> parts(graph.size(), 0);\\n        for (size_t i = 0; i < graph.size(); i++) {\\n            if (parts[i] != 0) continue;\\n            parts[i] = 1;\\n            if (!isBipartite(graph, parts, i)) return false;\\n        }\\n        return true;\\n    }\\n    \\nprivate:\\n    bool isBipartite(vector<vector<int>>& graph, vector<int>& parts, size_t i) {\\n        for (int next : graph[i]) {\\n            if (parts[next] == 0) {\\n                parts[next] = -parts[i];\\n                if (!isBipartite(graph, parts, next)) return false;\\n            } else if (parts[next] == parts[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```\n``` python []\\nclass Solution:\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        parts = [0] * len(graph)\\n        for i in range(len(graph)):\\n            if parts[i] != 0:\\n                continue\\n            parts[i] = 1\\n            if not self.dfs(graph, parts, i):\\n                return False\\n        return True\\n    \\n    def dfs(self, graph: List[List[int]], parts: List[int], i: int) -> bool:\\n        for next in graph[i]:\\n            if parts[next] == 0:\\n                parts[next] = -parts[i]\\n                if not self.dfs(graph, parts, next):\\n                    return False\\n            elif parts[next] == parts[i]:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540120,
                "title": "c-dfs-easy-to-understand-o-n",
                "content": "DFS\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(n+n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(int s,int x,vector<int> &v,vector<vector<int>> &g){\\n        if(v[s]!=-1){\\n            if(v[s] != x)return false;\\n            return true;\\n        }\\n        v[s] = x;\\n        bool ans = true;\\n        for(auto &i: g[s]){\\n            ans &= solve(i,x^1,v,g);\\n        }\\n        return ans;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size(),i;\\n        vector<int> v(n,-1);\\n        vector<vector<int>> g(n);\\n        for(i = 0; i < n; i++){\\n            for(auto &j: graph[i]){\\n                g[i].push_back(j);\\n            }\\n        }\\n        bool ans = true;\\n        for(i = 0; i < n; i++){\\n            if(v[i]==-1){\\n                ans &= solve(i,0,v,g);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int s,int x,vector<int> &v,vector<vector<int>> &g){\\n        if(v[s]!=-1){\\n            if(v[s] != x)return false;\\n            return true;\\n        }\\n        v[s] = x;\\n        bool ans = true;\\n        for(auto &i: g[s]){\\n            ans &= solve(i,x^1,v,g);\\n        }\\n        return ans;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size(),i;\\n        vector<int> v(n,-1);\\n        vector<vector<int>> g(n);\\n        for(i = 0; i < n; i++){\\n            for(auto &j: graph[i]){\\n                g[i].push_back(j);\\n            }\\n        }\\n        bool ans = true;\\n        for(i = 0; i < n; i++){\\n            if(v[i]==-1){\\n                ans &= solve(i,0,v,g);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375187,
                "title": "t-c-o-v-2e-dfs-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int i, int col,vector<int>& color, vector<vector<int>>& adj)\\n    {\\n        color[i] = col;\\n        for(auto it : adj[i])\\n        {\\n            if(color[it] == -1)\\n            {\\n               if(dfs(it, !col,color, adj) == false)\\n                        return false;\\n            }\\n            else if(color[it] == col)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int V = graph.size();\\n        vector<int> color(V,-1);\\n\\n        for(int i=0; i<V; i++)\\n        {\\n            if(color[i] == -1)\\n            {\\n                if(dfs(i,0,color,graph) == false)\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int i, int col,vector<int>& color, vector<vector<int>>& adj)\\n    {\\n        color[i] = col;\\n        for(auto it : adj[i])\\n        {\\n            if(color[it] == -1)\\n            {\\n               if(dfs(it, !col,color, adj) == false)\\n                        return false;\\n            }\\n            else if(color[it] == col)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int V = graph.size();\\n        vector<int> color(V,-1);\\n\\n        for(int i=0; i<V; i++)\\n        {\\n            if(color[i] == -1)\\n            {\\n                if(dfs(i,0,color,graph) == false)\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332194,
                "title": "easy-to-understand-bfs-dfs-both-approaches",
                "content": "# Complexity\\n- Time complexity: $$O(V)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(V)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n##  dfs\\n```\\nclass Solution {\\npublic:\\n    bool coloring(vector<vector<int>>& graph, int i, vector<int>& color, int to_color){\\n        if (color[i]== to_color)return true;\\n        if (color[i] == 1-to_color)return false;\\n        color[i]= to_color;\\n        for (int it=0; it<graph[i].size(); it++){\\n            if (coloring(graph,graph[i][it],color,1-to_color)==false)return false;\\n        }\\n        return true;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int v= graph.size();\\n        vector<int> color(v,-1);\\n        for (int i=0; i<v; i++){\\n            if (color[i]==-1){\\n                if(coloring(graph,i,color,0)==false)return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n## bfs\\n```\\nclass Solution {\\npublic:\\n    bool coloring(vector<vector<int>>& graph, int i, vector<int>& color){\\n        queue<int> q;\\n        q.push(i);\\n        color[i]=0;\\n        while (!q.empty()){\\n            int node= q.front(); \\n            q.pop();\\n            for (auto val: graph[node]){\\n                if (color[val]==color[node])return false;\\n                else if (color[val]== -1){\\n                    color[val]= 1- color[node];\\n                    q.push(val);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int v= graph.size();\\n        vector<int> color(v,-1);\\n        for (int i=0; i<v; i++){\\n            if (color[i]==-1){\\n                if(coloring(graph,i,color)==false)return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool coloring(vector<vector<int>>& graph, int i, vector<int>& color, int to_color){\\n        if (color[i]== to_color)return true;\\n        if (color[i] == 1-to_color)return false;\\n        color[i]= to_color;\\n        for (int it=0; it<graph[i].size(); it++){\\n            if (coloring(graph,graph[i][it],color,1-to_color)==false)return false;\\n        }\\n        return true;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int v= graph.size();\\n        vector<int> color(v,-1);\\n        for (int i=0; i<v; i++){\\n            if (color[i]==-1){\\n                if(coloring(graph,i,color,0)==false)return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool coloring(vector<vector<int>>& graph, int i, vector<int>& color){\\n        queue<int> q;\\n        q.push(i);\\n        color[i]=0;\\n        while (!q.empty()){\\n            int node= q.front(); \\n            q.pop();\\n            for (auto val: graph[node]){\\n                if (color[val]==color[node])return false;\\n                else if (color[val]== -1){\\n                    color[val]= 1- color[node];\\n                    q.push(val);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int v= graph.size();\\n        vector<int> color(v,-1);\\n        for (int i=0; i<v; i++){\\n            if (color[i]==-1){\\n                if(coloring(graph,i,color)==false)return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234249,
                "title": "dfs",
                "content": "# Approach\\nTry to color verticies into two colors while doing DFS traversal. If we can find an edge that connects verticies of the same color - then graph is not bipartite.\\nSince graph can be disjoint we need to try to start DFS from every not colored vertice.\\n\\n# Complexity\\n- Time complexity: $$O(v + e)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(v)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public bool IsBipartite(int[][] graph)\\n    {\\n        int[] color = new int[graph.Length];\\n        for (int i = 0; i < graph.Length; i++)\\n        {\\n            if (color[i] == 0)\\n            {\\n                color[i] = 1;\\n                if (!Dfs(graph, color, i)) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    private bool Dfs(int[][] graph, int[] color, int v)\\n    {\\n        int currentColor = color[v];\\n        foreach (int w in graph[v])\\n        {\\n            if (color[w] == currentColor) return false;\\n            if (color[w] == 0)\\n            {\\n                color[w] = -currentColor;\\n                if (!Dfs(graph, color, w)) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public bool IsBipartite(int[][] graph)\\n    {\\n        int[] color = new int[graph.Length];\\n        for (int i = 0; i < graph.Length; i++)\\n        {\\n            if (color[i] == 0)\\n            {\\n                color[i] = 1;\\n                if (!Dfs(graph, color, i)) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    private bool Dfs(int[][] graph, int[] color, int v)\\n    {\\n        int currentColor = color[v];\\n        foreach (int w in graph[v])\\n        {\\n            if (color[w] == currentColor) return false;\\n            if (color[w] == 0)\\n            {\\n                color[w] = -currentColor;\\n                if (!Dfs(graph, color, w)) return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219336,
                "title": "785-is-graph-bipartite-java",
                "content": "```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int n=graph.length;\\n        int clr[]=new int[n];\\n        for(int i=0;i<n;i++)\\n        clr[i]=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(clr[i]==-1)\\n            {\\n                if(!bfs(graph,i,clr))\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean bfs (int [][]graph,int n,int [] clr)\\n    {\\n        Queue<Integer> q=new LinkedList();\\n        q.add(n);\\n        clr[n]=0;\\n        while(q.size()!=0)\\n        {\\n            int t=q.poll();\\n            for(int x:graph[t])\\n            {\\n                if(clr[x]==-1)\\n                {\\n                    clr[x]=1-clr[t];\\n                    q.add(x);\\n                }\\n                else if(clr[x]==clr[t])\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) {\\n        int n=graph.length;\\n        int clr[]=new int[n];\\n        for(int i=0;i<n;i++)\\n        clr[i]=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(clr[i]==-1)\\n            {\\n                if(!bfs(graph,i,clr))\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean bfs (int [][]graph,int n,int [] clr)\\n    {\\n        Queue<Integer> q=new LinkedList();\\n        q.add(n);\\n        clr[n]=0;\\n        while(q.size()!=0)\\n        {\\n            int t=q.poll();\\n            for(int x:graph[t])\\n            {\\n                if(clr[x]==-1)\\n                {\\n                    clr[x]=1-clr[t];\\n                    q.add(x);\\n                }\\n                else if(clr[x]==clr[t])\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136503,
                "title": "easy",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[][]} graph\\n * @return {boolean}\\n */\\n\\nlet solve = (src, graph, vis) => {\\n    let q = new Queue();\\n    q.enqueue(src);\\n    vis[src] = 0;\\n\\n    while(!q.isEmpty())\\n    {\\n        let node = q.front();\\n        q.pop();\\n\\n        for(let i=0; i<graph[node].length; i++)\\n        {\\n            let en = graph[node][i];\\n\\n            if(vis[en] != -1 && vis[en] == vis[node])\\n                return false;\\n            else if(vis[en] == -1)\\n            {\\n                // vis[en] = !vis[node];\\n                vis[en] = vis[node] == 0 ? 1 : 0;\\n                q.push(en);\\n            }\\n        }\\n    }\\n\\n    return true;\\n}\\n\\nvar isBipartite = function(graph) {\\n    let n = graph.length;\\n    let vis = new Array(n);\\n    vis.fill(-1);\\n\\n    for(let i=0; i<n; i++)\\n    {\\n        if(vis[i] == -1)\\n        {\\n            let rs = solve(i, graph, vis);\\n            if(rs == false)\\n            {\\n                return false;\\n            }\\n        }\\n    }\\n\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} graph\\n * @return {boolean}\\n */\\n\\nlet solve = (src, graph, vis) => {\\n    let q = new Queue();\\n    q.enqueue(src);\\n    vis[src] = 0;\\n\\n    while(!q.isEmpty())\\n    {\\n        let node = q.front();\\n        q.pop();\\n\\n        for(let i=0; i<graph[node].length; i++)\\n        {\\n            let en = graph[node][i];\\n\\n            if(vis[en] != -1 && vis[en] == vis[node])\\n                return false;\\n            else if(vis[en] == -1)\\n            {\\n                // vis[en] = !vis[node];\\n                vis[en] = vis[node] == 0 ? 1 : 0;\\n                q.push(en);\\n            }\\n        }\\n    }\\n\\n    return true;\\n}\\n\\nvar isBipartite = function(graph) {\\n    let n = graph.length;\\n    let vis = new Array(n);\\n    vis.fill(-1);\\n\\n    for(let i=0; i<n; i++)\\n    {\\n        if(vis[i] == -1)\\n        {\\n            let rs = solve(i, graph, vis);\\n            if(rs == false)\\n            {\\n                return false;\\n            }\\n        }\\n    }\\n\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3130122,
                "title": "java-c-100-solution-using-depth-first-search-is-graph-bipartite",
                "content": "# Complexity\\n- Time complexity: $$O(V+E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(V)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public boolean checkGraph(int[][] graph,int idx,int currColor,int[] color)\\n    {\\n        if(color[idx]!=0)\\n            return color[idx]==currColor;\\n        color[idx]=currColor;\\n        for(int next : graph[idx])\\n            if(!checkGraph(graph,next,-currColor,color))\\n                return false;\\n        return true;\\n    }\\n    public boolean isBipartite(int[][] graph) {\\n        int[] color = new int[graph.length];\\n        for(int i=0;i<graph.length;i++)\\n            if(color[i]==0 && !checkGraph(graph,i,1,color))\\n                return false;\\n        return true;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool checkGraph(vector<vector<int>>& graph,int idx,int currColor,vector<int>& color)\\n    {\\n        if(color[idx]!=0)\\n            return color[idx]==currColor;\\n        color[idx]=currColor;\\n        for(int next : graph[idx])\\n            if(!checkGraph(graph,next,-currColor,color))\\n                return false;\\n        return true;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        vector<int> color(graph.size(),0);\\n        for(int i=0;i<graph.size();i++)\\n            if(color[i]==0 && !checkGraph(graph,i,1,color))\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```Java []\\nclass Solution {\\n    public boolean checkGraph(int[][] graph,int idx,int currColor,int[] color)\\n    {\\n        if(color[idx]!=0)\\n            return color[idx]==currColor;\\n        color[idx]=currColor;\\n        for(int next : graph[idx])\\n            if(!checkGraph(graph,next,-currColor,color))\\n                return false;\\n        return true;\\n    }\\n    public boolean isBipartite(int[][] graph) {\\n        int[] color = new int[graph.length];\\n        for(int i=0;i<graph.length;i++)\\n            if(color[i]==0 && !checkGraph(graph,i,1,color))\\n                return false;\\n        return true;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool checkGraph(vector<vector<int>>& graph,int idx,int currColor,vector<int>& color)\\n    {\\n        if(color[idx]!=0)\\n            return color[idx]==currColor;\\n        color[idx]=currColor;\\n        for(int next : graph[idx])\\n            if(!checkGraph(graph,next,-currColor,color))\\n                return false;\\n        return true;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        vector<int> color(graph.size(),0);\\n        for(int i=0;i<graph.size();i++)\\n            if(color[i]==0 && !checkGraph(graph,i,1,color))\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119055,
                "title": "tommy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O($$ --> \\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool dfs(int index,vector<int> &visited,vector<int> adj[])\\n{\\n    queue<int> queue;\\n    queue.push(index);\\n    visited[index]=0;\\n    while(!queue.empty())\\n    {\\n        int node=queue.front();\\n        queue.pop();\\n        for(auto i:adj[node]){\\n            if(visited[i]==-1)// ever ever visited\\n            {\\n               visited[i]=!visited[node];\\n               queue.push(i);\\n            }\\n            else  //visited\\n            {\\n                if(visited[i]==visited[node]) return false;\\n            }\\n        }\\n    }\\n    return true;\\n}\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        vector<int> adj[n];\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tfor(int j = 0; j < graph[i].size(); j++) {\\n\\t\\t\\t\\tadj[i].push_back(graph[i][j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\n        vector<int> visited(n,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n           if(visited[i]==-1)\\n           {\\n               if(dfs(i,visited,adj)==false) return false;\\n           }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool dfs(int index,vector<int> &visited,vector<int> adj[])\\n{\\n    queue<int> queue;\\n    queue.push(index);\\n    visited[index]=0;\\n    while(!queue.empty())\\n    {\\n        int node=queue.front();\\n        queue.pop();\\n        for(auto i:adj[node]){\\n            if(visited[i]==-1)// ever ever visited\\n            {\\n               visited[i]=!visited[node];\\n               queue.push(i);\\n            }\\n            else  //visited\\n            {\\n                if(visited[i]==visited[node]) return false;\\n            }\\n        }\\n    }\\n    return true;\\n}\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        vector<int> adj[n];\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tfor(int j = 0; j < graph[i].size(); j++) {\\n\\t\\t\\t\\tadj[i].push_back(graph[i][j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\n        vector<int> visited(n,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n           if(visited[i]==-1)\\n           {\\n               if(dfs(i,visited,adj)==false) return false;\\n           }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103107,
                "title": "simple-bfs-striver-sol-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n           int n=graph.size();\\n            \\n            // vector<vector<int>>adj(n);\\n            // for(int i=0;i<n;i++) adj[i].push_back(graph[i]);\\n            queue<int>q;\\n            vector<int>vis(n,-1);\\n           \\n            for(int i=0;i<n;i++) if(vis[i]==-1){ \\n                    \\n                    q.push(i);\\n            vis[i]=1; \\n            while(q.size()){\\n                    \\n                    int node=q.front();\\n                    q.pop();\\n                    for(auto x: graph[node]){\\n                            if(vis[x]==-1){\\n                                    vis[x]=!vis[node];\\n                                    q.push(x);\\n                            }\\n                            else if(vis[x]==vis[node]) return false;\\n                    }\\n                    \\n            }\\n            }\\n            \\n            return true;\\n            \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "class Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n           int n=graph.size();\\n            \\n            // vector<vector<int>>adj(n);\\n            // for(int i=0;i<n;i++) adj[i].push_back(graph[i]);\\n            queue<int>q;\\n            vector<int>vis(n,-1);\\n           \\n            for(int i=0;i<n;i++) if(vis[i]==-1){ \\n                    \\n                    q.push(i);\\n            vis[i]=1; \\n            while(q.size()){\\n                    \\n                    int node=q.front();\\n                    q.pop();\\n                    for(auto x: graph[node]){\\n                            if(vis[x]==-1){\\n                                    vis[x]=!vis[node];\\n                                    q.push(x);\\n                            }",
                "codeTag": "Java"
            },
            {
                "id": 3057860,
                "title": "using-dfs-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkBipartite(vector<vector<int>> &adj, int start,int col,vector<int>&color){\\n        color[start]=col;\\n        for(auto &it:adj[start]){\\n            if(color[it]==-1){\\n                \\n                if(checkBipartite(adj,it,!color[start],color)==false) return false;\\n            }else if(color[it]==color[start]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        vector<vector<int>> adj=graph;\\n        vector<int>color(n,-1);\\n        for(int i=0;i<n;i++){\\n            if(color[i]==-1){\\n                if(checkBipartite(adj,i,0,color)==false){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkBipartite(vector<vector<int>> &adj, int start,int col,vector<int>&color){\\n        color[start]=col;\\n        for(auto &it:adj[start]){\\n            if(color[it]==-1){\\n                \\n                if(checkBipartite(adj,it,!color[start],color)==false) return false;\\n            }else if(color[it]==color[start]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        vector<vector<int>> adj=graph;\\n        vector<int>color(n,-1);\\n        for(int i=0;i<n;i++){\\n            if(color[i]==-1){\\n                if(checkBipartite(adj,i,0,color)==false){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044725,
                "title": "easy-c-solution-beats-85-dfs-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int i,int col,vector<int>&color,vector<vector<int>>&adj,int n){\\n        color[i]=col;\\n        for(auto it:adj[i]){\\n            if(color[it]==-1){\\n                if(dfs(it,!col,color,adj,n)==false) return false;\\n            }\\n            else if(color[it]==col) return false;\\n        }\\n        return true;\\n    }\\n    bool isBipartite(vector<vector<int>>& adj) {\\n        int n=adj.size();\\n        vector<int>color(n,-1);\\n\\t    for(int i=0;i<n;i++){\\n\\t        if(color[i]==-1){\\n\\t            if(dfs(i,0,color,adj,n)==false) return false;\\n\\t        }\\n\\t    }\\n\\t    return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int i,int col,vector<int>&color,vector<vector<int>>&adj,int n){\\n        color[i]=col;\\n        for(auto it:adj[i]){\\n            if(color[it]==-1){\\n                if(dfs(it,!col,color,adj,n)==false) return false;\\n            }\\n            else if(color[it]==col) return false;\\n        }\\n        return true;\\n    }\\n    bool isBipartite(vector<vector<int>>& adj) {\\n        int n=adj.size();\\n        vector<int>color(n,-1);\\n\\t    for(int i=0;i<n;i++){\\n\\t        if(color[i]==-1){\\n\\t            if(dfs(i,0,color,adj,n)==false) return false;\\n\\t        }\\n\\t    }\\n\\t    return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021305,
                "title": "simple-bfs-solution-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        queue<int>q;\\n        vector<int>col(graph.size(),-1);\\n        for(int i=0;i<graph.size();i++){\\n         if(col[i]==-1){\\n             q.push(i);\\n             col[i]=1;\\n             while(!q.empty()){\\n                 auto it=q.front();\\n                 q.pop();\\n                 if(col[it]==0){\\n                    for(auto j:graph[it]){\\n                        if(col[j]==0) return false;\\n                        if(col[j]==-1){\\n                            col[j]=1;\\n                            q.push(j);\\n                        }\\n                    }\\n                 }\\n                 else{\\n                   for(auto j:graph[it]){\\n                        if(col[j]==1) return false;\\n                        if(col[j]==-1){\\n                            col[j]=0;\\n                            q.push(j);\\n                        }\\n                    }  \\n                 }\\n             }\\n         }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        queue<int>q;\\n        vector<int>col(graph.size(),-1);\\n        for(int i=0;i<graph.size();i++){\\n         if(col[i]==-1){\\n             q.push(i);\\n             col[i]=1;\\n             while(!q.empty()){\\n                 auto it=q.front();\\n                 q.pop();\\n                 if(col[it]==0){\\n                    for(auto j:graph[it]){\\n                        if(col[j]==0) return false;\\n                        if(col[j]==-1){\\n                            col[j]=1;\\n                            q.push(j);\\n                        }\\n                    }\\n                 }\\n                 else{\\n                   for(auto j:graph[it]){\\n                        if(col[j]==1) return false;\\n                        if(col[j]==-1){\\n                            col[j]=0;\\n                            q.push(j);\\n                        }\\n                    }  \\n                 }\\n             }\\n         }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017269,
                "title": "intuition-approach-complexity-analysis-commented-code",
                "content": "# Intuition\\nThe first thought the comes across, is to traverse the Graph, assigning opposite colours (say 0 and 1) to the Adjacent Nodes. We keep on doing this, by say DFS(Depth First Search Traversal). The moment we come across a condition that the adjacent nodes have been coloured with the same colour, we can conclude that Graph is not Bipartite.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe take a \\'colour\\' array, in which all the nodes are initially set to -1, as the graph is yet to be traversed. Then, we start with a unvisited node, colour it with 0. Now, we explore its Adjacency List. If we find a node that is yet to be visited, we colour it with the opposite colour and pass that node into further DFS calls for exploration. Else, if an adjacent Node has already been visited, we check its colour. If it is the same as the current node, it means the similar colours have been put together, and the graph cannot be Bipartite. We return false and exit. If after performing the entire traversal, we don\\'t return false and haven\\'t exited yet, it means that the Graph is Bipartite and we return true.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity Analysis\\n#  Time Complexity : O(Vertices + 2*Edges)\\nWe Run a for loop to make sure that all nodes are visited : O (Vertices)\\nWe perform a usual DFS (Depth First Search Traversal) with the Time Complexity of O (Vertices + 2*Edges) in case of an Undirected Graph\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n#  Space Complexity : O(Vertices)\\nWe use a \\'colour\\' array of the dimensions of number of vertices : O(Vertices)\\nAlso, in the worst case, the Depth of Recursion will be as much as the Total Number of Vertices, that is O(Vertices) when the Graph is Skewed\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\nprivate :\\n    bool dfsCheck(int node, vector<vector<int>>&graph, int col,int colour[])\\n    {\\n        // Mark the Current Node with Colour\\n        colour[node] = col;\\n\\n        // Now we move to its Adjacency List\\n        // If we find a neighbouring node uncoloured,\\n        // We give it a colour opposite to the Current Node\\'s Colour\\n\\n        for(auto it : graph[node])\\n        {\\n            if(colour[it]==-1)\\n            {\\n                // Colour it with Opposite Colour & pass it for further DFS calls\\n                if(dfsCheck(it,graph,!col,colour)==false)\\n                {\\n                    return false;\\n                }\\n            }\\n            if(colour[it]==col)\\n            {\\n                // If the Adjacent Node has the Same Colour as the Current Node\\n                // Then Conflicting Colours are side by side\\n                // And the Graph is not Bipartite\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph)\\n    {\\n        // Finding the Number of Vertices\\n        int V = graph.size();\\n        // Colour Array \\n        int colour[V];\\n        for(int i=0; i<V; i++)\\n        {\\n            colour[i] = -1;\\n            // Initializing all the Nodes as Uncoloured\\n        }\\n\\n        // Dfs Approach\\n        // Since it is mentioned that all the Nodes may not be connected,\\n        // That is, there can be isolated components,\\n        // We run this for loop to make sure all the Nodes are Visited\\n\\n        // Default colour to start exploring any component be set to 0,\\n      \\n        for(int i=0; i<V;i++)\\n        {\\n            if(colour[i]==-1)\\n            {\\n                if(dfsCheck(i,graph,0,colour)==false)\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\nprivate :\\n    bool dfsCheck(int node, vector<vector<int>>&graph, int col,int colour[])\\n    {\\n        // Mark the Current Node with Colour\\n        colour[node] = col;\\n\\n        // Now we move to its Adjacency List\\n        // If we find a neighbouring node uncoloured,\\n        // We give it a colour opposite to the Current Node\\'s Colour\\n\\n        for(auto it : graph[node])\\n        {\\n            if(colour[it]==-1)\\n            {\\n                // Colour it with Opposite Colour & pass it for further DFS calls\\n                if(dfsCheck(it,graph,!col,colour)==false)\\n                {\\n                    return false;\\n                }\\n            }\\n            if(colour[it]==col)\\n            {\\n                // If the Adjacent Node has the Same Colour as the Current Node\\n                // Then Conflicting Colours are side by side\\n                // And the Graph is not Bipartite\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph)\\n    {\\n        // Finding the Number of Vertices\\n        int V = graph.size();\\n        // Colour Array \\n        int colour[V];\\n        for(int i=0; i<V; i++)\\n        {\\n            colour[i] = -1;\\n            // Initializing all the Nodes as Uncoloured\\n        }\\n\\n        // Dfs Approach\\n        // Since it is mentioned that all the Nodes may not be connected,\\n        // That is, there can be isolated components,\\n        // We run this for loop to make sure all the Nodes are Visited\\n\\n        // Default colour to start exploring any component be set to 0,\\n      \\n        for(int i=0; i<V;i++)\\n        {\\n            if(colour[i]==-1)\\n            {\\n                if(dfsCheck(i,graph,0,colour)==false)\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963913,
                "title": "c-simple-bruteforce-by-bfs-clean-easy-code",
                "content": "![image](https://assets.leetcode.com/users/images/a2df064c-fb0c-4d87-8f5f-ce933c2e9119_1672245900.6901555.png)\\n\\n**T->O(n+2E) && S->O(n) [same as BFS Algo]**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tbool check(int start,vector<vector<int>>& adj,vector<int>& color){\\n\\t\\t\\t\\tqueue<int>q;\\n\\t\\t\\t\\tcolor[start]=0;\\n\\t\\t\\t\\tq.push(start);\\n\\t\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\t\\tint prev=q.front();\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\tfor(auto curr: adj[prev]){\\n\\t\\t\\t\\t\\t\\tif(color[curr]==-1){\\n\\t\\t\\t\\t\\t\\t\\tcolor[curr]=!color[prev];\\n\\t\\t\\t\\t\\t\\t\\tq.push(curr);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if(color[curr]==color[prev]) return false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tbool isBipartite(vector<vector<int>>& adj) {\\n\\t\\t\\t\\tint n=adj.size();\\n\\t\\t\\t\\tvector<int> color(n,-1);\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\tif(color[i]==-1 && !check(i,adj,color)) return false; \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tbool check(int start,vector<vector<int>>& adj,vector<int>& color){\\n\\t\\t\\t\\tqueue<int>q;\\n\\t\\t\\t\\tcolor[start]=0;\\n\\t\\t\\t\\tq.push(start);\\n\\t\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\t\\tint prev=q.front();\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\tfor(auto curr: adj[prev]){\\n\\t\\t\\t\\t\\t\\tif(color[curr]==-1){\\n\\t\\t\\t\\t\\t\\t\\tcolor[curr]=!color[prev];\\n\\t\\t\\t\\t\\t\\t\\tq.push(curr);\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2885211,
                "title": "c-bfs-dfs-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Code\\nBFS:-\\n```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int v[graph.size()];\\n        for(int i=0; i<graph.size(); i++){v[i]=-1;}\\n        for(int i=0; i<graph.size(); i++){\\n            if(v[i]==-1){\\n                v[i]=0;\\n                queue<int>q;\\n                q.push(i);\\n                while(!q.empty()){\\n                    int ind=q.front();\\n                    q.pop();\\n                    for(auto it: graph[ind]){\\n                        if(v[it]==-1){\\n                            v[it]=!v[ind];\\n                            q.push(it);\\n                        }\\n                        else if(v[it]==v[ind]){return false;}\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\nDFS:-\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int x, int y, int v[], vector<vector<int>>& graph){\\n        v[x]=y;\\n        for(auto it: graph[x]){\\n            if(v[it]==-1){\\n                if(!dfs(it, !y, v, graph)){return false;};\\n            }\\n            else if(v[it]==v[x]){return false;}\\n        }\\n        return true;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int v[graph.size()];\\n        for(int i=0; i<graph.size(); i++){v[i]=-1;}\\n        for(int i=0; i<graph.size(); i++){\\n            if(v[i]==-1){\\n                if(!dfs(i, 0, v, graph)){return false;};\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int v[graph.size()];\\n        for(int i=0; i<graph.size(); i++){v[i]=-1;}\\n        for(int i=0; i<graph.size(); i++){\\n            if(v[i]==-1){\\n                v[i]=0;\\n                queue<int>q;\\n                q.push(i);\\n                while(!q.empty()){\\n                    int ind=q.front();\\n                    q.pop();\\n                    for(auto it: graph[ind]){\\n                        if(v[it]==-1){\\n                            v[it]=!v[ind];\\n                            q.push(it);\\n                        }\\n                        else if(v[it]==v[ind]){return false;}\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool dfs(int x, int y, int v[], vector<vector<int>>& graph){\\n        v[x]=y;\\n        for(auto it: graph[x]){\\n            if(v[it]==-1){\\n                if(!dfs(it, !y, v, graph)){return false;};\\n            }\\n            else if(v[it]==v[x]){return false;}\\n        }\\n        return true;\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int v[graph.size()];\\n        for(int i=0; i<graph.size(); i++){v[i]=-1;}\\n        for(int i=0; i<graph.size(); i++){\\n            if(v[i]==-1){\\n                if(!dfs(i, 0, v, graph)){return false;};\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862941,
                "title": "java-dfs-code-100-00-faster-93-59-less-memory-usage",
                "content": "```\\nclass Solution {\\n    private boolean isSameColored(int node,int color,int[] vis,int[][] graph){\\n        vis[node]=color;\\n        //neighbours\\n        for(int it:graph[node]){\\n            if(vis[it]==0){\\n                if(isSameColored(it,-color,vis,graph)==true)\\n                    return true;\\n            }\\n            else if(vis[it]==color)\\n                return true;\\n        }\\n        return false;\\n        \\n    }\\n    public boolean isBipartite(int[][] graph) {\\n        int n=graph.length;\\n        int[] vis = new int[n];\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                if(isSameColored(i,1,vis,graph)==true)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    private boolean isSameColored(int node,int color,int[] vis,int[][] graph){\\n        vis[node]=color;\\n        //neighbours\\n        for(int it:graph[node]){\\n            if(vis[it]==0){\\n                if(isSameColored(it,-color,vis,graph)==true)\\n                    return true;\\n            }\\n            else if(vis[it]==color)\\n                return true;\\n        }\\n        return false;\\n        \\n    }\\n    public boolean isBipartite(int[][] graph) {\\n        int n=graph.length;\\n        int[] vis = new int[n];\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                if(isSameColored(i,1,vis,graph)==true)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564810,
                "content": [
                    {
                        "username": "sasuke_uchiha",
                        "content": "Hi, Can please someone help me explainning How the input\\n[[1,3], [0,2], [1,3], [0,2]] \\nis working. I am not able to understand How does this input make this graph\\n0----1\\n|      |\\n|      |\\n3----2"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "0----1, 3\\n1----0, 2\\n2----1, 3\\n3----0, 2\\n\\n\\n 0-----1\\n |         | \\n3----- 2\\n\\n\\ntwo components"
                    },
                    {
                        "username": "RahulRaniwal",
                        "content": "for every value of row it is given that which node is connected to it\n\n0 -> 1 ,3\n1 -> 0 , 2\n2 -> 1 , 3\n3 -> 0 , 2\n\n0 ------- 1\n|              |\n|              |\n3 ------- 2\nThats how your graph will look \n[@Sunidhi Chaudhary](/sasuke_uchiha)"
                    },
                    {
                        "username": "gflanary",
                        "content": "This is a straightforward problem, but the description is positively awful.\\n\\nIf they had an image with disjoint sets and especially if they had one with colorized groupings, it would be clear what the intent was."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I found the description perfectly clear and rigorous, but I didn't find the problem straight forward at all.\nI guess I gotta work on my graph problems and you have to work on your problem reading/analysis!\nRoom for improvement for all"
                    },
                    {
                        "username": "mc_montecarlo",
                        "content": "I have a doubt with the test-case:\\n[[4],[],[4],[4],[0,2,3]]\\n\\nAbove test-case represents a graph is isn\\'t connected. But, the expected result of above is true. So my question is, how can a dis-connected graph be bi-partite?"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "A disconnected graph is bipartite if all the individually connected components are bipartite themselves. i.e, a singly disconnected graph with 2 or more regions is bipartite if all of those regions are bipartite."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "[@sasta_samurai](/sasta_samurai) \"questions says you should form two sets where every element of both sets are connected. \"\\nNo the question doesn\\'t say that.\\nIt says every \\'edge\\' must connect nodes from A and B.\\nA disconnected node can be put in any group because it has no edge."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Unfortunately the problem description is totally unclear about how to handle unconnected graphs. I hate when it\\'s a coin toss about how to handle some specific test case. In this case I agree that it should be false and got a WA because of it."
                    },
                    {
                        "username": "1dan_1609_",
                        "content": "In a disconnected graph. you have to basically check if each connected sub graph is bipartite."
                    },
                    {
                        "username": "sasta_samurai",
                        "content": "[@Riantix](/Riantix) I don\\'t think your conclusion is correct, questions says you should form two sets where every element of both sets are connected. [0,1,2] [3,4] 1 is not connected to any nodes in original graph while in your answer, it is connected to 3 and 4."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@Riantix](/Riantix)  dumb dumb dumb\\n"
                    },
                    {
                        "username": "user1737NM",
                        "content": "[@Riantix](/Riantix) how come 3 and 4 can belong to the same group?"
                    },
                    {
                        "username": "Riantix",
                        "content": "[@yyol](/yyol) A bipartite graph simply means you have can have two groups, each node goes to exactly one group, and there are no edges between two nodes in the same group. Thus an unconnected graph can still be bipartite.\\n\\nAs an example, a graph with 5 nodes and no edges (thus being unconnected) will be bipartite. You can form the two groups as [0, 1, 2] [3, 4] or [0], [1, 2, 3, 4], or others."
                    },
                    {
                        "username": "yyol",
                        "content": "same question, did you have conclusion?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "My respect for **76 / 81 testcase**"
                    },
                    {
                        "username": "SrirajBehera",
                        "content": "it means component graphs are present, which is not mentioned in the awful description :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is that the input [[]] one?  it nailed me too"
                    },
                    {
                        "username": "02Gaurav",
                        "content": "i also passed 79/81 but 2 cases i dont know where exactly the problem is. Seems greedy approach wont work\\n"
                    },
                    {
                        "username": "lukevastus",
                        "content": "Apparently the graph should look like a triangle. \t\nSo why is the number 2 neither in graph[0] or in graph[1]?\nThe correct test case should be [[1, 2], [0, 2], [0, 1]]\n"
                    },
                    {
                        "username": "user8228j",
                        "content": "an hour and 15 minutes of my life gone."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/is-graph-bipartite/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Coloring by Depth-First Search [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "so how does [[1,3], [0,2], [1,3], [0,2]]\\nturn into a square diagram? two [1,3] and two [0,2]? \\n[1,3] means x at 1 and y at 3?"
                    },
                    {
                        "username": "v1shal",
                        "content": "In adj list representation, array at ith position represents the neighbors of ith node\\n\\n0--> 1,3\\n1--> 0,2\\n2--> 1,3\\n3--> 0,2\\n\\nfor ex - neighbors of node \"0\" is 1 and 3 and so on.\\n\\nWhen you connect them it would turn into a square"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Is this description so good that they locked the editorial \\uD83D\\uDE44"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/possible-bipartition/description/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Thank you for the info. The description over there sounds like a directed graph. The fact that ai dislikes bi cannot imply that  bi dislikes ai"
                    }
                ]
            },
            {
                "id": 1712857,
                "content": [
                    {
                        "username": "sasuke_uchiha",
                        "content": "Hi, Can please someone help me explainning How the input\\n[[1,3], [0,2], [1,3], [0,2]] \\nis working. I am not able to understand How does this input make this graph\\n0----1\\n|      |\\n|      |\\n3----2"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "0----1, 3\\n1----0, 2\\n2----1, 3\\n3----0, 2\\n\\n\\n 0-----1\\n |         | \\n3----- 2\\n\\n\\ntwo components"
                    },
                    {
                        "username": "RahulRaniwal",
                        "content": "for every value of row it is given that which node is connected to it\n\n0 -> 1 ,3\n1 -> 0 , 2\n2 -> 1 , 3\n3 -> 0 , 2\n\n0 ------- 1\n|              |\n|              |\n3 ------- 2\nThats how your graph will look \n[@Sunidhi Chaudhary](/sasuke_uchiha)"
                    },
                    {
                        "username": "gflanary",
                        "content": "This is a straightforward problem, but the description is positively awful.\\n\\nIf they had an image with disjoint sets and especially if they had one with colorized groupings, it would be clear what the intent was."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I found the description perfectly clear and rigorous, but I didn't find the problem straight forward at all.\nI guess I gotta work on my graph problems and you have to work on your problem reading/analysis!\nRoom for improvement for all"
                    },
                    {
                        "username": "mc_montecarlo",
                        "content": "I have a doubt with the test-case:\\n[[4],[],[4],[4],[0,2,3]]\\n\\nAbove test-case represents a graph is isn\\'t connected. But, the expected result of above is true. So my question is, how can a dis-connected graph be bi-partite?"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "A disconnected graph is bipartite if all the individually connected components are bipartite themselves. i.e, a singly disconnected graph with 2 or more regions is bipartite if all of those regions are bipartite."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "[@sasta_samurai](/sasta_samurai) \"questions says you should form two sets where every element of both sets are connected. \"\\nNo the question doesn\\'t say that.\\nIt says every \\'edge\\' must connect nodes from A and B.\\nA disconnected node can be put in any group because it has no edge."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Unfortunately the problem description is totally unclear about how to handle unconnected graphs. I hate when it\\'s a coin toss about how to handle some specific test case. In this case I agree that it should be false and got a WA because of it."
                    },
                    {
                        "username": "1dan_1609_",
                        "content": "In a disconnected graph. you have to basically check if each connected sub graph is bipartite."
                    },
                    {
                        "username": "sasta_samurai",
                        "content": "[@Riantix](/Riantix) I don\\'t think your conclusion is correct, questions says you should form two sets where every element of both sets are connected. [0,1,2] [3,4] 1 is not connected to any nodes in original graph while in your answer, it is connected to 3 and 4."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@Riantix](/Riantix)  dumb dumb dumb\\n"
                    },
                    {
                        "username": "user1737NM",
                        "content": "[@Riantix](/Riantix) how come 3 and 4 can belong to the same group?"
                    },
                    {
                        "username": "Riantix",
                        "content": "[@yyol](/yyol) A bipartite graph simply means you have can have two groups, each node goes to exactly one group, and there are no edges between two nodes in the same group. Thus an unconnected graph can still be bipartite.\\n\\nAs an example, a graph with 5 nodes and no edges (thus being unconnected) will be bipartite. You can form the two groups as [0, 1, 2] [3, 4] or [0], [1, 2, 3, 4], or others."
                    },
                    {
                        "username": "yyol",
                        "content": "same question, did you have conclusion?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "My respect for **76 / 81 testcase**"
                    },
                    {
                        "username": "SrirajBehera",
                        "content": "it means component graphs are present, which is not mentioned in the awful description :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is that the input [[]] one?  it nailed me too"
                    },
                    {
                        "username": "02Gaurav",
                        "content": "i also passed 79/81 but 2 cases i dont know where exactly the problem is. Seems greedy approach wont work\\n"
                    },
                    {
                        "username": "lukevastus",
                        "content": "Apparently the graph should look like a triangle. \t\nSo why is the number 2 neither in graph[0] or in graph[1]?\nThe correct test case should be [[1, 2], [0, 2], [0, 1]]\n"
                    },
                    {
                        "username": "user8228j",
                        "content": "an hour and 15 minutes of my life gone."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/is-graph-bipartite/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Coloring by Depth-First Search [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "so how does [[1,3], [0,2], [1,3], [0,2]]\\nturn into a square diagram? two [1,3] and two [0,2]? \\n[1,3] means x at 1 and y at 3?"
                    },
                    {
                        "username": "v1shal",
                        "content": "In adj list representation, array at ith position represents the neighbors of ith node\\n\\n0--> 1,3\\n1--> 0,2\\n2--> 1,3\\n3--> 0,2\\n\\nfor ex - neighbors of node \"0\" is 1 and 3 and so on.\\n\\nWhen you connect them it would turn into a square"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Is this description so good that they locked the editorial \\uD83D\\uDE44"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/possible-bipartition/description/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Thank you for the info. The description over there sounds like a directed graph. The fact that ai dislikes bi cannot imply that  bi dislikes ai"
                    }
                ]
            },
            {
                "id": 1569879,
                "content": [
                    {
                        "username": "sasuke_uchiha",
                        "content": "Hi, Can please someone help me explainning How the input\\n[[1,3], [0,2], [1,3], [0,2]] \\nis working. I am not able to understand How does this input make this graph\\n0----1\\n|      |\\n|      |\\n3----2"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "0----1, 3\\n1----0, 2\\n2----1, 3\\n3----0, 2\\n\\n\\n 0-----1\\n |         | \\n3----- 2\\n\\n\\ntwo components"
                    },
                    {
                        "username": "RahulRaniwal",
                        "content": "for every value of row it is given that which node is connected to it\n\n0 -> 1 ,3\n1 -> 0 , 2\n2 -> 1 , 3\n3 -> 0 , 2\n\n0 ------- 1\n|              |\n|              |\n3 ------- 2\nThats how your graph will look \n[@Sunidhi Chaudhary](/sasuke_uchiha)"
                    },
                    {
                        "username": "gflanary",
                        "content": "This is a straightforward problem, but the description is positively awful.\\n\\nIf they had an image with disjoint sets and especially if they had one with colorized groupings, it would be clear what the intent was."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I found the description perfectly clear and rigorous, but I didn't find the problem straight forward at all.\nI guess I gotta work on my graph problems and you have to work on your problem reading/analysis!\nRoom for improvement for all"
                    },
                    {
                        "username": "mc_montecarlo",
                        "content": "I have a doubt with the test-case:\\n[[4],[],[4],[4],[0,2,3]]\\n\\nAbove test-case represents a graph is isn\\'t connected. But, the expected result of above is true. So my question is, how can a dis-connected graph be bi-partite?"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "A disconnected graph is bipartite if all the individually connected components are bipartite themselves. i.e, a singly disconnected graph with 2 or more regions is bipartite if all of those regions are bipartite."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "[@sasta_samurai](/sasta_samurai) \"questions says you should form two sets where every element of both sets are connected. \"\\nNo the question doesn\\'t say that.\\nIt says every \\'edge\\' must connect nodes from A and B.\\nA disconnected node can be put in any group because it has no edge."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Unfortunately the problem description is totally unclear about how to handle unconnected graphs. I hate when it\\'s a coin toss about how to handle some specific test case. In this case I agree that it should be false and got a WA because of it."
                    },
                    {
                        "username": "1dan_1609_",
                        "content": "In a disconnected graph. you have to basically check if each connected sub graph is bipartite."
                    },
                    {
                        "username": "sasta_samurai",
                        "content": "[@Riantix](/Riantix) I don\\'t think your conclusion is correct, questions says you should form two sets where every element of both sets are connected. [0,1,2] [3,4] 1 is not connected to any nodes in original graph while in your answer, it is connected to 3 and 4."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@Riantix](/Riantix)  dumb dumb dumb\\n"
                    },
                    {
                        "username": "user1737NM",
                        "content": "[@Riantix](/Riantix) how come 3 and 4 can belong to the same group?"
                    },
                    {
                        "username": "Riantix",
                        "content": "[@yyol](/yyol) A bipartite graph simply means you have can have two groups, each node goes to exactly one group, and there are no edges between two nodes in the same group. Thus an unconnected graph can still be bipartite.\\n\\nAs an example, a graph with 5 nodes and no edges (thus being unconnected) will be bipartite. You can form the two groups as [0, 1, 2] [3, 4] or [0], [1, 2, 3, 4], or others."
                    },
                    {
                        "username": "yyol",
                        "content": "same question, did you have conclusion?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "My respect for **76 / 81 testcase**"
                    },
                    {
                        "username": "SrirajBehera",
                        "content": "it means component graphs are present, which is not mentioned in the awful description :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is that the input [[]] one?  it nailed me too"
                    },
                    {
                        "username": "02Gaurav",
                        "content": "i also passed 79/81 but 2 cases i dont know where exactly the problem is. Seems greedy approach wont work\\n"
                    },
                    {
                        "username": "lukevastus",
                        "content": "Apparently the graph should look like a triangle. \t\nSo why is the number 2 neither in graph[0] or in graph[1]?\nThe correct test case should be [[1, 2], [0, 2], [0, 1]]\n"
                    },
                    {
                        "username": "user8228j",
                        "content": "an hour and 15 minutes of my life gone."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/is-graph-bipartite/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Coloring by Depth-First Search [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "so how does [[1,3], [0,2], [1,3], [0,2]]\\nturn into a square diagram? two [1,3] and two [0,2]? \\n[1,3] means x at 1 and y at 3?"
                    },
                    {
                        "username": "v1shal",
                        "content": "In adj list representation, array at ith position represents the neighbors of ith node\\n\\n0--> 1,3\\n1--> 0,2\\n2--> 1,3\\n3--> 0,2\\n\\nfor ex - neighbors of node \"0\" is 1 and 3 and so on.\\n\\nWhen you connect them it would turn into a square"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Is this description so good that they locked the editorial \\uD83D\\uDE44"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/possible-bipartition/description/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Thank you for the info. The description over there sounds like a directed graph. The fact that ai dislikes bi cannot imply that  bi dislikes ai"
                    }
                ]
            },
            {
                "id": 1796416,
                "content": [
                    {
                        "username": "sasuke_uchiha",
                        "content": "Hi, Can please someone help me explainning How the input\\n[[1,3], [0,2], [1,3], [0,2]] \\nis working. I am not able to understand How does this input make this graph\\n0----1\\n|      |\\n|      |\\n3----2"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "0----1, 3\\n1----0, 2\\n2----1, 3\\n3----0, 2\\n\\n\\n 0-----1\\n |         | \\n3----- 2\\n\\n\\ntwo components"
                    },
                    {
                        "username": "RahulRaniwal",
                        "content": "for every value of row it is given that which node is connected to it\n\n0 -> 1 ,3\n1 -> 0 , 2\n2 -> 1 , 3\n3 -> 0 , 2\n\n0 ------- 1\n|              |\n|              |\n3 ------- 2\nThats how your graph will look \n[@Sunidhi Chaudhary](/sasuke_uchiha)"
                    },
                    {
                        "username": "gflanary",
                        "content": "This is a straightforward problem, but the description is positively awful.\\n\\nIf they had an image with disjoint sets and especially if they had one with colorized groupings, it would be clear what the intent was."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I found the description perfectly clear and rigorous, but I didn't find the problem straight forward at all.\nI guess I gotta work on my graph problems and you have to work on your problem reading/analysis!\nRoom for improvement for all"
                    },
                    {
                        "username": "mc_montecarlo",
                        "content": "I have a doubt with the test-case:\\n[[4],[],[4],[4],[0,2,3]]\\n\\nAbove test-case represents a graph is isn\\'t connected. But, the expected result of above is true. So my question is, how can a dis-connected graph be bi-partite?"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "A disconnected graph is bipartite if all the individually connected components are bipartite themselves. i.e, a singly disconnected graph with 2 or more regions is bipartite if all of those regions are bipartite."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "[@sasta_samurai](/sasta_samurai) \"questions says you should form two sets where every element of both sets are connected. \"\\nNo the question doesn\\'t say that.\\nIt says every \\'edge\\' must connect nodes from A and B.\\nA disconnected node can be put in any group because it has no edge."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Unfortunately the problem description is totally unclear about how to handle unconnected graphs. I hate when it\\'s a coin toss about how to handle some specific test case. In this case I agree that it should be false and got a WA because of it."
                    },
                    {
                        "username": "1dan_1609_",
                        "content": "In a disconnected graph. you have to basically check if each connected sub graph is bipartite."
                    },
                    {
                        "username": "sasta_samurai",
                        "content": "[@Riantix](/Riantix) I don\\'t think your conclusion is correct, questions says you should form two sets where every element of both sets are connected. [0,1,2] [3,4] 1 is not connected to any nodes in original graph while in your answer, it is connected to 3 and 4."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@Riantix](/Riantix)  dumb dumb dumb\\n"
                    },
                    {
                        "username": "user1737NM",
                        "content": "[@Riantix](/Riantix) how come 3 and 4 can belong to the same group?"
                    },
                    {
                        "username": "Riantix",
                        "content": "[@yyol](/yyol) A bipartite graph simply means you have can have two groups, each node goes to exactly one group, and there are no edges between two nodes in the same group. Thus an unconnected graph can still be bipartite.\\n\\nAs an example, a graph with 5 nodes and no edges (thus being unconnected) will be bipartite. You can form the two groups as [0, 1, 2] [3, 4] or [0], [1, 2, 3, 4], or others."
                    },
                    {
                        "username": "yyol",
                        "content": "same question, did you have conclusion?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "My respect for **76 / 81 testcase**"
                    },
                    {
                        "username": "SrirajBehera",
                        "content": "it means component graphs are present, which is not mentioned in the awful description :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is that the input [[]] one?  it nailed me too"
                    },
                    {
                        "username": "02Gaurav",
                        "content": "i also passed 79/81 but 2 cases i dont know where exactly the problem is. Seems greedy approach wont work\\n"
                    },
                    {
                        "username": "lukevastus",
                        "content": "Apparently the graph should look like a triangle. \t\nSo why is the number 2 neither in graph[0] or in graph[1]?\nThe correct test case should be [[1, 2], [0, 2], [0, 1]]\n"
                    },
                    {
                        "username": "user8228j",
                        "content": "an hour and 15 minutes of my life gone."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/is-graph-bipartite/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Coloring by Depth-First Search [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "so how does [[1,3], [0,2], [1,3], [0,2]]\\nturn into a square diagram? two [1,3] and two [0,2]? \\n[1,3] means x at 1 and y at 3?"
                    },
                    {
                        "username": "v1shal",
                        "content": "In adj list representation, array at ith position represents the neighbors of ith node\\n\\n0--> 1,3\\n1--> 0,2\\n2--> 1,3\\n3--> 0,2\\n\\nfor ex - neighbors of node \"0\" is 1 and 3 and so on.\\n\\nWhen you connect them it would turn into a square"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Is this description so good that they locked the editorial \\uD83D\\uDE44"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/possible-bipartition/description/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Thank you for the info. The description over there sounds like a directed graph. The fact that ai dislikes bi cannot imply that  bi dislikes ai"
                    }
                ]
            },
            {
                "id": 1565319,
                "content": [
                    {
                        "username": "sasuke_uchiha",
                        "content": "Hi, Can please someone help me explainning How the input\\n[[1,3], [0,2], [1,3], [0,2]] \\nis working. I am not able to understand How does this input make this graph\\n0----1\\n|      |\\n|      |\\n3----2"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "0----1, 3\\n1----0, 2\\n2----1, 3\\n3----0, 2\\n\\n\\n 0-----1\\n |         | \\n3----- 2\\n\\n\\ntwo components"
                    },
                    {
                        "username": "RahulRaniwal",
                        "content": "for every value of row it is given that which node is connected to it\n\n0 -> 1 ,3\n1 -> 0 , 2\n2 -> 1 , 3\n3 -> 0 , 2\n\n0 ------- 1\n|              |\n|              |\n3 ------- 2\nThats how your graph will look \n[@Sunidhi Chaudhary](/sasuke_uchiha)"
                    },
                    {
                        "username": "gflanary",
                        "content": "This is a straightforward problem, but the description is positively awful.\\n\\nIf they had an image with disjoint sets and especially if they had one with colorized groupings, it would be clear what the intent was."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I found the description perfectly clear and rigorous, but I didn't find the problem straight forward at all.\nI guess I gotta work on my graph problems and you have to work on your problem reading/analysis!\nRoom for improvement for all"
                    },
                    {
                        "username": "mc_montecarlo",
                        "content": "I have a doubt with the test-case:\\n[[4],[],[4],[4],[0,2,3]]\\n\\nAbove test-case represents a graph is isn\\'t connected. But, the expected result of above is true. So my question is, how can a dis-connected graph be bi-partite?"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "A disconnected graph is bipartite if all the individually connected components are bipartite themselves. i.e, a singly disconnected graph with 2 or more regions is bipartite if all of those regions are bipartite."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "[@sasta_samurai](/sasta_samurai) \"questions says you should form two sets where every element of both sets are connected. \"\\nNo the question doesn\\'t say that.\\nIt says every \\'edge\\' must connect nodes from A and B.\\nA disconnected node can be put in any group because it has no edge."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Unfortunately the problem description is totally unclear about how to handle unconnected graphs. I hate when it\\'s a coin toss about how to handle some specific test case. In this case I agree that it should be false and got a WA because of it."
                    },
                    {
                        "username": "1dan_1609_",
                        "content": "In a disconnected graph. you have to basically check if each connected sub graph is bipartite."
                    },
                    {
                        "username": "sasta_samurai",
                        "content": "[@Riantix](/Riantix) I don\\'t think your conclusion is correct, questions says you should form two sets where every element of both sets are connected. [0,1,2] [3,4] 1 is not connected to any nodes in original graph while in your answer, it is connected to 3 and 4."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@Riantix](/Riantix)  dumb dumb dumb\\n"
                    },
                    {
                        "username": "user1737NM",
                        "content": "[@Riantix](/Riantix) how come 3 and 4 can belong to the same group?"
                    },
                    {
                        "username": "Riantix",
                        "content": "[@yyol](/yyol) A bipartite graph simply means you have can have two groups, each node goes to exactly one group, and there are no edges between two nodes in the same group. Thus an unconnected graph can still be bipartite.\\n\\nAs an example, a graph with 5 nodes and no edges (thus being unconnected) will be bipartite. You can form the two groups as [0, 1, 2] [3, 4] or [0], [1, 2, 3, 4], or others."
                    },
                    {
                        "username": "yyol",
                        "content": "same question, did you have conclusion?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "My respect for **76 / 81 testcase**"
                    },
                    {
                        "username": "SrirajBehera",
                        "content": "it means component graphs are present, which is not mentioned in the awful description :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is that the input [[]] one?  it nailed me too"
                    },
                    {
                        "username": "02Gaurav",
                        "content": "i also passed 79/81 but 2 cases i dont know where exactly the problem is. Seems greedy approach wont work\\n"
                    },
                    {
                        "username": "lukevastus",
                        "content": "Apparently the graph should look like a triangle. \t\nSo why is the number 2 neither in graph[0] or in graph[1]?\nThe correct test case should be [[1, 2], [0, 2], [0, 1]]\n"
                    },
                    {
                        "username": "user8228j",
                        "content": "an hour and 15 minutes of my life gone."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/is-graph-bipartite/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Coloring by Depth-First Search [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "so how does [[1,3], [0,2], [1,3], [0,2]]\\nturn into a square diagram? two [1,3] and two [0,2]? \\n[1,3] means x at 1 and y at 3?"
                    },
                    {
                        "username": "v1shal",
                        "content": "In adj list representation, array at ith position represents the neighbors of ith node\\n\\n0--> 1,3\\n1--> 0,2\\n2--> 1,3\\n3--> 0,2\\n\\nfor ex - neighbors of node \"0\" is 1 and 3 and so on.\\n\\nWhen you connect them it would turn into a square"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Is this description so good that they locked the editorial \\uD83D\\uDE44"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/possible-bipartition/description/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Thank you for the info. The description over there sounds like a directed graph. The fact that ai dislikes bi cannot imply that  bi dislikes ai"
                    }
                ]
            },
            {
                "id": 1898622,
                "content": [
                    {
                        "username": "sasuke_uchiha",
                        "content": "Hi, Can please someone help me explainning How the input\\n[[1,3], [0,2], [1,3], [0,2]] \\nis working. I am not able to understand How does this input make this graph\\n0----1\\n|      |\\n|      |\\n3----2"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "0----1, 3\\n1----0, 2\\n2----1, 3\\n3----0, 2\\n\\n\\n 0-----1\\n |         | \\n3----- 2\\n\\n\\ntwo components"
                    },
                    {
                        "username": "RahulRaniwal",
                        "content": "for every value of row it is given that which node is connected to it\n\n0 -> 1 ,3\n1 -> 0 , 2\n2 -> 1 , 3\n3 -> 0 , 2\n\n0 ------- 1\n|              |\n|              |\n3 ------- 2\nThats how your graph will look \n[@Sunidhi Chaudhary](/sasuke_uchiha)"
                    },
                    {
                        "username": "gflanary",
                        "content": "This is a straightforward problem, but the description is positively awful.\\n\\nIf they had an image with disjoint sets and especially if they had one with colorized groupings, it would be clear what the intent was."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I found the description perfectly clear and rigorous, but I didn't find the problem straight forward at all.\nI guess I gotta work on my graph problems and you have to work on your problem reading/analysis!\nRoom for improvement for all"
                    },
                    {
                        "username": "mc_montecarlo",
                        "content": "I have a doubt with the test-case:\\n[[4],[],[4],[4],[0,2,3]]\\n\\nAbove test-case represents a graph is isn\\'t connected. But, the expected result of above is true. So my question is, how can a dis-connected graph be bi-partite?"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "A disconnected graph is bipartite if all the individually connected components are bipartite themselves. i.e, a singly disconnected graph with 2 or more regions is bipartite if all of those regions are bipartite."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "[@sasta_samurai](/sasta_samurai) \"questions says you should form two sets where every element of both sets are connected. \"\\nNo the question doesn\\'t say that.\\nIt says every \\'edge\\' must connect nodes from A and B.\\nA disconnected node can be put in any group because it has no edge."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Unfortunately the problem description is totally unclear about how to handle unconnected graphs. I hate when it\\'s a coin toss about how to handle some specific test case. In this case I agree that it should be false and got a WA because of it."
                    },
                    {
                        "username": "1dan_1609_",
                        "content": "In a disconnected graph. you have to basically check if each connected sub graph is bipartite."
                    },
                    {
                        "username": "sasta_samurai",
                        "content": "[@Riantix](/Riantix) I don\\'t think your conclusion is correct, questions says you should form two sets where every element of both sets are connected. [0,1,2] [3,4] 1 is not connected to any nodes in original graph while in your answer, it is connected to 3 and 4."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@Riantix](/Riantix)  dumb dumb dumb\\n"
                    },
                    {
                        "username": "user1737NM",
                        "content": "[@Riantix](/Riantix) how come 3 and 4 can belong to the same group?"
                    },
                    {
                        "username": "Riantix",
                        "content": "[@yyol](/yyol) A bipartite graph simply means you have can have two groups, each node goes to exactly one group, and there are no edges between two nodes in the same group. Thus an unconnected graph can still be bipartite.\\n\\nAs an example, a graph with 5 nodes and no edges (thus being unconnected) will be bipartite. You can form the two groups as [0, 1, 2] [3, 4] or [0], [1, 2, 3, 4], or others."
                    },
                    {
                        "username": "yyol",
                        "content": "same question, did you have conclusion?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "My respect for **76 / 81 testcase**"
                    },
                    {
                        "username": "SrirajBehera",
                        "content": "it means component graphs are present, which is not mentioned in the awful description :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is that the input [[]] one?  it nailed me too"
                    },
                    {
                        "username": "02Gaurav",
                        "content": "i also passed 79/81 but 2 cases i dont know where exactly the problem is. Seems greedy approach wont work\\n"
                    },
                    {
                        "username": "lukevastus",
                        "content": "Apparently the graph should look like a triangle. \t\nSo why is the number 2 neither in graph[0] or in graph[1]?\nThe correct test case should be [[1, 2], [0, 2], [0, 1]]\n"
                    },
                    {
                        "username": "user8228j",
                        "content": "an hour and 15 minutes of my life gone."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/is-graph-bipartite/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Coloring by Depth-First Search [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "so how does [[1,3], [0,2], [1,3], [0,2]]\\nturn into a square diagram? two [1,3] and two [0,2]? \\n[1,3] means x at 1 and y at 3?"
                    },
                    {
                        "username": "v1shal",
                        "content": "In adj list representation, array at ith position represents the neighbors of ith node\\n\\n0--> 1,3\\n1--> 0,2\\n2--> 1,3\\n3--> 0,2\\n\\nfor ex - neighbors of node \"0\" is 1 and 3 and so on.\\n\\nWhen you connect them it would turn into a square"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Is this description so good that they locked the editorial \\uD83D\\uDE44"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/possible-bipartition/description/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Thank you for the info. The description over there sounds like a directed graph. The fact that ai dislikes bi cannot imply that  bi dislikes ai"
                    }
                ]
            },
            {
                "id": 1566435,
                "content": [
                    {
                        "username": "sasuke_uchiha",
                        "content": "Hi, Can please someone help me explainning How the input\\n[[1,3], [0,2], [1,3], [0,2]] \\nis working. I am not able to understand How does this input make this graph\\n0----1\\n|      |\\n|      |\\n3----2"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "0----1, 3\\n1----0, 2\\n2----1, 3\\n3----0, 2\\n\\n\\n 0-----1\\n |         | \\n3----- 2\\n\\n\\ntwo components"
                    },
                    {
                        "username": "RahulRaniwal",
                        "content": "for every value of row it is given that which node is connected to it\n\n0 -> 1 ,3\n1 -> 0 , 2\n2 -> 1 , 3\n3 -> 0 , 2\n\n0 ------- 1\n|              |\n|              |\n3 ------- 2\nThats how your graph will look \n[@Sunidhi Chaudhary](/sasuke_uchiha)"
                    },
                    {
                        "username": "gflanary",
                        "content": "This is a straightforward problem, but the description is positively awful.\\n\\nIf they had an image with disjoint sets and especially if they had one with colorized groupings, it would be clear what the intent was."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I found the description perfectly clear and rigorous, but I didn't find the problem straight forward at all.\nI guess I gotta work on my graph problems and you have to work on your problem reading/analysis!\nRoom for improvement for all"
                    },
                    {
                        "username": "mc_montecarlo",
                        "content": "I have a doubt with the test-case:\\n[[4],[],[4],[4],[0,2,3]]\\n\\nAbove test-case represents a graph is isn\\'t connected. But, the expected result of above is true. So my question is, how can a dis-connected graph be bi-partite?"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "A disconnected graph is bipartite if all the individually connected components are bipartite themselves. i.e, a singly disconnected graph with 2 or more regions is bipartite if all of those regions are bipartite."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "[@sasta_samurai](/sasta_samurai) \"questions says you should form two sets where every element of both sets are connected. \"\\nNo the question doesn\\'t say that.\\nIt says every \\'edge\\' must connect nodes from A and B.\\nA disconnected node can be put in any group because it has no edge."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Unfortunately the problem description is totally unclear about how to handle unconnected graphs. I hate when it\\'s a coin toss about how to handle some specific test case. In this case I agree that it should be false and got a WA because of it."
                    },
                    {
                        "username": "1dan_1609_",
                        "content": "In a disconnected graph. you have to basically check if each connected sub graph is bipartite."
                    },
                    {
                        "username": "sasta_samurai",
                        "content": "[@Riantix](/Riantix) I don\\'t think your conclusion is correct, questions says you should form two sets where every element of both sets are connected. [0,1,2] [3,4] 1 is not connected to any nodes in original graph while in your answer, it is connected to 3 and 4."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@Riantix](/Riantix)  dumb dumb dumb\\n"
                    },
                    {
                        "username": "user1737NM",
                        "content": "[@Riantix](/Riantix) how come 3 and 4 can belong to the same group?"
                    },
                    {
                        "username": "Riantix",
                        "content": "[@yyol](/yyol) A bipartite graph simply means you have can have two groups, each node goes to exactly one group, and there are no edges between two nodes in the same group. Thus an unconnected graph can still be bipartite.\\n\\nAs an example, a graph with 5 nodes and no edges (thus being unconnected) will be bipartite. You can form the two groups as [0, 1, 2] [3, 4] or [0], [1, 2, 3, 4], or others."
                    },
                    {
                        "username": "yyol",
                        "content": "same question, did you have conclusion?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "My respect for **76 / 81 testcase**"
                    },
                    {
                        "username": "SrirajBehera",
                        "content": "it means component graphs are present, which is not mentioned in the awful description :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is that the input [[]] one?  it nailed me too"
                    },
                    {
                        "username": "02Gaurav",
                        "content": "i also passed 79/81 but 2 cases i dont know where exactly the problem is. Seems greedy approach wont work\\n"
                    },
                    {
                        "username": "lukevastus",
                        "content": "Apparently the graph should look like a triangle. \t\nSo why is the number 2 neither in graph[0] or in graph[1]?\nThe correct test case should be [[1, 2], [0, 2], [0, 1]]\n"
                    },
                    {
                        "username": "user8228j",
                        "content": "an hour and 15 minutes of my life gone."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/is-graph-bipartite/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Coloring by Depth-First Search [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "so how does [[1,3], [0,2], [1,3], [0,2]]\\nturn into a square diagram? two [1,3] and two [0,2]? \\n[1,3] means x at 1 and y at 3?"
                    },
                    {
                        "username": "v1shal",
                        "content": "In adj list representation, array at ith position represents the neighbors of ith node\\n\\n0--> 1,3\\n1--> 0,2\\n2--> 1,3\\n3--> 0,2\\n\\nfor ex - neighbors of node \"0\" is 1 and 3 and so on.\\n\\nWhen you connect them it would turn into a square"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Is this description so good that they locked the editorial \\uD83D\\uDE44"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/possible-bipartition/description/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Thank you for the info. The description over there sounds like a directed graph. The fact that ai dislikes bi cannot imply that  bi dislikes ai"
                    }
                ]
            },
            {
                "id": 1566576,
                "content": [
                    {
                        "username": "sasuke_uchiha",
                        "content": "Hi, Can please someone help me explainning How the input\\n[[1,3], [0,2], [1,3], [0,2]] \\nis working. I am not able to understand How does this input make this graph\\n0----1\\n|      |\\n|      |\\n3----2"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "0----1, 3\\n1----0, 2\\n2----1, 3\\n3----0, 2\\n\\n\\n 0-----1\\n |         | \\n3----- 2\\n\\n\\ntwo components"
                    },
                    {
                        "username": "RahulRaniwal",
                        "content": "for every value of row it is given that which node is connected to it\n\n0 -> 1 ,3\n1 -> 0 , 2\n2 -> 1 , 3\n3 -> 0 , 2\n\n0 ------- 1\n|              |\n|              |\n3 ------- 2\nThats how your graph will look \n[@Sunidhi Chaudhary](/sasuke_uchiha)"
                    },
                    {
                        "username": "gflanary",
                        "content": "This is a straightforward problem, but the description is positively awful.\\n\\nIf they had an image with disjoint sets and especially if they had one with colorized groupings, it would be clear what the intent was."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I found the description perfectly clear and rigorous, but I didn't find the problem straight forward at all.\nI guess I gotta work on my graph problems and you have to work on your problem reading/analysis!\nRoom for improvement for all"
                    },
                    {
                        "username": "mc_montecarlo",
                        "content": "I have a doubt with the test-case:\\n[[4],[],[4],[4],[0,2,3]]\\n\\nAbove test-case represents a graph is isn\\'t connected. But, the expected result of above is true. So my question is, how can a dis-connected graph be bi-partite?"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "A disconnected graph is bipartite if all the individually connected components are bipartite themselves. i.e, a singly disconnected graph with 2 or more regions is bipartite if all of those regions are bipartite."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "[@sasta_samurai](/sasta_samurai) \"questions says you should form two sets where every element of both sets are connected. \"\\nNo the question doesn\\'t say that.\\nIt says every \\'edge\\' must connect nodes from A and B.\\nA disconnected node can be put in any group because it has no edge."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Unfortunately the problem description is totally unclear about how to handle unconnected graphs. I hate when it\\'s a coin toss about how to handle some specific test case. In this case I agree that it should be false and got a WA because of it."
                    },
                    {
                        "username": "1dan_1609_",
                        "content": "In a disconnected graph. you have to basically check if each connected sub graph is bipartite."
                    },
                    {
                        "username": "sasta_samurai",
                        "content": "[@Riantix](/Riantix) I don\\'t think your conclusion is correct, questions says you should form two sets where every element of both sets are connected. [0,1,2] [3,4] 1 is not connected to any nodes in original graph while in your answer, it is connected to 3 and 4."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@Riantix](/Riantix)  dumb dumb dumb\\n"
                    },
                    {
                        "username": "user1737NM",
                        "content": "[@Riantix](/Riantix) how come 3 and 4 can belong to the same group?"
                    },
                    {
                        "username": "Riantix",
                        "content": "[@yyol](/yyol) A bipartite graph simply means you have can have two groups, each node goes to exactly one group, and there are no edges between two nodes in the same group. Thus an unconnected graph can still be bipartite.\\n\\nAs an example, a graph with 5 nodes and no edges (thus being unconnected) will be bipartite. You can form the two groups as [0, 1, 2] [3, 4] or [0], [1, 2, 3, 4], or others."
                    },
                    {
                        "username": "yyol",
                        "content": "same question, did you have conclusion?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "My respect for **76 / 81 testcase**"
                    },
                    {
                        "username": "SrirajBehera",
                        "content": "it means component graphs are present, which is not mentioned in the awful description :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is that the input [[]] one?  it nailed me too"
                    },
                    {
                        "username": "02Gaurav",
                        "content": "i also passed 79/81 but 2 cases i dont know where exactly the problem is. Seems greedy approach wont work\\n"
                    },
                    {
                        "username": "lukevastus",
                        "content": "Apparently the graph should look like a triangle. \t\nSo why is the number 2 neither in graph[0] or in graph[1]?\nThe correct test case should be [[1, 2], [0, 2], [0, 1]]\n"
                    },
                    {
                        "username": "user8228j",
                        "content": "an hour and 15 minutes of my life gone."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/is-graph-bipartite/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Coloring by Depth-First Search [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "so how does [[1,3], [0,2], [1,3], [0,2]]\\nturn into a square diagram? two [1,3] and two [0,2]? \\n[1,3] means x at 1 and y at 3?"
                    },
                    {
                        "username": "v1shal",
                        "content": "In adj list representation, array at ith position represents the neighbors of ith node\\n\\n0--> 1,3\\n1--> 0,2\\n2--> 1,3\\n3--> 0,2\\n\\nfor ex - neighbors of node \"0\" is 1 and 3 and so on.\\n\\nWhen you connect them it would turn into a square"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Is this description so good that they locked the editorial \\uD83D\\uDE44"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/possible-bipartition/description/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Thank you for the info. The description over there sounds like a directed graph. The fact that ai dislikes bi cannot imply that  bi dislikes ai"
                    }
                ]
            },
            {
                "id": 1898645,
                "content": [
                    {
                        "username": "sasuke_uchiha",
                        "content": "Hi, Can please someone help me explainning How the input\\n[[1,3], [0,2], [1,3], [0,2]] \\nis working. I am not able to understand How does this input make this graph\\n0----1\\n|      |\\n|      |\\n3----2"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "0----1, 3\\n1----0, 2\\n2----1, 3\\n3----0, 2\\n\\n\\n 0-----1\\n |         | \\n3----- 2\\n\\n\\ntwo components"
                    },
                    {
                        "username": "RahulRaniwal",
                        "content": "for every value of row it is given that which node is connected to it\n\n0 -> 1 ,3\n1 -> 0 , 2\n2 -> 1 , 3\n3 -> 0 , 2\n\n0 ------- 1\n|              |\n|              |\n3 ------- 2\nThats how your graph will look \n[@Sunidhi Chaudhary](/sasuke_uchiha)"
                    },
                    {
                        "username": "gflanary",
                        "content": "This is a straightforward problem, but the description is positively awful.\\n\\nIf they had an image with disjoint sets and especially if they had one with colorized groupings, it would be clear what the intent was."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I found the description perfectly clear and rigorous, but I didn't find the problem straight forward at all.\nI guess I gotta work on my graph problems and you have to work on your problem reading/analysis!\nRoom for improvement for all"
                    },
                    {
                        "username": "mc_montecarlo",
                        "content": "I have a doubt with the test-case:\\n[[4],[],[4],[4],[0,2,3]]\\n\\nAbove test-case represents a graph is isn\\'t connected. But, the expected result of above is true. So my question is, how can a dis-connected graph be bi-partite?"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "A disconnected graph is bipartite if all the individually connected components are bipartite themselves. i.e, a singly disconnected graph with 2 or more regions is bipartite if all of those regions are bipartite."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "[@sasta_samurai](/sasta_samurai) \"questions says you should form two sets where every element of both sets are connected. \"\\nNo the question doesn\\'t say that.\\nIt says every \\'edge\\' must connect nodes from A and B.\\nA disconnected node can be put in any group because it has no edge."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Unfortunately the problem description is totally unclear about how to handle unconnected graphs. I hate when it\\'s a coin toss about how to handle some specific test case. In this case I agree that it should be false and got a WA because of it."
                    },
                    {
                        "username": "1dan_1609_",
                        "content": "In a disconnected graph. you have to basically check if each connected sub graph is bipartite."
                    },
                    {
                        "username": "sasta_samurai",
                        "content": "[@Riantix](/Riantix) I don\\'t think your conclusion is correct, questions says you should form two sets where every element of both sets are connected. [0,1,2] [3,4] 1 is not connected to any nodes in original graph while in your answer, it is connected to 3 and 4."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@Riantix](/Riantix)  dumb dumb dumb\\n"
                    },
                    {
                        "username": "user1737NM",
                        "content": "[@Riantix](/Riantix) how come 3 and 4 can belong to the same group?"
                    },
                    {
                        "username": "Riantix",
                        "content": "[@yyol](/yyol) A bipartite graph simply means you have can have two groups, each node goes to exactly one group, and there are no edges between two nodes in the same group. Thus an unconnected graph can still be bipartite.\\n\\nAs an example, a graph with 5 nodes and no edges (thus being unconnected) will be bipartite. You can form the two groups as [0, 1, 2] [3, 4] or [0], [1, 2, 3, 4], or others."
                    },
                    {
                        "username": "yyol",
                        "content": "same question, did you have conclusion?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "My respect for **76 / 81 testcase**"
                    },
                    {
                        "username": "SrirajBehera",
                        "content": "it means component graphs are present, which is not mentioned in the awful description :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is that the input [[]] one?  it nailed me too"
                    },
                    {
                        "username": "02Gaurav",
                        "content": "i also passed 79/81 but 2 cases i dont know where exactly the problem is. Seems greedy approach wont work\\n"
                    },
                    {
                        "username": "lukevastus",
                        "content": "Apparently the graph should look like a triangle. \t\nSo why is the number 2 neither in graph[0] or in graph[1]?\nThe correct test case should be [[1, 2], [0, 2], [0, 1]]\n"
                    },
                    {
                        "username": "user8228j",
                        "content": "an hour and 15 minutes of my life gone."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/is-graph-bipartite/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Coloring by Depth-First Search [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "so how does [[1,3], [0,2], [1,3], [0,2]]\\nturn into a square diagram? two [1,3] and two [0,2]? \\n[1,3] means x at 1 and y at 3?"
                    },
                    {
                        "username": "v1shal",
                        "content": "In adj list representation, array at ith position represents the neighbors of ith node\\n\\n0--> 1,3\\n1--> 0,2\\n2--> 1,3\\n3--> 0,2\\n\\nfor ex - neighbors of node \"0\" is 1 and 3 and so on.\\n\\nWhen you connect them it would turn into a square"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Is this description so good that they locked the editorial \\uD83D\\uDE44"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/possible-bipartition/description/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Thank you for the info. The description over there sounds like a directed graph. The fact that ai dislikes bi cannot imply that  bi dislikes ai"
                    }
                ]
            },
            {
                "id": 1815093,
                "content": [
                    {
                        "username": "sasuke_uchiha",
                        "content": "Hi, Can please someone help me explainning How the input\\n[[1,3], [0,2], [1,3], [0,2]] \\nis working. I am not able to understand How does this input make this graph\\n0----1\\n|      |\\n|      |\\n3----2"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "0----1, 3\\n1----0, 2\\n2----1, 3\\n3----0, 2\\n\\n\\n 0-----1\\n |         | \\n3----- 2\\n\\n\\ntwo components"
                    },
                    {
                        "username": "RahulRaniwal",
                        "content": "for every value of row it is given that which node is connected to it\n\n0 -> 1 ,3\n1 -> 0 , 2\n2 -> 1 , 3\n3 -> 0 , 2\n\n0 ------- 1\n|              |\n|              |\n3 ------- 2\nThats how your graph will look \n[@Sunidhi Chaudhary](/sasuke_uchiha)"
                    },
                    {
                        "username": "gflanary",
                        "content": "This is a straightforward problem, but the description is positively awful.\\n\\nIf they had an image with disjoint sets and especially if they had one with colorized groupings, it would be clear what the intent was."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I found the description perfectly clear and rigorous, but I didn't find the problem straight forward at all.\nI guess I gotta work on my graph problems and you have to work on your problem reading/analysis!\nRoom for improvement for all"
                    },
                    {
                        "username": "mc_montecarlo",
                        "content": "I have a doubt with the test-case:\\n[[4],[],[4],[4],[0,2,3]]\\n\\nAbove test-case represents a graph is isn\\'t connected. But, the expected result of above is true. So my question is, how can a dis-connected graph be bi-partite?"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "A disconnected graph is bipartite if all the individually connected components are bipartite themselves. i.e, a singly disconnected graph with 2 or more regions is bipartite if all of those regions are bipartite."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "[@sasta_samurai](/sasta_samurai) \"questions says you should form two sets where every element of both sets are connected. \"\\nNo the question doesn\\'t say that.\\nIt says every \\'edge\\' must connect nodes from A and B.\\nA disconnected node can be put in any group because it has no edge."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Unfortunately the problem description is totally unclear about how to handle unconnected graphs. I hate when it\\'s a coin toss about how to handle some specific test case. In this case I agree that it should be false and got a WA because of it."
                    },
                    {
                        "username": "1dan_1609_",
                        "content": "In a disconnected graph. you have to basically check if each connected sub graph is bipartite."
                    },
                    {
                        "username": "sasta_samurai",
                        "content": "[@Riantix](/Riantix) I don\\'t think your conclusion is correct, questions says you should form two sets where every element of both sets are connected. [0,1,2] [3,4] 1 is not connected to any nodes in original graph while in your answer, it is connected to 3 and 4."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@Riantix](/Riantix)  dumb dumb dumb\\n"
                    },
                    {
                        "username": "user1737NM",
                        "content": "[@Riantix](/Riantix) how come 3 and 4 can belong to the same group?"
                    },
                    {
                        "username": "Riantix",
                        "content": "[@yyol](/yyol) A bipartite graph simply means you have can have two groups, each node goes to exactly one group, and there are no edges between two nodes in the same group. Thus an unconnected graph can still be bipartite.\\n\\nAs an example, a graph with 5 nodes and no edges (thus being unconnected) will be bipartite. You can form the two groups as [0, 1, 2] [3, 4] or [0], [1, 2, 3, 4], or others."
                    },
                    {
                        "username": "yyol",
                        "content": "same question, did you have conclusion?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "My respect for **76 / 81 testcase**"
                    },
                    {
                        "username": "SrirajBehera",
                        "content": "it means component graphs are present, which is not mentioned in the awful description :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is that the input [[]] one?  it nailed me too"
                    },
                    {
                        "username": "02Gaurav",
                        "content": "i also passed 79/81 but 2 cases i dont know where exactly the problem is. Seems greedy approach wont work\\n"
                    },
                    {
                        "username": "lukevastus",
                        "content": "Apparently the graph should look like a triangle. \t\nSo why is the number 2 neither in graph[0] or in graph[1]?\nThe correct test case should be [[1, 2], [0, 2], [0, 1]]\n"
                    },
                    {
                        "username": "user8228j",
                        "content": "an hour and 15 minutes of my life gone."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/is-graph-bipartite/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Coloring by Depth-First Search [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "so how does [[1,3], [0,2], [1,3], [0,2]]\\nturn into a square diagram? two [1,3] and two [0,2]? \\n[1,3] means x at 1 and y at 3?"
                    },
                    {
                        "username": "v1shal",
                        "content": "In adj list representation, array at ith position represents the neighbors of ith node\\n\\n0--> 1,3\\n1--> 0,2\\n2--> 1,3\\n3--> 0,2\\n\\nfor ex - neighbors of node \"0\" is 1 and 3 and so on.\\n\\nWhen you connect them it would turn into a square"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Is this description so good that they locked the editorial \\uD83D\\uDE44"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/possible-bipartition/description/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Thank you for the info. The description over there sounds like a directed graph. The fact that ai dislikes bi cannot imply that  bi dislikes ai"
                    }
                ]
            },
            {
                "id": 1564810,
                "content": [
                    {
                        "username": "sasuke_uchiha",
                        "content": "Hi, Can please someone help me explainning How the input\\n[[1,3], [0,2], [1,3], [0,2]] \\nis working. I am not able to understand How does this input make this graph\\n0----1\\n|      |\\n|      |\\n3----2"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "0----1, 3\\n1----0, 2\\n2----1, 3\\n3----0, 2\\n\\n\\n 0-----1\\n |         | \\n3----- 2\\n\\n\\ntwo components"
                    },
                    {
                        "username": "RahulRaniwal",
                        "content": "for every value of row it is given that which node is connected to it\n\n0 -> 1 ,3\n1 -> 0 , 2\n2 -> 1 , 3\n3 -> 0 , 2\n\n0 ------- 1\n|              |\n|              |\n3 ------- 2\nThats how your graph will look \n[@Sunidhi Chaudhary](/sasuke_uchiha)"
                    },
                    {
                        "username": "gflanary",
                        "content": "This is a straightforward problem, but the description is positively awful.\\n\\nIf they had an image with disjoint sets and especially if they had one with colorized groupings, it would be clear what the intent was."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I found the description perfectly clear and rigorous, but I didn't find the problem straight forward at all.\nI guess I gotta work on my graph problems and you have to work on your problem reading/analysis!\nRoom for improvement for all"
                    },
                    {
                        "username": "mc_montecarlo",
                        "content": "I have a doubt with the test-case:\\n[[4],[],[4],[4],[0,2,3]]\\n\\nAbove test-case represents a graph is isn\\'t connected. But, the expected result of above is true. So my question is, how can a dis-connected graph be bi-partite?"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "A disconnected graph is bipartite if all the individually connected components are bipartite themselves. i.e, a singly disconnected graph with 2 or more regions is bipartite if all of those regions are bipartite."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "[@sasta_samurai](/sasta_samurai) \"questions says you should form two sets where every element of both sets are connected. \"\\nNo the question doesn\\'t say that.\\nIt says every \\'edge\\' must connect nodes from A and B.\\nA disconnected node can be put in any group because it has no edge."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Unfortunately the problem description is totally unclear about how to handle unconnected graphs. I hate when it\\'s a coin toss about how to handle some specific test case. In this case I agree that it should be false and got a WA because of it."
                    },
                    {
                        "username": "1dan_1609_",
                        "content": "In a disconnected graph. you have to basically check if each connected sub graph is bipartite."
                    },
                    {
                        "username": "sasta_samurai",
                        "content": "[@Riantix](/Riantix) I don\\'t think your conclusion is correct, questions says you should form two sets where every element of both sets are connected. [0,1,2] [3,4] 1 is not connected to any nodes in original graph while in your answer, it is connected to 3 and 4."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@Riantix](/Riantix)  dumb dumb dumb\\n"
                    },
                    {
                        "username": "user1737NM",
                        "content": "[@Riantix](/Riantix) how come 3 and 4 can belong to the same group?"
                    },
                    {
                        "username": "Riantix",
                        "content": "[@yyol](/yyol) A bipartite graph simply means you have can have two groups, each node goes to exactly one group, and there are no edges between two nodes in the same group. Thus an unconnected graph can still be bipartite.\\n\\nAs an example, a graph with 5 nodes and no edges (thus being unconnected) will be bipartite. You can form the two groups as [0, 1, 2] [3, 4] or [0], [1, 2, 3, 4], or others."
                    },
                    {
                        "username": "yyol",
                        "content": "same question, did you have conclusion?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "My respect for **76 / 81 testcase**"
                    },
                    {
                        "username": "SrirajBehera",
                        "content": "it means component graphs are present, which is not mentioned in the awful description :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is that the input [[]] one?  it nailed me too"
                    },
                    {
                        "username": "02Gaurav",
                        "content": "i also passed 79/81 but 2 cases i dont know where exactly the problem is. Seems greedy approach wont work\\n"
                    },
                    {
                        "username": "lukevastus",
                        "content": "Apparently the graph should look like a triangle. \t\nSo why is the number 2 neither in graph[0] or in graph[1]?\nThe correct test case should be [[1, 2], [0, 2], [0, 1]]\n"
                    },
                    {
                        "username": "user8228j",
                        "content": "an hour and 15 minutes of my life gone."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/is-graph-bipartite/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Coloring by Depth-First Search [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "so how does [[1,3], [0,2], [1,3], [0,2]]\\nturn into a square diagram? two [1,3] and two [0,2]? \\n[1,3] means x at 1 and y at 3?"
                    },
                    {
                        "username": "v1shal",
                        "content": "In adj list representation, array at ith position represents the neighbors of ith node\\n\\n0--> 1,3\\n1--> 0,2\\n2--> 1,3\\n3--> 0,2\\n\\nfor ex - neighbors of node \"0\" is 1 and 3 and so on.\\n\\nWhen you connect them it would turn into a square"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Is this description so good that they locked the editorial \\uD83D\\uDE44"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/possible-bipartition/description/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Thank you for the info. The description over there sounds like a directed graph. The fact that ai dislikes bi cannot imply that  bi dislikes ai"
                    }
                ]
            },
            {
                "id": 1712857,
                "content": [
                    {
                        "username": "sasuke_uchiha",
                        "content": "Hi, Can please someone help me explainning How the input\\n[[1,3], [0,2], [1,3], [0,2]] \\nis working. I am not able to understand How does this input make this graph\\n0----1\\n|      |\\n|      |\\n3----2"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "0----1, 3\\n1----0, 2\\n2----1, 3\\n3----0, 2\\n\\n\\n 0-----1\\n |         | \\n3----- 2\\n\\n\\ntwo components"
                    },
                    {
                        "username": "RahulRaniwal",
                        "content": "for every value of row it is given that which node is connected to it\n\n0 -> 1 ,3\n1 -> 0 , 2\n2 -> 1 , 3\n3 -> 0 , 2\n\n0 ------- 1\n|              |\n|              |\n3 ------- 2\nThats how your graph will look \n[@Sunidhi Chaudhary](/sasuke_uchiha)"
                    },
                    {
                        "username": "gflanary",
                        "content": "This is a straightforward problem, but the description is positively awful.\\n\\nIf they had an image with disjoint sets and especially if they had one with colorized groupings, it would be clear what the intent was."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I found the description perfectly clear and rigorous, but I didn't find the problem straight forward at all.\nI guess I gotta work on my graph problems and you have to work on your problem reading/analysis!\nRoom for improvement for all"
                    },
                    {
                        "username": "mc_montecarlo",
                        "content": "I have a doubt with the test-case:\\n[[4],[],[4],[4],[0,2,3]]\\n\\nAbove test-case represents a graph is isn\\'t connected. But, the expected result of above is true. So my question is, how can a dis-connected graph be bi-partite?"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "A disconnected graph is bipartite if all the individually connected components are bipartite themselves. i.e, a singly disconnected graph with 2 or more regions is bipartite if all of those regions are bipartite."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "[@sasta_samurai](/sasta_samurai) \"questions says you should form two sets where every element of both sets are connected. \"\\nNo the question doesn\\'t say that.\\nIt says every \\'edge\\' must connect nodes from A and B.\\nA disconnected node can be put in any group because it has no edge."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Unfortunately the problem description is totally unclear about how to handle unconnected graphs. I hate when it\\'s a coin toss about how to handle some specific test case. In this case I agree that it should be false and got a WA because of it."
                    },
                    {
                        "username": "1dan_1609_",
                        "content": "In a disconnected graph. you have to basically check if each connected sub graph is bipartite."
                    },
                    {
                        "username": "sasta_samurai",
                        "content": "[@Riantix](/Riantix) I don\\'t think your conclusion is correct, questions says you should form two sets where every element of both sets are connected. [0,1,2] [3,4] 1 is not connected to any nodes in original graph while in your answer, it is connected to 3 and 4."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@Riantix](/Riantix)  dumb dumb dumb\\n"
                    },
                    {
                        "username": "user1737NM",
                        "content": "[@Riantix](/Riantix) how come 3 and 4 can belong to the same group?"
                    },
                    {
                        "username": "Riantix",
                        "content": "[@yyol](/yyol) A bipartite graph simply means you have can have two groups, each node goes to exactly one group, and there are no edges between two nodes in the same group. Thus an unconnected graph can still be bipartite.\\n\\nAs an example, a graph with 5 nodes and no edges (thus being unconnected) will be bipartite. You can form the two groups as [0, 1, 2] [3, 4] or [0], [1, 2, 3, 4], or others."
                    },
                    {
                        "username": "yyol",
                        "content": "same question, did you have conclusion?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "My respect for **76 / 81 testcase**"
                    },
                    {
                        "username": "SrirajBehera",
                        "content": "it means component graphs are present, which is not mentioned in the awful description :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is that the input [[]] one?  it nailed me too"
                    },
                    {
                        "username": "02Gaurav",
                        "content": "i also passed 79/81 but 2 cases i dont know where exactly the problem is. Seems greedy approach wont work\\n"
                    },
                    {
                        "username": "lukevastus",
                        "content": "Apparently the graph should look like a triangle. \t\nSo why is the number 2 neither in graph[0] or in graph[1]?\nThe correct test case should be [[1, 2], [0, 2], [0, 1]]\n"
                    },
                    {
                        "username": "user8228j",
                        "content": "an hour and 15 minutes of my life gone."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/is-graph-bipartite/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Coloring by Depth-First Search [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "so how does [[1,3], [0,2], [1,3], [0,2]]\\nturn into a square diagram? two [1,3] and two [0,2]? \\n[1,3] means x at 1 and y at 3?"
                    },
                    {
                        "username": "v1shal",
                        "content": "In adj list representation, array at ith position represents the neighbors of ith node\\n\\n0--> 1,3\\n1--> 0,2\\n2--> 1,3\\n3--> 0,2\\n\\nfor ex - neighbors of node \"0\" is 1 and 3 and so on.\\n\\nWhen you connect them it would turn into a square"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Is this description so good that they locked the editorial \\uD83D\\uDE44"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/possible-bipartition/description/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Thank you for the info. The description over there sounds like a directed graph. The fact that ai dislikes bi cannot imply that  bi dislikes ai"
                    }
                ]
            },
            {
                "id": 1569879,
                "content": [
                    {
                        "username": "sasuke_uchiha",
                        "content": "Hi, Can please someone help me explainning How the input\\n[[1,3], [0,2], [1,3], [0,2]] \\nis working. I am not able to understand How does this input make this graph\\n0----1\\n|      |\\n|      |\\n3----2"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "0----1, 3\\n1----0, 2\\n2----1, 3\\n3----0, 2\\n\\n\\n 0-----1\\n |         | \\n3----- 2\\n\\n\\ntwo components"
                    },
                    {
                        "username": "RahulRaniwal",
                        "content": "for every value of row it is given that which node is connected to it\n\n0 -> 1 ,3\n1 -> 0 , 2\n2 -> 1 , 3\n3 -> 0 , 2\n\n0 ------- 1\n|              |\n|              |\n3 ------- 2\nThats how your graph will look \n[@Sunidhi Chaudhary](/sasuke_uchiha)"
                    },
                    {
                        "username": "gflanary",
                        "content": "This is a straightforward problem, but the description is positively awful.\\n\\nIf they had an image with disjoint sets and especially if they had one with colorized groupings, it would be clear what the intent was."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I found the description perfectly clear and rigorous, but I didn't find the problem straight forward at all.\nI guess I gotta work on my graph problems and you have to work on your problem reading/analysis!\nRoom for improvement for all"
                    },
                    {
                        "username": "mc_montecarlo",
                        "content": "I have a doubt with the test-case:\\n[[4],[],[4],[4],[0,2,3]]\\n\\nAbove test-case represents a graph is isn\\'t connected. But, the expected result of above is true. So my question is, how can a dis-connected graph be bi-partite?"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "A disconnected graph is bipartite if all the individually connected components are bipartite themselves. i.e, a singly disconnected graph with 2 or more regions is bipartite if all of those regions are bipartite."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "[@sasta_samurai](/sasta_samurai) \"questions says you should form two sets where every element of both sets are connected. \"\\nNo the question doesn\\'t say that.\\nIt says every \\'edge\\' must connect nodes from A and B.\\nA disconnected node can be put in any group because it has no edge."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Unfortunately the problem description is totally unclear about how to handle unconnected graphs. I hate when it\\'s a coin toss about how to handle some specific test case. In this case I agree that it should be false and got a WA because of it."
                    },
                    {
                        "username": "1dan_1609_",
                        "content": "In a disconnected graph. you have to basically check if each connected sub graph is bipartite."
                    },
                    {
                        "username": "sasta_samurai",
                        "content": "[@Riantix](/Riantix) I don\\'t think your conclusion is correct, questions says you should form two sets where every element of both sets are connected. [0,1,2] [3,4] 1 is not connected to any nodes in original graph while in your answer, it is connected to 3 and 4."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@Riantix](/Riantix)  dumb dumb dumb\\n"
                    },
                    {
                        "username": "user1737NM",
                        "content": "[@Riantix](/Riantix) how come 3 and 4 can belong to the same group?"
                    },
                    {
                        "username": "Riantix",
                        "content": "[@yyol](/yyol) A bipartite graph simply means you have can have two groups, each node goes to exactly one group, and there are no edges between two nodes in the same group. Thus an unconnected graph can still be bipartite.\\n\\nAs an example, a graph with 5 nodes and no edges (thus being unconnected) will be bipartite. You can form the two groups as [0, 1, 2] [3, 4] or [0], [1, 2, 3, 4], or others."
                    },
                    {
                        "username": "yyol",
                        "content": "same question, did you have conclusion?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "My respect for **76 / 81 testcase**"
                    },
                    {
                        "username": "SrirajBehera",
                        "content": "it means component graphs are present, which is not mentioned in the awful description :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is that the input [[]] one?  it nailed me too"
                    },
                    {
                        "username": "02Gaurav",
                        "content": "i also passed 79/81 but 2 cases i dont know where exactly the problem is. Seems greedy approach wont work\\n"
                    },
                    {
                        "username": "lukevastus",
                        "content": "Apparently the graph should look like a triangle. \t\nSo why is the number 2 neither in graph[0] or in graph[1]?\nThe correct test case should be [[1, 2], [0, 2], [0, 1]]\n"
                    },
                    {
                        "username": "user8228j",
                        "content": "an hour and 15 minutes of my life gone."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/is-graph-bipartite/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Coloring by Depth-First Search [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "so how does [[1,3], [0,2], [1,3], [0,2]]\\nturn into a square diagram? two [1,3] and two [0,2]? \\n[1,3] means x at 1 and y at 3?"
                    },
                    {
                        "username": "v1shal",
                        "content": "In adj list representation, array at ith position represents the neighbors of ith node\\n\\n0--> 1,3\\n1--> 0,2\\n2--> 1,3\\n3--> 0,2\\n\\nfor ex - neighbors of node \"0\" is 1 and 3 and so on.\\n\\nWhen you connect them it would turn into a square"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Is this description so good that they locked the editorial \\uD83D\\uDE44"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/possible-bipartition/description/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Thank you for the info. The description over there sounds like a directed graph. The fact that ai dislikes bi cannot imply that  bi dislikes ai"
                    }
                ]
            },
            {
                "id": 1796416,
                "content": [
                    {
                        "username": "sasuke_uchiha",
                        "content": "Hi, Can please someone help me explainning How the input\\n[[1,3], [0,2], [1,3], [0,2]] \\nis working. I am not able to understand How does this input make this graph\\n0----1\\n|      |\\n|      |\\n3----2"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "0----1, 3\\n1----0, 2\\n2----1, 3\\n3----0, 2\\n\\n\\n 0-----1\\n |         | \\n3----- 2\\n\\n\\ntwo components"
                    },
                    {
                        "username": "RahulRaniwal",
                        "content": "for every value of row it is given that which node is connected to it\n\n0 -> 1 ,3\n1 -> 0 , 2\n2 -> 1 , 3\n3 -> 0 , 2\n\n0 ------- 1\n|              |\n|              |\n3 ------- 2\nThats how your graph will look \n[@Sunidhi Chaudhary](/sasuke_uchiha)"
                    },
                    {
                        "username": "gflanary",
                        "content": "This is a straightforward problem, but the description is positively awful.\\n\\nIf they had an image with disjoint sets and especially if they had one with colorized groupings, it would be clear what the intent was."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I found the description perfectly clear and rigorous, but I didn't find the problem straight forward at all.\nI guess I gotta work on my graph problems and you have to work on your problem reading/analysis!\nRoom for improvement for all"
                    },
                    {
                        "username": "mc_montecarlo",
                        "content": "I have a doubt with the test-case:\\n[[4],[],[4],[4],[0,2,3]]\\n\\nAbove test-case represents a graph is isn\\'t connected. But, the expected result of above is true. So my question is, how can a dis-connected graph be bi-partite?"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "A disconnected graph is bipartite if all the individually connected components are bipartite themselves. i.e, a singly disconnected graph with 2 or more regions is bipartite if all of those regions are bipartite."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "[@sasta_samurai](/sasta_samurai) \"questions says you should form two sets where every element of both sets are connected. \"\\nNo the question doesn\\'t say that.\\nIt says every \\'edge\\' must connect nodes from A and B.\\nA disconnected node can be put in any group because it has no edge."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Unfortunately the problem description is totally unclear about how to handle unconnected graphs. I hate when it\\'s a coin toss about how to handle some specific test case. In this case I agree that it should be false and got a WA because of it."
                    },
                    {
                        "username": "1dan_1609_",
                        "content": "In a disconnected graph. you have to basically check if each connected sub graph is bipartite."
                    },
                    {
                        "username": "sasta_samurai",
                        "content": "[@Riantix](/Riantix) I don\\'t think your conclusion is correct, questions says you should form two sets where every element of both sets are connected. [0,1,2] [3,4] 1 is not connected to any nodes in original graph while in your answer, it is connected to 3 and 4."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@Riantix](/Riantix)  dumb dumb dumb\\n"
                    },
                    {
                        "username": "user1737NM",
                        "content": "[@Riantix](/Riantix) how come 3 and 4 can belong to the same group?"
                    },
                    {
                        "username": "Riantix",
                        "content": "[@yyol](/yyol) A bipartite graph simply means you have can have two groups, each node goes to exactly one group, and there are no edges between two nodes in the same group. Thus an unconnected graph can still be bipartite.\\n\\nAs an example, a graph with 5 nodes and no edges (thus being unconnected) will be bipartite. You can form the two groups as [0, 1, 2] [3, 4] or [0], [1, 2, 3, 4], or others."
                    },
                    {
                        "username": "yyol",
                        "content": "same question, did you have conclusion?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "My respect for **76 / 81 testcase**"
                    },
                    {
                        "username": "SrirajBehera",
                        "content": "it means component graphs are present, which is not mentioned in the awful description :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is that the input [[]] one?  it nailed me too"
                    },
                    {
                        "username": "02Gaurav",
                        "content": "i also passed 79/81 but 2 cases i dont know where exactly the problem is. Seems greedy approach wont work\\n"
                    },
                    {
                        "username": "lukevastus",
                        "content": "Apparently the graph should look like a triangle. \t\nSo why is the number 2 neither in graph[0] or in graph[1]?\nThe correct test case should be [[1, 2], [0, 2], [0, 1]]\n"
                    },
                    {
                        "username": "user8228j",
                        "content": "an hour and 15 minutes of my life gone."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/is-graph-bipartite/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Coloring by Depth-First Search [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "so how does [[1,3], [0,2], [1,3], [0,2]]\\nturn into a square diagram? two [1,3] and two [0,2]? \\n[1,3] means x at 1 and y at 3?"
                    },
                    {
                        "username": "v1shal",
                        "content": "In adj list representation, array at ith position represents the neighbors of ith node\\n\\n0--> 1,3\\n1--> 0,2\\n2--> 1,3\\n3--> 0,2\\n\\nfor ex - neighbors of node \"0\" is 1 and 3 and so on.\\n\\nWhen you connect them it would turn into a square"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Is this description so good that they locked the editorial \\uD83D\\uDE44"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/possible-bipartition/description/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Thank you for the info. The description over there sounds like a directed graph. The fact that ai dislikes bi cannot imply that  bi dislikes ai"
                    }
                ]
            },
            {
                "id": 1565319,
                "content": [
                    {
                        "username": "sasuke_uchiha",
                        "content": "Hi, Can please someone help me explainning How the input\\n[[1,3], [0,2], [1,3], [0,2]] \\nis working. I am not able to understand How does this input make this graph\\n0----1\\n|      |\\n|      |\\n3----2"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "0----1, 3\\n1----0, 2\\n2----1, 3\\n3----0, 2\\n\\n\\n 0-----1\\n |         | \\n3----- 2\\n\\n\\ntwo components"
                    },
                    {
                        "username": "RahulRaniwal",
                        "content": "for every value of row it is given that which node is connected to it\n\n0 -> 1 ,3\n1 -> 0 , 2\n2 -> 1 , 3\n3 -> 0 , 2\n\n0 ------- 1\n|              |\n|              |\n3 ------- 2\nThats how your graph will look \n[@Sunidhi Chaudhary](/sasuke_uchiha)"
                    },
                    {
                        "username": "gflanary",
                        "content": "This is a straightforward problem, but the description is positively awful.\\n\\nIf they had an image with disjoint sets and especially if they had one with colorized groupings, it would be clear what the intent was."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I found the description perfectly clear and rigorous, but I didn't find the problem straight forward at all.\nI guess I gotta work on my graph problems and you have to work on your problem reading/analysis!\nRoom for improvement for all"
                    },
                    {
                        "username": "mc_montecarlo",
                        "content": "I have a doubt with the test-case:\\n[[4],[],[4],[4],[0,2,3]]\\n\\nAbove test-case represents a graph is isn\\'t connected. But, the expected result of above is true. So my question is, how can a dis-connected graph be bi-partite?"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "A disconnected graph is bipartite if all the individually connected components are bipartite themselves. i.e, a singly disconnected graph with 2 or more regions is bipartite if all of those regions are bipartite."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "[@sasta_samurai](/sasta_samurai) \"questions says you should form two sets where every element of both sets are connected. \"\\nNo the question doesn\\'t say that.\\nIt says every \\'edge\\' must connect nodes from A and B.\\nA disconnected node can be put in any group because it has no edge."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Unfortunately the problem description is totally unclear about how to handle unconnected graphs. I hate when it\\'s a coin toss about how to handle some specific test case. In this case I agree that it should be false and got a WA because of it."
                    },
                    {
                        "username": "1dan_1609_",
                        "content": "In a disconnected graph. you have to basically check if each connected sub graph is bipartite."
                    },
                    {
                        "username": "sasta_samurai",
                        "content": "[@Riantix](/Riantix) I don\\'t think your conclusion is correct, questions says you should form two sets where every element of both sets are connected. [0,1,2] [3,4] 1 is not connected to any nodes in original graph while in your answer, it is connected to 3 and 4."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@Riantix](/Riantix)  dumb dumb dumb\\n"
                    },
                    {
                        "username": "user1737NM",
                        "content": "[@Riantix](/Riantix) how come 3 and 4 can belong to the same group?"
                    },
                    {
                        "username": "Riantix",
                        "content": "[@yyol](/yyol) A bipartite graph simply means you have can have two groups, each node goes to exactly one group, and there are no edges between two nodes in the same group. Thus an unconnected graph can still be bipartite.\\n\\nAs an example, a graph with 5 nodes and no edges (thus being unconnected) will be bipartite. You can form the two groups as [0, 1, 2] [3, 4] or [0], [1, 2, 3, 4], or others."
                    },
                    {
                        "username": "yyol",
                        "content": "same question, did you have conclusion?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "My respect for **76 / 81 testcase**"
                    },
                    {
                        "username": "SrirajBehera",
                        "content": "it means component graphs are present, which is not mentioned in the awful description :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is that the input [[]] one?  it nailed me too"
                    },
                    {
                        "username": "02Gaurav",
                        "content": "i also passed 79/81 but 2 cases i dont know where exactly the problem is. Seems greedy approach wont work\\n"
                    },
                    {
                        "username": "lukevastus",
                        "content": "Apparently the graph should look like a triangle. \t\nSo why is the number 2 neither in graph[0] or in graph[1]?\nThe correct test case should be [[1, 2], [0, 2], [0, 1]]\n"
                    },
                    {
                        "username": "user8228j",
                        "content": "an hour and 15 minutes of my life gone."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/is-graph-bipartite/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Coloring by Depth-First Search [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "so how does [[1,3], [0,2], [1,3], [0,2]]\\nturn into a square diagram? two [1,3] and two [0,2]? \\n[1,3] means x at 1 and y at 3?"
                    },
                    {
                        "username": "v1shal",
                        "content": "In adj list representation, array at ith position represents the neighbors of ith node\\n\\n0--> 1,3\\n1--> 0,2\\n2--> 1,3\\n3--> 0,2\\n\\nfor ex - neighbors of node \"0\" is 1 and 3 and so on.\\n\\nWhen you connect them it would turn into a square"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Is this description so good that they locked the editorial \\uD83D\\uDE44"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/possible-bipartition/description/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Thank you for the info. The description over there sounds like a directed graph. The fact that ai dislikes bi cannot imply that  bi dislikes ai"
                    }
                ]
            },
            {
                "id": 1898622,
                "content": [
                    {
                        "username": "sasuke_uchiha",
                        "content": "Hi, Can please someone help me explainning How the input\\n[[1,3], [0,2], [1,3], [0,2]] \\nis working. I am not able to understand How does this input make this graph\\n0----1\\n|      |\\n|      |\\n3----2"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "0----1, 3\\n1----0, 2\\n2----1, 3\\n3----0, 2\\n\\n\\n 0-----1\\n |         | \\n3----- 2\\n\\n\\ntwo components"
                    },
                    {
                        "username": "RahulRaniwal",
                        "content": "for every value of row it is given that which node is connected to it\n\n0 -> 1 ,3\n1 -> 0 , 2\n2 -> 1 , 3\n3 -> 0 , 2\n\n0 ------- 1\n|              |\n|              |\n3 ------- 2\nThats how your graph will look \n[@Sunidhi Chaudhary](/sasuke_uchiha)"
                    },
                    {
                        "username": "gflanary",
                        "content": "This is a straightforward problem, but the description is positively awful.\\n\\nIf they had an image with disjoint sets and especially if they had one with colorized groupings, it would be clear what the intent was."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I found the description perfectly clear and rigorous, but I didn't find the problem straight forward at all.\nI guess I gotta work on my graph problems and you have to work on your problem reading/analysis!\nRoom for improvement for all"
                    },
                    {
                        "username": "mc_montecarlo",
                        "content": "I have a doubt with the test-case:\\n[[4],[],[4],[4],[0,2,3]]\\n\\nAbove test-case represents a graph is isn\\'t connected. But, the expected result of above is true. So my question is, how can a dis-connected graph be bi-partite?"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "A disconnected graph is bipartite if all the individually connected components are bipartite themselves. i.e, a singly disconnected graph with 2 or more regions is bipartite if all of those regions are bipartite."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "[@sasta_samurai](/sasta_samurai) \"questions says you should form two sets where every element of both sets are connected. \"\\nNo the question doesn\\'t say that.\\nIt says every \\'edge\\' must connect nodes from A and B.\\nA disconnected node can be put in any group because it has no edge."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Unfortunately the problem description is totally unclear about how to handle unconnected graphs. I hate when it\\'s a coin toss about how to handle some specific test case. In this case I agree that it should be false and got a WA because of it."
                    },
                    {
                        "username": "1dan_1609_",
                        "content": "In a disconnected graph. you have to basically check if each connected sub graph is bipartite."
                    },
                    {
                        "username": "sasta_samurai",
                        "content": "[@Riantix](/Riantix) I don\\'t think your conclusion is correct, questions says you should form two sets where every element of both sets are connected. [0,1,2] [3,4] 1 is not connected to any nodes in original graph while in your answer, it is connected to 3 and 4."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@Riantix](/Riantix)  dumb dumb dumb\\n"
                    },
                    {
                        "username": "user1737NM",
                        "content": "[@Riantix](/Riantix) how come 3 and 4 can belong to the same group?"
                    },
                    {
                        "username": "Riantix",
                        "content": "[@yyol](/yyol) A bipartite graph simply means you have can have two groups, each node goes to exactly one group, and there are no edges between two nodes in the same group. Thus an unconnected graph can still be bipartite.\\n\\nAs an example, a graph with 5 nodes and no edges (thus being unconnected) will be bipartite. You can form the two groups as [0, 1, 2] [3, 4] or [0], [1, 2, 3, 4], or others."
                    },
                    {
                        "username": "yyol",
                        "content": "same question, did you have conclusion?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "My respect for **76 / 81 testcase**"
                    },
                    {
                        "username": "SrirajBehera",
                        "content": "it means component graphs are present, which is not mentioned in the awful description :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is that the input [[]] one?  it nailed me too"
                    },
                    {
                        "username": "02Gaurav",
                        "content": "i also passed 79/81 but 2 cases i dont know where exactly the problem is. Seems greedy approach wont work\\n"
                    },
                    {
                        "username": "lukevastus",
                        "content": "Apparently the graph should look like a triangle. \t\nSo why is the number 2 neither in graph[0] or in graph[1]?\nThe correct test case should be [[1, 2], [0, 2], [0, 1]]\n"
                    },
                    {
                        "username": "user8228j",
                        "content": "an hour and 15 minutes of my life gone."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/is-graph-bipartite/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Coloring by Depth-First Search [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "so how does [[1,3], [0,2], [1,3], [0,2]]\\nturn into a square diagram? two [1,3] and two [0,2]? \\n[1,3] means x at 1 and y at 3?"
                    },
                    {
                        "username": "v1shal",
                        "content": "In adj list representation, array at ith position represents the neighbors of ith node\\n\\n0--> 1,3\\n1--> 0,2\\n2--> 1,3\\n3--> 0,2\\n\\nfor ex - neighbors of node \"0\" is 1 and 3 and so on.\\n\\nWhen you connect them it would turn into a square"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Is this description so good that they locked the editorial \\uD83D\\uDE44"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/possible-bipartition/description/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Thank you for the info. The description over there sounds like a directed graph. The fact that ai dislikes bi cannot imply that  bi dislikes ai"
                    }
                ]
            },
            {
                "id": 1566435,
                "content": [
                    {
                        "username": "sasuke_uchiha",
                        "content": "Hi, Can please someone help me explainning How the input\\n[[1,3], [0,2], [1,3], [0,2]] \\nis working. I am not able to understand How does this input make this graph\\n0----1\\n|      |\\n|      |\\n3----2"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "0----1, 3\\n1----0, 2\\n2----1, 3\\n3----0, 2\\n\\n\\n 0-----1\\n |         | \\n3----- 2\\n\\n\\ntwo components"
                    },
                    {
                        "username": "RahulRaniwal",
                        "content": "for every value of row it is given that which node is connected to it\n\n0 -> 1 ,3\n1 -> 0 , 2\n2 -> 1 , 3\n3 -> 0 , 2\n\n0 ------- 1\n|              |\n|              |\n3 ------- 2\nThats how your graph will look \n[@Sunidhi Chaudhary](/sasuke_uchiha)"
                    },
                    {
                        "username": "gflanary",
                        "content": "This is a straightforward problem, but the description is positively awful.\\n\\nIf they had an image with disjoint sets and especially if they had one with colorized groupings, it would be clear what the intent was."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I found the description perfectly clear and rigorous, but I didn't find the problem straight forward at all.\nI guess I gotta work on my graph problems and you have to work on your problem reading/analysis!\nRoom for improvement for all"
                    },
                    {
                        "username": "mc_montecarlo",
                        "content": "I have a doubt with the test-case:\\n[[4],[],[4],[4],[0,2,3]]\\n\\nAbove test-case represents a graph is isn\\'t connected. But, the expected result of above is true. So my question is, how can a dis-connected graph be bi-partite?"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "A disconnected graph is bipartite if all the individually connected components are bipartite themselves. i.e, a singly disconnected graph with 2 or more regions is bipartite if all of those regions are bipartite."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "[@sasta_samurai](/sasta_samurai) \"questions says you should form two sets where every element of both sets are connected. \"\\nNo the question doesn\\'t say that.\\nIt says every \\'edge\\' must connect nodes from A and B.\\nA disconnected node can be put in any group because it has no edge."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Unfortunately the problem description is totally unclear about how to handle unconnected graphs. I hate when it\\'s a coin toss about how to handle some specific test case. In this case I agree that it should be false and got a WA because of it."
                    },
                    {
                        "username": "1dan_1609_",
                        "content": "In a disconnected graph. you have to basically check if each connected sub graph is bipartite."
                    },
                    {
                        "username": "sasta_samurai",
                        "content": "[@Riantix](/Riantix) I don\\'t think your conclusion is correct, questions says you should form two sets where every element of both sets are connected. [0,1,2] [3,4] 1 is not connected to any nodes in original graph while in your answer, it is connected to 3 and 4."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@Riantix](/Riantix)  dumb dumb dumb\\n"
                    },
                    {
                        "username": "user1737NM",
                        "content": "[@Riantix](/Riantix) how come 3 and 4 can belong to the same group?"
                    },
                    {
                        "username": "Riantix",
                        "content": "[@yyol](/yyol) A bipartite graph simply means you have can have two groups, each node goes to exactly one group, and there are no edges between two nodes in the same group. Thus an unconnected graph can still be bipartite.\\n\\nAs an example, a graph with 5 nodes and no edges (thus being unconnected) will be bipartite. You can form the two groups as [0, 1, 2] [3, 4] or [0], [1, 2, 3, 4], or others."
                    },
                    {
                        "username": "yyol",
                        "content": "same question, did you have conclusion?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "My respect for **76 / 81 testcase**"
                    },
                    {
                        "username": "SrirajBehera",
                        "content": "it means component graphs are present, which is not mentioned in the awful description :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is that the input [[]] one?  it nailed me too"
                    },
                    {
                        "username": "02Gaurav",
                        "content": "i also passed 79/81 but 2 cases i dont know where exactly the problem is. Seems greedy approach wont work\\n"
                    },
                    {
                        "username": "lukevastus",
                        "content": "Apparently the graph should look like a triangle. \t\nSo why is the number 2 neither in graph[0] or in graph[1]?\nThe correct test case should be [[1, 2], [0, 2], [0, 1]]\n"
                    },
                    {
                        "username": "user8228j",
                        "content": "an hour and 15 minutes of my life gone."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/is-graph-bipartite/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Coloring by Depth-First Search [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "so how does [[1,3], [0,2], [1,3], [0,2]]\\nturn into a square diagram? two [1,3] and two [0,2]? \\n[1,3] means x at 1 and y at 3?"
                    },
                    {
                        "username": "v1shal",
                        "content": "In adj list representation, array at ith position represents the neighbors of ith node\\n\\n0--> 1,3\\n1--> 0,2\\n2--> 1,3\\n3--> 0,2\\n\\nfor ex - neighbors of node \"0\" is 1 and 3 and so on.\\n\\nWhen you connect them it would turn into a square"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Is this description so good that they locked the editorial \\uD83D\\uDE44"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/possible-bipartition/description/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Thank you for the info. The description over there sounds like a directed graph. The fact that ai dislikes bi cannot imply that  bi dislikes ai"
                    }
                ]
            },
            {
                "id": 1566576,
                "content": [
                    {
                        "username": "sasuke_uchiha",
                        "content": "Hi, Can please someone help me explainning How the input\\n[[1,3], [0,2], [1,3], [0,2]] \\nis working. I am not able to understand How does this input make this graph\\n0----1\\n|      |\\n|      |\\n3----2"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "0----1, 3\\n1----0, 2\\n2----1, 3\\n3----0, 2\\n\\n\\n 0-----1\\n |         | \\n3----- 2\\n\\n\\ntwo components"
                    },
                    {
                        "username": "RahulRaniwal",
                        "content": "for every value of row it is given that which node is connected to it\n\n0 -> 1 ,3\n1 -> 0 , 2\n2 -> 1 , 3\n3 -> 0 , 2\n\n0 ------- 1\n|              |\n|              |\n3 ------- 2\nThats how your graph will look \n[@Sunidhi Chaudhary](/sasuke_uchiha)"
                    },
                    {
                        "username": "gflanary",
                        "content": "This is a straightforward problem, but the description is positively awful.\\n\\nIf they had an image with disjoint sets and especially if they had one with colorized groupings, it would be clear what the intent was."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I found the description perfectly clear and rigorous, but I didn't find the problem straight forward at all.\nI guess I gotta work on my graph problems and you have to work on your problem reading/analysis!\nRoom for improvement for all"
                    },
                    {
                        "username": "mc_montecarlo",
                        "content": "I have a doubt with the test-case:\\n[[4],[],[4],[4],[0,2,3]]\\n\\nAbove test-case represents a graph is isn\\'t connected. But, the expected result of above is true. So my question is, how can a dis-connected graph be bi-partite?"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "A disconnected graph is bipartite if all the individually connected components are bipartite themselves. i.e, a singly disconnected graph with 2 or more regions is bipartite if all of those regions are bipartite."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "[@sasta_samurai](/sasta_samurai) \"questions says you should form two sets where every element of both sets are connected. \"\\nNo the question doesn\\'t say that.\\nIt says every \\'edge\\' must connect nodes from A and B.\\nA disconnected node can be put in any group because it has no edge."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Unfortunately the problem description is totally unclear about how to handle unconnected graphs. I hate when it\\'s a coin toss about how to handle some specific test case. In this case I agree that it should be false and got a WA because of it."
                    },
                    {
                        "username": "1dan_1609_",
                        "content": "In a disconnected graph. you have to basically check if each connected sub graph is bipartite."
                    },
                    {
                        "username": "sasta_samurai",
                        "content": "[@Riantix](/Riantix) I don\\'t think your conclusion is correct, questions says you should form two sets where every element of both sets are connected. [0,1,2] [3,4] 1 is not connected to any nodes in original graph while in your answer, it is connected to 3 and 4."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@Riantix](/Riantix)  dumb dumb dumb\\n"
                    },
                    {
                        "username": "user1737NM",
                        "content": "[@Riantix](/Riantix) how come 3 and 4 can belong to the same group?"
                    },
                    {
                        "username": "Riantix",
                        "content": "[@yyol](/yyol) A bipartite graph simply means you have can have two groups, each node goes to exactly one group, and there are no edges between two nodes in the same group. Thus an unconnected graph can still be bipartite.\\n\\nAs an example, a graph with 5 nodes and no edges (thus being unconnected) will be bipartite. You can form the two groups as [0, 1, 2] [3, 4] or [0], [1, 2, 3, 4], or others."
                    },
                    {
                        "username": "yyol",
                        "content": "same question, did you have conclusion?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "My respect for **76 / 81 testcase**"
                    },
                    {
                        "username": "SrirajBehera",
                        "content": "it means component graphs are present, which is not mentioned in the awful description :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is that the input [[]] one?  it nailed me too"
                    },
                    {
                        "username": "02Gaurav",
                        "content": "i also passed 79/81 but 2 cases i dont know where exactly the problem is. Seems greedy approach wont work\\n"
                    },
                    {
                        "username": "lukevastus",
                        "content": "Apparently the graph should look like a triangle. \t\nSo why is the number 2 neither in graph[0] or in graph[1]?\nThe correct test case should be [[1, 2], [0, 2], [0, 1]]\n"
                    },
                    {
                        "username": "user8228j",
                        "content": "an hour and 15 minutes of my life gone."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/is-graph-bipartite/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Coloring by Depth-First Search [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "so how does [[1,3], [0,2], [1,3], [0,2]]\\nturn into a square diagram? two [1,3] and two [0,2]? \\n[1,3] means x at 1 and y at 3?"
                    },
                    {
                        "username": "v1shal",
                        "content": "In adj list representation, array at ith position represents the neighbors of ith node\\n\\n0--> 1,3\\n1--> 0,2\\n2--> 1,3\\n3--> 0,2\\n\\nfor ex - neighbors of node \"0\" is 1 and 3 and so on.\\n\\nWhen you connect them it would turn into a square"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Is this description so good that they locked the editorial \\uD83D\\uDE44"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/possible-bipartition/description/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Thank you for the info. The description over there sounds like a directed graph. The fact that ai dislikes bi cannot imply that  bi dislikes ai"
                    }
                ]
            },
            {
                "id": 1898645,
                "content": [
                    {
                        "username": "sasuke_uchiha",
                        "content": "Hi, Can please someone help me explainning How the input\\n[[1,3], [0,2], [1,3], [0,2]] \\nis working. I am not able to understand How does this input make this graph\\n0----1\\n|      |\\n|      |\\n3----2"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "0----1, 3\\n1----0, 2\\n2----1, 3\\n3----0, 2\\n\\n\\n 0-----1\\n |         | \\n3----- 2\\n\\n\\ntwo components"
                    },
                    {
                        "username": "RahulRaniwal",
                        "content": "for every value of row it is given that which node is connected to it\n\n0 -> 1 ,3\n1 -> 0 , 2\n2 -> 1 , 3\n3 -> 0 , 2\n\n0 ------- 1\n|              |\n|              |\n3 ------- 2\nThats how your graph will look \n[@Sunidhi Chaudhary](/sasuke_uchiha)"
                    },
                    {
                        "username": "gflanary",
                        "content": "This is a straightforward problem, but the description is positively awful.\\n\\nIf they had an image with disjoint sets and especially if they had one with colorized groupings, it would be clear what the intent was."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I found the description perfectly clear and rigorous, but I didn't find the problem straight forward at all.\nI guess I gotta work on my graph problems and you have to work on your problem reading/analysis!\nRoom for improvement for all"
                    },
                    {
                        "username": "mc_montecarlo",
                        "content": "I have a doubt with the test-case:\\n[[4],[],[4],[4],[0,2,3]]\\n\\nAbove test-case represents a graph is isn\\'t connected. But, the expected result of above is true. So my question is, how can a dis-connected graph be bi-partite?"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "A disconnected graph is bipartite if all the individually connected components are bipartite themselves. i.e, a singly disconnected graph with 2 or more regions is bipartite if all of those regions are bipartite."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "[@sasta_samurai](/sasta_samurai) \"questions says you should form two sets where every element of both sets are connected. \"\\nNo the question doesn\\'t say that.\\nIt says every \\'edge\\' must connect nodes from A and B.\\nA disconnected node can be put in any group because it has no edge."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Unfortunately the problem description is totally unclear about how to handle unconnected graphs. I hate when it\\'s a coin toss about how to handle some specific test case. In this case I agree that it should be false and got a WA because of it."
                    },
                    {
                        "username": "1dan_1609_",
                        "content": "In a disconnected graph. you have to basically check if each connected sub graph is bipartite."
                    },
                    {
                        "username": "sasta_samurai",
                        "content": "[@Riantix](/Riantix) I don\\'t think your conclusion is correct, questions says you should form two sets where every element of both sets are connected. [0,1,2] [3,4] 1 is not connected to any nodes in original graph while in your answer, it is connected to 3 and 4."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@Riantix](/Riantix)  dumb dumb dumb\\n"
                    },
                    {
                        "username": "user1737NM",
                        "content": "[@Riantix](/Riantix) how come 3 and 4 can belong to the same group?"
                    },
                    {
                        "username": "Riantix",
                        "content": "[@yyol](/yyol) A bipartite graph simply means you have can have two groups, each node goes to exactly one group, and there are no edges between two nodes in the same group. Thus an unconnected graph can still be bipartite.\\n\\nAs an example, a graph with 5 nodes and no edges (thus being unconnected) will be bipartite. You can form the two groups as [0, 1, 2] [3, 4] or [0], [1, 2, 3, 4], or others."
                    },
                    {
                        "username": "yyol",
                        "content": "same question, did you have conclusion?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "My respect for **76 / 81 testcase**"
                    },
                    {
                        "username": "SrirajBehera",
                        "content": "it means component graphs are present, which is not mentioned in the awful description :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is that the input [[]] one?  it nailed me too"
                    },
                    {
                        "username": "02Gaurav",
                        "content": "i also passed 79/81 but 2 cases i dont know where exactly the problem is. Seems greedy approach wont work\\n"
                    },
                    {
                        "username": "lukevastus",
                        "content": "Apparently the graph should look like a triangle. \t\nSo why is the number 2 neither in graph[0] or in graph[1]?\nThe correct test case should be [[1, 2], [0, 2], [0, 1]]\n"
                    },
                    {
                        "username": "user8228j",
                        "content": "an hour and 15 minutes of my life gone."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/is-graph-bipartite/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Coloring by Depth-First Search [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "so how does [[1,3], [0,2], [1,3], [0,2]]\\nturn into a square diagram? two [1,3] and two [0,2]? \\n[1,3] means x at 1 and y at 3?"
                    },
                    {
                        "username": "v1shal",
                        "content": "In adj list representation, array at ith position represents the neighbors of ith node\\n\\n0--> 1,3\\n1--> 0,2\\n2--> 1,3\\n3--> 0,2\\n\\nfor ex - neighbors of node \"0\" is 1 and 3 and so on.\\n\\nWhen you connect them it would turn into a square"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Is this description so good that they locked the editorial \\uD83D\\uDE44"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/possible-bipartition/description/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Thank you for the info. The description over there sounds like a directed graph. The fact that ai dislikes bi cannot imply that  bi dislikes ai"
                    }
                ]
            },
            {
                "id": 1815093,
                "content": [
                    {
                        "username": "sasuke_uchiha",
                        "content": "Hi, Can please someone help me explainning How the input\\n[[1,3], [0,2], [1,3], [0,2]] \\nis working. I am not able to understand How does this input make this graph\\n0----1\\n|      |\\n|      |\\n3----2"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "0----1, 3\\n1----0, 2\\n2----1, 3\\n3----0, 2\\n\\n\\n 0-----1\\n |         | \\n3----- 2\\n\\n\\ntwo components"
                    },
                    {
                        "username": "RahulRaniwal",
                        "content": "for every value of row it is given that which node is connected to it\n\n0 -> 1 ,3\n1 -> 0 , 2\n2 -> 1 , 3\n3 -> 0 , 2\n\n0 ------- 1\n|              |\n|              |\n3 ------- 2\nThats how your graph will look \n[@Sunidhi Chaudhary](/sasuke_uchiha)"
                    },
                    {
                        "username": "gflanary",
                        "content": "This is a straightforward problem, but the description is positively awful.\\n\\nIf they had an image with disjoint sets and especially if they had one with colorized groupings, it would be clear what the intent was."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I found the description perfectly clear and rigorous, but I didn't find the problem straight forward at all.\nI guess I gotta work on my graph problems and you have to work on your problem reading/analysis!\nRoom for improvement for all"
                    },
                    {
                        "username": "mc_montecarlo",
                        "content": "I have a doubt with the test-case:\\n[[4],[],[4],[4],[0,2,3]]\\n\\nAbove test-case represents a graph is isn\\'t connected. But, the expected result of above is true. So my question is, how can a dis-connected graph be bi-partite?"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "A disconnected graph is bipartite if all the individually connected components are bipartite themselves. i.e, a singly disconnected graph with 2 or more regions is bipartite if all of those regions are bipartite."
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "[@sasta_samurai](/sasta_samurai) \"questions says you should form two sets where every element of both sets are connected. \"\\nNo the question doesn\\'t say that.\\nIt says every \\'edge\\' must connect nodes from A and B.\\nA disconnected node can be put in any group because it has no edge."
                    },
                    {
                        "username": "jeffcamera",
                        "content": "Unfortunately the problem description is totally unclear about how to handle unconnected graphs. I hate when it\\'s a coin toss about how to handle some specific test case. In this case I agree that it should be false and got a WA because of it."
                    },
                    {
                        "username": "1dan_1609_",
                        "content": "In a disconnected graph. you have to basically check if each connected sub graph is bipartite."
                    },
                    {
                        "username": "sasta_samurai",
                        "content": "[@Riantix](/Riantix) I don\\'t think your conclusion is correct, questions says you should form two sets where every element of both sets are connected. [0,1,2] [3,4] 1 is not connected to any nodes in original graph while in your answer, it is connected to 3 and 4."
                    },
                    {
                        "username": "meow_power",
                        "content": "[@Riantix](/Riantix)  dumb dumb dumb\\n"
                    },
                    {
                        "username": "user1737NM",
                        "content": "[@Riantix](/Riantix) how come 3 and 4 can belong to the same group?"
                    },
                    {
                        "username": "Riantix",
                        "content": "[@yyol](/yyol) A bipartite graph simply means you have can have two groups, each node goes to exactly one group, and there are no edges between two nodes in the same group. Thus an unconnected graph can still be bipartite.\\n\\nAs an example, a graph with 5 nodes and no edges (thus being unconnected) will be bipartite. You can form the two groups as [0, 1, 2] [3, 4] or [0], [1, 2, 3, 4], or others."
                    },
                    {
                        "username": "yyol",
                        "content": "same question, did you have conclusion?"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "My respect for **76 / 81 testcase**"
                    },
                    {
                        "username": "SrirajBehera",
                        "content": "it means component graphs are present, which is not mentioned in the awful description :)"
                    },
                    {
                        "username": "user5400vw",
                        "content": "is that the input [[]] one?  it nailed me too"
                    },
                    {
                        "username": "02Gaurav",
                        "content": "i also passed 79/81 but 2 cases i dont know where exactly the problem is. Seems greedy approach wont work\\n"
                    },
                    {
                        "username": "lukevastus",
                        "content": "Apparently the graph should look like a triangle. \t\nSo why is the number 2 neither in graph[0] or in graph[1]?\nThe correct test case should be [[1, 2], [0, 2], [0, 1]]\n"
                    },
                    {
                        "username": "user8228j",
                        "content": "an hour and 15 minutes of my life gone."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/is-graph-bipartite/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Coloring by Depth-First Search [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hopeNoPip",
                        "content": "so how does [[1,3], [0,2], [1,3], [0,2]]\\nturn into a square diagram? two [1,3] and two [0,2]? \\n[1,3] means x at 1 and y at 3?"
                    },
                    {
                        "username": "v1shal",
                        "content": "In adj list representation, array at ith position represents the neighbors of ith node\\n\\n0--> 1,3\\n1--> 0,2\\n2--> 1,3\\n3--> 0,2\\n\\nfor ex - neighbors of node \"0\" is 1 and 3 and so on.\\n\\nWhen you connect them it would turn into a square"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Is this description so good that they locked the editorial \\uD83D\\uDE44"
                    },
                    {
                        "username": "rjdarkknight1",
                        "content": "same as https://leetcode.com/problems/possible-bipartition/description/"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Thank you for the info. The description over there sounds like a directed graph. The fact that ai dislikes bi cannot imply that  bi dislikes ai"
                    }
                ]
            },
            {
                "id": 1898608,
                "content": [
                    {
                        "username": "andrewlaack1",
                        "content": "Honest question, has anyone ever had an interview where they were asked a graph theory question?"
                    },
                    {
                        "username": "who_rules",
                        "content": "Asked at FAANG company"
                    },
                    {
                        "username": "jbreefer",
                        "content": "Absolutely yes. Less common than path finding or greedy but still, definitely yes"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "Many times!"
                    },
                    {
                        "username": "asim35",
                        "content": "yes, i was asked courses and prerequisite question, that is solved using graph colouring"
                    },
                    {
                        "username": "anwendeng",
                        "content": "DFS recursion solution is more easy than other. In fact, it is to solve the graph coloring problem!!BFS solution is doable, and even faster"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/is-graph-bipartite/solutions/3540461/easy-c-dfs-solution/"
                    },
                    {
                        "username": "meow_power",
                        "content": "Equivalent definitions of a bipartite graph:\\n1) There is no cycle of odd length\\n\\n2) we can split the nodes of the graph\\n(vertex set of the graph) into 2 subsets so\\nthat there is all the edges go from 1 subset\\nto the other subset.\\n\\n3.The graph should be bi-colourable.\\n\\f"
                    },
                    {
                        "username": "intodust",
                        "content": "graph[i] will contain integers in range [0, graph.length - 1].\\nShould be\\ngraph[i] will contain NULL or integers in range[0, graph.length -1]\\n\\n"
                    },
                    {
                        "username": "stefancristianco",
                        "content": "Bipartite graph solved via a \"graph coloring algorithm\" works best with non directed graphs. This being a directed graph you need to transform it into a non directed graph before you call bfs/dfs.\\n\\nFor example. The validation algortihm returns \"false\" for the following case, I believe the answer should be \"true\".\\nInput: [[1,2],[],[],[1,2],[3]]\\nOutput: false\\n\\nBut should be true because we can split the nodes as follows:\\n{0,3}, {1,2,4}"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "First of all tell me how come 0 is connected to 1 and 2 but both of them are not connected to 0 as per your test case  [[1,2],[],[],[1,2],[3]]"
                    },
                    {
                        "username": "AnkurHaritosh",
                        "content": "Hey everyone, the Leetcode community has helped me a lot. I am preparing for interviews and filming my explanations. Hope this helps out someone: https://youtu.be/8eHAqJVdd0c"
                    },
                    {
                        "username": "charonme",
                        "content": "note that an empty graph [[],[],[],[],[]] is bipartite too"
                    },
                    {
                        "username": "rishichowdhury711",
                        "content": "can anyone help me as to how\\n[[1],[0,3],[3],[1,2]] is  bipartite graph in the context of this question. I think it is not because there is no edge between 0 and 2 . Therefore it should not be a bipartite graph"
                    },
                    {
                        "username": "Diyo",
                        "content": "should be quite simple if you draw it.\\n-node 0 is connected to node 1 [1]\\n-node 1 is connected to node 0 and 3 [0,3]\\n-node 2 is connected to node 3 [3]\\n-node 3 is connected to node 1 and 2 [1,2]\\nyou get the following graph:\\n1-----0\\n|\\n|\\n3-----2\\nyou can colour node 0 white, node 1 black, node 3 white, node 2 black\\n--> the graph is bicolourable --> the graph is bipartite --> return true"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The graph is bipartite because the nodes can be partitioned into two sets {0,3} and {1,2}. At this point, we have successfully partitioned all the nodes into two independent sets, and every edge in the graph connects a node from Set A to a node from Set B. No two vertices in the same set are connected by an edge, so the graph is bipartite.\n\n[0] - [1] - [3] - [2]"
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "One thing to mention that the test cases also considers the case where the graph is divided into components so keep in mind to iterate over the BFS or DFS algo to make sure you dont leave any component unchecked ..... dont worry about TLE it wont happen LOL"
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "I KNOW ITS NOT GOOD PLATFORM TO ASK BUT ANY GOOD ANIME RECOMMENDATION THAT COULD HELP ME RELIEVE MY STRESS.... THANKS IN ADVANCE"
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "Naruto"
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "One Piece"
                    },
                    {
                        "username": "charonme",
                        "content": "one punch man"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Kamisama kiss, ichigo mashimaro"
                    }
                ]
            },
            {
                "id": 1898757,
                "content": [
                    {
                        "username": "andrewlaack1",
                        "content": "Honest question, has anyone ever had an interview where they were asked a graph theory question?"
                    },
                    {
                        "username": "who_rules",
                        "content": "Asked at FAANG company"
                    },
                    {
                        "username": "jbreefer",
                        "content": "Absolutely yes. Less common than path finding or greedy but still, definitely yes"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "Many times!"
                    },
                    {
                        "username": "asim35",
                        "content": "yes, i was asked courses and prerequisite question, that is solved using graph colouring"
                    },
                    {
                        "username": "anwendeng",
                        "content": "DFS recursion solution is more easy than other. In fact, it is to solve the graph coloring problem!!BFS solution is doable, and even faster"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/is-graph-bipartite/solutions/3540461/easy-c-dfs-solution/"
                    },
                    {
                        "username": "meow_power",
                        "content": "Equivalent definitions of a bipartite graph:\\n1) There is no cycle of odd length\\n\\n2) we can split the nodes of the graph\\n(vertex set of the graph) into 2 subsets so\\nthat there is all the edges go from 1 subset\\nto the other subset.\\n\\n3.The graph should be bi-colourable.\\n\\f"
                    },
                    {
                        "username": "intodust",
                        "content": "graph[i] will contain integers in range [0, graph.length - 1].\\nShould be\\ngraph[i] will contain NULL or integers in range[0, graph.length -1]\\n\\n"
                    },
                    {
                        "username": "stefancristianco",
                        "content": "Bipartite graph solved via a \"graph coloring algorithm\" works best with non directed graphs. This being a directed graph you need to transform it into a non directed graph before you call bfs/dfs.\\n\\nFor example. The validation algortihm returns \"false\" for the following case, I believe the answer should be \"true\".\\nInput: [[1,2],[],[],[1,2],[3]]\\nOutput: false\\n\\nBut should be true because we can split the nodes as follows:\\n{0,3}, {1,2,4}"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "First of all tell me how come 0 is connected to 1 and 2 but both of them are not connected to 0 as per your test case  [[1,2],[],[],[1,2],[3]]"
                    },
                    {
                        "username": "AnkurHaritosh",
                        "content": "Hey everyone, the Leetcode community has helped me a lot. I am preparing for interviews and filming my explanations. Hope this helps out someone: https://youtu.be/8eHAqJVdd0c"
                    },
                    {
                        "username": "charonme",
                        "content": "note that an empty graph [[],[],[],[],[]] is bipartite too"
                    },
                    {
                        "username": "rishichowdhury711",
                        "content": "can anyone help me as to how\\n[[1],[0,3],[3],[1,2]] is  bipartite graph in the context of this question. I think it is not because there is no edge between 0 and 2 . Therefore it should not be a bipartite graph"
                    },
                    {
                        "username": "Diyo",
                        "content": "should be quite simple if you draw it.\\n-node 0 is connected to node 1 [1]\\n-node 1 is connected to node 0 and 3 [0,3]\\n-node 2 is connected to node 3 [3]\\n-node 3 is connected to node 1 and 2 [1,2]\\nyou get the following graph:\\n1-----0\\n|\\n|\\n3-----2\\nyou can colour node 0 white, node 1 black, node 3 white, node 2 black\\n--> the graph is bicolourable --> the graph is bipartite --> return true"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The graph is bipartite because the nodes can be partitioned into two sets {0,3} and {1,2}. At this point, we have successfully partitioned all the nodes into two independent sets, and every edge in the graph connects a node from Set A to a node from Set B. No two vertices in the same set are connected by an edge, so the graph is bipartite.\n\n[0] - [1] - [3] - [2]"
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "One thing to mention that the test cases also considers the case where the graph is divided into components so keep in mind to iterate over the BFS or DFS algo to make sure you dont leave any component unchecked ..... dont worry about TLE it wont happen LOL"
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "I KNOW ITS NOT GOOD PLATFORM TO ASK BUT ANY GOOD ANIME RECOMMENDATION THAT COULD HELP ME RELIEVE MY STRESS.... THANKS IN ADVANCE"
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "Naruto"
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "One Piece"
                    },
                    {
                        "username": "charonme",
                        "content": "one punch man"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Kamisama kiss, ichigo mashimaro"
                    }
                ]
            },
            {
                "id": 1898590,
                "content": [
                    {
                        "username": "andrewlaack1",
                        "content": "Honest question, has anyone ever had an interview where they were asked a graph theory question?"
                    },
                    {
                        "username": "who_rules",
                        "content": "Asked at FAANG company"
                    },
                    {
                        "username": "jbreefer",
                        "content": "Absolutely yes. Less common than path finding or greedy but still, definitely yes"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "Many times!"
                    },
                    {
                        "username": "asim35",
                        "content": "yes, i was asked courses and prerequisite question, that is solved using graph colouring"
                    },
                    {
                        "username": "anwendeng",
                        "content": "DFS recursion solution is more easy than other. In fact, it is to solve the graph coloring problem!!BFS solution is doable, and even faster"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/is-graph-bipartite/solutions/3540461/easy-c-dfs-solution/"
                    },
                    {
                        "username": "meow_power",
                        "content": "Equivalent definitions of a bipartite graph:\\n1) There is no cycle of odd length\\n\\n2) we can split the nodes of the graph\\n(vertex set of the graph) into 2 subsets so\\nthat there is all the edges go from 1 subset\\nto the other subset.\\n\\n3.The graph should be bi-colourable.\\n\\f"
                    },
                    {
                        "username": "intodust",
                        "content": "graph[i] will contain integers in range [0, graph.length - 1].\\nShould be\\ngraph[i] will contain NULL or integers in range[0, graph.length -1]\\n\\n"
                    },
                    {
                        "username": "stefancristianco",
                        "content": "Bipartite graph solved via a \"graph coloring algorithm\" works best with non directed graphs. This being a directed graph you need to transform it into a non directed graph before you call bfs/dfs.\\n\\nFor example. The validation algortihm returns \"false\" for the following case, I believe the answer should be \"true\".\\nInput: [[1,2],[],[],[1,2],[3]]\\nOutput: false\\n\\nBut should be true because we can split the nodes as follows:\\n{0,3}, {1,2,4}"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "First of all tell me how come 0 is connected to 1 and 2 but both of them are not connected to 0 as per your test case  [[1,2],[],[],[1,2],[3]]"
                    },
                    {
                        "username": "AnkurHaritosh",
                        "content": "Hey everyone, the Leetcode community has helped me a lot. I am preparing for interviews and filming my explanations. Hope this helps out someone: https://youtu.be/8eHAqJVdd0c"
                    },
                    {
                        "username": "charonme",
                        "content": "note that an empty graph [[],[],[],[],[]] is bipartite too"
                    },
                    {
                        "username": "rishichowdhury711",
                        "content": "can anyone help me as to how\\n[[1],[0,3],[3],[1,2]] is  bipartite graph in the context of this question. I think it is not because there is no edge between 0 and 2 . Therefore it should not be a bipartite graph"
                    },
                    {
                        "username": "Diyo",
                        "content": "should be quite simple if you draw it.\\n-node 0 is connected to node 1 [1]\\n-node 1 is connected to node 0 and 3 [0,3]\\n-node 2 is connected to node 3 [3]\\n-node 3 is connected to node 1 and 2 [1,2]\\nyou get the following graph:\\n1-----0\\n|\\n|\\n3-----2\\nyou can colour node 0 white, node 1 black, node 3 white, node 2 black\\n--> the graph is bicolourable --> the graph is bipartite --> return true"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The graph is bipartite because the nodes can be partitioned into two sets {0,3} and {1,2}. At this point, we have successfully partitioned all the nodes into two independent sets, and every edge in the graph connects a node from Set A to a node from Set B. No two vertices in the same set are connected by an edge, so the graph is bipartite.\n\n[0] - [1] - [3] - [2]"
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "One thing to mention that the test cases also considers the case where the graph is divided into components so keep in mind to iterate over the BFS or DFS algo to make sure you dont leave any component unchecked ..... dont worry about TLE it wont happen LOL"
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "I KNOW ITS NOT GOOD PLATFORM TO ASK BUT ANY GOOD ANIME RECOMMENDATION THAT COULD HELP ME RELIEVE MY STRESS.... THANKS IN ADVANCE"
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "Naruto"
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "One Piece"
                    },
                    {
                        "username": "charonme",
                        "content": "one punch man"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Kamisama kiss, ichigo mashimaro"
                    }
                ]
            },
            {
                "id": 1570145,
                "content": [
                    {
                        "username": "andrewlaack1",
                        "content": "Honest question, has anyone ever had an interview where they were asked a graph theory question?"
                    },
                    {
                        "username": "who_rules",
                        "content": "Asked at FAANG company"
                    },
                    {
                        "username": "jbreefer",
                        "content": "Absolutely yes. Less common than path finding or greedy but still, definitely yes"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "Many times!"
                    },
                    {
                        "username": "asim35",
                        "content": "yes, i was asked courses and prerequisite question, that is solved using graph colouring"
                    },
                    {
                        "username": "anwendeng",
                        "content": "DFS recursion solution is more easy than other. In fact, it is to solve the graph coloring problem!!BFS solution is doable, and even faster"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/is-graph-bipartite/solutions/3540461/easy-c-dfs-solution/"
                    },
                    {
                        "username": "meow_power",
                        "content": "Equivalent definitions of a bipartite graph:\\n1) There is no cycle of odd length\\n\\n2) we can split the nodes of the graph\\n(vertex set of the graph) into 2 subsets so\\nthat there is all the edges go from 1 subset\\nto the other subset.\\n\\n3.The graph should be bi-colourable.\\n\\f"
                    },
                    {
                        "username": "intodust",
                        "content": "graph[i] will contain integers in range [0, graph.length - 1].\\nShould be\\ngraph[i] will contain NULL or integers in range[0, graph.length -1]\\n\\n"
                    },
                    {
                        "username": "stefancristianco",
                        "content": "Bipartite graph solved via a \"graph coloring algorithm\" works best with non directed graphs. This being a directed graph you need to transform it into a non directed graph before you call bfs/dfs.\\n\\nFor example. The validation algortihm returns \"false\" for the following case, I believe the answer should be \"true\".\\nInput: [[1,2],[],[],[1,2],[3]]\\nOutput: false\\n\\nBut should be true because we can split the nodes as follows:\\n{0,3}, {1,2,4}"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "First of all tell me how come 0 is connected to 1 and 2 but both of them are not connected to 0 as per your test case  [[1,2],[],[],[1,2],[3]]"
                    },
                    {
                        "username": "AnkurHaritosh",
                        "content": "Hey everyone, the Leetcode community has helped me a lot. I am preparing for interviews and filming my explanations. Hope this helps out someone: https://youtu.be/8eHAqJVdd0c"
                    },
                    {
                        "username": "charonme",
                        "content": "note that an empty graph [[],[],[],[],[]] is bipartite too"
                    },
                    {
                        "username": "rishichowdhury711",
                        "content": "can anyone help me as to how\\n[[1],[0,3],[3],[1,2]] is  bipartite graph in the context of this question. I think it is not because there is no edge between 0 and 2 . Therefore it should not be a bipartite graph"
                    },
                    {
                        "username": "Diyo",
                        "content": "should be quite simple if you draw it.\\n-node 0 is connected to node 1 [1]\\n-node 1 is connected to node 0 and 3 [0,3]\\n-node 2 is connected to node 3 [3]\\n-node 3 is connected to node 1 and 2 [1,2]\\nyou get the following graph:\\n1-----0\\n|\\n|\\n3-----2\\nyou can colour node 0 white, node 1 black, node 3 white, node 2 black\\n--> the graph is bicolourable --> the graph is bipartite --> return true"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The graph is bipartite because the nodes can be partitioned into two sets {0,3} and {1,2}. At this point, we have successfully partitioned all the nodes into two independent sets, and every edge in the graph connects a node from Set A to a node from Set B. No two vertices in the same set are connected by an edge, so the graph is bipartite.\n\n[0] - [1] - [3] - [2]"
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "One thing to mention that the test cases also considers the case where the graph is divided into components so keep in mind to iterate over the BFS or DFS algo to make sure you dont leave any component unchecked ..... dont worry about TLE it wont happen LOL"
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "I KNOW ITS NOT GOOD PLATFORM TO ASK BUT ANY GOOD ANIME RECOMMENDATION THAT COULD HELP ME RELIEVE MY STRESS.... THANKS IN ADVANCE"
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "Naruto"
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "One Piece"
                    },
                    {
                        "username": "charonme",
                        "content": "one punch man"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Kamisama kiss, ichigo mashimaro"
                    }
                ]
            },
            {
                "id": 1573813,
                "content": [
                    {
                        "username": "andrewlaack1",
                        "content": "Honest question, has anyone ever had an interview where they were asked a graph theory question?"
                    },
                    {
                        "username": "who_rules",
                        "content": "Asked at FAANG company"
                    },
                    {
                        "username": "jbreefer",
                        "content": "Absolutely yes. Less common than path finding or greedy but still, definitely yes"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "Many times!"
                    },
                    {
                        "username": "asim35",
                        "content": "yes, i was asked courses and prerequisite question, that is solved using graph colouring"
                    },
                    {
                        "username": "anwendeng",
                        "content": "DFS recursion solution is more easy than other. In fact, it is to solve the graph coloring problem!!BFS solution is doable, and even faster"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/is-graph-bipartite/solutions/3540461/easy-c-dfs-solution/"
                    },
                    {
                        "username": "meow_power",
                        "content": "Equivalent definitions of a bipartite graph:\\n1) There is no cycle of odd length\\n\\n2) we can split the nodes of the graph\\n(vertex set of the graph) into 2 subsets so\\nthat there is all the edges go from 1 subset\\nto the other subset.\\n\\n3.The graph should be bi-colourable.\\n\\f"
                    },
                    {
                        "username": "intodust",
                        "content": "graph[i] will contain integers in range [0, graph.length - 1].\\nShould be\\ngraph[i] will contain NULL or integers in range[0, graph.length -1]\\n\\n"
                    },
                    {
                        "username": "stefancristianco",
                        "content": "Bipartite graph solved via a \"graph coloring algorithm\" works best with non directed graphs. This being a directed graph you need to transform it into a non directed graph before you call bfs/dfs.\\n\\nFor example. The validation algortihm returns \"false\" for the following case, I believe the answer should be \"true\".\\nInput: [[1,2],[],[],[1,2],[3]]\\nOutput: false\\n\\nBut should be true because we can split the nodes as follows:\\n{0,3}, {1,2,4}"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "First of all tell me how come 0 is connected to 1 and 2 but both of them are not connected to 0 as per your test case  [[1,2],[],[],[1,2],[3]]"
                    },
                    {
                        "username": "AnkurHaritosh",
                        "content": "Hey everyone, the Leetcode community has helped me a lot. I am preparing for interviews and filming my explanations. Hope this helps out someone: https://youtu.be/8eHAqJVdd0c"
                    },
                    {
                        "username": "charonme",
                        "content": "note that an empty graph [[],[],[],[],[]] is bipartite too"
                    },
                    {
                        "username": "rishichowdhury711",
                        "content": "can anyone help me as to how\\n[[1],[0,3],[3],[1,2]] is  bipartite graph in the context of this question. I think it is not because there is no edge between 0 and 2 . Therefore it should not be a bipartite graph"
                    },
                    {
                        "username": "Diyo",
                        "content": "should be quite simple if you draw it.\\n-node 0 is connected to node 1 [1]\\n-node 1 is connected to node 0 and 3 [0,3]\\n-node 2 is connected to node 3 [3]\\n-node 3 is connected to node 1 and 2 [1,2]\\nyou get the following graph:\\n1-----0\\n|\\n|\\n3-----2\\nyou can colour node 0 white, node 1 black, node 3 white, node 2 black\\n--> the graph is bicolourable --> the graph is bipartite --> return true"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The graph is bipartite because the nodes can be partitioned into two sets {0,3} and {1,2}. At this point, we have successfully partitioned all the nodes into two independent sets, and every edge in the graph connects a node from Set A to a node from Set B. No two vertices in the same set are connected by an edge, so the graph is bipartite.\n\n[0] - [1] - [3] - [2]"
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "One thing to mention that the test cases also considers the case where the graph is divided into components so keep in mind to iterate over the BFS or DFS algo to make sure you dont leave any component unchecked ..... dont worry about TLE it wont happen LOL"
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "I KNOW ITS NOT GOOD PLATFORM TO ASK BUT ANY GOOD ANIME RECOMMENDATION THAT COULD HELP ME RELIEVE MY STRESS.... THANKS IN ADVANCE"
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "Naruto"
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "One Piece"
                    },
                    {
                        "username": "charonme",
                        "content": "one punch man"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Kamisama kiss, ichigo mashimaro"
                    }
                ]
            },
            {
                "id": 1574970,
                "content": [
                    {
                        "username": "andrewlaack1",
                        "content": "Honest question, has anyone ever had an interview where they were asked a graph theory question?"
                    },
                    {
                        "username": "who_rules",
                        "content": "Asked at FAANG company"
                    },
                    {
                        "username": "jbreefer",
                        "content": "Absolutely yes. Less common than path finding or greedy but still, definitely yes"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "Many times!"
                    },
                    {
                        "username": "asim35",
                        "content": "yes, i was asked courses and prerequisite question, that is solved using graph colouring"
                    },
                    {
                        "username": "anwendeng",
                        "content": "DFS recursion solution is more easy than other. In fact, it is to solve the graph coloring problem!!BFS solution is doable, and even faster"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/is-graph-bipartite/solutions/3540461/easy-c-dfs-solution/"
                    },
                    {
                        "username": "meow_power",
                        "content": "Equivalent definitions of a bipartite graph:\\n1) There is no cycle of odd length\\n\\n2) we can split the nodes of the graph\\n(vertex set of the graph) into 2 subsets so\\nthat there is all the edges go from 1 subset\\nto the other subset.\\n\\n3.The graph should be bi-colourable.\\n\\f"
                    },
                    {
                        "username": "intodust",
                        "content": "graph[i] will contain integers in range [0, graph.length - 1].\\nShould be\\ngraph[i] will contain NULL or integers in range[0, graph.length -1]\\n\\n"
                    },
                    {
                        "username": "stefancristianco",
                        "content": "Bipartite graph solved via a \"graph coloring algorithm\" works best with non directed graphs. This being a directed graph you need to transform it into a non directed graph before you call bfs/dfs.\\n\\nFor example. The validation algortihm returns \"false\" for the following case, I believe the answer should be \"true\".\\nInput: [[1,2],[],[],[1,2],[3]]\\nOutput: false\\n\\nBut should be true because we can split the nodes as follows:\\n{0,3}, {1,2,4}"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "First of all tell me how come 0 is connected to 1 and 2 but both of them are not connected to 0 as per your test case  [[1,2],[],[],[1,2],[3]]"
                    },
                    {
                        "username": "AnkurHaritosh",
                        "content": "Hey everyone, the Leetcode community has helped me a lot. I am preparing for interviews and filming my explanations. Hope this helps out someone: https://youtu.be/8eHAqJVdd0c"
                    },
                    {
                        "username": "charonme",
                        "content": "note that an empty graph [[],[],[],[],[]] is bipartite too"
                    },
                    {
                        "username": "rishichowdhury711",
                        "content": "can anyone help me as to how\\n[[1],[0,3],[3],[1,2]] is  bipartite graph in the context of this question. I think it is not because there is no edge between 0 and 2 . Therefore it should not be a bipartite graph"
                    },
                    {
                        "username": "Diyo",
                        "content": "should be quite simple if you draw it.\\n-node 0 is connected to node 1 [1]\\n-node 1 is connected to node 0 and 3 [0,3]\\n-node 2 is connected to node 3 [3]\\n-node 3 is connected to node 1 and 2 [1,2]\\nyou get the following graph:\\n1-----0\\n|\\n|\\n3-----2\\nyou can colour node 0 white, node 1 black, node 3 white, node 2 black\\n--> the graph is bicolourable --> the graph is bipartite --> return true"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The graph is bipartite because the nodes can be partitioned into two sets {0,3} and {1,2}. At this point, we have successfully partitioned all the nodes into two independent sets, and every edge in the graph connects a node from Set A to a node from Set B. No two vertices in the same set are connected by an edge, so the graph is bipartite.\n\n[0] - [1] - [3] - [2]"
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "One thing to mention that the test cases also considers the case where the graph is divided into components so keep in mind to iterate over the BFS or DFS algo to make sure you dont leave any component unchecked ..... dont worry about TLE it wont happen LOL"
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "I KNOW ITS NOT GOOD PLATFORM TO ASK BUT ANY GOOD ANIME RECOMMENDATION THAT COULD HELP ME RELIEVE MY STRESS.... THANKS IN ADVANCE"
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "Naruto"
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "One Piece"
                    },
                    {
                        "username": "charonme",
                        "content": "one punch man"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Kamisama kiss, ichigo mashimaro"
                    }
                ]
            },
            {
                "id": 1899045,
                "content": [
                    {
                        "username": "andrewlaack1",
                        "content": "Honest question, has anyone ever had an interview where they were asked a graph theory question?"
                    },
                    {
                        "username": "who_rules",
                        "content": "Asked at FAANG company"
                    },
                    {
                        "username": "jbreefer",
                        "content": "Absolutely yes. Less common than path finding or greedy but still, definitely yes"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "Many times!"
                    },
                    {
                        "username": "asim35",
                        "content": "yes, i was asked courses and prerequisite question, that is solved using graph colouring"
                    },
                    {
                        "username": "anwendeng",
                        "content": "DFS recursion solution is more easy than other. In fact, it is to solve the graph coloring problem!!BFS solution is doable, and even faster"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/is-graph-bipartite/solutions/3540461/easy-c-dfs-solution/"
                    },
                    {
                        "username": "meow_power",
                        "content": "Equivalent definitions of a bipartite graph:\\n1) There is no cycle of odd length\\n\\n2) we can split the nodes of the graph\\n(vertex set of the graph) into 2 subsets so\\nthat there is all the edges go from 1 subset\\nto the other subset.\\n\\n3.The graph should be bi-colourable.\\n\\f"
                    },
                    {
                        "username": "intodust",
                        "content": "graph[i] will contain integers in range [0, graph.length - 1].\\nShould be\\ngraph[i] will contain NULL or integers in range[0, graph.length -1]\\n\\n"
                    },
                    {
                        "username": "stefancristianco",
                        "content": "Bipartite graph solved via a \"graph coloring algorithm\" works best with non directed graphs. This being a directed graph you need to transform it into a non directed graph before you call bfs/dfs.\\n\\nFor example. The validation algortihm returns \"false\" for the following case, I believe the answer should be \"true\".\\nInput: [[1,2],[],[],[1,2],[3]]\\nOutput: false\\n\\nBut should be true because we can split the nodes as follows:\\n{0,3}, {1,2,4}"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "First of all tell me how come 0 is connected to 1 and 2 but both of them are not connected to 0 as per your test case  [[1,2],[],[],[1,2],[3]]"
                    },
                    {
                        "username": "AnkurHaritosh",
                        "content": "Hey everyone, the Leetcode community has helped me a lot. I am preparing for interviews and filming my explanations. Hope this helps out someone: https://youtu.be/8eHAqJVdd0c"
                    },
                    {
                        "username": "charonme",
                        "content": "note that an empty graph [[],[],[],[],[]] is bipartite too"
                    },
                    {
                        "username": "rishichowdhury711",
                        "content": "can anyone help me as to how\\n[[1],[0,3],[3],[1,2]] is  bipartite graph in the context of this question. I think it is not because there is no edge between 0 and 2 . Therefore it should not be a bipartite graph"
                    },
                    {
                        "username": "Diyo",
                        "content": "should be quite simple if you draw it.\\n-node 0 is connected to node 1 [1]\\n-node 1 is connected to node 0 and 3 [0,3]\\n-node 2 is connected to node 3 [3]\\n-node 3 is connected to node 1 and 2 [1,2]\\nyou get the following graph:\\n1-----0\\n|\\n|\\n3-----2\\nyou can colour node 0 white, node 1 black, node 3 white, node 2 black\\n--> the graph is bicolourable --> the graph is bipartite --> return true"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The graph is bipartite because the nodes can be partitioned into two sets {0,3} and {1,2}. At this point, we have successfully partitioned all the nodes into two independent sets, and every edge in the graph connects a node from Set A to a node from Set B. No two vertices in the same set are connected by an edge, so the graph is bipartite.\n\n[0] - [1] - [3] - [2]"
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "One thing to mention that the test cases also considers the case where the graph is divided into components so keep in mind to iterate over the BFS or DFS algo to make sure you dont leave any component unchecked ..... dont worry about TLE it wont happen LOL"
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "I KNOW ITS NOT GOOD PLATFORM TO ASK BUT ANY GOOD ANIME RECOMMENDATION THAT COULD HELP ME RELIEVE MY STRESS.... THANKS IN ADVANCE"
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "Naruto"
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "One Piece"
                    },
                    {
                        "username": "charonme",
                        "content": "one punch man"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Kamisama kiss, ichigo mashimaro"
                    }
                ]
            },
            {
                "id": 1898762,
                "content": [
                    {
                        "username": "andrewlaack1",
                        "content": "Honest question, has anyone ever had an interview where they were asked a graph theory question?"
                    },
                    {
                        "username": "who_rules",
                        "content": "Asked at FAANG company"
                    },
                    {
                        "username": "jbreefer",
                        "content": "Absolutely yes. Less common than path finding or greedy but still, definitely yes"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "Many times!"
                    },
                    {
                        "username": "asim35",
                        "content": "yes, i was asked courses and prerequisite question, that is solved using graph colouring"
                    },
                    {
                        "username": "anwendeng",
                        "content": "DFS recursion solution is more easy than other. In fact, it is to solve the graph coloring problem!!BFS solution is doable, and even faster"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/is-graph-bipartite/solutions/3540461/easy-c-dfs-solution/"
                    },
                    {
                        "username": "meow_power",
                        "content": "Equivalent definitions of a bipartite graph:\\n1) There is no cycle of odd length\\n\\n2) we can split the nodes of the graph\\n(vertex set of the graph) into 2 subsets so\\nthat there is all the edges go from 1 subset\\nto the other subset.\\n\\n3.The graph should be bi-colourable.\\n\\f"
                    },
                    {
                        "username": "intodust",
                        "content": "graph[i] will contain integers in range [0, graph.length - 1].\\nShould be\\ngraph[i] will contain NULL or integers in range[0, graph.length -1]\\n\\n"
                    },
                    {
                        "username": "stefancristianco",
                        "content": "Bipartite graph solved via a \"graph coloring algorithm\" works best with non directed graphs. This being a directed graph you need to transform it into a non directed graph before you call bfs/dfs.\\n\\nFor example. The validation algortihm returns \"false\" for the following case, I believe the answer should be \"true\".\\nInput: [[1,2],[],[],[1,2],[3]]\\nOutput: false\\n\\nBut should be true because we can split the nodes as follows:\\n{0,3}, {1,2,4}"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "First of all tell me how come 0 is connected to 1 and 2 but both of them are not connected to 0 as per your test case  [[1,2],[],[],[1,2],[3]]"
                    },
                    {
                        "username": "AnkurHaritosh",
                        "content": "Hey everyone, the Leetcode community has helped me a lot. I am preparing for interviews and filming my explanations. Hope this helps out someone: https://youtu.be/8eHAqJVdd0c"
                    },
                    {
                        "username": "charonme",
                        "content": "note that an empty graph [[],[],[],[],[]] is bipartite too"
                    },
                    {
                        "username": "rishichowdhury711",
                        "content": "can anyone help me as to how\\n[[1],[0,3],[3],[1,2]] is  bipartite graph in the context of this question. I think it is not because there is no edge between 0 and 2 . Therefore it should not be a bipartite graph"
                    },
                    {
                        "username": "Diyo",
                        "content": "should be quite simple if you draw it.\\n-node 0 is connected to node 1 [1]\\n-node 1 is connected to node 0 and 3 [0,3]\\n-node 2 is connected to node 3 [3]\\n-node 3 is connected to node 1 and 2 [1,2]\\nyou get the following graph:\\n1-----0\\n|\\n|\\n3-----2\\nyou can colour node 0 white, node 1 black, node 3 white, node 2 black\\n--> the graph is bicolourable --> the graph is bipartite --> return true"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The graph is bipartite because the nodes can be partitioned into two sets {0,3} and {1,2}. At this point, we have successfully partitioned all the nodes into two independent sets, and every edge in the graph connects a node from Set A to a node from Set B. No two vertices in the same set are connected by an edge, so the graph is bipartite.\n\n[0] - [1] - [3] - [2]"
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "One thing to mention that the test cases also considers the case where the graph is divided into components so keep in mind to iterate over the BFS or DFS algo to make sure you dont leave any component unchecked ..... dont worry about TLE it wont happen LOL"
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "I KNOW ITS NOT GOOD PLATFORM TO ASK BUT ANY GOOD ANIME RECOMMENDATION THAT COULD HELP ME RELIEVE MY STRESS.... THANKS IN ADVANCE"
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "Naruto"
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "One Piece"
                    },
                    {
                        "username": "charonme",
                        "content": "one punch man"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Kamisama kiss, ichigo mashimaro"
                    }
                ]
            },
            {
                "id": 1795908,
                "content": [
                    {
                        "username": "andrewlaack1",
                        "content": "Honest question, has anyone ever had an interview where they were asked a graph theory question?"
                    },
                    {
                        "username": "who_rules",
                        "content": "Asked at FAANG company"
                    },
                    {
                        "username": "jbreefer",
                        "content": "Absolutely yes. Less common than path finding or greedy but still, definitely yes"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "Many times!"
                    },
                    {
                        "username": "asim35",
                        "content": "yes, i was asked courses and prerequisite question, that is solved using graph colouring"
                    },
                    {
                        "username": "anwendeng",
                        "content": "DFS recursion solution is more easy than other. In fact, it is to solve the graph coloring problem!!BFS solution is doable, and even faster"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/is-graph-bipartite/solutions/3540461/easy-c-dfs-solution/"
                    },
                    {
                        "username": "meow_power",
                        "content": "Equivalent definitions of a bipartite graph:\\n1) There is no cycle of odd length\\n\\n2) we can split the nodes of the graph\\n(vertex set of the graph) into 2 subsets so\\nthat there is all the edges go from 1 subset\\nto the other subset.\\n\\n3.The graph should be bi-colourable.\\n\\f"
                    },
                    {
                        "username": "intodust",
                        "content": "graph[i] will contain integers in range [0, graph.length - 1].\\nShould be\\ngraph[i] will contain NULL or integers in range[0, graph.length -1]\\n\\n"
                    },
                    {
                        "username": "stefancristianco",
                        "content": "Bipartite graph solved via a \"graph coloring algorithm\" works best with non directed graphs. This being a directed graph you need to transform it into a non directed graph before you call bfs/dfs.\\n\\nFor example. The validation algortihm returns \"false\" for the following case, I believe the answer should be \"true\".\\nInput: [[1,2],[],[],[1,2],[3]]\\nOutput: false\\n\\nBut should be true because we can split the nodes as follows:\\n{0,3}, {1,2,4}"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "First of all tell me how come 0 is connected to 1 and 2 but both of them are not connected to 0 as per your test case  [[1,2],[],[],[1,2],[3]]"
                    },
                    {
                        "username": "AnkurHaritosh",
                        "content": "Hey everyone, the Leetcode community has helped me a lot. I am preparing for interviews and filming my explanations. Hope this helps out someone: https://youtu.be/8eHAqJVdd0c"
                    },
                    {
                        "username": "charonme",
                        "content": "note that an empty graph [[],[],[],[],[]] is bipartite too"
                    },
                    {
                        "username": "rishichowdhury711",
                        "content": "can anyone help me as to how\\n[[1],[0,3],[3],[1,2]] is  bipartite graph in the context of this question. I think it is not because there is no edge between 0 and 2 . Therefore it should not be a bipartite graph"
                    },
                    {
                        "username": "Diyo",
                        "content": "should be quite simple if you draw it.\\n-node 0 is connected to node 1 [1]\\n-node 1 is connected to node 0 and 3 [0,3]\\n-node 2 is connected to node 3 [3]\\n-node 3 is connected to node 1 and 2 [1,2]\\nyou get the following graph:\\n1-----0\\n|\\n|\\n3-----2\\nyou can colour node 0 white, node 1 black, node 3 white, node 2 black\\n--> the graph is bicolourable --> the graph is bipartite --> return true"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The graph is bipartite because the nodes can be partitioned into two sets {0,3} and {1,2}. At this point, we have successfully partitioned all the nodes into two independent sets, and every edge in the graph connects a node from Set A to a node from Set B. No two vertices in the same set are connected by an edge, so the graph is bipartite.\n\n[0] - [1] - [3] - [2]"
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "One thing to mention that the test cases also considers the case where the graph is divided into components so keep in mind to iterate over the BFS or DFS algo to make sure you dont leave any component unchecked ..... dont worry about TLE it wont happen LOL"
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "I KNOW ITS NOT GOOD PLATFORM TO ASK BUT ANY GOOD ANIME RECOMMENDATION THAT COULD HELP ME RELIEVE MY STRESS.... THANKS IN ADVANCE"
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "Naruto"
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "One Piece"
                    },
                    {
                        "username": "charonme",
                        "content": "one punch man"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Kamisama kiss, ichigo mashimaro"
                    }
                ]
            },
            {
                "id": 1795910,
                "content": [
                    {
                        "username": "andrewlaack1",
                        "content": "Honest question, has anyone ever had an interview where they were asked a graph theory question?"
                    },
                    {
                        "username": "who_rules",
                        "content": "Asked at FAANG company"
                    },
                    {
                        "username": "jbreefer",
                        "content": "Absolutely yes. Less common than path finding or greedy but still, definitely yes"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "Many times!"
                    },
                    {
                        "username": "asim35",
                        "content": "yes, i was asked courses and prerequisite question, that is solved using graph colouring"
                    },
                    {
                        "username": "anwendeng",
                        "content": "DFS recursion solution is more easy than other. In fact, it is to solve the graph coloring problem!!BFS solution is doable, and even faster"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/is-graph-bipartite/solutions/3540461/easy-c-dfs-solution/"
                    },
                    {
                        "username": "meow_power",
                        "content": "Equivalent definitions of a bipartite graph:\\n1) There is no cycle of odd length\\n\\n2) we can split the nodes of the graph\\n(vertex set of the graph) into 2 subsets so\\nthat there is all the edges go from 1 subset\\nto the other subset.\\n\\n3.The graph should be bi-colourable.\\n\\f"
                    },
                    {
                        "username": "intodust",
                        "content": "graph[i] will contain integers in range [0, graph.length - 1].\\nShould be\\ngraph[i] will contain NULL or integers in range[0, graph.length -1]\\n\\n"
                    },
                    {
                        "username": "stefancristianco",
                        "content": "Bipartite graph solved via a \"graph coloring algorithm\" works best with non directed graphs. This being a directed graph you need to transform it into a non directed graph before you call bfs/dfs.\\n\\nFor example. The validation algortihm returns \"false\" for the following case, I believe the answer should be \"true\".\\nInput: [[1,2],[],[],[1,2],[3]]\\nOutput: false\\n\\nBut should be true because we can split the nodes as follows:\\n{0,3}, {1,2,4}"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "First of all tell me how come 0 is connected to 1 and 2 but both of them are not connected to 0 as per your test case  [[1,2],[],[],[1,2],[3]]"
                    },
                    {
                        "username": "AnkurHaritosh",
                        "content": "Hey everyone, the Leetcode community has helped me a lot. I am preparing for interviews and filming my explanations. Hope this helps out someone: https://youtu.be/8eHAqJVdd0c"
                    },
                    {
                        "username": "charonme",
                        "content": "note that an empty graph [[],[],[],[],[]] is bipartite too"
                    },
                    {
                        "username": "rishichowdhury711",
                        "content": "can anyone help me as to how\\n[[1],[0,3],[3],[1,2]] is  bipartite graph in the context of this question. I think it is not because there is no edge between 0 and 2 . Therefore it should not be a bipartite graph"
                    },
                    {
                        "username": "Diyo",
                        "content": "should be quite simple if you draw it.\\n-node 0 is connected to node 1 [1]\\n-node 1 is connected to node 0 and 3 [0,3]\\n-node 2 is connected to node 3 [3]\\n-node 3 is connected to node 1 and 2 [1,2]\\nyou get the following graph:\\n1-----0\\n|\\n|\\n3-----2\\nyou can colour node 0 white, node 1 black, node 3 white, node 2 black\\n--> the graph is bicolourable --> the graph is bipartite --> return true"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The graph is bipartite because the nodes can be partitioned into two sets {0,3} and {1,2}. At this point, we have successfully partitioned all the nodes into two independent sets, and every edge in the graph connects a node from Set A to a node from Set B. No two vertices in the same set are connected by an edge, so the graph is bipartite.\n\n[0] - [1] - [3] - [2]"
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "One thing to mention that the test cases also considers the case where the graph is divided into components so keep in mind to iterate over the BFS or DFS algo to make sure you dont leave any component unchecked ..... dont worry about TLE it wont happen LOL"
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "I KNOW ITS NOT GOOD PLATFORM TO ASK BUT ANY GOOD ANIME RECOMMENDATION THAT COULD HELP ME RELIEVE MY STRESS.... THANKS IN ADVANCE"
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "Naruto"
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "One Piece"
                    },
                    {
                        "username": "charonme",
                        "content": "one punch man"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "Kamisama kiss, ichigo mashimaro"
                    }
                ]
            },
            {
                "id": 2023448,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "can anyone help find the mistake in this code\\nint size=graph.size();\\n        vector<int> color(size,-1);\\n        queue<int> qp;\\n        color[0]=0;\\n        qp.push(0);\\n        while(!qp.empty()){\\n                int node=qp.front();\\n                qp.pop();\\n                for(auto it:graph[node]){\\n                    if(color[it]==-1){\\n                        color[it]=!color[node];\\n                        qp.push(it);\\n                    }\\n                    else{\\n                        if(color[it]==color[node]);\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;"
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "The good description can be -- color the graph with 2 colors such that no adjacent nodes have same color."
                    },
                    {
                        "username": "SG-C",
                        "content": "logic is easy but code is not \\uD83D\\uDE12"
                    },
                    {
                        "username": "user8199lj",
                        "content": "Here I was trying to get the best runtime, then when I saw the solution I just gave up on humanity!\\nPro tip : Get your submission in and look at the best result.\\nCertainly made my day.  "
                    },
                    {
                        "username": "shfnet",
                        "content": "How is it possible for a graph with a node that doesn\\'t have any edges to be bipartite? If this node is placed in one side, than it cannot be connected to any node on the other side. This breaks the requirement that each node in one side has to connect to some node on the other side. So, am I missing something? Thanks in advance.\\ne.g. see test case 62 / 81:  `[[],[3],[],[1],[]]`\\nThe empty sub arrays `[]` represent nodes that don\\'t have edges. These nodes cannot connect to nodes on the other side. Therefor the graph cannot be bipartite, and yet, this test case expects a `true` result."
                    },
                    {
                        "username": "shfnet",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thanks."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "A graph is bipartite if you can partition its nodes into two distinct sets so that no edge connect two nodes from the same set.\\nAn extreme case is a graph without any edges. It is bipartite because there are no edges connecting two nodes from the same set.\\nThe explanation on [Wikipedia](https://en.wikipedia.org/wiki/Bipartite_graph) might be a little bit easier to understand."
                    },
                    {
                        "username": "Sid_2027",
                        "content": "A bipartite graph consists of nodes that can be divided into two groups, each represented by a different color. The key characteristic of a bipartite graph is that there are no connections between nodes of the same color. To determine if a graph is bipartite, we can apply a coloring algorithm starting from an initial node. We assign one color to the starting node, another color to its neighbors, and continue this process for subsequent neighbors. If at any point we encounter adjacent nodes with the same color, the graph is not bipartite. Otherwise, if we successfully color all the nodes without conflicts, the graph is bipartite. This check can be performed using various graph traversal algorithms.\\nI used DFS it was quite easy to implement."
                    },
                    {
                        "username": "Amitayus",
                        "content": "I found the casual definition of bipartite not very explicit, \"independent\" here is a hard definition that means none of the nodes in the set share an edge.  Bipartite   \nbasically means that you can divide the nodes into two sets, A and B, where each node in A does not connect to other nodes in set A, and each node in A has a connection to a node in B, and vice-versa."
                    },
                    {
                        "username": "inforajsoni",
                        "content": "can anybody tell me ? what is error in this code?    https://leetcode.com/problems/is-graph-bipartite/submissions/953528808/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "In this exercise the parameter `graph` is already an adjacency list.\n`graph[node1]` is a `std::vector` of all direct neighbors of `node1`."
                    },
                    {
                        "username": "conquer",
                        "content": "The below definition is wrong, not every edge in the graph... every node in set A connect to a node in set B.\\n\\nA graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": " This problem is a lite version of Problem No. 886, Possible Bipartition.\n"
                    }
                ]
            },
            {
                "id": 1984133,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "can anyone help find the mistake in this code\\nint size=graph.size();\\n        vector<int> color(size,-1);\\n        queue<int> qp;\\n        color[0]=0;\\n        qp.push(0);\\n        while(!qp.empty()){\\n                int node=qp.front();\\n                qp.pop();\\n                for(auto it:graph[node]){\\n                    if(color[it]==-1){\\n                        color[it]=!color[node];\\n                        qp.push(it);\\n                    }\\n                    else{\\n                        if(color[it]==color[node]);\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;"
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "The good description can be -- color the graph with 2 colors such that no adjacent nodes have same color."
                    },
                    {
                        "username": "SG-C",
                        "content": "logic is easy but code is not \\uD83D\\uDE12"
                    },
                    {
                        "username": "user8199lj",
                        "content": "Here I was trying to get the best runtime, then when I saw the solution I just gave up on humanity!\\nPro tip : Get your submission in and look at the best result.\\nCertainly made my day.  "
                    },
                    {
                        "username": "shfnet",
                        "content": "How is it possible for a graph with a node that doesn\\'t have any edges to be bipartite? If this node is placed in one side, than it cannot be connected to any node on the other side. This breaks the requirement that each node in one side has to connect to some node on the other side. So, am I missing something? Thanks in advance.\\ne.g. see test case 62 / 81:  `[[],[3],[],[1],[]]`\\nThe empty sub arrays `[]` represent nodes that don\\'t have edges. These nodes cannot connect to nodes on the other side. Therefor the graph cannot be bipartite, and yet, this test case expects a `true` result."
                    },
                    {
                        "username": "shfnet",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thanks."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "A graph is bipartite if you can partition its nodes into two distinct sets so that no edge connect two nodes from the same set.\\nAn extreme case is a graph without any edges. It is bipartite because there are no edges connecting two nodes from the same set.\\nThe explanation on [Wikipedia](https://en.wikipedia.org/wiki/Bipartite_graph) might be a little bit easier to understand."
                    },
                    {
                        "username": "Sid_2027",
                        "content": "A bipartite graph consists of nodes that can be divided into two groups, each represented by a different color. The key characteristic of a bipartite graph is that there are no connections between nodes of the same color. To determine if a graph is bipartite, we can apply a coloring algorithm starting from an initial node. We assign one color to the starting node, another color to its neighbors, and continue this process for subsequent neighbors. If at any point we encounter adjacent nodes with the same color, the graph is not bipartite. Otherwise, if we successfully color all the nodes without conflicts, the graph is bipartite. This check can be performed using various graph traversal algorithms.\\nI used DFS it was quite easy to implement."
                    },
                    {
                        "username": "Amitayus",
                        "content": "I found the casual definition of bipartite not very explicit, \"independent\" here is a hard definition that means none of the nodes in the set share an edge.  Bipartite   \nbasically means that you can divide the nodes into two sets, A and B, where each node in A does not connect to other nodes in set A, and each node in A has a connection to a node in B, and vice-versa."
                    },
                    {
                        "username": "inforajsoni",
                        "content": "can anybody tell me ? what is error in this code?    https://leetcode.com/problems/is-graph-bipartite/submissions/953528808/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "In this exercise the parameter `graph` is already an adjacency list.\n`graph[node1]` is a `std::vector` of all direct neighbors of `node1`."
                    },
                    {
                        "username": "conquer",
                        "content": "The below definition is wrong, not every edge in the graph... every node in set A connect to a node in set B.\\n\\nA graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": " This problem is a lite version of Problem No. 886, Possible Bipartition.\n"
                    }
                ]
            },
            {
                "id": 1957532,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "can anyone help find the mistake in this code\\nint size=graph.size();\\n        vector<int> color(size,-1);\\n        queue<int> qp;\\n        color[0]=0;\\n        qp.push(0);\\n        while(!qp.empty()){\\n                int node=qp.front();\\n                qp.pop();\\n                for(auto it:graph[node]){\\n                    if(color[it]==-1){\\n                        color[it]=!color[node];\\n                        qp.push(it);\\n                    }\\n                    else{\\n                        if(color[it]==color[node]);\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;"
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "The good description can be -- color the graph with 2 colors such that no adjacent nodes have same color."
                    },
                    {
                        "username": "SG-C",
                        "content": "logic is easy but code is not \\uD83D\\uDE12"
                    },
                    {
                        "username": "user8199lj",
                        "content": "Here I was trying to get the best runtime, then when I saw the solution I just gave up on humanity!\\nPro tip : Get your submission in and look at the best result.\\nCertainly made my day.  "
                    },
                    {
                        "username": "shfnet",
                        "content": "How is it possible for a graph with a node that doesn\\'t have any edges to be bipartite? If this node is placed in one side, than it cannot be connected to any node on the other side. This breaks the requirement that each node in one side has to connect to some node on the other side. So, am I missing something? Thanks in advance.\\ne.g. see test case 62 / 81:  `[[],[3],[],[1],[]]`\\nThe empty sub arrays `[]` represent nodes that don\\'t have edges. These nodes cannot connect to nodes on the other side. Therefor the graph cannot be bipartite, and yet, this test case expects a `true` result."
                    },
                    {
                        "username": "shfnet",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thanks."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "A graph is bipartite if you can partition its nodes into two distinct sets so that no edge connect two nodes from the same set.\\nAn extreme case is a graph without any edges. It is bipartite because there are no edges connecting two nodes from the same set.\\nThe explanation on [Wikipedia](https://en.wikipedia.org/wiki/Bipartite_graph) might be a little bit easier to understand."
                    },
                    {
                        "username": "Sid_2027",
                        "content": "A bipartite graph consists of nodes that can be divided into two groups, each represented by a different color. The key characteristic of a bipartite graph is that there are no connections between nodes of the same color. To determine if a graph is bipartite, we can apply a coloring algorithm starting from an initial node. We assign one color to the starting node, another color to its neighbors, and continue this process for subsequent neighbors. If at any point we encounter adjacent nodes with the same color, the graph is not bipartite. Otherwise, if we successfully color all the nodes without conflicts, the graph is bipartite. This check can be performed using various graph traversal algorithms.\\nI used DFS it was quite easy to implement."
                    },
                    {
                        "username": "Amitayus",
                        "content": "I found the casual definition of bipartite not very explicit, \"independent\" here is a hard definition that means none of the nodes in the set share an edge.  Bipartite   \nbasically means that you can divide the nodes into two sets, A and B, where each node in A does not connect to other nodes in set A, and each node in A has a connection to a node in B, and vice-versa."
                    },
                    {
                        "username": "inforajsoni",
                        "content": "can anybody tell me ? what is error in this code?    https://leetcode.com/problems/is-graph-bipartite/submissions/953528808/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "In this exercise the parameter `graph` is already an adjacency list.\n`graph[node1]` is a `std::vector` of all direct neighbors of `node1`."
                    },
                    {
                        "username": "conquer",
                        "content": "The below definition is wrong, not every edge in the graph... every node in set A connect to a node in set B.\\n\\nA graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": " This problem is a lite version of Problem No. 886, Possible Bipartition.\n"
                    }
                ]
            },
            {
                "id": 1954240,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "can anyone help find the mistake in this code\\nint size=graph.size();\\n        vector<int> color(size,-1);\\n        queue<int> qp;\\n        color[0]=0;\\n        qp.push(0);\\n        while(!qp.empty()){\\n                int node=qp.front();\\n                qp.pop();\\n                for(auto it:graph[node]){\\n                    if(color[it]==-1){\\n                        color[it]=!color[node];\\n                        qp.push(it);\\n                    }\\n                    else{\\n                        if(color[it]==color[node]);\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;"
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "The good description can be -- color the graph with 2 colors such that no adjacent nodes have same color."
                    },
                    {
                        "username": "SG-C",
                        "content": "logic is easy but code is not \\uD83D\\uDE12"
                    },
                    {
                        "username": "user8199lj",
                        "content": "Here I was trying to get the best runtime, then when I saw the solution I just gave up on humanity!\\nPro tip : Get your submission in and look at the best result.\\nCertainly made my day.  "
                    },
                    {
                        "username": "shfnet",
                        "content": "How is it possible for a graph with a node that doesn\\'t have any edges to be bipartite? If this node is placed in one side, than it cannot be connected to any node on the other side. This breaks the requirement that each node in one side has to connect to some node on the other side. So, am I missing something? Thanks in advance.\\ne.g. see test case 62 / 81:  `[[],[3],[],[1],[]]`\\nThe empty sub arrays `[]` represent nodes that don\\'t have edges. These nodes cannot connect to nodes on the other side. Therefor the graph cannot be bipartite, and yet, this test case expects a `true` result."
                    },
                    {
                        "username": "shfnet",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thanks."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "A graph is bipartite if you can partition its nodes into two distinct sets so that no edge connect two nodes from the same set.\\nAn extreme case is a graph without any edges. It is bipartite because there are no edges connecting two nodes from the same set.\\nThe explanation on [Wikipedia](https://en.wikipedia.org/wiki/Bipartite_graph) might be a little bit easier to understand."
                    },
                    {
                        "username": "Sid_2027",
                        "content": "A bipartite graph consists of nodes that can be divided into two groups, each represented by a different color. The key characteristic of a bipartite graph is that there are no connections between nodes of the same color. To determine if a graph is bipartite, we can apply a coloring algorithm starting from an initial node. We assign one color to the starting node, another color to its neighbors, and continue this process for subsequent neighbors. If at any point we encounter adjacent nodes with the same color, the graph is not bipartite. Otherwise, if we successfully color all the nodes without conflicts, the graph is bipartite. This check can be performed using various graph traversal algorithms.\\nI used DFS it was quite easy to implement."
                    },
                    {
                        "username": "Amitayus",
                        "content": "I found the casual definition of bipartite not very explicit, \"independent\" here is a hard definition that means none of the nodes in the set share an edge.  Bipartite   \nbasically means that you can divide the nodes into two sets, A and B, where each node in A does not connect to other nodes in set A, and each node in A has a connection to a node in B, and vice-versa."
                    },
                    {
                        "username": "inforajsoni",
                        "content": "can anybody tell me ? what is error in this code?    https://leetcode.com/problems/is-graph-bipartite/submissions/953528808/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "In this exercise the parameter `graph` is already an adjacency list.\n`graph[node1]` is a `std::vector` of all direct neighbors of `node1`."
                    },
                    {
                        "username": "conquer",
                        "content": "The below definition is wrong, not every edge in the graph... every node in set A connect to a node in set B.\\n\\nA graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": " This problem is a lite version of Problem No. 886, Possible Bipartition.\n"
                    }
                ]
            },
            {
                "id": 1930770,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "can anyone help find the mistake in this code\\nint size=graph.size();\\n        vector<int> color(size,-1);\\n        queue<int> qp;\\n        color[0]=0;\\n        qp.push(0);\\n        while(!qp.empty()){\\n                int node=qp.front();\\n                qp.pop();\\n                for(auto it:graph[node]){\\n                    if(color[it]==-1){\\n                        color[it]=!color[node];\\n                        qp.push(it);\\n                    }\\n                    else{\\n                        if(color[it]==color[node]);\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;"
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "The good description can be -- color the graph with 2 colors such that no adjacent nodes have same color."
                    },
                    {
                        "username": "SG-C",
                        "content": "logic is easy but code is not \\uD83D\\uDE12"
                    },
                    {
                        "username": "user8199lj",
                        "content": "Here I was trying to get the best runtime, then when I saw the solution I just gave up on humanity!\\nPro tip : Get your submission in and look at the best result.\\nCertainly made my day.  "
                    },
                    {
                        "username": "shfnet",
                        "content": "How is it possible for a graph with a node that doesn\\'t have any edges to be bipartite? If this node is placed in one side, than it cannot be connected to any node on the other side. This breaks the requirement that each node in one side has to connect to some node on the other side. So, am I missing something? Thanks in advance.\\ne.g. see test case 62 / 81:  `[[],[3],[],[1],[]]`\\nThe empty sub arrays `[]` represent nodes that don\\'t have edges. These nodes cannot connect to nodes on the other side. Therefor the graph cannot be bipartite, and yet, this test case expects a `true` result."
                    },
                    {
                        "username": "shfnet",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thanks."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "A graph is bipartite if you can partition its nodes into two distinct sets so that no edge connect two nodes from the same set.\\nAn extreme case is a graph without any edges. It is bipartite because there are no edges connecting two nodes from the same set.\\nThe explanation on [Wikipedia](https://en.wikipedia.org/wiki/Bipartite_graph) might be a little bit easier to understand."
                    },
                    {
                        "username": "Sid_2027",
                        "content": "A bipartite graph consists of nodes that can be divided into two groups, each represented by a different color. The key characteristic of a bipartite graph is that there are no connections between nodes of the same color. To determine if a graph is bipartite, we can apply a coloring algorithm starting from an initial node. We assign one color to the starting node, another color to its neighbors, and continue this process for subsequent neighbors. If at any point we encounter adjacent nodes with the same color, the graph is not bipartite. Otherwise, if we successfully color all the nodes without conflicts, the graph is bipartite. This check can be performed using various graph traversal algorithms.\\nI used DFS it was quite easy to implement."
                    },
                    {
                        "username": "Amitayus",
                        "content": "I found the casual definition of bipartite not very explicit, \"independent\" here is a hard definition that means none of the nodes in the set share an edge.  Bipartite   \nbasically means that you can divide the nodes into two sets, A and B, where each node in A does not connect to other nodes in set A, and each node in A has a connection to a node in B, and vice-versa."
                    },
                    {
                        "username": "inforajsoni",
                        "content": "can anybody tell me ? what is error in this code?    https://leetcode.com/problems/is-graph-bipartite/submissions/953528808/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "In this exercise the parameter `graph` is already an adjacency list.\n`graph[node1]` is a `std::vector` of all direct neighbors of `node1`."
                    },
                    {
                        "username": "conquer",
                        "content": "The below definition is wrong, not every edge in the graph... every node in set A connect to a node in set B.\\n\\nA graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": " This problem is a lite version of Problem No. 886, Possible Bipartition.\n"
                    }
                ]
            },
            {
                "id": 1914366,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "can anyone help find the mistake in this code\\nint size=graph.size();\\n        vector<int> color(size,-1);\\n        queue<int> qp;\\n        color[0]=0;\\n        qp.push(0);\\n        while(!qp.empty()){\\n                int node=qp.front();\\n                qp.pop();\\n                for(auto it:graph[node]){\\n                    if(color[it]==-1){\\n                        color[it]=!color[node];\\n                        qp.push(it);\\n                    }\\n                    else{\\n                        if(color[it]==color[node]);\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;"
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "The good description can be -- color the graph with 2 colors such that no adjacent nodes have same color."
                    },
                    {
                        "username": "SG-C",
                        "content": "logic is easy but code is not \\uD83D\\uDE12"
                    },
                    {
                        "username": "user8199lj",
                        "content": "Here I was trying to get the best runtime, then when I saw the solution I just gave up on humanity!\\nPro tip : Get your submission in and look at the best result.\\nCertainly made my day.  "
                    },
                    {
                        "username": "shfnet",
                        "content": "How is it possible for a graph with a node that doesn\\'t have any edges to be bipartite? If this node is placed in one side, than it cannot be connected to any node on the other side. This breaks the requirement that each node in one side has to connect to some node on the other side. So, am I missing something? Thanks in advance.\\ne.g. see test case 62 / 81:  `[[],[3],[],[1],[]]`\\nThe empty sub arrays `[]` represent nodes that don\\'t have edges. These nodes cannot connect to nodes on the other side. Therefor the graph cannot be bipartite, and yet, this test case expects a `true` result."
                    },
                    {
                        "username": "shfnet",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thanks."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "A graph is bipartite if you can partition its nodes into two distinct sets so that no edge connect two nodes from the same set.\\nAn extreme case is a graph without any edges. It is bipartite because there are no edges connecting two nodes from the same set.\\nThe explanation on [Wikipedia](https://en.wikipedia.org/wiki/Bipartite_graph) might be a little bit easier to understand."
                    },
                    {
                        "username": "Sid_2027",
                        "content": "A bipartite graph consists of nodes that can be divided into two groups, each represented by a different color. The key characteristic of a bipartite graph is that there are no connections between nodes of the same color. To determine if a graph is bipartite, we can apply a coloring algorithm starting from an initial node. We assign one color to the starting node, another color to its neighbors, and continue this process for subsequent neighbors. If at any point we encounter adjacent nodes with the same color, the graph is not bipartite. Otherwise, if we successfully color all the nodes without conflicts, the graph is bipartite. This check can be performed using various graph traversal algorithms.\\nI used DFS it was quite easy to implement."
                    },
                    {
                        "username": "Amitayus",
                        "content": "I found the casual definition of bipartite not very explicit, \"independent\" here is a hard definition that means none of the nodes in the set share an edge.  Bipartite   \nbasically means that you can divide the nodes into two sets, A and B, where each node in A does not connect to other nodes in set A, and each node in A has a connection to a node in B, and vice-versa."
                    },
                    {
                        "username": "inforajsoni",
                        "content": "can anybody tell me ? what is error in this code?    https://leetcode.com/problems/is-graph-bipartite/submissions/953528808/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "In this exercise the parameter `graph` is already an adjacency list.\n`graph[node1]` is a `std::vector` of all direct neighbors of `node1`."
                    },
                    {
                        "username": "conquer",
                        "content": "The below definition is wrong, not every edge in the graph... every node in set A connect to a node in set B.\\n\\nA graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": " This problem is a lite version of Problem No. 886, Possible Bipartition.\n"
                    }
                ]
            },
            {
                "id": 1900021,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "can anyone help find the mistake in this code\\nint size=graph.size();\\n        vector<int> color(size,-1);\\n        queue<int> qp;\\n        color[0]=0;\\n        qp.push(0);\\n        while(!qp.empty()){\\n                int node=qp.front();\\n                qp.pop();\\n                for(auto it:graph[node]){\\n                    if(color[it]==-1){\\n                        color[it]=!color[node];\\n                        qp.push(it);\\n                    }\\n                    else{\\n                        if(color[it]==color[node]);\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;"
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "The good description can be -- color the graph with 2 colors such that no adjacent nodes have same color."
                    },
                    {
                        "username": "SG-C",
                        "content": "logic is easy but code is not \\uD83D\\uDE12"
                    },
                    {
                        "username": "user8199lj",
                        "content": "Here I was trying to get the best runtime, then when I saw the solution I just gave up on humanity!\\nPro tip : Get your submission in and look at the best result.\\nCertainly made my day.  "
                    },
                    {
                        "username": "shfnet",
                        "content": "How is it possible for a graph with a node that doesn\\'t have any edges to be bipartite? If this node is placed in one side, than it cannot be connected to any node on the other side. This breaks the requirement that each node in one side has to connect to some node on the other side. So, am I missing something? Thanks in advance.\\ne.g. see test case 62 / 81:  `[[],[3],[],[1],[]]`\\nThe empty sub arrays `[]` represent nodes that don\\'t have edges. These nodes cannot connect to nodes on the other side. Therefor the graph cannot be bipartite, and yet, this test case expects a `true` result."
                    },
                    {
                        "username": "shfnet",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thanks."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "A graph is bipartite if you can partition its nodes into two distinct sets so that no edge connect two nodes from the same set.\\nAn extreme case is a graph without any edges. It is bipartite because there are no edges connecting two nodes from the same set.\\nThe explanation on [Wikipedia](https://en.wikipedia.org/wiki/Bipartite_graph) might be a little bit easier to understand."
                    },
                    {
                        "username": "Sid_2027",
                        "content": "A bipartite graph consists of nodes that can be divided into two groups, each represented by a different color. The key characteristic of a bipartite graph is that there are no connections between nodes of the same color. To determine if a graph is bipartite, we can apply a coloring algorithm starting from an initial node. We assign one color to the starting node, another color to its neighbors, and continue this process for subsequent neighbors. If at any point we encounter adjacent nodes with the same color, the graph is not bipartite. Otherwise, if we successfully color all the nodes without conflicts, the graph is bipartite. This check can be performed using various graph traversal algorithms.\\nI used DFS it was quite easy to implement."
                    },
                    {
                        "username": "Amitayus",
                        "content": "I found the casual definition of bipartite not very explicit, \"independent\" here is a hard definition that means none of the nodes in the set share an edge.  Bipartite   \nbasically means that you can divide the nodes into two sets, A and B, where each node in A does not connect to other nodes in set A, and each node in A has a connection to a node in B, and vice-versa."
                    },
                    {
                        "username": "inforajsoni",
                        "content": "can anybody tell me ? what is error in this code?    https://leetcode.com/problems/is-graph-bipartite/submissions/953528808/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "In this exercise the parameter `graph` is already an adjacency list.\n`graph[node1]` is a `std::vector` of all direct neighbors of `node1`."
                    },
                    {
                        "username": "conquer",
                        "content": "The below definition is wrong, not every edge in the graph... every node in set A connect to a node in set B.\\n\\nA graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": " This problem is a lite version of Problem No. 886, Possible Bipartition.\n"
                    }
                ]
            },
            {
                "id": 1899256,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "can anyone help find the mistake in this code\\nint size=graph.size();\\n        vector<int> color(size,-1);\\n        queue<int> qp;\\n        color[0]=0;\\n        qp.push(0);\\n        while(!qp.empty()){\\n                int node=qp.front();\\n                qp.pop();\\n                for(auto it:graph[node]){\\n                    if(color[it]==-1){\\n                        color[it]=!color[node];\\n                        qp.push(it);\\n                    }\\n                    else{\\n                        if(color[it]==color[node]);\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;"
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "The good description can be -- color the graph with 2 colors such that no adjacent nodes have same color."
                    },
                    {
                        "username": "SG-C",
                        "content": "logic is easy but code is not \\uD83D\\uDE12"
                    },
                    {
                        "username": "user8199lj",
                        "content": "Here I was trying to get the best runtime, then when I saw the solution I just gave up on humanity!\\nPro tip : Get your submission in and look at the best result.\\nCertainly made my day.  "
                    },
                    {
                        "username": "shfnet",
                        "content": "How is it possible for a graph with a node that doesn\\'t have any edges to be bipartite? If this node is placed in one side, than it cannot be connected to any node on the other side. This breaks the requirement that each node in one side has to connect to some node on the other side. So, am I missing something? Thanks in advance.\\ne.g. see test case 62 / 81:  `[[],[3],[],[1],[]]`\\nThe empty sub arrays `[]` represent nodes that don\\'t have edges. These nodes cannot connect to nodes on the other side. Therefor the graph cannot be bipartite, and yet, this test case expects a `true` result."
                    },
                    {
                        "username": "shfnet",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thanks."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "A graph is bipartite if you can partition its nodes into two distinct sets so that no edge connect two nodes from the same set.\\nAn extreme case is a graph without any edges. It is bipartite because there are no edges connecting two nodes from the same set.\\nThe explanation on [Wikipedia](https://en.wikipedia.org/wiki/Bipartite_graph) might be a little bit easier to understand."
                    },
                    {
                        "username": "Sid_2027",
                        "content": "A bipartite graph consists of nodes that can be divided into two groups, each represented by a different color. The key characteristic of a bipartite graph is that there are no connections between nodes of the same color. To determine if a graph is bipartite, we can apply a coloring algorithm starting from an initial node. We assign one color to the starting node, another color to its neighbors, and continue this process for subsequent neighbors. If at any point we encounter adjacent nodes with the same color, the graph is not bipartite. Otherwise, if we successfully color all the nodes without conflicts, the graph is bipartite. This check can be performed using various graph traversal algorithms.\\nI used DFS it was quite easy to implement."
                    },
                    {
                        "username": "Amitayus",
                        "content": "I found the casual definition of bipartite not very explicit, \"independent\" here is a hard definition that means none of the nodes in the set share an edge.  Bipartite   \nbasically means that you can divide the nodes into two sets, A and B, where each node in A does not connect to other nodes in set A, and each node in A has a connection to a node in B, and vice-versa."
                    },
                    {
                        "username": "inforajsoni",
                        "content": "can anybody tell me ? what is error in this code?    https://leetcode.com/problems/is-graph-bipartite/submissions/953528808/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "In this exercise the parameter `graph` is already an adjacency list.\n`graph[node1]` is a `std::vector` of all direct neighbors of `node1`."
                    },
                    {
                        "username": "conquer",
                        "content": "The below definition is wrong, not every edge in the graph... every node in set A connect to a node in set B.\\n\\nA graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": " This problem is a lite version of Problem No. 886, Possible Bipartition.\n"
                    }
                ]
            },
            {
                "id": 1899209,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "can anyone help find the mistake in this code\\nint size=graph.size();\\n        vector<int> color(size,-1);\\n        queue<int> qp;\\n        color[0]=0;\\n        qp.push(0);\\n        while(!qp.empty()){\\n                int node=qp.front();\\n                qp.pop();\\n                for(auto it:graph[node]){\\n                    if(color[it]==-1){\\n                        color[it]=!color[node];\\n                        qp.push(it);\\n                    }\\n                    else{\\n                        if(color[it]==color[node]);\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;"
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "The good description can be -- color the graph with 2 colors such that no adjacent nodes have same color."
                    },
                    {
                        "username": "SG-C",
                        "content": "logic is easy but code is not \\uD83D\\uDE12"
                    },
                    {
                        "username": "user8199lj",
                        "content": "Here I was trying to get the best runtime, then when I saw the solution I just gave up on humanity!\\nPro tip : Get your submission in and look at the best result.\\nCertainly made my day.  "
                    },
                    {
                        "username": "shfnet",
                        "content": "How is it possible for a graph with a node that doesn\\'t have any edges to be bipartite? If this node is placed in one side, than it cannot be connected to any node on the other side. This breaks the requirement that each node in one side has to connect to some node on the other side. So, am I missing something? Thanks in advance.\\ne.g. see test case 62 / 81:  `[[],[3],[],[1],[]]`\\nThe empty sub arrays `[]` represent nodes that don\\'t have edges. These nodes cannot connect to nodes on the other side. Therefor the graph cannot be bipartite, and yet, this test case expects a `true` result."
                    },
                    {
                        "username": "shfnet",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thanks."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "A graph is bipartite if you can partition its nodes into two distinct sets so that no edge connect two nodes from the same set.\\nAn extreme case is a graph without any edges. It is bipartite because there are no edges connecting two nodes from the same set.\\nThe explanation on [Wikipedia](https://en.wikipedia.org/wiki/Bipartite_graph) might be a little bit easier to understand."
                    },
                    {
                        "username": "Sid_2027",
                        "content": "A bipartite graph consists of nodes that can be divided into two groups, each represented by a different color. The key characteristic of a bipartite graph is that there are no connections between nodes of the same color. To determine if a graph is bipartite, we can apply a coloring algorithm starting from an initial node. We assign one color to the starting node, another color to its neighbors, and continue this process for subsequent neighbors. If at any point we encounter adjacent nodes with the same color, the graph is not bipartite. Otherwise, if we successfully color all the nodes without conflicts, the graph is bipartite. This check can be performed using various graph traversal algorithms.\\nI used DFS it was quite easy to implement."
                    },
                    {
                        "username": "Amitayus",
                        "content": "I found the casual definition of bipartite not very explicit, \"independent\" here is a hard definition that means none of the nodes in the set share an edge.  Bipartite   \nbasically means that you can divide the nodes into two sets, A and B, where each node in A does not connect to other nodes in set A, and each node in A has a connection to a node in B, and vice-versa."
                    },
                    {
                        "username": "inforajsoni",
                        "content": "can anybody tell me ? what is error in this code?    https://leetcode.com/problems/is-graph-bipartite/submissions/953528808/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "In this exercise the parameter `graph` is already an adjacency list.\n`graph[node1]` is a `std::vector` of all direct neighbors of `node1`."
                    },
                    {
                        "username": "conquer",
                        "content": "The below definition is wrong, not every edge in the graph... every node in set A connect to a node in set B.\\n\\nA graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": " This problem is a lite version of Problem No. 886, Possible Bipartition.\n"
                    }
                ]
            },
            {
                "id": 1899186,
                "content": [
                    {
                        "username": "utkarsh_verma",
                        "content": "can anyone help find the mistake in this code\\nint size=graph.size();\\n        vector<int> color(size,-1);\\n        queue<int> qp;\\n        color[0]=0;\\n        qp.push(0);\\n        while(!qp.empty()){\\n                int node=qp.front();\\n                qp.pop();\\n                for(auto it:graph[node]){\\n                    if(color[it]==-1){\\n                        color[it]=!color[node];\\n                        qp.push(it);\\n                    }\\n                    else{\\n                        if(color[it]==color[node]);\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;"
                    },
                    {
                        "username": "Pankaj__123",
                        "content": "The good description can be -- color the graph with 2 colors such that no adjacent nodes have same color."
                    },
                    {
                        "username": "SG-C",
                        "content": "logic is easy but code is not \\uD83D\\uDE12"
                    },
                    {
                        "username": "user8199lj",
                        "content": "Here I was trying to get the best runtime, then when I saw the solution I just gave up on humanity!\\nPro tip : Get your submission in and look at the best result.\\nCertainly made my day.  "
                    },
                    {
                        "username": "shfnet",
                        "content": "How is it possible for a graph with a node that doesn\\'t have any edges to be bipartite? If this node is placed in one side, than it cannot be connected to any node on the other side. This breaks the requirement that each node in one side has to connect to some node on the other side. So, am I missing something? Thanks in advance.\\ne.g. see test case 62 / 81:  `[[],[3],[],[1],[]]`\\nThe empty sub arrays `[]` represent nodes that don\\'t have edges. These nodes cannot connect to nodes on the other side. Therefor the graph cannot be bipartite, and yet, this test case expects a `true` result."
                    },
                    {
                        "username": "shfnet",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thanks."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "A graph is bipartite if you can partition its nodes into two distinct sets so that no edge connect two nodes from the same set.\\nAn extreme case is a graph without any edges. It is bipartite because there are no edges connecting two nodes from the same set.\\nThe explanation on [Wikipedia](https://en.wikipedia.org/wiki/Bipartite_graph) might be a little bit easier to understand."
                    },
                    {
                        "username": "Sid_2027",
                        "content": "A bipartite graph consists of nodes that can be divided into two groups, each represented by a different color. The key characteristic of a bipartite graph is that there are no connections between nodes of the same color. To determine if a graph is bipartite, we can apply a coloring algorithm starting from an initial node. We assign one color to the starting node, another color to its neighbors, and continue this process for subsequent neighbors. If at any point we encounter adjacent nodes with the same color, the graph is not bipartite. Otherwise, if we successfully color all the nodes without conflicts, the graph is bipartite. This check can be performed using various graph traversal algorithms.\\nI used DFS it was quite easy to implement."
                    },
                    {
                        "username": "Amitayus",
                        "content": "I found the casual definition of bipartite not very explicit, \"independent\" here is a hard definition that means none of the nodes in the set share an edge.  Bipartite   \nbasically means that you can divide the nodes into two sets, A and B, where each node in A does not connect to other nodes in set A, and each node in A has a connection to a node in B, and vice-versa."
                    },
                    {
                        "username": "inforajsoni",
                        "content": "can anybody tell me ? what is error in this code?    https://leetcode.com/problems/is-graph-bipartite/submissions/953528808/"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "In this exercise the parameter `graph` is already an adjacency list.\n`graph[node1]` is a `std::vector` of all direct neighbors of `node1`."
                    },
                    {
                        "username": "conquer",
                        "content": "The below definition is wrong, not every edge in the graph... every node in set A connect to a node in set B.\\n\\nA graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": " This problem is a lite version of Problem No. 886, Possible Bipartition.\n"
                    }
                ]
            },
            {
                "id": 1899176,
                "content": [
                    {
                        "username": "vietnha1999",
                        "content": "Same with https://leetcode.com/problems/possible-bipartition/editorial/"
                    },
                    {
                        "username": "Jateq",
                        "content": "i have no enemies.... except graphs"
                    },
                    {
                        "username": "bit_weiser",
                        "content": "hey guys you know what time it is !!!!!!!!????????\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nits time to see other people solution "
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Please, add clarification for a term \"independent [edge] set\", as it was not aparent to me that it is <i>actually a term</i>."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "Solve for Graph Coloring Problem \\uD83D\\uDE0A "
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "In fact to check whether a graph is bipartite we need to check whether it can be colored in m=2 ways or not...,now the problem is simple!"
                    },
                    {
                        "username": "psionl0",
                        "content": "I have learned a lot about Bipartite Graphs from this exercise."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "and another graph week?\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Working ....to reach the level of problem."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "in ICU for 1:30 hour , by the way  good question"
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "[[1],[0,3],[3],[1,2]] can anyone please explain me this case"
                    },
                    {
                        "username": "Diyo",
                        "content": "should be quite simple if you draw it. \n-node 0 is connected to node 1 [1]\n-node 1 is connected to node 0 and 3 [0,3]\n-node 2 is connected to node 3 [3]\n-node 3 is connected to node 1 and 2 [1,2]\nyou get the following graph:\n1-----0\n          |\n          |\n3-----2\nyou can colour node 0 white, node 1 black, node 3 white, node 2 black\n--> the graph is bicolourable --> the graph is bipartite --> return true "
                    }
                ]
            },
            {
                "id": 1899143,
                "content": [
                    {
                        "username": "vietnha1999",
                        "content": "Same with https://leetcode.com/problems/possible-bipartition/editorial/"
                    },
                    {
                        "username": "Jateq",
                        "content": "i have no enemies.... except graphs"
                    },
                    {
                        "username": "bit_weiser",
                        "content": "hey guys you know what time it is !!!!!!!!????????\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nits time to see other people solution "
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Please, add clarification for a term \"independent [edge] set\", as it was not aparent to me that it is <i>actually a term</i>."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "Solve for Graph Coloring Problem \\uD83D\\uDE0A "
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "In fact to check whether a graph is bipartite we need to check whether it can be colored in m=2 ways or not...,now the problem is simple!"
                    },
                    {
                        "username": "psionl0",
                        "content": "I have learned a lot about Bipartite Graphs from this exercise."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "and another graph week?\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Working ....to reach the level of problem."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "in ICU for 1:30 hour , by the way  good question"
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "[[1],[0,3],[3],[1,2]] can anyone please explain me this case"
                    },
                    {
                        "username": "Diyo",
                        "content": "should be quite simple if you draw it. \n-node 0 is connected to node 1 [1]\n-node 1 is connected to node 0 and 3 [0,3]\n-node 2 is connected to node 3 [3]\n-node 3 is connected to node 1 and 2 [1,2]\nyou get the following graph:\n1-----0\n          |\n          |\n3-----2\nyou can colour node 0 white, node 1 black, node 3 white, node 2 black\n--> the graph is bicolourable --> the graph is bipartite --> return true "
                    }
                ]
            },
            {
                "id": 1899092,
                "content": [
                    {
                        "username": "vietnha1999",
                        "content": "Same with https://leetcode.com/problems/possible-bipartition/editorial/"
                    },
                    {
                        "username": "Jateq",
                        "content": "i have no enemies.... except graphs"
                    },
                    {
                        "username": "bit_weiser",
                        "content": "hey guys you know what time it is !!!!!!!!????????\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nits time to see other people solution "
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Please, add clarification for a term \"independent [edge] set\", as it was not aparent to me that it is <i>actually a term</i>."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "Solve for Graph Coloring Problem \\uD83D\\uDE0A "
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "In fact to check whether a graph is bipartite we need to check whether it can be colored in m=2 ways or not...,now the problem is simple!"
                    },
                    {
                        "username": "psionl0",
                        "content": "I have learned a lot about Bipartite Graphs from this exercise."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "and another graph week?\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Working ....to reach the level of problem."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "in ICU for 1:30 hour , by the way  good question"
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "[[1],[0,3],[3],[1,2]] can anyone please explain me this case"
                    },
                    {
                        "username": "Diyo",
                        "content": "should be quite simple if you draw it. \n-node 0 is connected to node 1 [1]\n-node 1 is connected to node 0 and 3 [0,3]\n-node 2 is connected to node 3 [3]\n-node 3 is connected to node 1 and 2 [1,2]\nyou get the following graph:\n1-----0\n          |\n          |\n3-----2\nyou can colour node 0 white, node 1 black, node 3 white, node 2 black\n--> the graph is bicolourable --> the graph is bipartite --> return true "
                    }
                ]
            },
            {
                "id": 1899073,
                "content": [
                    {
                        "username": "vietnha1999",
                        "content": "Same with https://leetcode.com/problems/possible-bipartition/editorial/"
                    },
                    {
                        "username": "Jateq",
                        "content": "i have no enemies.... except graphs"
                    },
                    {
                        "username": "bit_weiser",
                        "content": "hey guys you know what time it is !!!!!!!!????????\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nits time to see other people solution "
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Please, add clarification for a term \"independent [edge] set\", as it was not aparent to me that it is <i>actually a term</i>."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "Solve for Graph Coloring Problem \\uD83D\\uDE0A "
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "In fact to check whether a graph is bipartite we need to check whether it can be colored in m=2 ways or not...,now the problem is simple!"
                    },
                    {
                        "username": "psionl0",
                        "content": "I have learned a lot about Bipartite Graphs from this exercise."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "and another graph week?\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Working ....to reach the level of problem."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "in ICU for 1:30 hour , by the way  good question"
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "[[1],[0,3],[3],[1,2]] can anyone please explain me this case"
                    },
                    {
                        "username": "Diyo",
                        "content": "should be quite simple if you draw it. \n-node 0 is connected to node 1 [1]\n-node 1 is connected to node 0 and 3 [0,3]\n-node 2 is connected to node 3 [3]\n-node 3 is connected to node 1 and 2 [1,2]\nyou get the following graph:\n1-----0\n          |\n          |\n3-----2\nyou can colour node 0 white, node 1 black, node 3 white, node 2 black\n--> the graph is bicolourable --> the graph is bipartite --> return true "
                    }
                ]
            },
            {
                "id": 1899056,
                "content": [
                    {
                        "username": "vietnha1999",
                        "content": "Same with https://leetcode.com/problems/possible-bipartition/editorial/"
                    },
                    {
                        "username": "Jateq",
                        "content": "i have no enemies.... except graphs"
                    },
                    {
                        "username": "bit_weiser",
                        "content": "hey guys you know what time it is !!!!!!!!????????\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nits time to see other people solution "
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Please, add clarification for a term \"independent [edge] set\", as it was not aparent to me that it is <i>actually a term</i>."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "Solve for Graph Coloring Problem \\uD83D\\uDE0A "
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "In fact to check whether a graph is bipartite we need to check whether it can be colored in m=2 ways or not...,now the problem is simple!"
                    },
                    {
                        "username": "psionl0",
                        "content": "I have learned a lot about Bipartite Graphs from this exercise."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "and another graph week?\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Working ....to reach the level of problem."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "in ICU for 1:30 hour , by the way  good question"
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "[[1],[0,3],[3],[1,2]] can anyone please explain me this case"
                    },
                    {
                        "username": "Diyo",
                        "content": "should be quite simple if you draw it. \n-node 0 is connected to node 1 [1]\n-node 1 is connected to node 0 and 3 [0,3]\n-node 2 is connected to node 3 [3]\n-node 3 is connected to node 1 and 2 [1,2]\nyou get the following graph:\n1-----0\n          |\n          |\n3-----2\nyou can colour node 0 white, node 1 black, node 3 white, node 2 black\n--> the graph is bicolourable --> the graph is bipartite --> return true "
                    }
                ]
            },
            {
                "id": 1899010,
                "content": [
                    {
                        "username": "vietnha1999",
                        "content": "Same with https://leetcode.com/problems/possible-bipartition/editorial/"
                    },
                    {
                        "username": "Jateq",
                        "content": "i have no enemies.... except graphs"
                    },
                    {
                        "username": "bit_weiser",
                        "content": "hey guys you know what time it is !!!!!!!!????????\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nits time to see other people solution "
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Please, add clarification for a term \"independent [edge] set\", as it was not aparent to me that it is <i>actually a term</i>."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "Solve for Graph Coloring Problem \\uD83D\\uDE0A "
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "In fact to check whether a graph is bipartite we need to check whether it can be colored in m=2 ways or not...,now the problem is simple!"
                    },
                    {
                        "username": "psionl0",
                        "content": "I have learned a lot about Bipartite Graphs from this exercise."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "and another graph week?\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Working ....to reach the level of problem."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "in ICU for 1:30 hour , by the way  good question"
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "[[1],[0,3],[3],[1,2]] can anyone please explain me this case"
                    },
                    {
                        "username": "Diyo",
                        "content": "should be quite simple if you draw it. \n-node 0 is connected to node 1 [1]\n-node 1 is connected to node 0 and 3 [0,3]\n-node 2 is connected to node 3 [3]\n-node 3 is connected to node 1 and 2 [1,2]\nyou get the following graph:\n1-----0\n          |\n          |\n3-----2\nyou can colour node 0 white, node 1 black, node 3 white, node 2 black\n--> the graph is bicolourable --> the graph is bipartite --> return true "
                    }
                ]
            },
            {
                "id": 1898985,
                "content": [
                    {
                        "username": "vietnha1999",
                        "content": "Same with https://leetcode.com/problems/possible-bipartition/editorial/"
                    },
                    {
                        "username": "Jateq",
                        "content": "i have no enemies.... except graphs"
                    },
                    {
                        "username": "bit_weiser",
                        "content": "hey guys you know what time it is !!!!!!!!????????\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nits time to see other people solution "
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Please, add clarification for a term \"independent [edge] set\", as it was not aparent to me that it is <i>actually a term</i>."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "Solve for Graph Coloring Problem \\uD83D\\uDE0A "
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "In fact to check whether a graph is bipartite we need to check whether it can be colored in m=2 ways or not...,now the problem is simple!"
                    },
                    {
                        "username": "psionl0",
                        "content": "I have learned a lot about Bipartite Graphs from this exercise."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "and another graph week?\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Working ....to reach the level of problem."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "in ICU for 1:30 hour , by the way  good question"
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "[[1],[0,3],[3],[1,2]] can anyone please explain me this case"
                    },
                    {
                        "username": "Diyo",
                        "content": "should be quite simple if you draw it. \n-node 0 is connected to node 1 [1]\n-node 1 is connected to node 0 and 3 [0,3]\n-node 2 is connected to node 3 [3]\n-node 3 is connected to node 1 and 2 [1,2]\nyou get the following graph:\n1-----0\n          |\n          |\n3-----2\nyou can colour node 0 white, node 1 black, node 3 white, node 2 black\n--> the graph is bicolourable --> the graph is bipartite --> return true "
                    }
                ]
            },
            {
                "id": 1898976,
                "content": [
                    {
                        "username": "vietnha1999",
                        "content": "Same with https://leetcode.com/problems/possible-bipartition/editorial/"
                    },
                    {
                        "username": "Jateq",
                        "content": "i have no enemies.... except graphs"
                    },
                    {
                        "username": "bit_weiser",
                        "content": "hey guys you know what time it is !!!!!!!!????????\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nits time to see other people solution "
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Please, add clarification for a term \"independent [edge] set\", as it was not aparent to me that it is <i>actually a term</i>."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "Solve for Graph Coloring Problem \\uD83D\\uDE0A "
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "In fact to check whether a graph is bipartite we need to check whether it can be colored in m=2 ways or not...,now the problem is simple!"
                    },
                    {
                        "username": "psionl0",
                        "content": "I have learned a lot about Bipartite Graphs from this exercise."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "and another graph week?\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Working ....to reach the level of problem."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "in ICU for 1:30 hour , by the way  good question"
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "[[1],[0,3],[3],[1,2]] can anyone please explain me this case"
                    },
                    {
                        "username": "Diyo",
                        "content": "should be quite simple if you draw it. \n-node 0 is connected to node 1 [1]\n-node 1 is connected to node 0 and 3 [0,3]\n-node 2 is connected to node 3 [3]\n-node 3 is connected to node 1 and 2 [1,2]\nyou get the following graph:\n1-----0\n          |\n          |\n3-----2\nyou can colour node 0 white, node 1 black, node 3 white, node 2 black\n--> the graph is bicolourable --> the graph is bipartite --> return true "
                    }
                ]
            },
            {
                "id": 1898886,
                "content": [
                    {
                        "username": "vietnha1999",
                        "content": "Same with https://leetcode.com/problems/possible-bipartition/editorial/"
                    },
                    {
                        "username": "Jateq",
                        "content": "i have no enemies.... except graphs"
                    },
                    {
                        "username": "bit_weiser",
                        "content": "hey guys you know what time it is !!!!!!!!????????\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nits time to see other people solution "
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Please, add clarification for a term \"independent [edge] set\", as it was not aparent to me that it is <i>actually a term</i>."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "Solve for Graph Coloring Problem \\uD83D\\uDE0A "
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "In fact to check whether a graph is bipartite we need to check whether it can be colored in m=2 ways or not...,now the problem is simple!"
                    },
                    {
                        "username": "psionl0",
                        "content": "I have learned a lot about Bipartite Graphs from this exercise."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "and another graph week?\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Working ....to reach the level of problem."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "in ICU for 1:30 hour , by the way  good question"
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "[[1],[0,3],[3],[1,2]] can anyone please explain me this case"
                    },
                    {
                        "username": "Diyo",
                        "content": "should be quite simple if you draw it. \n-node 0 is connected to node 1 [1]\n-node 1 is connected to node 0 and 3 [0,3]\n-node 2 is connected to node 3 [3]\n-node 3 is connected to node 1 and 2 [1,2]\nyou get the following graph:\n1-----0\n          |\n          |\n3-----2\nyou can colour node 0 white, node 1 black, node 3 white, node 2 black\n--> the graph is bicolourable --> the graph is bipartite --> return true "
                    }
                ]
            },
            {
                "id": 1898833,
                "content": [
                    {
                        "username": "vietnha1999",
                        "content": "Same with https://leetcode.com/problems/possible-bipartition/editorial/"
                    },
                    {
                        "username": "Jateq",
                        "content": "i have no enemies.... except graphs"
                    },
                    {
                        "username": "bit_weiser",
                        "content": "hey guys you know what time it is !!!!!!!!????????\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\nits time to see other people solution "
                    },
                    {
                        "username": "Dzuchun",
                        "content": "Please, add clarification for a term \"independent [edge] set\", as it was not aparent to me that it is <i>actually a term</i>."
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "Solve for Graph Coloring Problem \\uD83D\\uDE0A "
                    },
                    {
                        "username": "dudhaniayush",
                        "content": "In fact to check whether a graph is bipartite we need to check whether it can be colored in m=2 ways or not...,now the problem is simple!"
                    },
                    {
                        "username": "psionl0",
                        "content": "I have learned a lot about Bipartite Graphs from this exercise."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "and another graph week?\\n"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Working ....to reach the level of problem."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "in ICU for 1:30 hour , by the way  good question"
                    },
                    {
                        "username": "vivek-raj-gupta-2002",
                        "content": "[[1],[0,3],[3],[1,2]] can anyone please explain me this case"
                    },
                    {
                        "username": "Diyo",
                        "content": "should be quite simple if you draw it. \n-node 0 is connected to node 1 [1]\n-node 1 is connected to node 0 and 3 [0,3]\n-node 2 is connected to node 3 [3]\n-node 3 is connected to node 1 and 2 [1,2]\nyou get the following graph:\n1-----0\n          |\n          |\n3-----2\nyou can colour node 0 white, node 1 black, node 3 white, node 2 black\n--> the graph is bicolourable --> the graph is bipartite --> return true "
                    }
                ]
            },
            {
                "id": 1898771,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "This question is similiar to graph coloring.\\nTry thinking in the way of solving graph coloring of adjacent nodes."
                    },
                    {
                        "username": "champ-",
                        "content": "Why not example 1 is false?\\n\\nWhy not {0} and {1,2,3} "
                    },
                    {
                        "username": "champ-",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thank you "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The graph in example 1 is not bipartite because there are edges between 1 and 2, and between 2 and 3.   \\nIn a bipartite graph the nodes can be partitioned into two sets so that all edges only connect nodes between the two sets, not within one set. (see [wikipedia](https://en.wikipedia.org/wiki/Bipartite_graph))."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Clear explanation of Bipartite - Divide the vertices in two independent sets such that if any edges exists, they exists between the nodes in two sets and not within each set.\\nCheck wiki for image - https://en.wikipedia.org/wiki/Bipartite_graph"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "This week is a LinkedList where nodes are LinkedList and Graph...:)"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "class Solution {\\npublic:\\n\\n    bool dfs(int prev, int node, vector<int> &vis, vector<vector<int>> graph){\\n        vis[node] = prev;\\n        for(auto i:graph[node]){\\n            if(vis[i] == -1) if(!dfs(!prev,i,vis,graph)) return false;\\n            else if(vis[i] == prev) return false;\\n        }\\n        return true;\\n    }\\n\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<int> vis (n,-1);\\n        for(int i = 0; i<n ; i++){\\n            if(vis[i] == -1){\\n                if(!dfs(0,i,vis,graph)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\nit is giving true in non-biparte graph.....please help\\uD83E\\uDD79\\uD83E\\uDD72"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "[@siebenschlaefer](/siebenschlaefer)\\nthank you so much \\ngot it!!!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "An `else` belongs to the closest `if`. So the compiler interprets\n```cpp\nif (a) if (b) return result1;\nelse if (c) return result2;\n```\nas\n```cpp\nif (a) {\n    if (b) {\n        return result1;\n    } else {\n        if (c) {\n            return result2;\n        }\n    }\n}\n```\n\nBTW: To avoid unnecessary and expensive copies you might want to change the parameter `graph` of the helper function `dfs()` to a reference."
                    },
                    {
                        "username": "dreykanbern",
                        "content": "Hello everyone, I hope this is not a toxic community. Can you please tell me some material for studying graphs? Maybe a youtube channel or whatever, I feel like a helpless kitten when I see tasks like this, thanks in advance for your help!"
                    },
                    {
                        "username": "dreykanbern",
                        "content": "[@H4CE](/H4CE) Thank you so much"
                    },
                    {
                        "username": "H4CE",
                        "content": "You can follow the Graph series by takeYouForward youtube channel. It is completely in English and I think it covers in depth graph concepts."
                    },
                    {
                        "username": "eairox",
                        "content": "[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]] \\n\\nshould be true but expected is false. Why is it false?\\n\\n0--------3\\n|\\n|\\n2--------1\\n|\\n|\\n4\\n\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@SanskarTyagi](/SanskarTyagi) Here\\'s how:\\nThe input is an \"adjacency list\": `[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]]` means that\\n- node `0` is connected to nodes `1`, `2`, and `3`\\n- node `1` is connected to nodes `0`, `3`, and `4`\\n- node `2` is connected to nodes `0` and `3`\\n- node `3` is connected to nodes `0`, `1`, and `2`\\n- node `4` is connected to node `1`"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  But how is 0 -- 2 connected ?? \\nthe edges have no input for 0 and 2 connection . and if we say there is connected graph because of [0,1,2] then in the first example why is 1,2,3 connected as 1- 2 \\n                           |\\n                          3\\nand not  1  -   2 \\n                 \\\\     |\\n                   \\\\   |\\n                      3"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "In your visualization there are some edges missing.  \nHere's a complete visualization of `[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]]`:\n```\n2--3\n| /|\n|/ |\n0--1--4\n```"
                    },
                    {
                        "username": "Karan108",
                        "content": "class Solution {\\nprivate:\\n    bool dfs(vector<int>adj[] , int col , vector<int>&color , int start) {\\n        color[start]=col ;\\n        for (auto it:adj[start]) {\\n            if(color[it]==-1) {\\n                dfs(adj , !col , color , it) ;\\n            } else if(color[it]==color[start]) {\\n                return false ;\\n            }\\n        }\\n        return true ;\\n    }\\npublic:\\n    bool isBipartite(vector<vector<int>>&graph) {\\n        int n=graph.size() ;\\n        int m=graph[0].size() ;\\n        vector<int>adj[n] ;\\n        for (int i =0 ; i<n ; i++) {\\n            for (int j=0 ; j<m ; j++) {\\n                if (graph[i][j]==1) {\\n                    adj[i].push_back(j) ;\\n                    adj[j].push_back(i) ;\\n                }\\n            }\\n        }\\n        vector<int>color(n,-1) ;\\n        for (int i=0 ; i<n ; i++) {\\n            if(color[i]==-1) {\\n                if (dfs(adj ,0 , color , i)==false) {\\n                    return false ;\\n                } \\n            }\\n        }\\n        return true ;\\n    }\\n};\\n\\nruntime error someone pls help\\n"
                    },
                    {
                        "username": "lakshya_rana",
                        "content": "vector<vector<int>> graph is an adjacency list so , dont make adj list just delete that part of conversion and replace adj to graph in yout code "
                    },
                    {
                        "username": "user8738ZV",
                        "content": "simply a graph color problem using two color , if we are able to color it using two colors then it is bipartite other wise it is not"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "\\n bool  isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        int m = graph[0].size();\\n        int color[n];\\n        for(int i=0;i<n;i++)color[i]=-1;\\n        for(int i=0;i<n;i++){\\n            if(color[i] == -1){\\n                color[i] = 0;\\n            }\\n            for(int j=0;j<m;j++){\\n                if(color[j] == -1){\\n                    color[j] = !color[i];\\n                    if(isBipartite(graph)==false){\\n                        return false;\\n                    }\\n                }\\n                else if(color[j] == color[i]){\\n                    return false;\\n                }\\n            }\\n\\n        }\\n        return true;\\n    }\\n\\ncan any help to find out the error in above approach of dfs traversal"
                    },
                    {
                        "username": "lakshya_rana",
                        "content": "vector<vector> graph is an adjacency list so , dont make adj list just delete that part of conversion and replace adj to graph in yout code\\n"
                    }
                ]
            },
            {
                "id": 1898700,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "This question is similiar to graph coloring.\\nTry thinking in the way of solving graph coloring of adjacent nodes."
                    },
                    {
                        "username": "champ-",
                        "content": "Why not example 1 is false?\\n\\nWhy not {0} and {1,2,3} "
                    },
                    {
                        "username": "champ-",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thank you "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The graph in example 1 is not bipartite because there are edges between 1 and 2, and between 2 and 3.   \\nIn a bipartite graph the nodes can be partitioned into two sets so that all edges only connect nodes between the two sets, not within one set. (see [wikipedia](https://en.wikipedia.org/wiki/Bipartite_graph))."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Clear explanation of Bipartite - Divide the vertices in two independent sets such that if any edges exists, they exists between the nodes in two sets and not within each set.\\nCheck wiki for image - https://en.wikipedia.org/wiki/Bipartite_graph"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "This week is a LinkedList where nodes are LinkedList and Graph...:)"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "class Solution {\\npublic:\\n\\n    bool dfs(int prev, int node, vector<int> &vis, vector<vector<int>> graph){\\n        vis[node] = prev;\\n        for(auto i:graph[node]){\\n            if(vis[i] == -1) if(!dfs(!prev,i,vis,graph)) return false;\\n            else if(vis[i] == prev) return false;\\n        }\\n        return true;\\n    }\\n\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<int> vis (n,-1);\\n        for(int i = 0; i<n ; i++){\\n            if(vis[i] == -1){\\n                if(!dfs(0,i,vis,graph)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\nit is giving true in non-biparte graph.....please help\\uD83E\\uDD79\\uD83E\\uDD72"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "[@siebenschlaefer](/siebenschlaefer)\\nthank you so much \\ngot it!!!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "An `else` belongs to the closest `if`. So the compiler interprets\n```cpp\nif (a) if (b) return result1;\nelse if (c) return result2;\n```\nas\n```cpp\nif (a) {\n    if (b) {\n        return result1;\n    } else {\n        if (c) {\n            return result2;\n        }\n    }\n}\n```\n\nBTW: To avoid unnecessary and expensive copies you might want to change the parameter `graph` of the helper function `dfs()` to a reference."
                    },
                    {
                        "username": "dreykanbern",
                        "content": "Hello everyone, I hope this is not a toxic community. Can you please tell me some material for studying graphs? Maybe a youtube channel or whatever, I feel like a helpless kitten when I see tasks like this, thanks in advance for your help!"
                    },
                    {
                        "username": "dreykanbern",
                        "content": "[@H4CE](/H4CE) Thank you so much"
                    },
                    {
                        "username": "H4CE",
                        "content": "You can follow the Graph series by takeYouForward youtube channel. It is completely in English and I think it covers in depth graph concepts."
                    },
                    {
                        "username": "eairox",
                        "content": "[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]] \\n\\nshould be true but expected is false. Why is it false?\\n\\n0--------3\\n|\\n|\\n2--------1\\n|\\n|\\n4\\n\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@SanskarTyagi](/SanskarTyagi) Here\\'s how:\\nThe input is an \"adjacency list\": `[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]]` means that\\n- node `0` is connected to nodes `1`, `2`, and `3`\\n- node `1` is connected to nodes `0`, `3`, and `4`\\n- node `2` is connected to nodes `0` and `3`\\n- node `3` is connected to nodes `0`, `1`, and `2`\\n- node `4` is connected to node `1`"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  But how is 0 -- 2 connected ?? \\nthe edges have no input for 0 and 2 connection . and if we say there is connected graph because of [0,1,2] then in the first example why is 1,2,3 connected as 1- 2 \\n                           |\\n                          3\\nand not  1  -   2 \\n                 \\\\     |\\n                   \\\\   |\\n                      3"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "In your visualization there are some edges missing.  \nHere's a complete visualization of `[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]]`:\n```\n2--3\n| /|\n|/ |\n0--1--4\n```"
                    },
                    {
                        "username": "Karan108",
                        "content": "class Solution {\\nprivate:\\n    bool dfs(vector<int>adj[] , int col , vector<int>&color , int start) {\\n        color[start]=col ;\\n        for (auto it:adj[start]) {\\n            if(color[it]==-1) {\\n                dfs(adj , !col , color , it) ;\\n            } else if(color[it]==color[start]) {\\n                return false ;\\n            }\\n        }\\n        return true ;\\n    }\\npublic:\\n    bool isBipartite(vector<vector<int>>&graph) {\\n        int n=graph.size() ;\\n        int m=graph[0].size() ;\\n        vector<int>adj[n] ;\\n        for (int i =0 ; i<n ; i++) {\\n            for (int j=0 ; j<m ; j++) {\\n                if (graph[i][j]==1) {\\n                    adj[i].push_back(j) ;\\n                    adj[j].push_back(i) ;\\n                }\\n            }\\n        }\\n        vector<int>color(n,-1) ;\\n        for (int i=0 ; i<n ; i++) {\\n            if(color[i]==-1) {\\n                if (dfs(adj ,0 , color , i)==false) {\\n                    return false ;\\n                } \\n            }\\n        }\\n        return true ;\\n    }\\n};\\n\\nruntime error someone pls help\\n"
                    },
                    {
                        "username": "lakshya_rana",
                        "content": "vector<vector<int>> graph is an adjacency list so , dont make adj list just delete that part of conversion and replace adj to graph in yout code "
                    },
                    {
                        "username": "user8738ZV",
                        "content": "simply a graph color problem using two color , if we are able to color it using two colors then it is bipartite other wise it is not"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "\\n bool  isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        int m = graph[0].size();\\n        int color[n];\\n        for(int i=0;i<n;i++)color[i]=-1;\\n        for(int i=0;i<n;i++){\\n            if(color[i] == -1){\\n                color[i] = 0;\\n            }\\n            for(int j=0;j<m;j++){\\n                if(color[j] == -1){\\n                    color[j] = !color[i];\\n                    if(isBipartite(graph)==false){\\n                        return false;\\n                    }\\n                }\\n                else if(color[j] == color[i]){\\n                    return false;\\n                }\\n            }\\n\\n        }\\n        return true;\\n    }\\n\\ncan any help to find out the error in above approach of dfs traversal"
                    },
                    {
                        "username": "lakshya_rana",
                        "content": "vector<vector> graph is an adjacency list so , dont make adj list just delete that part of conversion and replace adj to graph in yout code\\n"
                    }
                ]
            },
            {
                "id": 1898672,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "This question is similiar to graph coloring.\\nTry thinking in the way of solving graph coloring of adjacent nodes."
                    },
                    {
                        "username": "champ-",
                        "content": "Why not example 1 is false?\\n\\nWhy not {0} and {1,2,3} "
                    },
                    {
                        "username": "champ-",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thank you "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The graph in example 1 is not bipartite because there are edges between 1 and 2, and between 2 and 3.   \\nIn a bipartite graph the nodes can be partitioned into two sets so that all edges only connect nodes between the two sets, not within one set. (see [wikipedia](https://en.wikipedia.org/wiki/Bipartite_graph))."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Clear explanation of Bipartite - Divide the vertices in two independent sets such that if any edges exists, they exists between the nodes in two sets and not within each set.\\nCheck wiki for image - https://en.wikipedia.org/wiki/Bipartite_graph"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "This week is a LinkedList where nodes are LinkedList and Graph...:)"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "class Solution {\\npublic:\\n\\n    bool dfs(int prev, int node, vector<int> &vis, vector<vector<int>> graph){\\n        vis[node] = prev;\\n        for(auto i:graph[node]){\\n            if(vis[i] == -1) if(!dfs(!prev,i,vis,graph)) return false;\\n            else if(vis[i] == prev) return false;\\n        }\\n        return true;\\n    }\\n\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<int> vis (n,-1);\\n        for(int i = 0; i<n ; i++){\\n            if(vis[i] == -1){\\n                if(!dfs(0,i,vis,graph)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\nit is giving true in non-biparte graph.....please help\\uD83E\\uDD79\\uD83E\\uDD72"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "[@siebenschlaefer](/siebenschlaefer)\\nthank you so much \\ngot it!!!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "An `else` belongs to the closest `if`. So the compiler interprets\n```cpp\nif (a) if (b) return result1;\nelse if (c) return result2;\n```\nas\n```cpp\nif (a) {\n    if (b) {\n        return result1;\n    } else {\n        if (c) {\n            return result2;\n        }\n    }\n}\n```\n\nBTW: To avoid unnecessary and expensive copies you might want to change the parameter `graph` of the helper function `dfs()` to a reference."
                    },
                    {
                        "username": "dreykanbern",
                        "content": "Hello everyone, I hope this is not a toxic community. Can you please tell me some material for studying graphs? Maybe a youtube channel or whatever, I feel like a helpless kitten when I see tasks like this, thanks in advance for your help!"
                    },
                    {
                        "username": "dreykanbern",
                        "content": "[@H4CE](/H4CE) Thank you so much"
                    },
                    {
                        "username": "H4CE",
                        "content": "You can follow the Graph series by takeYouForward youtube channel. It is completely in English and I think it covers in depth graph concepts."
                    },
                    {
                        "username": "eairox",
                        "content": "[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]] \\n\\nshould be true but expected is false. Why is it false?\\n\\n0--------3\\n|\\n|\\n2--------1\\n|\\n|\\n4\\n\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@SanskarTyagi](/SanskarTyagi) Here\\'s how:\\nThe input is an \"adjacency list\": `[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]]` means that\\n- node `0` is connected to nodes `1`, `2`, and `3`\\n- node `1` is connected to nodes `0`, `3`, and `4`\\n- node `2` is connected to nodes `0` and `3`\\n- node `3` is connected to nodes `0`, `1`, and `2`\\n- node `4` is connected to node `1`"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  But how is 0 -- 2 connected ?? \\nthe edges have no input for 0 and 2 connection . and if we say there is connected graph because of [0,1,2] then in the first example why is 1,2,3 connected as 1- 2 \\n                           |\\n                          3\\nand not  1  -   2 \\n                 \\\\     |\\n                   \\\\   |\\n                      3"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "In your visualization there are some edges missing.  \nHere's a complete visualization of `[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]]`:\n```\n2--3\n| /|\n|/ |\n0--1--4\n```"
                    },
                    {
                        "username": "Karan108",
                        "content": "class Solution {\\nprivate:\\n    bool dfs(vector<int>adj[] , int col , vector<int>&color , int start) {\\n        color[start]=col ;\\n        for (auto it:adj[start]) {\\n            if(color[it]==-1) {\\n                dfs(adj , !col , color , it) ;\\n            } else if(color[it]==color[start]) {\\n                return false ;\\n            }\\n        }\\n        return true ;\\n    }\\npublic:\\n    bool isBipartite(vector<vector<int>>&graph) {\\n        int n=graph.size() ;\\n        int m=graph[0].size() ;\\n        vector<int>adj[n] ;\\n        for (int i =0 ; i<n ; i++) {\\n            for (int j=0 ; j<m ; j++) {\\n                if (graph[i][j]==1) {\\n                    adj[i].push_back(j) ;\\n                    adj[j].push_back(i) ;\\n                }\\n            }\\n        }\\n        vector<int>color(n,-1) ;\\n        for (int i=0 ; i<n ; i++) {\\n            if(color[i]==-1) {\\n                if (dfs(adj ,0 , color , i)==false) {\\n                    return false ;\\n                } \\n            }\\n        }\\n        return true ;\\n    }\\n};\\n\\nruntime error someone pls help\\n"
                    },
                    {
                        "username": "lakshya_rana",
                        "content": "vector<vector<int>> graph is an adjacency list so , dont make adj list just delete that part of conversion and replace adj to graph in yout code "
                    },
                    {
                        "username": "user8738ZV",
                        "content": "simply a graph color problem using two color , if we are able to color it using two colors then it is bipartite other wise it is not"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "\\n bool  isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        int m = graph[0].size();\\n        int color[n];\\n        for(int i=0;i<n;i++)color[i]=-1;\\n        for(int i=0;i<n;i++){\\n            if(color[i] == -1){\\n                color[i] = 0;\\n            }\\n            for(int j=0;j<m;j++){\\n                if(color[j] == -1){\\n                    color[j] = !color[i];\\n                    if(isBipartite(graph)==false){\\n                        return false;\\n                    }\\n                }\\n                else if(color[j] == color[i]){\\n                    return false;\\n                }\\n            }\\n\\n        }\\n        return true;\\n    }\\n\\ncan any help to find out the error in above approach of dfs traversal"
                    },
                    {
                        "username": "lakshya_rana",
                        "content": "vector<vector> graph is an adjacency list so , dont make adj list just delete that part of conversion and replace adj to graph in yout code\\n"
                    }
                ]
            },
            {
                "id": 1898666,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "This question is similiar to graph coloring.\\nTry thinking in the way of solving graph coloring of adjacent nodes."
                    },
                    {
                        "username": "champ-",
                        "content": "Why not example 1 is false?\\n\\nWhy not {0} and {1,2,3} "
                    },
                    {
                        "username": "champ-",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thank you "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The graph in example 1 is not bipartite because there are edges between 1 and 2, and between 2 and 3.   \\nIn a bipartite graph the nodes can be partitioned into two sets so that all edges only connect nodes between the two sets, not within one set. (see [wikipedia](https://en.wikipedia.org/wiki/Bipartite_graph))."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Clear explanation of Bipartite - Divide the vertices in two independent sets such that if any edges exists, they exists between the nodes in two sets and not within each set.\\nCheck wiki for image - https://en.wikipedia.org/wiki/Bipartite_graph"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "This week is a LinkedList where nodes are LinkedList and Graph...:)"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "class Solution {\\npublic:\\n\\n    bool dfs(int prev, int node, vector<int> &vis, vector<vector<int>> graph){\\n        vis[node] = prev;\\n        for(auto i:graph[node]){\\n            if(vis[i] == -1) if(!dfs(!prev,i,vis,graph)) return false;\\n            else if(vis[i] == prev) return false;\\n        }\\n        return true;\\n    }\\n\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<int> vis (n,-1);\\n        for(int i = 0; i<n ; i++){\\n            if(vis[i] == -1){\\n                if(!dfs(0,i,vis,graph)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\nit is giving true in non-biparte graph.....please help\\uD83E\\uDD79\\uD83E\\uDD72"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "[@siebenschlaefer](/siebenschlaefer)\\nthank you so much \\ngot it!!!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "An `else` belongs to the closest `if`. So the compiler interprets\n```cpp\nif (a) if (b) return result1;\nelse if (c) return result2;\n```\nas\n```cpp\nif (a) {\n    if (b) {\n        return result1;\n    } else {\n        if (c) {\n            return result2;\n        }\n    }\n}\n```\n\nBTW: To avoid unnecessary and expensive copies you might want to change the parameter `graph` of the helper function `dfs()` to a reference."
                    },
                    {
                        "username": "dreykanbern",
                        "content": "Hello everyone, I hope this is not a toxic community. Can you please tell me some material for studying graphs? Maybe a youtube channel or whatever, I feel like a helpless kitten when I see tasks like this, thanks in advance for your help!"
                    },
                    {
                        "username": "dreykanbern",
                        "content": "[@H4CE](/H4CE) Thank you so much"
                    },
                    {
                        "username": "H4CE",
                        "content": "You can follow the Graph series by takeYouForward youtube channel. It is completely in English and I think it covers in depth graph concepts."
                    },
                    {
                        "username": "eairox",
                        "content": "[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]] \\n\\nshould be true but expected is false. Why is it false?\\n\\n0--------3\\n|\\n|\\n2--------1\\n|\\n|\\n4\\n\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@SanskarTyagi](/SanskarTyagi) Here\\'s how:\\nThe input is an \"adjacency list\": `[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]]` means that\\n- node `0` is connected to nodes `1`, `2`, and `3`\\n- node `1` is connected to nodes `0`, `3`, and `4`\\n- node `2` is connected to nodes `0` and `3`\\n- node `3` is connected to nodes `0`, `1`, and `2`\\n- node `4` is connected to node `1`"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  But how is 0 -- 2 connected ?? \\nthe edges have no input for 0 and 2 connection . and if we say there is connected graph because of [0,1,2] then in the first example why is 1,2,3 connected as 1- 2 \\n                           |\\n                          3\\nand not  1  -   2 \\n                 \\\\     |\\n                   \\\\   |\\n                      3"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "In your visualization there are some edges missing.  \nHere's a complete visualization of `[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]]`:\n```\n2--3\n| /|\n|/ |\n0--1--4\n```"
                    },
                    {
                        "username": "Karan108",
                        "content": "class Solution {\\nprivate:\\n    bool dfs(vector<int>adj[] , int col , vector<int>&color , int start) {\\n        color[start]=col ;\\n        for (auto it:adj[start]) {\\n            if(color[it]==-1) {\\n                dfs(adj , !col , color , it) ;\\n            } else if(color[it]==color[start]) {\\n                return false ;\\n            }\\n        }\\n        return true ;\\n    }\\npublic:\\n    bool isBipartite(vector<vector<int>>&graph) {\\n        int n=graph.size() ;\\n        int m=graph[0].size() ;\\n        vector<int>adj[n] ;\\n        for (int i =0 ; i<n ; i++) {\\n            for (int j=0 ; j<m ; j++) {\\n                if (graph[i][j]==1) {\\n                    adj[i].push_back(j) ;\\n                    adj[j].push_back(i) ;\\n                }\\n            }\\n        }\\n        vector<int>color(n,-1) ;\\n        for (int i=0 ; i<n ; i++) {\\n            if(color[i]==-1) {\\n                if (dfs(adj ,0 , color , i)==false) {\\n                    return false ;\\n                } \\n            }\\n        }\\n        return true ;\\n    }\\n};\\n\\nruntime error someone pls help\\n"
                    },
                    {
                        "username": "lakshya_rana",
                        "content": "vector<vector<int>> graph is an adjacency list so , dont make adj list just delete that part of conversion and replace adj to graph in yout code "
                    },
                    {
                        "username": "user8738ZV",
                        "content": "simply a graph color problem using two color , if we are able to color it using two colors then it is bipartite other wise it is not"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "\\n bool  isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        int m = graph[0].size();\\n        int color[n];\\n        for(int i=0;i<n;i++)color[i]=-1;\\n        for(int i=0;i<n;i++){\\n            if(color[i] == -1){\\n                color[i] = 0;\\n            }\\n            for(int j=0;j<m;j++){\\n                if(color[j] == -1){\\n                    color[j] = !color[i];\\n                    if(isBipartite(graph)==false){\\n                        return false;\\n                    }\\n                }\\n                else if(color[j] == color[i]){\\n                    return false;\\n                }\\n            }\\n\\n        }\\n        return true;\\n    }\\n\\ncan any help to find out the error in above approach of dfs traversal"
                    },
                    {
                        "username": "lakshya_rana",
                        "content": "vector<vector> graph is an adjacency list so , dont make adj list just delete that part of conversion and replace adj to graph in yout code\\n"
                    }
                ]
            },
            {
                "id": 1898603,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "This question is similiar to graph coloring.\\nTry thinking in the way of solving graph coloring of adjacent nodes."
                    },
                    {
                        "username": "champ-",
                        "content": "Why not example 1 is false?\\n\\nWhy not {0} and {1,2,3} "
                    },
                    {
                        "username": "champ-",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thank you "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The graph in example 1 is not bipartite because there are edges between 1 and 2, and between 2 and 3.   \\nIn a bipartite graph the nodes can be partitioned into two sets so that all edges only connect nodes between the two sets, not within one set. (see [wikipedia](https://en.wikipedia.org/wiki/Bipartite_graph))."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Clear explanation of Bipartite - Divide the vertices in two independent sets such that if any edges exists, they exists between the nodes in two sets and not within each set.\\nCheck wiki for image - https://en.wikipedia.org/wiki/Bipartite_graph"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "This week is a LinkedList where nodes are LinkedList and Graph...:)"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "class Solution {\\npublic:\\n\\n    bool dfs(int prev, int node, vector<int> &vis, vector<vector<int>> graph){\\n        vis[node] = prev;\\n        for(auto i:graph[node]){\\n            if(vis[i] == -1) if(!dfs(!prev,i,vis,graph)) return false;\\n            else if(vis[i] == prev) return false;\\n        }\\n        return true;\\n    }\\n\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<int> vis (n,-1);\\n        for(int i = 0; i<n ; i++){\\n            if(vis[i] == -1){\\n                if(!dfs(0,i,vis,graph)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\nit is giving true in non-biparte graph.....please help\\uD83E\\uDD79\\uD83E\\uDD72"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "[@siebenschlaefer](/siebenschlaefer)\\nthank you so much \\ngot it!!!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "An `else` belongs to the closest `if`. So the compiler interprets\n```cpp\nif (a) if (b) return result1;\nelse if (c) return result2;\n```\nas\n```cpp\nif (a) {\n    if (b) {\n        return result1;\n    } else {\n        if (c) {\n            return result2;\n        }\n    }\n}\n```\n\nBTW: To avoid unnecessary and expensive copies you might want to change the parameter `graph` of the helper function `dfs()` to a reference."
                    },
                    {
                        "username": "dreykanbern",
                        "content": "Hello everyone, I hope this is not a toxic community. Can you please tell me some material for studying graphs? Maybe a youtube channel or whatever, I feel like a helpless kitten when I see tasks like this, thanks in advance for your help!"
                    },
                    {
                        "username": "dreykanbern",
                        "content": "[@H4CE](/H4CE) Thank you so much"
                    },
                    {
                        "username": "H4CE",
                        "content": "You can follow the Graph series by takeYouForward youtube channel. It is completely in English and I think it covers in depth graph concepts."
                    },
                    {
                        "username": "eairox",
                        "content": "[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]] \\n\\nshould be true but expected is false. Why is it false?\\n\\n0--------3\\n|\\n|\\n2--------1\\n|\\n|\\n4\\n\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@SanskarTyagi](/SanskarTyagi) Here\\'s how:\\nThe input is an \"adjacency list\": `[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]]` means that\\n- node `0` is connected to nodes `1`, `2`, and `3`\\n- node `1` is connected to nodes `0`, `3`, and `4`\\n- node `2` is connected to nodes `0` and `3`\\n- node `3` is connected to nodes `0`, `1`, and `2`\\n- node `4` is connected to node `1`"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  But how is 0 -- 2 connected ?? \\nthe edges have no input for 0 and 2 connection . and if we say there is connected graph because of [0,1,2] then in the first example why is 1,2,3 connected as 1- 2 \\n                           |\\n                          3\\nand not  1  -   2 \\n                 \\\\     |\\n                   \\\\   |\\n                      3"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "In your visualization there are some edges missing.  \nHere's a complete visualization of `[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]]`:\n```\n2--3\n| /|\n|/ |\n0--1--4\n```"
                    },
                    {
                        "username": "Karan108",
                        "content": "class Solution {\\nprivate:\\n    bool dfs(vector<int>adj[] , int col , vector<int>&color , int start) {\\n        color[start]=col ;\\n        for (auto it:adj[start]) {\\n            if(color[it]==-1) {\\n                dfs(adj , !col , color , it) ;\\n            } else if(color[it]==color[start]) {\\n                return false ;\\n            }\\n        }\\n        return true ;\\n    }\\npublic:\\n    bool isBipartite(vector<vector<int>>&graph) {\\n        int n=graph.size() ;\\n        int m=graph[0].size() ;\\n        vector<int>adj[n] ;\\n        for (int i =0 ; i<n ; i++) {\\n            for (int j=0 ; j<m ; j++) {\\n                if (graph[i][j]==1) {\\n                    adj[i].push_back(j) ;\\n                    adj[j].push_back(i) ;\\n                }\\n            }\\n        }\\n        vector<int>color(n,-1) ;\\n        for (int i=0 ; i<n ; i++) {\\n            if(color[i]==-1) {\\n                if (dfs(adj ,0 , color , i)==false) {\\n                    return false ;\\n                } \\n            }\\n        }\\n        return true ;\\n    }\\n};\\n\\nruntime error someone pls help\\n"
                    },
                    {
                        "username": "lakshya_rana",
                        "content": "vector<vector<int>> graph is an adjacency list so , dont make adj list just delete that part of conversion and replace adj to graph in yout code "
                    },
                    {
                        "username": "user8738ZV",
                        "content": "simply a graph color problem using two color , if we are able to color it using two colors then it is bipartite other wise it is not"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "\\n bool  isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        int m = graph[0].size();\\n        int color[n];\\n        for(int i=0;i<n;i++)color[i]=-1;\\n        for(int i=0;i<n;i++){\\n            if(color[i] == -1){\\n                color[i] = 0;\\n            }\\n            for(int j=0;j<m;j++){\\n                if(color[j] == -1){\\n                    color[j] = !color[i];\\n                    if(isBipartite(graph)==false){\\n                        return false;\\n                    }\\n                }\\n                else if(color[j] == color[i]){\\n                    return false;\\n                }\\n            }\\n\\n        }\\n        return true;\\n    }\\n\\ncan any help to find out the error in above approach of dfs traversal"
                    },
                    {
                        "username": "lakshya_rana",
                        "content": "vector<vector> graph is an adjacency list so , dont make adj list just delete that part of conversion and replace adj to graph in yout code\\n"
                    }
                ]
            },
            {
                "id": 1898601,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "This question is similiar to graph coloring.\\nTry thinking in the way of solving graph coloring of adjacent nodes."
                    },
                    {
                        "username": "champ-",
                        "content": "Why not example 1 is false?\\n\\nWhy not {0} and {1,2,3} "
                    },
                    {
                        "username": "champ-",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thank you "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The graph in example 1 is not bipartite because there are edges between 1 and 2, and between 2 and 3.   \\nIn a bipartite graph the nodes can be partitioned into two sets so that all edges only connect nodes between the two sets, not within one set. (see [wikipedia](https://en.wikipedia.org/wiki/Bipartite_graph))."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Clear explanation of Bipartite - Divide the vertices in two independent sets such that if any edges exists, they exists between the nodes in two sets and not within each set.\\nCheck wiki for image - https://en.wikipedia.org/wiki/Bipartite_graph"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "This week is a LinkedList where nodes are LinkedList and Graph...:)"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "class Solution {\\npublic:\\n\\n    bool dfs(int prev, int node, vector<int> &vis, vector<vector<int>> graph){\\n        vis[node] = prev;\\n        for(auto i:graph[node]){\\n            if(vis[i] == -1) if(!dfs(!prev,i,vis,graph)) return false;\\n            else if(vis[i] == prev) return false;\\n        }\\n        return true;\\n    }\\n\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<int> vis (n,-1);\\n        for(int i = 0; i<n ; i++){\\n            if(vis[i] == -1){\\n                if(!dfs(0,i,vis,graph)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\nit is giving true in non-biparte graph.....please help\\uD83E\\uDD79\\uD83E\\uDD72"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "[@siebenschlaefer](/siebenschlaefer)\\nthank you so much \\ngot it!!!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "An `else` belongs to the closest `if`. So the compiler interprets\n```cpp\nif (a) if (b) return result1;\nelse if (c) return result2;\n```\nas\n```cpp\nif (a) {\n    if (b) {\n        return result1;\n    } else {\n        if (c) {\n            return result2;\n        }\n    }\n}\n```\n\nBTW: To avoid unnecessary and expensive copies you might want to change the parameter `graph` of the helper function `dfs()` to a reference."
                    },
                    {
                        "username": "dreykanbern",
                        "content": "Hello everyone, I hope this is not a toxic community. Can you please tell me some material for studying graphs? Maybe a youtube channel or whatever, I feel like a helpless kitten when I see tasks like this, thanks in advance for your help!"
                    },
                    {
                        "username": "dreykanbern",
                        "content": "[@H4CE](/H4CE) Thank you so much"
                    },
                    {
                        "username": "H4CE",
                        "content": "You can follow the Graph series by takeYouForward youtube channel. It is completely in English and I think it covers in depth graph concepts."
                    },
                    {
                        "username": "eairox",
                        "content": "[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]] \\n\\nshould be true but expected is false. Why is it false?\\n\\n0--------3\\n|\\n|\\n2--------1\\n|\\n|\\n4\\n\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@SanskarTyagi](/SanskarTyagi) Here\\'s how:\\nThe input is an \"adjacency list\": `[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]]` means that\\n- node `0` is connected to nodes `1`, `2`, and `3`\\n- node `1` is connected to nodes `0`, `3`, and `4`\\n- node `2` is connected to nodes `0` and `3`\\n- node `3` is connected to nodes `0`, `1`, and `2`\\n- node `4` is connected to node `1`"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  But how is 0 -- 2 connected ?? \\nthe edges have no input for 0 and 2 connection . and if we say there is connected graph because of [0,1,2] then in the first example why is 1,2,3 connected as 1- 2 \\n                           |\\n                          3\\nand not  1  -   2 \\n                 \\\\     |\\n                   \\\\   |\\n                      3"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "In your visualization there are some edges missing.  \nHere's a complete visualization of `[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]]`:\n```\n2--3\n| /|\n|/ |\n0--1--4\n```"
                    },
                    {
                        "username": "Karan108",
                        "content": "class Solution {\\nprivate:\\n    bool dfs(vector<int>adj[] , int col , vector<int>&color , int start) {\\n        color[start]=col ;\\n        for (auto it:adj[start]) {\\n            if(color[it]==-1) {\\n                dfs(adj , !col , color , it) ;\\n            } else if(color[it]==color[start]) {\\n                return false ;\\n            }\\n        }\\n        return true ;\\n    }\\npublic:\\n    bool isBipartite(vector<vector<int>>&graph) {\\n        int n=graph.size() ;\\n        int m=graph[0].size() ;\\n        vector<int>adj[n] ;\\n        for (int i =0 ; i<n ; i++) {\\n            for (int j=0 ; j<m ; j++) {\\n                if (graph[i][j]==1) {\\n                    adj[i].push_back(j) ;\\n                    adj[j].push_back(i) ;\\n                }\\n            }\\n        }\\n        vector<int>color(n,-1) ;\\n        for (int i=0 ; i<n ; i++) {\\n            if(color[i]==-1) {\\n                if (dfs(adj ,0 , color , i)==false) {\\n                    return false ;\\n                } \\n            }\\n        }\\n        return true ;\\n    }\\n};\\n\\nruntime error someone pls help\\n"
                    },
                    {
                        "username": "lakshya_rana",
                        "content": "vector<vector<int>> graph is an adjacency list so , dont make adj list just delete that part of conversion and replace adj to graph in yout code "
                    },
                    {
                        "username": "user8738ZV",
                        "content": "simply a graph color problem using two color , if we are able to color it using two colors then it is bipartite other wise it is not"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "\\n bool  isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        int m = graph[0].size();\\n        int color[n];\\n        for(int i=0;i<n;i++)color[i]=-1;\\n        for(int i=0;i<n;i++){\\n            if(color[i] == -1){\\n                color[i] = 0;\\n            }\\n            for(int j=0;j<m;j++){\\n                if(color[j] == -1){\\n                    color[j] = !color[i];\\n                    if(isBipartite(graph)==false){\\n                        return false;\\n                    }\\n                }\\n                else if(color[j] == color[i]){\\n                    return false;\\n                }\\n            }\\n\\n        }\\n        return true;\\n    }\\n\\ncan any help to find out the error in above approach of dfs traversal"
                    },
                    {
                        "username": "lakshya_rana",
                        "content": "vector<vector> graph is an adjacency list so , dont make adj list just delete that part of conversion and replace adj to graph in yout code\\n"
                    }
                ]
            },
            {
                "id": 1882671,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "This question is similiar to graph coloring.\\nTry thinking in the way of solving graph coloring of adjacent nodes."
                    },
                    {
                        "username": "champ-",
                        "content": "Why not example 1 is false?\\n\\nWhy not {0} and {1,2,3} "
                    },
                    {
                        "username": "champ-",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thank you "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The graph in example 1 is not bipartite because there are edges between 1 and 2, and between 2 and 3.   \\nIn a bipartite graph the nodes can be partitioned into two sets so that all edges only connect nodes between the two sets, not within one set. (see [wikipedia](https://en.wikipedia.org/wiki/Bipartite_graph))."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Clear explanation of Bipartite - Divide the vertices in two independent sets such that if any edges exists, they exists between the nodes in two sets and not within each set.\\nCheck wiki for image - https://en.wikipedia.org/wiki/Bipartite_graph"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "This week is a LinkedList where nodes are LinkedList and Graph...:)"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "class Solution {\\npublic:\\n\\n    bool dfs(int prev, int node, vector<int> &vis, vector<vector<int>> graph){\\n        vis[node] = prev;\\n        for(auto i:graph[node]){\\n            if(vis[i] == -1) if(!dfs(!prev,i,vis,graph)) return false;\\n            else if(vis[i] == prev) return false;\\n        }\\n        return true;\\n    }\\n\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<int> vis (n,-1);\\n        for(int i = 0; i<n ; i++){\\n            if(vis[i] == -1){\\n                if(!dfs(0,i,vis,graph)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\nit is giving true in non-biparte graph.....please help\\uD83E\\uDD79\\uD83E\\uDD72"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "[@siebenschlaefer](/siebenschlaefer)\\nthank you so much \\ngot it!!!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "An `else` belongs to the closest `if`. So the compiler interprets\n```cpp\nif (a) if (b) return result1;\nelse if (c) return result2;\n```\nas\n```cpp\nif (a) {\n    if (b) {\n        return result1;\n    } else {\n        if (c) {\n            return result2;\n        }\n    }\n}\n```\n\nBTW: To avoid unnecessary and expensive copies you might want to change the parameter `graph` of the helper function `dfs()` to a reference."
                    },
                    {
                        "username": "dreykanbern",
                        "content": "Hello everyone, I hope this is not a toxic community. Can you please tell me some material for studying graphs? Maybe a youtube channel or whatever, I feel like a helpless kitten when I see tasks like this, thanks in advance for your help!"
                    },
                    {
                        "username": "dreykanbern",
                        "content": "[@H4CE](/H4CE) Thank you so much"
                    },
                    {
                        "username": "H4CE",
                        "content": "You can follow the Graph series by takeYouForward youtube channel. It is completely in English and I think it covers in depth graph concepts."
                    },
                    {
                        "username": "eairox",
                        "content": "[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]] \\n\\nshould be true but expected is false. Why is it false?\\n\\n0--------3\\n|\\n|\\n2--------1\\n|\\n|\\n4\\n\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@SanskarTyagi](/SanskarTyagi) Here\\'s how:\\nThe input is an \"adjacency list\": `[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]]` means that\\n- node `0` is connected to nodes `1`, `2`, and `3`\\n- node `1` is connected to nodes `0`, `3`, and `4`\\n- node `2` is connected to nodes `0` and `3`\\n- node `3` is connected to nodes `0`, `1`, and `2`\\n- node `4` is connected to node `1`"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  But how is 0 -- 2 connected ?? \\nthe edges have no input for 0 and 2 connection . and if we say there is connected graph because of [0,1,2] then in the first example why is 1,2,3 connected as 1- 2 \\n                           |\\n                          3\\nand not  1  -   2 \\n                 \\\\     |\\n                   \\\\   |\\n                      3"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "In your visualization there are some edges missing.  \nHere's a complete visualization of `[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]]`:\n```\n2--3\n| /|\n|/ |\n0--1--4\n```"
                    },
                    {
                        "username": "Karan108",
                        "content": "class Solution {\\nprivate:\\n    bool dfs(vector<int>adj[] , int col , vector<int>&color , int start) {\\n        color[start]=col ;\\n        for (auto it:adj[start]) {\\n            if(color[it]==-1) {\\n                dfs(adj , !col , color , it) ;\\n            } else if(color[it]==color[start]) {\\n                return false ;\\n            }\\n        }\\n        return true ;\\n    }\\npublic:\\n    bool isBipartite(vector<vector<int>>&graph) {\\n        int n=graph.size() ;\\n        int m=graph[0].size() ;\\n        vector<int>adj[n] ;\\n        for (int i =0 ; i<n ; i++) {\\n            for (int j=0 ; j<m ; j++) {\\n                if (graph[i][j]==1) {\\n                    adj[i].push_back(j) ;\\n                    adj[j].push_back(i) ;\\n                }\\n            }\\n        }\\n        vector<int>color(n,-1) ;\\n        for (int i=0 ; i<n ; i++) {\\n            if(color[i]==-1) {\\n                if (dfs(adj ,0 , color , i)==false) {\\n                    return false ;\\n                } \\n            }\\n        }\\n        return true ;\\n    }\\n};\\n\\nruntime error someone pls help\\n"
                    },
                    {
                        "username": "lakshya_rana",
                        "content": "vector<vector<int>> graph is an adjacency list so , dont make adj list just delete that part of conversion and replace adj to graph in yout code "
                    },
                    {
                        "username": "user8738ZV",
                        "content": "simply a graph color problem using two color , if we are able to color it using two colors then it is bipartite other wise it is not"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "\\n bool  isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        int m = graph[0].size();\\n        int color[n];\\n        for(int i=0;i<n;i++)color[i]=-1;\\n        for(int i=0;i<n;i++){\\n            if(color[i] == -1){\\n                color[i] = 0;\\n            }\\n            for(int j=0;j<m;j++){\\n                if(color[j] == -1){\\n                    color[j] = !color[i];\\n                    if(isBipartite(graph)==false){\\n                        return false;\\n                    }\\n                }\\n                else if(color[j] == color[i]){\\n                    return false;\\n                }\\n            }\\n\\n        }\\n        return true;\\n    }\\n\\ncan any help to find out the error in above approach of dfs traversal"
                    },
                    {
                        "username": "lakshya_rana",
                        "content": "vector<vector> graph is an adjacency list so , dont make adj list just delete that part of conversion and replace adj to graph in yout code\\n"
                    }
                ]
            },
            {
                "id": 1804151,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "This question is similiar to graph coloring.\\nTry thinking in the way of solving graph coloring of adjacent nodes."
                    },
                    {
                        "username": "champ-",
                        "content": "Why not example 1 is false?\\n\\nWhy not {0} and {1,2,3} "
                    },
                    {
                        "username": "champ-",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thank you "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The graph in example 1 is not bipartite because there are edges between 1 and 2, and between 2 and 3.   \\nIn a bipartite graph the nodes can be partitioned into two sets so that all edges only connect nodes between the two sets, not within one set. (see [wikipedia](https://en.wikipedia.org/wiki/Bipartite_graph))."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Clear explanation of Bipartite - Divide the vertices in two independent sets such that if any edges exists, they exists between the nodes in two sets and not within each set.\\nCheck wiki for image - https://en.wikipedia.org/wiki/Bipartite_graph"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "This week is a LinkedList where nodes are LinkedList and Graph...:)"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "class Solution {\\npublic:\\n\\n    bool dfs(int prev, int node, vector<int> &vis, vector<vector<int>> graph){\\n        vis[node] = prev;\\n        for(auto i:graph[node]){\\n            if(vis[i] == -1) if(!dfs(!prev,i,vis,graph)) return false;\\n            else if(vis[i] == prev) return false;\\n        }\\n        return true;\\n    }\\n\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<int> vis (n,-1);\\n        for(int i = 0; i<n ; i++){\\n            if(vis[i] == -1){\\n                if(!dfs(0,i,vis,graph)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\nit is giving true in non-biparte graph.....please help\\uD83E\\uDD79\\uD83E\\uDD72"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "[@siebenschlaefer](/siebenschlaefer)\\nthank you so much \\ngot it!!!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "An `else` belongs to the closest `if`. So the compiler interprets\n```cpp\nif (a) if (b) return result1;\nelse if (c) return result2;\n```\nas\n```cpp\nif (a) {\n    if (b) {\n        return result1;\n    } else {\n        if (c) {\n            return result2;\n        }\n    }\n}\n```\n\nBTW: To avoid unnecessary and expensive copies you might want to change the parameter `graph` of the helper function `dfs()` to a reference."
                    },
                    {
                        "username": "dreykanbern",
                        "content": "Hello everyone, I hope this is not a toxic community. Can you please tell me some material for studying graphs? Maybe a youtube channel or whatever, I feel like a helpless kitten when I see tasks like this, thanks in advance for your help!"
                    },
                    {
                        "username": "dreykanbern",
                        "content": "[@H4CE](/H4CE) Thank you so much"
                    },
                    {
                        "username": "H4CE",
                        "content": "You can follow the Graph series by takeYouForward youtube channel. It is completely in English and I think it covers in depth graph concepts."
                    },
                    {
                        "username": "eairox",
                        "content": "[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]] \\n\\nshould be true but expected is false. Why is it false?\\n\\n0--------3\\n|\\n|\\n2--------1\\n|\\n|\\n4\\n\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@SanskarTyagi](/SanskarTyagi) Here\\'s how:\\nThe input is an \"adjacency list\": `[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]]` means that\\n- node `0` is connected to nodes `1`, `2`, and `3`\\n- node `1` is connected to nodes `0`, `3`, and `4`\\n- node `2` is connected to nodes `0` and `3`\\n- node `3` is connected to nodes `0`, `1`, and `2`\\n- node `4` is connected to node `1`"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  But how is 0 -- 2 connected ?? \\nthe edges have no input for 0 and 2 connection . and if we say there is connected graph because of [0,1,2] then in the first example why is 1,2,3 connected as 1- 2 \\n                           |\\n                          3\\nand not  1  -   2 \\n                 \\\\     |\\n                   \\\\   |\\n                      3"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "In your visualization there are some edges missing.  \nHere's a complete visualization of `[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]]`:\n```\n2--3\n| /|\n|/ |\n0--1--4\n```"
                    },
                    {
                        "username": "Karan108",
                        "content": "class Solution {\\nprivate:\\n    bool dfs(vector<int>adj[] , int col , vector<int>&color , int start) {\\n        color[start]=col ;\\n        for (auto it:adj[start]) {\\n            if(color[it]==-1) {\\n                dfs(adj , !col , color , it) ;\\n            } else if(color[it]==color[start]) {\\n                return false ;\\n            }\\n        }\\n        return true ;\\n    }\\npublic:\\n    bool isBipartite(vector<vector<int>>&graph) {\\n        int n=graph.size() ;\\n        int m=graph[0].size() ;\\n        vector<int>adj[n] ;\\n        for (int i =0 ; i<n ; i++) {\\n            for (int j=0 ; j<m ; j++) {\\n                if (graph[i][j]==1) {\\n                    adj[i].push_back(j) ;\\n                    adj[j].push_back(i) ;\\n                }\\n            }\\n        }\\n        vector<int>color(n,-1) ;\\n        for (int i=0 ; i<n ; i++) {\\n            if(color[i]==-1) {\\n                if (dfs(adj ,0 , color , i)==false) {\\n                    return false ;\\n                } \\n            }\\n        }\\n        return true ;\\n    }\\n};\\n\\nruntime error someone pls help\\n"
                    },
                    {
                        "username": "lakshya_rana",
                        "content": "vector<vector<int>> graph is an adjacency list so , dont make adj list just delete that part of conversion and replace adj to graph in yout code "
                    },
                    {
                        "username": "user8738ZV",
                        "content": "simply a graph color problem using two color , if we are able to color it using two colors then it is bipartite other wise it is not"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "\\n bool  isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        int m = graph[0].size();\\n        int color[n];\\n        for(int i=0;i<n;i++)color[i]=-1;\\n        for(int i=0;i<n;i++){\\n            if(color[i] == -1){\\n                color[i] = 0;\\n            }\\n            for(int j=0;j<m;j++){\\n                if(color[j] == -1){\\n                    color[j] = !color[i];\\n                    if(isBipartite(graph)==false){\\n                        return false;\\n                    }\\n                }\\n                else if(color[j] == color[i]){\\n                    return false;\\n                }\\n            }\\n\\n        }\\n        return true;\\n    }\\n\\ncan any help to find out the error in above approach of dfs traversal"
                    },
                    {
                        "username": "lakshya_rana",
                        "content": "vector<vector> graph is an adjacency list so , dont make adj list just delete that part of conversion and replace adj to graph in yout code\\n"
                    }
                ]
            },
            {
                "id": 1773811,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "This question is similiar to graph coloring.\\nTry thinking in the way of solving graph coloring of adjacent nodes."
                    },
                    {
                        "username": "champ-",
                        "content": "Why not example 1 is false?\\n\\nWhy not {0} and {1,2,3} "
                    },
                    {
                        "username": "champ-",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thank you "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The graph in example 1 is not bipartite because there are edges between 1 and 2, and between 2 and 3.   \\nIn a bipartite graph the nodes can be partitioned into two sets so that all edges only connect nodes between the two sets, not within one set. (see [wikipedia](https://en.wikipedia.org/wiki/Bipartite_graph))."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Clear explanation of Bipartite - Divide the vertices in two independent sets such that if any edges exists, they exists between the nodes in two sets and not within each set.\\nCheck wiki for image - https://en.wikipedia.org/wiki/Bipartite_graph"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "This week is a LinkedList where nodes are LinkedList and Graph...:)"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "class Solution {\\npublic:\\n\\n    bool dfs(int prev, int node, vector<int> &vis, vector<vector<int>> graph){\\n        vis[node] = prev;\\n        for(auto i:graph[node]){\\n            if(vis[i] == -1) if(!dfs(!prev,i,vis,graph)) return false;\\n            else if(vis[i] == prev) return false;\\n        }\\n        return true;\\n    }\\n\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<int> vis (n,-1);\\n        for(int i = 0; i<n ; i++){\\n            if(vis[i] == -1){\\n                if(!dfs(0,i,vis,graph)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\nit is giving true in non-biparte graph.....please help\\uD83E\\uDD79\\uD83E\\uDD72"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "[@siebenschlaefer](/siebenschlaefer)\\nthank you so much \\ngot it!!!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "An `else` belongs to the closest `if`. So the compiler interprets\n```cpp\nif (a) if (b) return result1;\nelse if (c) return result2;\n```\nas\n```cpp\nif (a) {\n    if (b) {\n        return result1;\n    } else {\n        if (c) {\n            return result2;\n        }\n    }\n}\n```\n\nBTW: To avoid unnecessary and expensive copies you might want to change the parameter `graph` of the helper function `dfs()` to a reference."
                    },
                    {
                        "username": "dreykanbern",
                        "content": "Hello everyone, I hope this is not a toxic community. Can you please tell me some material for studying graphs? Maybe a youtube channel or whatever, I feel like a helpless kitten when I see tasks like this, thanks in advance for your help!"
                    },
                    {
                        "username": "dreykanbern",
                        "content": "[@H4CE](/H4CE) Thank you so much"
                    },
                    {
                        "username": "H4CE",
                        "content": "You can follow the Graph series by takeYouForward youtube channel. It is completely in English and I think it covers in depth graph concepts."
                    },
                    {
                        "username": "eairox",
                        "content": "[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]] \\n\\nshould be true but expected is false. Why is it false?\\n\\n0--------3\\n|\\n|\\n2--------1\\n|\\n|\\n4\\n\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@SanskarTyagi](/SanskarTyagi) Here\\'s how:\\nThe input is an \"adjacency list\": `[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]]` means that\\n- node `0` is connected to nodes `1`, `2`, and `3`\\n- node `1` is connected to nodes `0`, `3`, and `4`\\n- node `2` is connected to nodes `0` and `3`\\n- node `3` is connected to nodes `0`, `1`, and `2`\\n- node `4` is connected to node `1`"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  But how is 0 -- 2 connected ?? \\nthe edges have no input for 0 and 2 connection . and if we say there is connected graph because of [0,1,2] then in the first example why is 1,2,3 connected as 1- 2 \\n                           |\\n                          3\\nand not  1  -   2 \\n                 \\\\     |\\n                   \\\\   |\\n                      3"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "In your visualization there are some edges missing.  \nHere's a complete visualization of `[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]]`:\n```\n2--3\n| /|\n|/ |\n0--1--4\n```"
                    },
                    {
                        "username": "Karan108",
                        "content": "class Solution {\\nprivate:\\n    bool dfs(vector<int>adj[] , int col , vector<int>&color , int start) {\\n        color[start]=col ;\\n        for (auto it:adj[start]) {\\n            if(color[it]==-1) {\\n                dfs(adj , !col , color , it) ;\\n            } else if(color[it]==color[start]) {\\n                return false ;\\n            }\\n        }\\n        return true ;\\n    }\\npublic:\\n    bool isBipartite(vector<vector<int>>&graph) {\\n        int n=graph.size() ;\\n        int m=graph[0].size() ;\\n        vector<int>adj[n] ;\\n        for (int i =0 ; i<n ; i++) {\\n            for (int j=0 ; j<m ; j++) {\\n                if (graph[i][j]==1) {\\n                    adj[i].push_back(j) ;\\n                    adj[j].push_back(i) ;\\n                }\\n            }\\n        }\\n        vector<int>color(n,-1) ;\\n        for (int i=0 ; i<n ; i++) {\\n            if(color[i]==-1) {\\n                if (dfs(adj ,0 , color , i)==false) {\\n                    return false ;\\n                } \\n            }\\n        }\\n        return true ;\\n    }\\n};\\n\\nruntime error someone pls help\\n"
                    },
                    {
                        "username": "lakshya_rana",
                        "content": "vector<vector<int>> graph is an adjacency list so , dont make adj list just delete that part of conversion and replace adj to graph in yout code "
                    },
                    {
                        "username": "user8738ZV",
                        "content": "simply a graph color problem using two color , if we are able to color it using two colors then it is bipartite other wise it is not"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "\\n bool  isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        int m = graph[0].size();\\n        int color[n];\\n        for(int i=0;i<n;i++)color[i]=-1;\\n        for(int i=0;i<n;i++){\\n            if(color[i] == -1){\\n                color[i] = 0;\\n            }\\n            for(int j=0;j<m;j++){\\n                if(color[j] == -1){\\n                    color[j] = !color[i];\\n                    if(isBipartite(graph)==false){\\n                        return false;\\n                    }\\n                }\\n                else if(color[j] == color[i]){\\n                    return false;\\n                }\\n            }\\n\\n        }\\n        return true;\\n    }\\n\\ncan any help to find out the error in above approach of dfs traversal"
                    },
                    {
                        "username": "lakshya_rana",
                        "content": "vector<vector> graph is an adjacency list so , dont make adj list just delete that part of conversion and replace adj to graph in yout code\\n"
                    }
                ]
            },
            {
                "id": 1737164,
                "content": [
                    {
                        "username": "Indraneel965",
                        "content": "This question is similiar to graph coloring.\\nTry thinking in the way of solving graph coloring of adjacent nodes."
                    },
                    {
                        "username": "champ-",
                        "content": "Why not example 1 is false?\\n\\nWhy not {0} and {1,2,3} "
                    },
                    {
                        "username": "champ-",
                        "content": "[@siebenschlaefer](/siebenschlaefer) thank you "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The graph in example 1 is not bipartite because there are edges between 1 and 2, and between 2 and 3.   \\nIn a bipartite graph the nodes can be partitioned into two sets so that all edges only connect nodes between the two sets, not within one set. (see [wikipedia](https://en.wikipedia.org/wiki/Bipartite_graph))."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Clear explanation of Bipartite - Divide the vertices in two independent sets such that if any edges exists, they exists between the nodes in two sets and not within each set.\\nCheck wiki for image - https://en.wikipedia.org/wiki/Bipartite_graph"
                    },
                    {
                        "username": "anubhavanand",
                        "content": "This week is a LinkedList where nodes are LinkedList and Graph...:)"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "class Solution {\\npublic:\\n\\n    bool dfs(int prev, int node, vector<int> &vis, vector<vector<int>> graph){\\n        vis[node] = prev;\\n        for(auto i:graph[node]){\\n            if(vis[i] == -1) if(!dfs(!prev,i,vis,graph)) return false;\\n            else if(vis[i] == prev) return false;\\n        }\\n        return true;\\n    }\\n\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        vector<int> vis (n,-1);\\n        for(int i = 0; i<n ; i++){\\n            if(vis[i] == -1){\\n                if(!dfs(0,i,vis,graph)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\nit is giving true in non-biparte graph.....please help\\uD83E\\uDD79\\uD83E\\uDD72"
                    },
                    {
                        "username": "jappi_jsl",
                        "content": "[@siebenschlaefer](/siebenschlaefer)\\nthank you so much \\ngot it!!!"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "An `else` belongs to the closest `if`. So the compiler interprets\n```cpp\nif (a) if (b) return result1;\nelse if (c) return result2;\n```\nas\n```cpp\nif (a) {\n    if (b) {\n        return result1;\n    } else {\n        if (c) {\n            return result2;\n        }\n    }\n}\n```\n\nBTW: To avoid unnecessary and expensive copies you might want to change the parameter `graph` of the helper function `dfs()` to a reference."
                    },
                    {
                        "username": "dreykanbern",
                        "content": "Hello everyone, I hope this is not a toxic community. Can you please tell me some material for studying graphs? Maybe a youtube channel or whatever, I feel like a helpless kitten when I see tasks like this, thanks in advance for your help!"
                    },
                    {
                        "username": "dreykanbern",
                        "content": "[@H4CE](/H4CE) Thank you so much"
                    },
                    {
                        "username": "H4CE",
                        "content": "You can follow the Graph series by takeYouForward youtube channel. It is completely in English and I think it covers in depth graph concepts."
                    },
                    {
                        "username": "eairox",
                        "content": "[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]] \\n\\nshould be true but expected is false. Why is it false?\\n\\n0--------3\\n|\\n|\\n2--------1\\n|\\n|\\n4\\n\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "[@SanskarTyagi](/SanskarTyagi) Here\\'s how:\\nThe input is an \"adjacency list\": `[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]]` means that\\n- node `0` is connected to nodes `1`, `2`, and `3`\\n- node `1` is connected to nodes `0`, `3`, and `4`\\n- node `2` is connected to nodes `0` and `3`\\n- node `3` is connected to nodes `0`, `1`, and `2`\\n- node `4` is connected to node `1`"
                    },
                    {
                        "username": "SanskarTyagi",
                        "content": "[@siebenschlaefer](/siebenschlaefer)  But how is 0 -- 2 connected ?? \\nthe edges have no input for 0 and 2 connection . and if we say there is connected graph because of [0,1,2] then in the first example why is 1,2,3 connected as 1- 2 \\n                           |\\n                          3\\nand not  1  -   2 \\n                 \\\\     |\\n                   \\\\   |\\n                      3"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "In your visualization there are some edges missing.  \nHere's a complete visualization of `[[1,2,3],[0,3,4],[0,3],[0,1,2],[1]]`:\n```\n2--3\n| /|\n|/ |\n0--1--4\n```"
                    },
                    {
                        "username": "Karan108",
                        "content": "class Solution {\\nprivate:\\n    bool dfs(vector<int>adj[] , int col , vector<int>&color , int start) {\\n        color[start]=col ;\\n        for (auto it:adj[start]) {\\n            if(color[it]==-1) {\\n                dfs(adj , !col , color , it) ;\\n            } else if(color[it]==color[start]) {\\n                return false ;\\n            }\\n        }\\n        return true ;\\n    }\\npublic:\\n    bool isBipartite(vector<vector<int>>&graph) {\\n        int n=graph.size() ;\\n        int m=graph[0].size() ;\\n        vector<int>adj[n] ;\\n        for (int i =0 ; i<n ; i++) {\\n            for (int j=0 ; j<m ; j++) {\\n                if (graph[i][j]==1) {\\n                    adj[i].push_back(j) ;\\n                    adj[j].push_back(i) ;\\n                }\\n            }\\n        }\\n        vector<int>color(n,-1) ;\\n        for (int i=0 ; i<n ; i++) {\\n            if(color[i]==-1) {\\n                if (dfs(adj ,0 , color , i)==false) {\\n                    return false ;\\n                } \\n            }\\n        }\\n        return true ;\\n    }\\n};\\n\\nruntime error someone pls help\\n"
                    },
                    {
                        "username": "lakshya_rana",
                        "content": "vector<vector<int>> graph is an adjacency list so , dont make adj list just delete that part of conversion and replace adj to graph in yout code "
                    },
                    {
                        "username": "user8738ZV",
                        "content": "simply a graph color problem using two color , if we are able to color it using two colors then it is bipartite other wise it is not"
                    },
                    {
                        "username": "SpidyCoder_1",
                        "content": "\\n bool  isBipartite(vector<vector<int>>& graph) {\\n        int n = graph.size();\\n        int m = graph[0].size();\\n        int color[n];\\n        for(int i=0;i<n;i++)color[i]=-1;\\n        for(int i=0;i<n;i++){\\n            if(color[i] == -1){\\n                color[i] = 0;\\n            }\\n            for(int j=0;j<m;j++){\\n                if(color[j] == -1){\\n                    color[j] = !color[i];\\n                    if(isBipartite(graph)==false){\\n                        return false;\\n                    }\\n                }\\n                else if(color[j] == color[i]){\\n                    return false;\\n                }\\n            }\\n\\n        }\\n        return true;\\n    }\\n\\ncan any help to find out the error in above approach of dfs traversal"
                    },
                    {
                        "username": "lakshya_rana",
                        "content": "vector<vector> graph is an adjacency list so , dont make adj list just delete that part of conversion and replace adj to graph in yout code\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "K-th Smallest Prime Fraction",
        "question_content": "<p>You are given a sorted integer array <code>arr</code> containing <code>1</code> and <strong>prime</strong> numbers, where all the integers of <code>arr</code> are unique. You are also given an integer <code>k</code>.</p>\n\n<p>For every <code>i</code> and <code>j</code> where <code>0 &lt;= i &lt; j &lt; arr.length</code>, we consider the fraction <code>arr[i] / arr[j]</code>.</p>\n\n<p>Return <em>the</em> <code>k<sup>th</sup></code> <em>smallest fraction considered</em>. Return your answer as an array of integers of size <code>2</code>, where <code>answer[0] == arr[i]</code> and <code>answer[1] == arr[j]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [1,2,3,5], k = 3\n<strong>Output:</strong> [2,5]\n<strong>Explanation:</strong> The fractions to be considered in sorted order are:\n1/5, 1/3, 2/5, 1/2, 3/5, and 2/3.\nThe third fraction is 2/5.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [1,7], k = 1\n<strong>Output:</strong> [1,7]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>arr[0] == 1</code></li>\n\t<li><code>arr[i]</code> is a <strong>prime</strong> number for <code>i &gt; 0</code>.</li>\n\t<li>All the numbers of <code>arr</code> are <strong>unique</strong> and sorted in <strong>strictly increasing</strong> order.</li>\n\t<li><code>1 &lt;= k &lt;= arr.length * (arr.length - 1) / 2</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Can you solve the problem with better than <code>O(n<sup>2</sup>)</code> complexity?",
        "solutions": [
            {
                "id": 115819,
                "title": "summary-of-solutions-for-problems-reducible-to-leetcode-378",
                "content": "This post is a quick summary of all common solutions applicable to problems similar to [*378. Kth Smallest Element in a Sorted Matrix*](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/), where we are given an `n x n` matrix with each of the rows and columns sorted in ascending order, and need to find the `kth` smallest element in the matrix. \\n\\nFor your reference, the following is a list of LeetCode problems that can be transformed into problems equivalent to finding the *\"Kth Smallest Element in a Sorted Matrix\"* and thus can be solved effectively using the algorithms developed here:\\n\\n1. [373. Find K Pairs with Smallest Sums](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/description/)\\n2. [378. Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/)\\n3. [668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\\n4. [719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/)\\n5. [786. K-th Smallest Prime Fraction](https://leetcode.com/problems/k-th-smallest-prime-fraction/description/)\\n\\nThis list may not be complete and you\\'re welcome to add more examples. Also if you\\'re only interested in solutions to this problem (i.e., `786. K-th Smallest Prime Fraction`), you may go directly to the last section (section `VIII`) where I have listed a couple of solutions as demonstrations to algorithms that will be derived shortly.\\n\\n---\\n\\n**`I -- Sorting-based solution`**\\n\\nThis is the most straightforward solution, where we put all the elements in the matrix into an array and sort it in ascending order, then the `kth` smallest element in the matrix will be the one at index `k-1` of the array. Here is a quick demonstration of this algorithm:\\n\\n<br>\\n\\n```\\npublic int kthSmallest(int[][] matrix, int k) {\\n    int n = matrix.length, i = 0;\\n    \\n    int[] nums = new int[n * n];\\n    \\n    for (int[] row : matrix) {\\n        for (int ele : row) {\\n            nums[i++] = ele;\\n        }\\n    }\\n    \\n    Arrays.sort(nums);\\n    \\n    return nums[k - 1];\\n}\\n```\\n\\n<br>\\n\\nTime complexity: `O(n^2 * log(n^2))`\\nSpace complexity: `O(n^2)`\\n\\nAs expected, this naive solution is not very performant in terms of time (due to sorting) and space (due to the extra array) complexities, so let\\'s see how we may improve it and derive more efficient algorithms.\\n\\n---\\n\\n**`II -- PriorityQueue-based solution`**\\n\\nOne observation here is that we don\\'t need to keep track of all the `n^2` elements since only the `kth` smallest element is required. We may maintain a `PriorityQueue` with size `k` to track only the `k` smallest elements in the matrix. At the end, the `kth` smallest element in the matrix will be the largest one in the `PriorityQueue`. Here is an implementation of this idea:\\n\\n<br>\\n\\n```\\npublic int kthSmallest(int[][] matrix, int k) {\\n    PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n    \\n    for (int[] row : matrix) {\\n        for (int ele : row) {\\n            pq.offer(ele);\\n            \\n            if (pq.size() > k) {\\n                pq.poll();\\n            }\\n        }\\n    }\\n    \\n    return pq.peek();\\n}\\n```\\n\\n<br>\\n\\nTime complexity: `O(n^2 * logk)`\\nSpace complexity: `O(k)`\\n\\nThough in the worst case (`k = n^2`), the time and space complexities of this solution are the same as those of the naive solution above, we are still able to achieve slight performance gains for average cases where `k` is generally smaller compared to `n^2`.\\n\\n---\\n\\n**`III -- PriorityQueue-based solution with optimization`**\\n\\nUp to this point, you may notice that the above two solutions actually apply to arbitrary matrices -- they will find the `kth` smallest element in the matrix whether or not its rows or columns are sorted. What happens if we take advantage of the sorted properties of the matrix?\\n\\nWell, I have yet to mention another straightforward way for finding the `kth` smallest element in the matrix: if we keep removing the smallest element from the matrix for `k-1` times, then after removing, the smallest element now in the matrix will be the `kth` smallest element we are looking for. \\n\\nIf the elements in the matrix are in random order, we have no better ways for finding and removing the smallest elements in the matrix other than adding all elements to a `PriorityQueue`. This will yield a time (and space) complexity no better, if not worse, than that of the naive solution. However, with the rows (or columns) of the matrix sorted, we don\\'t have to add all elements to the `PriorityQueue` at once. Instead, we can create a pool of candidate elements as long as we can ensure that it contains the smallest element of the matrix (even after removing). \\n\\nAssume the rows are sorted in ascending order, which implies initially the smallest element of the matrix must be within the first column, therefore the pool can be initialized with elements from the first column. Now as we are extracting and removing smallest elements from the pool, we need to supplement more candiate elements. The key observation here is that for each extracted element, it suffices to add to the pool only the element immediately following it in the same row, without violating the property that the pool always contains the smallest element of the matrix (even after removing). The following is a solution based on this idea:\\n\\n<br>\\n\\n```\\npublic int kthSmallest(int[][] matrix, int k) {\\n    PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>() {\\n        public int compare(int[] a, int[] b) { // (a[0], a[1]) and (b[0], b[1]) are positions in the matrix\\n            return Integer.compare(matrix[a[0]][a[1]], matrix[b[0]][b[1]]);\\n        }\\n    });\\n    \\n    int n = matrix.length;\\n    \\n    for (int i = 0; i < n; i++) {\\n        pq.offer(new int[] {i, 0});  // initialize the pool with elements from the first column\\n    }\\n    \\n    while (--k > 0) {                // remove the smallest elements from the matrix (k-1) times\\n        int[] p = pq.poll();\\n        \\n        if (++p[1] < n) {\\n            pq.offer(p);             // add the next element in the same row if it exists\\n        }\\n    }\\n    \\n    return matrix[pq.peek()[0]][pq.peek()[1]];\\n}\\n```\\n\\n<br>\\n\\nTime complexity: `O(max(n, k) * logn)`\\nSpace complexity: `O(n)`\\n\\nNote that by making use of the sorted properties of the matrix, we were able to cut down the space complexity to `O(n)` and achieve a slightly better time complexity compared to that of the naive solution (though the worst case is the same).\\n\\n---\\n\\n**`IV -- BinarySearch-based solution`**\\n\\nThe binary search solution is essentially a special case of the more general \"trial and error\" algorithm described in my other [post](https://leetcode.com/problems/find-k-th-smallest-pair-distance/discuss/109082/Approach-the-problem-using-the-%22trial-and-error%22-algorithm), where I have summarized the algorithm\\'s key ideas and demonstrated them for `LeetCode 719`. I would recommend you read at least the beginning part to get familiar with the terminologies that will be used here.\\n\\n<br>\\n\\n**The candidate solution**: in this case, the cadidate solution is simply an integer.\\n\\n**The search space**: in this case, the search space is given by `[MIN, MAX]`, where `MIN` and `MAX` are the minimum and maximum elements in the matrix, respectively. \\n\\n**The traverse method**: in this case, we can do a binary search since the search space is sorted naturally in ascending order (this also accounts for the name \"BinarySearch-based solution\").\\n\\n**The verification algorithm**: in this case, the verification algorithm is implemented by comparing the count of elements in the matrix **less than or equal to** the candidate solution, denoted as `cnt`, with the rank `k`: if `cnt < k`, we throw away the left half of the search space; otherwise we discard the right half.\\n\\n<br>\\n\\nNote that the verification algorithm is based on the following two observations:\\n\\n1. There will be **at least** `k` elements in the matrix that are *less than or equal to* the `kth` smallest element.\\n\\n2. If there are **at least** `k` elements in the matrix that are *less than or equal* to a candidate solution, then the actual `kth` smallest element in the matrix *cannot be greater than* this candiate solution.\\n\\nAlso the counting of elements no greater than a candidate solution can be done in linear time by employing the classic two-pointer techinique which takes advantage of the sorted properties of the matrix. The following is the solution for this algorithm:\\n\\n<br>\\n\\n```\\npublic int kthSmallest(int[][] matrix, int k) {\\n    int n = matrix.length;\\n    \\n    int l = matrix[0][0];               // minimum element in the matrix\\n    int r = matrix[n - 1][n - 1];       // maximum element in the matrix\\n    \\n    for (int cnt = 0; l < r; cnt = 0) { // this is the binary search loop\\n        int m = l + (r - l) / 2;\\n        \\n        for(int i = 0, j = n - 1; i < n; i++)  {\\n            while (j >= 0 && matrix[i][j] > m) j--;  // the pointer j will only go in one direction\\n            cnt += (j + 1);\\n        }\\n        \\n        if (cnt < k) {\\n            l = m + 1;   // cnt less than k, so throw away left half\\n        } else {\\n            r = m;       // otherwise discard right half\\n        }\\n    }\\n    \\n    return l;\\n}\\n```\\n\\n<br>\\n\\nTime complexity: `O(n * log(MAX - MIN))`\\nSpace complexity: `O(1)`\\n\\nThe binary search solution is much more efficient compared to those derived in previous sections. We use only constant space and the time complexity is almost linear for any practical integer matrices (for which `MIN` and `MAX` are within the `32-bit` integer range).\\n\\n---\\n\\n**`V -- ZigzagSearch-based solution`**\\n\\nThe zigzag search solution is another special version of the more general \"trial and error\" algorithm, where now the search space is formed only by integers contained in the input matrix itself, rather than continous integers in the range `[MIN, MAX]`. We can summarize the following properties of this solution:\\n\\n<br>\\n\\n**The candidate solution**: in this case, the cadidate solution is also an integer, but it must be an element of the input matrix.\\n\\n**The search space**: in this case, the search space is given by the input matrix itself.\\n\\n**The traverse method**: in this case, we cannot do a binary search since there is no total ordering of the candidate solutions. However, we do have partial orderings where each row and column of the matrix are sorted in ascending order. This enables us to do a zigzag search where we start from the upper-right corner of the matrix and proceed to either the next row or previous column depending on the result of the verification algorithm (we can also start from the bottom-left corner and proceed to either the previous row or next column).\\n\\n**The verification algorithm**: in this case, the verification algorithm is implemented by comparing two counts, denoted as `cnt_lt` and `cnt_le` respectively, with the rank `k`: if `cnt_le < k`, we proceed to the next row; else if `cnt_lt >= k`, we proceed to the previous column; otherwise we\\'ve found the `kth` smallest element in the matrix so return it. Here `cnt_lt` denotes the number of elements in the matrix **less than** the candidate solution, while `cnt_le` denotes the number of elements in the matrix **less than or equal to** the candidate solution (the reason we need two counts is that there may be duplicates in the input matrix).\\n\\n<br>\\n\\nNote that the verification algorithm is based on the following two observations:\\n\\n1. There will be **at most** `k - 1` elements in the matrix that are *less than* the `kth` smallest element.\\n\\n2. There will be **at least** `k` elements in the matrix that are *less than or equal to* the `kth` smallest element.\\n\\nAnd again the counting can be done in linear time using the classic two-pointer techinique. The following is the code for this algorithm:\\n\\n<br>\\n\\n```\\npublic int kthSmallest(int[][] matrix, int k) {\\n    int n = matrix.length;\\n    \\n    int row = 0;          // we start from the upper-right corner\\n    int col = n - 1;      \\n    \\n    for (int cnt_le = 0, cnt_lt = 0; true; cnt_le = 0, cnt_lt = 0) {\\n        for (int i = 0, j = n - 1, p = n - 1; i < n; i++) {\\n            while (j >= 0 && matrix[i][j] > matrix[row][col]) j--;    // pointer j for counting cnt_le\\n            cnt_le += (j + 1);\\n            \\n            while (p >= 0 && matrix[i][p] >= matrix[row][col]) p--;   // pointer p for counting cnt_lt\\n            cnt_lt += (p + 1);\\n        }\\n        \\n        if (cnt_le < k) {         // candidate solution too small so increase it\\n            row++; \\n        } else if (cnt_lt >= k) { // candidate solution too large so decrease it\\n            col--;\\n        } else {                  // candidate solution equal to the kth smallest element so return\\n            return matrix[row][col];\\n        }\\n    }\\n}\\n```\\n\\n<br>\\n\\nTime complexity: `O(n^2)`\\nSpace complexity: `O(1)`\\n\\nThe zigzag search solution is less efficient compared to the binary search solution, but still achieves significant performance gains compared to the other three solutions.\\n\\n---\\n\\n**`VI -- BiSelect solution`**\\n\\nThis is the most advanced algorithm for this type of problems that achieves linear time complexity. The main theory is based on the ideas proposed in [*this paper*](http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf). Here is an implementation in Java, which is very lengthy. I would refer you to this awesome [post](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/85170/on-from-paper-yes-orows) by [*stefanpochmann*](https://discuss.leetcode.com/user/stefanpochmann) for a shorter and concise version in Python, and this [post](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/85201/c-on-time-on-space-solution-with-detail-intuitive-explanation) by [zhiqing_xiao](https://leetcode.com/zhiqing_xiao/) for more explanations (and a solution in C++). This BiSelect-algorithm is good to know but may not be suitable for an interview, so you may opt to skip it and continue.\\n\\n<br>\\n\\n```\\npublic int kthSmallest(int[][] matrix, int k) {\\n    int n = matrix.length;\\n\\t\\t\\n    int[] index = new int[n];\\n\\t    \\n    for (int i = 0; i < n; i++) {\\n        index[i] = i;\\n    }\\n   \\n    int[] L = new int[12 * n];\\n        \\n    return biselect(matrix, index, k, k, L)[0];\\n}\\n\\nprivate int[] biselect(int[][] matrix, int[] index, int k1, int k2, int[] L) {\\n    int n = index.length;\\n        \\n    if (n <= 2) {\\n        int[] nums = new int[n * n];\\n            \\n        for (int i = 0, k = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                nums[k++] = matrix[index[i]][index[j]];\\n            }\\n        }\\n            \\n        Arrays.sort(nums);\\n            \\n        return new int[] {nums[k1 - 1], nums[k2 - 1]};\\n    }\\n        \\n    int[] index_ = new int[(n + 1) / 2 + (n - 1) % 2];\\n    int k1_ = 0;\\n    int k2_ = (k2 + 3) / 4;\\n        \\n    for (int i = 0, k = 0; i < n; i += 2) {\\n        index_[k++] = index[i];\\n    }\\n        \\n    if (n % 2 == 0) {\\n        index_[index_.length - 1] = index[n - 1];\\n        k1_ = (k1 + 3) / 4 + n + 1;\\n    } else {\\n        k1_ = (k1 + 2 * n) / 4 + 1;\\n    }\\n        \\n    int[] pair = biselect(matrix, index_, k1_, k2_, L);\\n    int a = pair[0], b = pair[1];\\n    int ra_less = 0, rb_more = 0;\\n        \\n    int Len = 0;\\n        \\n    for (int i = 0, ja = n, jb = n; i < n; i++) {\\n        while (ja > 0 && matrix[index[i]][index[ja - 1]] >= a) ja--;\\n        ra_less += ja;\\n            \\n        while (jb > 0 && matrix[index[i]][index[jb - 1]] > b) jb--;\\n        rb_more += n - jb;\\n            \\n        for (int j = jb; j < ja; j++) {\\n            L[Len++] = matrix[index[i]][index[j]];\\n        }\\n    }\\n        \\n    int x = 0, y = 0;\\n        \\n    if (ra_less <= k1 - 1) {\\n        x = a;\\n    } else if (k1 + rb_more - n * n <= 0) {\\n        x = b;\\n    } else {\\n        x = L[pick(L, 0, Len, k1 + rb_more - n * n)];\\n    }\\n        \\n    if (ra_less <= k2 - 1) {\\n        y = a;\\n    } else if (k2 + rb_more - n * n <= 0) {\\n        y = b;\\n    } else {\\n        y = L[pick(L, 0, Len, k2 + rb_more - n * n)];\\n    }\\n        \\n    return new int[] {x, y};\\n}\\n\\t\\nprivate int pick(int[] nums, int l, int r, int k) {\\n    int[] pos = partition(nums, l, r, medianOfMedians(nums, l, r));\\n        \\n    int p = pos[0], q = pos[1];\\n        \\n    if (q - l < k) {\\n        return pick(nums, q, r, k - (q - l));\\n    } else if (k <= p - l) {\\n        return pick(nums, l, p, k);\\n    } else {\\n        return p;\\n    }\\n}\\n    \\nprivate int[] partition(int[] nums, int l, int r, int pos) {\\n    int pivot = nums[pos];\\n    swap(nums, pos, r - 1);\\n        \\n    int p = l, q = r - 1;\\n        \\n    for (int i = l; i < q;) {\\n        if (nums[i] < pivot) {\\n            swap(nums, p++, i++);\\n        } else if (nums[i] > pivot) {\\n            swap(nums, i, --q);\\n        } else {\\n            i++;\\n        }\\n    }\\n        \\n    swap(nums, q++, r - 1);\\n        \\n    return new int[] {p, q};\\n}\\n    \\nprivate int medianOfMedians(int[] nums, int l, int r) {\\n    if (r - l <= 5) return medianOfFive(nums, l, r);\\n        \\n    int rr = l;\\n        \\n    for (int i = l; i < r; i += 5) {\\n        swap(nums, rr++, medianOfFive(nums, i, Math.min(i + 5,  r)));\\n    }\\n        \\n    return pick(nums, l, rr, (rr - l + 1) / 2);\\n}\\n    \\nprivate int medianOfFive(int[] nums, int l, int r) {\\n    Arrays.sort(nums, l, r);\\n    return l + (r - l - 1) / 2;\\n}\\n    \\nprivate void swap(int[] nums, int i, int j) {\\n    int t = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = t;\\n}\\n```\\n\\n<br>\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(n)`\\n\\n---\\n\\n**`VII -- Transform other problems into \"Kth Smallest Element in a Sorted Matrix\"`**\\n\\nFor problems other than the \"Kth Smallest Element in a Sorted Matrix\", to apply the algorithms developed above, we need to rephrase and transform them into one that is equivalent to finding the `Kth Smallest Element in a Sorted Matrix`. Whether we can do so depends on the nature of the problems, but at least this is true for those listed at the beginning of the post.\\n\\nNow the key to the transformation process is to build the sorted matrix in terms of the problem input. On the one hand, we need to relate each matrix element `matrix[i][j]` to the problem input. On the other hand, we need to arrange these elements so that each row and column of the matrix are sorted in ascending order. Again, these details will depend on the nature of the problems. But as far as this post is concerned, I will assume the input are two arrays sorted in ascending order, denoted as `a` and `b` respectively, and the matrix elements can be computed using arithmetic operations of the two array elements.\\n\\n1. Addition: `matrix[i][j] = a[i\\'] + b[j\\']`\\n2. Subtraction: `matrix[i][j] = a[i\\'] - b[j\\']`\\n3. Multiplication: `matrix[i][j] = a[i\\'] * b[j\\']`\\n4. Division: `matrix[i][j] = a[i\\'] / b[j\\']`\\n\\nNote that the index mappings `i --> i\\'` and `j --> j\\'` are not necessarily identity mappings, but rather they will be chosen to ensure that the rows and columns in the matrix are sorted in ascending order. For simplicity, we name two type of mappings here which are *identity mapping* (where `i\\' = i` and `j\\' = j`) and *\"negative\" mapping* (where `i\\' = na - 1 - i` and `j\\' = nb - 1 - j`, with `na`, `nb` being the lengths of the two arrays).\\n\\n<br>\\n\\nNext I will reformulate LeetCode problems `378`, `668`, `719` and `786` as examples to show how the transformation is done:\\n\\n1. [373. Find K Pairs with Smallest Sums](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/description/): In this case, the two input arrays are `nums1` and `nums2`, so `a` will refer to `nums1` and `b` to `nums2`. And we have `matrix[i][j] = nums1[i] + nums2[j]`, where identity mappings are chosen for both the row and column indices. Note that for this problem we are required to find all the `K` pairs with the smallest sums, so the optimized PriorityQueue solution would be the best to try.\\n\\n<br>\\n\\n2. [668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/): In this case, only the lengths of the two arrays are given as input, but it\\'s trival to get the array elements (`a[i] = i + 1`, `b[j] = j + 1`). And we have `matrix[i][j] = a[i] * b[j]`, where again identity mappings are chosen for both the row and column indices. The `Kth` smallest element in the multiplication table will be the same as the `Kth` smallest element in the matrix.\\n\\n<br>\\n\\n3. [719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/): In this case there is only one array `nums` as input, so both `a` and `b` will refer to `nums`. After sorting `nums` in ascending order, we have `matrix[i][j] = nums[i] - nums[n - 1 - j]`, where `n = nums.length`. Note that the mapping for column index is chosen to be \"negative\" in order to make sure the columns are sorted in ascending order. Also note that our matrix will contain all pair distances (including negative ones) while the original problem asks for the `Kth` smallest pair distance out of absolute pair distances (there are `n(n-1)/2` such pairs). So we need to shift the rank up to `K\\' = K + n(n+1)/2`. The `Kth` smallest pair distance then will be the `K\\'th` smallest element in the matrix.\\n\\n<br>\\n\\n4. [786. K-th Smallest Prime Fraction](https://leetcode.com/problems/k-th-smallest-prime-fraction/description/): In this case again there is only one array `A` as input, so both `a` and `b` will refer to `A`. We have `matrix[i][j] = nums[i] / nums[n - 1 - j]`, where `n = A.length` and `/` is floating point division (not integer division). Again the mapping for column index is chosen to be \"negative\" to ensure the columns are sorted in ascending order. The `Kth` smallest prime fraction then will be the `Kth` smallest element in the matrix.\\n\\n<br>\\n\\nNote that there may be other properties of the matrix that are specific to a particular problem, such as whether the matrix contains duplicates or not, whether the matrix elements are integers or not, etc. These extra properties may help optimize the algorithms developed earlier.\\n\\n---\\n\\n**`VIII -- Solutions for this problem (786. K-th Smallest Prime Fraction)`**\\n\\nIn this section, I will list three solutions for this problem, where the first one is an example of the optimized PriorityQueue-based solution, the second is an example of the BinarySearch-based solution, and the last one is an example of the ZigzagSearch-based solution.\\n\\n<br>\\n\\n**SOLUTION ONE** -- Using PriorityQueue with optimization\\n\\n* Time complexity: `O((n + K) * logn)`, with `n = A.length`\\n* Space complexity: `O(n)`\\n\\n```\\npublic int[] kthSmallestPrimeFraction(int[] A, int K) {\\n    int n = A.length;\\n    \\n    PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>() {\\n        public int compare(int[] a, int[] b) {\\n            return Integer.compare(A[a[0]] * A[n - 1 - b[1]], A[n - 1 - a[1]] * A[b[0]]);\\n        }\\n    });\\n    \\n    for (int i = 0; i < n; i++) {\\n        pq.offer(new int[] {i, 0});\\n    }\\n    \\n    while (--K > 0) {\\n        int[] p = pq.poll();\\n        \\n        if (++p[1] < n) {\\n            pq.offer(p);\\n        }\\n    }\\n    \\n    return new int[] {A[pq.peek()[0]], A[n - 1 - pq.peek()[1]]};\\n}\\n```\\n\\nRemarks:\\n\\n1. When accessing the input array using column index `j` of the matrix, we need to perform the \"negative\" mapping to get the correct index into the array: `j\\' = n - 1 - j`.\\n\\n2. When comparing two fractions, instead of doing floating-point divisions, we convert them into integer multiplications: `p/q < x/y  <==> p * y < x * q`. This optimization is also used in the following two solutions.\\n\\n<br>\\n\\n**SOLUTION TWO** -- Using BinarySearch\\n\\n* Time complexity: `O(n * log(MAX^2))`, where `MAX` is the maximum element in `A`\\n* Space complexity: `O(1)`\\n\\n```\\npublic int[] kthSmallestPrimeFraction(int[] A, int K) {\\n    double l = 0, r = 1;\\n    int p = 0, q = 1;\\n    \\n    for (int n = A.length, cnt = 0; true; cnt = 0, p = 0) {\\n        double m = (l + r) / 2;\\n        \\n        for (int i = 0, j = n - 1; i < n; i++) {\\n            while (j >= 0 && A[i] > m * A[n - 1 - j]) j--;\\n            cnt += (j + 1);\\n            \\n            if (j >= 0 && p * A[n - 1 - j] < q * A[i]) {\\n                p = A[i];\\n                q = A[n - 1 - j];\\n            }\\n        }\\n        \\n        if (cnt < K) {\\n            l = m;\\n        } else if (cnt > K) {\\n            r = m;\\n        } else {\\n            return new int[] {p, q};\\n        }\\n    }\\n}\\n```\\n\\nRemarks:\\n\\n1. The `kth` smallest fraction is known to be in the range `[0, 1]`, so we initialize the search space with this range (i.e., `l = 0` and `r = 1`).\\n\\n2. We need the pair `(p, q)` to record the maximum fraction in the matrix that is no greater than each candidate solution. This is necessary because on the one hand, the candidate solution itself cannot tell us what the numerator and denominator of the fraction are (remember the candidate solution is just a floating-point number); on the other hand, even if we can get the numerator and denominator of the candidate solution, these values may not be contained in the input array (remember all the fractions must be formed by pair of integers from the input array). This is different from the case when the matrix elements are integers, where at the end of the binary search, the candidate solution must be equal to the `kth` smallest element in the matrix.\\n\\n3. The above solution only works when there are no duplicate fractions in the matrix (which is indeed the case for prime fractions). Otherwise, we need two counts, `cnt_le` and `cnt_lt`, to account for duplicates, similar to what we did in the ZigzagSearch solution below.\\n\\n4. The time complexity is computed as follows: the binary search loop will terminate when the count of elements no greater than a candidate solution reaches `K`. This is guaranteed to happen when the size of the search range `[l, r]` becomes smaller than the smallest absolute distance between any pair of fractions in the matrix, which is `>= 1/MAX^2`. Since each iteration will reduce the search range by half, the binary search loop will terminate after at most `log(MAX^2)` steps. Each iteration is done in linear time, therefore the total time complexity is `O(n * log(MAX^2))`, which is equivalent to `O(n * log(MAX))`.\\n\\n<br>\\n\\n**SOLUTION THREE** -- Using ZigzagSearch\\n\\n* Time complexity: `O(n^2)`\\n* Space complexity: `O(1)`\\n\\n```\\npublic int[] kthSmallestPrimeFraction(int[] A, int K) {\\n    int n = A.length;\\n    \\n    int row = 0; \\n    int col = n - 1;\\n    \\n    for (int cnt_le = 0, cnt_lt = 0; true; cnt_le = 0, cnt_lt = 0) {\\n        for (int i = 0, j = n - 1, p = n - 1; i < n; i++) {\\n            while (j >= 0 && A[i] * A[n - 1 - col] > A[n - 1 - j] * A[row]) j--;\\n            cnt_le += (j + 1);\\n                \\n            while (p >= 0 && A[i] * A[n - 1 - col] >= A[n - 1 - p] * A[row]) p--;\\n            cnt_lt += (p + 1);\\n        }\\n            \\n        if (cnt_le < K) {\\n            row++;\\n        } else if (cnt_lt >= K) {\\n            col--;\\n        } else {\\n            return new int[] {A[row], A[n - 1 - col]};\\n        }\\n    }\\n}\\n```\\n\\nRemarks:\\n\\n1. We no longer need to keep track of the largest fraction in the matrix that is no greater than each candidate solution, because now all the candidate solutions are formed by integer pairs from the input array itself.\\n\\n2. The above solution can be further optimized due to the fact that there are no duplicates in the fraction matrix. This implies we always have `cnt_lt = cnt_le - 1`, therefore the loop for conuting `cnt_lt` can be dropped. You may refer to [lixx2100\\'s comment](https://leetcode.com/problems/k-th-smallest-prime-fraction/discuss/115486/Java-AC-O(max(nk)-*-logn)-Short-Easy-PriorityQueue/116025) for more information.\\n\\n---\\n\\n\\nHope you enjoy these solutions and happy coding!",
                "solutionTags": [],
                "code": "```\\npublic int kthSmallest(int[][] matrix, int k) {\\n    int n = matrix.length, i = 0;\\n    \\n    int[] nums = new int[n * n];\\n    \\n    for (int[] row : matrix) {\\n        for (int ele : row) {\\n            nums[i++] = ele;\\n        }\\n    }\\n    \\n    Arrays.sort(nums);\\n    \\n    return nums[k - 1];\\n}\\n```\n```\\npublic int kthSmallest(int[][] matrix, int k) {\\n    PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n    \\n    for (int[] row : matrix) {\\n        for (int ele : row) {\\n            pq.offer(ele);\\n            \\n            if (pq.size() > k) {\\n                pq.poll();\\n            }\\n        }\\n    }\\n    \\n    return pq.peek();\\n}\\n```\n```\\npublic int kthSmallest(int[][] matrix, int k) {\\n    PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>() {\\n        public int compare(int[] a, int[] b) { // (a[0], a[1]) and (b[0], b[1]) are positions in the matrix\\n            return Integer.compare(matrix[a[0]][a[1]], matrix[b[0]][b[1]]);\\n        }\\n    });\\n    \\n    int n = matrix.length;\\n    \\n    for (int i = 0; i < n; i++) {\\n        pq.offer(new int[] {i, 0});  // initialize the pool with elements from the first column\\n    }\\n    \\n    while (--k > 0) {                // remove the smallest elements from the matrix (k-1) times\\n        int[] p = pq.poll();\\n        \\n        if (++p[1] < n) {\\n            pq.offer(p);             // add the next element in the same row if it exists\\n        }\\n    }\\n    \\n    return matrix[pq.peek()[0]][pq.peek()[1]];\\n}\\n```\n```\\npublic int kthSmallest(int[][] matrix, int k) {\\n    int n = matrix.length;\\n    \\n    int l = matrix[0][0];               // minimum element in the matrix\\n    int r = matrix[n - 1][n - 1];       // maximum element in the matrix\\n    \\n    for (int cnt = 0; l < r; cnt = 0) { // this is the binary search loop\\n        int m = l + (r - l) / 2;\\n        \\n        for(int i = 0, j = n - 1; i < n; i++)  {\\n            while (j >= 0 && matrix[i][j] > m) j--;  // the pointer j will only go in one direction\\n            cnt += (j + 1);\\n        }\\n        \\n        if (cnt < k) {\\n            l = m + 1;   // cnt less than k, so throw away left half\\n        } else {\\n            r = m;       // otherwise discard right half\\n        }\\n    }\\n    \\n    return l;\\n}\\n```\n```\\npublic int kthSmallest(int[][] matrix, int k) {\\n    int n = matrix.length;\\n    \\n    int row = 0;          // we start from the upper-right corner\\n    int col = n - 1;      \\n    \\n    for (int cnt_le = 0, cnt_lt = 0; true; cnt_le = 0, cnt_lt = 0) {\\n        for (int i = 0, j = n - 1, p = n - 1; i < n; i++) {\\n            while (j >= 0 && matrix[i][j] > matrix[row][col]) j--;    // pointer j for counting cnt_le\\n            cnt_le += (j + 1);\\n            \\n            while (p >= 0 && matrix[i][p] >= matrix[row][col]) p--;   // pointer p for counting cnt_lt\\n            cnt_lt += (p + 1);\\n        }\\n        \\n        if (cnt_le < k) {         // candidate solution too small so increase it\\n            row++; \\n        } else if (cnt_lt >= k) { // candidate solution too large so decrease it\\n            col--;\\n        } else {                  // candidate solution equal to the kth smallest element so return\\n            return matrix[row][col];\\n        }\\n    }\\n}\\n```\n```\\npublic int kthSmallest(int[][] matrix, int k) {\\n    int n = matrix.length;\\n\\t\\t\\n    int[] index = new int[n];\\n\\t    \\n    for (int i = 0; i < n; i++) {\\n        index[i] = i;\\n    }\\n   \\n    int[] L = new int[12 * n];\\n        \\n    return biselect(matrix, index, k, k, L)[0];\\n}\\n\\nprivate int[] biselect(int[][] matrix, int[] index, int k1, int k2, int[] L) {\\n    int n = index.length;\\n        \\n    if (n <= 2) {\\n        int[] nums = new int[n * n];\\n            \\n        for (int i = 0, k = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                nums[k++] = matrix[index[i]][index[j]];\\n            }\\n        }\\n            \\n        Arrays.sort(nums);\\n            \\n        return new int[] {nums[k1 - 1], nums[k2 - 1]};\\n    }\\n        \\n    int[] index_ = new int[(n + 1) / 2 + (n - 1) % 2];\\n    int k1_ = 0;\\n    int k2_ = (k2 + 3) / 4;\\n        \\n    for (int i = 0, k = 0; i < n; i += 2) {\\n        index_[k++] = index[i];\\n    }\\n        \\n    if (n % 2 == 0) {\\n        index_[index_.length - 1] = index[n - 1];\\n        k1_ = (k1 + 3) / 4 + n + 1;\\n    } else {\\n        k1_ = (k1 + 2 * n) / 4 + 1;\\n    }\\n        \\n    int[] pair = biselect(matrix, index_, k1_, k2_, L);\\n    int a = pair[0], b = pair[1];\\n    int ra_less = 0, rb_more = 0;\\n        \\n    int Len = 0;\\n        \\n    for (int i = 0, ja = n, jb = n; i < n; i++) {\\n        while (ja > 0 && matrix[index[i]][index[ja - 1]] >= a) ja--;\\n        ra_less += ja;\\n            \\n        while (jb > 0 && matrix[index[i]][index[jb - 1]] > b) jb--;\\n        rb_more += n - jb;\\n            \\n        for (int j = jb; j < ja; j++) {\\n            L[Len++] = matrix[index[i]][index[j]];\\n        }\\n    }\\n        \\n    int x = 0, y = 0;\\n        \\n    if (ra_less <= k1 - 1) {\\n        x = a;\\n    } else if (k1 + rb_more - n * n <= 0) {\\n        x = b;\\n    } else {\\n        x = L[pick(L, 0, Len, k1 + rb_more - n * n)];\\n    }\\n        \\n    if (ra_less <= k2 - 1) {\\n        y = a;\\n    } else if (k2 + rb_more - n * n <= 0) {\\n        y = b;\\n    } else {\\n        y = L[pick(L, 0, Len, k2 + rb_more - n * n)];\\n    }\\n        \\n    return new int[] {x, y};\\n}\\n\\t\\nprivate int pick(int[] nums, int l, int r, int k) {\\n    int[] pos = partition(nums, l, r, medianOfMedians(nums, l, r));\\n        \\n    int p = pos[0], q = pos[1];\\n        \\n    if (q - l < k) {\\n        return pick(nums, q, r, k - (q - l));\\n    } else if (k <= p - l) {\\n        return pick(nums, l, p, k);\\n    } else {\\n        return p;\\n    }\\n}\\n    \\nprivate int[] partition(int[] nums, int l, int r, int pos) {\\n    int pivot = nums[pos];\\n    swap(nums, pos, r - 1);\\n        \\n    int p = l, q = r - 1;\\n        \\n    for (int i = l; i < q;) {\\n        if (nums[i] < pivot) {\\n            swap(nums, p++, i++);\\n        } else if (nums[i] > pivot) {\\n            swap(nums, i, --q);\\n        } else {\\n            i++;\\n        }\\n    }\\n        \\n    swap(nums, q++, r - 1);\\n        \\n    return new int[] {p, q};\\n}\\n    \\nprivate int medianOfMedians(int[] nums, int l, int r) {\\n    if (r - l <= 5) return medianOfFive(nums, l, r);\\n        \\n    int rr = l;\\n        \\n    for (int i = l; i < r; i += 5) {\\n        swap(nums, rr++, medianOfFive(nums, i, Math.min(i + 5,  r)));\\n    }\\n        \\n    return pick(nums, l, rr, (rr - l + 1) / 2);\\n}\\n    \\nprivate int medianOfFive(int[] nums, int l, int r) {\\n    Arrays.sort(nums, l, r);\\n    return l + (r - l - 1) / 2;\\n}\\n    \\nprivate void swap(int[] nums, int i, int j) {\\n    int t = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = t;\\n}\\n```\n```\\npublic int[] kthSmallestPrimeFraction(int[] A, int K) {\\n    int n = A.length;\\n    \\n    PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>() {\\n        public int compare(int[] a, int[] b) {\\n            return Integer.compare(A[a[0]] * A[n - 1 - b[1]], A[n - 1 - a[1]] * A[b[0]]);\\n        }\\n    });\\n    \\n    for (int i = 0; i < n; i++) {\\n        pq.offer(new int[] {i, 0});\\n    }\\n    \\n    while (--K > 0) {\\n        int[] p = pq.poll();\\n        \\n        if (++p[1] < n) {\\n            pq.offer(p);\\n        }\\n    }\\n    \\n    return new int[] {A[pq.peek()[0]], A[n - 1 - pq.peek()[1]]};\\n}\\n```\n```\\npublic int[] kthSmallestPrimeFraction(int[] A, int K) {\\n    double l = 0, r = 1;\\n    int p = 0, q = 1;\\n    \\n    for (int n = A.length, cnt = 0; true; cnt = 0, p = 0) {\\n        double m = (l + r) / 2;\\n        \\n        for (int i = 0, j = n - 1; i < n; i++) {\\n            while (j >= 0 && A[i] > m * A[n - 1 - j]) j--;\\n            cnt += (j + 1);\\n            \\n            if (j >= 0 && p * A[n - 1 - j] < q * A[i]) {\\n                p = A[i];\\n                q = A[n - 1 - j];\\n            }\\n        }\\n        \\n        if (cnt < K) {\\n            l = m;\\n        } else if (cnt > K) {\\n            r = m;\\n        } else {\\n            return new int[] {p, q};\\n        }\\n    }\\n}\\n```\n```\\npublic int[] kthSmallestPrimeFraction(int[] A, int K) {\\n    int n = A.length;\\n    \\n    int row = 0; \\n    int col = n - 1;\\n    \\n    for (int cnt_le = 0, cnt_lt = 0; true; cnt_le = 0, cnt_lt = 0) {\\n        for (int i = 0, j = n - 1, p = n - 1; i < n; i++) {\\n            while (j >= 0 && A[i] * A[n - 1 - col] > A[n - 1 - j] * A[row]) j--;\\n            cnt_le += (j + 1);\\n                \\n            while (p >= 0 && A[i] * A[n - 1 - col] >= A[n - 1 - p] * A[row]) p--;\\n            cnt_lt += (p + 1);\\n        }\\n            \\n        if (cnt_le < K) {\\n            row++;\\n        } else if (cnt_lt >= K) {\\n            col--;\\n        } else {\\n            return new int[] {A[row], A[n - 1 - col]};\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 115486,
                "title": "java-ac-o-max-n-k-logn-short-easy-priorityqueue",
                "content": "This solution probably doesn't have the best runtime but it's really simple and easy to understand.\n\nSays if the list is `[1, 7, 23, 29, 47]`, we can easily have this table of relationships\n```\n1/47  < 1/29    < 1/23 < 1/7\n7/47  < 7/29    < 7/23\n23/47 < 23/29\n29/47\n```\nSo now the problem becomes \"find the kth smallest element of (n-1) sorted list\"\n\nFollowing is my implementation using PriorityQueue, running time is ~~O(nlogn)~~ O(max(n,k) * logn), space is O(n):\n\n```java\n    public int[] kthSmallestPrimeFraction(int[] a, int k) {\n        int n = a.length;\n        // 0: numerator idx, 1: denominator idx\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                int s1 = a[o1[0]] * a[o2[1]];\n                int s2 = a[o2[0]] * a[o1[1]];\n                return s1 - s2;\n            }\n        });\n        for (int i = 0; i < n-1; i++) {\n            pq.add(new int[]{i, n-1});\n        }\n        for (int i = 0; i < k-1; i++) {\n            int[] pop = pq.remove();\n            int ni = pop[0];\n            int di = pop[1];\n            if (pop[1] - 1 > pop[0]) {\n                pop[1]--;\n                pq.add(pop);\n            }\n        }\n\n        int[] peek = pq.peek();\n        return new int[]{a[peek[0]], a[peek[1]]};\n    }\n```",
                "solutionTags": [],
                "code": "```\n1/47  < 1/29    < 1/23 < 1/7\n7/47  < 7/29    < 7/23\n23/47 < 23/29\n29/47\n```\n```java\n    public int[] kthSmallestPrimeFraction(int[] a, int k) {\n        int n = a.length;\n        // 0: numerator idx, 1: denominator idx\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                int s1 = a[o1[0]] * a[o2[1]];\n                int s2 = a[o2[0]] * a[o1[1]];\n                return s1 - s2;\n            }\n        });\n        for (int i = 0; i < n-1; i++) {\n            pq.add(new int[]{i, n-1});\n        }\n        for (int i = 0; i < k-1; i++) {\n            int[] pop = pq.remove();\n            int ni = pop[0];\n            int di = pop[1];\n            if (pop[1] - 1 > pop[0]) {\n                pop[1]--;\n                pq.add(pop);\n            }\n        }\n\n        int[] peek = pq.peek();\n        return new int[]{a[peek[0]], a[peek[1]]};\n    }\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 115545,
                "title": "o-n",
                "content": "    def kthSmallestPrimeFraction(self, A, K):\n        class Row(int):\n            def __getitem__(self, j):\n                return float(self) / A[~j], [int(self), A[~j]]\n        return self.kthSmallest(map(Row, A), K)[1]\n\n    # copy&paste old solution from https://discuss.leetcode.com/topic/53126/o-n-from-paper-yes-o-rows\n    def kthSmallest(self, matrix, k):\n        ...\n\nIt's O(n) where n is the size of A. Reusing my old O(n) solution for [\"Kth Smallest Element in a Sorted Matrix\"](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/85170/on-from-paper-yes-orows) again, similar to how I did it for [\"Find K-th Smallest Pair Distance\"](https://leetcode.com/problems/find-k-th-smallest-pair-distance/discuss/109092/%221-liner%22-and-%22almost-O(n)%22). I build a virtual sorted matrix of entries `p/q, [p, q]`, get the K-th smallest entry, and extract and return its `[p, q]`. For example, for `A = [1, 2, 5, 7]` my fractions matrix looks like this:\n```\n  |  7    5    2    1\n--+-------------------\n1 | 1/7  1/5  1/2  1/1\n2 | 2/7  2/5  2/2  2/1\n5 | 5/7  5/5  5/2  5/1\n7 | 7/7  7/5  7/2  7/1\n```",
                "solutionTags": [],
                "code": "```\n  |  7    5    2    1\n--+-------------------\n1 | 1/7  1/5  1/2  1/1\n2 | 2/7  2/5  2/2  2/1\n5 | 5/7  5/5  5/2  5/1\n7 | 7/7  7/5  7/2  7/1\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 115531,
                "title": "c-9lines-priority-queue",
                "content": "it is like find `k-th` smallest element in `n` sorted array, which has a classic solution using priority_queue\\n\\nconsider an input of `[n1, n2, n3, n4, n5]`, the possible factors are:\\n`[n1/n5, n1/n4, n1/n3, n1/n2, n1/n1]`\\n`[n2/n5, n2/n4, n2/n3, n2/n2]`\\n`[n3/n5, n3/n4, n3/n3]`\\n`[n4/n5, n4/n4]`\\n`[n5/n5]`\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& A, int K) {\\n        priority_queue<pair<double, pair<int,int>>>pq;\\n        for(int i = 0; i < A.size(); i++)\\n            pq.push({-1.0*A[i]/A.back(), {i,A.size()-1}});\\n        while(--K > 0)\\n        {\\n            pair<int,int> cur = pq.top().second;\\n            pq.pop();\\n            cur.second--;\\n            pq.push({-1.0*A[cur.first]/A[cur.second], {cur.first, cur.second}});\\n        }\\n        return {A[pq.top().second.first], A[pq.top().second.second]};\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& A, int K) {\\n        priority_queue<pair<double, pair<int,int>>>pq;\\n        for(int i = 0; i < A.size(); i++)\\n            pq.push({-1.0*A[i]/A.back(), {i,A.size()-1}",
                "codeTag": "Java"
            },
            {
                "id": 862410,
                "title": "c-binary-search-short-and-easy-faster-than-99",
                "content": "![image](https://assets.leetcode.com/users/images/430d8e33-d715-4f7c-8849-1bedf8a36b66_1600962077.976813.png)\\n\\nRefer - https://zxi.mytechroad.com/blog/two-pointers/leetcode-786-k-th-smallest-prime-fraction/\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        double l = 0, r = 1.0;\\n        while(l<r){\\n            double m = (l+r)/2;\\n\\t\\t\\t//max_f is used to store the maximum fraction less than mid\\n            double max_f = 0.0;\\n\\t\\t\\t//p and q are used for storing the indices of max fraction\\n            int total=0,p=0,q=0;\\n            int j=1;\\n            for(int i=0;i<n-1;i++){\\n\\t\\t\\t//if this fraction is greater than mid , move denominator rightwards to find a smaller mid\\n                while(j<n && arr[i] > m*arr[j])\\n                    j++;\\n\\t\\t\\t\\t\\t//j elements are greater than mid in this row , n-j are smaller , add them to result\\n                total += (n-j);\\n                if(j==n)\\n                    break;\\n\\t\\t\\t\\t//cast to double speedily\\n                double f = static_cast<double>(arr[i]) / arr[j];\\n\\t\\t\\t\\t//update max fraction for this mid\\n                if (f > max_f) {\\n                  p = i;\\n                  q = j;\\n                  max_f = f;\\n                }\\n            }\\n            if (total == k)\\n                return {arr[p], arr[q]};       \\n\\t\\t\\t//there are too many fractions less than mid=> mid is too big => make mid smaller and try\\n            else if (total > k)\\n                r = m;\\n            else\\n                l = m;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        double l = 0, r = 1.0;\\n        while(l<r){\\n            double m = (l+r)/2;\\n\\t\\t\\t//max_f is used to store the maximum fraction less than mid\\n            double max_f = 0.0;\\n\\t\\t\\t//p and q are used for storing the indices of max fraction\\n            int total=0,p=0,q=0;\\n            int j=1;\\n            for(int i=0;i<n-1;i++){\\n\\t\\t\\t//if this fraction is greater than mid , move denominator rightwards to find a smaller mid\\n                while(j<n && arr[i] > m*arr[j])\\n                    j++;\\n\\t\\t\\t\\t\\t//j elements are greater than mid in this row , n-j are smaller , add them to result\\n                total += (n-j);\\n                if(j==n)\\n                    break;\\n\\t\\t\\t\\t//cast to double speedily\\n                double f = static_cast<double>(arr[i]) / arr[j];\\n\\t\\t\\t\\t//update max fraction for this mid\\n                if (f > max_f) {\\n                  p = i;\\n                  q = j;\\n                  max_f = f;\\n                }\\n            }\\n            if (total == k)\\n                return {arr[p], arr[q]};       \\n\\t\\t\\t//there are too many fractions less than mid=> mid is too big => make mid smaller and try\\n            else if (total > k)\\n                r = m;\\n            else\\n                l = m;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 115538,
                "title": "python-solution-using-binary-search",
                "content": "@dragonitedd explained my idea:\nfor each row i, all the numbers (call them ```A[j]```) to the right of ```A[i]/m```, are the ones such that ```A[i]/A[j]``` will be smaller than ```m```.\nsum them up so that you will know the total number of pairs ```A[i]/A[j]``` that are smaller than ```m```. Find a proper m such that the total number equals ```K```, and then you find the maximum ```A[i]/A[j]``` among all pairs that are smaller than ```A[i]/m```, which is the Kth smallest number.\n\nPython3\n````\ndef kthSmallestPrimeFraction(self, A, K):\n        l, r, N = 0, 1, len(A)\n        while True:\n            m = (l + r) / 2\n            border = [bisect.bisect(A, A[i] / m) for i in range(N)]\n            cur = sum(N - i for i in border)\n            if cur > K:\n                r = m\n            elif cur < K:\n                l = m\n            else:\n                return max([(A[i], A[j]) for i, j in enumerate(border) if j < N], key=lambda x: x[0] / x[1])\n\n",
                "solutionTags": [],
                "code": "```A[j]```\n```A[i]/m```\n```A[i]/A[j]```\n```m```\n```A[i]/A[j]```\n```m```\n```K```\n```A[i]/A[j]```\n```A[i]/m```",
                "codeTag": "Unknown"
            },
            {
                "id": 115505,
                "title": "java-14ms-o-n-c-c-is-the-number-of-iteration-c-30-is-enough",
                "content": "\tint p, q;\n\n\t// O(n) for each check.\n\tboolean check(double mid, int[] A, int K) {\n\t\tint n = A.length;\n\t\tint p1 = 0, q1 = 0;\n\t\tint total = 0;\n\n\t\tfor (int i = 0, j = 0; i < n; i++) {\n\t\t\tfor (; j < n; j++) { // j will not backtrack.\n\t\t\t\tif (i < j && A[i] < A[j] * mid) {\n\t\t\t\t\tif (p1 == 0 || p1 * A[j] < A[i] * q1) {\n\t\t\t\t\t\tp1 = A[i];\n\t\t\t\t\t\tq1 = A[j];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttotal += n - j;\n\t\t}\n\t\tif (total <= K) {\n\t\t\tif (p == 0 || p * q1 < p1 * q) {\n\t\t\t\tp = p1;\n\t\t\t\tq = q1;\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpublic int[] kthSmallestPrimeFraction(int[] A, int K) {\n\t\tp = q = 0;\n\t\tdouble low = 0.0;\n\t\tdouble high = 1.0;\n\t\t// Around 30 times of iteration\n\t\twhile (high - low > 1e-8) {\n\t\t\tdouble mid = (low + high) / 2.0;\n\t\t\tif (check(mid, A, K)) {\n\t\t\t\tlow = mid;\n\t\t\t} else {\n\t\t\t\thigh = mid;\n\t\t\t}\n\t\t}\n\t\treturn new int[] { p, q };\n\t}",
                "solutionTags": [],
                "code": "\tint p, q;\n\t// O(n) for each check.\n\tboolean check(double mid, int[] A, int K) {\n\t\tint n = A.length;\n\t\tint p1 = 0, q1 = 0;\n\t\tint total = 0;\n\t\tfor (int i = 0, j = 0; i < n; i++) {\n\t\t\tfor (; j < n; j++) { // j will not backtrack.\n\t\t\t\tif (i < j && A[i] < A[j] * mid) {\n\t\t\t\t\tif (p1 == 0 || p1 * A[j] < A[i] * q1) {\n\t\t\t\t\t\tp1 = A[i];\n\t\t\t\t\t\tq1 = A[j];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttotal += n - j;\n\t\t}\n\t\tif (total <= K) {\n\t\t\tif (p == 0 || p * q1 < p1 * q) {\n\t\t\t\tp = p1;\n\t\t\t\tq = q1;\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\tpublic int[] kthSmallestPrimeFraction(int[] A, int K) {\n\t\tp = q = 0;\n\t\tdouble low = 0.0;\n\t\tdouble high = 1.0;\n\t\twhile (high - low > 1e-8) {\n\t\t\tdouble mid = (low + high) / 2.0;\n\t\t\tif (check(mid, A, K)) {\n\t\t\t\tlow = mid;\n\t\t\t} else {\n\t\t\t\thigh = mid;\n\t\t\t}\n\t\t}\n\t\treturn new int[] { p, q };\n\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 228346,
                "title": "java-simple-code",
                "content": "```\\n    private int[] countPairs(int[] A, double x) {\\n        int count = 0, n = A.length, p = 0, q = 0;\\n        double max = 0.0;\\n        for (int i = 0, j = 0; i < n; i++) {\\n            while (j < i && A[j] < A[i] * x) j++;\\n            if (j > 0) {\\n                double fraction = (double)A[j-1] / (double)A[i];\\n                if (max < fraction) {\\n                    max = fraction;\\n                    p = A[j-1];\\n                    q = A[i];\\n                }\\n            }\\n            count += j;\\n        }\\n        return new int[] {count, p, q};\\n    }\\n\\n    public int[] kthSmallestPrimeFraction(int[] A, int K) {\\n        int n = A.length, min = A[0], max = A[n-1], p=0, q=0;\\n        double lo = (double)min/(double)max, hi = 1.0;\\n        while (lo < hi) {\\n            double mid = (lo + hi) / 2.0;\\n            int[] count = countPairs(A, mid);\\n            if (count[0] == K) {\\n                p = count[1];\\n                q = count[2];\\n                break;\\n            }\\n            if (count[0] < K) lo = mid;\\n            else hi = mid;\\n        }\\n        return new int[] {p, q};\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private int[] countPairs(int[] A, double x) {\\n        int count = 0, n = A.length, p = 0, q = 0;\\n        double max = 0.0;\\n        for (int i = 0, j = 0; i < n; i++) {\\n            while (j < i && A[j] < A[i] * x) j++;\\n            if (j > 0) {\\n                double fraction = (double)A[j-1] / (double)A[i];\\n                if (max < fraction) {\\n                    max = fraction;\\n                    p = A[j-1];\\n                    q = A[i];\\n                }\\n            }\\n            count += j;\\n        }\\n        return new int[] {count, p, q};\\n    }\\n\\n    public int[] kthSmallestPrimeFraction(int[] A, int K) {\\n        int n = A.length, min = A[0], max = A[n-1], p=0, q=0;\\n        double lo = (double)min/(double)max, hi = 1.0;\\n        while (lo < hi) {\\n            double mid = (lo + hi) / 2.0;\\n            int[] count = countPairs(A, mid);\\n            if (count[0] == K) {\\n                p = count[1];\\n                q = count[2];\\n                break;\\n            }\\n            if (count[0] < K) lo = mid;\\n            else hi = mid;\\n        }\\n        return new int[] {p, q};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1444834,
                "title": "python-o-k-log-n-solution-with-intuitive-variable-names-and-comments",
                "content": "The intuition behind the heap problem is that at each step, we only consider one fraction in the heap for every denominator.\\nWe start off with the first element as numerator and other elements as denominators and whenever we choose the smallest fraction,\\nwe choose the next greatest numerator as the candidate for the denominator.\\n```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        # We create a heap structure to retrieve the smallest fractions\\n        # As we are given the array in sorted order, let us go ahead \\n        # create an initial heap with the first element as the numerator and\\n        # the rest of the elements as the denominator\\n\\t\\t\\n        fraction_heap = []\\n        last_element_index = len(arr) - 1\\n        \\n        # We also store the index of the numerator and the denominator with the\\n        # value of the fraction\\n        # In the end, we get a heap with each element [fraction_value, numerator_index, denominator_index]\\n\\t\\t\\n        for denominator_index in range(last_element_index, 0, -1):\\n\\t\\t\\n            # Calculate the value of the fraction\\n            fraction_value = arr[0] / float(arr[denominator_index])\\n\\t\\t\\t\\n            # Store fraction value with numerator and denominator\\n            fraction_heap.append(((fraction_value), 0, denominator_index))\\n            \\n        # To get the kth smallest fraction, we loop over the heap k - 1 times\\n        # This will get rid of the k - 1 smaller fractions\\n        # In the end, we can peak the top and return the result numerator and denominator\\n\\t\\t\\n        for iteration in range(k - 1):\\n\\t\\t\\n            fraction_value, numerator_index, denominator_index = heapq.heappop(fraction_heap)\\n\\t\\t\\t\\n            # For the denominator at denominator_index, this is the smallest fraction that was\\n            # in the heap. The next smallest fraction with the same denominator would be with nmumerator \\n            # index numerator_index + 1\\n\\t\\t\\t\\n            numerator_index += 1\\n\\t\\t\\t\\n            # We check if numerator_index is still lower than denominator_index\\n            # If it is, we add the next smallest fraction\\n            # This way, we only include 1 entry for each denominator in the heap instead of all possible\\n            # fractions\\n            # This gives us an O(n) space complexity instead of O(n^2)\\n\\t\\t\\t\\n            if numerator_index < denominator_index:\\n                fraction_value = arr[numerator_index] / float(arr[denominator_index])\\n                heapq.heappush(fraction_heap, ((fraction_value), numerator_index, denominator_index))\\n                \\n        # In the end, we return the numerator and denominator represented by the heap top\\n\\t\\t\\n        fraction_value, numerator_index, denominator_index = heapq.heappop(fraction_heap)\\n        return arr[numerator_index], arr[denominator_index]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        # We create a heap structure to retrieve the smallest fractions\\n        # As we are given the array in sorted order, let us go ahead \\n        # create an initial heap with the first element as the numerator and\\n        # the rest of the elements as the denominator\\n\\t\\t\\n        fraction_heap = []\\n        last_element_index = len(arr) - 1\\n        \\n        # We also store the index of the numerator and the denominator with the\\n        # value of the fraction\\n        # In the end, we get a heap with each element [fraction_value, numerator_index, denominator_index]\\n\\t\\t\\n        for denominator_index in range(last_element_index, 0, -1):\\n\\t\\t\\n            # Calculate the value of the fraction\\n            fraction_value = arr[0] / float(arr[denominator_index])\\n\\t\\t\\t\\n            # Store fraction value with numerator and denominator\\n            fraction_heap.append(((fraction_value), 0, denominator_index))\\n            \\n        # To get the kth smallest fraction, we loop over the heap k - 1 times\\n        # This will get rid of the k - 1 smaller fractions\\n        # In the end, we can peak the top and return the result numerator and denominator\\n\\t\\t\\n        for iteration in range(k - 1):\\n\\t\\t\\n            fraction_value, numerator_index, denominator_index = heapq.heappop(fraction_heap)\\n\\t\\t\\t\\n            # For the denominator at denominator_index, this is the smallest fraction that was\\n            # in the heap. The next smallest fraction with the same denominator would be with nmumerator \\n            # index numerator_index + 1\\n\\t\\t\\t\\n            numerator_index += 1\\n\\t\\t\\t\\n            # We check if numerator_index is still lower than denominator_index\\n            # If it is, we add the next smallest fraction\\n            # This way, we only include 1 entry for each denominator in the heap instead of all possible\\n            # fractions\\n            # This gives us an O(n) space complexity instead of O(n^2)\\n\\t\\t\\t\\n            if numerator_index < denominator_index:\\n                fraction_value = arr[numerator_index] / float(arr[denominator_index])\\n                heapq.heappush(fraction_heap, ((fraction_value), numerator_index, denominator_index))\\n                \\n        # In the end, we return the numerator and denominator represented by the heap top\\n\\t\\t\\n        fraction_value, numerator_index, denominator_index = heapq.heappop(fraction_heap)\\n        return arr[numerator_index], arr[denominator_index]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 986614,
                "title": "java-easiest-and-readable-o-k-log-k-solution",
                "content": "```\\nclass Solution {\\n    public int[] kthSmallestPrimeFraction(int[] A, int K) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Double.compare((double)A[a[0]] / (double)A[a[1]], (double)A[b[0]] / (double)A[b[1]]));\\n        pq.offer(new int[]{0, A.length - 1});\\n        for (int i = 0; i < K - 1; i++) {\\n            int[] cur = pq.poll();\\n            if (cur[0] + 1 < A.length && cur[1] == A.length - 1) {\\n                pq.offer(new int[]{cur[0] + 1, cur[1]});\\n            }\\n            if (cur[1] - 1 >= 0) {\\n                pq.offer(new int[]{cur[0], cur[1] - 1});\\n            }\\n        }\\n        int[] cur = pq.poll();\\n        return new int[]{A[cur[0]], A[cur[1]]};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] kthSmallestPrimeFraction(int[] A, int K) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Double.compare((double)A[a[0]] / (double)A[a[1]], (double)A[b[0]] / (double)A[b[1]]));\\n        pq.offer(new int[]{0, A.length - 1});\\n        for (int i = 0; i < K - 1; i++) {\\n            int[] cur = pq.poll();\\n            if (cur[0] + 1 < A.length && cur[1] == A.length - 1) {\\n                pq.offer(new int[]{cur[0] + 1, cur[1]});\\n            }\\n            if (cur[1] - 1 >= 0) {\\n                pq.offer(new int[]{cur[0], cur[1] - 1});\\n            }\\n        }\\n        int[] cur = pq.poll();\\n        return new int[]{A[cur[0]], A[cur[1]]};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609274,
                "title": "python-clean-o-k-log-k-solution",
                "content": "This optimization evaluates (2*K - 1) items.\\n\\n* Keep a pool of K minimum values seen so far.  \\n* Remove smallest item K-1 times (-1 to keep kth smallest on heap).  \\n* When you remove that smallest value, add it\\'s successor (same numerator, next smallest denominator).  \\n\\t* This newly added item is still in the range of [smallest : 2*K - 1 smallest] items.  \\n\\t\\nSince, it\\'s on a minHeap after K-1 pops of the pool of 2*K-1 smallest items the Kth smallest will be on the top of the heap.\\n\\n```\\ndef kthSmallestPrimeFraction(self, A, K):\\n\\theap = [(A[i] / A[-1], i, len(A) - 1) for i in range(min(len(A) - 1, K))]\\n\\n\\tfor _ in range(K-1):\\n\\t\\t_, i, j = heap[0]\\n\\t\\theapreplace(heap, (A[i]/A[j-1], i, j - 1))\\n\\n\\treturn [A[heap[0][1]], A[heap[0][2]]]\\n```\\nYou can also do this in starting by ranging over K denominator values while keeping numerator fixed for initial heap.\\n```\\ndef kthSmallestPrimeFraction(self, A, K):\\n\\theap = [(A[0] / A[j], 0, j) for j in reversed(range(max(len(A) - K - 1, 1), len(A)))]\\n\\n\\tfor _ in range(K-1):\\n\\t\\t_, i, j = heap[0]\\n\\t\\tif i < len(A) - 1:\\n\\t\\t\\theapreplace(heap, (A[i+1]/A[j], i+1, j))\\n\\n\\treturn [A[heap[0][1]], A[heap[0][2]]]\\n```\\n\\n\\nIn the loop you could also just heappush the same items I\\'m replacing and after loop completion pop K-1 times.  I\\'m just doing it all in 1 loop.",
                "solutionTags": [],
                "code": "```\\ndef kthSmallestPrimeFraction(self, A, K):\\n\\theap = [(A[i] / A[-1], i, len(A) - 1) for i in range(min(len(A) - 1, K))]\\n\\n\\tfor _ in range(K-1):\\n\\t\\t_, i, j = heap[0]\\n\\t\\theapreplace(heap, (A[i]/A[j-1], i, j - 1))\\n\\n\\treturn [A[heap[0][1]], A[heap[0][2]]]\\n```\n```\\ndef kthSmallestPrimeFraction(self, A, K):\\n\\theap = [(A[0] / A[j], 0, j) for j in reversed(range(max(len(A) - K - 1, 1), len(A)))]\\n\\n\\tfor _ in range(K-1):\\n\\t\\t_, i, j = heap[0]\\n\\t\\tif i < len(A) - 1:\\n\\t\\t\\theapreplace(heap, (A[i+1]/A[j], i+1, j))\\n\\n\\treturn [A[heap[0][1]], A[heap[0][2]]]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1180561,
                "title": "java-faster-than-100-2-solutions-min-heap-and-binary-search",
                "content": "## 1.  **Min Heap** ( 564 ms)\\n\\n**Idea**\\n\\nAdd all the possible pairs in a min heap. \\n\\nMin heap is created on the basis of fractions:\\na[i]/a[j] < b[i]/b[j]\\na[i] * b[j] < b[i] * a[j]\\n\\nPoll k elements from the heap and return the kth element.\\n\\n```\\nclass Solution {\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        int n = arr.length;\\n        PriorityQueue<Element> minHeap = new PriorityQueue<Element>((a,b)->(arr[a.i]*arr[b.j]-arr[b.i]*arr[a.j]));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                minHeap.add(new Element(i,j));\\n            }\\n        }\\n        \\n        Element e=null;\\n        while(k!=0){\\n            e = minHeap.poll();\\n            k--;\\n        }\\n        return new int[]{arr[e.i],arr[e.j]};\\n    }\\n}\\n\\nclass Element{\\n    int i;\\n    int j;\\n    \\n    Element(int i,int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}\\n```\\n\\n**Time Complexity**\\nO(n^2)\\n**Space Complexity**\\nO(n^2)\\n\\n## 2. **Binary Search** (1ms)\\n\\n**Idea**\\n1. Find no of fractions less than mid, let this be total.\\n2. Find i and j for maximum fraction less than mid.\\n3. a) If total is equal to k, then the maximum fraction less than mid is our required answer. So we simply return this i and j found in step 2.\\nb) If total is greater than k, no of fractions less than mid is greater so we set high to mid.\\nc) else we set low to mid.\\n\\n```\\nclass Solution {\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        int n = arr.length;\\n        \\n        double low = 0;\\n        double high = 1.0;\\n        while(low<high){\\n            double mid = (low+high)/2;\\n            int res[] = getFractionsLessThanMid(arr,k,n,mid);\\n            \\n            if(res[0]==k) return new int[]{arr[res[1]],arr[res[2]]};\\n            else if(res[0]>k) high = mid;\\n            else low = mid;\\n        }\\n        \\n        return new int[]{};\\n    }\\n    \\n    private int[] getFractionsLessThanMid(int arr[],int k,int n,double mid){\\n        double maxLessThanMid = 0.0;\\n        int x = 0; //stores indices of max fraction less than mid;\\n        int y = 0;\\n            \\n        int total = 0;//for storing fractions less than mid\\n        int j = 1;\\n            \\n        for(int i=0;i<n-1;i++){    \\n            \\n            //while fraction is greater than mid increment j\\n            while(j<n && arr[i]>arr[j]*mid){\\n                j++;\\n            }\\n\\n            if(j==n) break;\\n\\n            total+=(n-j); //j fractions greater than mid, n-j fractions smaller than mid, add fractions smaller than mid to total\\n\\n            double fraction = (double)arr[i]/arr[j];\\n            if(fraction>maxLessThanMid){\\n                maxLessThanMid = fraction;\\n                x = i;\\n                y =j;\\n            }\\n        }\\n        return new int[]{total,x,y};\\n    }\\n}\\n```\\n\\n**Time Complexity**\\nO(n^2 log(n))\\n**Space Complexity**\\nO(1)\\n\\n***References:***\\nhttps://leetcode.com/problems/k-th-smallest-prime-fraction/discuss/862410/C%2B%2B-Binary-Search-short-and-easy-Faster-than-99\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        int n = arr.length;\\n        PriorityQueue<Element> minHeap = new PriorityQueue<Element>((a,b)->(arr[a.i]*arr[b.j]-arr[b.i]*arr[a.j]));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                minHeap.add(new Element(i,j));\\n            }\\n        }\\n        \\n        Element e=null;\\n        while(k!=0){\\n            e = minHeap.poll();\\n            k--;\\n        }\\n        return new int[]{arr[e.i],arr[e.j]};\\n    }\\n}\\n\\nclass Element{\\n    int i;\\n    int j;\\n    \\n    Element(int i,int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        int n = arr.length;\\n        \\n        double low = 0;\\n        double high = 1.0;\\n        while(low<high){\\n            double mid = (low+high)/2;\\n            int res[] = getFractionsLessThanMid(arr,k,n,mid);\\n            \\n            if(res[0]==k) return new int[]{arr[res[1]],arr[res[2]]};\\n            else if(res[0]>k) high = mid;\\n            else low = mid;\\n        }\\n        \\n        return new int[]{};\\n    }\\n    \\n    private int[] getFractionsLessThanMid(int arr[],int k,int n,double mid){\\n        double maxLessThanMid = 0.0;\\n        int x = 0; //stores indices of max fraction less than mid;\\n        int y = 0;\\n            \\n        int total = 0;//for storing fractions less than mid\\n        int j = 1;\\n            \\n        for(int i=0;i<n-1;i++){    \\n            \\n            //while fraction is greater than mid increment j\\n            while(j<n && arr[i]>arr[j]*mid){\\n                j++;\\n            }\\n\\n            if(j==n) break;\\n\\n            total+=(n-j); //j fractions greater than mid, n-j fractions smaller than mid, add fractions smaller than mid to total\\n\\n            double fraction = (double)arr[i]/arr[j];\\n            if(fraction>maxLessThanMid){\\n                maxLessThanMid = fraction;\\n                x = i;\\n                y =j;\\n            }\\n        }\\n        return new int[]{total,x,y};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 299105,
                "title": "python-binary-search-solution",
                "content": "```python\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, A: List[int], K: int) -> List[int]:\\n        lo, hi, n = 0, 1, len(A)\\n        while lo < hi:\\n            mi, j, p, q, cnt =  (lo + hi) / 2, 0, 0, 1, 0\\n            for i in range(n):\\n                while j < n and A[i] / A[j] > mi: j += 1\\n                if j < n and p / q < A[i] / A[j]: p, q = A[i], A[j]\\n                cnt += n - j\\n            if cnt > K: hi = mi\\n            elif cnt < K: lo = mi\\n            else: return [p, q]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, A: List[int], K: int) -> List[int]:\\n        lo, hi, n = 0, 1, len(A)\\n        while lo < hi:\\n            mi, j, p, q, cnt =  (lo + hi) / 2, 0, 0, 1, 0\\n            for i in range(n):\\n                while j < n and A[i] / A[j] > mi: j += 1\\n                if j < n and p / q < A[i] / A[j]: p, q = A[i], A[j]\\n                cnt += n - j\\n            if cnt > K: hi = mi\\n            elif cnt < K: lo = mi\\n            else: return [p, q]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116107,
                "title": "java-better-than-o-nlogn-it-can-be-o-klogk",
                "content": "The size of heap is at most K, and by K operations, the time complexity is O(KlogK).\n```\npublic int[] kthSmallestPrimeFraction(int[] A, int K) {\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> A[a[0]] * A[b[1]] - A[a[1]] * A[b[0]]);\n    pq.offer(new int[]{0, A.length - 1});\n    while (K > 1 && !pq.isEmpty()) {\n        int[] cur = pq.poll();\n        if (cur[1] == A.length - 1 && cur[0] + 1 < cur[1]) {\n            pq.offer(new int[]{cur[0] + 1, cur[1]});\n        }\n        if (cur[0] < cur[1] - 1) {\n            pq.offer(new int[]{cur[0], cur[1] - 1});\n        }\n        K--;\n    }\n    if (pq.isEmpty()) {\n        throw new RuntimeException(\"invalid input.\");\n    }\n    return new int[]{A[pq.peek()[0]], A[pq.peek()[1]]};\n}\n```",
                "solutionTags": [],
                "code": "```\npublic int[] kthSmallestPrimeFraction(int[] A, int K) {\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> A[a[0]] * A[b[1]] - A[a[1]] * A[b[0]]);\n    pq.offer(new int[]{0, A.length - 1});\n    while (K > 1 && !pq.isEmpty()) {\n        int[] cur = pq.poll();\n        if (cur[1] == A.length - 1 && cur[0] + 1 < cur[1]) {\n            pq.offer(new int[]{cur[0] + 1, cur[1]});\n        }\n        if (cur[0] < cur[1] - 1) {\n            pq.offer(new int[]{cur[0], cur[1] - 1});\n        }\n        K--;\n    }\n    if (pq.isEmpty()) {\n        throw new RuntimeException(\"invalid input.\");\n    }\n    return new int[]{A[pq.peek()[0]], A[pq.peek()[1]]};\n}\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 392081,
                "title": "c-binary-search-clean-code",
                "content": "O(n^2) solution.\\n```\\nclass Solution\\n{\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int> &A, int K)\\n    {\\n        int n = A.size();\\n        // pq of size n\\n        double low = 0.0, high = 1.0, mid;\\n        // constant iterations, 20 iteration will have high - low < 1e-6\\n        // each search is nlogn\\n        while (low < high)\\n        {\\n            mid = (low + high) / 2.0;\\n            // count smaller than mid;\\n            int count = 0;\\n            for (auto den : A)\\n            {\\n                int limit = mid * den;\\n                // count smaller and equal than limit\\n                int c = upper_bound(A.begin(), A.end(), limit) - A.begin();\\n                count += c;\\n            }\\n            if (count == K)\\n                break;\\n            else if (count > K)\\n                high = mid;\\n            else\\n                low = mid;\\n        }\\n        // get largest fraction smaller or equal to mid\\n        // O(n^2)\\n        double maxx = 0;\\n        vector<int> res;\\n        for (int i = 0; i < n; ++i)\\n        {\\n            for (int j = i + 1; j < n; ++j)\\n            {\\n                double d = (double)A[i] / A[j];\\n                if (d <= mid && d > maxx)\\n                {\\n                    maxx = d;\\n                    res = {A[i], A[j]};\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int> &A, int K)\\n    {\\n        int n = A.size();\\n        // pq of size n\\n        double low = 0.0, high = 1.0, mid;\\n        // constant iterations, 20 iteration will have high - low < 1e-6\\n        // each search is nlogn\\n        while (low < high)\\n        {\\n            mid = (low + high) / 2.0;\\n            // count smaller than mid;\\n            int count = 0;\\n            for (auto den : A)\\n            {\\n                int limit = mid * den;\\n                // count smaller and equal than limit\\n                int c = upper_bound(A.begin(), A.end(), limit) - A.begin();\\n                count += c;\\n            }\\n            if (count == K)\\n                break;\\n            else if (count > K)\\n                high = mid;\\n            else\\n                low = mid;\\n        }\\n        // get largest fraction smaller or equal to mid\\n        // O(n^2)\\n        double maxx = 0;\\n        vector<int> res;\\n        for (int i = 0; i < n; ++i)\\n        {\\n            for (int j = i + 1; j < n; ++j)\\n            {\\n                double d = (double)A[i] / A[j];\\n                if (d <= mid && d > maxx)\\n                {\\n                    maxx = d;\\n                    res = {A[i], A[j]};\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 115502,
                "title": "share-my-o-nlogn-solution-using-binary-search",
                "content": "Basically, I first use binary search to find a estimation. Then use the estimation and predefined error to search for the precise result.\nThe running time is O(C*nlogn) + O(n) where C is a constant depending on the error.\nI don't know the best way figure out the value of best error, but 1e-9 works for all tests cases.\n\n```\nclass Solution {\n    \n    private static final double err = 1e-9;\n    \n    private int smaller(double [] A, double val) {\n        int cnt = 0;\n        // fix q as A[j], binary search p as A[i]\n        for (int j = 1; j < A.length; ++j) {\n            // find the last element that is smaller than val\n            int lo = 0;\n            int hi = j - 1;\n            while (lo < hi) {\n                int mid = (lo + hi + 1) / 2;\n                if (A[mid] / A[j] < val) {\n                    lo = mid;\n                } else {\n                    hi = mid - 1;\n                }\n            }\n            if (lo == hi) {\n                cnt += ((A[lo] / A[j] < val) ? lo + 1 : lo);\n            }\n        }\n        return cnt;\n    }\n    \n    public int[] kthSmallestPrimeFraction(int[] AA, int K) {\n        // binary search the value\n        double [] A = new double [AA.length];\n        Set<Integer> nums = new HashSet<>();\n        for (int i = 0; i < A.length; ++i) {\n            A[i] = AA[i];\n            nums.add(AA[i]);\n        }\n        double lo = 1.0 / 30000;\n        double hi = 29999.0 / 30000;\n        while (hi - lo > err) {\n            double mid = (lo + hi) / 2;\n            int cnt = smaller(A, mid); // how many fractions smaller than mid\n            if (cnt > K - 1) {\n                hi = mid;\n            } else {\n                lo = mid;\n            }\n        }\n        \n        for (int i = 0; i < A.length; ++i) {\n            // search for each possible q (A[i])\n            int p = (int)Math.round(lo * A[i]);\n            if (p < A[i] && nums.contains(p) && Math.abs(p/A[i] - lo) < err) {\n                return new int[] {p, AA[i]};\n            }\n        }\n        // unreachable\n        assert(false);\n        return null;\n    }\n}\n\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    \n    private static final double err = 1e-9;\n    \n    private int smaller(double [] A, double val) {\n        int cnt = 0;\n        // fix q as A[j], binary search p as A[i]\n        for (int j = 1; j < A.length; ++j) {\n            // find the last element that is smaller than val\n            int lo = 0;\n            int hi = j - 1;\n            while (lo < hi) {\n                int mid = (lo + hi + 1) / 2;\n                if (A[mid] / A[j] < val) {\n                    lo = mid;\n                } else {\n                    hi = mid - 1;\n                }\n            }\n            if (lo == hi) {\n                cnt += ((A[lo] / A[j] < val) ? lo + 1 : lo);\n            }\n        }\n        return cnt;\n    }\n    \n    public int[] kthSmallestPrimeFraction(int[] AA, int K) {\n        // binary search the value\n        double [] A = new double [AA.length];\n        Set<Integer> nums = new HashSet<>();\n        for (int i = 0; i < A.length; ++i) {\n            A[i] = AA[i];\n            nums.add(AA[i]);\n        }\n        double lo = 1.0 / 30000;\n        double hi = 29999.0 / 30000;\n        while (hi - lo > err) {\n            double mid = (lo + hi) / 2;\n            int cnt = smaller(A, mid); // how many fractions smaller than mid\n            if (cnt > K - 1) {\n                hi = mid;\n            } else {\n                lo = mid;\n            }\n        }\n        \n        for (int i = 0; i < A.length; ++i) {\n            // search for each possible q (A[i])\n            int p = (int)Math.round(lo * A[i]);\n            if (p < A[i] && nums.contains(p) && Math.abs(p/A[i] - lo) < err) {\n                return new int[] {p, AA[i]};\n            }\n        }\n        // unreachable\n        assert(false);\n        return null;\n    }\n}\n\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488364,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n         priority_queue<pair<double, pair<int, int>>> pq;\\n         int n = arr.size();\\n         for(int i = 0 ; i < n - 1; i++){\\n            for(int j = i + 1 ; j < n; j++){\\n                pq.push({(double)arr[i]/arr[j],{arr[i], arr[j]}});\\n                if(pq.size() > k)\\n                    pq.pop();\\n            }   \\n        }\\n        return {pq.top().second.first,pq.top().second.second};  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n         priority_queue<pair<double, pair<int, int>>> pq;\\n         int n = arr.size();\\n         for(int i = 0 ; i < n - 1; i++){\\n            for(int j = i + 1 ; j < n; j++){\\n                pq.push({(double)arr[i]/arr[j],{arr[i], arr[j]}});\\n                if(pq.size() > k)\\n                    pq.pop();\\n            }   \\n        }\\n        return {pq.top().second.first,pq.top().second.second};  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354875,
                "title": "easy-solution-using-priority-queue",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        \\n           priority_queue<pair<float, pair<int, int>>> q;\\n\\n        int n=arr.size();\\n\\n        for(int i=0; i<n-1; i++){\\n            for(int j=i+1; j<n; j++){\\n               q.push({(float)arr[i]/arr[j],{arr[i], arr[j]}});\\n                if(q.size() > k)q.pop();\\n            }\\n        }\\n\\n        return {q.top().second.first, q.top().second.second};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        \\n           priority_queue<pair<float, pair<int, int>>> q;\\n\\n        int n=arr.size();\\n\\n        for(int i=0; i<n-1; i++){\\n            for(int j=i+1; j<n; j++){\\n               q.push({(float)arr[i]/arr[j],{arr[i], arr[j]}});\\n                if(q.size() > k)q.pop();\\n            }\\n        }\\n\\n        return {q.top().second.first, q.top().second.second};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272142,
                "title": "simple-approach-priority-queue-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        vector<int>ans;\\n        priority_queue<pair<float,pair<int,int>>>pq;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            for(int j=i+1;j<arr.size();j++)\\n            {\\n                float frac=double(arr[i])/arr[j];\\n                if(pq.size()<k)\\n                {\\n                    pq.push({frac,{arr[i],arr[j]}});\\n                }\\n                else if(pq.top().first>frac)\\n                {\\n                    pq.pop();\\n                    pq.push({frac,{arr[i],arr[j]}});\\n                }\\n            }\\n        }\\n        ans.push_back(pq.top().second.first);\\n        ans.push_back(pq.top().second.second);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        vector<int>ans;\\n        priority_queue<pair<float,pair<int,int>>>pq;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            for(int j=i+1;j<arr.size();j++)\\n            {\\n                float frac=double(arr[i])/arr[j];\\n                if(pq.size()<k)\\n                {\\n                    pq.push({frac,{arr[i],arr[j]}});\\n                }\\n                else if(pq.top().first>frac)\\n                {\\n                    pq.pop();\\n                    pq.push({frac,{arr[i],arr[j]}});\\n                }\\n            }\\n        }\\n        ans.push_back(pq.top().second.first);\\n        ans.push_back(pq.top().second.second);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772878,
                "title": "python-3-maxheap",
                "content": "```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        res = []\\n        \\n        for i in range(len(arr)):\\n            for j in range(i + 1, len(arr)):\\n                heappush(res, (-(arr[i] / arr[j]), arr[i], arr[j]))\\n                \\n                if len(res) > k:\\n                    heappop(res)\\n        \\n        return [res[0][1], res[0][2]]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        res = []\\n        \\n        for i in range(len(arr)):\\n            for j in range(i + 1, len(arr)):\\n                heappush(res, (-(arr[i] / arr[j]), arr[i], arr[j]))\\n                \\n                if len(res) > k:\\n                    heappop(res)\\n        \\n        return [res[0][1], res[0][2]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2255104,
                "title": "c-solution-using-priority-queue-max-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<pair<double,pair<int,int>>> pq;\\n        for(int i = 0;i<arr.size();i++){\\n            for(int j = i+1;j<arr.size();j++){\\n                double temp = (double)arr[i]/arr[j];\\n                pq.push(make_pair(temp,make_pair(arr[i],arr[j])));\\n                    if(pq.size()>k)\\n                        pq.pop();\\n            }\\n        }\\n        vector<int> ans;\\n        ans.push_back(pq.top().second.first);\\n        ans.push_back(pq.top().second.second);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<pair<double,pair<int,int>>> pq;\\n        for(int i = 0;i<arr.size();i++){\\n            for(int j = i+1;j<arr.size();j++){\\n                double temp = (double)arr[i]/arr[j];\\n                pq.push(make_pair(temp,make_pair(arr[i],arr[j])));\\n                    if(pq.size()>k)\\n                        pq.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 127310,
                "title": "python-binary-search-simple-and-fast-120-ms",
                "content": "similar idea comes from this solution ( that\\'s where the \"nums = A k = K\" comes from. I basically changed that solution into this one):\\nhttps://leetcode.com/problems/find-k-th-smallest-pair-distance/discuss/109082/Approach-the-problem-using-the-%22trial-and-error%22-algorithm\\nThe idea is for each value between 0 and 1, find how many numbers (x) are smaller than the value, and find out the biggist one in those numbers. if x = K, then the biggist one is the result.\\nthe time complexity should be O(n*log10000000) = O(23n) almost O(n)\\n```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, A, K):\\n        nums = A\\n        k = K\\n        #find the smallest and largest distance it can be\\n        small = 0.0\\n        large = 1.0\\n        #binary search small and large\\n        p = q = 0\\n        while large - small > 0.0000001:\\n            mid = small + (large-small)/2\\n            cnt = 0\\n            i = 1\\n            j = 0\\n            minDiff = 1.0\\n            for i in range(1,len(nums)):\\n                while j < i and nums[j]/nums[i] <= mid:\\n                    if minDiff > mid - nums[j]/nums[i]:\\n                        minDiff = mid - nums[j]/nums[i]\\n                        p = nums[i]\\n                        q = nums[j]\\n                    j+=1\\n                cnt += j\\n            if cnt == k:\\n                break;\\n            if cnt < k:\\n                small = mid\\n            else:\\n                large = mid \\n        return (q,p)\\n\\t\\t\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, A, K):\\n        nums = A\\n        k = K\\n        #find the smallest and largest distance it can be\\n        small = 0.0\\n        large = 1.0\\n        #binary search small and large\\n        p = q = 0\\n        while large - small > 0.0000001:\\n            mid = small + (large-small)/2\\n            cnt = 0\\n            i = 1\\n            j = 0\\n            minDiff = 1.0\\n            for i in range(1,len(nums)):\\n                while j < i and nums[j]/nums[i] <= mid:\\n                    if minDiff > mid - nums[j]/nums[i]:\\n                        minDiff = mid - nums[j]/nums[i]\\n                        p = nums[i]\\n                        q = nums[j]\\n                    j+=1\\n                cnt += j\\n            if cnt == k:\\n                break;\\n            if cnt < k:\\n                small = mid\\n            else:\\n                large = mid \\n        return (q,p)\\n\\t\\t\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 115986,
                "title": "c-video-solution",
                "content": "See video solution [here.](https://www.youtube.com/watch?v=3Ep-PXy8YIc)\n\n````\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct fraction {\n\tdouble value;\n\tint i, j;\n\tfraction (double d, int x, int y) : value (d), i (x), j (y) {}\n\tbool operator< (const fraction& f) const { return value > f.value; }\n};\n\nvector<int> kthSmallestPrimeFraction (vector<int>& A, int K) {\n\n\tpriority_queue<fraction> pq;\n\n\tfor (int i = 0; i < A.size (); i++) {\n\t\tpq.push (fraction (static_cast<double> (A[i]) / A.back (), i, A.size () - 1));\n\t}\n\n\twhile (K > 1)\n\t{\n\t\tauto top = pq.top ();\n\t\tpq.pop ();\n\t\ttop.j--;\n\t\tpq.push (fraction (static_cast<double> (A[top.i]) / A[top.j], top.i, top.j));\n\t\tK--;\n\t}\n\n\treturn { A[pq.top ().i], A[pq.top ().j] };\n}",
                "solutionTags": [],
                "code": "See video solution [here.](https://www.youtube.com/watch?v=3Ep-PXy8YIc)\n#include <vector>\n#include <queue>\nusing namespace std;\nstruct fraction {\n\tdouble value;\n\tint i, j;\n\tfraction (double d, int x, int y) : value (d), i (x), j (y) {}\n\tbool operator< (const fraction& f) const { return value > f.value; }\n};\nvector<int> kthSmallestPrimeFraction (vector<int>& A, int K) {\n\tpriority_queue<fraction> pq;\n\tfor (int i = 0; i < A.size (); i++) {\n\t\tpq.push (fraction (static_cast<double> (A[i]) / A.back (), i, A.size () - 1));\n\t}\n\twhile (K > 1)\n\t{\n\t\tauto top = pq.top ();\n\t\tpq.pop ();\n\t\ttop.j--;\n\t\tpq.push (fraction (static_cast<double> (A[top.i]) / A[top.j], top.i, top.j));\n\t\tK--;\n\t}\n\treturn { A[pq.top ().i], A[pq.top ().j] };\n}",
                "codeTag": "C++"
            },
            {
                "id": 3081422,
                "title": "easy-solution-using-priority-queue",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n         priority_queue<pair<float, pair<int, int>>> q;\\n         int n = arr.size();\\n         for(int i = 0 ; i < n - 1; i++){\\n            for(int j = i + 1 ; j < n; j++){\\n                q.push({(float)arr[i]/arr[j],{arr[i], arr[j]}});\\n                if(q.size() > k)q.pop();\\n            }   \\n        }\\n        return {q.top().second.first,q.top().second.second};  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n         priority_queue<pair<float, pair<int, int>>> q;\\n         int n = arr.size();\\n         for(int i = 0 ; i < n - 1; i++){\\n            for(int j = i + 1 ; j < n; j++){\\n                q.push({(float)arr[i]/arr[j],{arr[i], arr[j]}});\\n                if(q.size() > k)q.pop();\\n            }   \\n        }\\n        return {q.top().second.first,q.top().second.second};  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2890675,
                "title": "c-binary-search-solution",
                "content": "# Intuition\\nThis problem can be easily solved by **Brute Force** i.e. iterating over two for loops and calculating each fractional value as a floating point number and then sort it and return the Kth index value.\\n\\nSince it is Brute Force and is done in O(n^2) Time Complexity.\\nLet\\'s move to better solution that takes less than O(n^2) Time.\\n\\nIf we want to find fraction between any two values i.e. different i and j, which gives us:\\n**Arr[i]/Arr[j] = fraction_value**, can also be written as **Arr[i] = fraction_value * Arr[j]**\\nSo, if we have fraction_value then we can check in an array for till which index Arr[i] / Arr[j] can last.\\nEx: [1,2,5,7], Here if fraction_value = 0.5, then for each Arr[i] we can find maximum index till where Arr[i]/0.5 will be valid.\\ni.e.\\nArr[0] = 1, Arr[0]/0.5 = 2   =  Arr[j]\\nArr[1] = 2, Arr[1]/0.5 = 4   =  Arr[j]\\nArr[2] = 5, Arr[2]/0.5 = 10  =  Arr[j]\\nArr[3] = 7, Arr[4]/0.5 = 14  =  Arr[j]\\nSo for each index i, j is the upper bound index to get Kth number and denotes that j elements have fraction greater than 0.5\\nOverall, we must find a fraction_value for which there exists only K numbers such that all numbers have fraction less than equal to chosen fraction_value\\nThis can done via Binary Search.\\n\\n# Approach\\n1) Take left = 0 and right = 1\\n2) Take mid = (left+right)/2 as a fractional_value\\n3) Now for each number in the array, find how many numbers can have fraction_value exactly equal to mid\\n4) Find the upper bound index of **Arr[i]/mid** in the Array, this will calculate the indices for which the fraction_value is greater than mid on left side of indices and less than equal to mid on the right side.\\n5) Since we are interested in smallest fraction_values to find the Kth number, calculate the sum i.e. total number of Numbers for which the fraction_value is less than equal to mid\\n6) Now, here comes 3 situations:\\n a) If the **sum > K**, that means the mid value i.e. fraction_value is high or larger because it can not hold exactly K elements.\\nb) If the **sum < K**, that means the mid value i.e. fraction_value is low or smaller because it can hold less than K elements but we need to find the Kth index number in sorted fraction_values.\\nc) **Sum == K**, since K numbers is the amount we require because we can find the maximum desired fraction_values in these k values which was not possible when sum>k or sum<k\\n\\n7) After getting the final K numbers, we have find the maximum set which gives a/b i.e. maximum fraction value\\n\\n\\n# Complexity\\n- Time complexity:\\n**O(n*logn)**\\n\\n- Space complexity:\\nBounds vector : **O(n)**\\n\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int helper(float check, vector<int>& arr){\\n        int left = 0, right = arr.size();\\n        while(left<right){\\n            int mid = left + (right-left)/2;\\n            if(arr[mid]==check){\\n                return mid;\\n            }\\n            else if(arr[mid]>check){\\n                right = mid;\\n            }\\n            else{\\n                left = mid+1;\\n            }\\n        }\\n        return right;\\n    }\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        float left = 0, right = 1;\\n        int n = arr.size();\\n        while(true){\\n            float mid = float((float(left)+float(right))/2);\\n            vector<int> bounds;\\n            for(int i=0;i<n;i++){\\n                bounds.emplace_back(helper(float(arr[i])/mid,arr));\\n            }\\n            int curr_sum = 0;\\n            for(auto b:bounds){\\n                if(b<n) curr_sum += (n-b);\\n            }\\n            // cout<<curr_sum<<endl;\\n            if(curr_sum > k){\\n                right = mid;\\n            }\\n            else if(curr_sum < k){\\n                left = mid;\\n            }\\n            else{\\n                int a = 0, b = 0;\\n                float mx = 0;\\n                for(int i=0;i<bounds.size();i++){\\n                    if(bounds[i]<n){\\n                        if(float(arr[i])/float(arr[bounds[i]]) > mx){\\n                            mx = float(arr[i])/float(arr[bounds[i]]);\\n                            a = arr[bounds[i]]; b = arr[i];\\n                        }\\n                    }\\n                }\\n                return {b,a};\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```\\n\\n**Do upvote if you understood the solution :)\\nDo suggest any changes or errors in Time/Space complexity or any other**",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int helper(float check, vector<int>& arr){\\n        int left = 0, right = arr.size();\\n        while(left<right){\\n            int mid = left + (right-left)/2;\\n            if(arr[mid]==check){\\n                return mid;\\n            }\\n            else if(arr[mid]>check){\\n                right = mid;\\n            }\\n            else{\\n                left = mid+1;\\n            }\\n        }\\n        return right;\\n    }\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        float left = 0, right = 1;\\n        int n = arr.size();\\n        while(true){\\n            float mid = float((float(left)+float(right))/2);\\n            vector<int> bounds;\\n            for(int i=0;i<n;i++){\\n                bounds.emplace_back(helper(float(arr[i])/mid,arr));\\n            }\\n            int curr_sum = 0;\\n            for(auto b:bounds){\\n                if(b<n) curr_sum += (n-b);\\n            }\\n            // cout<<curr_sum<<endl;\\n            if(curr_sum > k){\\n                right = mid;\\n            }\\n            else if(curr_sum < k){\\n                left = mid;\\n            }\\n            else{\\n                int a = 0, b = 0;\\n                float mx = 0;\\n                for(int i=0;i<bounds.size();i++){\\n                    if(bounds[i]<n){\\n                        if(float(arr[i])/float(arr[bounds[i]]) > mx){\\n                            mx = float(arr[i])/float(arr[bounds[i]]);\\n                            a = arr[bounds[i]]; b = arr[i];\\n                        }\\n                    }\\n                }\\n                return {b,a};\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2744456,
                "title": "binary-search-sliding-window-beats-91-21",
                "content": "# Intuition\\n\\nBinary search the possible range of fraction `[0, 1]`. For each possible value `v`, we use sliding window (two pointers) to count the number (`cnt`) of fractions < v, as well as record the largest fraction `l/r` that is < v.\\n\\nDuring binary search, when `cnt == k` we can return the result `[l, r]`.\\n\\n# Complexity\\n- Time complexity: O(NlogW), where N is array size, and W is the range size between the smallest and the largest fraction, in float number space.\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        N = len(arr)\\n        def count_less(v):\\n            \"\"\"1. the number of fractions < v\\n            2. the largest fraction l/r that is < v\"\"\"\\n            li = 0\\n            cnt, l, r = 0, arr[0], arr[-1]\\n            for ri in range(1, N):\\n                while li < ri and arr[li]/arr[ri] < v:\\n                    if arr[li]/arr[ri] > l/r:\\n                        l, r = arr[li], arr[ri]\\n                    li += 1\\n                cnt += li\\n            return cnt, l, r\\n\\n        lo, hi = arr[0]/arr[-1], 1\\n        while lo <= hi:\\n            v = (lo+hi)/2\\n            cnt, l, r = count_less(v)\\n            if cnt == k:\\n                return [l, r]\\n            if cnt < k:\\n                lo = v\\n            else:\\n                hi = v\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        N = len(arr)\\n        def count_less(v):\\n            \"\"\"1. the number of fractions < v\\n            2. the largest fraction l/r that is < v\"\"\"\\n            li = 0\\n            cnt, l, r = 0, arr[0], arr[-1]\\n            for ri in range(1, N):\\n                while li < ri and arr[li]/arr[ri] < v:\\n                    if arr[li]/arr[ri] > l/r:\\n                        l, r = arr[li], arr[ri]\\n                    li += 1\\n                cnt += li\\n            return cnt, l, r\\n\\n        lo, hi = arr[0]/arr[-1], 1\\n        while lo <= hi:\\n            v = (lo+hi)/2\\n            cnt, l, r = count_less(v)\\n            if cnt == k:\\n                return [l, r]\\n            if cnt < k:\\n                lo = v\\n            else:\\n                hi = v\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463340,
                "title": "c-priority-queue-short-easy",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) \\n    {\\n        priority_queue<pair<double,pair<int,int>>> pq;\\n        for(int i=0;i<arr.size()-1;i++)\\n            for(int j=i+1;j<arr.size();j++)\\n            {\\n                pq.push({(double)arr[i]/(double)arr[j],{arr[i],arr[j]}});\\n                if(pq.size()>k)\\n                    pq.pop();\\n            }\\n        return {pq.top().second.first,pq.top().second.second};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) \\n    {\\n        priority_queue<pair<double,pair<int,int>>> pq;\\n        for(int i=0;i<arr.size()-1;i++)\\n            for(int j=i+1;j<arr.size();j++)\\n            {\\n                pq.push({(double)arr[i]/(double)arr[j],{arr[i],arr[j]}});\\n                if(pq.size()>k)\\n                    pq.pop();\\n            }\\n        return {pq.top().second.first,pq.top().second.second};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281192,
                "title": "lo-aagya-tumhara-bhai-sabse-easy-solution-lekar",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n      \\n    \\n      priority_queue<pair<double, pair<int, int>>>ans;\\n    for(int i=0;i<arr.size()-1;i++)\\n    {\\n      for(int j=i+1;j<arr.size();j++)\\n      { double x=(double)arr[i] /(double)arr[j];\\n       if(ans.size()<k)\\n       ans.push({x,{arr[i],arr[j]}});\\n       else if(ans.top().first>x)\\n       {\\n         ans.pop();\\n         ans.push({x,{arr[i],arr[j]}});\\n       }\\n       else continue;\\n      }\\n    }\\n      vector<int>res;\\n      res.push_back(ans.top().second.first);\\n      res.push_back(ans.top().second.second);\\n      return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n      \\n    \\n      priority_queue<pair<double, pair<int, int>>>ans;\\n    for(int i=0;i<arr.size()-1;i++)\\n    {\\n      for(int j=i+1;j<arr.size();j++)\\n      { double x=(double)arr[i] /(double)arr[j];\\n       if(ans.size()<k)\\n       ans.push({x,{arr[i],arr[j]}});\\n       else if(ans.top().first>x)\\n       {\\n         ans.pop();\\n         ans.push({x,{arr[i],arr[j]}});\\n       }\\n       else continue;\\n      }\\n    }\\n      vector<int>res;\\n      res.push_back(ans.top().second.first);\\n      res.push_back(ans.top().second.second);\\n      return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1812356,
                "title": "425-ms-o-n-2-c-solution-using-priority-queue-and-comparator-class",
                "content": "For fractions `x / y` and `p / q` we can compare the two fractions as follows:\\n\\t\\t\\tLet `x / y` ` <` `p / q`\\n\\t\\t\\tthen `x * q` `<`  `y * p`   **[Cross Multiplication Method]**\\n\\t\\t\\t\\n```\\ntypedef pair<int,int> pr;\\nclass Solution {\\npublic:\\n    class Compare\\n    {\\n        public:\\n        bool operator() (const pr &p1, const pr &p2)\\n        {\\n            if(p1.first*p2.second < p1.second*p2.first){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n    };\\n   \\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<pr,vector<pr>, Compare> pq;\\n        for(int i=0;i<arr.size();++i)\\n            for(int j=i+1;j<arr.size();++j){\\n                pq.push({arr[i],arr[j]});\\n                if(pq.size() > k) pq.pop();\\n            }\\n            \\n       \\n        return vector<int>{pq.top().first,pq.top().second};\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntypedef pair<int,int> pr;\\nclass Solution {\\npublic:\\n    class Compare\\n    {\\n        public:\\n        bool operator() (const pr &p1, const pr &p2)\\n        {\\n            if(p1.first*p2.second < p1.second*p2.first){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n    };\\n   \\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<pr,vector<pr>, Compare> pq;\\n        for(int i=0;i<arr.size();++i)\\n            for(int j=i+1;j<arr.size();++j){\\n                pq.push({arr[i],arr[j]});\\n                if(pq.size() > k) pq.pop();\\n            }\\n            \\n       \\n        return vector<int>{pq.top().first,pq.top().second};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555258,
                "title": "c-binary-search-in-segment-0-1",
                "content": "The idea is to find a value `m` to separate all fractions in two sets: `< m` and `>= m`.\\nIn each step we should calculate the number of fractions in set `< m` and the greatest value in it. If `< m` contains of k fractions, than `the greatest value in it` will be the answer.\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        double l = 0, r = 1;\\n        \\n        while (l < r) {\\n            double m = (l + r) / 2;\\n            int numerator = 0, denominator = 0, count = 0;\\n            \\n            for (int i = 0; i < arr.size(); ++i) {\\n                auto it = lower_bound(arr.begin(), arr.end(), m * arr[i]);\\n                count += it - arr.begin();\\n                \\n                if (it != arr.begin() && numerator * arr[i] <= *(it - 1) * denominator) {\\n                    numerator = *(it - 1);\\n                    denominator = arr[i];\\n                }\\n            }\\n            \\n            if (count == k) {\\n                return {numerator, denominator};\\n            } else if (count < k) {\\n                l = m;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        \\n        return {0, 0};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        double l = 0, r = 1;\\n        \\n        while (l < r) {\\n            double m = (l + r) / 2;\\n            int numerator = 0, denominator = 0, count = 0;\\n            \\n            for (int i = 0; i < arr.size(); ++i) {\\n                auto it = lower_bound(arr.begin(), arr.end(), m * arr[i]);\\n                count += it - arr.begin();\\n                \\n                if (it != arr.begin() && numerator * arr[i] <= *(it - 1) * denominator) {\\n                    numerator = *(it - 1);\\n                    denominator = arr[i];\\n                }\\n            }\\n            \\n            if (count == k) {\\n                return {numerator, denominator};\\n            } else if (count < k) {\\n                l = m;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        \\n        return {0, 0};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691784,
                "title": "java-o-k-log-n-solution-with-o-n-space",
                "content": "```\\nclass Solution {\\n    public int[] kthSmallestPrimeFraction(int[] A, int K) {\\n        Queue<Pair<Integer, Integer>> queue = new PriorityQueue<>((a, b) -> {\\n            double left = (double) A[a.getKey()] / A[a.getValue()];\\n            double right = (double) A[b.getKey()] / A[b.getValue()];\\n            return Double.compare(left, right);\\n        });\\n        \\n        int n = A.length;\\n        for (int i = 1; i < n; i++) {\\n            queue.add(new Pair(0, i));\\n        }\\n        \\n        while (K-- > 1) {\\n            Pair<Integer, Integer> current = queue.poll();\\n            \\n            if (current.getKey() + 1 >= current.getValue()) {\\n                continue;\\n            }\\n            \\n            queue.add(new Pair(current.getKey() + 1, current.getValue()));\\n        }\\n        \\n        Pair<Integer, Integer> answer = queue.poll();\\n        return new int[] { A[answer.getKey()], A[answer.getValue()] };\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] kthSmallestPrimeFraction(int[] A, int K) {\\n        Queue<Pair<Integer, Integer>> queue = new PriorityQueue<>((a, b) -> {\\n            double left = (double) A[a.getKey()] / A[a.getValue()];\\n            double right = (double) A[b.getKey()] / A[b.getValue()];\\n            return Double.compare(left, right);\\n        });\\n        \\n        int n = A.length;\\n        for (int i = 1; i < n; i++) {\\n            queue.add(new Pair(0, i));\\n        }\\n        \\n        while (K-- > 1) {\\n            Pair<Integer, Integer> current = queue.poll();\\n            \\n            if (current.getKey() + 1 >= current.getValue()) {\\n                continue;\\n            }\\n            \\n            queue.add(new Pair(current.getKey() + 1, current.getValue()));\\n        }\\n        \\n        Pair<Integer, Integer> answer = queue.poll();\\n        return new int[] { A[answer.getKey()], A[answer.getValue()] };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 579624,
                "title": "minimum-heap-priority-queue-python-solution-with-explaination",
                "content": "```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, A: List[int], k: int) -> List[int]:\\n\\t\\t#pq is a Priority Queue Array\\n        pq = []\\n        for i,v in enumerate(A):\\n\\t\\t\\t# Pushing [\\n\\t\\t\\t#\\tp/q (toCompare),\\n\\t\\t\\t#\\trowNumber (To Prioritize Next Smallest Fraction)\\n\\t\\t\\t#   colNumber (To Prioritize Next Smallest Fraction)\\n\\t\\t\\t#   p (to retuen the value)\\n\\t\\t\\t#   q (to return the value) ]\\n            heappush(pq, (1/v, i, 0, 1, v))\\n\\n        while k > 0:\\n\\t\\t\\t# popping out the minimum\\n            v, row, col, p, q = heappop(pq)\\n\\n\\t\\t\\t# if next value of same row is available\\n            if col < len(A):\\n\\t\\t\\t\\t# if p < q then only push it to pq\\n                if row > col+1:\\n                    heappush(pq, (A[col+1]/A[row], row, col+1, A[col+1], A[row]))\\n            k -= 1\\n\\t\\t\\t\\n        return [p, q]",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, A: List[int], k: int) -> List[int]:\\n\\t\\t#pq is a Priority Queue Array\\n        pq = []\\n        for i,v in enumerate(A):\\n\\t\\t\\t# Pushing [\\n\\t\\t\\t#\\tp/q (toCompare),\\n\\t\\t\\t#\\trowNumber (To Prioritize Next Smallest Fraction)\\n\\t\\t\\t#   colNumber (To Prioritize Next Smallest Fraction)\\n\\t\\t\\t#   p (to retuen the value)\\n\\t\\t\\t#   q (to return the value) ]\\n            heappush(pq, (1/v, i, 0, 1, v))\\n\\n        while k > 0:\\n\\t\\t\\t# popping out the minimum\\n            v, row, col, p, q = heappop(pq)\\n\\n\\t\\t\\t# if next value of same row is available\\n            if col < len(A):\\n\\t\\t\\t\\t# if p < q then only push it to pq\\n                if row > col+1:\\n                    heappush(pq, (A[col+1]/A[row], row, col+1, A[col+1], A[row]))\\n            k -= 1\\n\\t\\t\\t\\n        return [p, q]",
                "codeTag": "Java"
            },
            {
                "id": 115682,
                "title": "java-binary-search",
                "content": "    public int[] kthSmallestPrimeFraction(int[] A, int K) {\n        int n = A.length, x = 0, y = 0, total = 0;\n        double l = 0, r = 1;\n        while(total != K) {\n            total = 0;\n            double m = (l + r) /2.0, max = 0.0;\n            for(int i = 0, j = 1; i < n; i++) {\n                while(j < n && A[i] > m * A[j])\n                    j++;\n                if (j == n || (total += n - j) > K)\n                    break;\n                if (A[i] > max * A[j]) {\n                    max = A[i] / (double) A[j] ;\n                    x = A[i];\n                    y = A[j];\n                }\n            }\n            if (total > K)\n                r = m;\n            else \n                l = m;\n        }\n        return new int[] {x, y};\n    }",
                "solutionTags": [],
                "code": "    public int[] kthSmallestPrimeFraction(int[] A, int K) {\n        int n = A.length, x = 0, y = 0, total = 0;\n        double l = 0, r = 1;\n        while(total != K) {\n            total = 0;\n            double m = (l + r) /2.0, max = 0.0;\n            for(int i = 0, j = 1; i < n; i++) {\n                while(j < n && A[i] > m * A[j])\n                    j++;\n                if (j == n || (total += n - j) > K)\n                    break;\n                if (A[i] > max * A[j]) {\n                    max = A[i] / (double) A[j] ;\n                    x = A[i];\n                    y = A[j];\n                }\n            }\n            if (total > K)\n                r = m;\n                l = m;\n        }\n        return new int[] {x, y};\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3465690,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    double cur_large;\\n    double ans=99999;\\n    int ans_row,ans_col;\\n    int cur_row,cur_col;\\n    int smaller_count(double mid,vector<int>& arr)\\n    {\\n        int row=0, col=0;\\n        int counter=0;\\n        cur_large=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            while(col<arr.size() && mid<((double)arr[row])/((double)arr[col]))\\n            {\\n                col++;\\n            }\\n            if(col<arr.size() && cur_large<((double)arr[row])/((double)arr[col]))\\n            {\\n                cur_large=((double)arr[row])/((double)arr[col]);\\n                cur_row=row;\\n                cur_col=col;\\n            }\\n            counter+=arr.size()-col;\\n            row++;\\n        }\\n        return counter;\\n    }\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        double start=0.0;\\n        double end=1.0;\\n        int counting;\\n        while(start<end)\\n        {\\n            double mid=(start+end)/2;\\n            counting=smaller_count(mid,arr);\\n            if(counting>=k)\\n            {\\n                if(ans>cur_large)\\n                {\\n                    ans=cur_large;\\n                    ans_row=cur_row;\\n                    ans_col=cur_col;\\n                }\\n                end=mid;\\n                if(counting==k)\\n                    break;\\n            }\\n            else\\n            {\\n                start=mid;\\n            }\\n        }\\n        vector<int> out;\\n        if(ans==99999)\\n        {\\n            return out;\\n        }\\n        else\\n        {\\n            out.push_back(arr[ans_row]);\\n            out.push_back(arr[ans_col]);\\n            return out;\\n        }\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        def con(value):\\n            nb_smallest_fraction = 0\\n            numer = arr[0]\\n            denom = arr[-1]\\n\\n            slow = 0\\n            for fast in range(1, len(arr)):\\n                while slow < fast and arr[slow] / arr[fast] < value:\\n                    if arr[slow] / arr[fast] > numer / denom:\\n                        numer, denom = arr[slow], arr[fast]\\n\\n                    slow += 1\\n\\n                nb_smallest_fraction += slow\\n\\n            return nb_smallest_fraction, numer, denom\\n\\n        l = arr[0] / arr[-1]\\n        r = 1\\n\\n        while l < r:\\n            m = (l+r) / 2\\n\\n            count, numer, denom = con(m)\\n\\n            if count == k:\\n                return [numer, denom]\\n\\n            if count > k:\\n                r = m\\n            else:\\n                l = m\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        int n = arr.length;\\n        \\n        double low = 0;\\n        double high = 1.0;\\n        while(low<high){\\n            double mid = (low+high)/2;\\n            int res[] = getFractionsLessThanMid(arr, n, mid);\\n            \\n            if(res[0]==k) return new int[]{arr[res[1]],arr[res[2]]};\\n            else if(res[0]>k) high = mid;\\n            else low = mid;\\n        }   \\n        return new int[]{};\\n    }\\n    private int[] getFractionsLessThanMid(int arr[], int n, double mid){\\n        double maxLessThanMid = 0.0;\\n        int x = 0;\\n        int y = 0;\\n        int total = 0;\\n        int j = 1;\\n        for(int i = 0 ; i < n-1 ; i++){    \\n            \\n            while(j < n && arr[i] > (arr[j] * mid)){\\n                j++;\\n            }\\n            if(j==n) break;\\n            total += (n-j);\\n\\n            double fraction = (double)arr[i]/arr[j];\\n            if(fraction > maxLessThanMid){\\n                maxLessThanMid = fraction;\\n                x = i;\\n                y = j;\\n            }\\n        }\\n        return new int[]{total,x,y};\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    double cur_large;\\n    double ans=99999;\\n    int ans_row,ans_col;\\n    int cur_row,cur_col;\\n    int smaller_count(double mid,vector<int>& arr)\\n    {\\n        int row=0, col=0;\\n        int counter=0;\\n        cur_large=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            while(col<arr.size() && mid<((double)arr[row])/((double)arr[col]))\\n            {\\n                col++;\\n            }\\n            if(col<arr.size() && cur_large<((double)arr[row])/((double)arr[col]))\\n            {\\n                cur_large=((double)arr[row])/((double)arr[col]);\\n                cur_row=row;\\n                cur_col=col;\\n            }\\n            counter+=arr.size()-col;\\n            row++;\\n        }\\n        return counter;\\n    }\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        double start=0.0;\\n        double end=1.0;\\n        int counting;\\n        while(start<end)\\n        {\\n            double mid=(start+end)/2;\\n            counting=smaller_count(mid,arr);\\n            if(counting>=k)\\n            {\\n                if(ans>cur_large)\\n                {\\n                    ans=cur_large;\\n                    ans_row=cur_row;\\n                    ans_col=cur_col;\\n                }\\n                end=mid;\\n                if(counting==k)\\n                    break;\\n            }\\n            else\\n            {\\n                start=mid;\\n            }\\n        }\\n        vector<int> out;\\n        if(ans==99999)\\n        {\\n            return out;\\n        }\\n        else\\n        {\\n            out.push_back(arr[ans_row]);\\n            out.push_back(arr[ans_col]);\\n            return out;\\n        }\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        def con(value):\\n            nb_smallest_fraction = 0\\n            numer = arr[0]\\n            denom = arr[-1]\\n\\n            slow = 0\\n            for fast in range(1, len(arr)):\\n                while slow < fast and arr[slow] / arr[fast] < value:\\n                    if arr[slow] / arr[fast] > numer / denom:\\n                        numer, denom = arr[slow], arr[fast]\\n\\n                    slow += 1\\n\\n                nb_smallest_fraction += slow\\n\\n            return nb_smallest_fraction, numer, denom\\n\\n        l = arr[0] / arr[-1]\\n        r = 1\\n\\n        while l < r:\\n            m = (l+r) / 2\\n\\n            count, numer, denom = con(m)\\n\\n            if count == k:\\n                return [numer, denom]\\n\\n            if count > k:\\n                r = m\\n            else:\\n                l = m\\n```\n```Java []\\nclass Solution {\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        int n = arr.length;\\n        \\n        double low = 0;\\n        double high = 1.0;\\n        while(low<high){\\n            double mid = (low+high)/2;\\n            int res[] = getFractionsLessThanMid(arr, n, mid);\\n            \\n            if(res[0]==k) return new int[]{arr[res[1]],arr[res[2]]};\\n            else if(res[0]>k) high = mid;\\n            else low = mid;\\n        }   \\n        return new int[]{};\\n    }\\n    private int[] getFractionsLessThanMid(int arr[], int n, double mid){\\n        double maxLessThanMid = 0.0;\\n        int x = 0;\\n        int y = 0;\\n        int total = 0;\\n        int j = 1;\\n        for(int i = 0 ; i < n-1 ; i++){    \\n            \\n            while(j < n && arr[i] > (arr[j] * mid)){\\n                j++;\\n            }\\n            if(j==n) break;\\n            total += (n-j);\\n\\n            double fraction = (double)arr[i]/arr[j];\\n            if(fraction > maxLessThanMid){\\n                maxLessThanMid = fraction;\\n                x = i;\\n                y = j;\\n            }\\n        }\\n        return new int[]{total,x,y};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072038,
                "title": "js-solution-brute-force-o-n-2-runtime-1787-ms-beats-55-56-memory-115-9-mb-beats-33-33",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar kthSmallestPrimeFraction = function(arr, k) {\\n    const res = [];\\n\\tarr.forEach((item, i) => {\\n\\t\\tfor (let j = i + 1; j < arr.length; j++) {\\n\\t\\t\\tres.push([ item / arr[j], item, arr[j] ]);\\n\\t\\t}\\n\\t});\\n\\tres.sort((a, b) => a[0] - b[0]);\\n\\treturn [ res[k - 1][1], res[k - 1][2] ];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar kthSmallestPrimeFraction = function(arr, k) {\\n    const res = [];\\n\\tarr.forEach((item, i) => {\\n\\t\\tfor (let j = i + 1; j < arr.length; j++) {\\n\\t\\t\\tres.push([ item / arr[j], item, arr[j] ]);\\n\\t\\t}\\n\\t});\\n\\tres.sort((a, b) => a[0] - b[0]);\\n\\treturn [ res[k - 1][1], res[k - 1][2] ];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2121258,
                "title": "explained-easiest-python-solution",
                "content": "# [Explained] Easiest Python Solution\\n\\nNote: It is not the most optimal solution, but it is easy and beginner friendly approach.\\n```\\nclass Solution:\\n\\n\\tdef kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n\\t\\tif len(arr) > 2:\\n\\t\\t\\tres = []  # list for storing the list: [prime fraction of arr[i]/arr[j], arr[i], arr[j]]\\n\\n\\t\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\tfor j in range(i + 1, len(arr)):\\n\\t\\t\\t\\t\\t# creating and adding the sublist to res\\n\\t\\t\\t\\t\\ttmp = [arr[i] / arr[j], arr[i], arr[j]]\\n\\t\\t\\t\\t\\tres.append(tmp)\\n\\n\\t\\t\\t# sorting res on the basis of value of arr[i] \\n\\t\\t\\tres.sort(key=lambda x: x[0])\\n\\n\\t\\t\\t# creating and returning the required list\\n\\t\\t\\treturn [res[k - 1][1], res[k - 1][2]]\\n\\t\\telse:\\n\\t\\t\\treturn arr\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n\\tdef kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n\\t\\tif len(arr) > 2:\\n\\t\\t\\tres = []  # list for storing the list: [prime fraction of arr[i]/arr[j], arr[i], arr[j]]\\n\\n\\t\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\tfor j in range(i + 1, len(arr)):\\n\\t\\t\\t\\t\\t# creating and adding the sublist to res\\n\\t\\t\\t\\t\\ttmp = [arr[i] / arr[j], arr[i], arr[j]]\\n\\t\\t\\t\\t\\tres.append(tmp)\\n\\n\\t\\t\\t# sorting res on the basis of value of arr[i] \\n\\t\\t\\tres.sort(key=lambda x: x[0])\\n\\n\\t\\t\\t# creating and returning the required list\\n\\t\\t\\treturn [res[k - 1][1], res[k - 1][2]]\\n\\t\\telse:\\n\\t\\t\\treturn arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2079089,
                "title": "c-binary-search",
                "content": "```\\nvector <int> v(2);\\nint a=1; \\n\\nclass Solution {\\npublic:\\n    \\n    void is_valid(vector<int>& arr,int k,double mid)\\n    {\\n        int n=arr.size();\\n        int count=0;\\n        int num=-1,den=-1;\\n        double imax = INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=n-1;j>i;j--)\\n            {\\n                double val = (double)arr[i]/arr[j];\\n                \\n                if( val < mid )\\n                {\\n                    count++;\\n                    if(imax <= val)\\n                    {\\n                        imax = val;\\n                        num = arr[i];\\n                        den = arr[j];\\n                    }\\n                }\\n                    \\n            }\\n        }\\n        \\n        if(count>k)\\n        a = -1;\\n        \\n        else if(count<k)\\n        a = 0;\\n        \\n        else\\n        {\\n            v[0] = num;\\n            v[1] = den;\\n        }\\n    }\\n    \\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        double low = arr[0]/arr[n-1];\\n        double high = 1;\\n        double mid;\\n       \\n        \\n        while(low<high)\\n        {\\n            mid = low + (high-low)/2;\\n            a=1;\\n            is_valid(arr,k,mid);\\n            \\n            if(a==0)\\n            low = mid;\\n            \\n            else if(a==-1)\\n            high = mid;\\n            \\n            else\\n                break;\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    void is_valid(vector<int>& arr,int k,double mid)\\n    {\\n        int n=arr.size();\\n        int count=0;\\n        int num=-1,den=-1;\\n        double imax = INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=n-1;j>i;j--)\\n            {\\n                double val = (double)arr[i]/arr[j];\\n                \\n                if( val < mid )\\n                {\\n                    count++;\\n                    if(imax <= val)\\n                    {\\n                        imax = val;\\n                        num = arr[i];\\n                        den = arr[j];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1796735,
                "title": "python-soln-using-heap",
                "content": "\\tclass Solution:\\n\\t\\tdef kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n\\t\\t\\t# using heap Time O(klogn)\\n\\t\\t\\tn = len(arr)\\n\\t\\t\\thp = [(arr[i]/arr[-1], i, n-1) for i in range(n-1)]\\n\\t\\t\\theapify(hp)\\n\\n\\t\\t\\twhile k-1:\\n\\t\\t\\t\\t_,i,j = heappop(hp)\\n\\t\\t\\t\\tif i < j-1:\\n\\t\\t\\t\\t\\theappush(hp, (arr[i]/arr[j-1], i, j-1))\\n\\t\\t\\t\\tk -= 1\\n\\n\\t\\t\\t_,i,j = heappop(hp)\\n\\n\\t\\t\\treturn [arr[i], arr[j]]",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n\\t\\t\\t# using heap Time O(klogn)\\n\\t\\t\\tn = len(arr)\\n\\t\\t\\thp = [(arr[i]/arr[-1], i, n-1) for i in range(n-1)]\\n\\t\\t\\theapify(hp)\\n\\n\\t\\t\\twhile k-1:\\n\\t\\t\\t\\t_,i,j = heappop(hp)\\n\\t\\t\\t\\tif i < j-1:\\n\\t\\t\\t\\t\\theappush(hp, (arr[i]/arr[j-1], i, j-1))\\n\\t\\t\\t\\tk -= 1\\n\\n\\t\\t\\t_,i,j = heappop(hp)\\n\\n\\t\\t\\treturn [arr[i], arr[j]]",
                "codeTag": "Java"
            },
            {
                "id": 1526369,
                "title": "c-binary-search-approach",
                "content": "class Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& nums, int k) {\\n        \\n        double low=0,high=1;\\n        \\n        int n=nums.size();\\n        \\n        while(low<=high){\\n            \\n            double mid=(low+high)/2;\\n            \\n            double maxf=0.0;\\n            \\n            int p,q;\\n            \\n            int total=0;\\n            \\n            int j=1;\\n            \\n            for(int i=0;i<n-1;i++){\\n                \\n                while(j<n && (double)nums[i]/(double)nums[j]>mid){\\n                    j++;\\n                }\\n                \\n                total+=(n-j);\\n                \\n                if(j==n){\\n                    break;\\n                }\\n                \\n                double frac=(double)nums[i]/(double)nums[j];\\n                \\n                if(frac>=maxf){\\n                    \\n                    maxf=frac;\\n                    p=i;\\n                    q=j;\\n                    \\n                }\\n                \\n            }\\n            \\n            if(total==k){\\n                return {nums[p],nums[q]};\\n            }\\n            \\n            else if(total>k){\\n                high=mid;\\n            }\\n            \\n            else{\\n                low=mid;\\n            }\\n            \\n        }\\n        \\n        return {};\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& nums, int k) {\\n        \\n        double low=0,high=1;\\n        \\n        int n=nums.size();\\n        \\n        while(low<=high){\\n            \\n            double mid=(low+high)/2;\\n            \\n            double maxf=0.0;\\n            \\n            int p,q;\\n            \\n            int total=0;\\n            \\n            int j=1;\\n            \\n            for(int i=0;i<n-1;i++){\\n                \\n                while(j<n && (double)nums[i]/(double)nums[j]>mid){\\n                    j++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1383452,
                "title": "lol-poor-test-cases-and-optimized-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& nums, int k) {\\n        priority_queue<pair<double,pair<int,int>>>q;\\n            for(int i=0;i<nums.size()-1;i++)\\n            {\\n                for(int j=i+1;j<nums.size();j++)\\n                {\\n                    q.push({nums[i]*1.0/nums[j],{i,j}});\\n                }\\n            }\\n        while(q.size()>k)\\n        {\\n            q.pop();\\n        }\\n        return {nums[q.top().second.first],nums[q.top().second.second]};\\n    }\\n};\\n\\n```\\nopti code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& A, int K) {\\n        priority_queue<pair<double, pair<int,int>>>pq;\\n        for(int i = 0; i < A.size(); i++)\\n            pq.push({-1.0*A[i]/A.back(), {i,A.size()-1}});\\n        while(--K > 0)\\n        {\\n            pair<int,int> cur = pq.top().second;\\n            pq.pop();\\n            cur.second--;\\n            pq.push({-1.0*A[cur.first]/A[cur.second], {cur.first, cur.second}});\\n        }\\n        return {A[pq.top().second.first], A[pq.top().second.second]};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& nums, int k) {\\n        priority_queue<pair<double,pair<int,int>>>q;\\n            for(int i=0;i<nums.size()-1;i++)\\n            {\\n                for(int j=i+1;j<nums.size();j++)\\n                {\\n                    q.push({nums[i]*1.0/nums[j],{i,j}});\\n                }\\n            }\\n        while(q.size()>k)\\n        {\\n            q.pop();\\n        }\\n        return {nums[q.top().second.first],nums[q.top().second.second]};\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& A, int K) {\\n        priority_queue<pair<double, pair<int,int>>>pq;\\n        for(int i = 0; i < A.size(); i++)\\n            pq.push({-1.0*A[i]/A.back(), {i,A.size()-1}});\\n        while(--K > 0)\\n        {\\n            pair<int,int> cur = pq.top().second;\\n            pq.pop();\\n            cur.second--;\\n            pq.push({-1.0*A[cur.first]/A[cur.second], {cur.first, cur.second}});\\n        }\\n        return {A[pq.top().second.first], A[pq.top().second.second]};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316280,
                "title": "best-explained-c-code-using-minheap-o-k-log-n-o-n",
                "content": "The main idea is to use a priority queue \\u2018pq\\u2019 which stores the value of the fraction and the indices of elements that contribute to that fraction. The priority queue sorts the value based on the fraction values in ascending order. Pop the top K values and add values that are greater than the current value of the fraction. After K, such iteration, the top value will be our answer.\\n \\n1. Maintain a priority queue \\u2018pq\\u2019 that at every node stores a vector \\n* the fraction value that is ARR[i] / ARR[j] where \\u2018i\\u2019 and \\u2018j\\u2019 and indices and \\u2018i\\u2019 < \\u2018j\\u2019.\\n* ARR[i].\\n* ARR[j].\\n\\n2. Initially add N values where all \\u2018i\\u2019 from 0 to \\u2018N - 1\\u2019 is the numerator but have a common denominator the value at \\u2018N - 1\\u2019th index, i.e., ARR[N - 1].\\n\\n3. While \\u2018K\\u2019 is greater than 1:\\n* Pop of the top Node.\\n* The top node \\u2018TOPNODE\\u2019 contains fraction value and index \\u2018i\\u2019, which denotes numerator, and \\u2018j,\\u2019 which denotes denominator.\\n* Reduce \\u2018j\\u2019 by 1.\\n* Push back in the node :\\n-> Fraction value with ARR[i] / ARR[j]\\n-> \\u2018i\\u2019 the element which is the numerator.\\n-> \\u2018j\\u2019 the element which is the denominator.\\n* Reduce \\u2018K\\u2019 by 1.\\n\\n4. The top node now is our result.\\n* Pop the top node :\\nReturn \\u2018{ARR[\\u2018TOPNODE\\u2019[1]], ARR[\\u2018TOPNODE\\u2019[1]]}\\u2019 as the final answer.\\n___\\n* Time Complexity\\nO(K * log(N)), where \\u2018N\\u2019 is the length of the given array and \\u2018K\\u2019 is the number given to us.\\nWe have to query the priority queue \\u2018K\\u2019 times, and the queue contains \\u2018N\\u2019 elements; therefore, the net time complexity will be O(K * log(N)).\\n___\\n* Space Complexity\\nO(N),  where \\u2018N\\u2019 is the length of the given array.\\n\\nSince we are using extra space to keep track of the elements in the priority queue, the net space complexity will be O(N).\\n___\\n* Code - \\n```\\nclass Solution {\\npublic:\\n    \\n    typedef pair<double, pair<int, int>> pii;\\n    \\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        priority_queue< pii, vector<pii>, greater<pii>  > pq;\\n        \\n        for(int i=0; i<n; i++){\\n            pq.push({(double)arr[i]/arr[n-1], {i, n-1}});\\n        }\\n        \\n        while(k > 1){\\n            auto top = pq.top();    pq.pop();\\n            int i = top.second.first;\\n            int j = top.second.second;\\n            pq.push({(double)arr[i]/arr[j-1], {i, j-1}});\\n            k--;\\n        }\\n        \\n        auto top = pq.top();\\n        return {arr[top.second.first], arr[top.second.second]};\\n    }\\n};\\n```\\n\\nPlease upvote to appetiate.\\uD83C\\uDF7B",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    typedef pair<double, pair<int, int>> pii;\\n    \\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        priority_queue< pii, vector<pii>, greater<pii>  > pq;\\n        \\n        for(int i=0; i<n; i++){\\n            pq.push({(double)arr[i]/arr[n-1], {i, n-1}});\\n        }\\n        \\n        while(k > 1){\\n            auto top = pq.top();    pq.pop();\\n            int i = top.second.first;\\n            int j = top.second.second;\\n            pq.push({(double)arr[i]/arr[j-1], {i, j-1}});\\n            k--;\\n        }\\n        \\n        auto top = pq.top();\\n        return {arr[top.second.first], arr[top.second.second]};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1305973,
                "title": "c-786-k-th-smallest-prime-fraction",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        int n = size(arr); \\n        priority_queue<pair<double, pair<int, int>>, vector<pair<double, pair<int, int>>>, greater<>> pq; \\n        for (int i = 0; i < n-1; ++i) \\n            pq.push({(double) arr[i]/arr[n-1], {i, n-1}}); \\n        \\n        int i = 0, j = 0; \\n        while (k--) {\\n            auto elem = pq.top(); pq.pop(); \\n            i = elem.second.first;\\n            j = elem.second.second; \\n            if (i < j-1) pq.push({(double) arr[i]/arr[j-1], {i, j-1}}); \\n        }\\n        return {arr[i], arr[j]}; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        int n = size(arr); \\n        priority_queue<pair<double, pair<int, int>>, vector<pair<double, pair<int, int>>>, greater<>> pq; \\n        for (int i = 0; i < n-1; ++i) \\n            pq.push({(double) arr[i]/arr[n-1], {i, n-1}}); \\n        \\n        int i = 0, j = 0; \\n        while (k--) {\\n            auto elem = pq.top(); pq.pop(); \\n            i = elem.second.first;\\n            j = elem.second.second; \\n            if (i < j-1) pq.push({(double) arr[i]/arr[j-1], {i, j-1}}); \\n        }\\n        return {arr[i], arr[j]}; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171960,
                "title": "javascript-binary-search",
                "content": "The key idea is that you need to set the different value from 0 to 1 because arr[i] / arr[j] must be greater than 0 and lower than 1.\\nthen make medium value to count how many arr[i] / arr[j] is lower than the medium value. if the count is greater than k, change the start value to the medium value, else the end value to the medium value.\\nThere will be two binary searchs. One is for finding the medium value between 0 and 1, and one for counting how many arr[i] / arr[j] are under the medium value.\\n\\n```\\n var kthSmallestPrimeFraction = function(arr, k) {\\n    let [s, e] = [0, 1];\\n    while (s < e) {\\n        let m = (s + e) / 2;\\n        let cnt = 0;\\n        let best = Infinity;\\n        let [ii, jj] = [0, 0];\\n        for (let i = 0; i < arr.length - 1; i++) {\\n            let [ss, ee] = [i + 1, arr.length - 1];\\n            while (ss <= ee) {\\n                let mm = Math.floor((ss + ee) / 2);\\n                let v = arr[i] / arr[mm];\\n                if (v > m) {\\n                    ss = mm + 1;\\n                } else {\\n                    ee = mm - 1;\\n                }   \\n            }\\n            let dif = arr.length - ss;\\n            if (dif > 0) {\\n                cnt += dif;\\n                let val = m - arr[i] / arr[ss];\\n                if (val < best) {\\n                    [ii, jj] = [i, ss];\\n                    best = val;\\n                }\\n            }\\n        }\\n        if (cnt == k) {\\n            return [arr[ii], arr[jj]];\\n        } else if (cnt < k) {\\n            s = m;\\n        } else {\\n            e = m;\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "The key idea is that you need to set the different value from 0 to 1 because arr[i] / arr[j] must be greater than 0 and lower than 1.\\nthen make medium value to count how many arr[i] / arr[j] is lower than the medium value. if the count is greater than k, change the start value to the medium value, else the end value to the medium value.\\nThere will be two binary searchs. One is for finding the medium value between 0 and 1, and one for counting how many arr[i] / arr[j] are under the medium value.\\n\\n```\\n var kthSmallestPrimeFraction = function(arr, k) {\\n    let [s, e] = [0, 1];\\n    while (s < e) {\\n        let m = (s + e) / 2;\\n        let cnt = 0;\\n        let best = Infinity;\\n        let [ii, jj] = [0, 0];\\n        for (let i = 0; i < arr.length - 1; i++) {\\n            let [ss, ee] = [i + 1, arr.length - 1];\\n            while (ss <= ee) {\\n                let mm = Math.floor((ss + ee) / 2);\\n                let v = arr[i] / arr[mm];\\n                if (v > m) {\\n                    ss = mm + 1;\\n                } else {\\n                    ee = mm - 1;\\n                }   \\n            }\\n            let dif = arr.length - ss;\\n            if (dif > 0) {\\n                cnt += dif;\\n                let val = m - arr[i] / arr[ss];\\n                if (val < best) {\\n                    [ii, jj] = [i, ss];\\n                    best = val;\\n                }\\n            }\\n        }\\n        if (cnt == k) {\\n            return [arr[ii], arr[jj]];\\n        } else if (cnt < k) {\\n            s = m;\\n        } else {\\n            e = m;\\n        }\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 920802,
                "title": "cpp14-binary-search-solution",
                "content": "```\\n/*\\n\\nFind the number of fractions which are less than or equal to mid and find how many are greater than mid.\\nSince the array is sorted , we can do this in O(N) time. IF count of such = K , then we find the answer ,\\nelse move low and high according to the count value. Also keep track of maximum fraction value so far.\\nTC = I think N log(Max - Min)\\n\\n*/\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& A, int K) {\\n        int n = A.size();\\n        double low = 0.0 , high = 1.0;\\n        while(high - low >= 0.00000001){\\n            double mid = (low + high) / 2 ;\\n            double maxfractionvalue = 0.0;\\n            int count = 0 , p = 0 , q = 0 ;\\n            int j = 1;\\n            for(int i = 0 ; i < n - 1 ; ++i){\\n                while(j < n and A[i] > mid * A[j]) ++j;\\n                count+= (n - j);\\n                if(j == n) break;\\n                double currentfractionvalue = static_cast<double> (A[i]) / A[j];\\n                if(currentfractionvalue > maxfractionvalue){\\n                    p = i ;\\n                    q = j ;\\n                    maxfractionvalue = currentfractionvalue;\\n                }\\n            }\\n            if(count == K) return {A[p] , A[q]};\\n            else if(count > K){\\n                high = mid ;\\n            }\\n            else {\\n                low = mid;\\n            }\\n        }\\n        return {};\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\nFind the number of fractions which are less than or equal to mid and find how many are greater than mid.\\nSince the array is sorted , we can do this in O(N) time. IF count of such = K , then we find the answer ,\\nelse move low and high according to the count value. Also keep track of maximum fraction value so far.\\nTC = I think N log(Max - Min)\\n\\n*/\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& A, int K) {\\n        int n = A.size();\\n        double low = 0.0 , high = 1.0;\\n        while(high - low >= 0.00000001){\\n            double mid = (low + high) / 2 ;\\n            double maxfractionvalue = 0.0;\\n            int count = 0 , p = 0 , q = 0 ;\\n            int j = 1;\\n            for(int i = 0 ; i < n - 1 ; ++i){\\n                while(j < n and A[i] > mid * A[j]) ++j;\\n                count+= (n - j);\\n                if(j == n) break;\\n                double currentfractionvalue = static_cast<double> (A[i]) / A[j];\\n                if(currentfractionvalue > maxfractionvalue){\\n                    p = i ;\\n                    q = j ;\\n                    maxfractionvalue = currentfractionvalue;\\n                }\\n            }\\n            if(count == K) return {A[p] , A[q]};\\n            else if(count > K){\\n                high = mid ;\\n            }\\n            else {\\n                low = mid;\\n            }\\n        }\\n        return {};\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362958,
                "title": "c-max-heap-of-size-k",
                "content": "class Solution {\\npublic:\\n    \\n    vector<int> kthSmallestPrimeFraction(vector<int>& A, int K) {\\n        \\n        // max heap\\n        priority_queue< pair<double, pair<int,int> > > pq;\\n        \\n        int n = A.size();\\n        int x = 0;\\n        \\n        for (int i=0; i<n; ++i) {\\n            for (int j=i+1; j<n; ++j) {\\n                // we will maintain max heap of size k\\n                if (x < K) {\\n                    pq.push(make_pair((double)(A[i])/A[j], make_pair(A[i],A[j])));\\n                } else {\\n                    // once k elements are in heap\\n                    // only add new element if its fraction is less than top of heap\\n                    // this way, max element will be popped, and smaller value is pushed\\n                    // so all the k values that will remain at the end,\\n                    // will be k smallest fractions\\n                    if ((double)(A[i])/A[j] < pq.top().first) {\\n                        pq.pop();\\n                        pq.push(make_pair((double)(A[i])/A[j], make_pair(A[i],A[j])));\\n                    }\\n                }\\n                \\n                x += 1;\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        \\n        // top of heap is answer\\n        ans.push_back(pq.top().second.first);\\n        ans.push_back(pq.top().second.second);\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    vector<int> kthSmallestPrimeFraction(vector<int>& A, int K) {\\n        \\n        // max heap\\n        priority_queue< pair<double, pair<int,int> > > pq;\\n        \\n        int n = A.size();\\n        int x = 0;\\n        \\n        for (int i=0; i<n; ++i) {\\n            for (int j=i+1; j<n; ++j) {\\n                // we will maintain max heap of size k\\n                if (x < K) {\\n                    pq.push(make_pair((double)(A[i])/A[j], make_pair(A[i],A[j])));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 326490,
                "title": "python-binary-search-bisect-solution",
                "content": "The answer must be between 0, 1. We use binary seach to check the exact upper bound.\\nThen use bisect to check for this upper bound, what is the larget prime ratio.\\nComplexicity (O(nlg n lg n))\\nNotice that the second part can be doen using sliding window, which reduce the total complexicity to (O(n lg n))\\n```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, A: List[int], K: int) -> List[int]:\\n        def count(tar):\\n            res,tmp = 0, [0,A[-1]]\\n            for i in range(len(A)):\\n                loc = bisect.bisect_left(A,A[i]/tar)\\n                res += len(A) - loc\\n                if loc < len(A) and A[i]/A[loc] > tmp[0]/tmp[1]:\\n                    tmp = [A[i],A[loc]]\\n            return res, tmp\\n        l, m, r = 0, 0.5,1\\n        cur,_ = count(m)\\n        while cur != K:\\n            if cur < K:\\n                l = m\\n            else:\\n                r = m\\n            m = (l+r)/2\\n            cur, _ = count(m)\\n        return _\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, A: List[int], K: int) -> List[int]:\\n        def count(tar):\\n            res,tmp = 0, [0,A[-1]]\\n            for i in range(len(A)):\\n                loc = bisect.bisect_left(A,A[i]/tar)\\n                res += len(A) - loc\\n                if loc < len(A) and A[i]/A[loc] > tmp[0]/tmp[1]:\\n                    tmp = [A[i],A[loc]]\\n            return res, tmp\\n        l, m, r = 0, 0.5,1\\n        cur,_ = count(m)\\n        while cur != K:\\n            if cur < K:\\n                l = m\\n            else:\\n                r = m\\n            m = (l+r)/2\\n            cur, _ = count(m)\\n        return _\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296881,
                "title": "python-priority-queue-clean-solution",
                "content": "```\\nfrom heapq import heappop,heappush\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, A: List[int], K: int) -> List[int]:\\n        pq = []\\n        n = len(A)\\n        for i in range(1, n):\\n            heappush(pq, (1/A[i], 0, i))\\n        while K > 0:\\n            _, p, q = heappop(pq)\\n            K -= 1\\n            if K == 0: return[A[p], A[q]]\\n            p += 1\\n            if p < q:\\n                heappush(pq, (A[p]/A[q], p, q))\\n",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heappop,heappush\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, A: List[int], K: int) -> List[int]:\\n        pq = []\\n        n = len(A)\\n        for i in range(1, n):\\n            heappush(pq, (1/A[i], 0, i))\\n        while K > 0:\\n            _, p, q = heappop(pq)\\n            K -= 1\\n            if K == 0: return[A[p], A[q]]\\n            p += 1\\n            if p < q:\\n                heappush(pq, (A[p]/A[q], p, q))\\n",
                "codeTag": "Java"
            },
            {
                "id": 162340,
                "title": "5-line-python-heap-solution",
                "content": "```\\nclass Solution(object):\\n    def kthSmallestPrimeFraction(self, A, k):\\n        stack=[(A[0]*1.0/A[i],0,i) for i in range(len(A)-1,0,-1)]\\n        for i in range(0,k):\\n            frac,nu,de=heapq.heappop(stack)\\n            if nu+1<de: heapq.heappush(stack,(1.0*A[nu+1]/A[de],nu+1,de))              \\n        return [A[nu],A[de]]\\n        \\n        ",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def kthSmallestPrimeFraction(self, A, k):\\n        stack=[(A[0]*1.0/A[i],0,i) for i in range(len(A)-1,0,-1)]\\n        for i in range(0,k):\\n            frac,nu,de=heapq.heappop(stack)\\n            if nu+1<de: heapq.heappush(stack,(1.0*A[nu+1]/A[de],nu+1,de))              \\n        return [A[nu],A[de]]\\n        \\n        ",
                "codeTag": "Java"
            },
            {
                "id": 144976,
                "title": "simple-c-solution",
                "content": "```\\n#define y second.second\\n#define x second.first\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> kthSmallestPrimeFraction(vector<int>& A, int K) {\\n        priority_queue<pair<double,pair<int,int>>,vector<pair<double,pair<int,int>>>,greater<pair<double,pair<int,int>>>> q;\\n        unordered_map<int,int> nxt;\\n        for(int i = A.size()-1;i > 0;i--)\\n            nxt[A[i]] = A[i-1];\\n\\n        double last = A[A.size()-1],d;\\n        nxt[1] = 0;\\n\\n        for(int i = 0;i < A.size();i++){\\n            d = (double)A[i]/last;\\n            q.push(make_pair(d,make_pair(A[i],last)));\\n        }\\n        \\n        while(q.size() && K){\\n            K--;\\n            if(K == 0) break;\\n\\n            pair<double,pair<int,int>> p = q.top();q.pop();\\n            if(nxt[p.y] != 0){\\n                p.y = nxt[p.y];\\n                d = (double)p.x/(double)p.y;\\n                q.push(make_pair(d,p.second));\\n            }\\n        }\\n        \\n        vector<int> ret(2);\\n        ret[0] = q.top().second.first;\\n        ret[1] = q.top().second.second;\\n\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define y second.second\\n#define x second.first\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> kthSmallestPrimeFraction(vector<int>& A, int K) {\\n        priority_queue<pair<double,pair<int,int>>,vector<pair<double,pair<int,int>>>,greater<pair<double,pair<int,int>>>> q;\\n        unordered_map<int,int> nxt;\\n        for(int i = A.size()-1;i > 0;i--)\\n            nxt[A[i]] = A[i-1];\\n\\n        double last = A[A.size()-1],d;\\n        nxt[1] = 0;\\n\\n        for(int i = 0;i < A.size();i++){\\n            d = (double)A[i]/last;\\n            q.push(make_pair(d,make_pair(A[i],last)));\\n        }\\n        \\n        while(q.size() && K){\\n            K--;\\n            if(K == 0) break;\\n\\n            pair<double,pair<int,int>> p = q.top();q.pop();\\n            if(nxt[p.y] != 0){\\n                p.y = nxt[p.y];\\n                d = (double)p.x/(double)p.y;\\n                q.push(make_pair(d,p.second));\\n            }\\n        }\\n        \\n        vector<int> ret(2);\\n        ret[0] = q.top().second.first;\\n        ret[1] = q.top().second.second;\\n\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 139692,
                "title": "shear-my-python3-solution-which-beats-98-73-python3-submissions",
                "content": "    def kthSmallestPrimeFraction(self, A, K):\\n        n = len(A)\\n        def guess(num):\\n            count, right = 0, 0\\n            floor = [0, 1]\\n            for left in range(n):\\n                if right == left:\\n                    right += 1\\n                while right < n and A[left] / A[right] > num:\\n                    right += 1\\n                count += n - right\\n                if right < n and A[left] / A[right] > floor[0] / floor[1]:\\n                    floor = [A[left], A[right]]\\n            return count, floor\\n        left, right = 0, 1\\n        while left + 1e-7 < right:\\n            mid = (left + right) / 2\\n            count, floor = guess(mid)\\n            if count > K:\\n                right = mid\\n            elif count < K:\\n                left = mid\\n            else:\\n                return floor",
                "solutionTags": [],
                "code": "    def kthSmallestPrimeFraction(self, A, K):\\n        n = len(A)\\n        def guess(num):\\n            count, right = 0, 0\\n            floor = [0, 1]\\n            for left in range(n):\\n                if right == left:\\n                    right += 1\\n                while right < n and A[left] / A[right] > num:\\n                    right += 1\\n                count += n - right\\n                if right < n and A[left] / A[right] > floor[0] / floor[1]:\\n                    floor = [A[left], A[right]]\\n            return count, floor\\n        left, right = 0, 1\\n        while left + 1e-7 < right:\\n            mid = (left + right) / 2\\n            count, floor = guess(mid)\\n            if count > K:\\n                right = mid\\n            elif count < K:\\n                left = mid\\n            else:\\n                return floor",
                "codeTag": "Python3"
            },
            {
                "id": 116134,
                "title": "c-clean-o-n-solution-by-binary-search",
                "content": "My solution includes two steps:\n(1) Use binary search to find the approximate value (called 'mid') of the Kth pair fraction of array A. The resolution limit to stop binary search is set as 1e-8.\n(2) Got back to find the pair in array A with the value nearest to 'mid'.\nThe time complex is O(n). The run time is 19 ms. I also tried a solution based on priority queue with run time 1556 ms. Hence, binary search is much faster. \n```\nclass Solution {\npublic:\n    vector<int> kthSmallestPrimeFraction(vector<int>& A, int K) {\n        double low = 0, high = 1, mid;\n        set<int> set1(A.begin(), A.end());\n\t\t\t\t//step 1: find the approximate value of p/q\n        while (high - low >= 0.00000001) {\n            mid = (high + low) / 2.0;\n            int cnt = CountNum(A, mid);  //count the # of pair (p, q) with value p/q < mid. The time complexity of CountNum is O(n)\n            if (cnt >= K)\n                high = mid;\n            else\n                low = mid;\n        }\n\t\t\t\t\n        //step 2: find a (p, q) pair in array A with the value of p/q nearest to 'mid'\n\t\t\t\tdouble dis = INT_MAX;\n        vector<int> res;\n        for (int i = A.size() - 1; i >= 0; i--) {\n            int d = A[i] * mid + 0.5; //find the nearst integer d with d / A[i] == mid\n            if (set1.find(d) != set1.end()) {\n                double cur_dis = fabs((double) d / (double) A[i] - mid);\n                if (dis > cur_dis) {\n                    res = {d, A[i]};\n                    dis = cur_dis;\n                }\n            }\n        }\n        return res;\n    }\n\t\t\n    int CountNum(vector<int>& A, double val) {\n        int cnt = 0, end = A.size();\n        for (int i = A.size() - 2; i >= 0; i--) {\n            cnt += A.size() - end;\n            if (i < end) {\n                while (A[i] <= val * A[--end]) cnt++;\n                end++;\n            }\n        }\n        return cnt;\n    }\n};\n```\n",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n    vector<int> kthSmallestPrimeFraction(vector<int>& A, int K) {\n        double low = 0, high = 1, mid;\n        set<int> set1(A.begin(), A.end());\n\t\t\t\t//step 1: find the approximate value of p/q\n        while (high - low >= 0.00000001) {\n            mid = (high + low) / 2.0;\n            int cnt = CountNum(A, mid);  //count the # of pair (p, q) with value p/q < mid. The time complexity of CountNum is O(n)\n            if (cnt >= K)\n                high = mid;\n            else\n                low = mid;\n        }\n\t\t\t\t\n        //step 2: find a (p, q) pair in array A with the value of p/q nearest to 'mid'\n\t\t\t\tdouble dis = INT_MAX;\n        vector<int> res;\n        for (int i = A.size() - 1; i >= 0; i--) {\n            int d = A[i] * mid + 0.5; //find the nearst integer d with d / A[i] == mid\n            if (set1.find(d) != set1.end()) {\n                double cur_dis = fabs((double) d / (double) A[i] - mid);\n                if (dis > cur_dis) {\n                    res = {d, A[i]};\n                    dis = cur_dis;\n                }\n            }\n        }\n        return res;\n    }\n\t\t\n    int CountNum(vector<int>& A, double val) {\n        int cnt = 0, end = A.size();\n        for (int i = A.size() - 2; i >= 0; i--) {\n            cnt += A.size() - end;\n            if (i < end) {\n                while (A[i] <= val * A[--end]) cnt++;\n                end++;\n            }\n        }\n        return cnt;\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918242,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        vector<int>ans;\\n        priority_queue<pair<float,pair<float,float>>, vector<pair<float,pair<float,float>>> , greater<pair<float,pair<float,float>>>>p;\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                float frac=(float)arr[i]/(float)arr[j];\\n               \\n               p.push({frac,{arr[i],arr[j]}});\\n            }\\n           \\n        }\\n       \\n          k-=1;\\n            while(k--){\\n              p.pop();\\n            }\\n            ans.push_back(p.top().second.first);\\n            ans.push_back(p.top().second.second);\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        vector<int>ans;\\n        priority_queue<pair<float,pair<float,float>>, vector<pair<float,pair<float,float>>> , greater<pair<float,pair<float,float>>>>p;\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                float frac=(float)arr[i]/(float)arr[j];\\n               \\n               p.push({frac,{arr[i],arr[j]}});\\n            }\\n           \\n        }\\n       \\n          k-=1;\\n            while(k--){\\n              p.pop();\\n            }\\n            ans.push_back(p.top().second.first);\\n            ans.push_back(p.top().second.second);\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542364,
                "title": "python3-easy-solution-beats-78-8",
                "content": "# Code\\n```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        consider = []\\n        n = len(arr)\\n\\n        for i in range(n):\\n            for j in range(max(n-k,i+1),n):\\n                consider.append((arr[i],arr[j]))\\n\\n        consider.sort(key=lambda x: x[0]/x[1])\\n        return consider[k-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        consider = []\\n        n = len(arr)\\n\\n        for i in range(n):\\n            for j in range(max(n-k,i+1),n):\\n                consider.append((arr[i],arr[j]))\\n\\n        consider.sort(key=lambda x: x[0]/x[1])\\n        return consider[k-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540344,
                "title": "using-set-and-pair-intuitive-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo find the kth smallest fraction, we can generate all possible fractions using the given array arr. We can iterate over each pair of elements in arr and calculate their fraction. We\\'ll store these fractions in a sorted manner and return the kth smallest fraction.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a set called fractions to store the fractions in a sorted order. Each element in the set is a pair consisting of the fraction as the key and another pair of the numerator and denominator as the value.\\n2. Iterate over the elements in arr using two nested loops. The outer loop iterates over the numerators, and the inner loop iterates over the denominators starting from the next index to avoid duplicates.\\n3. Calculate the fraction by dividing the numerator by the denominator, casted to double. Insert the fraction along with the numerator and denominator pair into the fractions set.\\n4. Locate the kth smallest fraction by advancing the iterator it to the k-1 position in the set.\\n5. Return the numerator and denominator of the kth smallest fraction as a pair.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(n^2 log k), where n is the size of the input array arr. We have nested loops iterating over the elements of arr, resulting in n^2 iterations. The insertion into the set takes logarithmic time, and finding the kth smallest fraction takes O(log k) time. Since we are inserting into the set k times, the overall time complexity is O(n^2 log k).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k), as we are storing the fractions in a set, which can have a maximum of k elements.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        set<pair<double, pair<int, int>>> fractions;\\n        \\n        for (int i = 0; i < arr.size(); i++) {\\n            for (int j = i + 1; j < arr.size(); j++) {\\n                double fraction = static_cast<double>(arr[i]) / arr[j];\\n                fractions.insert({fraction, {arr[i], arr[j]}});\\n            }\\n        }\\n        \\n        auto it = fractions.begin();\\n        advance(it, k - 1);\\n        \\n        return {it->second.first, it->second.second};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        set<pair<double, pair<int, int>>> fractions;\\n        \\n        for (int i = 0; i < arr.size(); i++) {\\n            for (int j = i + 1; j < arr.size(); j++) {\\n                double fraction = static_cast<double>(arr[i]) / arr[j];\\n                fractions.insert({fraction, {arr[i], arr[j]}});\\n            }\\n        }\\n        \\n        auto it = fractions.begin();\\n        advance(it, k - 1);\\n        \\n        return {it->second.first, it->second.second};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295467,
                "title": "brute-force-must-see-easy-to-understand",
                "content": "# Code\\n```\\n\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) \\n    {\\n         //we will use max heap of size k\\n          priority_queue<pair<double,vector<int>>>pq;\\n\\n         for(int j=0;j<arr.size();j++)\\n         {\\n             for(int i=j-1;i>=0;i--)\\n             {   \\n                 double fraction = ((1.00*arr[i])/(arr[j]));\\n\\n                 if(pq.size() < k)\\n                 {\\n                     pq.push({fraction,{arr[i],arr[j]}});\\n                 }\\n                 else\\n                 {\\n                     if(pq.top().first > fraction)\\n                     {\\n                         pq.pop();\\n                         pq.push({fraction,{arr[i],arr[j]}});\\n                     }\\n                 }\\n             }\\n         }   \\n        return pq.top().second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) \\n    {\\n         //we will use max heap of size k\\n          priority_queue<pair<double,vector<int>>>pq;\\n\\n         for(int j=0;j<arr.size();j++)\\n         {\\n             for(int i=j-1;i>=0;i--)\\n             {   \\n                 double fraction = ((1.00*arr[i])/(arr[j]));\\n\\n                 if(pq.size() < k)\\n                 {\\n                     pq.push({fraction,{arr[i],arr[j]}});\\n                 }\\n                 else\\n                 {\\n                     if(pq.top().first > fraction)\\n                     {\\n                         pq.pop();\\n                         pq.push({fraction,{arr[i],arr[j]}});\\n                     }\\n                 }\\n             }\\n         }   \\n        return pq.top().second;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3293921,
                "title": "python-naive-greedy-sol",
                "content": "# Intuition\\nstore the fractions as dictionary\\n\\n# Approach\\nsort based on values\\n\\n# Complexity\\n- Time complexity:\\no(n2)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        d={}\\n\\n        for i in range(0, len(arr)):\\n            for j in range(i+1, len(arr)):\\n                d[(arr[i],arr[j])]= arr[i]/arr[j]\\n        # print(d)\\n\\n        ds= sorted(d.items(), key= lambda x: x[1])\\n        print(ds[k-1])\\n\\n        return ([ds[k-1][0][0],ds[k-1][0][1]])\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        d={}\\n\\n        for i in range(0, len(arr)):\\n            for j in range(i+1, len(arr)):\\n                d[(arr[i],arr[j])]= arr[i]/arr[j]\\n        # print(d)\\n\\n        ds= sorted(d.items(), key= lambda x: x[1])\\n        print(ds[k-1])\\n\\n        return ([ds[k-1][0][0],ds[k-1][0][1]])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272385,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom fractions import Fraction\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        sol_arr = []\\n        for i in range(len(arr)-1):\\n            for j in range(i+1,len(arr)):\\n                sol_arr.append(arr[i]/arr[j])\\n        sol_arr = sorted(sol_arr)\\n        smallest = sol_arr[k-1]\\n        sol = str(Fraction(str(smallest)).limit_denominator())\\n        numerator, denominator = sol.split(\"/\")\\n        return [int(numerator), int(denominator)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom fractions import Fraction\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        sol_arr = []\\n        for i in range(len(arr)-1):\\n            for j in range(i+1,len(arr)):\\n                sol_arr.append(arr[i]/arr[j])\\n        sol_arr = sorted(sol_arr)\\n        smallest = sol_arr[k-1]\\n        sol = str(Fraction(str(smallest)).limit_denominator())\\n        numerator, denominator = sol.split(\"/\")\\n        return [int(numerator), int(denominator)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026475,
                "title": "java-max-heap-priority-queue",
                "content": "# Please Upvote :D\\n``` java []\\nclass Solution {\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(\\n            (a, b) -> {\\n                double x = a[0] / (1.0 * a[1]);\\n                double y = b[0] / (1.0 * b[1]);\\n                return x > y? -1 : 1;\\n            }\\n        );\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            for (int j = i + 1; j < arr.length; j++) {\\n                pq.offer(new int[] {arr[i], arr[j]});\\n                if (pq.size() > k) {\\n                    pq.poll();\\n                }\\n            }\\n        }\\n\\n        return pq.poll();\\n    }\\n}\\n\\n// TC: O(n^2 * logk), SC: O(k)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(\\n            (a, b) -> {\\n                double x = a[0] / (1.0 * a[1]);\\n                double y = b[0] / (1.0 * b[1]);\\n                return x > y? -1 : 1;\\n            }\\n        );\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            for (int j = i + 1; j < arr.length; j++) {\\n                pq.offer(new int[] {arr[i], arr[j]});\\n                if (pq.size() > k) {\\n                    pq.poll();\\n                }\\n            }\\n        }\\n\\n        return pq.poll();\\n    }\\n}\\n\\n// TC: O(n^2 * logk), SC: O(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908833,
                "title": "java-priorityqueue-maxheap",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        PriorityQueue<Pair> maxHeap= new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for(int i=0; i< arr.length - 1; i++){\\n            for(int j=i+1; j< arr.length; j++){\\n                double frac = (double)arr[i]/arr[j];\\n                \\n                maxHeap.add(new Pair(frac, arr[i], arr[j]));\\n\\n                if(maxHeap.size()>k){\\n                    maxHeap.remove(maxHeap.peek());\\n                }\\n                \\n            }\\n        }\\n        return new int[]{maxHeap.peek().val1,maxHeap.peek().val2};\\n    }\\n\\n    public class Pair implements Comparable<Pair>{\\n        double frac ; \\n        int val1 ;\\n        int val2 ;\\n        \\n        Pair(double frac , int val1 , int val2){\\n            this.frac = frac;\\n            this.val1 = val1; \\n            this.val2 = val2;\\n        }\\n\\n        public int compareTo(Pair o){\\n            if(this.frac > o.frac){\\n                return 1;\\n            }\\n            return -1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        PriorityQueue<Pair> maxHeap= new PriorityQueue<>(Collections.reverseOrder());\\n\\n        for(int i=0; i< arr.length - 1; i++){\\n            for(int j=i+1; j< arr.length; j++){\\n                double frac = (double)arr[i]/arr[j];\\n                \\n                maxHeap.add(new Pair(frac, arr[i], arr[j]));\\n\\n                if(maxHeap.size()>k){\\n                    maxHeap.remove(maxHeap.peek());\\n                }\\n                \\n            }\\n        }\\n        return new int[]{maxHeap.peek().val1,maxHeap.peek().val2};\\n    }\\n\\n    public class Pair implements Comparable<Pair>{\\n        double frac ; \\n        int val1 ;\\n        int val2 ;\\n        \\n        Pair(double frac , int val1 , int val2){\\n            this.frac = frac;\\n            this.val1 = val1; \\n            this.val2 = val2;\\n        }\\n\\n        public int compareTo(Pair o){\\n            if(this.frac > o.frac){\\n                return 1;\\n            }\\n            return -1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738454,
                "title": "python-o-k-log-k-min-heap-solution",
                "content": "```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        minHeap, sz = [], len(arr)\\n        for i in range(sz):\\n            heappush(minHeap, [(arr[i] / arr[-1]), i, sz - 1])\\n            if i == k - 1: break\\n        while minHeap:\\n            k -= 1\\n            if k == 0: break\\n            minElem = heappop(minHeap)\\n            minElem[2] -= 1\\n            if minElem[2] > minElem[1]:\\n                heappush(minHeap, [(arr[minElem[1]] / arr[minElem[2]]), minElem[1], minElem[2]])\\n        return [arr[minHeap[0][1]], arr[minHeap[0][2]]]\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        minHeap, sz = [], len(arr)\\n        for i in range(sz):\\n            heappush(minHeap, [(arr[i] / arr[-1]), i, sz - 1])\\n            if i == k - 1: break\\n        while minHeap:\\n            k -= 1\\n            if k == 0: break\\n            minElem = heappop(minHeap)\\n            minElem[2] -= 1\\n            if minElem[2] > minElem[1]:\\n                heappush(minHeap, [(arr[minElem[1]] / arr[minElem[2]]), minElem[1], minElem[2]])\\n        return [arr[minHeap[0][1]], arr[minHeap[0][2]]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717759,
                "title": "python-two-solutions-heap-and-binary-search",
                "content": "# **1. USING A HEAP**\\nThe simplest solution we can think of is a Heap Solution in which we keep track of k smallest fractions by maintaing a max heap of k size. WE use a max Heap because we want to discard all the bigger fractions from top and only keep the smaller ones. In the end, the top of heap will have the kth smallest fraction.\\n\\n\\n```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        # Kth Smallest means we need a maxHeap such that we discard all the bigger fractions from top\\n        # We will maintain the size of heap as K\\n        \\n        heap = []\\n        \\n        # For each element in the array\\n        for i in range(len(arr)):\\n            # Go through each element after it\\n            for j in range(i+1, len(arr)):\\n                # Calculate the fraction\\n                fraction = arr[i]/arr[j]\\n                \\n                # Push the fraction into the heap, along with the ith and jth values\\n                heappush(heap, (-fraction, arr[i], arr[j]))\\n                \\n                # If the heap size becomes more than k, pop the topmost element\\n                if len(heap) > k: heappop(heap)\\n                \\n        # At the end, the top of heap will have the kth smallest fraction\\n        return [heap[0][1], heap[0][2]]\\n```\\n\\n# **2. BINARY SEARCH ON ANSWER**\\n\\nWe are asked for the kth smallest fraction. What can be the range in which the kth smallest fraction will be?\\n\\nIn other words, what is the range in which any possible fraction in the given input array will be? \\n\\nIt will be the range 0 to 1. Why?\\n\\nbecause it is given that we have to consider only those fractions where i < j and since this is a sorted array , it means the numerator will always be smaller than denominator, meaning the fraction will never be more than 1 for any two pairs. In fact, it cannot even be exactly 0 or 1 but we can take 0 as lower and 1 as upper bound for our Binary search.\\n\\nSo, when we find a mid value, we need to see how many fractions are there that are less than (or equal to) that mid value. And if there are exactly k values, then that means, we can take the largest fraction out of those and that will be the kth smallest fraction.\\n\\n```\\nclass Solution:\\n    \\n    # Helper method to find how many fractions are smaller than a particular fraction\\n    def countSmallerFractions(self, target, arr):\\n        count = 0\\n        p,q = 0,0\\n        maxFraction = 0\\n        \\n        for i in range(len(arr) - 1): \\n            for j in range(i+1, len(arr)):\\n                # If for this jth element, fraction is <= target\\n                # That means, for any element after jth index also, this will be valid\\n                # hence we can simply increment count here\\n                if arr[i] / arr[j] <= target: \\n                    count += len(arr) - j\\n                    \\n                    # If at the end, count is k, we need to return the pair\\n                    # So here, we will also keep updating the pair values p and q\\n                    if (arr[i] / arr[j]) > maxFraction: \\n                        maxFraction = arr[i] / arr[j]\\n                        p = arr[i]\\n                        q  = arr[j]\\n                        \\n                    break\\n                \\n                \\n        return (count, [p,q])\\n    \\n    \\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        \\n        # Binary Search on Answer\\n        # We are asked for the Kth Smallest Prime Fraction\\n        \\n        # What can be the range of Fractions for this problem?\\n        # Since array is sorted in increasing order\\n        # and we consider a fraction where numerator < denominator\\n        \\n        # All valid fractions in the array will be between 0 and 1 only\\n        start = 0\\n        end = 1\\n\\n        # Apply Binary Search\\n        # We want a fraction that is the kth smallest\\n        # In other words - There are k fractions less than or equal to it (including itself)\\n        while start < end:\\n            \\n            # We want the fraction, not an integer value\\n            # Hence we did not use \"//\" here\\n            mid  = start  + (end - start) / 2\\n                        \\n            # How many fractions are <= \"mid\" fraction\\n            (count, result) = self.countSmallerFractions(mid, arr)\\n                            \\n            if count == k: return result\\n            \\n            if count < k: start = mid\\n            else: end = mid\\n        \\n        \\n        return []\\n```\\n        \\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        # Kth Smallest means we need a maxHeap such that we discard all the bigger fractions from top\\n        # We will maintain the size of heap as K\\n        \\n        heap = []\\n        \\n        # For each element in the array\\n        for i in range(len(arr)):\\n            # Go through each element after it\\n            for j in range(i+1, len(arr)):\\n                # Calculate the fraction\\n                fraction = arr[i]/arr[j]\\n                \\n                # Push the fraction into the heap, along with the ith and jth values\\n                heappush(heap, (-fraction, arr[i], arr[j]))\\n                \\n                # If the heap size becomes more than k, pop the topmost element\\n                if len(heap) > k: heappop(heap)\\n                \\n        # At the end, the top of heap will have the kth smallest fraction\\n        return [heap[0][1], heap[0][2]]\\n```\n```\\nclass Solution:\\n    \\n    # Helper method to find how many fractions are smaller than a particular fraction\\n    def countSmallerFractions(self, target, arr):\\n        count = 0\\n        p,q = 0,0\\n        maxFraction = 0\\n        \\n        for i in range(len(arr) - 1): \\n            for j in range(i+1, len(arr)):\\n                # If for this jth element, fraction is <= target\\n                # That means, for any element after jth index also, this will be valid\\n                # hence we can simply increment count here\\n                if arr[i] / arr[j] <= target: \\n                    count += len(arr) - j\\n                    \\n                    # If at the end, count is k, we need to return the pair\\n                    # So here, we will also keep updating the pair values p and q\\n                    if (arr[i] / arr[j]) > maxFraction: \\n                        maxFraction = arr[i] / arr[j]\\n                        p = arr[i]\\n                        q  = arr[j]\\n                        \\n                    break\\n                \\n                \\n        return (count, [p,q])\\n    \\n    \\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        \\n        # Binary Search on Answer\\n        # We are asked for the Kth Smallest Prime Fraction\\n        \\n        # What can be the range of Fractions for this problem?\\n        # Since array is sorted in increasing order\\n        # and we consider a fraction where numerator < denominator\\n        \\n        # All valid fractions in the array will be between 0 and 1 only\\n        start = 0\\n        end = 1\\n\\n        # Apply Binary Search\\n        # We want a fraction that is the kth smallest\\n        # In other words - There are k fractions less than or equal to it (including itself)\\n        while start < end:\\n            \\n            # We want the fraction, not an integer value\\n            # Hence we did not use \"//\" here\\n            mid  = start  + (end - start) / 2\\n                        \\n            # How many fractions are <= \"mid\" fraction\\n            (count, result) = self.countSmallerFractions(mid, arr)\\n                            \\n            if count == k: return result\\n            \\n            if count < k: start = mid\\n            else: end = mid\\n        \\n        \\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469369,
                "title": "c-priority-queue-short-and-easy-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        priority_queue<pair<double, pair<int, int>>> pq;\\n        for(int i = 0 ; i < n - 1; i++)\\n        {\\n            for(int j = i + 1 ; j < n; j++)\\n            {\\n                pq.push({(double)arr[i]/arr[j],{arr[i], arr[j]}});\\n                if(pq.size() > k)\\n                    pq.pop();\\n            }   \\n        }\\n        return {pq.top().second.first,pq.top().second.second};  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        priority_queue<pair<double, pair<int, int>>> pq;\\n        for(int i = 0 ; i < n - 1; i++)\\n        {\\n            for(int j = i + 1 ; j < n; j++)\\n            {\\n                pq.push({(double)arr[i]/arr[j],{arr[i], arr[j]}});\\n                if(pq.size() > k)\\n                    pq.pop();\\n            }   \\n        }\\n        return {pq.top().second.first,pq.top().second.second};  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468244,
                "title": "k-th-smallest-prime-fraction-solution-java",
                "content": "class Solution {\\n  public int[] kthSmallestPrimeFraction(int[] A, int K) {\\n    final int n = A.length;\\n    double l = 0.0;\\n    double r = 1.0;\\n\\n    while (l < r) {\\n      final double m = (l + r) / 2.0;\\n      int fractionsNoGreaterThanM = 0;\\n      int p = 0;\\n      int q = 1;\\n\\n      // for each index i, find the first index j s.t. A[i] / A[j] <= m,\\n      // so fractionsNoGreaterThanM for index i will be n - j\\n      for (int i = 0, j = 1; i < n; ++i) {\\n        while (j < n && A[i] > m * A[j])\\n          ++j;\\n        if (j == n)\\n          break;\\n        fractionsNoGreaterThanM += n - j;\\n        if (p * A[j] < q * A[i]) {\\n          p = A[i];\\n          q = A[j];\\n        }\\n      }\\n\\n      if (fractionsNoGreaterThanM == K)\\n        return new int[] {p, q};\\n      if (fractionsNoGreaterThanM > K)\\n        r = m;\\n      else\\n        l = m;\\n    }\\n\\n    throw new IllegalArgumentException();\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Binary Search",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n  public int[] kthSmallestPrimeFraction(int[] A, int K) {\\n    final int n = A.length;\\n    double l = 0.0;\\n    double r = 1.0;\\n\\n    while (l < r) {\\n      final double m = (l + r) / 2.0;\\n      int fractionsNoGreaterThanM = 0;\\n      int p = 0;\\n      int q = 1;\\n\\n      // for each index i, find the first index j s.t. A[i] / A[j] <= m,\\n      // so fractionsNoGreaterThanM for index i will be n - j\\n      for (int i = 0, j = 1; i < n; ++i) {\\n        while (j < n && A[i] > m * A[j])\\n          ++j;\\n        if (j == n)\\n          break;\\n        fractionsNoGreaterThanM += n - j;\\n        if (p * A[j] < q * A[i]) {\\n          p = A[i];\\n          q = A[j];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2432606,
                "title": "easy-solution-of-k-th-smallest-prime-fraction-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        \\n        vector<float> fraction;\\n        vector<int> ans;\\n        \\n        for(int i = 0; i < arr.size()-1; i++)\\n        {\\n            for(int j = i+1; j < arr.size(); j++)\\n            {\\n                fraction.push_back((float)arr[i]/arr[j]);\\n            }\\n        }\\n        \\n        sort(fraction.begin(), fraction.end());\\n        \\n        float d = fraction[k-1];\\n        \\n        for(int i = 0; i < arr.size()-1; i++)\\n        {\\n            for(int j = i+1; j < arr.size(); j++)\\n            {\\n                if(d == (float)arr[i]/arr[j])\\n                {\\n                    ans.push_back(arr[i]);\\n                    ans.push_back(arr[j]);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        \\n        vector<float> fraction;\\n        vector<int> ans;\\n        \\n        for(int i = 0; i < arr.size()-1; i++)\\n        {\\n            for(int j = i+1; j < arr.size(); j++)\\n            {\\n                fraction.push_back((float)arr[i]/arr[j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2296283,
                "title": "c-solution-using-priority-queue-max-heap",
                "content": "\\nclass Solution {\\npublic:\\n\\n\\tvector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n\\t\\n\\t// creating priority queue for storing fraction value\\n\\t// main idea - based on value of k which ranges between 0 to n*(n-1)/2\\n\\t// So the ANS will be that in which num>dem that is why j  is running with i+1\\n        priority_queue<pair<double,pair<int,int>>> pq;\\n        for(int i = 0;i<arr.size();i++){\\n            for(int j = i+1;j<arr.size();j++){\\n                double temp = (double)arr[i]/arr[j];\\n                pq.push(make_pair(temp,make_pair(arr[i],arr[j])));\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// here we are removing so that ...at last top contain the ans\\n                    if(pq.size()>k)\\n                        pq.pop();\\n\\t\\t\\t\\t\\n            }\\n        }\\n\\t\\t\\n\\t\\t//top of the priority queue will contain the ans\\n\\t\\t\\n        vector<int> ans;\\n        ans.push_back(pq.top().second.first);\\n        ans.push_back(pq.top().second.second);\\n        return ans;\\n    }\\n};\\n**please upvote if it helps!**",
                "solutionTags": [
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n\\n\\tvector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n\\t\\n\\t// creating priority queue for storing fraction value\\n\\t// main idea - based on value of k which ranges between 0 to n*(n-1)/2\\n\\t// So the ANS will be that in which num>dem that is why j  is running with i+1\\n        priority_queue<pair<double,pair<int,int>>> pq;\\n        for(int i = 0;i<arr.size();i++){\\n            for(int j = i+1;j<arr.size();j++){\\n                double temp = (double)arr[i]/arr[j];\\n                pq.push(make_pair(temp,make_pair(arr[i],arr[j])));\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// here we are removing so that ...at last top contain the ans\\n                    if(pq.size()>k)\\n                        pq.pop();\\n\\t\\t\\t\\t\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2282230,
                "title": "binary-search-nearly-linear-o-n-log-1-eps-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        double lo = 0.0, hi = 1.0, eps = 1e-9;\\n        int p, q;\\n        int n = arr.size();\\n        while (lo + eps < hi) {\\n            double m = lo + (hi - lo) / 2.0;\\n            int cnt = 0;\\n            int l = 0, r = 0;\\n            for (l = 0; l < n; l++) {\\n                while (r < n && (double)arr[l] > m * arr[r])\\n                    r++;\\n                cnt += n - r;\\n            }\\n            if (cnt >= k) hi = m;\\n            else lo = m;\\n        }\\n        int l = 0, r = 0;\\n        double best_dif = 1.0;\\n        for (l = 0; l < n; l++) {\\n            while (r < n && (double)arr[l] > hi * arr[r])\\n                r++;\\n            if (r == n) r = n-1;\\n            if (abs((double)arr[l] / arr[r] - hi) < best_dif) {\\n                best_dif = abs((double)arr[l] / arr[r] - hi);\\n                p = arr[l], q = arr[r];\\n            }\\n        }\\n        return {p, q};\\n    }\\n};\\n```\\nThe key idea is to convert the prime numbers into floats, and binary search for the value of p/q based on the number of fractions smaller than it. You can count the number of fractions smaller than the value you\\'re searching for using two pointers.\\nChoosing eps = 1e-9 gives a running time of about 30 * n, which is nearly linear.",
                "solutionTags": [
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        double lo = 0.0, hi = 1.0, eps = 1e-9;\\n        int p, q;\\n        int n = arr.size();\\n        while (lo + eps < hi) {\\n            double m = lo + (hi - lo) / 2.0;\\n            int cnt = 0;\\n            int l = 0, r = 0;\\n            for (l = 0; l < n; l++) {\\n                while (r < n && (double)arr[l] > m * arr[r])\\n                    r++;\\n                cnt += n - r;\\n            }\\n            if (cnt >= k) hi = m;\\n            else lo = m;\\n        }\\n        int l = 0, r = 0;\\n        double best_dif = 1.0;\\n        for (l = 0; l < n; l++) {\\n            while (r < n && (double)arr[l] > hi * arr[r])\\n                r++;\\n            if (r == n) r = n-1;\\n            if (abs((double)arr[l] / arr[r] - hi) < best_dif) {\\n                best_dif = abs((double)arr[l] / arr[r] - hi);\\n                p = arr[l], q = arr[r];\\n            }\\n        }\\n        return {p, q};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2277270,
                "title": "easy-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<pair<double, pair<int, int>>> pq;\\n        for (int i = 0; i < arr.size() - 1; i++){\\n            for (int j = i + 1; j < arr.size(); j++){\\n                double frac = (double) arr[i] / (double) arr[j];\\n                if(pq.size() < k) {\\n                    pq.push({frac, {arr[i], arr[j]}});\\n                }\\n                else {\\n                    if(pq.top().first > frac) {\\n                        pq.pop();\\n                        pq.push({frac, {arr[i], arr[j]}});\\n                    }\\n                    else {\\n                        continue;\\n                    }\\n                }\\n            }   \\n        }\\n        return {pq.top().second.first, pq.top().second.second};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<pair<double, pair<int, int>>> pq;\\n        for (int i = 0; i < arr.size() - 1; i++){\\n            for (int j = i + 1; j < arr.size(); j++){\\n                double frac = (double) arr[i] / (double) arr[j];\\n                if(pq.size() < k) {\\n                    pq.push({frac, {arr[i], arr[j]}});\\n                }\\n                else {\\n                    if(pq.top().first > frac) {\\n                        pq.pop();\\n                        pq.push({frac, {arr[i], arr[j]}});\\n                    }\\n                    else {\\n                        continue;\\n                    }\\n                }\\n            }   \\n        }\\n        return {pq.top().second.first, pq.top().second.second};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2217495,
                "title": "o-log-n-runtime",
                "content": "```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, A, K):\\n        l, r, N = 0, 1, len(A)\\n        while True:\\n            m = (l + r) / 2\\n            border = [bisect.bisect(A, A[i] / m) for i in range(N)]\\n            cur = sum(N - i for i in border)\\n            if cur > K:\\n                r = m\\n            elif cur < K:\\n                l = m\\n            else:\\n                return max([(A[i], A[j]) for i, j in enumerate(border) if j < N], key=lambda x: x[0] / x[1])\\n        \\n```",
                "solutionTags": [
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, A, K):\\n        l, r, N = 0, 1, len(A)\\n        while True:\\n            m = (l + r) / 2\\n            border = [bisect.bisect(A, A[i] / m) for i in range(N)]\\n            cur = sum(N - i for i in border)\\n            if cur > K:\\n                r = m\\n            elif cur < K:\\n                l = m\\n            else:\\n                return max([(A[i], A[j]) for i, j in enumerate(border) if j < N], key=lambda x: x[0] / x[1])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1925921,
                "title": "c-priority-queue-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) \\n    {\\n        priority_queue<pair<double,pair<int,int>>> pq;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            for(int j=i+1;j<arr.size();j++)\\n            {\\n                double temp=(double)arr[i]/arr[j];\\n                pq.push({temp,{arr[i],arr[j]}});\\n                if(pq.size()>k)\\n                    pq.pop();\\n            }\\n        }\\n        \\n        return {pq.top().second.first,pq.top().second.second};\\n        \\n    }\\n};\\n//  if you like the solution plz upvote..",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) \\n    {\\n        priority_queue<pair<double,pair<int,int>>> pq;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            for(int j=i+1;j<arr.size();j++)\\n            {\\n                double temp=(double)arr[i]/arr[j];\\n                pq.push({temp,{arr[i],arr[j]}",
                "codeTag": "Java"
            },
            {
                "id": 1746622,
                "title": "python",
                "content": "```\\ndef kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        heap = []\\n        heapify(heap)\\n        i,j = 0,1\\n        while i<len(arr)-1:\\n            heappush(heap,[-(arr[i]/arr[j]),[i,j]])\\n            if len(heap)>k:\\n                heappop(heap)\\n            if j+1==len(arr):\\n                i+=1\\n                j=i+1\\n                continue\\n            j+=1\\n        r = heappop(heap)[1]\\n        return [arr[r[0]],arr[r[1]]]\\n```\\n```\\ndef kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        heap = []\\n        heapify(heap)\\n        for i in range(len(arr)):\\n            for j in range(i+1,len(arr)):\\n                heappush(heap,[-(arr[i]/arr[j]),[i,j]])\\n                if len(heap)>k:\\n                    heappop(heap)  \\n        r = heappop(heap)[1]\\n        return [arr[r[0]],arr[r[1]]]\\n                \\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        heap = []\\n        heapify(heap)\\n        i,j = 0,1\\n        while i<len(arr)-1:\\n            heappush(heap,[-(arr[i]/arr[j]),[i,j]])\\n            if len(heap)>k:\\n                heappop(heap)\\n            if j+1==len(arr):\\n                i+=1\\n                j=i+1\\n                continue\\n            j+=1\\n        r = heappop(heap)[1]\\n        return [arr[r[0]],arr[r[1]]]\\n```\n```\\ndef kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        heap = []\\n        heapify(heap)\\n        for i in range(len(arr)):\\n            for j in range(i+1,len(arr)):\\n                heappush(heap,[-(arr[i]/arr[j]),[i,j]])\\n                if len(heap)>k:\\n                    heappop(heap)  \\n        r = heappop(heap)[1]\\n        return [arr[r[0]],arr[r[1]]]\\n                \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1734389,
                "title": "java-clear-and-concise-using-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n\\t\\t// max-heap\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {\\n            double x = (double)b[0] / b[1];\\n            double y = (double)a[0] / a[1];\\n            if (x > y)\\n\\t\\t\\t\\treturn 1;  // lambda exp. returns b(param of lambda exp), if the value is positive. Hence returned b.\\n            return -1;  // lambda exp. returns a(param of lambda exp), if the value is negative. Hence returned a.\\n        });\\n        \\n        for (int i = 0 ; i < arr.length ; i++) {\\n            for (int j = i+1 ; j < arr.length ; j++) {\\n                pq.offer(new int[]{arr[i], arr[j]});\\n\\t\\t\\t\\t// Avoiding size greater than k\\n                while (pq.size() > k) {\\n                    pq.poll();\\n                }\\n            }\\n        }\\n\\n        return pq.poll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n\\t\\t// max-heap\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {\\n            double x = (double)b[0] / b[1];\\n            double y = (double)a[0] / a[1];\\n            if (x > y)\\n\\t\\t\\t\\treturn 1;  // lambda exp. returns b(param of lambda exp), if the value is positive. Hence returned b.\\n            return -1;  // lambda exp. returns a(param of lambda exp), if the value is negative. Hence returned a.\\n        });\\n        \\n        for (int i = 0 ; i < arr.length ; i++) {\\n            for (int j = i+1 ; j < arr.length ; j++) {\\n                pq.offer(new int[]{arr[i], arr[j]});\\n\\t\\t\\t\\t// Avoiding size greater than k\\n                while (pq.size() > k) {\\n                    pq.poll();\\n                }\\n            }\\n        }\\n\\n        return pq.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678746,
                "title": "c-binary-search-with-detailed-explanation",
                "content": "\\tfindCount(arr, target) : this returns the number of fractions in the array, which have a value less than or equal to target\\n\\t\\t\\t\\t\\t\\t\\t also this function returns the numerator and the denominator of the fraction that is closest to target (it might be equal as well)\\n\\n\\n\\n\\tfor now, just assume this function is already implemented\\n\\n\\tnow all the fractions under consideration lie between arr[0] / arr[n-1] and 1\\n\\n\\tthe approach is to apply binary search on this range\\n\\n\\twhat to search for? Ans : find the value of target, such that the number of fractions which are less than or equal to target are exactly equal to K\\n\\twhen you find such a target, return the fraction which is supplied by this findCount() function\\n\\n\\tnow mid = (low + high)/2;\\n\\n\\tvector<int> cur = findCount(arr, mid);\\n\\tcur[0] gives the number of fractions whose values are less than or equal to mid\\n\\tin case cur[0] == 0, means we have found the answer\\n\\n\\twhen cur[0] > k, it means that we are too far ahead, so move to the left portion\\n\\twhen cur[0] < k, it means that we are too left, so move to the right portion\\n\\n\\timplemeting findCount(arr, target)\\n\\n\\twe use two pointer method to do this\\n\\n\\ttreat each element as a fixed denominator , and find the largest i, such that arr[i] / arr[j] <= target\\n\\tand after finding this i, to your answer, add all the numbers from 0 to i\\n\\t(because all the numbers are sorted, so all the numbers till i, when treated as numerator (and arr[j] as the fixed denominator),\\n\\twill always be less than target)\\n\\n\\t[1, 3, 5, 7, 11, 13 , 17] (try out on this array)\\n\\t\\n\\t\\n```\\n\\tclass Solution {\\npublic:\\n\\tvector<int> findCount(vector<int> &arr, double mid) {\\n\\t\\tint n = arr.size();\\n\\t\\tint num = arr[0];\\n\\t\\tint denom = arr[n - 1];\\n\\n\\t\\tint i = 0; int cnt = 0;\\n\\t\\tfor (int j = 1; j < n; j++) {\\n\\t\\t\\twhile (arr[i] <= mid * arr[j]) i++;\\n\\t\\t\\tcnt += i;\\n\\n\\t\\t\\tif (i > 0 && arr[i - 1] * denom >= num *  arr[j]) {\\n\\t\\t\\t\\tnum = arr[i - 1];\\n\\t\\t\\t\\tdenom = arr[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn {cnt, num, denom};\\n\\t}\\n\\tvector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n\\n\\t\\tint n = arr.size();\\n\\t\\tdouble low = (arr[0] * 1.0) / arr[n - 1];\\n\\t\\tdouble high = 1;\\n\\n\\t\\tif (k == 1) return {arr[0], arr[n - 1]};\\n\\t\\tvector<int> ans;\\n\\n\\t\\twhile (low <= high) {\\n\\t\\t\\tdouble mid = (low + high) / 2;\\n\\t\\t\\tvector<int> cur = findCount(arr, mid);\\n\\n\\t\\t\\tif (cur[0] == k) {\\n\\t\\t\\t\\treturn {cur[1], cur[2]};\\n\\t\\t\\t}\\n\\n\\t\\t\\telse if (cur[0] > k) {\\n\\t\\t\\t\\thigh = mid;\\n\\t\\t\\t} else low = mid;\\n\\t\\t}\\n\\n\\t\\treturn {};\\n\\t}\\n};\\n\\t```",
                "solutionTags": [
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\n\\tclass Solution {\\npublic:\\n\\tvector<int> findCount(vector<int> &arr, double mid) {\\n\\t\\tint n = arr.size();\\n\\t\\tint num = arr[0];\\n\\t\\tint denom = arr[n - 1];\\n\\n\\t\\tint i = 0; int cnt = 0;\\n\\t\\tfor (int j = 1; j < n; j++) {\\n\\t\\t\\twhile (arr[i] <= mid * arr[j]) i++;\\n\\t\\t\\tcnt += i;\\n\\n\\t\\t\\tif (i > 0 && arr[i - 1] * denom >= num *  arr[j]) {\\n\\t\\t\\t\\tnum = arr[i - 1];\\n\\t\\t\\t\\tdenom = arr[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn {cnt, num, denom};\\n\\t}\\n\\tvector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n\\n\\t\\tint n = arr.size();\\n\\t\\tdouble low = (arr[0] * 1.0) / arr[n - 1];\\n\\t\\tdouble high = 1;\\n\\n\\t\\tif (k == 1) return {arr[0], arr[n - 1]};\\n\\t\\tvector<int> ans;\\n\\n\\t\\twhile (low <= high) {\\n\\t\\t\\tdouble mid = (low + high) / 2;\\n\\t\\t\\tvector<int> cur = findCount(arr, mid);\\n\\n\\t\\t\\tif (cur[0] == k) {\\n\\t\\t\\t\\treturn {cur[1], cur[2]};\\n\\t\\t\\t}\\n\\n\\t\\t\\telse if (cur[0] > k) {\\n\\t\\t\\t\\thigh = mid;\\n\\t\\t\\t} else low = mid;\\n\\t\\t}\\n\\n\\t\\treturn {};\\n\\t}\\n};\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1639161,
                "title": "simple-python-one-liner",
                "content": "```\\ndef kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        return sorted(list(combinations(arr, 2)), key=lambda x: x[0] / x[1])[k - 1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        return sorted(list(combinations(arr, 2)), key=lambda x: x[0] / x[1])[k - 1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1561540,
                "title": "java-45-81-using-priorityqueue-with-explanation-comments",
                "content": "This solution uses a PriorityQueue to keep track of up to n-1 fractions (where n is the number of elements in arr).  Each fraction starts as one of the first n-1 values in arr in the numerator, with the last value in the denominator.  These initial choices guarantee that there is no smaller number with each given numerator in the queue.\\n\\nAfter initially populating these fractions, the system pulls the first k-1 fractions from the head of the queue.  Each time a fraction is pulled, the denominator is reduced to the next smallest value, and the resulting fraction is re-queued as long as the numerator and denominator are not the same (which would violate the i < j condition in the problem description).\\n\\nThe kth fraction pulled from the queue is the answer.\\n\\nTo make the PriorityQueue work without resorting to floating-point arithmetic, the program cross-multiplies numerators and denominators, and compares the results.  This relies on the math fact that, for positive a, b, c, d:  a/b < c/d is equivalent to ad < bc.\\n\\nThe fractions are actually stored as indexes into the given array, not the values themselves.  This allows denominators to be reduced very easily, by subtracting one from an index.  At the end, when pulling the kth fraction, the program dereferences each index to get the actual values for the final answer.\\n\\n```\\nclass Solution {\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        // Create a priority queue for the fractions.\\n        // To compare two fractions, cross-multiply the denominators.\\n        // Note that the arrays in question are indices into arr, not values.\\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                return Integer.compare(arr[a[0]] * arr[b[1]], arr[a[1]] * arr[b[0]]);\\n            }\\n        });\\n        \\n        // Initially populate the queue with fractions with every possible numerator,\\n        // and the largest denominator.\\n        for (int i = 0; i < arr.length - 1; i++) queue.offer(new int[] { i, arr.length - 1 });\\n        \\n        // For k-1 iterations, get and remove the smallest fraction from the head of the queue.\\n        // Change the denominator to the next smallest number, and put back in the queue.\\n        // If the change in denominator makes it equal to the numerator, do not re-queue.\\n        for (int i = 1; i < k; i++) {\\n            int[] fraction = queue.poll();\\n            fraction[1]--;\\n            if (fraction[0] < fraction[1]) queue.offer(fraction);\\n        }\\n        \\n        // Take the kth smallest fraction from the queue.  De-reference the indices, and return.\\n        int[] answer = queue.poll();\\n        answer[0] = arr[answer[0]];\\n        answer[1] = arr[answer[1]];\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        // Create a priority queue for the fractions.\\n        // To compare two fractions, cross-multiply the denominators.\\n        // Note that the arrays in question are indices into arr, not values.\\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                return Integer.compare(arr[a[0]] * arr[b[1]], arr[a[1]] * arr[b[0]]);\\n            }\\n        });\\n        \\n        // Initially populate the queue with fractions with every possible numerator,\\n        // and the largest denominator.\\n        for (int i = 0; i < arr.length - 1; i++) queue.offer(new int[] { i, arr.length - 1 });\\n        \\n        // For k-1 iterations, get and remove the smallest fraction from the head of the queue.\\n        // Change the denominator to the next smallest number, and put back in the queue.\\n        // If the change in denominator makes it equal to the numerator, do not re-queue.\\n        for (int i = 1; i < k; i++) {\\n            int[] fraction = queue.poll();\\n            fraction[1]--;\\n            if (fraction[0] < fraction[1]) queue.offer(fraction);\\n        }\\n        \\n        // Take the kth smallest fraction from the queue.  De-reference the indices, and return.\\n        int[] answer = queue.poll();\\n        answer[0] = arr[answer[0]];\\n        answer[1] = arr[answer[1]];\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540598,
                "title": "using-binary-search-in-java-o-n-logn",
                "content": "**To solve this question we will assume 3 points:-**\\n1.) Our fraction window will lie in between 0 to 1\\n2.) For each window we will have x elements in that bucket and when bucket reaches k i.e. x == k our answer will be topmost/max element of that bucket.\\n3.) We can find count of element in bucket < mid in O(n) time using the concept of ladder setps.\\n**Time Complexity O(n * logn)**\\n```\\nclass Solution {\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        //As our fraction lie between 0 & 1\\n        double hi = 1;\\n        double lo = 0;\\n        while(true){\\n            int ansnum = 0;\\n            int ansden = 1;\\n            double mid = lo + (hi - lo)/2;\\n            int i = 0;\\n            int j = arr.length-1;\\n            int count = 0;\\n            while(i < arr.length-1 && j > 0){\\n                //arr[i]/arr[arr.length - j] > mid => till it not lie in that bucket\\n                while(j > 0 && arr[i] > mid * arr[arr.length - j]){\\n                    j--;\\n                }\\n                count += j;\\n                //arr[i]/arr[arr.length - j] > ansnum/ansden\\n                if(j > 0 && arr[i]*ansden >= ansnum*arr[arr.length - j]){\\n                    ansnum = arr[i];\\n                    ansden = arr[arr.length - j];\\n                }\\n                i++;\\n            }            \\n            if(count == k){\\n                return new int[] {ansnum,ansden};\\n            }else if(count > k){\\n                hi = mid;\\n            }else{\\n                lo = mid;\\n            }\\n        }\\n    }\\n}\\n```\\nIf code is not self explainatory one can comment, I will try to give detailed explaintion.",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        //As our fraction lie between 0 & 1\\n        double hi = 1;\\n        double lo = 0;\\n        while(true){\\n            int ansnum = 0;\\n            int ansden = 1;\\n            double mid = lo + (hi - lo)/2;\\n            int i = 0;\\n            int j = arr.length-1;\\n            int count = 0;\\n            while(i < arr.length-1 && j > 0){\\n                //arr[i]/arr[arr.length - j] > mid => till it not lie in that bucket\\n                while(j > 0 && arr[i] > mid * arr[arr.length - j]){\\n                    j--;\\n                }\\n                count += j;\\n                //arr[i]/arr[arr.length - j] > ansnum/ansden\\n                if(j > 0 && arr[i]*ansden >= ansnum*arr[arr.length - j]){\\n                    ansnum = arr[i];\\n                    ansden = arr[arr.length - j];\\n                }\\n                i++;\\n            }            \\n            if(count == k){\\n                return new int[] {ansnum,ansden};\\n            }else if(count > k){\\n                hi = mid;\\n            }else{\\n                lo = mid;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1468507,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        typedef pair<double,pair<int,int>>pr;\\n        priority_queue<pr>maxh;\\n        vector<int>v;\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                \\n                    double d=(double)arr[i]/arr[j];\\n                    maxh.push({d,{i,j}});\\n                    \\n                \\n                    \\n                    \\n            }\\n            \\n        }\\n        while(maxh.size()>k){\\n            maxh.pop();\\n            \\n            \\n            \\n        }\\n        int a=maxh.top().second.first;\\n        int b=maxh.top().second.second;\\n        v.push_back(arr[a]);\\n        v.push_back(arr[b]);\\n        return v;\\n        \\n        \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        typedef pair<double,pair<int,int>>pr;\\n        priority_queue<pr>maxh;\\n        vector<int>v;\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                \\n                    double d=(double)arr[i]/arr[j];\\n                    maxh.push({d,{i,j}});\\n                    \\n                \\n                    \\n                    \\n            }\\n            \\n        }\\n        while(maxh.size()>k){\\n            maxh.pop();\\n            \\n            \\n            \\n        }\\n        int a=maxh.top().second.first;\\n        int b=maxh.top().second.second;\\n        v.push_back(arr[a]);\\n        v.push_back(arr[b]);\\n        return v;\\n        \\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1278494,
                "title": "java-easy-solution-using-max-pq",
                "content": "```\\npublic int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> {\\n            // y = ad-bc\\n           int y = a[0] * b[1] - a[1] * b[0];\\n           return -y; //max pq\\n        });\\n        for(int i=0;i<arr.length-1;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                pq.add(new int[] {arr[i],arr[j]});\\n                if(pq.size() > k){\\n                    pq.remove();\\n                }\\n            }\\n        }\\n        int ans[];\\n        ans = pq.remove();\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> {\\n            // y = ad-bc\\n           int y = a[0] * b[1] - a[1] * b[0];\\n           return -y; //max pq\\n        });\\n        for(int i=0;i<arr.length-1;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                pq.add(new int[] {arr[i],arr[j]});\\n                if(pq.size() > k){\\n                    pq.remove();\\n                }\\n            }\\n        }\\n        int ans[];\\n        ans = pq.remove();\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1275649,
                "title": "c-o-max-n-k-log-n",
                "content": "```\\nclass Solution {\\npublic:\\n   #define p pair<float, pair<int,int>>\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n          \\n        int n=arr.size();\\n        int i=0;\\n        int j=n-1;\\n        priority_queue< p,vector<p>,greater<p> >pq;\\n        for(int i=0;i<n-1;i++){\\n            float num = float(arr[i])/(arr[j]);\\n            pq.push({num,{i,j}});\\n        }\\n        \\n        while(!pq.empty()&&k-1){\\n            auto it = pq.top();\\n            pq.pop();\\n            if(it.second.second!=it.second.first+1){\\n                int i=it.second.first;\\n                int j=it.second.second;\\n                float num = float(arr[i])/arr[j-1];\\n                pq.push({num,{i,j-1}});\\n            }\\n            \\n            k--;\\n        }\\n        \\n        return {arr[pq.top().second.first],arr[pq.top().second.second]};\\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   #define p pair<float, pair<int,int>>\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n          \\n        int n=arr.size();\\n        int i=0;\\n        int j=n-1;\\n        priority_queue< p,vector<p>,greater<p> >pq;\\n        for(int i=0;i<n-1;i++){\\n            float num = float(arr[i])/(arr[j]);\\n            pq.push({num,{i,j}});\\n        }\\n        \\n        while(!pq.empty()&&k-1){\\n            auto it = pq.top();\\n            pq.pop();\\n            if(it.second.second!=it.second.first+1){\\n                int i=it.second.first;\\n                int j=it.second.second;\\n                float num = float(arr[i])/arr[j-1];\\n                pq.push({num,{i,j-1}});\\n            }\\n            \\n            k--;\\n        }\\n        \\n        return {arr[pq.top().second.first],arr[pq.top().second.second]};\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1136588,
                "title": "python-solution-using-heap-klogk",
                "content": "```\\nclass Solution(object):\\n    def kthSmallestPrimeFraction(self, arr, k):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        n = len(arr)\\n        heap = [(arr[0]/float(arr[-1]), 0, n-1)]\\n        a = set()\\n        a.add((0,n-1))\\n        while k > 1:\\n            item, b1, b2 = heapq.heappop(heap)\\n            if b1+1!=b2 and b1+1 < b2:\\n                heapq.heappush(heap, (arr[b1]/float(arr[b2-1]), b1, b2-1))\\n                a.add((b1, b2-1))\\n            if b1+1 < len(arr)-1 and (b1+1, n-1) not in a:\\n                heapq.heappush(heap, (arr[b1+1]/float(arr[-1]), b1+1, n-1))\\n                a.add((b1+1, n-1))\\n            k-=1\\n        return [arr[heap[0][1]], arr[heap[0][2]]]\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def kthSmallestPrimeFraction(self, arr, k):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        n = len(arr)\\n        heap = [(arr[0]/float(arr[-1]), 0, n-1)]\\n        a = set()\\n        a.add((0,n-1))\\n        while k > 1:\\n            item, b1, b2 = heapq.heappop(heap)\\n            if b1+1!=b2 and b1+1 < b2:\\n                heapq.heappush(heap, (arr[b1]/float(arr[b2-1]), b1, b2-1))\\n                a.add((b1, b2-1))\\n            if b1+1 < len(arr)-1 and (b1+1, n-1) not in a:\\n                heapq.heappush(heap, (arr[b1+1]/float(arr[-1]), b1+1, n-1))\\n                a.add((b1+1, n-1))\\n            k-=1\\n        return [arr[heap[0][1]], arr[heap[0][2]]]\\n",
                "codeTag": "Java"
            },
            {
                "id": 1058231,
                "title": "5-lines-super-simple-python",
                "content": "```\\nimport heapq\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        \\n        heap = []\\n        for i in range (0, len(arr)):\\n            heapq.heappush(heap, (arr[i]/arr[-1], i, len(arr)-1))\\n            \\n        for i in range (0, k):\\n            _, l, h = heapq.heappop(heap)\\n            if h > 0: heapq.heappush(heap, (arr[l]/arr[h-1], l, h-1))\\n        \\n        return [arr[l],arr[h]]\\n",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        \\n        heap = []\\n        for i in range (0, len(arr)):\\n            heapq.heappush(heap, (arr[i]/arr[-1], i, len(arr)-1))\\n            \\n        for i in range (0, k):\\n            _, l, h = heapq.heappop(heap)\\n            if h > 0: heapq.heappush(heap, (arr[l]/arr[h-1], l, h-1))\\n        \\n        return [arr[l],arr[h]]\\n",
                "codeTag": "Java"
            },
            {
                "id": 1054343,
                "title": "java-3ms-binary-search",
                "content": "class Solution {\\n   \\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n       int n = arr.length;\\n        double lo = 0.0, hi = 1.0;\\n        int p = 0, q = 0;\\n        while (true) {\\n            double mid = (lo + hi) / 2;\\n            // find the prime fraction having value less than eqaul to mid\\n            int count = 0;\\n            double maxFrac = 0.0;\\n            int j = 1;\\n            for (int i = 0; i < n - 1; i++) {\\n                while (j < n && arr[i] > (arr[j] * mid)) {\\n                    j++;\\n                }\\n                count += (n - j);\\n                if (j == n)\\n                    break;\\n                double currFrac = ((double)arr[i] / (double)arr[j]);\\n\\n                if (currFrac > maxFrac) {\\n                    p = i;\\n                    q = j;\\n                    maxFrac = currFrac;\\n                }\\n            }\\n            if (count == k) {\\n                return new int[] { arr[p], arr[q] };\\n            } else if (count > k) {\\n                hi = mid;\\n            } else {\\n                lo = mid;\\n            }\\n        }\\n   \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n   \\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n       int n = arr.length;\\n        double lo = 0.0, hi = 1.0;\\n        int p = 0, q = 0;\\n        while (true) {\\n            double mid = (lo + hi) / 2;\\n            // find the prime fraction having value less than eqaul to mid\\n            int count = 0;\\n            double maxFrac = 0.0;\\n            int j = 1;\\n            for (int i = 0; i < n - 1; i++) {\\n                while (j < n && arr[i] > (arr[j] * mid)) {\\n                    j++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1048091,
                "title": "brute-force-easy-but-not-tle-c-with-priority-queue-1636-ms",
                "content": "```\\ntypedef pair<double,pair<int,int>> pr;\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<pr,vector<pr>,greater<pr>> pq;\\n        for(int i=0;i<arr.size();++i)\\n            for(int j=i+1;j<arr.size();++j)\\n                pq.push({(double)arr[i]/arr[j],{arr[i],arr[j]}});\\n            \\n        while(--k)\\n            pq.pop();\\n        return vector<int>{pq.top().second.first,pq.top().second.second};\\n    }\\n};\\n\\n\\n// Time: O(N^2)\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntypedef pair<double,pair<int,int>> pr;\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<pr,vector<pr>,greater<pr>> pq;\\n        for(int i=0;i<arr.size();++i)\\n            for(int j=i+1;j<arr.size();++j)\\n                pq.push({(double)arr[i]/arr[j],{arr[i],arr[j]}});\\n            \\n        while(--k)\\n            pq.pop();\\n        return vector<int>{pq.top().second.first,pq.top().second.second};\\n    }\\n};\\n\\n\\n// Time: O(N^2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 713893,
                "title": "priority-queue-with-heapq-easy-to-understand",
                "content": "\\n\\tclass Solution:\\n\\t\\tdef kthSmallestPrimeFraction(self, A: List[int], K: int) -> List[int]:\\n\\t\\t\\tpq = []\\n\\n\\t\\t\\tn = len(A)\\n\\t\\t\\tfor i in range(n -1 ):\\n\\t\\t\\t\\theappush(pq, (A[i] / A[-1],  i, n - 1 ))\\n\\n\\t\\t\\twhile K > 1:\\n\\n\\t\\t\\t\\tt = heappop(pq)\\n\\t\\t\\t\\t#print(t)\\n\\t\\t\\t\\theappush(pq, (A[t[1]] / A[t[2] - 1],  t[1], t[2] - 1))\\n\\n\\t\\t\\t\\tK -= 1\\n\\t\\t\\tt = heappop(pq)\\n\\n\\t\\t\\treturn [A[t[1]] ,A[t[2]] ]\\n\\t\\n\\t\\t",
                "solutionTags": [],
                "code": "\\n\\tclass Solution:\\n\\t\\tdef kthSmallestPrimeFraction(self, A: List[int], K: int) -> List[int]:\\n\\t\\t\\tpq = []\\n\\n\\t\\t\\tn = len(A)\\n\\t\\t\\tfor i in range(n -1 ):\\n\\t\\t\\t\\theappush(pq, (A[i] / A[-1],  i, n - 1 ))\\n\\n\\t\\t\\twhile K > 1:\\n\\n\\t\\t\\t\\tt = heappop(pq)\\n\\t\\t\\t\\t#print(t)\\n\\t\\t\\t\\theappush(pq, (A[t[1]] / A[t[2] - 1],  t[1], t[2] - 1))\\n\\n\\t\\t\\t\\tK -= 1\\n\\t\\t\\tt = heappop(pq)\\n\\n\\t\\t\\treturn [A[t[1]] ,A[t[2]] ]\\n\\t\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 546251,
                "title": "accepted-c-solution-with-binary-search",
                "content": "```\\n    public class Solution\\n    {\\n        private int Check(double[] nums, double cand)\\n        {\\n            int res = 0;\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                var p = nums[i];\\n                var minQ = p / cand;\\n\\n                var idx = Array.BinarySearch(nums, minQ);\\n\\n                if (idx <= 0)\\n                {\\n                    int nearest = idx + 1;\\n                    nearest = -nearest;\\n                    res += nums.Length - nearest;\\n                }\\n                else\\n                {\\n                    while (idx > 0 && nums[idx] == nums[idx - 1])\\n                    {\\n                        idx--;\\n                    }\\n\\n                    res += nums.Length - idx;\\n                }\\n            }\\n\\n            return res;\\n        }\\n\\n        public int[] KthSmallestPrimeFraction(int[] nums, int k)\\n        {\\n            var doubles = nums.Select(n => (double) n).ToArray();\\n            double min = (double) nums[0] / nums[nums.Length - 1];\\n            double max = 1;\\n            double mid = 0;\\n\\n            while (max - min > 0.0000000001)\\n            {\\n                mid = min + (max - min) / 2;\\n                var count = Check(doubles, mid);\\n\\n                if (count < k)\\n                {\\n                    min = mid;\\n                }\\n                else\\n                {\\n                    max = mid;\\n                }\\n            }\\n\\n            int[] res = new int[] {1, 1};\\n\\n            for (int i = 0; i < nums.Length - 1; i++)\\n            {\\n                double p = doubles[i];\\n\\n                int l = i + 1;\\n                int r = nums.Length - 1;\\n\\n                while (l < r)\\n                {\\n                    if (r - l <= 1)\\n                    {\\n                        break;\\n                    }\\n\\n                    int m = l + (r - l) / 2;\\n                    var frac = p / nums[m];\\n\\n                    if (frac <= mid)\\n                    {\\n                        r = m;\\n                    }\\n                    else\\n                    {\\n                        l = m;\\n                    }\\n                }\\n\\n                int q = l;\\n                var cand = p / nums[l];\\n                if (Math.Abs(p / nums[r] - mid) < Math.Abs(cand - mid))\\n                {\\n                    q = r;\\n                    cand = p / nums[r];\\n                }\\n\\n                if (Math.Abs(mid - (double) res[0] / res[1]) > Math.Abs(cand - mid))\\n                {\\n                    res[0] = nums[i];\\n                    res[1] = nums[q];\\n                }\\n            }\\n\\n            return res;\\n\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        private int Check(double[] nums, double cand)\\n        {\\n            int res = 0;\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                var p = nums[i];\\n                var minQ = p / cand;\\n\\n                var idx = Array.BinarySearch(nums, minQ);\\n\\n                if (idx <= 0)\\n                {\\n                    int nearest = idx + 1;\\n                    nearest = -nearest;\\n                    res += nums.Length - nearest;\\n                }\\n                else\\n                {\\n                    while (idx > 0 && nums[idx] == nums[idx - 1])\\n                    {\\n                        idx--;\\n                    }\\n\\n                    res += nums.Length - idx;\\n                }\\n            }\\n\\n            return res;\\n        }\\n\\n        public int[] KthSmallestPrimeFraction(int[] nums, int k)\\n        {\\n            var doubles = nums.Select(n => (double) n).ToArray();\\n            double min = (double) nums[0] / nums[nums.Length - 1];\\n            double max = 1;\\n            double mid = 0;\\n\\n            while (max - min > 0.0000000001)\\n            {\\n                mid = min + (max - min) / 2;\\n                var count = Check(doubles, mid);\\n\\n                if (count < k)\\n                {\\n                    min = mid;\\n                }\\n                else\\n                {\\n                    max = mid;\\n                }\\n            }\\n\\n            int[] res = new int[] {1, 1};\\n\\n            for (int i = 0; i < nums.Length - 1; i++)\\n            {\\n                double p = doubles[i];\\n\\n                int l = i + 1;\\n                int r = nums.Length - 1;\\n\\n                while (l < r)\\n                {\\n                    if (r - l <= 1)\\n                    {\\n                        break;\\n                    }\\n\\n                    int m = l + (r - l) / 2;\\n                    var frac = p / nums[m];\\n\\n                    if (frac <= mid)\\n                    {\\n                        r = m;\\n                    }\\n                    else\\n                    {\\n                        l = m;\\n                    }\\n                }\\n\\n                int q = l;\\n                var cand = p / nums[l];\\n                if (Math.Abs(p / nums[r] - mid) < Math.Abs(cand - mid))\\n                {\\n                    q = r;\\n                    cand = p / nums[r];\\n                }\\n\\n                if (Math.Abs(mid - (double) res[0] / res[1]) > Math.Abs(cand - mid))\\n                {\\n                    res[0] = nums[i];\\n                    res[1] = nums[q];\\n                }\\n            }\\n\\n            return res;\\n\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433959,
                "title": "java-easy-to-understand-used-minheap",
                "content": "```\\npublic static int[] kthSmallestPrimeFraction(int[] A, int K) {\\n\\t\\tPriorityQueue<int[]> minHeap = new PriorityQueue<int[]>(new Comparator<int[]>() {\\n\\t\\t\\tpublic int compare(int[] i1, int[] i2) {\\n\\t\\t\\t\\treturn Integer.compare(A[i1[0]] * A[i2[1]], A[i1[1]] * A[i2[0]]);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tfor (int i = 0; i < A.length - 1; i++)\\n\\t\\t\\tminHeap.offer(new int[] { i, A.length - 1 });\\n\\n\\t\\tfor (int i = 0; i < K - 1; i++) {\\n\\t\\t\\tint[] curMin = minHeap.poll();\\n\\t\\t\\tif (curMin[1] - 1 > curMin[0])\\n\\t\\t\\t\\tminHeap.offer(new int[] { curMin[0], curMin[1] - 1 });\\n\\t\\t}\\n\\n\\t\\tint[] ret = minHeap.poll();\\n\\t\\treturn new int[] { A[ret[0]], A[ret[1]] };\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\npublic static int[] kthSmallestPrimeFraction(int[] A, int K) {\\n\\t\\tPriorityQueue<int[]> minHeap = new PriorityQueue<int[]>(new Comparator<int[]>() {\\n\\t\\t\\tpublic int compare(int[] i1, int[] i2) {\\n\\t\\t\\t\\treturn Integer.compare(A[i1[0]] * A[i2[1]], A[i1[1]] * A[i2[0]]);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tfor (int i = 0; i < A.length - 1; i++)\\n\\t\\t\\tminHeap.offer(new int[] { i, A.length - 1 });\\n\\n\\t\\tfor (int i = 0; i < K - 1; i++) {\\n\\t\\t\\tint[] curMin = minHeap.poll();\\n\\t\\t\\tif (curMin[1] - 1 > curMin[0])\\n\\t\\t\\t\\tminHeap.offer(new int[] { curMin[0], curMin[1] - 1 });\\n\\t\\t}\\n\\n\\t\\tint[] ret = minHeap.poll();\\n\\t\\treturn new int[] { A[ret[0]], A[ret[1]] };\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 392520,
                "title": "go-o-klogk-solution-using-priorityqueue",
                "content": "```Go\\ntype Fraction struct {\\n\\tVal       float64\\n\\tNumIndex  int // numberator index\\n\\tDenoIndex int // denominator index\\n}\\n\\ntype minHeap []Fraction\\n\\nfunc (m minHeap) Len() int {\\n\\treturn len(m)\\n}\\n\\nfunc (m minHeap) Swap(i, j int) {\\n\\tm[i], m[j] = m[j], m[i]\\n}\\n\\nfunc (m minHeap) Less(i, j int) bool {\\n\\treturn m[i].Val < m[j].Val\\n}\\n\\nfunc (m *minHeap) Push(x interface{}) {\\n\\t*m = append(*m, x.(Fraction))\\n}\\n\\nfunc (m *minHeap) Pop() interface{} {\\n\\told := *m\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\told = old[:n-1]\\n\\t*m = old\\n\\treturn x\\n}\\n\\n/*\\n1/5 < 1/3 < 1/2\\n2/5 < 2/3\\n3/5\\n*/\\nfunc kthSmallestPrimeFraction(A []int, K int) []int {\\n    m := &minHeap{}\\n\\theap.Init(m)\\n    \\n    // push first fractions into the heap.\\n    // we will push [ 1/5, 2/5, 3/5 ]\\n    n := len(A)\\n    for i:=0;i<n-1;i++{\\n        f := Fraction{float64(A[i])/float64(A[n-1]), i, n-1}\\n        heap.Push(m, f)\\n    }\\n    \\n    result := []int{}\\n    // pop k elements\\n    for {\\n        f := heap.Pop(m)\\n        temp := f.(Fraction)\\n        K--\\n        if K == 0{\\n            result = append(result, A[temp.NumIndex])\\n            result = append(result, A[temp.DenoIndex])\\n            return result\\n        }\\n        // push next fraction from poped chain\\n        nextNum := temp.NumIndex\\n        nextDeno := temp.DenoIndex - 1\\n        if nextNum < nextDeno{\\n            nextF := Fraction{float64(A[nextNum])/float64(A[nextDeno]), nextNum, nextDeno}\\n            heap.Push(m, nextF)\\n        }\\n        \\n    }\\n    return nil\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```Go\\ntype Fraction struct {\\n\\tVal       float64\\n\\tNumIndex  int // numberator index\\n\\tDenoIndex int // denominator index\\n}\\n\\ntype minHeap []Fraction\\n\\nfunc (m minHeap) Len() int {\\n\\treturn len(m)\\n}\\n\\nfunc (m minHeap) Swap(i, j int) {\\n\\tm[i], m[j] = m[j], m[i]\\n}\\n\\nfunc (m minHeap) Less(i, j int) bool {\\n\\treturn m[i].Val < m[j].Val\\n}\\n\\nfunc (m *minHeap) Push(x interface{}) {\\n\\t*m = append(*m, x.(Fraction))\\n}\\n\\nfunc (m *minHeap) Pop() interface{} {\\n\\told := *m\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\told = old[:n-1]\\n\\t*m = old\\n\\treturn x\\n}\\n\\n/*\\n1/5 < 1/3 < 1/2\\n2/5 < 2/3\\n3/5\\n*/\\nfunc kthSmallestPrimeFraction(A []int, K int) []int {\\n    m := &minHeap{}\\n\\theap.Init(m)\\n    \\n    // push first fractions into the heap.\\n    // we will push [ 1/5, 2/5, 3/5 ]\\n    n := len(A)\\n    for i:=0;i<n-1;i++{\\n        f := Fraction{float64(A[i])/float64(A[n-1]), i, n-1}\\n        heap.Push(m, f)\\n    }\\n    \\n    result := []int{}\\n    // pop k elements\\n    for {\\n        f := heap.Pop(m)\\n        temp := f.(Fraction)\\n        K--\\n        if K == 0{\\n            result = append(result, A[temp.NumIndex])\\n            result = append(result, A[temp.DenoIndex])\\n            return result\\n        }\\n        // push next fraction from poped chain\\n        nextNum := temp.NumIndex\\n        nextDeno := temp.DenoIndex - 1\\n        if nextNum < nextDeno{\\n            nextF := Fraction{float64(A[nextNum])/float64(A[nextDeno]), nextNum, nextDeno}\\n            heap.Push(m, nextF)\\n        }\\n        \\n    }\\n    return nil\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 359794,
                "title": "java-offer-in-poll-bisect",
                "content": "\\nOffer In Poll:\\n\\nOffer new element only when we poll an element out from a sorted candidates list.\\nHere, the sorted candidates list is formed by the fact that for any number i, the i/v value is getting smaller in order when v is in ascending order.\\n\\nUsing offer in poll, we reduce the time from O(N^2 * logN) to O(N*logN)\\n```\\nclass Solution {\\n    public int[] kthSmallestPrimeFraction(int[] A, int K) {\\n        int n = A.length;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(\\n           (a,b)->Integer.compare(A[a[0]]*A[b[1]], A[a[1]]*A[b[0]]));\\n        for (int i=0; i<n-1; i++){\\n            pq.add(new int[]{i, n-1});\\n        }\\n        for (int i=0;i<K-1;i++){\\n            int[] cur = pq.poll();\\n            if (cur[1]-1>cur[0]){\\n                pq.add(new int[]{cur[0],cur[1]-1});\\n            }\\n        }\\n        int[] ret = pq.poll();\\n        return new int[]{A[ret[0]], A[ret[1]]};\\n    }\\n}\\n```\\n\\nAlso, for FIND THE KTH LARGEST, we always get Trial and Error solution:\\n```\\nclass Solution {\\n    int[] arr;\\n    public int[] kthSmallestPrimeFraction(int[] A, int K) {\\n        arr = A;\\n        double low=0.0, high=1.0, mid;\\n        int[] ret;\\n        while (true){\\n            mid = (low+high)/2.0;\\n            ret = trial(mid);\\n            if (ret[0]<K){\\n                low = mid;\\n            }else if(ret[0]>K){\\n                high = mid;\\n            }else{\\n                return new int[]{ret[1],ret[2]};\\n            }\\n        }\\n    }\\n    \\n    int[] trial(double mid){\\n        int cnt = 0, n = arr.length, p=0, q=1;\\n        for (int i=0, j=n-1; i<n-1; i++,j=n-1){\\n            while (j>i && arr[i]<arr[j]*mid) j--;\\n            cnt += n-j-1;\\n            if (j<n-1 && p*arr[j+1] < q*arr[i]){\\n                p = arr[i];\\n                q = arr[j+1];\\n            }\\n        }\\n        return new int[]{cnt,p,q};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] kthSmallestPrimeFraction(int[] A, int K) {\\n        int n = A.length;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(\\n           (a,b)->Integer.compare(A[a[0]]*A[b[1]], A[a[1]]*A[b[0]]));\\n        for (int i=0; i<n-1; i++){\\n            pq.add(new int[]{i, n-1});\\n        }\\n        for (int i=0;i<K-1;i++){\\n            int[] cur = pq.poll();\\n            if (cur[1]-1>cur[0]){\\n                pq.add(new int[]{cur[0],cur[1]-1});\\n            }\\n        }\\n        int[] ret = pq.poll();\\n        return new int[]{A[ret[0]], A[ret[1]]};\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int[] arr;\\n    public int[] kthSmallestPrimeFraction(int[] A, int K) {\\n        arr = A;\\n        double low=0.0, high=1.0, mid;\\n        int[] ret;\\n        while (true){\\n            mid = (low+high)/2.0;\\n            ret = trial(mid);\\n            if (ret[0]<K){\\n                low = mid;\\n            }else if(ret[0]>K){\\n                high = mid;\\n            }else{\\n                return new int[]{ret[1],ret[2]};\\n            }\\n        }\\n    }\\n    \\n    int[] trial(double mid){\\n        int cnt = 0, n = arr.length, p=0, q=1;\\n        for (int i=0, j=n-1; i<n-1; i++,j=n-1){\\n            while (j>i && arr[i]<arr[j]*mid) j--;\\n            cnt += n-j-1;\\n            if (j<n-1 && p*arr[j+1] < q*arr[i]){\\n                p = arr[i];\\n                q = arr[j+1];\\n            }\\n        }\\n        return new int[]{cnt,p,q};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 256403,
                "title": "java-priorityqueue-solution",
                "content": "```    \\npublic int[] kthSmallestPrimeFraction(int[] A, int K) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b)->Double.compare((double)A[a[0]]/(double)A[a[1]], (double)A[b[0]]/(double)A[b[1]]));\\n        for(int i = 0; i < A.length; i++) pq.offer(new int[]{i, A.length - 1});\\n        while(--K > 0) {\\n            int[] t = pq.poll();\\n            pq.offer(new int[]{t[0], t[1] - 1});\\n        }\\n        return new int[]{A[pq.peek()[0]], A[pq.peek()[1]]};\\n    }\\n```",
                "solutionTags": [],
                "code": "```    \\npublic int[] kthSmallestPrimeFraction(int[] A, int K) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b)->Double.compare((double)A[a[0]]/(double)A[a[1]], (double)A[b[0]]/(double)A[b[1]]));\\n        for(int i = 0; i < A.length; i++) pq.offer(new int[]{i, A.length - 1});\\n        while(--K > 0) {\\n            int[] t = pq.poll();\\n            pq.offer(new int[]{t[0], t[1] - 1});\\n        }\\n        return new int[]{A[pq.peek()[0]], A[pq.peek()[1]]};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 115867,
                "title": "priorityqueue-solution-similar-to-searching-in-sorted-matrix",
                "content": "```\npublic int[] kthSmallestPrimeFraction(int[] A, int K) {\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>(K, \n            (a,b)->(A[a[0]] * A[b[1]] - A[b[0]] * A[a[1]]));\n        \n        for(int i = A.length-1; i >=0; --i){\n            pq.add(new int[]{0, i});\n        }\n        \n        while(K > 0 && !pq.isEmpty()){\n            K--;\n            int [] p = pq.poll();\n            if(K == 0){\n                return  new int[]{A[p[0]], A[p[1]]};\n            }\n            pq.add(new int[] { p[0]+1, p[1]});\n        }\n        return new int[]{0, 0};\n        \n    }",
                "solutionTags": [],
                "code": "public int[] kthSmallestPrimeFraction(int[] A, int K) {\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>(K, \n            (a,b)->(A[a[0]] * A[b[1]] - A[b[0]] * A[a[1]]));\n        for(int i = A.length-1; i >=0; --i){\n            pq.add(new int[]{0, i});\n        }\n        while(K > 0 && !pq.isEmpty()){\n            K--;\n            int [] p = pq.poll();\n            if(K == 0){\n                return  new int[]{A[p[0]], A[p[1]]};\n            }\n            pq.add(new int[] { p[0]+1, p[1]});\n        }\n        return new int[]{0, 0};\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 115620,
                "title": "python-o-nlogn-tle-java-ac",
                "content": "The same algorithm gives TLE and AC in Python and Java respectively.\n```\nclass Solution(object):\n    def kthSmallestPrimeFraction(self, A, K):\n        \"\"\"\n        :type A: List[int]\n        :type K: int\n        :rtype: List[int]\n        \"\"\"\n        N=len(A)\n        h=[(1.0/A[-1],N-1,0)]\n        \n        while K:\n            (f,qi,pi)=heapq.heappop(h)\n            if pi==0 and qi>0:\n                heapq.heappush(h,(1.0/A[qi-1],qi-1,0))\n            if pi+1<N:\n                heapq.heappush(h,(1.0*A[pi+1]/A[qi],qi,pi+1))\n            K-=1\n\t\t\t\t\t\t\n        return [A[pi],A[qi]]\n```\n\n```\nclass Solution {\n    public int[] kthSmallestPrimeFraction(int[] A, int K) {\n  \n        class Elm implements Comparable<Elm>{\n            double f;\n            int pi,qi;\n            public int compareTo(Elm o){\n                return f==o.f? 0: f<o.f? -1: 1;\n            }\n            Elm(double f,int qi,int pi){\n                this.pi=pi;\n                this.qi=qi;\n                this.f=f;\n            }\n        }\n        PriorityQueue<Elm> h = new PriorityQueue<Elm>();\n        Elm mn=new Elm(1.0/A[A.length-1],A.length-1,0);\n        h.add(mn);\n        while (K-->0){\n            mn = h.poll();\n            if (mn.pi==0 && mn.qi>0)\n                h.add(new Elm(1.0/A[mn.qi-1],mn.qi-1,0));\n            if (mn.pi+1<A.length)\n                h.add(new Elm(1.0*A[mn.pi+1]/A[mn.qi],mn.qi,mn.pi+1));\n        }\n        return new int[]{A[mn.pi],A[mn.qi]};\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def kthSmallestPrimeFraction(self, A, K):\n        \"\"\"\n        :type A: List[int]\n        :type K: int\n        :rtype: List[int]\n        \"\"\"\n        N=len(A)\n        h=[(1.0/A[-1],N-1,0)]\n        \n        while K:\n            (f,qi,pi)=heapq.heappop(h)\n            if pi==0 and qi>0:\n                heapq.heappush(h,(1.0/A[qi-1],qi-1,0))\n            if pi+1<N:\n                heapq.heappush(h,(1.0*A[pi+1]/A[qi],qi,pi+1))\n            K-=1\n\t\t\t\t\t\t\n        return [A[pi],A[qi]]\n```\n```\nclass Solution {\n    public int[] kthSmallestPrimeFraction(int[] A, int K) {\n  \n        class Elm implements Comparable<Elm>{\n            double f;\n            int pi,qi;\n            public int compareTo(Elm o){\n                return f==o.f? 0: f<o.f? -1: 1;\n            }\n            Elm(double f,int qi,int pi){\n                this.pi=pi;\n                this.qi=qi;\n                this.f=f;\n            }\n        }\n        PriorityQueue<Elm> h = new PriorityQueue<Elm>();\n        Elm mn=new Elm(1.0/A[A.length-1],A.length-1,0);\n        h.add(mn);\n        while (K-->0){\n            mn = h.poll();\n            if (mn.pi==0 && mn.qi>0)\n                h.add(new Elm(1.0/A[mn.qi-1],mn.qi-1,0));\n            if (mn.pi+1<A.length)\n                h.add(new Elm(1.0*A[mn.pi+1]/A[mn.qi],mn.qi,mn.pi+1));\n        }\n        return new int[]{A[mn.pi],A[mn.qi]};\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090873,
                "title": "c-binary-search",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n\\\\log{n})$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        double l = 0, r = 1, m;\\n        vector<int> res;\\n        while (l <= r) {\\n            m = (l + r) / 2;\\n            int j = 1, total = 0, numerator = 0, denominator = 0;\\n            double maxFraction = 0;\\n            for (int i = 0; i < n; ++ i) {\\n                while (j < n && arr[i] > arr[j] * m) ++ j;\\n                total += n - j;\\n                if (j < n && maxFraction < arr[i] * 1.0 / arr[j]) {\\n                    maxFraction = arr[i] * 1.0 / arr[j];\\n                    numerator = i; denominator = j;\\n                }\\n            }\\n            if (total == k) {\\n                res = {arr[numerator], arr[denominator]};\\n                break;\\n            }\\n            if (total > k) r = m;\\n            else l = m;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        double l = 0, r = 1, m;\\n        vector<int> res;\\n        while (l <= r) {\\n            m = (l + r) / 2;\\n            int j = 1, total = 0, numerator = 0, denominator = 0;\\n            double maxFraction = 0;\\n            for (int i = 0; i < n; ++ i) {\\n                while (j < n && arr[i] > arr[j] * m) ++ j;\\n                total += n - j;\\n                if (j < n && maxFraction < arr[i] * 1.0 / arr[j]) {\\n                    maxFraction = arr[i] * 1.0 / arr[j];\\n                    numerator = i; denominator = j;\\n                }\\n            }\\n            if (total == k) {\\n                res = {arr[numerator], arr[denominator]};\\n                break;\\n            }\\n            if (total > k) r = m;\\n            else l = m;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067782,
                "title": "dictionary-a-very-bad-approach-runtime-1296ms-and-memory-112mb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        res={}\\n        for i in range(len(arr)):\\n            for j in range(i,len(arr)):\\n                if arr[i]!=arr[j]:\\n                    res[arr[i]/arr[j]]=[arr[i],arr[j]]\\n        sort_res=list(res.keys())\\n        sort_res.sort()\\n        return res[sort_res[k-1]]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        res={}\\n        for i in range(len(arr)):\\n            for j in range(i,len(arr)):\\n                if arr[i]!=arr[j]:\\n                    res[arr[i]/arr[j]]=[arr[i],arr[j]]\\n        sort_res=list(res.keys())\\n        sort_res.sort()\\n        return res[sort_res[k-1]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065336,
                "title": "k-th-smallest-prime-fraction",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar kthSmallestPrimeFraction = function(arr, k) {\\n    arr.sort((a,b)=>{return a - b});\\n    let map = new Map();\\n    let count=0;\\n    for(let i=1;i<arr.length;i++){\\n        for(let j=i-1;j>=0;j--){\\n            map.set(count,[arr[i],arr[j]]);\\n            count++;\\n        }\\n    }\\n    let array = Array.from(map.values());\\n    array.sort((a,b)=>{return b[0]/b[1] - a[0]/a[1]});\\n    let result = array[k-1];\\n    return result.sort((a,b)=>{return a-b})\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar kthSmallestPrimeFraction = function(arr, k) {\\n    arr.sort((a,b)=>{return a - b});\\n    let map = new Map();\\n    let count=0;\\n    for(let i=1;i<arr.length;i++){\\n        for(let j=i-1;j>=0;j--){\\n            map.set(count,[arr[i],arr[j]]);\\n            count++;\\n        }\\n    }\\n    let array = Array.from(map.values());\\n    array.sort((a,b)=>{return b[0]/b[1] - a[0]/a[1]});\\n    let result = array[k-1];\\n    return result.sort((a,b)=>{return a-b})\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034314,
                "title": "java-easy-solution-o-n-2-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(Total Pairs)\\n# Code\\n```\\nclass Solution {\\n    class pair{\\n        double fraction;\\n        int x;\\n        int y;\\n        pair(double fraction,int x,int y){\\n            this.x=x;\\n            this.y=y;\\n            this.fraction=fraction;\\n        }\\n    }\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        PriorityQueue<pair>pq=new PriorityQueue<>(\\n            (a,b)->{\\n                if(a.fraction>b.fraction) return 1;//valid \\n                if(a.fraction<b.fraction) return -1;//invalid\\n                return 0;\\n\\n            }\\n        );\\n\\n        int[]ans=new int[2];\\n        for(int i=0;i<arr.length-1;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                double frac=(double)arr[i]/(double)arr[j];\\n                pq.add(new pair(frac,arr[i],arr[j]));\\n            }\\n        }\\n\\n        for(int i=0;i<k-1;i++)\\n            pq.poll();\\n        \\n        pair pr=pq.poll();\\n        ans[0]=pr.x;\\n        ans[1]=pr.y;\\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class pair{\\n        double fraction;\\n        int x;\\n        int y;\\n        pair(double fraction,int x,int y){\\n            this.x=x;\\n            this.y=y;\\n            this.fraction=fraction;\\n        }\\n    }\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        PriorityQueue<pair>pq=new PriorityQueue<>(\\n            (a,b)->{\\n                if(a.fraction>b.fraction) return 1;//valid \\n                if(a.fraction<b.fraction) return -1;//invalid\\n                return 0;\\n\\n            }\\n        );\\n\\n        int[]ans=new int[2];\\n        for(int i=0;i<arr.length-1;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                double frac=(double)arr[i]/(double)arr[j];\\n                pq.add(new pair(frac,arr[i],arr[j]));\\n            }\\n        }\\n\\n        for(int i=0;i<k-1;i++)\\n            pq.poll();\\n        \\n        pair pr=pq.poll();\\n        ans[0]=pr.x;\\n        ans[1]=pr.y;\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001601,
                "title": "simple-approach-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n**Max Heap Approach using Priority Queue**\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*n+k)$$\\n\\n- Space complexity:\\n$$O(n*nlogn)$$\\n\\n# Code\\n```\\ntypedef pair<double, pair<int, int>> triplet;\\n\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<triplet> pq;\\n        int n = arr.size();\\n\\n        for(int i = 0;i < n-1; i++) {\\n            for(int j = i+1;j < n; j++) {\\n                double d = (1.0*arr[i])/(1.0*arr[j]);\\n                pq.push({-d, {arr[i], arr[j]}});\\n            }\\n        }\\n\\n        vector<int> ans(2);\\n        while(k--) {\\n            triplet t = pq.top();\\n            ans[0] = t.second.first;\\n            ans[1] = t.second.second;\\n            pq.pop();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntypedef pair<double, pair<int, int>> triplet;\\n\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<triplet> pq;\\n        int n = arr.size();\\n\\n        for(int i = 0;i < n-1; i++) {\\n            for(int j = i+1;j < n; j++) {\\n                double d = (1.0*arr[i])/(1.0*arr[j]);\\n                pq.push({-d, {arr[i], arr[j]}});\\n            }\\n        }\\n\\n        vector<int> ans(2);\\n        while(k--) {\\n            triplet t = pq.top();\\n            ans[0] = t.second.first;\\n            ans[1] = t.second.second;\\n            pq.pop();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995973,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        int n = arr.length;\\n        PriorityQueue<Element> minHeap = new PriorityQueue<Element>((a,b)->(arr[a.i]*arr[b.j]-arr[b.i]*arr[a.j]));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                minHeap.add(new Element(i,j));\\n            }\\n        }\\n        \\n        Element e=null;\\n        while(k!=0){\\n            e = minHeap.poll();\\n            k--;\\n        }\\n        return new int[]{arr[e.i],arr[e.j]};\\n    }\\n}\\n\\nclass Element{\\n    int i;\\n    int j;\\n    \\n    Element(int i,int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        vector<int>ans;\\n        priority_queue<pair<float,pair<float,float>>, vector<pair<float,pair<float,float>>> , greater<pair<float,pair<float,float>>>>p;\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                float frac=(float)arr[i]/(float)arr[j];\\n               \\n               p.push({frac,{arr[i],arr[j]}});\\n            }\\n           \\n        }\\n       \\n          k-=1;\\n            while(k--){\\n              p.pop();\\n            }\\n            ans.push_back(p.top().second.first);\\n            ans.push_back(p.top().second.second);\\n            return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        int n = arr.length;\\n        PriorityQueue<Element> minHeap = new PriorityQueue<Element>((a,b)->(arr[a.i]*arr[b.j]-arr[b.i]*arr[a.j]));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                minHeap.add(new Element(i,j));\\n            }\\n        }\\n        \\n        Element e=null;\\n        while(k!=0){\\n            e = minHeap.poll();\\n            k--;\\n        }\\n        return new int[]{arr[e.i],arr[e.j]};\\n    }\\n}\\n\\nclass Element{\\n    int i;\\n    int j;\\n    \\n    Element(int i,int j){\\n        this.i = i;\\n        this.j = j;\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        vector<int>ans;\\n        priority_queue<pair<float,pair<float,float>>, vector<pair<float,pair<float,float>>> , greater<pair<float,pair<float,float>>>>p;\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                float frac=(float)arr[i]/(float)arr[j];\\n               \\n               p.push({frac,{arr[i],arr[j]}});\\n            }\\n           \\n        }\\n       \\n          k-=1;\\n            while(k--){\\n              p.pop();\\n            }\\n            ans.push_back(p.top().second.first);\\n            ans.push_back(p.top().second.second);\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989796,
                "title": "easy-c-sorting-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        sort(arr.begin(),arr.end());\\n          int sz=arr.size();\\n          vector<pair<double,pair<int,int>>>v;\\n            for(int i=0;i<sz;i++){\\n              for(int j=i+1;j<sz;j++)\\n                {\\n                  double val=(arr[i]*1.0)/arr[j];\\n                    v.push_back({{val},{arr[i],arr[j]}});\\n                \\n                }\\n                }\\n                sort(v.begin(),v.end());\\n             //   for(auto it:v)\\n               //  cout<<it.second.first<<\" \"<<it.second.second<<endl;\\n                auto p=v[k-1];\\n                int st=p.second.first;\\n                int ed=p.second.second;\\n                vector<int>res;\\n                res={st,ed};\\n                return res;\\n            }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        sort(arr.begin(),arr.end());\\n          int sz=arr.size();\\n          vector<pair<double,pair<int,int>>>v;\\n            for(int i=0;i<sz;i++){\\n              for(int j=i+1;j<sz;j++)\\n                {\\n                  double val=(arr[i]*1.0)/arr[j];\\n                    v.push_back({{val},{arr[i],arr[j]}});\\n                \\n                }\\n                }\\n                sort(v.begin(),v.end());\\n             //   for(auto it:v)\\n               //  cout<<it.second.first<<\" \"<<it.second.second<<endl;\\n                auto p=v[k-1];\\n                int st=p.second.first;\\n                int ed=p.second.second;\\n                vector<int>res;\\n                res={st,ed};\\n                return res;\\n            }\\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3975189,
                "title": "easy-c-solution-using-max-heap-easy-to-understand-optimised-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<pair<double,pair<int,int>>, vector<pair<double,pair<int,int>>>, greater<pair<double, pair<int,int>>>>pq;\\n        for(int i=0;i<arr.size()-1;i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                double frac = (double)arr[i]/arr[j];\\n                pq.push({frac,{arr[i],arr[j]}});\\n            }\\n        }\\n        int a1;\\n        int a2;\\n        while(k--){\\n            a1 = pq.top().second.first;\\n            a2 = pq.top().second.second;\\n            pq.pop();\\n        }\\n        return {a1,a2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<pair<double,pair<int,int>>, vector<pair<double,pair<int,int>>>, greater<pair<double, pair<int,int>>>>pq;\\n        for(int i=0;i<arr.size()-1;i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                double frac = (double)arr[i]/arr[j];\\n                pq.push({frac,{arr[i],arr[j]}});\\n            }\\n        }\\n        int a1;\\n        int a2;\\n        while(k--){\\n            a1 = pq.top().second.first;\\n            a2 = pq.top().second.second;\\n            pq.pop();\\n        }\\n        return {a1,a2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975181,
                "title": "easy-c-solution-using-min-heap-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<pair<double,pair<int,int>>, vector<pair<double,pair<int,int>>>, greater<pair<double, pair<int,int>>>>pq;\\n        for(int i=0;i<arr.size()-1;i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                double frac = (double)arr[i]/arr[j];\\n                pq.push({frac,{arr[i],arr[j]}});\\n            }\\n        }\\n        int a1;\\n        int a2;\\n        while(k--){\\n            a1 = pq.top().second.first;\\n            a2 = pq.top().second.second;\\n            pq.pop();\\n        }\\n        return {a1,a2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<pair<double,pair<int,int>>, vector<pair<double,pair<int,int>>>, greater<pair<double, pair<int,int>>>>pq;\\n        for(int i=0;i<arr.size()-1;i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                double frac = (double)arr[i]/arr[j];\\n                pq.push({frac,{arr[i],arr[j]}});\\n            }\\n        }\\n        int a1;\\n        int a2;\\n        while(k--){\\n            a1 = pq.top().second.first;\\n            a2 = pq.top().second.second;\\n            pq.pop();\\n        }\\n        return {a1,a2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952683,
                "title": "beginner-method-brute-force-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst we try to get all the fraction corresponding to there arr[i] and arr[j].And in such a way that if we sort the fraction values our corresponding arr[i] and arr[j] got sorted.\\nFrom the sorted array we can find our kth smallest fraction and there corresponding arr[i] and arr[j].\\n# Complexity\\n- **Time complexity**: O(n*n)\\n- **Space complexity**:O(n*n)\\n- where n is the size of the arr.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) \\n    {\\n        int n=arr.size();\\n        vector<pair<double,pair<int,int> > >v;\\n        for(int i=0;i<n-1;i++) \\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                double x=(double)arr[i]/(double)arr[j];\\n                v.push_back({x,{arr[i],arr[j]}});\\n            }\\n        }   \\n        sort(v.begin(),v.end());\\n        vector<int> ans(2);\\n        ans[0]=v[k-1].second.first;\\n        ans[1]=v[k-1].second.second;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) \\n    {\\n        int n=arr.size();\\n        vector<pair<double,pair<int,int> > >v;\\n        for(int i=0;i<n-1;i++) \\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                double x=(double)arr[i]/(double)arr[j];\\n                v.push_back({x,{arr[i],arr[j]}});\\n            }\\n        }   \\n        sort(v.begin(),v.end());\\n        vector<int> ans(2);\\n        ans[0]=v[k-1].second.first;\\n        ans[1]=v[k-1].second.second;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947724,
                "title": "java-solution-priorityqueue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class Node{\\n        int up;\\n        int down;\\n        double value; \\n        public Node(int up, int down, double value){\\n            this.up = up;\\n            this.down = down;\\n            this.value = value;\\n        }\\n    }\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        int[] result = new int[2];\\n        PriorityQueue<Node> minHeap = new PriorityQueue<>(new Comparator<Node>(){\\n            public int compare(Node a, Node b){\\n                if(a.value == b.value){\\n                    return 0;\\n                }\\n                return a.value < b.value ? -1 : 1;\\n            }\\n        });\\n        int count = 0;\\n        for(int i = 0; i < arr.length; i++){\\n            for(int j = i + 1; j < arr.length; j++){\\n                minHeap.offer(new Node(arr[i], arr[j], (double) arr[i] / arr[j]));\\n            }\\n        }\\n        while(!minHeap.isEmpty()){\\n            Node current = minHeap.poll();\\n            count++;\\n            if(count == k){\\n                result[0] = current.up;\\n                result[1] = current.down;\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Node{\\n        int up;\\n        int down;\\n        double value; \\n        public Node(int up, int down, double value){\\n            this.up = up;\\n            this.down = down;\\n            this.value = value;\\n        }\\n    }\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        int[] result = new int[2];\\n        PriorityQueue<Node> minHeap = new PriorityQueue<>(new Comparator<Node>(){\\n            public int compare(Node a, Node b){\\n                if(a.value == b.value){\\n                    return 0;\\n                }\\n                return a.value < b.value ? -1 : 1;\\n            }\\n        });\\n        int count = 0;\\n        for(int i = 0; i < arr.length; i++){\\n            for(int j = i + 1; j < arr.length; j++){\\n                minHeap.offer(new Node(arr[i], arr[j], (double) arr[i] / arr[j]));\\n            }\\n        }\\n        while(!minHeap.isEmpty()){\\n            Node current = minHeap.poll();\\n            count++;\\n            if(count == k){\\n                result[0] = current.up;\\n                result[1] = current.down;\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941012,
                "title": "best-java-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(\\n            (a, b) -> {\\n                double x = a[0] / (1.0 * a[1]);\\n                double y = b[0] / (1.0 * b[1]);\\n                return x > y? -1 : 1;\\n            }\\n        );\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            for (int j = i + 1; j < arr.length; j++) {\\n                pq.add(new int[] {arr[i], arr[j]});\\n                if (pq.size() > k) {\\n                    pq.remove();\\n                }\\n            }\\n        }\\n\\n        return pq.remove();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(\\n            (a, b) -> {\\n                double x = a[0] / (1.0 * a[1]);\\n                double y = b[0] / (1.0 * b[1]);\\n                return x > y? -1 : 1;\\n            }\\n        );\\n\\n        for (int i = 0; i < arr.length; i++) {\\n            for (int j = i + 1; j < arr.length; j++) {\\n                pq.add(new int[] {arr[i], arr[j]});\\n                if (pq.size() > k) {\\n                    pq.remove();\\n                }\\n            }\\n        }\\n\\n        return pq.remove();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937954,
                "title": "c-solution-using-priority-queue-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        priority_queue<pair<double,pair<int,int>>> pq;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                double x=(double)arr[i]/arr[j];\\n                if(pq.size()==k)\\n                {\\n                    if(x<pq.top().first)\\n                    {\\n                        pq.pop();\\n                        pq.push({x,{arr[i],arr[j]}});\\n                    }\\n                }\\n                else\\n                {\\n                    pq.push({x,{arr[i],arr[j]}});\\n                }\\n\\n            }\\n        }\\n        return {pq.top().second.first,pq.top().second.second};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        priority_queue<pair<double,pair<int,int>>> pq;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                double x=(double)arr[i]/arr[j];\\n                if(pq.size()==k)\\n                {\\n                    if(x<pq.top().first)\\n                    {\\n                        pq.pop();\\n                        pq.push({x,{arr[i],arr[j]}});\\n                    }\\n                }\\n                else\\n                {\\n                    pq.push({x,{arr[i],arr[j]}});\\n                }\\n\\n            }\\n        }\\n        return {pq.top().second.first,pq.top().second.second};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930417,
                "title": "python-heap-with-explanation",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def kthSmallestPrimeFraction(self, arr, k):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        \\'\\'\\'we will be using min heap to  solve our question \\nthought it can be even done using max heap\\'\\'\\'\\n        heap = []\\n\\n\\'\\'\\'running two for loops, the outer one run from 0 to len(nums)-1 \\nand the inner one goes from i + 1 to then end of the array\\'\\'\\'\\n        for i in range(len(arr)-1):\\n            for j in range(i+1,len(arr)):\\n                numerator = float(arr[i])\\n                denominator = float(arr[j])\\n#diving every pair and storing the result in the heap, \\n#in heap we are pasing an array whose first element \\n#(element at 0th index) is the result of division and the second \\n#element is the array which contains the number\\n                result = float(numerator/denominator)\\n                heapq.heappush(heap, [result,[arr[i],arr[j]]])\\n#the heap will automatically sort itself based on  the result vaue\\n#given to it\\n\\n#finally we call a function heapq.nsmallest(k,heap) which gives \\n#us an array of k smallest number in the heap from the top, then\\n#we take the last element  of the heap as that is our answer and\\n#from that we take the last element which cotains the pair of\\n#number which we are looking for\\n        return heapq.nsmallest(k, heap)[-1][-1]\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def kthSmallestPrimeFraction(self, arr, k):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        \\'\\'\\'we will be using min heap to  solve our question \\nthought it can be even done using max heap\\'\\'\\'\\n        heap = []\\n\\n\\'\\'\\'running two for loops, the outer one run from 0 to len(nums)-1 \\nand the inner one goes from i + 1 to then end of the array\\'\\'\\'\\n        for i in range(len(arr)-1):\\n            for j in range(i+1,len(arr)):\\n                numerator = float(arr[i])\\n                denominator = float(arr[j])\\n#diving every pair and storing the result in the heap, \\n#in heap we are pasing an array whose first element \\n#(element at 0th index) is the result of division and the second \\n#element is the array which contains the number\\n                result = float(numerator/denominator)\\n                heapq.heappush(heap, [result,[arr[i],arr[j]]])\\n#the heap will automatically sort itself based on  the result vaue\\n#given to it\\n\\n#finally we call a function heapq.nsmallest(k,heap) which gives \\n#us an array of k smallest number in the heap from the top, then\\n#we take the last element  of the heap as that is our answer and\\n#from that we take the last element which cotains the pair of\\n#number which we are looking for\\n        return heapq.nsmallest(k, heap)[-1][-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903672,
                "title": "priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<pair<double,pair<int,int>>>pq;\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                double n1=arr[i];\\n                double n2=arr[j];\\n                double d=n1/n2;\\n                if(pq.size()<k){\\n                    pq.push({d,{arr[i],arr[j]}});\\n                }\\n                else if(pq.top().second.first*arr[j]>pq.top().second.second*arr[i]){\\n                    pq.pop();\\n                    pq.push({d,{arr[i],arr[j]}});\\n                }\\n            }\\n        }\\n        vector<int>v(2,0);\\n        v[0]=pq.top().second.first;\\n        v[1]=pq.top().second.second;\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<pair<double,pair<int,int>>>pq;\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                double n1=arr[i];\\n                double n2=arr[j];\\n                double d=n1/n2;\\n                if(pq.size()<k){\\n                    pq.push({d,{arr[i],arr[j]}});\\n                }\\n                else if(pq.top().second.first*arr[j]>pq.top().second.second*arr[i]){\\n                    pq.pop();\\n                    pq.push({d,{arr[i],arr[j]}});\\n                }\\n            }\\n        }\\n        vector<int>v(2,0);\\n        v[0]=pq.top().second.first;\\n        v[1]=pq.top().second.second;\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892249,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Answer {\\n    double val;\\n    List<int> res;\\n\\n    Answer(this.val, this.res);\\n}\\n\\nclass Solution {\\n  List<int> kthSmallestPrimeFraction(List<int> arr, int k) {\\n      final List<Answer> ans = [];\\n      for (int i = 0; i < arr.length; i++) {\\n          for (int j = i + 1; j < arr.length; j++) {\\n              ans.add(Answer(arr[i]/arr[j], [arr[i], arr[j]]));\\n          }\\n      }\\n      ans.sort((a, b) {\\n          return a.val.compareTo(b.val);\\n      });\\n      return ans[k - 1].res;\\n  }\\n\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\n\\nclass Answer {\\n    double val;\\n    List<int> res;\\n\\n    Answer(this.val, this.res);\\n}\\n\\nclass Solution {\\n  List<int> kthSmallestPrimeFraction(List<int> arr, int k) {\\n      final List<Answer> ans = [];\\n      for (int i = 0; i < arr.length; i++) {\\n          for (int j = i + 1; j < arr.length; j++) {\\n              ans.add(Answer(arr[i]/arr[j], [arr[i], arr[j]]));\\n          }\\n      }\\n      ans.sort((a, b) {\\n          return a.val.compareTo(b.val);\\n      });\\n      return ans[k - 1].res;\\n  }\\n\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882307,
                "title": "shortest-simplest-pq-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate pairs and put them in priority queue.\\ngrow it till k then pop if exceeds.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- O(n\\\\*n*log(n))\\n- Space complexity:\\n- O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<pair<double,pair<int,int>>> pq;\\n\\n\\n        for(int i = 0; i < arr.size(); i++) {\\n            for(int j = i+1; j < arr.size(); j++) {\\n                \\n                pq.push({ (1.00*arr[i])/arr[j], {arr[i],arr[j]} });\\n\\n                if (pq.size() > k)\\n                    pq.pop();\\n            }\\n        }\\n\\n        return {pq.top().second.first, pq.top().second.second};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<pair<double,pair<int,int>>> pq;\\n\\n\\n        for(int i = 0; i < arr.size(); i++) {\\n            for(int j = i+1; j < arr.size(); j++) {\\n                \\n                pq.push({ (1.00*arr[i])/arr[j], {arr[i],arr[j]} });\\n\\n                if (pq.size() > k)\\n                    pq.pop();\\n            }\\n        }\\n\\n        return {pq.top().second.first, pq.top().second.second};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864972,
                "title": "python-2-lines",
                "content": "# Intuition\\nSince k can be N*N-1, it looks like the solution is O(N^2)\\n\\n# Approach\\nBuild array of all possible pairs, sort it and return k-th item.\\n\\n# Complexity\\n- Time complexity:\\nO(N * N * log(N))\\n\\n- Space complexity:\\nO(N * N)\\n\\n# Code\\n```\\n    B = [ (a,b) for a in arr for b in arr if a != b ]\\n    return sorted(B, key=lambda x: x[0]/x[1])[k-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    B = [ (a,b) for a in arr for b in arr if a != b ]\\n    return sorted(B, key=lambda x: x[0]/x[1])[k-1]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3846599,
                "title": "rust-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n*n*log(n*n))$$ \\n\\n- Space complexity:\\n$$O(n*n)$$\\n\\n# Code\\n```\\nimpl Solution {\\n  pub fn kth_smallest_prime_fraction(arr: Vec<i32>, k: i32) -> Vec<i32> {\\n    let mut memo = vec![];\\n    let n = arr.len();\\n    for i in 0..n {\\n      for j in i+1..n {\\n        memo.push((arr[i],arr[j]));\\n      }\\n    }\\n\\n    memo.sort_by(|a,b| {\\n      let v1 = a.0 * b.1;\\n      let v2 = a.1 * b.0;\\n      v1.cmp(&v2)\\n    });\\n\\n    vec![memo[k as usize -1].0, memo[k as usize - 1].1]\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn kth_smallest_prime_fraction(arr: Vec<i32>, k: i32) -> Vec<i32> {\\n    let mut memo = vec![];\\n    let n = arr.len();\\n    for i in 0..n {\\n      for j in i+1..n {\\n        memo.push((arr[i],arr[j]));\\n      }\\n    }\\n\\n    memo.sort_by(|a,b| {\\n      let v1 = a.0 * b.1;\\n      let v2 = a.1 * b.0;\\n      v1.cmp(&v2)\\n    });\\n\\n    vec![memo[k as usize -1].0, memo[k as usize - 1].1]\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3826542,
                "title": "binary-search-easy-to-understand",
                "content": "# Intuition\\nA binary search solution that is easy to understand.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countLess(vector<int>& arr, float target){\\n        int n=arr.size();\\n        int c=0;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                double v = (arr[i]*1.0)/(arr[j]*1.0);\\n                if(fabs(v-target) < 0.000001 || target>v){\\n                    c=c+(n-j);\\n                    break;\\n                }\\n                //if v>target, j move continue\\n            }\\n        }\\n        return c;\\n    }\\n\\n    vector<int> findLeftClosest(vector<int>& a, float t){\\n        int n=a.size();\\n        int c=0;\\n        int ri=0,rj=0;\\n        double pv=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                double v = (a[i]*1.0)/(a[j]*1.0);\\n                if(fabs(v-t) < 0.000001){\\n                    return {a[i],a[j]};\\n                }\\n                if(t>v){\\n                    if(v>pv){\\n                        //only updates records when subesequent value is \\n                        //more close to the previous one\\n                        ri=i;\\n                        rj=j;\\n                        pv=v;\\n                    }\\n                    break;\\n                }\\n                //if v>target, j continue move\\n            }\\n        }\\n        return {a[ri],a[rj]};\\n    }\\n\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        //searching space 0 to n-1\\n        float L=0.0;\\n        float R=1.0;\\n        float cm=0;\\n        \\n        while(L<R){\\n            float m = (L+R)/2.0;\\n            //how many values are less than m\\n            int cv = countLess(arr, m);\\n            if(cv==k){\\n                cm=m;\\n                break;\\n            }else if(cv<k){\\n                L=m;\\n            }else{\\n                //cv>k\\n                R=m;\\n            }\\n        }\\n\\n        //find the left closest value according to the cm value\\n        return findLeftClosest(arr,cm);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countLess(vector<int>& arr, float target){\\n        int n=arr.size();\\n        int c=0;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                double v = (arr[i]*1.0)/(arr[j]*1.0);\\n                if(fabs(v-target) < 0.000001 || target>v){\\n                    c=c+(n-j);\\n                    break;\\n                }\\n                //if v>target, j move continue\\n            }\\n        }\\n        return c;\\n    }\\n\\n    vector<int> findLeftClosest(vector<int>& a, float t){\\n        int n=a.size();\\n        int c=0;\\n        int ri=0,rj=0;\\n        double pv=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                double v = (a[i]*1.0)/(a[j]*1.0);\\n                if(fabs(v-t) < 0.000001){\\n                    return {a[i],a[j]};\\n                }\\n                if(t>v){\\n                    if(v>pv){\\n                        //only updates records when subesequent value is \\n                        //more close to the previous one\\n                        ri=i;\\n                        rj=j;\\n                        pv=v;\\n                    }\\n                    break;\\n                }\\n                //if v>target, j continue move\\n            }\\n        }\\n        return {a[ri],a[rj]};\\n    }\\n\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        //searching space 0 to n-1\\n        float L=0.0;\\n        float R=1.0;\\n        float cm=0;\\n        \\n        while(L<R){\\n            float m = (L+R)/2.0;\\n            //how many values are less than m\\n            int cv = countLess(arr, m);\\n            if(cv==k){\\n                cm=m;\\n                break;\\n            }else if(cv<k){\\n                L=m;\\n            }else{\\n                //cv>k\\n                R=m;\\n            }\\n        }\\n\\n        //find the left closest value according to the cm value\\n        return findLeftClosest(arr,cm);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779339,
                "title": "using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        vector<int>ans; \\n        priority_queue<pair<double,pair<int,int>>>pq; \\n        int n=arr.size(); \\n        for(int i=0;i<n;i++) \\n        {\\n            for(int j=i+1;j<n;j++) \\n            {\\n                pq.push({arr[i]/(arr[j]*1.0),{arr[i],arr[j]}});\\n            }\\n        } \\n        int t=(pq.size()-k); \\n        while(t--) \\n        pq.pop(); \\n        ans.push_back(pq.top().second.first); \\n        ans.push_back(pq.top().second.second);  \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        vector<int>ans; \\n        priority_queue<pair<double,pair<int,int>>>pq; \\n        int n=arr.size(); \\n        for(int i=0;i<n;i++) \\n        {\\n            for(int j=i+1;j<n;j++) \\n            {\\n                pq.push({arr[i]/(arr[j]*1.0),{arr[i],arr[j]}});\\n            }\\n        } \\n        int t=(pq.size()-k); \\n        while(t--) \\n        pq.pop(); \\n        ans.push_back(pq.top().second.first); \\n        ans.push_back(pq.top().second.second);  \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769279,
                "title": "brute-force-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n\\n        priority_queue<pair<double,pair<int,int>>,vector<pair<double,pair<int,int>>>,greater<pair<double,pair<int,int>>>> pq;\\n        int n = arr.size();\\n    for(int i=0;i<n;i++){\\n        for(int j=0;j<n;j++){\\n            if(i!=j){\\n                double store = (double)arr[i]/arr[j];\\n                pq.push(make_pair(store,make_pair(arr[i],arr[j])));\\n            }\\n        }\\n    }\\n    k--;\\n    while(k--){\\n        pq.pop();\\n    }\\n    vector<int> v(2,0);\\n    v[0] = pq.top().second.first;\\n    v[1] = pq.top().second.second;\\n    return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n\\n        priority_queue<pair<double,pair<int,int>>,vector<pair<double,pair<int,int>>>,greater<pair<double,pair<int,int>>>> pq;\\n        int n = arr.size();\\n    for(int i=0;i<n;i++){\\n        for(int j=0;j<n;j++){\\n            if(i!=j){\\n                double store = (double)arr[i]/arr[j];\\n                pq.push(make_pair(store,make_pair(arr[i],arr[j])));\\n            }\\n        }\\n    }\\n    k--;\\n    while(k--){\\n        pq.pop();\\n    }\\n    vector<int> v(2,0);\\n    v[0] = pq.top().second.first;\\n    v[1] = pq.top().second.second;\\n    return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711850,
                "title": "python-sort-with-lambda-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        size = len(arr)\\n        temp_list = []\\n        for i in range(size):\\n            for j in range(i+1, size):\\n                temp_list.append([arr[i], arr[j]])\\n        \\n        temp_list = sorted(temp_list, key=lambda arr:arr[0]/arr[1])\\n        return temp_list[k-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        size = len(arr)\\n        temp_list = []\\n        for i in range(size):\\n            for j in range(i+1, size):\\n                temp_list.append([arr[i], arr[j]])\\n        \\n        temp_list = sorted(temp_list, key=lambda arr:arr[0]/arr[1])\\n        return temp_list[k-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696774,
                "title": "easy-to-understand-using-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<pair<float,pair<int,int>>>pq;\\n\\n\\n        for(int i=0;i<arr.size();i++)\\n        {\\n          for(int j=i+1;j<arr.size();j++)\\n          {\\n            float a=arr[i];\\n            float b=arr[j];\\n            float val=a/b;\\n            pq.push({val,{a,b}});\\n            if(pq.size()>k)pq.pop();\\n          }\\n        }\\n        return {pq.top().second.first,pq.top().second.second};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<pair<float,pair<int,int>>>pq;\\n\\n\\n        for(int i=0;i<arr.size();i++)\\n        {\\n          for(int j=i+1;j<arr.size();j++)\\n          {\\n            float a=arr[i];\\n            float b=arr[j];\\n            float val=a/b;\\n            pq.push({val,{a,b}});\\n            if(pq.size()>k)pq.pop();\\n          }\\n        }\\n        return {pq.top().second.first,pq.top().second.second};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693809,
                "title": "brute-force-approach-in-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMap stores its indexes as in sorted order\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        map<double,pair<int,int> > m;\\n\\n        for(int i=0;i<arr.size(); i++){\\n           for(int j=i+1; j<arr.size(); j++)\\n    m[double(arr[i])/double(arr[j])]=make_pair(arr[i],arr[j]);\\n        }\\n     \\n    for(auto p: m){\\n            if(k == 1)\\n             return {p.second.first,p.second.second};\\n             k--;\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        map<double,pair<int,int> > m;\\n\\n        for(int i=0;i<arr.size(); i++){\\n           for(int j=i+1; j<arr.size(); j++)\\n    m[double(arr[i])/double(arr[j])]=make_pair(arr[i],arr[j]);\\n        }\\n     \\n    for(auto p: m){\\n            if(k == 1)\\n             return {p.second.first,p.second.second};\\n             k--;\\n        }\\n        return {-1,-1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689362,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N + KlogK)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        n = len(arr)\\n        heap = []\\n        for i in range(n - 1):\\n            heap.append((arr[i] / arr[n - 1] , i , n - 1 ))\\n        heapq.heapify(heap)\\n        while k and heap:\\n            _ , i , j = heapq.heappop(heap)\\n            if i <  j - 1: \\n                heapq.heappush(heap , (arr[i] / arr[j - 1], i , j  - 1))\\n            k-=1\\n        return [arr[i] , arr[j]]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        n = len(arr)\\n        heap = []\\n        for i in range(n - 1):\\n            heap.append((arr[i] / arr[n - 1] , i , n - 1 ))\\n        heapq.heapify(heap)\\n        while k and heap:\\n            _ , i , j = heapq.heappop(heap)\\n            if i <  j - 1: \\n                heapq.heappush(heap , (arr[i] / arr[j - 1], i , j  - 1))\\n            k-=1\\n        return [arr[i] , arr[j]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689021,
                "title": "kth-smallest-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log(n) + N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        \\n        int n = arr.length;\\n\\n        double low = 0.0;\\n        double high = 1.0;\\n        while(low < high){\\n\\n            double mid = (low+high)/2;\\n\\n            int[] position = getFractionLessThanMid(arr, k, n, mid);\\n            if(position[0] == k){\\n                return new int[] {arr[position[1]], arr[position[2]]};\\n            }else if(position[0] > k){\\n                high = mid;\\n            }else{\\n                low = mid;\\n            }\\n        }\\n        return new int[2];\\n    }\\n\\n    private int[] getFractionLessThanMid(int[] arr, int k, int n, double mid){\\n        double max = 0.0d;\\n        \\n        int p =0, q =0;\\n\\n        int total = 0;\\n        for(int i=0, j=1;i<n-1;i++){\\n            while(j<n && arr[i]>(arr[j]*mid)){\\n                j++;\\n            }\\n            if(j==n) break;\\n\\n            total+= (n-j);\\n\\n            double fraction = (double) arr[i]/ (double) arr[j];\\n            if(fraction>max){\\n                max = fraction;\\n                p =i;\\n                 q= j;\\n            }\\n        }\\n\\n        return new int[]{total, p, q};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        \\n        int n = arr.length;\\n\\n        double low = 0.0;\\n        double high = 1.0;\\n        while(low < high){\\n\\n            double mid = (low+high)/2;\\n\\n            int[] position = getFractionLessThanMid(arr, k, n, mid);\\n            if(position[0] == k){\\n                return new int[] {arr[position[1]], arr[position[2]]};\\n            }else if(position[0] > k){\\n                high = mid;\\n            }else{\\n                low = mid;\\n            }\\n        }\\n        return new int[2];\\n    }\\n\\n    private int[] getFractionLessThanMid(int[] arr, int k, int n, double mid){\\n        double max = 0.0d;\\n        \\n        int p =0, q =0;\\n\\n        int total = 0;\\n        for(int i=0, j=1;i<n-1;i++){\\n            while(j<n && arr[i]>(arr[j]*mid)){\\n                j++;\\n            }\\n            if(j==n) break;\\n\\n            total+= (n-j);\\n\\n            double fraction = (double) arr[i]/ (double) arr[j];\\n            if(fraction>max){\\n                max = fraction;\\n                p =i;\\n                 q= j;\\n            }\\n        }\\n\\n        return new int[]{total, p, q};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687581,
                "title": "c-easy-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& nums, int k) {\\n    map<double,pair<int,int>> mp;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n        for(int j=i+1;j<nums.size();j++){\\n            if(nums[i]%nums[j]!=0)\\n            {\\n                double p=nums[i],q=nums[j];\\n                mp[(double)(p/q)]={nums[i],nums[j]};\\n            }\\n        }\\n    }\\n    int u=0;\\n    for(auto it:mp){\\n        u++;\\n        if(u==k)\\n        {\\n            return {mp[it.first].first,mp[it.first].second};\\n        }\\n    }    \\n    return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& nums, int k) {\\n    map<double,pair<int,int>> mp;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n        for(int j=i+1;j<nums.size();j++){\\n            if(nums[i]%nums[j]!=0)\\n            {\\n                double p=nums[i],q=nums[j];\\n                mp[(double)(p/q)]={nums[i],nums[j]};\\n            }\\n        }\\n    }\\n    int u=0;\\n    for(auto it:mp){\\n        u++;\\n        if(u==k)\\n        {\\n            return {mp[it.first].first,mp[it.first].second};\\n        }\\n    }    \\n    return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668757,
                "title": "easy-c-solution-max-heap-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        \\n\\n        priority_queue<pair<double, pair<int,int>>>pq;\\n\\n        int n=arr.size();\\n\\n        for(int i=0;i<n-1;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                pq.push({((double)arr[i]/arr[j]), {arr[i],arr[j]}});\\n\\n                if(pq.size()>k)\\n                {\\n                    pq.pop();\\n                }\\n            }\\n        }\\n\\n        vector<int>ans;\\n\\n        //return {pq.top().second.first,pq.top().second.second };\\n        ans.push_back(pq.top().second.first);\\n        ans.push_back(pq.top().second.second);\\n        \\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        \\n\\n        priority_queue<pair<double, pair<int,int>>>pq;\\n\\n        int n=arr.size();\\n\\n        for(int i=0;i<n-1;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                pq.push({((double)arr[i]/arr[j]), {arr[i],arr[j]}});\\n\\n                if(pq.size()>k)\\n                {\\n                    pq.pop();\\n                }\\n            }\\n        }\\n\\n        vector<int>ans;\\n\\n        //return {pq.top().second.first,pq.top().second.second };\\n        ans.push_back(pq.top().second.first);\\n        ans.push_back(pq.top().second.second);\\n        \\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663194,
                "title": "easy-to-understand-priority-queue-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        map<double,pair<int,int>> mp;\\n        priority_queue<double> pq;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            for(int j=i;j<arr.size();j++)\\n            {\\n                double frac=(double)arr[i]/arr[j];\\n                mp.insert({frac,{arr[i],arr[j]}});\\n                pq.push(frac);\\n                if(pq.size()>k) pq.pop();\\n            }\\n        } \\n        double res=pq.top();\\n        pair<int,int> pr=mp[res];\\n        vector<int> ans;\\n        ans.push_back(pr.first);\\n        ans.push_back(pr.second);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        map<double,pair<int,int>> mp;\\n        priority_queue<double> pq;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            for(int j=i;j<arr.size();j++)\\n            {\\n                double frac=(double)arr[i]/arr[j];\\n                mp.insert({frac,{arr[i],arr[j]}});\\n                pq.push(frac);\\n                if(pq.size()>k) pq.pop();\\n            }\\n        } \\n        double res=pq.top();\\n        pair<int,int> pr=mp[res];\\n        vector<int> ans;\\n        ans.push_back(pr.first);\\n        ans.push_back(pr.second);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660386,
                "title": "easy-c-using-priority-queue-pair-float-pair-int-int",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n\\n        priority_queue<pair<float,pair<int,int>> , vector<pair<float,pair<int,int>>>, greater<pair<float,pair<int,int>>> > p;\\n \\n    // Insertion of elements\\n    //p1.push(make_pair(4, 5));\\n\\n        for(int i=0;i<arr.size()-1;i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                p.push(make_pair((float(arr[i])/float(arr[j])),make_pair(arr[i],arr[j])));\\n\\n            }\\n        }\\n\\n        while(k-1){\\n            p.pop();\\n            k--;\\n        }\\n\\n        pair<float,pair<int,int>>ans=p.top();\\n\\n        return {ans.second.first,ans.second.second};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n\\n        priority_queue<pair<float,pair<int,int>> , vector<pair<float,pair<int,int>>>, greater<pair<float,pair<int,int>>> > p;\\n \\n    // Insertion of elements\\n    //p1.push(make_pair(4, 5));\\n\\n        for(int i=0;i<arr.size()-1;i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                p.push(make_pair((float(arr[i])/float(arr[j])),make_pair(arr[i],arr[j])));\\n\\n            }\\n        }\\n\\n        while(k-1){\\n            p.pop();\\n            k--;\\n        }\\n\\n        pair<float,pair<int,int>>ans=p.top();\\n\\n        return {ans.second.first,ans.second.second};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642564,
                "title": "c-o-2n-logn-2-binary-search-without-floating-point-numbers",
                "content": "Consider the TC: [1, 2, 3, 5],\\n![image](https://assets.leetcode.com/users/images/da8a8780-893e-4e9e-affe-25ef0012cc65_1686848808.2155418.png)\\n\\nIn the above matrix, all possible fractions are arranged in non-increasing order across the rows and non-decreasing order down the columns.\\n\\nKeeping this in mind, the rank of any fraction can be determined in O(NlogN) time.\\nFor each fraction considered, divide the fraction with each fraction having 1 as its numerator to obtain a factor.\\nThe closest prime greater than that factor tells you how many fractions in a column are lesser than the fraction considered.\\n\\nOnce you have the rank you can sift through the matrix in O(2logN) time leaving you with a total time complexity of O(2N * (logN)^2).\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> get_candidate(vector<int>& arr, vector<int>& low, vector<int>& high) {\\n        const int N = arr.size();\\n        int i;\\n        for(i = 1; i < N; i++)\\n            if(low[i] <= high[i])\\n                return vector<int>{arr[low[i]++], arr[i]};\\n        return {-1, -1};\\n    }\\n    \\n    int get_count(vector<int>& arr, vector<int>& frac, vector<int>& temp) {\\n        const int N = arr.size();\\n        int i, x, res = 0;\\n        for(i = 1; i < N; i++) {\\n            x = frac[0] * arr[i] / frac[1] + 1;\\n            auto it = lower_bound(arr.begin(), arr.end(), x);\\n            temp[i] = min(i, (int) (it - arr.begin()));\\n            res += temp[i];\\n            // if(it != arr.end())\\n            //     cout<<frac[0]<<\"/\"<<frac[1]<<\" - \"<<x<<\" - \"<<(*it)<<\" - \"<<temp[i]<<endl;\\n        }\\n        return res;\\n    }\\n    \\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        const int N = arr.size();\\n        vector<int> low(N), high(N), temp(N), frac(2);\\n        int i, x;\\n        for(i = 1; i < N; i++) {\\n            low[i] = 0;\\n            high[i] = i - 1;\\n        }\\n        while(true) {\\n            frac = get_candidate(arr, low, high);\\n            x = get_count(arr, frac, temp);\\n            if(x < k) {\\n                for(i = 1; i < N; i++)\\n                    low[i] = max(low[i], temp[i]);\\n            }\\n            else if(x > k) {\\n                for(i = 1; i < N; i++)\\n                    high[i] = min(high[i], temp[i] - 1);\\n            }\\n            else return frac;\\n            // cout<<\"RES \"<<frac[0]<<\"/\"<<frac[1]<<\" - \" <<x<<\" - \"<<low[1]<<\" - \"<<high[1]<<\" - \"<<temp[1]<<endl;\\n        }\\n        return frac;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> get_candidate(vector<int>& arr, vector<int>& low, vector<int>& high) {\\n        const int N = arr.size();\\n        int i;\\n        for(i = 1; i < N; i++)\\n            if(low[i] <= high[i])\\n                return vector<int>{arr[low[i]++], arr[i]};\\n        return {-1, -1};\\n    }\\n    \\n    int get_count(vector<int>& arr, vector<int>& frac, vector<int>& temp) {\\n        const int N = arr.size();\\n        int i, x, res = 0;\\n        for(i = 1; i < N; i++) {\\n            x = frac[0] * arr[i] / frac[1] + 1;\\n            auto it = lower_bound(arr.begin(), arr.end(), x);\\n            temp[i] = min(i, (int) (it - arr.begin()));\\n            res += temp[i];\\n            // if(it != arr.end())\\n            //     cout<<frac[0]<<\"/\"<<frac[1]<<\" - \"<<x<<\" - \"<<(*it)<<\" - \"<<temp[i]<<endl;\\n        }\\n        return res;\\n    }\\n    \\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        const int N = arr.size();\\n        vector<int> low(N), high(N), temp(N), frac(2);\\n        int i, x;\\n        for(i = 1; i < N; i++) {\\n            low[i] = 0;\\n            high[i] = i - 1;\\n        }\\n        while(true) {\\n            frac = get_candidate(arr, low, high);\\n            x = get_count(arr, frac, temp);\\n            if(x < k) {\\n                for(i = 1; i < N; i++)\\n                    low[i] = max(low[i], temp[i]);\\n            }\\n            else if(x > k) {\\n                for(i = 1; i < N; i++)\\n                    high[i] = min(high[i], temp[i] - 1);\\n            }\\n            else return frac;\\n            // cout<<\"RES \"<<frac[0]<<\"/\"<<frac[1]<<\" - \" <<x<<\" - \"<<low[1]<<\" - \"<<high[1]<<\" - \"<<temp[1]<<endl;\\n        }\\n        return frac;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3637744,
                "title": "c-brute-force-o-n-2",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool compare(const pair<pair<int,int>,double> &a,const pair<pair<int,int>,double> &b){\\n        return a.second<b.second;\\n    }\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        vector<pair<pair<int,int>,double>> p;\\n        for(int i=0;i<arr.size();i++){\\n            pair<pair<int,int>,double> pp;\\n            for(int j=i+1;j<arr.size();j++){\\n                pp=make_pair(make_pair(arr[i],arr[j]),double(arr[i])/arr[j]);\\n                p.push_back(pp);\\n            }\\n        }\\n        // for(int i=0;i<p.size();i++)cout<<p[i].first.first<<p[i].first.second<<\" -> \"<<p[i].second<<endl;\\n        sort(p.begin(),p.end(),compare);\\n        return {p[k-1].first.first,p[k-1].first.second};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool compare(const pair<pair<int,int>,double> &a,const pair<pair<int,int>,double> &b){\\n        return a.second<b.second;\\n    }\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        vector<pair<pair<int,int>,double>> p;\\n        for(int i=0;i<arr.size();i++){\\n            pair<pair<int,int>,double> pp;\\n            for(int j=i+1;j<arr.size();j++){\\n                pp=make_pair(make_pair(arr[i],arr[j]),double(arr[i])/arr[j]);\\n                p.push_back(pp);\\n            }\\n        }\\n        // for(int i=0;i<p.size();i++)cout<<p[i].first.first<<p[i].first.second<<\" -> \"<<p[i].second<<endl;\\n        sort(p.begin(),p.end(),compare);\\n        return {p[k-1].first.first,p[k-1].first.second};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3615135,
                "title": "using-sorted-dictionary",
                "content": "# Intuition\\n\\n# Approach\\nbrute force \\n# Complexity\\n- Time complexity:\\nO(n*n)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] KthSmallestPrimeFraction(int[] arr, int k) {\\n        SortedDictionary<double, List<int>> ress = new SortedDictionary<double, List<int>>();\\n\\n            for (int i = 0; i < arr.Length; i++)\\n            {\\n                for (int j = i+1; j < arr.Length; j++)\\n                {\\n                    ress.Add((double)arr[i] / arr[j], new List<int> { arr[i], arr[j]});\\n                }\\n            }\\n\\n            return ress.ElementAt(k - 1).Value.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] KthSmallestPrimeFraction(int[] arr, int k) {\\n        SortedDictionary<double, List<int>> ress = new SortedDictionary<double, List<int>>();\\n\\n            for (int i = 0; i < arr.Length; i++)\\n            {\\n                for (int j = i+1; j < arr.Length; j++)\\n                {\\n                    ress.Add((double)arr[i] / arr[j], new List<int> { arr[i], arr[j]});\\n                }\\n            }\\n\\n            return ress.ElementAt(k - 1).Value.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606217,
                "title": "c-solution-using-priority-queue-faster-and-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        priority_queue<pair<double,pair<int,int>>> pq;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                double x = arr[i]/(arr[j]*1.0);\\n                \\n                if(pq.size() == k){\\n                    if(x < pq.top().first){\\n                        pq.pop();\\n                        pq.push({x,{arr[i],arr[j]}});\\n                    }\\n                }\\n                else{\\n                    pq.push({x,{arr[i],arr[j]}});\\n                }\\n            }\\n        }\\n\\n        return {pq.top().second.first,pq.top().second.second};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        int n = arr.size();\\n        priority_queue<pair<double,pair<int,int>>> pq;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                double x = arr[i]/(arr[j]*1.0);\\n                \\n                if(pq.size() == k){\\n                    if(x < pq.top().first){\\n                        pq.pop();\\n                        pq.push({x,{arr[i],arr[j]}});\\n                    }\\n                }\\n                else{\\n                    pq.push({x,{arr[i],arr[j]}});\\n                }\\n            }\\n        }\\n\\n        return {pq.top().second.first,pq.top().second.second};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603967,
                "title": "easy-understandable-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        vector<vector<int>> vec;\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                vector<int>vec1;\\n                vec1.push_back(arr[i]);\\n                vec1.push_back(arr[j]);\\n                vec.push_back(vec1);                \\n            }\\n        }\\n        int n2=vec.size();\\n        vector<double>arr1;\\n        vector<int> vec1;\\n        for(int i=0;i<n2;i++){\\n            arr1.push_back((double)(vec[i][0])/(double)(vec[i][1]));\\n        }\\n        sort(arr1.begin(),arr1.end());\\n        for(int i=0;i<n2;i++){\\n            double tot=(double)(vec[i][0])/(double)(vec[i][1]);\\n            if(tot==arr1[k-1]){\\n                vec1.push_back(vec[i][0]);\\n                vec1.push_back(vec[i][1]);\\n                break;\\n            }\\n        }\\n        return vec1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        vector<vector<int>> vec;\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                vector<int>vec1;\\n                vec1.push_back(arr[i]);\\n                vec1.push_back(arr[j]);\\n                vec.push_back(vec1);                \\n            }\\n        }\\n        int n2=vec.size();\\n        vector<double>arr1;\\n        vector<int> vec1;\\n        for(int i=0;i<n2;i++){\\n            arr1.push_back((double)(vec[i][0])/(double)(vec[i][1]));\\n        }\\n        sort(arr1.begin(),arr1.end());\\n        for(int i=0;i<n2;i++){\\n            double tot=(double)(vec[i][0])/(double)(vec[i][1]);\\n            if(tot==arr1[k-1]){\\n                vec1.push_back(vec[i][0]);\\n                vec1.push_back(vec[i][1]);\\n                break;\\n            }\\n        }\\n        return vec1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596880,
                "title": "c-solution-using-max-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf the Problem states that about Kth element,Nth Element then the Intution may go to the Priority Queue. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPriority Queue is the Data Structure.but the datatype was a big problem. Here I created `pair<double,pair<int,int>>>` because Queue allowed only one datatype in it not like Map.\\n\\n`Double` for the `Divided value` of `2 numbers`\\n`Pair` stores the `Two Pair of Values `\\n\\n# Complexity\\n- Time complexity: O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(NlogN)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n\\tvector<int>ans;\\n\\tpriority_queue<pair<double,pair<int,int>>>q;\\n\\t\\n\\tfor(int i=0;i<arr.size();i++){\\n\\t\\tfor(int j=i+1;j<arr.size();j++){\\n            //Here i used (double),because the \\n            //arr[i] and arr[j] are int types\\n\\t\\t    double val = (double)arr[i]/arr[j];\\n\\t\\t    q.push({val,{arr[i],arr[j]}});\\n\\t\\t}\\n\\t}\\n\\t\\n\\tint i=0,first,second;\\n    //I used Max heap so i subtracted \\n    //the total length og q with k and + 1\\n\\tint end = q.size()-k;\\n\\twhile(i<end+1){\\n\\t\\tfirst = q.top().second.first;\\n\\t\\tsecond = q.top().second.second;\\n\\t\\tq.pop();\\n\\t\\ti++;\\n\\t}\\n\\tans.push_back(first);\\n\\tans.push_back(second);\\n    return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n\\tvector<int>ans;\\n\\tpriority_queue<pair<double,pair<int,int>>>q;\\n\\t\\n\\tfor(int i=0;i<arr.size();i++){\\n\\t\\tfor(int j=i+1;j<arr.size();j++){\\n            //Here i used (double),because the \\n            //arr[i] and arr[j] are int types\\n\\t\\t    double val = (double)arr[i]/arr[j];\\n\\t\\t    q.push({val,{arr[i],arr[j]}});\\n\\t\\t}\\n\\t}\\n\\t\\n\\tint i=0,first,second;\\n    //I used Max heap so i subtracted \\n    //the total length og q with k and + 1\\n\\tint end = q.size()-k;\\n\\twhile(i<end+1){\\n\\t\\tfirst = q.top().second.first;\\n\\t\\tsecond = q.top().second.second;\\n\\t\\tq.pop();\\n\\t\\ti++;\\n\\t}\\n\\tans.push_back(first);\\n\\tans.push_back(second);\\n    return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582219,
                "title": "easy-c-using-priority-queue-must-try",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<pair<float,pair<int,int>>> maxh;\\n        for(int i=0;i<arr.size()-1;i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                maxh.push({(float)arr[i]/arr[j],{arr[i],arr[j]}});\\n                if(maxh.size()>k){\\n                    maxh.pop();\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        ans.push_back(maxh.top().second.first);\\n        ans.push_back(maxh.top().second.second);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<pair<float,pair<int,int>>> maxh;\\n        for(int i=0;i<arr.size()-1;i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                maxh.push({(float)arr[i]/arr[j],{arr[i],arr[j]}});\\n                if(maxh.size()>k){\\n                    maxh.pop();\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        ans.push_back(maxh.top().second.first);\\n        ans.push_back(maxh.top().second.second);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578883,
                "title": "k-th-smallest-prime-fraction",
                "content": "---------------- beats 100% ----------------\\n\\n# Code\\n```\\nclass Solution {\\npublic int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n    int n = arr.length;\\n\\n    double low = arr[0] / (double)arr[n - 1];\\n    double high = 1;\\n\\n    while (low < high) {\\n      double mid = (low + high) / 2;\\n\\n      int count[] = f(arr, mid);\\n\\n      if (k < count[0]) {\\n        high = mid;\\n      } else if (k > count[0]) {\\n        low = mid;\\n      } else {\\n        return new int[] {count[1], count[2]};\\n      }\\n    }\\n    return null;\\n  }\\n\\n  static int[] f(int arr[], double target) {\\n    int count = 0;\\n    int i = 0;\\n    int n = arr.length;\\n    int num = arr[0], deno = arr[n - 1];\\n\\n    for (int j = 1; j<n; j++) {\\n      while (arr[i] <= arr[j]*target) {\\n        i++;\\n      }\\n      count += i;\\n      if (i > 0 && arr[i - 1]*deno > num * arr[j]) {\\n        num = arr[i - 1];\\n        deno = arr[j];\\n      }\\n    }\\n    return new int[] {count, num, deno};\\n  }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n    int n = arr.length;\\n\\n    double low = arr[0] / (double)arr[n - 1];\\n    double high = 1;\\n\\n    while (low < high) {\\n      double mid = (low + high) / 2;\\n\\n      int count[] = f(arr, mid);\\n\\n      if (k < count[0]) {\\n        high = mid;\\n      } else if (k > count[0]) {\\n        low = mid;\\n      } else {\\n        return new int[] {count[1], count[2]};\\n      }\\n    }\\n    return null;\\n  }\\n\\n  static int[] f(int arr[], double target) {\\n    int count = 0;\\n    int i = 0;\\n    int n = arr.length;\\n    int num = arr[0], deno = arr[n - 1];\\n\\n    for (int j = 1; j<n; j++) {\\n      while (arr[i] <= arr[j]*target) {\\n        i++;\\n      }\\n      count += i;\\n      if (i > 0 && arr[i - 1]*deno > num * arr[j]) {\\n        num = arr[i - 1];\\n        deno = arr[j];\\n      }\\n    }\\n    return new int[] {count, num, deno};\\n  }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578575,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        double result = 0;\\n        priority_queue<pair<double, pair<int, int>>, vector<pair<double, pair<int, int>>>, greater<pair<double, pair<int, int>>>> pq; \\n        for(int i=0; i<arr.size(); i++){\\n            for(int j=i+1; j<arr.size(); j++){\\n                pq.push(make_pair((double) arr[i]/ (double) arr[j], make_pair(arr[i], arr[j])));\\n            }\\n        }\\n        int i = 1;\\n        while(i < k){\\n            pq.pop();\\n            i++;\\n        }\\n        pair<double, pair<int, int>> temp = pq.top(); \\n        pair<int, int>p = temp.second;\\n        return {p.first, p.second};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        double result = 0;\\n        priority_queue<pair<double, pair<int, int>>, vector<pair<double, pair<int, int>>>, greater<pair<double, pair<int, int>>>> pq; \\n        for(int i=0; i<arr.size(); i++){\\n            for(int j=i+1; j<arr.size(); j++){\\n                pq.push(make_pair((double) arr[i]/ (double) arr[j], make_pair(arr[i], arr[j])));\\n            }\\n        }\\n        int i = 1;\\n        while(i < k){\\n            pq.pop();\\n            i++;\\n        }\\n        pair<double, pair<int, int>> temp = pq.top(); \\n        pair<int, int>p = temp.second;\\n        return {p.first, p.second};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578200,
                "title": "simple-cpp-code-with-max-heap",
                "content": "\\n# Code\\n```\\ntypedef pair<float, pair<int, int>> t;\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<t> maxh;\\n        for (int i=0; i<arr.size(); i++)\\n        {\\n            for (int j=i+1; j<arr.size(); j++)\\n            {\\n                maxh.push({(float)arr[i]/(float)arr[j], {arr[i], arr[j]}});\\n                if (maxh.size()>k)\\n                {\\n                    maxh.pop();\\n                }\\n            }\\n        }\\n\\n        vector<int> ans;\\n\\n        ans = {maxh.top().second.first, maxh.top().second.second};\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntypedef pair<float, pair<int, int>> t;\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<t> maxh;\\n        for (int i=0; i<arr.size(); i++)\\n        {\\n            for (int j=i+1; j<arr.size(); j++)\\n            {\\n                maxh.push({(float)arr[i]/(float)arr[j], {arr[i], arr[j]}});\\n                if (maxh.size()>k)\\n                {\\n                    maxh.pop();\\n                }\\n            }\\n        }\\n\\n        vector<int> ans;\\n\\n        ans = {maxh.top().second.first, maxh.top().second.second};\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568951,
                "title": "easy-c-code-priority-queue-of-double-division-and-pair-of-both-no-min-heap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<pair<double,pair<int,int>>,vector<pair<double,pair<int,int>>>,greater<pair<double,pair<int,int>>> >p;\\n        int size=arr.size();\\n        for(int i=0;i<size-1;i++){\\n            for(int j=i+1;j<size;j++){\\n                p.push({double(arr[i])/double(arr[j]),{arr[i],arr[j]}});\\n            }\\n        }\\n        while(k>1){\\n            p.pop();\\n            k--;\\n        }\\n        vector<int> v={p.top().second.first,p.top().second.second};\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<pair<double,pair<int,int>>,vector<pair<double,pair<int,int>>>,greater<pair<double,pair<int,int>>> >p;\\n        int size=arr.size();\\n        for(int i=0;i<size-1;i++){\\n            for(int j=i+1;j<size;j++){\\n                p.push({double(arr[i])/double(arr[j]),{arr[i],arr[j]}});\\n            }\\n        }\\n        while(k>1){\\n            p.pop();\\n            k--;\\n        }\\n        vector<int> v={p.top().second.first,p.top().second.second};\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554900,
                "title": "almost-working-c-solution",
                "content": "# Code\\n```\\nnamespace std {\\n    template<>\\n    struct hash<pair<int, int>>\\n    {\\n        std::size_t operator()(const pair<int, int>& s) const noexcept\\n        {\\n            std::size_t h1 = std::hash<int>{}(s.first);\\n            std::size_t h2 = std::hash<int>{}(s.second);\\n            return h1 ^ (h2 << 1);\\n        }\\n    };\\n}\\n    \\nclass Solution {\\npublic:\\n    struct IndexedNumber {\\n        int index;\\n        int value;\\n    };\\n\\n    typedef pair<IndexedNumber, IndexedNumber> IndexedFraction;\\n\\n    struct Cmp {\\n        bool operator()(const IndexedFraction& a, const IndexedFraction& b) const {\\n            double afrac = (double)a.first.value / a.second.value;\\n            double bfrac = (double)b.first.value / b.second.value;\\n            return afrac > bfrac; \\n        }\\n    };\\n\\n\\n\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        if (arr.size() <= 1) {\\n            return {};\\n        }\\n\\n        priority_queue<IndexedFraction, vector<IndexedFraction>, Cmp> values;\\n        set<pair<int, int>> seen;\\n\\n        values.push(pair(IndexedNumber{0, arr[0]}, IndexedNumber{(int)arr.size()-1, arr[(int)arr.size()-1]}));\\n        seen.insert(pair(0, (int)arr.size()-1));\\n\\n        vector<int> ans;\\n        for (int i = 0; i < k && !values.empty(); ++i) {\\n            auto frac = values.top();\\n            values.pop();\\n\\n\\n            ans = vector<int>{frac.first.value, frac.second.value};\\n\\n            if (frac.first.index + 1 < frac.second.index) {\\n                auto index_pair = pair(frac.first.index+1, frac.second.index);\\n                if (seen.find(index_pair) == seen.end()) {\\n                    auto num = IndexedNumber{frac.first.index+1, arr[frac.first.index+1]};\\n                    auto den = frac.second;\\n\\n                    values.push(pair(num, den));\\n                    seen.insert(index_pair);\\n                }\\n            }\\n            if (frac.second.index - 1 > frac.first.index) {\\n                auto index_pair = pair(frac.first.index, frac.second.index-1);\\n                if (seen.find(index_pair) == seen.end()) {\\n                    auto num = frac.first;\\n                    auto den = IndexedNumber{frac.second.index-1, arr[frac.second.index-1]};\\n\\n                    values.push(pair(num, den));\\n                    seen.insert(index_pair);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nnamespace std {\\n    template<>\\n    struct hash<pair<int, int>>\\n    {\\n        std::size_t operator()(const pair<int, int>& s) const noexcept\\n        {\\n            std::size_t h1 = std::hash<int>{}(s.first);\\n            std::size_t h2 = std::hash<int>{}(s.second);\\n            return h1 ^ (h2 << 1);\\n        }\\n    };\\n}\\n    \\nclass Solution {\\npublic:\\n    struct IndexedNumber {\\n        int index;\\n        int value;\\n    };\\n\\n    typedef pair<IndexedNumber, IndexedNumber> IndexedFraction;\\n\\n    struct Cmp {\\n        bool operator()(const IndexedFraction& a, const IndexedFraction& b) const {\\n            double afrac = (double)a.first.value / a.second.value;\\n            double bfrac = (double)b.first.value / b.second.value;\\n            return afrac > bfrac; \\n        }\\n    };\\n\\n\\n\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        if (arr.size() <= 1) {\\n            return {};\\n        }\\n\\n        priority_queue<IndexedFraction, vector<IndexedFraction>, Cmp> values;\\n        set<pair<int, int>> seen;\\n\\n        values.push(pair(IndexedNumber{0, arr[0]}, IndexedNumber{(int)arr.size()-1, arr[(int)arr.size()-1]}));\\n        seen.insert(pair(0, (int)arr.size()-1));\\n\\n        vector<int> ans;\\n        for (int i = 0; i < k && !values.empty(); ++i) {\\n            auto frac = values.top();\\n            values.pop();\\n\\n\\n            ans = vector<int>{frac.first.value, frac.second.value};\\n\\n            if (frac.first.index + 1 < frac.second.index) {\\n                auto index_pair = pair(frac.first.index+1, frac.second.index);\\n                if (seen.find(index_pair) == seen.end()) {\\n                    auto num = IndexedNumber{frac.first.index+1, arr[frac.first.index+1]};\\n                    auto den = frac.second;\\n\\n                    values.push(pair(num, den));\\n                    seen.insert(index_pair);\\n                }\\n            }\\n            if (frac.second.index - 1 > frac.first.index) {\\n                auto index_pair = pair(frac.first.index, frac.second.index-1);\\n                if (seen.find(index_pair) == seen.end()) {\\n                    auto num = frac.first;\\n                    auto den = IndexedNumber{frac.second.index-1, arr[frac.second.index-1]};\\n\\n                    values.push(pair(num, den));\\n                    seen.insert(index_pair);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546255,
                "title": "kth-smallest-fraction-in-java",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo find the kth smallest fraction interate over the given array and store each of the fraction along with its numerator and denominator and then sort the 2d array along the coloumn and return the numerator and denominator from the sorted 2d array\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        List<List<Double>> l=new ArrayList<>();\\n        for(int i=0;i<arr.length-1;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                List<Double> l1=new ArrayList<>();\\n                // double d= arr[i]/arr[j];\\n                l1.add((double)arr[i]/(double)arr[j]);\\n                l1.add((double)arr[i]);\\n                l1.add((double)arr[j]);\\n                l.add(l1);\\n            }\\n        }\\n        Collections.sort(l, new Comparator<List<Double>>() {\\n        @Override\\n            public int compare(List<Double> o1, List<Double> o2) {\\n                try {\\n                    return o1.get(0).compareTo(o2.get(0));\\n                    // return Double.compare((double)o1.get(0),(double)o2.get(0));\\n                } catch (NullPointerException e) {\\n                    return 0;\\n                }\\n            }\\n        });\\n        \\n        int[] arr1={l.get(k-1).get(1).intValue(),(int)l.get(k-1).get(2).intValue()};\\n        return arr1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        List<List<Double>> l=new ArrayList<>();\\n        for(int i=0;i<arr.length-1;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                List<Double> l1=new ArrayList<>();\\n                // double d= arr[i]/arr[j];\\n                l1.add((double)arr[i]/(double)arr[j]);\\n                l1.add((double)arr[i]);\\n                l1.add((double)arr[j]);\\n                l.add(l1);\\n            }\\n        }\\n        Collections.sort(l, new Comparator<List<Double>>() {\\n        @Override\\n            public int compare(List<Double> o1, List<Double> o2) {\\n                try {\\n                    return o1.get(0).compareTo(o2.get(0));\\n                    // return Double.compare((double)o1.get(0),(double)o2.get(0));\\n                } catch (NullPointerException e) {\\n                    return 0;\\n                }\\n            }\\n        });\\n        \\n        int[] arr1={l.get(k-1).get(1).intValue(),(int)l.get(k-1).get(2).intValue()};\\n        return arr1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542377,
                "title": "brute-force-c-using-set",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        set<pair<double,pair<long long,long >>>s;\\n        int n=arr.size();\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                double calc=(double)arr[i]/(double)arr[j];\\n                s.insert({calc,{arr[i],arr[j]}});\\n            }\\n        }\\n        auto kk=next(s.begin(),k-1);\\n        vector<int>ans;\\n        ans.push_back(kk->second.first);\\n        ans.push_back(kk->second.second);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        set<pair<double,pair<long long,long >>>s;\\n        int n=arr.size();\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                double calc=(double)arr[i]/(double)arr[j];\\n                s.insert({calc,{arr[i],arr[j]}});\\n            }\\n        }\\n        auto kk=next(s.begin(),k-1);\\n        vector<int>ans;\\n        ans.push_back(kk->second.first);\\n        ans.push_back(kk->second.second);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541751,
                "title": "max-heap-brute-force-approach-7-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        priority_queue<pair<double,pair<int,int>>> pq;  \\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){ \\n                pq.push({(double)arr[i]/arr[j],{arr[i],arr[j]}});\\n                if(pq.size()>k) pq.pop();\\n            }\\n        } \\n        return {pq.top().second.first,pq.top().second.second};\\n\\n    }\\n};\\n\\n\\n//please upvote \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        int n=arr.size();\\n        priority_queue<pair<double,pair<int,int>>> pq;  \\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){ \\n                pq.push({(double)arr[i]/arr[j],{arr[i],arr[j]}});\\n                if(pq.size()>k) pq.pop();\\n            }\\n        } \\n        return {pq.top().second.first,pq.top().second.second};\\n\\n    }\\n};\\n\\n\\n//please upvote \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541495,
                "title": "easiest-solution-using-hashmap",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        map<double,vector<int>> mp;\\n        int n=arr.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(arr[j]>arr[i]){\\n                    mp[double(arr[i])/double(arr[j])]={arr[i],arr[j]};\\n                }else{\\n                    break;\\n                }\\n            }\\n        }\\n        int c=1;\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            if(c==k){\\n                return it->second;\\n            }\\n            c++;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        map<double,vector<int>> mp;\\n        int n=arr.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(arr[j]>arr[i]){\\n                    mp[double(arr[i])/double(arr[j])]={arr[i],arr[j]};\\n                }else{\\n                    break;\\n                }\\n            }\\n        }\\n        int c=1;\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            if(c==k){\\n                return it->second;\\n            }\\n            c++;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540646,
                "title": "simple-and-easy",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<pair<double,pair<int,int>>,vector<pair<double,pair<int,int>>>,greater<> > p;\\n        int n=arr.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                p.push({(1.0*arr[i])/arr[j],{arr[i],arr[j]}});\\n            }\\n        }\\n        for(int i=1;i<k;i++){\\n            p.pop();\\n        }\\n        int a=p.top().second.first;\\n        int b=p.top().second.second;\\n        return {a,b};\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<pair<double,pair<int,int>>,vector<pair<double,pair<int,int>>>,greater<> > p;\\n        int n=arr.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                p.push({(1.0*arr[i])/arr[j],{arr[i],arr[j]}});\\n            }\\n        }\\n        for(int i=1;i<k;i++){\\n            p.pop();\\n        }\\n        int a=p.top().second.first;\\n        int b=p.top().second.second;\\n        return {a,b};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523868,
                "title": "solve-using-max-priority-queue-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) \\n    {\\n        priority_queue<pair<double,pair<int,int>>>p;\\n\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            for(int j=i+1;j<arr.size();j++)\\n            {\\n                double a=(double)arr[i]/arr[j];\\n\\n               \\n                p.push({a,{arr[i],arr[j]}});\\n\\n                if(p.size()>k)\\n                p.pop();\\n\\n            }\\n        }\\n        vector<int>ans;\\n\\n        //    int a=p.size()-k;\\n        // while(a!=1)\\n        // {\\n        //     cout<<p.top().first<<\" (\"<<p.top().second.first<<\",\"<<p.top().second.second<<\")\"<<endl;\\n        //     p.pop();\\n        //     a--;\\n        // }\\n\\n        ans.push_back(p.top().second.first);\\n        ans.push_back(p.top().second.second);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) \\n    {\\n        priority_queue<pair<double,pair<int,int>>>p;\\n\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            for(int j=i+1;j<arr.size();j++)\\n            {\\n                double a=(double)arr[i]/arr[j];\\n\\n               \\n                p.push({a,{arr[i],arr[j]}});\\n\\n                if(p.size()>k)\\n                p.pop();\\n\\n            }\\n        }\\n        vector<int>ans;\\n\\n        //    int a=p.size()-k;\\n        // while(a!=1)\\n        // {\\n        //     cout<<p.top().first<<\" (\"<<p.top().second.first<<\",\"<<p.top().second.second<<\")\"<<endl;\\n        //     p.pop();\\n        //     a--;\\n        // }\\n\\n        ans.push_back(p.top().second.first);\\n        ans.push_back(p.top().second.second);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3460902,
                "title": "python3-simple-heap-using-floating-point-numbers",
                "content": "# Intuition\\nThe range of the numbers was such that I didn\\'t think floating point inaccuracy would be a problem\\n\\n# Code\\n```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        seen = set()\\n        def gt(i, j):\\n            if j < 0:\\n                j += len(arr)\\n            if (i,j) in seen or j<=i:\\n                return (2.0, -1, -1)\\n            seen.add((i, j))\\n            return (arr[i] / arr[j], i, j)\\n        h = [gt(0, -1)]\\n\\n        c = 1\\n        while c < k:\\n            v, i, j = heappop(h)\\n            heappush(h, gt(i+1, j))\\n            heappush(h, gt(i, j-1))\\n            c += 1\\n        \\n        v, i, j = heappop(h)\\n        return [arr[i], arr[j]]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        seen = set()\\n        def gt(i, j):\\n            if j < 0:\\n                j += len(arr)\\n            if (i,j) in seen or j<=i:\\n                return (2.0, -1, -1)\\n            seen.add((i, j))\\n            return (arr[i] / arr[j], i, j)\\n        h = [gt(0, -1)]\\n\\n        c = 1\\n        while c < k:\\n            v, i, j = heappop(h)\\n            heappush(h, gt(i+1, j))\\n            heappush(h, gt(i, j-1))\\n            c += 1\\n        \\n        v, i, j = heappop(h)\\n        return [arr[i], arr[j]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432150,
                "title": "easy-and-unique-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n\\n        vector<int>v;\\n\\n        map<double,pair<int,int>>mp;\\n        priority_queue<double,vector<double>,greater<double>>pq;\\n\\n        int i = 0;\\n       while(i<arr.size()){\\n\\n            int j = i+1;\\n\\n           while(j<arr.size()){\\n                double l = arr[i];\\n                double m = arr[j];\\n\\n                double x = l/m;\\n                pq.push(x);\\n\\n                mp[x] = {arr[i],arr[j]};\\n                j++;\\n            }\\n           i++;\\n        }\\n        \\n\\n        double res = -1;\\n        while(k--){\\n\\n            res = pq.top();\\n           // cout<<res<<\"\\\\n\";\\n            pq.pop();\\n        }\\n        pair<int,int> it = mp[res];\\n\\n        v.push_back(it.first);\\n        v.push_back(it.second);\\n\\n        return v;\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n\\n        vector<int>v;\\n\\n        map<double,pair<int,int>>mp;\\n        priority_queue<double,vector<double>,greater<double>>pq;\\n\\n        int i = 0;\\n       while(i<arr.size()){\\n\\n            int j = i+1;\\n\\n           while(j<arr.size()){\\n                double l = arr[i];\\n                double m = arr[j];\\n\\n                double x = l/m;\\n                pq.push(x);\\n\\n                mp[x] = {arr[i],arr[j]};\\n                j++;\\n            }\\n           i++;\\n        }\\n        \\n\\n        double res = -1;\\n        while(k--){\\n\\n            res = pq.top();\\n           // cout<<res<<\"\\\\n\";\\n            pq.pop();\\n        }\\n        pair<int,int> it = mp[res];\\n\\n        v.push_back(it.first);\\n        v.push_back(it.second);\\n\\n        return v;\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3425003,
                "title": "easy-solution-using-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom fractions import Fraction\\n\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        n = len(arr)\\n        \\n        heap = [(arr[r]/arr[n-1], r, n-1) for r in range(n)]\\n        heapq.heapify(heap)\\n\\n        for _ in range(k-1):\\n            val, r, c = heapq.heappop(heap)\\n            if c :\\n                heapq.heappush(heap, (arr[r]/arr[c-1], r, c-1))\\n\\n        return arr[heap[0][1]], arr[heap[0][2]]\\n\\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom fractions import Fraction\\n\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        n = len(arr)\\n        \\n        heap = [(arr[r]/arr[n-1], r, n-1) for r in range(n)]\\n        heapq.heapify(heap)\\n\\n        for _ in range(k-1):\\n            val, r, c = heapq.heappop(heap)\\n            if c :\\n                heapq.heappush(heap, (arr[r]/arr[c-1], r, c-1))\\n\\n        return arr[heap[0][1]], arr[heap[0][2]]\\n\\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415763,
                "title": "simple-approach-priority-queue-java",
                "content": "# Code\\n```\\nclass Solution {\\n    //Pair class help for fetching result : {first , second}\\n    class Pair{\\n        double fractionVal;\\n        int firstVal;\\n        int secondVal;\\n        public Pair(double fractionVal , int firstVal , int secondVal){\\n            this.fractionVal = fractionVal;\\n            this.firstVal = firstVal;\\n            this.secondVal = secondVal;\\n        }\\n    }\\n    \\n    //Sorting priorityQueue in ascending order\\n    class FractionComparator implements Comparator<Pair>{\\n        public int compare(Pair a , Pair b){\\n            double fractionVal1 = a.fractionVal;\\n            double fractionVal2 = b.fractionVal;\\n            if(fractionVal1 < fractionVal2){\\n                return -1;\\n            }else if(fractionVal1 > fractionVal2){\\n                return 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n    }\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        int len = arr.length;\\n        PriorityQueue<Pair> minHeap = new PriorityQueue<>(new FractionComparator());\\n\\n        //put all (i < j) fraction value in priority queue\\n        for(int i = 0 ; i < len ; i++){\\n            int p = arr[i];\\n            for(int j = i + 1 ; j < len ; j++){\\n                int q = arr[j];\\n                double currFractionVal = (double) p / q;\\n                Pair newPair = new Pair(currFractionVal , p  , q);\\n                minHeap.add(newPair);\\n            }\\n        }\\n\\n        //remove k pairs from priority queue\\n        for(int i = 0; i < k - 1 ; i++){\\n            minHeap.poll();\\n        }\\n\\n        //fetch result\\n        Pair result = minHeap.peek();\\n        int firstVal = result.firstVal;\\n        int secondVal = result.secondVal;\\n        return new int[]{firstVal , secondVal};\\n    }\\n }\\n\\n    \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //Pair class help for fetching result : {first , second}\\n    class Pair{\\n        double fractionVal;\\n        int firstVal;\\n        int secondVal;\\n        public Pair(double fractionVal , int firstVal , int secondVal){\\n            this.fractionVal = fractionVal;\\n            this.firstVal = firstVal;\\n            this.secondVal = secondVal;\\n        }\\n    }\\n    \\n    //Sorting priorityQueue in ascending order\\n    class FractionComparator implements Comparator<Pair>{\\n        public int compare(Pair a , Pair b){\\n            double fractionVal1 = a.fractionVal;\\n            double fractionVal2 = b.fractionVal;\\n            if(fractionVal1 < fractionVal2){\\n                return -1;\\n            }else if(fractionVal1 > fractionVal2){\\n                return 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n    }\\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\\n        int len = arr.length;\\n        PriorityQueue<Pair> minHeap = new PriorityQueue<>(new FractionComparator());\\n\\n        //put all (i < j) fraction value in priority queue\\n        for(int i = 0 ; i < len ; i++){\\n            int p = arr[i];\\n            for(int j = i + 1 ; j < len ; j++){\\n                int q = arr[j];\\n                double currFractionVal = (double) p / q;\\n                Pair newPair = new Pair(currFractionVal , p  , q);\\n                minHeap.add(newPair);\\n            }\\n        }\\n\\n        //remove k pairs from priority queue\\n        for(int i = 0; i < k - 1 ; i++){\\n            minHeap.poll();\\n        }\\n\\n        //fetch result\\n        Pair result = minHeap.peek();\\n        int firstVal = result.firstVal;\\n        int secondVal = result.secondVal;\\n        return new int[]{firstVal , secondVal};\\n    }\\n }\\n\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395131,
                "title": "heap-solution-tc-o-n-2-log-k-and-o-n-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Approach 1:**\\n\\nSaare fraction daal do Max heap of size k mein with values of numerator and denominator.\\n\\n**Approach 2:**\\nFirst saare fractions daalo with denomination at n-1 th index in a min heap. Ab jo top element hai woh 1st smallest fraction hai. Ab next smallest fraction kaunsa hoga with same numerator -> denominator ka index reduce kardo ek se and push that fraction in minheap.\\n\\n# Code\\n```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        pq = []\\n\\n        n = len(arr)\\n\\n        for i in range(n):\\n            heappush(pq, [arr[i]/arr[n-1], [i, n-1]]) # adding all fraction with last denominator\\n\\n        while k > 1:\\n            top = heappop(pq) # 1st smallest number -> 2nd , 3rd ... kth\\n            deno = top[1][1]\\n            num = top[1][0]\\n            deno -= 1 # next smallest fraction after top\\n\\n            heappush(pq, [arr[num]/arr[deno], [num, deno]])\\n            k -= 1 # one least element mil gya\\n\\n        top = heappop(pq)\\n        num = top[1][0]\\n        deno = top[1][1]\\n        return [arr[num], arr[deno]]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        pq = []\\n\\n        n = len(arr)\\n\\n        for i in range(n):\\n            heappush(pq, [arr[i]/arr[n-1], [i, n-1]]) # adding all fraction with last denominator\\n\\n        while k > 1:\\n            top = heappop(pq) # 1st smallest number -> 2nd , 3rd ... kth\\n            deno = top[1][1]\\n            num = top[1][0]\\n            deno -= 1 # next smallest fraction after top\\n\\n            heappush(pq, [arr[num]/arr[deno], [num, deno]])\\n            k -= 1 # one least element mil gya\\n\\n        top = heappop(pq)\\n        num = top[1][0]\\n        deno = top[1][1]\\n        return [arr[num], arr[deno]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389702,
                "title": "python3-with-heap-queue",
                "content": "# Intuition\\n The smallest fraction result with index i (arr[i] in the numrator) is arr[i]/arr[n-1] as \\'arr\\' is sorted and the next smallest fraction with index i in numerator is arr[i]/arr[n-2] ... \\n\\n# Approach\\n1. Use heap queue to store arr[i]/arr[n-1] for i = 0 ... n-2 and corresponding indices (i, n-1)\\n2. Get the smallest indices from the heap and store possible next smallest indices: for (i, j) that means (i, j-1)\\n3.  Do (2) k times\\n# Complexity\\n- Time complexity:\\n<$$O(nlog(n))$$ for heap queue>\\n\\n- Space complexity:\\n<$$O(n)$$ for heap queue>\\n\\n# Code\\n```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        \\'\\'\\'       \\n        1. The smallest fraction with index i in numerator is arr[i]/arr[n-1] as arr is sorted\\n         and the next smallest fraction with index i in numerator is arr[i]/arr[n-2] ... \\n        2.  Use heap queue to get the smallest fraction and corresponding indices\\n        \\'\\'\\'\\n        hq, n = [], len(arr)\\n        for i in range(n-1):\\n            heapq.heappush(hq, (arr[i]/arr[n-1], i, n-1))\\n        _, i, j = heapq.heappop(hq)\\n        k -=1\\n        while k:\\n            if i < j-1:\\n                heapq.heappush(hq, (arr[i]/arr[j-1], i, j-1))            \\n            _, i, j = heapq.heappop(hq)\\n            k -=1\\n\\n        return [arr[i], arr[j]]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        \\'\\'\\'       \\n        1. The smallest fraction with index i in numerator is arr[i]/arr[n-1] as arr is sorted\\n         and the next smallest fraction with index i in numerator is arr[i]/arr[n-2] ... \\n        2.  Use heap queue to get the smallest fraction and corresponding indices\\n        \\'\\'\\'\\n        hq, n = [], len(arr)\\n        for i in range(n-1):\\n            heapq.heappush(hq, (arr[i]/arr[n-1], i, n-1))\\n        _, i, j = heapq.heappop(hq)\\n        k -=1\\n        while k:\\n            if i < j-1:\\n                heapq.heappush(hq, (arr[i]/arr[j-1], i, j-1))            \\n            _, i, j = heapq.heappop(hq)\\n            k -=1\\n\\n        return [arr[i], arr[j]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389080,
                "title": "easy-solution-simple-approach-vector",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe given solution uses a brute force approach to find all possible fractions using the given sorted integer array arr. It stores each fraction along with the corresponding values of arr[i] and arr[j] in a vector of pairs.\\n\\nTo compute the fraction, the solution uses typecasting to convert one of the operands to a double and then performs the division operation. This approach ensures that the decimal values of the fractions are sorted in ascending order.\\n\\nFinally, the solution returns the kth smallest fraction by accessing the k-1th element of the sorted vector and extracting the corresponding values of arr[i] and arr[j].\\n\\nThis approach has a time complexity of O(n^2 log n) due to the sorting of the vector of pairs. A more efficient approach would involve using a min-heap to maintain the k smallest fractions instead of sorting the entire vector. This would reduce the time complexity to O(n^2 log k).\\n\\n# Complexity\\n- Time complexity:\\nO(n^2 log n)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        vector<int>ans;\\n        // cout<< (double )1/3;\\n        vector<pair<double,pair<int,int>>> vec;\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                vec.push_back({(double)arr[i]/arr[j],{arr[i],arr[j]}});\\n            }\\n        }\\n        sort(vec.begin(),vec.end());\\n        ans.push_back(vec[k-1].second.first);\\n        ans.push_back(vec[k-1].second.second);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        vector<int>ans;\\n        // cout<< (double )1/3;\\n        vector<pair<double,pair<int,int>>> vec;\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                vec.push_back({(double)arr[i]/arr[j],{arr[i],arr[j]}});\\n            }\\n        }\\n        sort(vec.begin(),vec.end());\\n        ans.push_back(vec[k-1].second.first);\\n        ans.push_back(vec[k-1].second.second);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3381728,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<pair<float,pair<int,int>>>pq;\\n        int n=arr.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                    pq.push({(float)arr[i]/arr[j],{arr[i],arr[j]}});\\n                    if(pq.size()>k) pq.pop();\\n            }\\n        }\\n        return {pq.top().second.first,pq.top().second.second};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<pair<float,pair<int,int>>>pq;\\n        int n=arr.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                    pq.push({(float)arr[i]/arr[j],{arr[i],arr[j]}});\\n                    if(pq.size()>k) pq.pop();\\n            }\\n        }\\n        return {pq.top().second.first,pq.top().second.second};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378195,
                "title": "using-prioirty-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<pair<double      ,  pair<int  ,  int>>>  pq ;\\n        int i =  0 ; \\n        int j  =  arr.size() -1   ; \\n\\n        while ( i  <  arr.size() -1   ){\\n            \\n            pq.push({ static_cast<double>(arr[i])  / arr[j]  , { arr[i]  , arr[j]}} )  ; \\n            if  (  pq.size() >  k  ){\\n                pq.pop() ; \\n\\n            }\\n            j--  ;  \\n            if  (   j ==  i  ){\\n                j  =  arr.size() -  1  ; \\n                i  =  i  + 1     ; \\n                \\n            }\\n\\n\\n        } \\n        vector<int> ans ; \\n\\n        auto it  = pq.top() ; \\n        ans.push_back(it.second.first)  ; \\n        ans.push_back(it.second.second)  ; \\n        return ans ; \\n\\n        \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n        priority_queue<pair<double      ,  pair<int  ,  int>>>  pq ;\\n        int i =  0 ; \\n        int j  =  arr.size() -1   ; \\n\\n        while ( i  <  arr.size() -1   ){\\n            \\n            pq.push({ static_cast<double>(arr[i])  / arr[j]  , { arr[i]  , arr[j]}} )  ; \\n            if  (  pq.size() >  k  ){\\n                pq.pop() ; \\n\\n            }\\n            j--  ;  \\n            if  (   j ==  i  ){\\n                j  =  arr.size() -  1  ; \\n                i  =  i  + 1     ; \\n                \\n            }\\n\\n\\n        } \\n        vector<int> ans ; \\n\\n        auto it  = pq.top() ; \\n        ans.push_back(it.second.first)  ; \\n        ans.push_back(it.second.second)  ; \\n        return ans ; \\n\\n        \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372625,
                "title": "sorting-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) \\n    {\\n        int n=arr.size();\\n        vector<pair<double,pair<int,int>>> v;\\n        for(int x=0; x<n; x++)\\n        {\\n            for(int y=x+1; y<n; y++)\\n            {\\n                double f=(double)arr[x]/arr[y];\\n                v.push_back({f,{arr[x],arr[y]}});\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        vector<int> ans;\\n        ans={v[k-1].second.first,v[k-1].second.second};\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) \\n    {\\n        int n=arr.size();\\n        vector<pair<double,pair<int,int>>> v;\\n        for(int x=0; x<n; x++)\\n        {\\n            for(int y=x+1; y<n; y++)\\n            {\\n                double f=(double)arr[x]/arr[y];\\n                v.push_back({f,{arr[x],arr[y]}});\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        vector<int> ans;\\n        ans={v[k-1].second.first,v[k-1].second.second};\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343811,
                "title": "simple-python-solution-using-import-fractions-and-limit-denominator",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom fractions import Fraction\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        n=[]\\n        for i in range(len(arr)-1):\\n            for j in range(i+1,len(arr)):\\n                n.append(arr[i]/arr[j])\\n        n.sort()  \\n        a=n[k-1]\\n        a=Fraction(a).limit_denominator()    \\n        a=str(a).split(\\'/\\')\\n        return [int(a[0]),int(a[1])]\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom fractions import Fraction\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        n=[]\\n        for i in range(len(arr)-1):\\n            for j in range(i+1,len(arr)):\\n                n.append(arr[i]/arr[j])\\n        n.sort()  \\n        a=n[k-1]\\n        a=Fraction(a).limit_denominator()    \\n        a=str(a).split(\\'/\\')\\n        return [int(a[0]),int(a[1])]\\n        \\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566807,
                "content": [
                    {
                        "username": "devilhtc",
                        "content": "Should it be \nK will be between 1 and A.length * (A.length - 1) / 2.\ninstead of \nK will be between 1 and A.length * (A.length + 1) / 2.\nSince there are only A.length * (A.length - 1) / 2 pairs?\n"
                    },
                    {
                        "username": "jdsingh",
                        "content": "what is test case number 59?\\nmy code is giving tle but i am not able to view the given array in the test case 59"
                    },
                    {
                        "username": "8800AB",
                        "content": " Use min heap to get the minimum next fraction for each denominator out of all remaining and return the kth one by doing so.\n\nTo get the smallest each time(Hints):-\n1)Keep track of the next minimum fraction for each denominator into the heap.\n2)For this we may consider the initial state as -> (arr[0]/each denominator from index 1 till end) being the minimum fraction for each denominator.\n3)Once we popped the current minimum then the next minimum for that denominator will be what?\n\nIt will be the current numerator (of the popped) + 1 th indexed element \n\nAll this is possible since the array is sorted and has unique prime elements into it!!\nHope this helps ;)"
                    },
                    {
                        "username": "saikaushik003",
                        "content": "A straightforward strategy to tackle this challenge is to compute the fractions for each pair of numbers in the given list. By using a HashMap, we can store these fractions, associating them with the respective pairs. Subsequently, we sort the pairs based on their corresponding fraction values. Finally, we extract and return the k-th smallest fraction\\'s pair of numbers from the sorted list. This method revolves around generating fractions and then sorting them to identify the k-th smallest one."
                    },
                    {
                        "username": "Javid_Iqbal",
                        "content": "PLEASE ANY ONE TELL ME WHY THIS IS SHOWING TLE FOR LARGE TEST CASE\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n      //first push all keeping denominator same{1/7,2/7,3/7,5/7}\\n      // here we know that 1/7 is first smallest,pop from queue and decrease denominator and again push it compare with rest smallest fraction will come on top\\n      priority_queue<pair<double,pair<int,int>>,vector<pair<double,pair<int,int>>>,greater<pair<double,pair<int,int>>>>minheap;\\n      int n=arr.size();\\n      int den=arr[n-1];\\n      for(int i=0;i<n-1;i++){\\n          double frac=arr[i]/(den*1.0);\\n          minheap.push({frac,{i,n-1}});\\n      } \\n\\n      k--;\\n\\n            \\n        while(k&&!minheap.empty()){\\n            auto top=minheap.top();\\n            minheap.pop();\\n            int i=top.second.first;\\n            int j=top.second.second;\\n             j--;\\n            if(j>i){\\n                double frac=arr[i]/(arr[j]*1.0);\\n                     minheap.push({frac,{i,j}});\\n            }\\n            k--;\\n        }\\n         int a=arr[minheap.top().second.first];\\n         int b=arr[minheap.top().second.second];\\n        return {a,b};\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1899144,
                "content": [
                    {
                        "username": "devilhtc",
                        "content": "Should it be \nK will be between 1 and A.length * (A.length - 1) / 2.\ninstead of \nK will be between 1 and A.length * (A.length + 1) / 2.\nSince there are only A.length * (A.length - 1) / 2 pairs?\n"
                    },
                    {
                        "username": "jdsingh",
                        "content": "what is test case number 59?\\nmy code is giving tle but i am not able to view the given array in the test case 59"
                    },
                    {
                        "username": "8800AB",
                        "content": " Use min heap to get the minimum next fraction for each denominator out of all remaining and return the kth one by doing so.\n\nTo get the smallest each time(Hints):-\n1)Keep track of the next minimum fraction for each denominator into the heap.\n2)For this we may consider the initial state as -> (arr[0]/each denominator from index 1 till end) being the minimum fraction for each denominator.\n3)Once we popped the current minimum then the next minimum for that denominator will be what?\n\nIt will be the current numerator (of the popped) + 1 th indexed element \n\nAll this is possible since the array is sorted and has unique prime elements into it!!\nHope this helps ;)"
                    },
                    {
                        "username": "saikaushik003",
                        "content": "A straightforward strategy to tackle this challenge is to compute the fractions for each pair of numbers in the given list. By using a HashMap, we can store these fractions, associating them with the respective pairs. Subsequently, we sort the pairs based on their corresponding fraction values. Finally, we extract and return the k-th smallest fraction\\'s pair of numbers from the sorted list. This method revolves around generating fractions and then sorting them to identify the k-th smallest one."
                    },
                    {
                        "username": "Javid_Iqbal",
                        "content": "PLEASE ANY ONE TELL ME WHY THIS IS SHOWING TLE FOR LARGE TEST CASE\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n      //first push all keeping denominator same{1/7,2/7,3/7,5/7}\\n      // here we know that 1/7 is first smallest,pop from queue and decrease denominator and again push it compare with rest smallest fraction will come on top\\n      priority_queue<pair<double,pair<int,int>>,vector<pair<double,pair<int,int>>>,greater<pair<double,pair<int,int>>>>minheap;\\n      int n=arr.size();\\n      int den=arr[n-1];\\n      for(int i=0;i<n-1;i++){\\n          double frac=arr[i]/(den*1.0);\\n          minheap.push({frac,{i,n-1}});\\n      } \\n\\n      k--;\\n\\n            \\n        while(k&&!minheap.empty()){\\n            auto top=minheap.top();\\n            minheap.pop();\\n            int i=top.second.first;\\n            int j=top.second.second;\\n             j--;\\n            if(j>i){\\n                double frac=arr[i]/(arr[j]*1.0);\\n                     minheap.push({frac,{i,j}});\\n            }\\n            k--;\\n        }\\n         int a=arr[minheap.top().second.first];\\n         int b=arr[minheap.top().second.second];\\n        return {a,b};\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1786150,
                "content": [
                    {
                        "username": "devilhtc",
                        "content": "Should it be \nK will be between 1 and A.length * (A.length - 1) / 2.\ninstead of \nK will be between 1 and A.length * (A.length + 1) / 2.\nSince there are only A.length * (A.length - 1) / 2 pairs?\n"
                    },
                    {
                        "username": "jdsingh",
                        "content": "what is test case number 59?\\nmy code is giving tle but i am not able to view the given array in the test case 59"
                    },
                    {
                        "username": "8800AB",
                        "content": " Use min heap to get the minimum next fraction for each denominator out of all remaining and return the kth one by doing so.\n\nTo get the smallest each time(Hints):-\n1)Keep track of the next minimum fraction for each denominator into the heap.\n2)For this we may consider the initial state as -> (arr[0]/each denominator from index 1 till end) being the minimum fraction for each denominator.\n3)Once we popped the current minimum then the next minimum for that denominator will be what?\n\nIt will be the current numerator (of the popped) + 1 th indexed element \n\nAll this is possible since the array is sorted and has unique prime elements into it!!\nHope this helps ;)"
                    },
                    {
                        "username": "saikaushik003",
                        "content": "A straightforward strategy to tackle this challenge is to compute the fractions for each pair of numbers in the given list. By using a HashMap, we can store these fractions, associating them with the respective pairs. Subsequently, we sort the pairs based on their corresponding fraction values. Finally, we extract and return the k-th smallest fraction\\'s pair of numbers from the sorted list. This method revolves around generating fractions and then sorting them to identify the k-th smallest one."
                    },
                    {
                        "username": "Javid_Iqbal",
                        "content": "PLEASE ANY ONE TELL ME WHY THIS IS SHOWING TLE FOR LARGE TEST CASE\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n      //first push all keeping denominator same{1/7,2/7,3/7,5/7}\\n      // here we know that 1/7 is first smallest,pop from queue and decrease denominator and again push it compare with rest smallest fraction will come on top\\n      priority_queue<pair<double,pair<int,int>>,vector<pair<double,pair<int,int>>>,greater<pair<double,pair<int,int>>>>minheap;\\n      int n=arr.size();\\n      int den=arr[n-1];\\n      for(int i=0;i<n-1;i++){\\n          double frac=arr[i]/(den*1.0);\\n          minheap.push({frac,{i,n-1}});\\n      } \\n\\n      k--;\\n\\n            \\n        while(k&&!minheap.empty()){\\n            auto top=minheap.top();\\n            minheap.pop();\\n            int i=top.second.first;\\n            int j=top.second.second;\\n             j--;\\n            if(j>i){\\n                double frac=arr[i]/(arr[j]*1.0);\\n                     minheap.push({frac,{i,j}});\\n            }\\n            k--;\\n        }\\n         int a=arr[minheap.top().second.first];\\n         int b=arr[minheap.top().second.second];\\n        return {a,b};\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2036040,
                "content": [
                    {
                        "username": "devilhtc",
                        "content": "Should it be \nK will be between 1 and A.length * (A.length - 1) / 2.\ninstead of \nK will be between 1 and A.length * (A.length + 1) / 2.\nSince there are only A.length * (A.length - 1) / 2 pairs?\n"
                    },
                    {
                        "username": "jdsingh",
                        "content": "what is test case number 59?\\nmy code is giving tle but i am not able to view the given array in the test case 59"
                    },
                    {
                        "username": "8800AB",
                        "content": " Use min heap to get the minimum next fraction for each denominator out of all remaining and return the kth one by doing so.\n\nTo get the smallest each time(Hints):-\n1)Keep track of the next minimum fraction for each denominator into the heap.\n2)For this we may consider the initial state as -> (arr[0]/each denominator from index 1 till end) being the minimum fraction for each denominator.\n3)Once we popped the current minimum then the next minimum for that denominator will be what?\n\nIt will be the current numerator (of the popped) + 1 th indexed element \n\nAll this is possible since the array is sorted and has unique prime elements into it!!\nHope this helps ;)"
                    },
                    {
                        "username": "saikaushik003",
                        "content": "A straightforward strategy to tackle this challenge is to compute the fractions for each pair of numbers in the given list. By using a HashMap, we can store these fractions, associating them with the respective pairs. Subsequently, we sort the pairs based on their corresponding fraction values. Finally, we extract and return the k-th smallest fraction\\'s pair of numbers from the sorted list. This method revolves around generating fractions and then sorting them to identify the k-th smallest one."
                    },
                    {
                        "username": "Javid_Iqbal",
                        "content": "PLEASE ANY ONE TELL ME WHY THIS IS SHOWING TLE FOR LARGE TEST CASE\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n      //first push all keeping denominator same{1/7,2/7,3/7,5/7}\\n      // here we know that 1/7 is first smallest,pop from queue and decrease denominator and again push it compare with rest smallest fraction will come on top\\n      priority_queue<pair<double,pair<int,int>>,vector<pair<double,pair<int,int>>>,greater<pair<double,pair<int,int>>>>minheap;\\n      int n=arr.size();\\n      int den=arr[n-1];\\n      for(int i=0;i<n-1;i++){\\n          double frac=arr[i]/(den*1.0);\\n          minheap.push({frac,{i,n-1}});\\n      } \\n\\n      k--;\\n\\n            \\n        while(k&&!minheap.empty()){\\n            auto top=minheap.top();\\n            minheap.pop();\\n            int i=top.second.first;\\n            int j=top.second.second;\\n             j--;\\n            if(j>i){\\n                double frac=arr[i]/(arr[j]*1.0);\\n                     minheap.push({frac,{i,j}});\\n            }\\n            k--;\\n        }\\n         int a=arr[minheap.top().second.first];\\n         int b=arr[minheap.top().second.second];\\n        return {a,b};\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2016229,
                "content": [
                    {
                        "username": "devilhtc",
                        "content": "Should it be \nK will be between 1 and A.length * (A.length - 1) / 2.\ninstead of \nK will be between 1 and A.length * (A.length + 1) / 2.\nSince there are only A.length * (A.length - 1) / 2 pairs?\n"
                    },
                    {
                        "username": "jdsingh",
                        "content": "what is test case number 59?\\nmy code is giving tle but i am not able to view the given array in the test case 59"
                    },
                    {
                        "username": "8800AB",
                        "content": " Use min heap to get the minimum next fraction for each denominator out of all remaining and return the kth one by doing so.\n\nTo get the smallest each time(Hints):-\n1)Keep track of the next minimum fraction for each denominator into the heap.\n2)For this we may consider the initial state as -> (arr[0]/each denominator from index 1 till end) being the minimum fraction for each denominator.\n3)Once we popped the current minimum then the next minimum for that denominator will be what?\n\nIt will be the current numerator (of the popped) + 1 th indexed element \n\nAll this is possible since the array is sorted and has unique prime elements into it!!\nHope this helps ;)"
                    },
                    {
                        "username": "saikaushik003",
                        "content": "A straightforward strategy to tackle this challenge is to compute the fractions for each pair of numbers in the given list. By using a HashMap, we can store these fractions, associating them with the respective pairs. Subsequently, we sort the pairs based on their corresponding fraction values. Finally, we extract and return the k-th smallest fraction\\'s pair of numbers from the sorted list. This method revolves around generating fractions and then sorting them to identify the k-th smallest one."
                    },
                    {
                        "username": "Javid_Iqbal",
                        "content": "PLEASE ANY ONE TELL ME WHY THIS IS SHOWING TLE FOR LARGE TEST CASE\\nclass Solution {\\npublic:\\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {\\n      //first push all keeping denominator same{1/7,2/7,3/7,5/7}\\n      // here we know that 1/7 is first smallest,pop from queue and decrease denominator and again push it compare with rest smallest fraction will come on top\\n      priority_queue<pair<double,pair<int,int>>,vector<pair<double,pair<int,int>>>,greater<pair<double,pair<int,int>>>>minheap;\\n      int n=arr.size();\\n      int den=arr[n-1];\\n      for(int i=0;i<n-1;i++){\\n          double frac=arr[i]/(den*1.0);\\n          minheap.push({frac,{i,n-1}});\\n      } \\n\\n      k--;\\n\\n            \\n        while(k&&!minheap.empty()){\\n            auto top=minheap.top();\\n            minheap.pop();\\n            int i=top.second.first;\\n            int j=top.second.second;\\n             j--;\\n            if(j>i){\\n                double frac=arr[i]/(arr[j]*1.0);\\n                     minheap.push({frac,{i,j}});\\n            }\\n            k--;\\n        }\\n         int a=arr[minheap.top().second.first];\\n         int b=arr[minheap.top().second.second];\\n        return {a,b};\\n    }\\n};"
                    }
                ]
            }
        ]
    }
]