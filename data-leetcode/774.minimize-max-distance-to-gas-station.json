[
    {
        "title": "Integer Break",
        "question_content": "Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the product of those integers.\nReturn the maximum product you can get.\n&nbsp;\nExample 1:\n\nInput: n = 2\nOutput: 1\nExplanation: 2 = 1 + 1, 1 &times; 1 = 1.\n\nExample 2:\n\nInput: n = 10\nOutput: 36\nExplanation: 10 = 3 + 3 + 4, 3 &times; 3 &times; 4 = 36.\n\n&nbsp;\nConstraints:\n\n\t2 <= n <= 58",
        "solutions": [
            {
                "id": 80689,
                "title": "a-simple-explanation-of-the-math-part-and-a-o-n-solution",
                "content": "The first thing we should consider is : What is the max product if we break a number N into two factors?\\n\\nI use a function to express this product: f=x(N-x)\\n\\nWhen x=N/2, we get the maximum of this function.\\n\\nHowever, factors should be integers. Thus the maximum is (N/2)*(N/2) when N is even or (N-1)/2 *(N+1)/2 when N is odd.\\n\\nWhen the maximum of f is larger than N, we should do the break.\\n\\n(N/2)*(N/2)>=N, then N>=4\\n\\n(N-1)/2 *(N+1)/2>=N, then N>=5\\n\\nThese two expressions mean that factors should be less than 4, otherwise we can do the break and get a better product. The factors in last result should be 1, 2 or 3. Obviously, 1 should be abandoned. Thus, the factors of the perfect product should be 2 or 3.\\n\\nThe reason why we should use 3 as many as possible is \\n\\nFor 6, 3 * 3>2 * 2 * 2. Thus, the optimal product should contain no more than three 2. \\n\\nBelow is my accepted, O(N) solution.\\n\\n    public class Solution {\\n        public int integerBreak(int n) {\\n            if(n==2) return 1;\\n            if(n==3) return 2;\\n            int product = 1;\\n            while(n>4){\\n                product*=3;\\n                n-=3;\\n            }\\n            product*=n;\\n            \\n            return product;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int integerBreak(int n) {\\n            if(n==2) return 1;\\n            if(n==3) return 2;\\n            int product = 1;\\n            while(n>4){\\n                product*=3;\\n                n-=3;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 80694,
                "title": "java-dp-solution",
                "content": "    public int integerBreak(int n) {\\n           int[] dp = new int[n + 1];\\n           dp[1] = 1;\\n           for(int i = 2; i <= n; i ++) {\\n               for(int j = 1; j < i; j ++) {\\n                   dp[i] = Math.max(dp[i], (Math.max(j,dp[j])) * (Math.max(i - j, dp[i - j])));\\n               }\\n           }\\n           return dp[n];\\n        }",
                "solutionTags": [],
                "code": "    public int integerBreak(int n) {\\n           int[] dp = new int[n + 1];\\n           dp[1] = 1;\\n           for(int i = 2; i <= n; i ++) {\\n               for(int j = 1; j < i; j ++) {\\n                   dp[i] = Math.max(dp[i], (Math.max(j,dp[j])) * (Math.max(i - j, dp[i - j])));\\n               }\\n           }\\n           return dp[n];\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 285876,
                "title": "python-o-1-one-line-solution-detailed-explanation",
                "content": "Let\\'s first consider the limiting behaviour of the solution. \\n\\nFor large n, our \"integer break\" will consist of splitting up n into b groups of x. So n = bx, where rearranging yields b = <sup>n</sup>&frasl;<sub>x</sub>.\\n\\nOur goal is to maximize the product of these fragments, so we want to maximize f(x) = x<sup><sup>n</sup>&frasl;<sub>x</sub></sup>.\\n\\nUsing implicit differentiation, we find f\\'(x) = nx<sup><sup>n</sup>&frasl;<sub>x</sub> - 2 </sup>(1 - *log*x). Setting f\\'(x) = 0 gives x = **e**, so our objective function **f(x) is maximized at x = e**.\\n\\nObviously, **e** is not an integer, so we cannot split n into groups of **e** for the purposes of this question. However, this result gives us the intuition that n should be split into 2\\'s and 3\\'s, wherever possible, since 2 < **e** < 3.\\n\\nWe begin by working through the first several cases of n and try to identify a pattern: \\n\\n<table>\\n<th> n </th>\\n<th> Maximum Product </th>\\n<th> # of 2\\'s </th>\\n<th> # of 3\\'s </th>\\n<tr>\\n<td> 2 </td>\\n<td> 1 x 1 = 1 </td>\\n<td> 0 </td>\\n<td> 0 </td>\\n<tr>\\n<td> 3 </td>\\n<td> 1 x 2 = 2</td>\\n<td> 1 </td>\\n<td> 0 </td>\\n<tr>\\n<td> 4 </td>\\n<td> 2 x 2 = 4</td>\\n<td> 2 </td>\\n<td> 0 </td>\\n<tr>\\n<td> 5 </td>\\n<td> 2 x 3 = 6</td>\\n<td> 1 </td>\\n<td> 1 </td>\\n<tr>\\n<td> 6 </td>\\n<td> 3 x 3 = 9</td>\\n<td> 0 </td>\\n<td> 2 </td>\\n<tr>\\n<td> 7 </td>\\n<td> 2 x 2 x 3 = 12</td>\\n<td> 2 </td>\\n<td> 1 </td>\\n<tr>\\n<td> 8 </td>\\n<td> 2 x 3 x 3 = 18</td>\\n<td> 1 </td>\\n<td> 2 </td>\\n<tr>\\n<td> 9 </td>\\n<td> 3 x 3 x 3 = 27</td>\\n<td> 0 </td>\\n<td> 3 </td>\\n<tr>\\n<td> 10 </td>\\n<td> 2 x 2 x 3 x 3 = 36</td>\\n<td> 2 </td>\\n<td> 2 </td>\\n<tr>\\n<td> 11 </td>\\n<td> 2 x 3 x 3 x 3 = 54</td>\\n<td> 1 </td>\\n<td> 3 </td>\\n<tr>\\n<td> 12 </td>\\n<td> 3 x 3 x 3 x 3 = 81</td>\\n<td> 0 </td>\\n<td> 4 </td>\\n<tr>\\n<td> 13 </td>\\n<td> 2 x 2 x 3 x 3 x 3 = 108</td>\\n<td> 2 </td>\\n<td> 3 </td>\\n<tr>\\n<td> 14 </td>\\n<td> 2 x 3 x 3 x 3 x 3 = 162</td>\\n<td> 1 </td>\\n<td> 4 </td>\\n<tr>\\n<td> 15 </td>\\n<td> 3 x 3 x 3 x 3 x 3 = 243</td>\\n<td> 0 </td>\\n<td> 5 </td>\\n</table>\\n\\nWe can deduce a number of things from this table. First, a DP solution jumps out at us. Let dp[n] be the maximum possible product for integer n. Starting at n=7, we notice that dp[n] = 3*dp[n-3]. We obtain the following **O(n)** solution:\\n\\n**DP Implementation:**\\n\\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        case = [0,0,1,2,4,6,9]\\n        if n < 7:\\n            return case[n]\\n        dp = case + [0] * (n-6)\\n        for i in range(7, n+1):\\n            dp[i] = 3*dp[i-3]\\n        return dp[-1]\\n```\\n\\n(Note: we include the base cases for the invalid inputs of n=0 and n=1 to maintain alignment of the indexes of dp, avoiding the need for an offset.)\\n\\n<br>\\n<br>\\n\\nHowever, we aren\\'t done yet. If we look a little more carefully at the above table, we see that the powers of 2 and 3 follow a pattern. \\n\\nThe \"power of 2\" pattern is fairly easy to spot. Starting at n=4, the number of 2\\'s repeats the cycle of 2,1,0. So the \"2 exponent\" in the maximum product can be expressed as (-n)%3.\\n\\nThe \"power of 3\" pattern is similar, but slightly harder to express. Again, the pattern starts at n=4 and has a period of length 3. This time, the numbers in each cycle are all one more than the numbers in the previous cycle. 0,1,2 , 1,2,3 , 2,3,4 , ... . We figure out that we can express this \"3 exponent\" as ((n-1)%3) + (n-4)//3. The first term handles the periodic behavior and the second term captures the perpetual increases between cycles.\\n\\nWe now have an explicit formula to solve the problem, solving in **O(1)** time. Since the only special cases of n=2 and n=3 have maximum products of 1 and 2 respectively, we can handle everything in one line:\\n\\n**Explicit Formula Implementation:**\\n\\n```\\ndef integerBreak(self, n: int) -> int:\\n    return int(math.pow(2, (-n)%3) * math.pow(3, (n-1)%3 + (n-4)//3)) if n > 3 else n-1\\n```\\n\\n(Credit to [totsubo](https://leetcode.com/totsubo/) for correcting my initial error of using ** instead of ```math.pow()``` - we cannot use ** if we want to preserve constant time complexity.)",
                "solutionTags": [
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        case = [0,0,1,2,4,6,9]\\n        if n < 7:\\n            return case[n]\\n        dp = case + [0] * (n-6)\\n        for i in range(7, n+1):\\n            dp[i] = 3*dp[i-3]\\n        return dp[-1]\\n```\n```\\ndef integerBreak(self, n: int) -> int:\\n    return int(math.pow(2, (-n)%3) * math.pow(3, (n-1)%3 + (n-4)//3)) if n > 3 else n-1\\n```\n```math.pow()```",
                "codeTag": "Java"
            },
            {
                "id": 80785,
                "title": "o-log-n-time-solution-with-explanation",
                "content": "Given a number n lets say we have a possible product P = p1 * p2 * ... *pk. Then we notice what  would happen if we could break pi up into two more terms lets say one of the terms is 2 we would get the terms  pi-2 and 2 so if 2*(pi-2) > pi we would get a bigger product and this happens if pi > 4. since there is one other possible number less then 4 that is not 2  aka 3. Likewise for 3 if we instead breakup the one of the terms into pi-3 and 3 we would get a bigger product if 3*(pi-3) > pi which happens if  pi > 4.5.\\n\\nHence we see that all of the terms in the product must be 2's and 3's. So we now just need to write n = a*3 + b*2 such that P =  (3^a) * (2^b) is maximized. Hence we should favor more 3's then 2's in the product then 2's if possible. \\n\\nSo if n = a*3 then the answer will just be 3^a. \\n\\nif n = a*3 + 2 then the answer will be 2*(3^a).\\n\\nand if n = a*3  + 2*2  then the answer will be 2 * 2 * 3^a\\n\\nThe above three cover all cases  that n can be written as and the Math.pow() function takes O(log n) time to preform hence that is the running time.\\n\\n\\n    public class Solution {\\n        public int integerBreak(int n) {\\n            if(n == 2)\\n                return 1;\\n            else if(n == 3)\\n                return 2;\\n            else if(n%3 == 0)\\n                return (int)Math.pow(3, n/3);\\n            else if(n%3 == 1)\\n                return 2 * 2 * (int) Math.pow(3, (n - 4) / 3);\\n            else \\n                return 2 * (int) Math.pow(3, n/3);\\n        }\\n                \\n    }",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n        public int integerBreak(int n) {\\n            if(n == 2)\\n                return 1;\\n            else if(n == 3)\\n                return 2;\\n            else if(n%3 == 0)\\n                return (int)Math.pow(3, n/3);\\n            else if(n%3 == 1)\\n                return 2 * 2 * (int) Math.pow(3, (n - 4) / 3);\\n            else \\n                return 2 * (int) Math.pow(3, n/3);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 80772,
                "title": "c-dynamic-programming-solution",
                "content": "    class Solution {\\n    public:\\n        int integerBreak(int n) {\\n            \\n            if (n <= 2)\\n                return 1;\\n\\n            vector<int> maxArr(n+1, 0);\\n                        \\n            /** For a number i: write i as a sum of integers, then take the product of those integers.\\n            maxArr[i] = maximum of all the possible products */\\n            \\n            maxArr[1] = 0;\\n            maxArr[2] = 1; // 2=1+1 so maxArr[2] = 1*1\\n            \\n            for (int i=3; i<=n; i++) {\\n                for (int j=1; j<i; j++) {\\n                    /** Try to write i as: i = j + S where S=i-j corresponds to either one number or a sum of two or more numbers\\n                    \\n                    Assuming that j+S corresponds to the optimal solution for maxArr[i], we have two cases:\\n                    (1) i is the sum of two numbers, i.e. S=i-j is one number, and so maxArr[i]=j*(i-j)\\n                    (2) i is the sum of at least three numbers, i.e. S=i-j is a sum of at least 2 numbers,\\n                    and so the product of the numbers in this sum for S is maxArr[i-j]\\n                    (=maximum product after breaking up i-j into a sum of at least two integers):\\n                    maxArr[i] = j*maxArr[i-j]\\n                    */\\n                    maxArr[i] = max(maxArr[i], max(j*(i-j), j*maxArr[i-j]));\\n                }\\n            }\\n            return maxArr[n];\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int integerBreak(int n) {\\n            \\n            if (n <= 2)\\n                return 1;\\n\\n            vector<int> maxArr(n+1, 0);\\n                        \\n            /** For a number i: write i as a sum of integers, then take the product of those integers.\\n            maxArr[i] = maximum of all the possible products */\\n            \\n            maxArr[1] = 0;\\n            maxArr[2] = 1; // 2=1+1 so maxArr[2] = 1*1\\n            \\n            for (int i=3; i<=n; i++) {\\n                for (int j=1; j<i; j++) {\\n                    /** Try to write i as: i = j + S where S=i-j corresponds to either one number or a sum of two or more numbers\\n                    \\n                    Assuming that j+S corresponds to the optimal solution for maxArr[i], we have two cases:\\n                    (1) i is the sum of two numbers, i.e. S=i-j is one number, and so maxArr[i]=j*(i-j)\\n                    (2) i is the sum of at least three numbers, i.e. S=i-j is a sum of at least 2 numbers,\\n                    and so the product of the numbers in this sum for S is maxArr[i-j]\\n                    (=maximum product after breaking up i-j into a sum of at least two integers):\\n                    maxArr[i] = j*maxArr[i-j]\\n                    */\\n                    maxArr[i] = max(maxArr[i], max(j*(i-j), j*maxArr[i-j]));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 383679,
                "title": "python-dp-solution-with-detailed-explanation-avoids-confusion-about-factors-of-2-or-3",
                "content": "To find the max product of 8, break up 8 into the sum of two terms (keep the first term less than or equal to the second to prevent redundancy):\\n\\n```\\n1 + 7 --> 1 * 7 = 7\\n2 + 6 --> 2 * 6 = 12\\n3 + 5 --> 3 * 5 = 15\\n4 + 4 --> 4 * 4 = 16\\n```\\n\\nFrom this is seems that the max product 16, however we neglected to also break up each of the two terms into more terms, and check all those. Let\\'s break the 6 into 3 + 3:\\n\\n```\\n2 + 6 = 2 + 3 + 3 --> 2 * 3 * 3 = 18\\n```\\n\\nwhich ends up being the correct answer. But another way to get this is to reuse the previously computed max product of 6, which we know to be 9:\\n\\n```\\n2 * (3 * 3) = 2 * max_product_of_6 = 2 * 9 = 18\\n```\\n\\nSo for each choice of i and j with i <= j and i + j = n, check i * j but ALSO check if the previously computed max products for i and j are larger than i and j. Start with n = 1 and build up to the final n. Store the previously computed values in a dp list.\\n\\n```\\nclass Solution(object):\\n    def integerBreak(self, n):\\n        dp = [None, 1]\\n        for m in range (2, n + 1):\\n            j = m - 1\\n            i = 1\\n            max_product = 0\\n            while i <= j:\\n                max_product = max(max_product, max(i, dp[i]) * max(j, dp[j]))\\n                j -= 1\\n                i += 1\\n            dp.append(max_product)\\n        return dp[n]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n1 + 7 --> 1 * 7 = 7\\n2 + 6 --> 2 * 6 = 12\\n3 + 5 --> 3 * 5 = 15\\n4 + 4 --> 4 * 4 = 16\\n```\n```\\n2 + 6 = 2 + 3 + 3 --> 2 * 3 * 3 = 18\\n```\n```\\n2 * (3 * 3) = 2 * max_product_of_6 = 2 * 9 = 18\\n```\n```\\nclass Solution(object):\\n    def integerBreak(self, n):\\n        dp = [None, 1]\\n        for m in range (2, n + 1):\\n            j = m - 1\\n            i = 1\\n            max_product = 0\\n            while i <= j:\\n                max_product = max(max_product, max(i, dp[i]) * max(j, dp[j]))\\n                j -= 1\\n                i += 1\\n            dp.append(max_product)\\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 80720,
                "title": "easy-to-understand-c-with-explanation",
                "content": "For any integer `p` strictly greater than `4`, it has the property such that `3 * (p - 3) > p`, which means breaking it into two integers `3` and `p - 3` makes the product larger while keeping the sum unchanged. If `p - 3` is still greater than `4`, we should break it again into `3` and `p - 6`, giving `3 * 3 * (p - 6)`, and so on, until we cannot break it (less than or equal to 4) anymore. \\n\\nFor integer `4`, breaking it into `2 * 2` or keeping it as `4` does not change its contribution to the product. \\nWe cannot have more than two `4`s, because `2 * 3 * 3 > 4 * 4`. We cannot have more than three `2`s because `3 * 3 > 2 * 2 * 2`. \\n\\n\\n    class Solution {\\n    public:\\n        long long integerBreak(long long n) {\\n            if(n == 2) return 1;\\n            if(n == 3) return 2;\\n            if(n == 4) return 4;\\n            if(n == 5) return 6;\\n            if(n == 6) return 9;\\n            return 3 * integerBreak(n - 3);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        long long integerBreak(long long n) {\\n            if(n == 2) return 1;\\n            if(n == 3) return 2;\\n            if(n == 4) return 4;\\n            if(n == 5) return 6;\\n            if(n == 6) return 9;\\n            return 3 * integerBreak(n - 3);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1475874,
                "title": "python-from-backtracking-to-top-down-dp-o-n-2-clean-concise",
                "content": "**\\u274C Solution 1: Backtracking**\\n```python\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        self.ans = 0\\n        \\n        def bt(n, product, k):\\n            if n == 0:\\n                if k >= 2:\\n                    self.ans = max(self.ans, product)\\n                return\\n            \\n            for i in range(1, n+1):\\n                bt(n - i, product * i, k + 1)\\n                   \\n        bt(n, 1, 0)\\n        return self.ans\\n```\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Top down DP**\\n- Let `dp(n, k)` (where n <= 58, k <= 2) denote the maximum product we can get if we split `n` into positive integers. (k == 2 means split into >= 2 positive integer).\\n```python\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        @lru_cache(None)\\n        def dp(n, k):\\n            if n == 0:\\n                if k == 2:\\n                    return 1\\n                return 0\\n\\n            ans = 0\\n            for x in range(1, n + 1):\\n                ans = max(ans, dp(n - x, min(k + 1, 2)) * x)\\n            return ans\\n\\n        return dp(n, 0)\\n```\\nComplexity:\\n- Time: `O(N^2)`, where `N <= 58`.\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        self.ans = 0\\n        \\n        def bt(n, product, k):\\n            if n == 0:\\n                if k >= 2:\\n                    self.ans = max(self.ans, product)\\n                return\\n            \\n            for i in range(1, n+1):\\n                bt(n - i, product * i, k + 1)\\n                   \\n        bt(n, 1, 0)\\n        return self.ans\\n```\n```python\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        @lru_cache(None)\\n        def dp(n, k):\\n            if n == 0:\\n                if k == 2:\\n                    return 1\\n                return 0\\n\\n            ans = 0\\n            for x in range(1, n + 1):\\n                ans = max(ans, dp(n - x, min(k + 1, 2)) * x)\\n            return ans\\n\\n        return dp(n, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 80707,
                "title": "easy-java-dp-solution-with-explanation-typical-knapsack-problem",
                "content": "\\n```\\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        int max = 0;\\n        for(int i = 1; i < n; i++){\\n            for(int j = i; j <= n; j++){\\n                dp[j] = Math.max(dp[j], dp[j - i] * i);\\n                if(j == n){\\n                    if(max < dp[j])\\n                        max = dp[j];\\n                }\\n            }\\n        }\\n        return max;\\n```\\nThis is a typical knapsack problem. We can assume that the volume of the knapsack is **n**. The items we can choose range from **1** to **n - 1**(because we must divide n into at least two positive parts). The point is that we can choose each item many times. \\nThe first loop means the items we can choose(**i** means first i items).\\nAnd in the second loop, **j** means the sum of items that we are going to choose.\\nFor each item, we have two choices, pick it up or not. And we should choose the max result.\\njust as ***dp[j] = Math.max(dp[j], dp[j - i] * i);***\\nThen, you are able to solve the problem.\\nBy the way, the initialization is also important.",
                "solutionTags": [],
                "code": "```\\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        int max = 0;\\n        for(int i = 1; i < n; i++){\\n            for(int j = i; j <= n; j++){\\n                dp[j] = Math.max(dp[j], dp[j - i] * i);\\n                if(j == n){\\n                    if(max < dp[j])\\n                        max = dp[j];\\n                }\\n            }\\n        }\\n        return max;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 80801,
                "title": "python-8-lines-simple-o-1",
                "content": "> From the hint:\\n\\n> 7 = 3 + 4 = 12\\n\\n> 8 = 3 + 3 + 2 = 18 \\n\\n> 9 = 3 + 3 + 3 = 27\\n\\n> 10 = 3 + 3 + 4 = 36\\n\\n> 11 = 3 + 3 + 3 + 2 = 54\\n\\n> 12 = 3 + 3 + 3 + 3 = 81\\n\\n*Three* is a *magic* number.\\n\\n\\n\\n    class Solution(object):\\n        def integerBreak(self, n):\\n            if n == 2 or n == 3:\\n                return n - 1\\n            if n % 3 == 0:\\n                return 3**(n/3)\\n            if n % 3 == 1:\\n                return 3**(n/3 - 1)*4\\n            if n % 3 == 2:\\n                return 3**(n/3)*2",
                "solutionTags": [
                    "Python"
                ],
                "code": "> From the hint:\\n\\n> 7 = 3 + 4 = 12\\n\\n> 8 = 3 + 3 + 2 = 18 \\n\\n> 9 = 3 + 3 + 3 = 27\\n\\n> 10 = 3 + 3 + 4 = 36\\n\\n> 11 = 3 + 3 + 3 + 2 = 54\\n\\n> 12 = 3 + 3 + 3 + 3 = 81\\n\\n*Three* is a *magic* number.\\n\\n\\n\\n    class Solution(object):\\n        def integerBreak(self, n):\\n            if n == 2 or n == 3:\\n                return n - 1\\n            if n % 3 == 0:\\n                return 3**(n/3)\\n            if n % 3 == 1:\\n                return 3**(n/3 - 1)*4\\n            if n % 3 == 2:\\n                return 3**(n/3)*2",
                "codeTag": "Java"
            },
            {
                "id": 80832,
                "title": "share-some-thought-process-about-this-problem",
                "content": "    If we want to break a number, breaking it into 3s turns out to be the most efficient.\\n    2^3 < 3^2\\n    4^3 < 3^4\\n    5^3 < 3^5\\n    6^3 < 3^6\\n    ...\\n    \\n    Therefore, intuitively, we want as many 3 as possible \\n    if a number % 3 == 0, we just break it into 3s -> the product is Math.pow(3, n/3)\\n\\n    As for numbers % 3 == 1, we don't want the 'times * 1' in the end; \\n        borrowing a 3 is a natural thought. \\n        if we borrow a 3, 3 can be divided into \\n             case 1: 1 + 2 -> with the extra 1, we have 2*2 = 4\\n             case 2: (0) + 3 -> with the extra 1, we have 4\\n             turns out these two cases have the same results\\n        so, for numbers % 3 == 1 -> the result would be Math.pow(3, n/3-1)*4\\n\\n    Then we have the numbers % 3 == 2 left\\n         again, we try to borrow a 3,\\n             case 1: 1+2 -> with the extra 2, we have 1*5 or 3*2 => 3*2 is better\\n             case 2: 0+3 -> with the extra 2, we have 2*3 or 5 => 2*3 is better\\n         and we actually just end up with not borrowing at all! \\n         so we can just *2 if we have an extra 2 -> the result would be Math.pow(3, n/3)*2\\n\\n    Then, we have a couple corner cases two deal with since so far we only looked at \\n    numbers  that are larger than 3 -> luckily, we only have 2 and 3 left, \\n    which are pretty easy to figure out\\n    \\n    Thus my final solution is \\n\\n    public class Solution {\\n        public int integerBreak(int n) {\\n            if(n <= 3) return n-1; //assuming n >= 2\\n            return n%3 == 0 ? (int)Math.pow(3, n/3) : n%3 == 1 ? (int)Math.pow(3, n/3-1)*4 : (int)Math.pow(3, n/3)*2;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int integerBreak(int n) {\\n            if(n <= 3) return n-1; //assuming n >= 2\\n            return n%3 == 0 ? (int)Math.pow(3, n/3) : n%3 == 1 ? (int)Math.pow(3, n/3-1)*4 : (int)Math.pow(3, n/3)*2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1434210,
                "title": "cpp-java-recursion-memoization-0-ms-bottom-up-0-ms",
                "content": "This question is a classic rod cutting problem a subset of unbounded knapsack problem. \\nThe only catch is that we are multiplying with idx as we need to maximise the product\\nThe cpp solution got 0 ms while Java soln got 3 ms. \\n\\n-->Recursion(68 ms)\\n```\\nclass Solution {\\npublic:\\n    int helper(int n, int idx)\\n    {\\n       if(n == 0 or idx == 0) return 1;\\n        \\n       if(idx > n) return helper(n, idx - 1);\\n      \\n       return max((idx * helper(n - idx, idx)), helper(n , idx - 1));\\n    }\\n    \\n    int integerBreak(int n)\\n    {\\n       return helper(n, n - 1);\\n    }\\n};\\n```\\n\\nFor Java (49 ms) \\n```\\nclass Solution {\\n    public int helper(int n, int idx)\\n    {\\n       if(n == 0 || idx == 0) return 1;\\n        \\n       if(idx > n) return helper(n, idx - 1);\\n      \\n       return Math.max((idx * helper(n - idx, idx)), helper(n , idx - 1));\\n    }\\n    \\n    public int integerBreak(int n)\\n    {\\n        return helper(n, n - 1);\\n    }\\n}\\n```\\n\\n--> Memoization(0 ms)\\n```\\nclass Solution {\\npublic:\\n    int dp[59][58];\\n    \\n    int helper(int n, int idx)\\n    {\\n       if(n == 0 or idx == 0) return 1;\\n        \\n       if(dp[n][idx] != -1) return dp[n][idx];\\n        \\n       if(idx > n) return dp[n][idx] = helper(n, idx - 1);\\n      \\n       return dp[n][idx] = max((idx * helper(n - idx, idx)), helper(n , idx - 1));\\n    }\\n    \\n    int integerBreak(int n)\\n    {\\n        for(int i = 0; i < n + 1; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n                dp[i][j] = -1;\\n        }\\n        \\n        return helper(n, n - 1);\\n    }\\n};\\n```\\n\\n--> bottom up approach(0 ms)\\n```\\nclass Solution {\\npublic:\\n\\n    int integerBreak(int n)\\n    {\\n        int dp[n + 1][n];\\n        \\n        for(int row = 0; row < n + 1; row++)\\n        {\\n            for(int col = 0; col < n; col++)\\n            {\\n                if(row == 0 || col == 0)\\n                 dp[row][col] = 1;\\n            }\\n        }\\n        \\n        for(int row = 1; row < n + 1; row++)\\n        {\\n            for(int col = 1; col < n; col++)\\n            {\\n                if(row >= col)\\n                  dp[row][col] = max(col * dp[row - col][col], dp[row][col - 1]);\\n                \\n                else\\n                    dp[row][col] = dp[row][col - 1];\\n            }\\n        }\\n        \\n        return dp[n][n - 1];      \\n    }\\n};\\n```\\n\\nfor Java (3 ms)\\n```\\nclass Solution {\\n    public int integerBreak(int n)\\n    {\\n        int dp[][] = new int[n + 1][n];\\n        \\n        for(int row = 0; row < n + 1; row++)\\n        {\\n            for(int col = 0; col < n; col++)\\n            {\\n                if(row == 0 || col == 0)\\n                 dp[row][col] = 1;\\n            }\\n        }\\n        \\n        for(int row = 1; row < n + 1; row++)\\n        {\\n            for(int col = 1; col < n; col++)\\n            {\\n                if(row >= col)\\n                  dp[row][col] = Math.max(col * dp[row - col][col], dp[row][col - 1]);\\n                \\n                else\\n                    dp[row][col] = dp[row][col - 1];\\n            }\\n        }\\n        \\n        return dp[n][n - 1];      \\n    }\\n\\t```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int n, int idx)\\n    {\\n       if(n == 0 or idx == 0) return 1;\\n        \\n       if(idx > n) return helper(n, idx - 1);\\n      \\n       return max((idx * helper(n - idx, idx)), helper(n , idx - 1));\\n    }\\n    \\n    int integerBreak(int n)\\n    {\\n       return helper(n, n - 1);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int helper(int n, int idx)\\n    {\\n       if(n == 0 || idx == 0) return 1;\\n        \\n       if(idx > n) return helper(n, idx - 1);\\n      \\n       return Math.max((idx * helper(n - idx, idx)), helper(n , idx - 1));\\n    }\\n    \\n    public int integerBreak(int n)\\n    {\\n        return helper(n, n - 1);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[59][58];\\n    \\n    int helper(int n, int idx)\\n    {\\n       if(n == 0 or idx == 0) return 1;\\n        \\n       if(dp[n][idx] != -1) return dp[n][idx];\\n        \\n       if(idx > n) return dp[n][idx] = helper(n, idx - 1);\\n      \\n       return dp[n][idx] = max((idx * helper(n - idx, idx)), helper(n , idx - 1));\\n    }\\n    \\n    int integerBreak(int n)\\n    {\\n        for(int i = 0; i < n + 1; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n                dp[i][j] = -1;\\n        }\\n        \\n        return helper(n, n - 1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int integerBreak(int n)\\n    {\\n        int dp[n + 1][n];\\n        \\n        for(int row = 0; row < n + 1; row++)\\n        {\\n            for(int col = 0; col < n; col++)\\n            {\\n                if(row == 0 || col == 0)\\n                 dp[row][col] = 1;\\n            }\\n        }\\n        \\n        for(int row = 1; row < n + 1; row++)\\n        {\\n            for(int col = 1; col < n; col++)\\n            {\\n                if(row >= col)\\n                  dp[row][col] = max(col * dp[row - col][col], dp[row][col - 1]);\\n                \\n                else\\n                    dp[row][col] = dp[row][col - 1];\\n            }\\n        }\\n        \\n        return dp[n][n - 1];      \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int integerBreak(int n)\\n    {\\n        int dp[][] = new int[n + 1][n];\\n        \\n        for(int row = 0; row < n + 1; row++)\\n        {\\n            for(int col = 0; col < n; col++)\\n            {\\n                if(row == 0 || col == 0)\\n                 dp[row][col] = 1;\\n            }\\n        }\\n        \\n        for(int row = 1; row < n + 1; row++)\\n        {\\n            for(int col = 1; col < n; col++)\\n            {\\n                if(row >= col)\\n                  dp[row][col] = Math.max(col * dp[row - col][col], dp[row][col - 1]);\\n                \\n                else\\n                    dp[row][col] = dp[row][col - 1];\\n            }\\n        }\\n        \\n        return dp[n][n - 1];      \\n    }\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 986733,
                "title": "faster-than-100-00-memoization-dp-c",
                "content": "```\\n//memo [Runtime: 0 ms, faster than 100.00%]\\nclass Solution {\\npublic:\\n    int integerBreak(int n,int *dp) {\\n        if(n==0 || n==1)\\n            return 1;\\n        \\n        if(dp[n]!=-1) \\n            return dp[n];\\n        \\n        int maxi=0;\\n        \\n        for(int i=1;i<n;i++){\\n            maxi=max(maxi,max(integerBreak(n-i,dp)*i,i*(n-i)));\\n        }\\n        \\n        return dp[n]=maxi;\\n    }\\n    int integerBreak(int n) {\\n        int *ans = new int[n+1];\\n\\t\\tfor(int j = 0; j <= n; j++) {\\n\\t\\t\\tans[j] = -1;\\n\\t\\t}\\n        return integerBreak(n,ans);\\n    }\\n};\\n```\\n\\n```\\n//dp [Runtime: 0 ms, faster than 100.00%]\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        int dp[n+1];\\n        dp[0]=1;\\n        dp[1]=1;\\n        for(int j=2;j<n+1;j++){\\n            int maxi=0;\\n            for(int i=1;i<j;i++){\\n                maxi=max(maxi,max(dp[j-i]*i,i*(j-i)));\\n            }\\n            dp[j]=maxi;\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section**.\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//memo [Runtime: 0 ms, faster than 100.00%]\\nclass Solution {\\npublic:\\n    int integerBreak(int n,int *dp) {\\n        if(n==0 || n==1)\\n            return 1;\\n        \\n        if(dp[n]!=-1) \\n            return dp[n];\\n        \\n        int maxi=0;\\n        \\n        for(int i=1;i<n;i++){\\n            maxi=max(maxi,max(integerBreak(n-i,dp)*i,i*(n-i)));\\n        }\\n        \\n        return dp[n]=maxi;\\n    }\\n    int integerBreak(int n) {\\n        int *ans = new int[n+1];\\n\\t\\tfor(int j = 0; j <= n; j++) {\\n\\t\\t\\tans[j] = -1;\\n\\t\\t}\\n        return integerBreak(n,ans);\\n    }\\n};\\n```\n```\\n//dp [Runtime: 0 ms, faster than 100.00%]\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        int dp[n+1];\\n        dp[0]=1;\\n        dp[1]=1;\\n        for(int j=2;j<n+1;j++){\\n            int maxi=0;\\n            for(int i=1;i<j;i++){\\n                maxi=max(maxi,max(dp[j-i]*i,i*(j-i)));\\n            }\\n            dp[j]=maxi;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 80780,
                "title": "c-o-n-solution-with-dp",
                "content": "    class Solution {\\n    public:\\n        int integerBreak(int n) {\\n            int dp[n + 1];\\n            dp[0] = 0;\\n            dp[1] = 1;\\n            dp[2] = 1;\\n            dp[3] = 2;\\n            dp[4] = 4;\\n            for (int i = 5; i <= n; ++i) {\\n                dp[i] = 3 * max(i - 3, dp[i - 3]);\\n            }\\n            return dp[n];\\n        }\\n    };\\n\\n2 => 1, 1 => 1  \\n3 => 2, 1 => 2  \\n4 => 2, 2 => 4  \\n5 => 3, 2 => 6  \\n6 => 3, 3 => 9  \\n7 => 3, 4 => 12  \\n8 => 3, 5 => 18  \\n9 => 3, 6 => 27  \\n10 => 3, 7 => 36  \\n\\nBy observation, when you get maximum, one of the num is always 3.   \\nAfter 3, the result will be larger than or equal the number itself.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int integerBreak(int n) {\\n            int dp[n + 1];\\n            dp[0] = 0;\\n            dp[1] = 1;\\n            dp[2] = 1;\\n            dp[3] = 2;\\n            dp[4] = 4;\\n            for (int i = 5; i <= n; ++i) {\\n                dp[i] = 3 * max(i - 3, dp[i - 3]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 80805,
                "title": "c-0ms-dp-solution-with-explanation-in-chinese",
                "content": "    /*\\n     * \\u4ecen = 2\\u5f00\\u59cb\\u9012\\u63a8\\uff0c\\u9012\\u63a8\\u5230n = 4\\u7684\\u65f6\\u5019\\uff0c4\\u53ef\\u4ee5\\u62c6\\u5206\\u62101\\u548c3\\u62162\\u548c2\\n     * \\u90a3\\u4e483\\u8981\\u4e0d\\u8981\\u7ee7\\u7eed\\u62c6\\u5206\\u5462\\uff1f2\\u8981\\u4e0d\\u8981\\u7ee7\\u7eed\\u62c6\\u5206\\u5462\\uff1f\\n     * \\u4e0d\\u9700\\u8981\\u3002\\u56e0\\u4e3a\\u6211\\u4eec\\u5df2\\u7ecf\\u628a\\u62c6\\u52062\\u62163\\u80fd\\u5f97\\u5230\\u7684\\u6700\\u5927\\u503c\\u5206\\u522b\\u8ba1\\u7b97\\u597d\\u5b58\\u5728dp[2]\\u548cdp[3]\\u4e86\\n     * \\u6240\\u4ee5\\u6211\\u4eec\\u53ea\\u9700\\u8981\\u6bd4\\u8f832\\u548cdp[2]\\u30013\\u548cdp[3]\\u8c01\\u66f4\\u5927\\u5c31\\u77e5\\u9053\\u8981\\u4e0d\\u8981\\u7ee7\\u7eed\\u62c6\\u5206\\n     * \\u6240\\u4ee5\\u5bf9\\u6bcf\\u4e2an\\uff0c\\u6211\\u4eec\\u53ea\\u9700\\u8981\\u8003\\u8651\\u62c6\\u5206\\u6210\\u4e24\\u4e2a\\u6570a b\\u7684\\u60c5\\u51b5\\uff0c\\u7136\\u540e\\u770b\\u6bd4\\u8f83a\\u548cdp[a]\\n     * \\u4ee5\\u53cab\\u548cdp[b]\\u8c01\\u5927\\u5c31\\u7528\\u8c01\\u76f8\\u4e58\\uff0c\\u5982\\u679cdp[a]>a\\uff0c\\u8868\\u793adp[a]\\u7ee7\\u7eed\\u62c6\\u5206\\u80fd\\u5f97\\u5230\\u6bd4\\u4e0d\\u62c6\\u5206\\n     * \\u66f4\\u5927\\u7684\\u503c\\uff0c\\u90a3\\u4e48\\u5c31\\u62c6\\u5206a\\uff0c\\u5bf9\\u4e8edp[b]\\u548cb\\u4e5f\\u4e00\\u6837\\n     */\\n    class Solution {\\n    public:\\n        int integerBreak(int n) {\\n            vector<int> dp(n + 1, 0);\\n            for(int i = 2; i <= n; i++) {\\n                for(int j = 1; j <= i / 2; j++) {\\n                    dp[i] = max(dp[i], max(j, dp[j]) * max(i - j, dp[i - j]));\\n                }\\n            }\\n            return dp[n];\\n        }\\n    };\\n\\nAt most of the time I learnt from others post, this time let me share. Since I haven't seen any dp solution with detailed explanation, I write this post for your reference. \\n\\nI don't know how to make this explanation clear in English. Hope anyone with a better command of English can translate it for others. THanks.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        int integerBreak(int n) {\\n            vector<int> dp(n + 1, 0);\\n            for(int i = 2; i <= n; i++) {\\n                for(int j = 1; j <= i / 2; j++) {\\n                    dp[i] = max(dp[i], max(j, dp[j]) * max(i - j, dp[i - j]));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 80723,
                "title": "simple-java-solution",
                "content": "    Basic idea is to divide your number into threes unless when the last number is 4\\nEg : \\n\\n    7 = 3 * 2 * 2\\n    8 = 3 * 3 * 2\\n    9 = 3 * 3 * 3\\n    10 = 3 * 3 * 2 * 2\\n    11 = 3 * 3 * 3 * 2\\n    12 = 3 * 3 * 3 * 3\\n    13 = 3 * 3 * 3 * 2 * 2\\nSee, the pattern?\\n\\n   \\tpublic static int integerBreak(int n) {\\n\\t\\tif(n==2||n==3) return n-1;\\n\\t\\tif(n==4) return 4;\\n\\t\\tint temp = n;\\n\\t\\tint sum = 1;\\n\\t\\twhile(temp>4){\\n\\t\\t\\ttemp = temp -3;\\n\\t\\t\\tsum = sum*3;\\n\\t\\t}\\n\\t\\t\\treturn sum*temp;\\n\\t}",
                "solutionTags": [],
                "code": "    Basic idea is to divide your number into threes unless when the last number is 4\\nEg : \\n\\n    7 = 3 * 2 * 2\\n    8 = 3 * 3 * 2\\n    9 = 3 * 3 * 3\\n    10 = 3 * 3 * 2 * 2\\n    11 = 3 * 3 * 3 * 2\\n    12 = 3 * 3 * 3 * 3\\n    13 = 3 * 3 * 3 * 2 * 2\\nSee, the pattern?\\n\\n   \\tpublic static int integerBreak(int n) {\\n\\t\\tif(n==2||n==3) return n-1;\\n\\t\\tif(n==4) return 4;\\n\\t\\tint temp = n;\\n\\t\\tint sum = 1;\\n\\t\\twhile(temp>4){\\n\\t\\t\\ttemp = temp -3;\\n\\t\\t\\tsum = sum*3;\\n\\t\\t}\\n\\t\\t\\treturn sum*temp;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1182785,
                "title": "python-solution-with-explanation",
                "content": "This approach is a bottom up dynamic programming solution. We are going to have an array called `dp` where `dp[i]` will correspond to the maximum product of breaking number `i` into a sum of `k` positive integers. For each number `i` we are going to break it into two parts. The ways in which we can break `i` into two parts is by subtracting `j` from `i`, where `j < i`. So the two parts we will get will be `i-j` and `j`. Now we think to ourselves: \\'I just split `i` into two parts, namely `i-j` and `j`, and I have already found the maximum product for each of those parts. Ok, so now let me consider each of the following: **1.)** I multiply `i` and `i-j`. **2.)** I multiply the the maximum product I found for part `j` and `i-j`. **3.)** I multiply the the maximum product I found for part `i-j` and `j`.\\' **4.)** I multiply the the maximum product I found for part `j` and the maximum product I found for part `i-j`.\\' Now we set `dp[i]` to be the max of those four products we took into consideration. We then return `dp[n]`, the maximum product of breaking number `n` into a sum of `k` positive integers.\\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        dp = [0]*(n+1)\\n        dp[1] = 1\\n        \\n        for i in range(2, n+1):\\n            for j in range(1, i):\\n                dp[i] = max(dp[i], max(j, dp[j]) * max(i-j, dp[i-j]))\\n        return dp[n]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        dp = [0]*(n+1)\\n        dp[1] = 1\\n        \\n        for i in range(2, n+1):\\n            for j in range(1, i):\\n                dp[i] = max(dp[i], max(j, dp[j]) * max(i-j, dp[i-j]))\\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 80818,
                "title": "java-o-n-dp-solution-store-and-reuse-products",
                "content": "This is an O(n) solution, the idea is to store all previously calculated product, note any <code>n>4</code> will guarantee to have a factor of <code>3</code>. Modifed per suggestion of @jianbao.tao and @ericxliu, Thank you!\\n\\n\\n    public int integerBreak(int n) {\\n        if (n <= 2) return 1;\\n        if (n == 3) return 2;\\n        if (n == 4) return 4;\\n        int[] p = new int[n+1];\\n        p[2] = 2;\\n        p[3] = 3;\\n        p[4] = 4;\\n        for (int i = 5; i <= n; ++i) {\\n            p[i] = 3 * p[i-3];\\n        }\\n        return p[n];\\n    }\\n\\nWhy the max product of any <code>n>4</code> must contain a factor of 3? <br>\\n1. It can't contain any factor x that is >= 5, o.w., we can further increase the max product by decomposing x, as the decomposed x when x>=5 is strictly greater than x;<br>\\n2. Out of 1, 2, 3, 4, we know 1 won't be a factor of n when <code>n>4</code>, if n is an odd number, 3 must be there as a factor (2 and 4 can't add up to an odd number); <br>\\n3. Now say n is an even number (<code>n>4</code>) and only has factor of 2 and 4, we can always split a <code>6</code> to <code>3X3</code>, which is better than <code>2X2X2</code>.<br>\\nTherefore, the max product of any n (<code>n>4</code>) must contain a factor of 3. The recurrence relation holds.\\n\\nFurther, as it holds for all n (<code>n>4</code>), we will be only using 3 as factor for n (<code>n>4</code>), we keep subtracting 3 until <code>n<=4</code>, and adopt the remaining factor. This leads to the closed form answer:\\n\\n    public int integerBreak(int n) {\\n        if (n <= 2) return 1;\\n        if (n == 3) return 2;\\n        if (n % 3 == 0) return (int)Math.pow(3, (n/3));\\n        else if (n % 3 == 1) return 4 * (int)Math.pow(3, (n-4)/3);\\n        else return 2 * (int)Math.pow(3, (n-2)/3);\\n    }\\n\\nAs for the complexity of the close form solution, it depends on the implementation of the build-in pow, it could be O(logn) (as a simple O(logn) implementation exists), but not necessarily. The build-in pow could be better than that by using caching or bit level manipulation. I don\\u2019t know the answer though.",
                "solutionTags": [],
                "code": "This is an O(n) solution, the idea is to store all previously calculated product, note any <code>n>4</code> will guarantee to have a factor of <code>3</code>. Modifed per suggestion of @jianbao.tao and @ericxliu, Thank you!\\n\\n\\n    public int integerBreak(int n) {\\n        if (n <= 2) return 1;\\n        if (n == 3) return 2;\\n        if (n == 4) return 4;\\n        int[] p = new int[n+1];\\n        p[2] = 2;\\n        p[3] = 3;\\n        p[4] = 4;\\n        for (int i = 5; i <= n; ++i) {\\n            p[i] = 3 * p[i-3];\\n        }\\n        return p[n];\\n    }\\n\\nWhy the max product of any <code>n>4</code> must contain a factor of 3? <br>\\n1. It can't contain any factor x that is >= 5, o.w., we can further increase the max product by decomposing x, as the decomposed x when x>=5 is strictly greater than x;<br>\\n2. Out of 1, 2, 3, 4, we know 1 won't be a factor of n when <code>n>4</code>, if n is an odd number, 3 must be there as a factor (2 and 4 can't add up to an odd number); <br>\\n3. Now say n is an even number (<code>n>4</code>) and only has factor of 2 and 4, we can always split a <code>6</code> to <code>3X3</code>, which is better than <code>2X2X2</code>.<br>\\nTherefore, the max product of any n (<code>n>4</code>) must contain a factor of 3. The recurrence relation holds.\\n\\nFurther, as it holds for all n (<code>n>4</code>), we will be only using 3 as factor for n (<code>n>4</code>), we keep subtracting 3 until <code>n<=4</code>, and adopt the remaining factor. This leads to the closed form answer:\\n\\n    public int integerBreak(int n) {\\n        if (n <= 2) return 1;\\n        if (n == 3) return 2;\\n        if (n % 3 == 0) return (int)Math.pow(3, (n/3));\\n        else if (n % 3 == 1) return 4 * (int)Math.pow(3, (n-4)/3);\\n        else return 2 * (int)Math.pow(3, (n-2)/3);\\n    }\\n\\nAs for the complexity of the close form solution, it depends on the implementation of the build-in pow, it could be O(logn) (as a simple O(logn) implementation exists), but not necessarily. The build-in pow could be better than that by using caching or bit level manipulation. I don\\u2019t know the answer though.",
                "codeTag": "Unknown"
            },
            {
                "id": 868663,
                "title": "c-math-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        if (n <= 3) return 1 * (n - 1);\\n        int res = 1;\\n        while (n >= 5) n -= 3, res *= 3;\\n        return res * n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        if (n <= 3) return 1 * (n - 1);\\n        int res = 1;\\n        while (n >= 5) n -= 3, res *= 3;\\n        return res * n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 370573,
                "title": "4-different-solutions-with-thorough-explanations-in-c-100",
                "content": "**1. The naive solution** (Time limit exceeded)\\nIf I got a similar problem I would start with the naive solution. The naive solution\\'s running time is exponential trying to get the possible value for all of the variations and get the maximum among them.\\n```c++\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        return helper(0, 1, n, 0);\\n    }\\nprivate:\\n    int helper(int curSum, int curMult, int target, int depth) {\\n        if (curSum == target) return curMult;\\n        int maxRes = INT_MIN;\\n        for (int i = 1; i < target; i++) \\n            if (i + curSum <= target) maxRes = max(maxRes, helper(curSum + i, curMult * i, target, depth + 1));\\n        return maxRes;\\n    }\\n};\\n```\\n**2. Optimization using memoization** (~680ms)\\nAfter solving it naively it\\'s time to optimize it. Since it recomputes the same parameters again and again we can prune it \\nas we have done it with fibonacci numbers. The key insight here is to add memoization for the parameters which are changing. Now our solution is polynomial. \\n```c++\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        return helper(0, 1, n, 0);\\n    }\\nprivate:\\n    struct KeyHasher {\\n        size_t operator()(const pair<int, int>& p) const {\\n            return (hash<int>()(p.first) << 1) ^ (hash<int>()(p.second));\\n        }\\n    };\\n    unordered_map<pair<int, int>, int, KeyHasher> used;\\n    int helper(int curSum, int curMult, int target, int depth) {\\n        if (used.find({curSum, curMult}) != used.end()) return used[{curSum, curMult}];\\n        if (curSum == target) return curMult;\\n        int maxRes = INT_MIN;\\n        for (int i = 1; i < target; i++) \\n            if (i + curSum <= target) \\n                maxRes = max(maxRes, helper(curSum + i, curMult * i, target, depth + 1));\\n        used[{curSum, curMult}] = maxRes;\\n        return maxRes;\\n    }\\n};\\n```\\n**3. Optimization using dynamic programming** (~0 ms)\\nHere\\'s the DP O(n^2) solution. The key idea here is to find the solution for each solution depending of the previous results. \\ndp[i] => is the maximum product value we can get if we divide the number at least to 2 subgroups. For example, dp[2] = 1 which can be\\ndivided by 1 * 1, since 1 + 1 = 2. \\n**So there are three variations:**\\n```c++\\nSuppose that our number is n = 4.\\n1. dp[i -j] * dp[j]  => that\\'s when we represent 4 as [1, 1, 1, 1]  which gives 1\\n2. dp[i - j] * j => [1, 1, 2] or [2, 1, 1] which gives 2\\n3. (i - j) * j => [2, 2] which gives 4 \\nTherefore, dp[4] = 4\\n```\\n\\n```c++\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        vector<int> dp(n + 1, 1);\\n        for (int i = 3; i <= n; i++) {\\n            for (int j = 1; j < i; j++) {\\n                dp[i] = max(dp[i], max({dp[i - j] * dp[j], dp[i - j] * j, (i - j) * j}));\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n**4. Mathematical solution** O(log(N)) ~0ms\\nHow to understand this solution? Just look at the results for the first 13 values:\\n```c++\\n\\t2 -> 1, 1\\n\\t3 -> 1, 2\\n\\t4 -> 2, 2\\n\\t5 -> 3, 2\\n\\t6 -> 3, 3\\n\\t7 -> 3, 4\\n\\t8 -> 3, 3, 2\\n\\t9 -> 3, 3, 3\\n\\t10 -> 3, 3, 4\\n\\t11 -> 3, 3, 3, 2\\n\\t12 -> 3, 3, 3, 3\\n\\t13 -> 3, 3, 3, 4\\n```\\nIntuitively, we want 3 as many as possible. \\n```\\n1. n % 3 == 0 => it\\'s pow(3, n / 3) \\n2. n % 3 == 1 => We don\\'t want to have 1 in the result, because it\\'s not the optimal variation. What we can do is to break \\none of the three\\'s into 2 * 2 or 4. Therefore, the result is pow(3, (n / 3 ) - 1 ) * 4;\\n3. n % 3 == 2 => If we try to break one of the \\'threes\\' it turns out that is not effective. Therefore, pow(3, n / 3) * 2 is the answer.\\n```\\n\\n```c++\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        if (n <= 3) return n - 1;\\n        if (n % 3 == 0) return pow(3, n / 3);\\n        if (n % 3 == 2) return pow(3, n / 3) * 2;\\n        return pow(3, (n / 3 ) - 1 ) * 4;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        return helper(0, 1, n, 0);\\n    }\\nprivate:\\n    int helper(int curSum, int curMult, int target, int depth) {\\n        if (curSum == target) return curMult;\\n        int maxRes = INT_MIN;\\n        for (int i = 1; i < target; i++) \\n            if (i + curSum <= target) maxRes = max(maxRes, helper(curSum + i, curMult * i, target, depth + 1));\\n        return maxRes;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        return helper(0, 1, n, 0);\\n    }\\nprivate:\\n    struct KeyHasher {\\n        size_t operator()(const pair<int, int>& p) const {\\n            return (hash<int>()(p.first) << 1) ^ (hash<int>()(p.second));\\n        }\\n    };\\n    unordered_map<pair<int, int>, int, KeyHasher> used;\\n    int helper(int curSum, int curMult, int target, int depth) {\\n        if (used.find({curSum, curMult}) != used.end()) return used[{curSum, curMult}];\\n        if (curSum == target) return curMult;\\n        int maxRes = INT_MIN;\\n        for (int i = 1; i < target; i++) \\n            if (i + curSum <= target) \\n                maxRes = max(maxRes, helper(curSum + i, curMult * i, target, depth + 1));\\n        used[{curSum, curMult}] = maxRes;\\n        return maxRes;\\n    }\\n};\\n```\n```c++\\nSuppose that our number is n = 4.\\n1. dp[i -j] * dp[j]  => that\\'s when we represent 4 as [1, 1, 1, 1]  which gives 1\\n2. dp[i - j] * j => [1, 1, 2] or [2, 1, 1] which gives 2\\n3. (i - j) * j => [2, 2] which gives 4 \\nTherefore, dp[4] = 4\\n```\n```c++\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        vector<int> dp(n + 1, 1);\\n        for (int i = 3; i <= n; i++) {\\n            for (int j = 1; j < i; j++) {\\n                dp[i] = max(dp[i], max({dp[i - j] * dp[j], dp[i - j] * j, (i - j) * j}));\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```\n```c++\\n\\t2 -> 1, 1\\n\\t3 -> 1, 2\\n\\t4 -> 2, 2\\n\\t5 -> 3, 2\\n\\t6 -> 3, 3\\n\\t7 -> 3, 4\\n\\t8 -> 3, 3, 2\\n\\t9 -> 3, 3, 3\\n\\t10 -> 3, 3, 4\\n\\t11 -> 3, 3, 3, 2\\n\\t12 -> 3, 3, 3, 3\\n\\t13 -> 3, 3, 3, 4\\n```\n```\\n1. n % 3 == 0 => it\\'s pow(3, n / 3) \\n2. n % 3 == 1 => We don\\'t want to have 1 in the result, because it\\'s not the optimal variation. What we can do is to break \\none of the three\\'s into 2 * 2 or 4. Therefore, the result is pow(3, (n / 3 ) - 1 ) * 4;\\n3. n % 3 == 2 => If we try to break one of the \\'threes\\' it turns out that is not effective. Therefore, pow(3, n / 3) * 2 is the answer.\\n```\n```c++\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        if (n <= 3) return n - 1;\\n        if (n % 3 == 0) return pow(3, n / 3);\\n        if (n % 3 == 2) return pow(3, n / 3) * 2;\\n        return pow(3, (n / 3 ) - 1 ) * 4;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2662991,
                "title": "0-ms-4-lines-o-n-solution",
                "content": "```\\n\\tint integerBreak(int n) {\\n        if(n <= 3) return n-1;\\n        else if(n % 3 == 0) return pow(3, n/3);\\n        else if(n % 3 == 1) return 4 * pow(3, (n-4)/3);\\n        else return 2*pow(3, n/3);\\n    }\\n```",
                "solutionTags": [
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tint integerBreak(int n) {\\n        if(n <= 3) return n-1;\\n        else if(n % 3 == 0) return pow(3, n/3);\\n        else if(n % 3 == 1) return 4 * pow(3, (n-4)/3);\\n        else return 2*pow(3, n/3);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1374628,
                "title": "c-recursion-dp-memoization-dp-tabulation",
                "content": "**Method 1: RECURSION**\\n```\\nclass Solution {\\npublic:\\n    int recursion(int n, int cur)\\n    {\\n        // base\\n        if (n == 0 || cur == 0) {\\n            return 1;\\n        }\\n        // recurisve\\n        if (cur > n) {\\n            return recursion(n - 0, cur - 1);\\n        }\\n        else {\\n            return max(recursion(n - 0, cur - 1), cur * recursion(n - cur, cur));\\n        }\\n    }\\n    \\n    int integerBreak(int n) \\n    {\\n        return recursion(n, n - 1);    \\n    }\\n};\\n```\\n\\n**Method 2: DP MEMOIZATION**\\n```\\nclass Solution {\\npublic:\\n    int dp[58 + 1][57 + 1];\\n    \\n    int recursion(int n, int cur)\\n    {    \\n        if (n == 0 || cur == 0)\\n            return 1;\\n        if (dp[n][cur] != -1)\\n            return dp[n][cur];\\n        if (cur > n)\\n            return dp[n][cur] = recursion(n - 0, cur - 1);\\n        else\\n            return dp[n][cur] = max(recursion(n - 0, cur - 1), cur * recursion(n - cur, cur));\\n    }\\n    \\n    int integerBreak(int n) \\n    {\\n        memset(dp, -1, sizeof(dp));\\n        return recursion(n, n - 1);    \\n    }\\n};\\n```\\n\\n**Method 3: DP TABULATION**\\n```\\nclass Solution {\\npublic:\\n    int dp[58 + 1][57 + 1];\\n    \\n    int recursion(int n, int cur)\\n    {\\n        for (int i = 0; i < n + 1; i++) {\\n            for (int j = 0; j < cur + 1; j++) {\\n                if (i == 0 || j == 0) {\\n                    dp[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        for (int i = 1; i < n + 1; i++) {\\n            for (int j = 1; j < cur + 1; j++) {\\n                if (i < j) {\\n                    dp[i][j] = dp[i][j - 1];\\n                }\\n                else {\\n                    dp[i][j] = max(dp[i][j - 1], j * dp[i - j][j]);\\n                }\\n            }\\n        }\\n        \\n        return dp[n][cur];\\n    }\\n    \\n    int integerBreak(int n) \\n    {\\n        memset(dp, -1, sizeof(dp));\\n        return recursion(n, n - 1);    \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int recursion(int n, int cur)\\n    {\\n        // base\\n        if (n == 0 || cur == 0) {\\n            return 1;\\n        }\\n        // recurisve\\n        if (cur > n) {\\n            return recursion(n - 0, cur - 1);\\n        }\\n        else {\\n            return max(recursion(n - 0, cur - 1), cur * recursion(n - cur, cur));\\n        }\\n    }\\n    \\n    int integerBreak(int n) \\n    {\\n        return recursion(n, n - 1);    \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[58 + 1][57 + 1];\\n    \\n    int recursion(int n, int cur)\\n    {    \\n        if (n == 0 || cur == 0)\\n            return 1;\\n        if (dp[n][cur] != -1)\\n            return dp[n][cur];\\n        if (cur > n)\\n            return dp[n][cur] = recursion(n - 0, cur - 1);\\n        else\\n            return dp[n][cur] = max(recursion(n - 0, cur - 1), cur * recursion(n - cur, cur));\\n    }\\n    \\n    int integerBreak(int n) \\n    {\\n        memset(dp, -1, sizeof(dp));\\n        return recursion(n, n - 1);    \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[58 + 1][57 + 1];\\n    \\n    int recursion(int n, int cur)\\n    {\\n        for (int i = 0; i < n + 1; i++) {\\n            for (int j = 0; j < cur + 1; j++) {\\n                if (i == 0 || j == 0) {\\n                    dp[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        for (int i = 1; i < n + 1; i++) {\\n            for (int j = 1; j < cur + 1; j++) {\\n                if (i < j) {\\n                    dp[i][j] = dp[i][j - 1];\\n                }\\n                else {\\n                    dp[i][j] = max(dp[i][j - 1], j * dp[i - j][j]);\\n                }\\n            }\\n        }\\n        \\n        return dp[n][cur];\\n    }\\n    \\n    int integerBreak(int n) \\n    {\\n        memset(dp, -1, sizeof(dp));\\n        return recursion(n, n - 1);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484055,
                "title": "rz-o-n-2-dp-solution-and-o-n-solution-based-on-math",
                "content": "**1. DP solution ---> O(n ^ 2)**\\nWe are asked to break a positive integer n into 2 or more integers with maximum product. To find the optimal breakdown, as we know each breakdown divides the original problem into sub-problems, we can try a DP approach to first calculate the results of sub-problems. \\n\\nAssume f[i] means the maximum product we can get to breakdown i (i <= n). \\nStarting point: f[1] = 1\\nTransition equation:\\n```\\nfor i from 2 to n:\\n    for j from 1 to i / 2: ---> no need to check j > i / 2, becasue then i - j will be smaller than i / 2\\n        f[i] = max(f[i], max(j, f[j]) * max(i - j, f[i - j]))\\n```\\nSome notes:\\n1. The equation looks like a product of two numbers, how does it cover the cases that i is divided into more than 2 intergers? ---> the two factors in the multiplication can be f[j] and f[i - j], these two can further break down to a product of multiple integers\\n2. Why do we have j as one of the possible factors as in max(j, f[j])? ---> As per above equation, f[j] will be the product of at least two numbers, but in some cases, j itself can be bigger than all the possible product of its breakdowns, for example, when j == 2, f[j] == 1, j is greater than f[j].\\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        f = [0 for _ in range(n + 1)]\\n        f[1] = 1\\n        for i in range(2, n + 1):\\n            for j in range(1, i // 2 + 1):\\n                f[i] = max(f[i], max(j, f[j]) * max(i - j, f[i - j]))\\n        return f[n]\\n```\\n\\n**2. Math solution ---> O(n)**\\nTwo important obervations:\\n1. When n >= 4, by breaking it into 2 and n - 2, we get a product of 2 * (n - 2) == 2n - 4 >= 0. It means for any integer greater or equal to 4, we can further breaks it and it won\\'t make the product smaller. Also we know 1 will not help to make the product bigger, so we do not want to have any integer k >= 4 or k == 1 in our final breakdown. Then the only possible k becomes 2 or 3.\\n2. Since 3 + 3 == 2 + 2 + 2 == 6 and 3 * 3 > 2 * 2 * 2, as long as we have three 2s, we can change them to be two 3 to make the product bigger. So we will not have more than two 2 in the final breakdown.\\n\\nWith above observations, we would like to break n into as many 3 as possible until the remainder is less than or equal to 4. Why 4? Because 2 + 2 == 1 + 3 == 4 and 2 * 2 > 1 * 3, we want to break 4 into 2 * 2 instead of 3 * 1.\\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        if n == 2:\\n            return 1\\n        if n == 3:\\n            return 2\\n        \\n        res = 1\\n        while n > 4:\\n            res *= 3\\n            n -= 3\\n        return res * n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nfor i from 2 to n:\\n    for j from 1 to i / 2: ---> no need to check j > i / 2, becasue then i - j will be smaller than i / 2\\n        f[i] = max(f[i], max(j, f[j]) * max(i - j, f[i - j]))\\n```\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        f = [0 for _ in range(n + 1)]\\n        f[1] = 1\\n        for i in range(2, n + 1):\\n            for j in range(1, i // 2 + 1):\\n                f[i] = max(f[i], max(j, f[j]) * max(i - j, f[i - j]))\\n        return f[n]\\n```\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        if n == 2:\\n            return 1\\n        if n == 3:\\n            return 2\\n        \\n        res = 1\\n        while n > 4:\\n            res *= 3\\n            n -= 3\\n        return res * n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469325,
                "title": "c-recursion-memoization-tabulation-spaceoptimization",
                "content": "***Extension of Unbounded Knapsack***\\n\\n# Method - 1 [Recursion]\\n\\n![image](https://assets.leetcode.com/users/images/f5ffa5b9-b47a-474a-889f-ff3085b32c58_1661268384.0396595.png)\\n\\n**T->O(>>2^n) && S->O(n) [Recursion Stack Space]**\\n \\n\\t class Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int sum){\\n\\t\\t\\tif(i==1) return 1; \\n\\t\\t\\tint notpick=f(i-1,sum);\\n\\t\\t\\tint pick=0;\\n\\t\\t\\tif(sum>=i) pick=i*f(i,sum-i);\\n\\t\\t\\treturn max(pick,notpick);\\n\\t\\t}\\n\\n\\t\\tint integerBreak(int n){\\n\\t\\t\\treturn f(n-1,n);\\n\\t\\t}\\n\\t}; \\n\\t\\n![image](https://assets.leetcode.com/users/images/bc051183-4045-4935-9f04-67481e8677df_1661268798.458068.png)\\n\\n**T->O(n^2) && S->O(n^2) + O(n) [Recursion Stack Space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int sum,vector<vector<int>>& dp){\\n\\t\\t\\tif(i==1) return 1; \\n\\t\\t\\tif(dp[i][sum]!=-1) return dp[i][sum];\\n\\t\\t\\tint notpick=f(i-1,sum,dp);\\n\\t\\t\\tint pick=0;\\n\\t\\t\\tif(sum>=i) pick=i*f(i,sum-i,dp);\\n\\t\\t\\treturn dp[i][sum]=max(pick,notpick);\\n\\t\\t}\\n\\n\\t\\tint integerBreak(int n){\\n\\t\\t\\tvector<vector<int>> dp(n,vector<int>(n+1,-1));\\n\\t\\t\\treturn f(n-1,n,dp);\\n\\t\\t}\\n\\t}; \\n\\n# Method - 3 [Tabulation]\\n\\n![image](https://assets.leetcode.com/users/images/1d426630-e039-49d8-b9f3-1d0c5d884d69_1661269238.3084671.png)\\n\\n**T->O(n^2) && S->O(n^2)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint integerBreak(int n){\\n\\t\\t\\tvector<vector<int>> dp(n,vector<int>(n+1,0));\\n\\t\\t\\tfor(int j=0;j<n+1;j++) dp[1][j]=1;\\n\\t\\t\\tfor(int i=2;i<n;i++){\\n\\t\\t\\t\\tfor(int sum=0;sum<=n;sum++){\\n\\t\\t\\t\\t\\tint notpick=dp[i-1][sum];\\n\\t\\t\\t\\t\\tint pick=0;\\n\\t\\t\\t\\t\\tif(sum>=i) pick=i*dp[i][sum-i];\\n\\t\\t\\t\\t\\tdp[i][sum]=max(pick,notpick);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[n-1][n];\\n\\t\\t}\\n\\t}; \\n\\t\\n# Method - 4 [SpaceOptimization]\\t\\n![image](https://assets.leetcode.com/users/images/3662112e-7451-4735-a2a9-c7a4837dd840_1661269586.0845575.png)\\n\\n**T->O(n^2) && S->O(n)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint integerBreak(int n){\\n\\t\\t\\tvector<int> prev(n+1,1),curr(n+1,0);\\n\\t\\t\\tfor(int i=2;i<n;i++){\\n\\t\\t\\t\\tfor(int sum=0;sum<=n;sum++){\\n\\t\\t\\t\\t\\tint notpick=prev[sum];\\n\\t\\t\\t\\t\\tint pick=0;\\n\\t\\t\\t\\t\\tif(sum>=i) pick=i*curr[sum-i];\\n\\t\\t\\t\\t\\tcurr[sum]=max(pick,notpick);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tprev=curr;\\n\\t\\t\\t}\\n\\t\\t\\treturn prev[n];\\n\\t\\t}\\n\\t}; \\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int sum){\\n\\t\\t\\tif(i==1) return 1; \\n\\t\\t\\tint notpick=f(i-1,sum);\\n\\t\\t\\tint pick=0;\\n\\t\\t\\tif(sum>=i) pick=i*f(i,sum-i);\\n\\t\\t\\treturn max(pick,notpick);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 80757,
                "title": "python-solution-40ms-with-explanation",
                "content": "```\\nclass Solution(object):\\n    def integerBreak(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n == 2:\\n            return 1\\n        if n == 3:\\n            return 2\\n        list_3 = [3] * (n/3) # generate a list of 3\\n        mod_3 = n%3\\n        if mod_3 == 1: # if a 1 is left, then add it to the first element to get a 4\\n            list_3[0] += 1\\n        if mod_3 == 2: # if a 2 is left, then put it into the list\\n            list_3.append(2)\\n        return reduce(lambda a, b: a*b, list_3)\\n```\\nThe key for this problem is that we need to break the number to `2`s, `3`s and `4`s.\\nFirst we need to know a fact that,` if a,b > 3, |a-b| <= 1, then a*b>=a+b`. \\n\\nSo, `if n = a + b, a = a1+a2, b=b1+b2`, we should break n to `a1+a2+b1+b2, |a1-a2|<1 and |b1-b2|<1` instead of `a + b`, because `a1*a2>a, b1*b2>b`. However, we shall stop when we get a `3` or `2`, so what we shall do is to find the list of `3` and `2`.\\n\\nYou may have noticed why the `4` appeared. 'Cause if we break `4`, we get `2+2`, and `2+2 = 2*2`, so it's the same with the condition that we get two `2`s.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def integerBreak(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n == 2:\\n            return 1\\n        if n == 3:\\n            return 2\\n        list_3 = [3] * (n/3) # generate a list of 3\\n        mod_3 = n%3\\n        if mod_3 == 1: # if a 1 is left, then add it to the first element to get a 4\\n            list_3[0] += 1\\n        if mod_3 == 2: # if a 2 is left, then put it into the list\\n            list_3.append(2)\\n        return reduce(lambda a, b: a*b, list_3)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588868,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\nAfter considering all possibilities by hand for the first 10 values, one key observation is to greedily consume two 3s over three 2s because we want to maximize the product and for the sum of `6`, and we have two key candidates: `2 * 2 * 2 = 8 < 9 = 3 * 3`\\n```\\n6 = 2 + 2 + 2  \\uD83D\\uDC49  2 * 2 * 2 = 8\\n\\n6 = 3 + 3      \\uD83D\\uDC49      3 * 3 = 9\\n```\\n\\nWe can then use dynamic programming to greedily construct the `n`<sup>th</sup> best integer break value via the following base case and recurrence relation:\\n\\n**Base case:**\\n\\n`dp[i] = i` when `i <= 3`\\n\\nNote: this is contrary to the optimal solutions when `n <= 3`, so if `n <= 3` we return `n - 1`, ie. if `n == 2` then return `1` and if `n == 3` then return `2`.\\n\\n**Recurrence relation:**\\n\\nWe construct each optimal current `i`<sup>th</sup> solution by choosing the maximum of 2 possibilities:\\n\\n1. the previous optimal solution with sum two away from `i`, ie. `i - 2`, multiplied by `2` \\n2. the previous optimal solution with sum three away from `i`, ie. `i - 3`, multipled by `3`\\n\\nDP formula:\\n\\n`dp[i] = max(2 * dp[i - 2], 3 * dp[i - 3])`\\n\\n**Visualization:**\\n\\n![image](https://assets.leetcode.com/users/images/fdb3c316-13b8-4639-b901-59b6ad867c9f_1637456222.828826.png)\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun integerBreak(n: Int): Int {\\n        if (n <= 3)  // \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n            return n - 1\\n        fun go(i: Int = n): Int {\\n            if (i <= 3)\\n                return i\\n            return Math.max(2 * go(i - 2), 3 * go(i - 3))\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun integerBreak(n: Int): Int {\\n        if (n <= 3)  // \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n            return n - 1\\n        var m = mutableMapOf<Int, Int>()\\n        fun go(i: Int = n): Int {\\n            if (i <= 3)\\n                return i\\n            if (!m.contains(i))\\n                m[i] = Math.max(2 * go(i - 2), 3 * go(i - 3))\\n            return m[i]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun integerBreak(n: Int): Int {\\n        if (n <= 3)  // \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n            return n - 1\\n        var dp = IntArray(n + 1) { it }\\n        for (i in 4..n)\\n            dp[i] = Math.max(2 * dp[i - 2], 3 * dp[i - 3])\\n        return dp[n]\\n    }\\n}\\n```\\n\\n*Bottom-Up -- O(1) Memory via Sliding Window (a, b, c, d \\uD83D\\uDC48 dp[i - 3], dp[i - 2], dp[i - 1], dp[i])*\\n```\\nclass Solution {\\n    fun integerBreak(n: Int): Int {\\n        if (n <= 3)  // \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n            return n - 1\\n        var (a, b, c, d) = IntArray(4) { it + 1 }\\n        for (i in 4..n) {\\n            d = Math.max(2 * b, 3 * a)  // dp[i] = Math.max(2 * dp[i - 2], 3 * dp[i - 3])\\n            a = b; b = c; c = d         // \\uD83D\\uDC48 slide window\\n        }\\n        return d\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet integerBreak = n => {\\n    if (n <= 3)  // \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n        return n - 1;\\n    let go = (i = n) => {\\n        if (i <= 3)\\n            return i;\\n        return Math.max(2 * go(i - 2), 3 * go(i - 3));\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet integerBreak = (n, m = new Map()) => {\\n    if (n <= 3)  // \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n        return n - 1;\\n    let go = (i = n) => {\\n        if (i <= 3)\\n            return i;\\n        if (!m.has(i))\\n            m.set(i, Math.max(2 * go(i - 2), 3 * go(i - 3)));\\n        return m.get(i);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet integerBreak = n => {\\n    if (n <= 3)  // \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n        return n - 1;\\n    let dp = [...Array(n + 1).keys()];\\n    for (let i = 4; i <= n; ++i)\\n        dp[i] = Math.max(2 * dp[i - 2], 3 * dp[i - 3]);\\n    return dp[n];\\n};\\n```\\n\\n*Bottom-Up -- O(1) Memory via Sliding Window (a, b, c, d \\uD83D\\uDC48 dp[i - 3], dp[i - 2], dp[i - 1], dp[i])*\\n```\\nlet integerBreak = n => {\\n    if (n <= 3)  // \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n        return n - 1;\\n    let [a, b, c, d] = [...Array(4).keys()].map(it => it + 1);\\n    for (let i = 4; i <= n; ++i) {\\n        d = Math.max(2 * b, 3 * a);  // dp[i] = Math.max(2 * dp[i - 2], 3 * dp[i - 3]);\\n        a = b, b = c, c = d;         // \\uD83D\\uDC48 slide window\\n    }\\n    return d;\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        if n <= 3:  # \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n            return n - 1\\n        def go(i = n):\\n            if i <= 3:\\n                return i\\n            return max(2 * go(i - 2), 3 * go(i - 3))\\n        return go()\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        if n <= 3:  # \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n            return n - 1\\n        @cache\\n        def go(i = n):\\n            if i <= 3:\\n                return i\\n            return max(2 * go(i - 2), 3 * go(i - 3))\\n        return go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        if n <= 3:  # \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n            return n - 1\\n        dp = [i for i in range(n + 1)]\\n        for i in range(4, n + 1):\\n            dp[i] = max(2 * dp[i - 2], 3 * dp[i - 3])\\n        return dp[n]\\n```\\n\\n*Bottom-Up -- O(1) Memory via Sliding Window (a, b, c, d \\uD83D\\uDC48 dp[i - 3], dp[i - 2], dp[i - 1], dp[i])*\\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        if n <= 3:  # \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n            return n - 1\\n        a, b, c, d = [i + 1 for i in range(4)]\\n        for i in range(4, n + 1):\\n            d = max(2 * b, 3 * a)  # dp[i] = max(2 * dp[i - 2], 3 * dp[i - 3])\\n            a = b; b = c; c = d    # \\uD83D\\uDC48 slide window\\n        return d\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int)>;\\n    int integerBreak(int n) {\\n        if (n <= 3)  // \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n            return n - 1;\\n        fun go = [&](auto i) {\\n            if (i <= 3)\\n                return i;\\n            return max(2 * go(i - 2), 3 * go(i - 3));\\n        };\\n        return go(n);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int)>;\\n    using Map = unordered_map<int, int>;\\n    int integerBreak(int n, Map m = {}) {\\n        if (n <= 3)  // \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n            return n - 1;\\n        fun go = [&](auto i) {\\n            if (i <= 3)\\n                return i;\\n            if (m.find(i) == m.end())\\n                m[i] = max(2 * go(i - 2), 3 * go(i - 3));\\n            return m[i];\\n        };\\n        return go(n);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int integerBreak(int n) {\\n        if (n <= 3)  // \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n            return n - 1;\\n        VI dp(n + 1); iota(dp.begin(), dp.end(), 0);\\n        for (auto i{ 4 }; i <= n; ++i)\\n            dp[i] = max(2 * dp[i - 2], 3 * dp[i - 3]);\\n        return dp[n];\\n    }\\n};\\n```\\n\\n*Bottom-Up -- O(1) Memory via Sliding Window (a, b, c, d \\uD83D\\uDC48 dp[i - 3], dp[i - 2], dp[i - 1], dp[i])*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int integerBreak(int n) {\\n        if (n <= 3)  // \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n            return n - 1;\\n        auto [a, b, c, d] = make_tuple(1, 2, 3, 4);\\n        for (auto i{ 4 }; i <= n; ++i) {\\n            d = max(2 * b, 3 * a);  // dp[i] = max(2 * dp[i - 2], 3 * dp[i - 3])\\n            a = b, b = c, c = d;    // \\uD83D\\uDC48 slide window\\n        }\\n        return d;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n6 = 2 + 2 + 2  \\uD83D\\uDC49  2 * 2 * 2 = 8\\n\\n6 = 3 + 3      \\uD83D\\uDC49      3 * 3 = 9\\n```\n```\\nclass Solution {\\n    fun integerBreak(n: Int): Int {\\n        if (n <= 3)  // \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n            return n - 1\\n        fun go(i: Int = n): Int {\\n            if (i <= 3)\\n                return i\\n            return Math.max(2 * go(i - 2), 3 * go(i - 3))\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun integerBreak(n: Int): Int {\\n        if (n <= 3)  // \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n            return n - 1\\n        var m = mutableMapOf<Int, Int>()\\n        fun go(i: Int = n): Int {\\n            if (i <= 3)\\n                return i\\n            if (!m.contains(i))\\n                m[i] = Math.max(2 * go(i - 2), 3 * go(i - 3))\\n            return m[i]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun integerBreak(n: Int): Int {\\n        if (n <= 3)  // \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n            return n - 1\\n        var dp = IntArray(n + 1) { it }\\n        for (i in 4..n)\\n            dp[i] = Math.max(2 * dp[i - 2], 3 * dp[i - 3])\\n        return dp[n]\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun integerBreak(n: Int): Int {\\n        if (n <= 3)  // \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n            return n - 1\\n        var (a, b, c, d) = IntArray(4) { it + 1 }\\n        for (i in 4..n) {\\n            d = Math.max(2 * b, 3 * a)  // dp[i] = Math.max(2 * dp[i - 2], 3 * dp[i - 3])\\n            a = b; b = c; c = d         // \\uD83D\\uDC48 slide window\\n        }\\n        return d\\n    }\\n}\\n```\n```\\nlet integerBreak = n => {\\n    if (n <= 3)  // \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n        return n - 1;\\n    let go = (i = n) => {\\n        if (i <= 3)\\n            return i;\\n        return Math.max(2 * go(i - 2), 3 * go(i - 3));\\n    };\\n    return go();\\n};\\n```\n```\\nlet integerBreak = (n, m = new Map()) => {\\n    if (n <= 3)  // \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n        return n - 1;\\n    let go = (i = n) => {\\n        if (i <= 3)\\n            return i;\\n        if (!m.has(i))\\n            m.set(i, Math.max(2 * go(i - 2), 3 * go(i - 3)));\\n        return m.get(i);\\n    };\\n    return go();\\n};\\n```\n```\\nlet integerBreak = n => {\\n    if (n <= 3)  // \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n        return n - 1;\\n    let dp = [...Array(n + 1).keys()];\\n    for (let i = 4; i <= n; ++i)\\n        dp[i] = Math.max(2 * dp[i - 2], 3 * dp[i - 3]);\\n    return dp[n];\\n};\\n```\n```\\nlet integerBreak = n => {\\n    if (n <= 3)  // \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n        return n - 1;\\n    let [a, b, c, d] = [...Array(4).keys()].map(it => it + 1);\\n    for (let i = 4; i <= n; ++i) {\\n        d = Math.max(2 * b, 3 * a);  // dp[i] = Math.max(2 * dp[i - 2], 3 * dp[i - 3]);\\n        a = b, b = c, c = d;         // \\uD83D\\uDC48 slide window\\n    }\\n    return d;\\n};\\n```\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        if n <= 3:  # \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n            return n - 1\\n        def go(i = n):\\n            if i <= 3:\\n                return i\\n            return max(2 * go(i - 2), 3 * go(i - 3))\\n        return go()\\n```\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        if n <= 3:  # \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n            return n - 1\\n        @cache\\n        def go(i = n):\\n            if i <= 3:\\n                return i\\n            return max(2 * go(i - 2), 3 * go(i - 3))\\n        return go()\\n```\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        if n <= 3:  # \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n            return n - 1\\n        dp = [i for i in range(n + 1)]\\n        for i in range(4, n + 1):\\n            dp[i] = max(2 * dp[i - 2], 3 * dp[i - 3])\\n        return dp[n]\\n```\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        if n <= 3:  # \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n            return n - 1\\n        a, b, c, d = [i + 1 for i in range(4)]\\n        for i in range(4, n + 1):\\n            d = max(2 * b, 3 * a)  # dp[i] = max(2 * dp[i - 2], 3 * dp[i - 3])\\n            a = b; b = c; c = d    # \\uD83D\\uDC48 slide window\\n        return d\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int)>;\\n    int integerBreak(int n) {\\n        if (n <= 3)  // \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n            return n - 1;\\n        fun go = [&](auto i) {\\n            if (i <= 3)\\n                return i;\\n            return max(2 * go(i - 2), 3 * go(i - 3));\\n        };\\n        return go(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int)>;\\n    using Map = unordered_map<int, int>;\\n    int integerBreak(int n, Map m = {}) {\\n        if (n <= 3)  // \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n            return n - 1;\\n        fun go = [&](auto i) {\\n            if (i <= 3)\\n                return i;\\n            if (m.find(i) == m.end())\\n                m[i] = max(2 * go(i - 2), 3 * go(i - 3));\\n            return m[i];\\n        };\\n        return go(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int integerBreak(int n) {\\n        if (n <= 3)  // \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n            return n - 1;\\n        VI dp(n + 1); iota(dp.begin(), dp.end(), 0);\\n        for (auto i{ 4 }; i <= n; ++i)\\n            dp[i] = max(2 * dp[i - 2], 3 * dp[i - 3]);\\n        return dp[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int integerBreak(int n) {\\n        if (n <= 3)  // \\u2B50\\uFE0F recurrence relation\\'s base case != optimal solution\\n            return n - 1;\\n        auto [a, b, c, d] = make_tuple(1, 2, 3, 4);\\n        for (auto i{ 4 }; i <= n; ++i) {\\n            d = max(2 * b, 3 * a);  // dp[i] = max(2 * dp[i - 2], 3 * dp[i - 3])\\n            a = b, b = c, c = d;    // \\uD83D\\uDC48 slide window\\n        }\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 224403,
                "title": "c-0-ms-100-0-dp-iterative-solution-like-rod-cutting-problem",
                "content": "Fill `opt[0]....opt[n-1`  with maximum product you can get **with or without** dividing the integer for 0 to n-1. Then fill `opt[n]` with the constraint of dividing it atleast once.\\n```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        vector<int> opt(n+1, 0);\\n        opt[0] = 1;\\n        opt[1] = 1;\\n        \\n        for(int i = 2; i < n; i++){\\n            for(int j = 1; j <= i; j++){\\n                opt[i] = max(opt[i], j*opt[i-j]);\\n            }\\n        }\\n        \\n        opt[0] = 0;\\n        for(int j = 1; j <= n; j++){\\n            opt[n] = max(opt[n], j*opt[n-j]);\\n        }\\n        return opt[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        vector<int> opt(n+1, 0);\\n        opt[0] = 1;\\n        opt[1] = 1;\\n        \\n        for(int i = 2; i < n; i++){\\n            for(int j = 1; j <= i; j++){\\n                opt[i] = max(opt[i], j*opt[i-j]);\\n            }\\n        }\\n        \\n        opt[0] = 0;\\n        for(int j = 1; j <= n; j++){\\n            opt[n] = max(opt[n], j*opt[n-j]);\\n        }\\n        return opt[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 80903,
                "title": "1-liner-in-ruby-python",
                "content": "Ruby:\\n\\n    def integer_break(n)\\n      n < 4 ? n - 1 : 3**((n-2)/3) * ((n-2)%3+2)\\n    end\\n\\nPython:\\n\\n    def integerBreak(self, n):\\n        return n - 1 if n < 4 else 3**((n-2)/3) * ((n-2)%3+2)",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "Ruby:\\n\\n    def integer_break(n)\\n      n < 4 ? n - 1 : 3**((n-2)/3) * ((n-2)%3+2)\\n    end\\n\\nPython:\\n\\n    def integerBreak(self, n):\\n        return n - 1 if n < 4 else 3**((n-2)/3) * ((n-2)%3+2)",
                "codeTag": "Python3"
            },
            {
                "id": 80827,
                "title": "dp-solution-but-with-explanation",
                "content": "       int[] dp = new int[n+1];\\n        dp[1] = 1;\\n        for(int i = 2; i <= n; i++) \\n            for(int j = 1; j < i; j++) \\n                dp[i] = Math.max(dp[i], (Math.max(j,dp[j]) * Math.max(i-j,dp[i-j])));\\n        \\n        return dp[n];\\n\\n> dp[i] says that what the maximum product we can get for this number\\n\\nNow, how to get the recursion part?\\n\\n\\nOuter loop is being used build the values of all other numbers which will be required to get to the solution and our solution will be available in dp[n]\\n\\nWe will check all the possible combination present, which is being accomplished by second loop.\\nSo, we are looping from 1 till i and keep checking for the maximum value\\n\\nExample: i = 5 , so we will check for j = 1, 2, 3, 4 \\n\\nNow, either we can pick the number itself or we can pick the maximum we can get from combinational products, which is accomplished by Math.max(j,dp[j])\\nThen we will left with a number which is equal to i - j, say we were looping for j =3 and i = 5, then we are picking j =3 (and checking if we should pick 3 or its dp solution) then the other part of 5 will be (i-j = 5 - 3 = 2) so will check the same logic for 2 and then will get their product.\\n\\nAnd keep updating our dp[i] with different position of j.\\n\\nFurther second loop can optimized to \\nfor(int j = 1; 2*j < i; j++) \\nfor obvious reason to remove the duplicate checks\\n\\nHope this helps",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "       int[] dp = new int[n+1];\\n        dp[1] = 1;\\n        for(int i = 2; i <= n; i++) \\n            for(int j = 1; j < i; j++) \\n                dp[i] = Math.max(dp[i], (Math.max(j,dp[j]) * Math.max(i-j,dp[i-j])));\\n        \\n        return dp[n];\\n\\n> dp[i] says that what the maximum product we can get for this number\\n\\nNow, how to get the recursion part?\\n\\n\\nOuter loop is being used build the values of all other numbers which will be required to get to the solution and our solution will be available in dp[n]\\n\\nWe will check all the possible combination present, which is being accomplished by second loop.\\nSo, we are looping from 1 till i and keep checking for the maximum value\\n\\nExample: i = 5 , so we will check for j = 1, 2, 3, 4 \\n\\nNow, either we can pick the number itself or we can pick the maximum we can get from combinational products, which is accomplished by Math.max(j,dp[j])\\nThen we will left with a number which is equal to i - j, say we were looping for j =3 and i = 5, then we are picking j =3 (and checking if we should pick 3 or its dp solution) then the other part of 5 will be (i-j = 5 - 3 = 2) so will check the same logic for 2 and then will get their product.\\n\\nAnd keep updating our dp[i] with different position of j.\\n\\nFurther second loop can optimized to \\nfor(int j = 1; 2*j < i; j++) \\nfor obvious reason to remove the duplicate checks\\n\\nHope this helps",
                "codeTag": "Unknown"
            },
            {
                "id": 1723674,
                "title": "c-simple-solution-for-given-range-in-o-1",
                "content": "\\n**a>2 and b>2 \\na*b > a+b**\\n\\nEvery number >=4 can be reduced to 2 and 3.\\n\\nAfter writing the maximum product for 7,8,9,10, we can see a pattern that, if for a given number maximum product exists and each of the maximum term can be decomposed to multiples of 2 and 3\\n\\nas we know for a product to be maximum the maximum number should be more number of times, in our case it is 3 so we try to maximise for no of 3s \\n\\nfor number like 13 we have to make a way around for it to fit, so we take 13%3==1, if some how we try to make this value even, so that we can take 2s according to it. A clear observation would give us that if we can add one three to it, it will make 2 two\\'s, so :\\nif n%3==1 we reduce our 3s and add it to 2s\\nif n%3==2 we can take one 2\\n\\nfor 13:\\n13/3=4\\nwe have 4 3s  3,3,3,3 and 1 as stated above we convert this 1 to even by adding a 3\\nso above coverts to 3,3,3 and 4 (2,2,)\\n3,3,4 == 3,3,2,2 (2*2==4)\\n\\n\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        if(n==2)return 1;\\n        if(n==3)return 2;\\n        int two=0;\\n        int three=n/3;\\n        if(n%3==1)\\n        {\\n            three--;\\n        }\\n        two= (n-three*3)/2;\\n        \\n        return pow(3,three)*pow(2,two);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        if(n==2)return 1;\\n        if(n==3)return 2;\\n        int two=0;\\n        int three=n/3;\\n        if(n%3==1)\\n        {\\n            three--;\\n        }\\n        two= (n-three*3)/2;\\n        \\n        return pow(3,three)*pow(2,two);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735892,
                "title": "c-memoized-solution",
                "content": "Consider n as the weight of the knapsack, and you\\'ve to maximize the product of the values you choose (1 to n-1). Three choices exist for every item in the value array - either choose and continue, choose again recursively, do not choose.\\n```\\nint t[60][60];\\nint maxproduct(vector<int> val, int n, int W){\\n\\tif(!W) return 1;\\n\\tif(!n) return 0;\\n\\tif(t[n][W]!=-1)  return t[n][W];\\n\\tif(val[n-1]<=W){\\n\\t\\treturn t[n][W]=max(val[n-1]*maxproduct(val,n,W-val[n-1]),\\n\\t\\t\\t            \\t        maxproduct(val,n-1,W));\\n\\t}\\n\\treturn t[n][W] = maxproduct(val,n-1,W);\\n}\\n\\nint integerBreak(int n) {\\n\\tvector<int> val;\\n\\tmemset(t,-1,sizeof(t));\\n\\tfor(int i=1;i<n;i++)\\n\\t\\tval.push_back(i);\\n\\treturn maxproduct(val,n-1,n);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint t[60][60];\\nint maxproduct(vector<int> val, int n, int W){\\n\\tif(!W) return 1;\\n\\tif(!n) return 0;\\n\\tif(t[n][W]!=-1)  return t[n][W];\\n\\tif(val[n-1]<=W){\\n\\t\\treturn t[n][W]=max(val[n-1]*maxproduct(val,n,W-val[n-1]),\\n\\t\\t\\t            \\t        maxproduct(val,n-1,W));\\n\\t}\\n\\treturn t[n][W] = maxproduct(val,n-1,W);\\n}\\n\\nint integerBreak(int n) {\\n\\tvector<int> val;\\n\\tmemset(t,-1,sizeof(t));\\n\\tfor(int i=1;i<n;i++)\\n\\t\\tval.push_back(i);\\n\\treturn maxproduct(val,n-1,n);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3430074,
                "title": "3-approach-dp-linear-formula-based",
                "content": "\\n# Code 1\\nDynamic programming approach \\nTime Complexity  - O(N*2)\\nSpace Complexity - O(N)\\n```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        int[] dp = new int [n+1];\\n        dp[0]=0;\\n        dp[1]=0;\\n        dp[2]=1;\\n        for (int i=3;i<=n;i++)\\n            for (int j=1;j<=i;j++)\\n                dp[i] = Math.max(dp[i], j*Math.max(dp[i-j],i-j)); \\n                \\n        return dp[n];\\n    }\\n}\\n```\\n\\n\\n# Code 2\\nn = 1 => we get max value only when we divide 1 into 0 and 1\\nn = 2 => we get max value only when we divide 2 into 1 and 1\\nn = 3 => we get max value only when we divide 3 into 1 and 2\\nn = 4 => we get max value only when we divide 4 into 2 and 2\\nn = 5 => we get max value only when we divide 5 into 2 and 3\\nn = 6 => we get max value only when we divide 6 into 3 and 3\\nn = 7 => we get max value only when we divide 7 into 4 and 3\\nn = 8 => we get max value only when we divide 8 into 2, 3 and 3\\nn = 9 => we get max value only when we divide 9 into 3, 3 and 3\\nn = 10 => we get max value only when we divide 10 into 4, 3 and 3\\n\\nFrom here we can see that upto n=7 we have different values but after n=7 we can just multiply 3 to n-3 to get the max value.\\n\\n\\nTime Complexity : O(N)\\nSpace Complexity : O(1)\\n```\\nclass Solution {\\n    public int integerBreak(int n)\\n    {\\n        if (n == 2 || n == 3) return n-1;\\n        int result = 1;\\n        while (n>4){\\n            n -= 3;\\n            result *= 3;\\n        }\\n        return (n*result);\\n    }\\n}\\n```\\n\\n# Code 3\\n\\nFrom code 2 Explanation we can simplify code more  \\n1. n<=3  => ans =n-1\\n2. n%3 is 1 => maximum value should be 4 * 3**((n/3 - 1)\\n3. n%3 is 2 => maximum value should be 2 * 3**(n/3)\\n4. n%3 is 0 => maximum value should be 3**(n/3)\\nSimple Mathematics\\nTime Complexity : O(1)\\nSpace Complexity : O(1)\\n```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        if(n<=3)\\n            return n-1;\\n        else if(n%3==1)\\n            return pow(3,n/3 - 1)*4;\\n        else if(n%3==2)\\n            return 2*pow(3,n/3);\\n        else\\n            return pow(3, n/3);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        int[] dp = new int [n+1];\\n        dp[0]=0;\\n        dp[1]=0;\\n        dp[2]=1;\\n        for (int i=3;i<=n;i++)\\n            for (int j=1;j<=i;j++)\\n                dp[i] = Math.max(dp[i], j*Math.max(dp[i-j],i-j)); \\n                \\n        return dp[n];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int integerBreak(int n)\\n    {\\n        if (n == 2 || n == 3) return n-1;\\n        int result = 1;\\n        while (n>4){\\n            n -= 3;\\n            result *= 3;\\n        }\\n        return (n*result);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        if(n<=3)\\n            return n-1;\\n        else if(n%3==1)\\n            return pow(3,n/3 - 1)*4;\\n        else if(n%3==2)\\n            return 2*pow(3,n/3);\\n        else\\n            return pow(3, n/3);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 80728,
                "title": "c-o-1-solution",
                "content": "    class Solution {\\n    public:\\n        int integerBreak(int n) {\\n            if (n==2)\\n                return 1;\\n            if (n==3)\\n                return 2;\\n            if (n%3 == 0)\\n            {\\n                return pow(3,n/3);\\n            }\\n            if (n%3 == 2)\\n            {\\n                return pow(3,n/3)*2;\\n            }\\n            return pow(3,(n/3)-1)*4;\\n            \\n        }\\n    };\\n    /*\\n            2 - 1,1\\n            3 - 1,2\\n            4 - 2,2\\n            5 - 3,2\\n            6 - 3,3\\n            7 - 3,4\\n            8 - 3,3,2\\n            9 - 3,3,3\\n            10 - 3,3,4\\n            11 - 3,3,3,2\\n            12 - 3,3,3,3\\n            13 - 3,3,3,4\\n*/",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int integerBreak(int n) {\\n            if (n==2)\\n                return 1;\\n            if (n==3)\\n                return 2;\\n            if (n%3 == 0)\\n            {\\n                return pow(3,n/3);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3820939,
                "title": "c-apni-bhasha-mein-seedhi-baat-no-bakwaas-dp-interview-prep",
                "content": "# Intuition & Approach\\n- Explained in the code\\n\\n# Code\\n```\\nclass Solution\\n{\\n   \\tLOGIC\\n\\n   \\tKARNA KYA HAIN\\u2753\\n   \\t1. Integer \"n\" diya hain isko sum of \"k positive integers\" mein todna\\n   \\thain.\\n   \\t2. k should always be \">=2\".Matlab->Jyada se jyada numbers mein break karo.\\n   \\t3. Jo bhi k number ke sets banenge unme se max product wala set lena hain.\\n\\n   \\tINTUITION &APPROACH\\n   \\t1. Ab apne ko itna to samajh aa raha hain ki \"n ko bahut saare different\\n   \\tsets mein toda ja sakta hain\".\\n   \\t2. Hame lekin max prod wala hi set lena hain.\\n   \\t3. So we have \"many choices\" to make sets.\\n   \\t4. Jahan yeh \"choice shabd aagaya\" wahan lagega \"Recusion\".\\n   \\t5. Ab Recurrence Relation\\u2753\\n   \\t- Maximize karna hain to matlab har recursion mein \"max\" return karenge.\\n   \\t- Ab har num jo \"<=n/2\" hoga usse n ko break karenge .\\n   \\t- Why n/2\\u2753Kyoki we have to make sure ki \"jyada se jyada k value ho\".\\n   \\t- Observation ke hisab se jitne jyada numbers mein breaked utna bada prod.\\n   \\t- Agar \">n/2\" hoga to bade bade num mein break karna padega isse k ki val\\n   \\tchoti ho jayegi.\\n   \\t- \"BASE-CASE\":n==1->return 1\\n   \\t- So loop lagega \"1 to n/2\" tak ka aur har i ke liye max nikalenge. So,\\n   \\t\"res=max(res,i* Recursion(n-i))\"\\n   \\tWhere \"Recursion(n-i)\" means the max product for n-i value.\\n   \\t6. Ab kaafi overlapping problems hongi so to resolve this we will use DP.\\n   \\t7. RECURSION -> MEMOIZATION -> TABULATION\\n   \\t8. Memoization Steps\\u2753\\n   \\t- See what parameter is changing decide the dp dimension .->Here only 1\\n   \\tparam is changing so \"1D array\".\\n   \\t- In recurrence relation store the max val in dp[n]\\n   \\t- Check if any dp[x] has been previously solved.\\n   \\t9. Tabulation Steps\\n   \\t- Replace Recurrence function with dp[]\\n   \\t- Declare base case in dp array.\\n   \\t- The recursion loop will be replaced by for loop.\\n   \\t \"Meaning of dp[i]\"\\u2753-> It denotes the max product for digits in which\\n   \\tthe num i is divided.\\n//==============================================================================================================================\\n    public:\\n         //MEMOIZATION    \\n        int Memoization(int n, vector<int> &dp)\\n        {\\n            if (n == 1) return 1;\\n           \\t//BASE CASE\\n            if (dp[n] != -1) return dp[n];\\n           \\t//Already solved\\n            int ans = n;\\n           \\t//Could be INT_MIN also\\n            for (int i = 1; i <= n / 2; i++)\\n            {\\n                ans = max(ans, i* Memoization(n - i, dp));\\n               \\t//Finding max among sets\\n            }\\n            return dp[n] = ans;\\n           \\t//Storing the max val\\n        }\\n    int integerBreak(int n)\\n    {\\n        if (n < 4) return n - 1;\\n       \\t//Precalculated\\n        vector<int> dp(n + 1, -1);\\n       \\t//As only one param is changing\\n        return Memoization(n, dp);\\n    }\\n\\n   \\t//TABULATION\\n    int integerBreak(int n)\\n    {\\n        if (n < 4) return n - 1;\\n        vector<int> dp(n + 1, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n       \\t//BASE cases\\n        for (int num = 1; num <= n; num++)\\n        {\\n           \\t//Iterating for num 1 to n\\n            for (int div = 1; div <= num; div++)\\n           \\t//Calculating max prod for every num\\n            {\\n                dp[num] = max(dp[num], div *dp[num - div]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity:$O(N^2)$\\n\\n- Space complexity:$O(N)$\\n\\nIf you *like* \\uD83D\\uDC4D this solution do *upvote* \\u2B06\\uFE0F and if there is any *improvement or suggestion* do mention it in the *comment* section \\uD83D\\uDE0A.\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/1b604300-df68-46aa-a267-71f38463bb89_1684820402.7869222.jpeg\" width=\\'350\\' alt=\"Upvote Image\">\\n</p>",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\n   \\tLOGIC\\n\\n   \\tKARNA KYA HAIN\\u2753\\n   \\t1. Integer \"n\" diya hain isko sum of \"k positive integers\" mein todna\\n   \\thain.\\n   \\t2. k should always be \">=2\".Matlab->Jyada se jyada numbers mein break karo.\\n   \\t3. Jo bhi k number ke sets banenge unme se max product wala set lena hain.\\n\\n   \\tINTUITION &APPROACH\\n   \\t1. Ab apne ko itna to samajh aa raha hain ki \"n ko bahut saare different\\n   \\tsets mein toda ja sakta hain\".\\n   \\t2. Hame lekin max prod wala hi set lena hain.\\n   \\t3. So we have \"many choices\" to make sets.\\n   \\t4. Jahan yeh \"choice shabd aagaya\" wahan lagega \"Recusion\".\\n   \\t5. Ab Recurrence Relation\\u2753\\n   \\t- Maximize karna hain to matlab har recursion mein \"max\" return karenge.\\n   \\t- Ab har num jo \"<=n/2\" hoga usse n ko break karenge .\\n   \\t- Why n/2\\u2753Kyoki we have to make sure ki \"jyada se jyada k value ho\".\\n   \\t- Observation ke hisab se jitne jyada numbers mein breaked utna bada prod.\\n   \\t- Agar \">n/2\" hoga to bade bade num mein break karna padega isse k ki val\\n   \\tchoti ho jayegi.\\n   \\t- \"BASE-CASE\":n==1->return 1\\n   \\t- So loop lagega \"1 to n/2\" tak ka aur har i ke liye max nikalenge. So,\\n   \\t\"res=max(res,i* Recursion(n-i))\"\\n   \\tWhere \"Recursion(n-i)\" means the max product for n-i value.\\n   \\t6. Ab kaafi overlapping problems hongi so to resolve this we will use DP.\\n   \\t7. RECURSION -> MEMOIZATION -> TABULATION\\n   \\t8. Memoization Steps\\u2753\\n   \\t- See what parameter is changing decide the dp dimension .->Here only 1\\n   \\tparam is changing so \"1D array\".\\n   \\t- In recurrence relation store the max val in dp[n]\\n   \\t- Check if any dp[x] has been previously solved.\\n   \\t9. Tabulation Steps\\n   \\t- Replace Recurrence function with dp[]\\n   \\t- Declare base case in dp array.\\n   \\t- The recursion loop will be replaced by for loop.\\n   \\t \"Meaning of dp[i]\"\\u2753-> It denotes the max product for digits in which\\n   \\tthe num i is divided.\\n//==============================================================================================================================\\n    public:\\n         //MEMOIZATION    \\n        int Memoization(int n, vector<int> &dp)\\n        {\\n            if (n == 1) return 1;\\n           \\t//BASE CASE\\n            if (dp[n] != -1) return dp[n];\\n           \\t//Already solved\\n            int ans = n;\\n           \\t//Could be INT_MIN also\\n            for (int i = 1; i <= n / 2; i++)\\n            {\\n                ans = max(ans, i* Memoization(n - i, dp));\\n               \\t//Finding max among sets\\n            }\\n            return dp[n] = ans;\\n           \\t//Storing the max val\\n        }\\n    int integerBreak(int n)\\n    {\\n        if (n < 4) return n - 1;\\n       \\t//Precalculated\\n        vector<int> dp(n + 1, -1);\\n       \\t//As only one param is changing\\n        return Memoization(n, dp);\\n    }\\n\\n   \\t//TABULATION\\n    int integerBreak(int n)\\n    {\\n        if (n < 4) return n - 1;\\n        vector<int> dp(n + 1, 0);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n       \\t//BASE cases\\n        for (int num = 1; num <= n; num++)\\n        {\\n           \\t//Iterating for num 1 to n\\n            for (int div = 1; div <= num; div++)\\n           \\t//Calculating max prod for every num\\n            {\\n                dp[num] = max(dp[num], div *dp[num - div]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830343,
                "title": "o-1-tc-1-10-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:1\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:1\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        if(n<=3):\\n            return n-1\\n        n3=n//3\\n        r3=n%3\\n        if(r3==0):\\n            return 3**n3\\n        if(r3==1):\\n            r3=4\\n            n3-=1\\n        return r3*(3**n3)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        if(n<=3):\\n            return n-1\\n        n3=n//3\\n        r3=n%3\\n        if(r3==0):\\n            return 3**n3\\n        if(r3==1):\\n            r3=4\\n            n3-=1\\n        return r3*(3**n3)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345769,
                "title": "dp-unbounded-knapsack-top-down-and-bottom-up-c",
                "content": "**TOP DOWN DP - MEMOIZATION** \\n```\\nclass Solution {\\npublic: \\n    \\n    int dp[60][60]; \\n    \\n    int integerBreak(int n) { \\n        \\n        vector<int> nums; \\n        \\n        for(int i = 1; i <= n/2; i++) { \\n            nums.push_back(i);\\n        } \\n        \\n        if (n % 2 != 0) { \\n            nums.push_back((n/2) + 1);\\n        }\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        return UKS(nums, n, nums.size());\\n    } \\n    \\n    int UKS(vector<int> &nums, int W, int n) { \\n        \\n        if (W == 0) { \\n            return 1;\\n        }   \\n        \\n        else if (n == 0) { \\n            return 0;\\n        }\\n        \\n        else if (dp[n][W] != -1) { \\n            return dp[n][W];\\n        } \\n        \\n        else if (nums[n-1] > W) { \\n            return dp[n][W] = UKS (nums, W, n-1);\\n        }\\n        \\n        return dp[n][W] = max(nums[n-1] * UKS(nums, W - nums[n-1], n), UKS(nums, W, n-1));\\n    }\\n};\\n``` \\n\\n**BOTTOM-UP TABULATION** \\n\\n```\\nclass Solution {\\npublic: \\n    \\n    int dp[60][60]; \\n    \\n    int integerBreak(int n) { \\n        \\n        vector<int> nums; \\n        \\n        for(int i = 1; i <= n/2; i++) { \\n            nums.push_back(i);\\n        } \\n        \\n        if (n % 2 != 0) { \\n            nums.push_back((n/2) + 1);\\n        }\\n        \\n        int s = nums.size(); \\n        \\n        int dp[s+1][n+1]; \\n        \\n        for (int i = 0; i <= s; i++) { \\n            \\n            for (int j = 0; j <= n; j++) {  \\n                \\n                if (i == 0) { \\n                    dp[i][j] = 0;\\n                }  \\n                \\n                else if (j == 0) { \\n                    dp[i][j] = 1;\\n                }\\n                \\n                else if (nums[i-1] <= j) { \\n                    dp[i][j] = max(nums[i-1] * dp[i][j-nums[i-1]], dp[i-1][j]);\\n                } \\n                \\n                else { \\n                    dp[i][j] = dp[i-1][j];\\n                }\\n            }\\n        }\\n        \\n        return dp[s][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    \\n    int dp[60][60]; \\n    \\n    int integerBreak(int n) { \\n        \\n        vector<int> nums; \\n        \\n        for(int i = 1; i <= n/2; i++) { \\n            nums.push_back(i);\\n        } \\n        \\n        if (n % 2 != 0) { \\n            nums.push_back((n/2) + 1);\\n        }\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        return UKS(nums, n, nums.size());\\n    } \\n    \\n    int UKS(vector<int> &nums, int W, int n) { \\n        \\n        if (W == 0) { \\n            return 1;\\n        }   \\n        \\n        else if (n == 0) { \\n            return 0;\\n        }\\n        \\n        else if (dp[n][W] != -1) { \\n            return dp[n][W];\\n        } \\n        \\n        else if (nums[n-1] > W) { \\n            return dp[n][W] = UKS (nums, W, n-1);\\n        }\\n        \\n        return dp[n][W] = max(nums[n-1] * UKS(nums, W - nums[n-1], n), UKS(nums, W, n-1));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic: \\n    \\n    int dp[60][60]; \\n    \\n    int integerBreak(int n) { \\n        \\n        vector<int> nums; \\n        \\n        for(int i = 1; i <= n/2; i++) { \\n            nums.push_back(i);\\n        } \\n        \\n        if (n % 2 != 0) { \\n            nums.push_back((n/2) + 1);\\n        }\\n        \\n        int s = nums.size(); \\n        \\n        int dp[s+1][n+1]; \\n        \\n        for (int i = 0; i <= s; i++) { \\n            \\n            for (int j = 0; j <= n; j++) {  \\n                \\n                if (i == 0) { \\n                    dp[i][j] = 0;\\n                }  \\n                \\n                else if (j == 0) { \\n                    dp[i][j] = 1;\\n                }\\n                \\n                else if (nums[i-1] <= j) { \\n                    dp[i][j] = max(nums[i-1] * dp[i][j-nums[i-1]], dp[i-1][j]);\\n                } \\n                \\n                else { \\n                    dp[i][j] = dp[i-1][j];\\n                }\\n            }\\n        }\\n        \\n        return dp[s][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940093,
                "title": "dp-memoization-approach",
                "content": "```\\nvar integerBreak = function(n) {\\n    let memo = new Map()\\n    \\n    function dp(n){\\n        if(n == 1 || n == 2) return 1\\n        if(memo.has(n)) return memo.get(n)\\n        \\n        let q = 0\\n        for(let i=1; i<=n/2; i++){\\n            q = Math.max(q, i * Math.max((n-i),dp(n-i)))\\n        }\\n        memo.set(n, q)\\n        return q\\n    }\\n    return dp(n)\\n};\\n```\\n\\nThe time complexity is O(n^2). \\nThere are `n/2` loops for the 1st recursive call, `(n-1)/2` for the 2nd call, and so on. \\nTherefore the total number of loops is: ` n/2 + (n-1)/2 + (n-2)/2 + (n-3)/2 + (n-4)/2 + ... + (n-(n-3))/2` \\nThis sum evaluates to an upper bound of: `(n*2 - n(n+1)/2)/2` \\nwhich simplifies to `(n^2-n)/4`. Which is O(n^2)",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nvar integerBreak = function(n) {\\n    let memo = new Map()\\n    \\n    function dp(n){\\n        if(n == 1 || n == 2) return 1\\n        if(memo.has(n)) return memo.get(n)\\n        \\n        let q = 0\\n        for(let i=1; i<=n/2; i++){\\n            q = Math.max(q, i * Math.max((n-i),dp(n-i)))\\n        }\\n        memo.set(n, q)\\n        return q\\n    }\\n    return dp(n)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 843882,
                "title": "java-similar-to-unbounded-knapsack-brute-force-recursion-with-memoization-2d-dynamic-programming",
                "content": "Method 1 : Brute Force\\nTime   Complexity : O(2^n)\\nSpace Complexity : O(n)\\n```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        return unboundedKnapsack(n, n-1);\\n    }\\n    public int unboundedKnapsack(int n, int curr) {\\n        if(n<0 || curr < 0)\\n            return 0;\\n        if(n == 0)\\n            return 1;\\n        if(curr == 0)\\n            return 0;\\n        if(n< curr)\\n            return unboundedKnapsack(n, curr-1);\\n        else \\n            return Math.max(unboundedKnapsack(n, curr-1), curr*unboundedKnapsack(n-curr, curr));    \\n    }\\n}\\n```\\n\\nMethod 2 : Recursion With Memoization\\nTime   Complexity : O(n * n)\\nSpace Complexity : O(n * n)\\n```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        Integer [][] dp = new Integer[n+1][n+1];\\n        return unboundedKnapsack(n, n-1, dp);\\n    }\\n    public int unboundedKnapsack(int n, int curr, Integer [][] dp) {\\n        if(dp[n][curr] != null)\\n            return dp[n][curr];\\n        if(n<0 || curr < 0)\\n            return 0;\\n        if(n == 0)\\n            return dp[n][curr] = 1;\\n        if(curr == 0)\\n            return dp[n][curr] = 0; \\n        if(n< curr) \\n            return dp[n][curr] = unboundedKnapsack(n, curr-1, dp);\\n        else \\n            return dp[n][curr] = Math.max(unboundedKnapsack(n, curr-1, dp), curr*unboundedKnapsack(n-curr, curr, dp));    \\n    }\\n}\\n```\\n\\nMethod 3 : 2D Dynamic Programming \\nTime   Complexity : O(n * n)\\nSpace Complexity : O(n * n)\\n```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        if (n == 2)\\n            return 1;\\n        if (n == 3)\\n            return 2;\\n        int [][] dp = new int[n+1][n+1];\\n        for(int i=0;i<dp.length;i++)\\n            dp[i][0] = 0;\\n        for(int j=0;j<dp[0].length;j++)\\n            dp[0][j] = 1;\\n        for(int i=1;i<dp.length;i++) {\\n            for(int j=1;j<dp[0].length;j++) {\\n                if(i<j) \\n                    dp[i][j] = dp[i][j-1];\\n                else \\n                    dp[i][j] = Math.max(dp[i][j-1], j*dp[i-j][j]);\\n            }\\n        }\\n        return dp[n][n];\\n    } \\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        return unboundedKnapsack(n, n-1);\\n    }\\n    public int unboundedKnapsack(int n, int curr) {\\n        if(n<0 || curr < 0)\\n            return 0;\\n        if(n == 0)\\n            return 1;\\n        if(curr == 0)\\n            return 0;\\n        if(n< curr)\\n            return unboundedKnapsack(n, curr-1);\\n        else \\n            return Math.max(unboundedKnapsack(n, curr-1), curr*unboundedKnapsack(n-curr, curr));    \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        Integer [][] dp = new Integer[n+1][n+1];\\n        return unboundedKnapsack(n, n-1, dp);\\n    }\\n    public int unboundedKnapsack(int n, int curr, Integer [][] dp) {\\n        if(dp[n][curr] != null)\\n            return dp[n][curr];\\n        if(n<0 || curr < 0)\\n            return 0;\\n        if(n == 0)\\n            return dp[n][curr] = 1;\\n        if(curr == 0)\\n            return dp[n][curr] = 0; \\n        if(n< curr) \\n            return dp[n][curr] = unboundedKnapsack(n, curr-1, dp);\\n        else \\n            return dp[n][curr] = Math.max(unboundedKnapsack(n, curr-1, dp), curr*unboundedKnapsack(n-curr, curr, dp));    \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        if (n == 2)\\n            return 1;\\n        if (n == 3)\\n            return 2;\\n        int [][] dp = new int[n+1][n+1];\\n        for(int i=0;i<dp.length;i++)\\n            dp[i][0] = 0;\\n        for(int j=0;j<dp[0].length;j++)\\n            dp[0][j] = 1;\\n        for(int i=1;i<dp.length;i++) {\\n            for(int j=1;j<dp[0].length;j++) {\\n                if(i<j) \\n                    dp[i][j] = dp[i][j-1];\\n                else \\n                    dp[i][j] = Math.max(dp[i][j-1], j*dp[i-j][j]);\\n            }\\n        }\\n        return dp[n][n];\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 80751,
                "title": "a-clear-math-proof-of-the-algorithm",
                "content": "It is well-known that the algorithm should return the result by breaking n into factors 2 or 3, and also many other authors have been revealed the reasons for that. However, there are still some ambiguous questions about their explanations. For example, why does n have to break down as n=x+x+...+x ?, and why choosing 3 as factors is better than 2?\\n\\nHence, here I want to share a more strict proof of the correctness of the algorithm.\\n\\n/**\\n\\t\\t\\t * Given n, let m be the number of summands so that a1+a2+...+am =\\n\\t\\t\\t * n. By the Inequality of Arithmetic and Geometric Means, we have:\\n\\t\\t\\t * \\n\\t\\t\\t * a1 * a2 * ... * am <= (n/m)^m (i.e., power(n/m, m)) and that\\n\\t\\t\\t * equality holds iff (if and only if) a1=a2=...=am.\\n\\t\\t\\t * \\n\\t\\t\\t * Now let x=n/m, and consider the function f(x)=x^(n/x), we are\\n\\t\\t\\t * going to find its max. Let y=ln[f(x)]=(n/x) * ln(x). Then:\\n\\t\\t\\t * \\n\\t\\t\\t * y' = -(n/x^2) * ln(x) + (n/x) * (1/x) = (n/x^2) * [ln(e)-ln(x)],\\n\\t\\t\\t * \\n\\t\\t\\t * where e=exp(1)=2.71828... . Since ln() is an increasing function,\\n\\t\\t\\t * so\\n\\t\\t\\t * \\n\\t\\t\\t * f(x) is increasing iff y is increasing iff y'>0 iff\\n\\t\\t\\t * [ln(e)-ln(x)]>0 iff x<e; and is decreasing iff x>e; and is\\n\\t\\t\\t * maximized when x=e.\\n\\t\\t\\t * \\n\\t\\t\\t * Since x is an integer, x=2 or 3 would maximize f(x). Now let's\\n\\t\\t\\t * check which of f(2), f(3) is bigger.\\n\\t\\t\\t * \\n\\t\\t\\t * Since ln[f(x)]=n * ln(x)/x, and ln(2)/2 < ln(3)/3, so f(3) is the\\n\\t\\t\\t * max.\\n\\t\\t\\t * \\n\\t\\t\\t * In order words, f(x) is maximized at 3 among all !integer! x.\\n\\t\\t\\t * Given the fact that n, m, x are all integers, and the equality\\n\\t\\t\\t * condition of the Inequality of Arithmetic and Geometric Mean, we\\n\\t\\t\\t * have the following two results:\\n\\t\\t\\t * \\n\\t\\t\\t * 1. Notice that every non-negative integer n can be broken down as\\n\\t\\t\\t * n = r * 3 + s * 2, for some non-negatives r,s. (This can be proved by\\n\\t\\t\\t * induction or by the fact that the greatest common divisor of 3\\n\\t\\t\\t * and 2 is 1.) Thus, x = 2 or 3 is always attainable. Therefore,\\n\\t\\t\\t * the product P = a1 * a2 * ... * am is maximized only when ai = 2\\n\\t\\t\\t * or 3, for all i.\\n\\t\\t\\t * \\n\\t\\t\\t * 2. If x=3 is attainable, i.e., if n/m=3, i.e., if n%3==0, then\\n\\t\\t\\t * the product P is maximized when ai = 3, for all i.\\n\\t\\t\\t * \\n\\t\\t\\t * Now the only uncertain is the cases n=3k+1 or 3k+2, for some\\n\\t\\t\\t * positive integer k. Why do they have to break down as 3(k-1)+2 * 2\\n\\t\\t\\t * and 3k+2 to achieve the max of the product P?\\n\\t\\t\\t * \\n\\t\\t\\t * From 1, we have P must be maximized when n is broken down as\\n\\t\\t\\t * n = r * 3 + s * 2, for some non-negatives r,s. Hence s=(n-3r)/2, so\\n\\t\\t\\t * \\n\\t\\t\\t * P(r) = (3^r)(2^s) = (3^r)(2^((n-3r)/2)), and ln(P) =\\n\\t\\t\\t * rln(3)+[(n-3r)ln(2)]/2.\\n\\t\\t\\t * \\n\\t\\t\\t * Let z=ln(P), then z'=ln(3)-3ln(2)/2 > 0. Hence, P(r) is an\\n\\t\\t\\t * increasing function. And so P is always maximized when r is the\\n\\t\\t\\t * largest !attainable! non-negative integer. Strictly saying, P is\\n\\t\\t\\t * maximized when r is the largest non-negative integer, so that\\n\\t\\t\\t * n = r * 3 + s * 2 with s being also a non-negative integer.\\n\\t\\t\\t * \\n\\t\\t\\t * Until now, we are all clear about the reasons why we break down\\n\\t\\t\\t * the integer n as what it should be for all cases of n=3k, 3k+1\\n\\t\\t\\t * and 3k+2.\\n\\t\\t\\t */\\n\\n```\\npublic int integerBreak(int n) {\\n\\t\\t\\tif (n < 3)\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\tif (n == 3)\\n\\t\\t\\t\\treturn 2;\\n\\t\\t\\tif (n % 3 == 0)\\n\\t\\t\\t\\treturn (int) Math.pow(3, n / 3);\\n\\t\\t\\tif (n % 3 == 1)\\n\\t\\t\\t\\treturn 2 * 2 * ((int) Math.pow(3, (n - 4) / 3));\\n\\n\\t\\t\\treturn 2 * ((int) Math.pow(3, (n - 2) / 3));\\n\\t\\t}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int integerBreak(int n) {\\n\\t\\t\\tif (n < 3)\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\tif (n == 3)\\n\\t\\t\\t\\treturn 2;\\n\\t\\t\\tif (n % 3 == 0)\\n\\t\\t\\t\\treturn (int) Math.pow(3, n / 3);\\n\\t\\t\\tif (n % 3 == 1)\\n\\t\\t\\t\\treturn 2 * 2 * ((int) Math.pow(3, (n - 4) / 3));\\n\\n\\t\\t\\treturn 2 * ((int) Math.pow(3, (n - 2) / 3));\\n\\t\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 80865,
                "title": "5-lines-0ms-java-solution-with-detailed-explanation-and-proof",
                "content": "Observation and Analysis:\\n\\n>     2  1 , 1\\n>     3  1 , 2\\n>     4  2 , 2\\n>     5  3 , 2\\n>     6  3 , 3\\n>     7  3 , 2 , 2\\n>     8  3 , 3 , 2\\n>     9  3 , 3 , 3\\n>     10 3 , 3 , 2, 2    \\nif we split n into k1...kt, for each k(1 <= k <= n)\\n\\n>     1. if k <= 3, f(k) <= k, which means if we still have k to be split, we should use it as a whole.\\n>     2. if k > 3, f(k) >= k (k can at least split into 2 and k - 2, k * (k - 2) - k = k(k - 3) >= 0)\\n>         therefore, if we have k (k > 3), we must split it to get a bigger product \\n>     3. in this situation, if we split k into 1 and k - 1(k - 1 may keep spliting to m1...mt), \\n      we can always get a bigger product by adding this \"1\" to one of the small split number m; \\n      therefore, the smallest number that we split is 2\\n>     4. Whenever we have a k > 3, we will separate it into small numbers\\n>     Finally, all the small numbers will be either 2 or 3.\\n\\nSolution:\\n\\n>     suppose we can separate k into k1, k2, ... kt to get the biggest product for k. \\n>     1. now we consider k + 1: Since we won't split into k and 1, so we must add this extra 1 to one of the t small numbers.\\n>     2. if we add 1 to a \"2\", then we form a new \"3\"; if we add 1 to a \"3\", \\n           we must separate it again into two 2s.\\n>     3. for the first choice, we will get f(k) / 2 * 3 = 1.5 f(k); \\n           for the second choice, we will get f(k) / 3 * 4 = 1.3 f(k)\\n>     4. therefore, as long as we have 2, we change a \"2\" to \"3\" rather than changing a \"3\" to two 2s.\\n>     5. the whole process will tend to get as much 3s as possible to get bigger product.\\n\\n    public int integerBreak(int n) {\\n        if (n == 2) return 1;\\n        if (n == 3) return 2;\\n        if (n % 3 == 0) return (int)Math.pow(3, n / 3);\\n        if (n % 3 == 1) return (int)Math.pow(3, (n - 4) / 3) * 4;// we cannot have a small number that is equal to 1. Then use 4 instead.\\n        return (int)Math.pow(3, (n - 2) / 3) * 2;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Observation and Analysis:\\n\\n>     2  1 , 1\\n>     3  1 , 2\\n>     4  2 , 2\\n>     5  3 , 2\\n>     6  3 , 3\\n>     7  3 , 2 , 2\\n>     8  3 , 3 , 2\\n>     9  3 , 3 , 3\\n>     10 3 , 3 , 2, 2    \\nif we split n into k1...kt, for each k(1 <= k <= n)\\n\\n>     1. if k <= 3, f(k) <= k, which means if we still have k to be split, we should use it as a whole.\\n>     2. if k > 3, f(k) >= k (k can at least split into 2 and k - 2, k * (k - 2) - k = k(k - 3) >= 0)\\n>         therefore, if we have k (k > 3), we must split it to get a bigger product \\n>     3. in this situation, if we split k into 1 and k - 1(k - 1 may keep spliting to m1...mt), \\n      we can always get a bigger product by adding this \"1\" to one of the small split number m; \\n      therefore, the smallest number that we split is 2\\n>     4. Whenever we have a k > 3, we will separate it into small numbers\\n>     Finally, all the small numbers will be either 2 or 3.\\n\\nSolution:\\n\\n>     suppose we can separate k into k1, k2, ... kt to get the biggest product for k. \\n>     1. now we consider k + 1: Since we won't split into k and 1, so we must add this extra 1 to one of the t small numbers.\\n>     2. if we add 1 to a \"2\", then we form a new \"3\"; if we add 1 to a \"3\", \\n           we must separate it again into two 2s.\\n>     3. for the first choice, we will get f(k) / 2 * 3 = 1.5 f(k); \\n           for the second choice, we will get f(k) / 3 * 4 = 1.3 f(k)\\n>     4. therefore, as long as we have 2, we change a \"2\" to \"3\" rather than changing a \"3\" to two 2s.\\n>     5. the whole process will tend to get as much 3s as possible to get bigger product.\\n\\n    public int integerBreak(int n) {\\n        if (n == 2) return 1;\\n        if (n == 3) return 2;\\n        if (n % 3 == 0) return (int)Math.pow(3, n / 3);\\n        if (n % 3 == 1) return (int)Math.pow(3, (n - 4) / 3) * 4;// we cannot have a small number that is equal to 1. Then use 4 instead.\\n        return (int)Math.pow(3, (n - 2) / 3) * 2;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3246244,
                "title": "343-space-100-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo solve this problem, we can use dynamic programming. We will create a dp array of size n+1 where dp[i] will represent the maximum product that can be obtained by breaking the integer i into the sum of k positive integers, where k>=2.\\n\\nWe will then iterate from 2 to n and for each i, we will break it into the sum of j and i-j, where j is in the range 1 to i/2. We will then calculate the product of these two integers and take the maximum of all such products. This maximum value will be stored in dp[i].\\n\\nFinally, we will return dp[n], which will represent the maximum product that can be obtained by breaking n into the sum of k positive integers, where k>=2.\\n\\nThe time complexity of this algorithm is O(n^2) and the space complexity is O(n).\\n\\n# Complexity\\n- Time complexity:\\n42.66%\\n\\n- Space complexity:\\n100%\\n\\n# Code\\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        # Initialize dp array with 0\\'s\\n        dp = [0]*(n+1)\\n        \\n        # Base case\\n        dp[2] = 1\\n        \\n        # Iterate from 3 to n\\n        for i in range(3, n+1):\\n            # Iterate from 1 to i//2\\n            for j in range(1, i//2+1):\\n                # Calculate the product of j and i-j\\n                prod = j*(i-j)\\n                \\n                # Update the maximum product in dp[i]\\n                dp[i] = max(dp[i], max(prod, j*dp[i-j]))\\n        \\n        # Return dp[n]\\n        return dp[n]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        # Initialize dp array with 0\\'s\\n        dp = [0]*(n+1)\\n        \\n        # Base case\\n        dp[2] = 1\\n        \\n        # Iterate from 3 to n\\n        for i in range(3, n+1):\\n            # Iterate from 1 to i//2\\n            for j in range(1, i//2+1):\\n                # Calculate the product of j and i-j\\n                prod = j*(i-j)\\n                \\n                # Update the maximum product in dp[i]\\n                dp[i] = max(dp[i], max(prod, j*dp[i-j]))\\n        \\n        # Return dp[n]\\n        return dp[n]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2302440,
                "title": "python-from-dp-n-2-n-o-1",
                "content": "You try splitting a number into sums like 1+4, 2+3, 3+2, 4+1\\nThen you try splitting right [summand](https://en.wiktionary.org/wiki/summand) 4 -> 2+2, 3 -> 2+1, 2 -> 1+1, ... and so on. \\nYou see repeated (overlapping) & dependent (optimal substructure) subprobles and click - DP.\\nYou can draw an n-ary tree and see yourself.\\n\\n**DP: top-down approach + memo O(n^2)**\\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        @cache\\n        def dfs(a):\\n            if a == 1:\\n                return 1\\n            \\n            max_res = 1\\n            for right in range(1, a):\\n                left = a - right\\n\\t\\t\\t\\t# you can chose left side * right side (e.g. 10: 5 x 5 = 25)\\n\\t\\t\\t\\t# or you can carry on splitting 5 * f(5) => 5 * (3 * 2) = 30\\n                max_res = max(max_res, left * right, left * dfs(right))\\n            \\n            return max_res\\n        \\n        return dfs(n)\\n```\\n\\n**DP: bottom-up O(n^2)**\\nThe same as above but without stack.\\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        dp = [1] * (n + 1)\\n\\n        for i in range(2, n + 1):\\n            max_res = 1\\n            for right in range(2, i):\\n                left = i - right\\n                max_res = max(max_res, left * right, left * dp[right])\\n            dp[i] = max_res\\n        \\n        return dp[n]\\n```\\n\\n---\\nThe logic/code above was what comes first aka bruteforce.\\n\\n---\\n**Futher observations:**\\nIf you calc max products for the first 12 elements you\\'ll see the following:\\n```\\nnum sum     #2 #3\\n 2  1+1      0  0\\n 3  2+1      1  0\\n ---\\n 4  2+2      2  0\\n 5  2+3      1  1\\n 6  3+3      0  2\\n ---\\n 7  2+2+3    2  1\\n 8  2+3+3    1  2\\n 9  3+3+3    0  3\\n ---\\n10  2+2+3+3  2  2\\n11  2+3+3+3  1  3\\n12  3+3+3+3  0  4\\n```\\n**Observations: #1**\\nYou can see that the difference between n=4,5,6 and n=7,8,9 is the [summand](https://en.wiktionary.org/wiki/summand) +3\\nBetween n=7,8,9 and n=10,11,12 the summond is again +3 and so on...\\n\\n**DP: bottom-up O(n)**\\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        dp = [0,1,1,2,4,6,9] + [0] * (max(0, n - 6))\\n        \\n        for i in range(7, n + 1):\\n            dp[i] = 3 * dp[i - 3]\\n        \\n        return dp[n]\\n```\\n**Observations: #2**\\nNow look at number of 2 and 3 summands for element n=4+?\\nDo you see the pattern? No?!\\nFor 2 it\\'s 210 210 210 210 ...\\nFor 3 it\\'s 012 123 234 345 ...\\n\\nWe can extract it into a formula: `2 ^ (2 - (n - 1) % 3) * 3 ^ ((n - 1) % 3 + (n - 1 - 3) // 3)`\\nI intentionally left it w/o simplification so that it\\'s easier to understand it.\\nNow you can apply the formula to n > 3 and return hardcoded values for n=2 and n=3.\\n\\n**Math: O(1)**\\nTook me 15 minutes to extract the formula. No way I am going to extract it quickly under pressure.\\n\\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        if n == 2: return 1\\n        elif n == 3: return 2\\n        else:\\n            # return 2 ** (2 - (n - 1) % 3) * 3 ** ((n - 1) % 3 + (n - 1 - 3) // 3) # log(n)\\n            n -= 1\\n            return int(math.pow(2, (2 - n % 3))) * int(math.pow(3, (n % 3 + (n - 3) // 3))) # O(1)\\n```\\n\\nP.S. An interesting fact about python\\'s power operator ** O(log(n)) vs pow(x,y) O(1) is [here](https://stackoverflow.com/questions/48839772/why-is-time-complexity-o1-for-powx-y-while-it-is-on-for-xy) \\n\\n**If you like it, upvote!**",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        @cache\\n        def dfs(a):\\n            if a == 1:\\n                return 1\\n            \\n            max_res = 1\\n            for right in range(1, a):\\n                left = a - right\\n\\t\\t\\t\\t# you can chose left side * right side (e.g. 10: 5 x 5 = 25)\\n\\t\\t\\t\\t# or you can carry on splitting 5 * f(5) => 5 * (3 * 2) = 30\\n                max_res = max(max_res, left * right, left * dfs(right))\\n            \\n            return max_res\\n        \\n        return dfs(n)\\n```\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        dp = [1] * (n + 1)\\n\\n        for i in range(2, n + 1):\\n            max_res = 1\\n            for right in range(2, i):\\n                left = i - right\\n                max_res = max(max_res, left * right, left * dp[right])\\n            dp[i] = max_res\\n        \\n        return dp[n]\\n```\n```\\nnum sum     #2 #3\\n 2  1+1      0  0\\n 3  2+1      1  0\\n ---\\n 4  2+2      2  0\\n 5  2+3      1  1\\n 6  3+3      0  2\\n ---\\n 7  2+2+3    2  1\\n 8  2+3+3    1  2\\n 9  3+3+3    0  3\\n ---\\n10  2+2+3+3  2  2\\n11  2+3+3+3  1  3\\n12  3+3+3+3  0  4\\n```\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        dp = [0,1,1,2,4,6,9] + [0] * (max(0, n - 6))\\n        \\n        for i in range(7, n + 1):\\n            dp[i] = 3 * dp[i - 3]\\n        \\n        return dp[n]\\n```\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        if n == 2: return 1\\n        elif n == 3: return 2\\n        else:\\n            # return 2 ** (2 - (n - 1) % 3) * 3 ** ((n - 1) % 3 + (n - 1 - 3) // 3) # log(n)\\n            n -= 1\\n            return int(math.pow(2, (2 - n % 3))) * int(math.pow(3, (n % 3 + (n - 3) // 3))) # O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451699,
                "title": "java-easy-solution-beats-100-pure-math",
                "content": "```\\nclass Solution { \\n    public int integerBreak(int n) {\\n        int res = 0;\\n        int three = n / 3;\\n        int rest = n % 3;\\n        if (n == 2) {\\n            return 1;\\n        } else if (n == 3) {\\n            return 2;\\n        } else if (rest == 0) {\\n            res = (int) Math.pow(3, three);\\n        } else if (rest == 1){\\n            res = (int) Math.pow(3, three - 1) * (rest + 3);\\n        } else if (rest == 2){\\n            res = (int) Math.pow(3, three) * (rest);\\n        }\\n        return res;\\n    }\\n}\\n\\n//7=3x4=12\\n//8=3x3x2=18\\n//9=3x3x3=27\\n//10=3x3x4=36\\n//54=3^18=387420489\\n//55=(3^17)*4=516560652\\n//56=(3^18)*2=774840978\\n//57=3^19=1162261467\\n//58=(3^18)x2=1549681956",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution { \\n    public int integerBreak(int n) {\\n        int res = 0;\\n        int three = n / 3;\\n        int rest = n % 3;\\n        if (n == 2) {\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1424472,
                "title": "a-mathematical-constant-hiding-in-plainsight",
                "content": "The optimal solution should strike a perfect balance between the length `k` of the integer partition and the size of each component we are pulling out. \\n\\nFor example consider the possibilities when `n = 17`:\\n```\\n17 = 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 1 (2 ^ 8 * 1)\\n17 = 3 + 3 + 3 + 3 + 3 + 2 (3 ^ 5 * 2)\\n17 = 4 + 4 + 4 + 4 + 1 (4 ^ 4 * 1)\\n17 = 5 + 5 + 5 + 2 (5 ^ 3 * 2)\\n...\\n```\\n\\nThe bigger the number `m` we pull out of `n` to partition it the less times we can do it, meaning a lower exponent `m` is raised to when we do the multiplication at the end. However, the smaller `m` is, the more of it that we can partition out of `n` leading to a bigger exponent, but at the expense of the base it is being raised to.\\n\\nSo we must ask ourselves, what is the optimal number `x` that we can equally partition `n` into while also achieving the greatest exponential expression. Essentially what we are asking is: Find `x` such that `x ^ (n / x)` is maximized.\\n\\nThis `x` just so happens to be `e` therefore the answer to this question: `integerBreak(n)` for large `n` should be approximately `e^(n/e)`.\\n\\n\\nLet\\'s look at some numerical examples to make sure:\\n\\n**NOTE:** It is better to show how good the approximation is using the inverse relation (`n ~ e * ln(integerBreak(n))`) rather than `integerBreak(n) ~ e^(n/e)` because of how sensitive exponential functions are to their input.\\n\\n```\\nn   integerBreak(n)     n ~ e * ln(integerBreak(n))\\n--  ---------------     ---------------------------\\n10  36                  9.7410\\n15  243                 14.9316        \\n20  1458                19.8021\\n25  8748                24.6727\\n30  59049               29.8634\\n35  354294              34.7339\\n40  2125764             39.6044\\n45  14348907            44.7951\\n50  86093442            49.6656\\n55  516560652           54.5360\\n```\\n\\nAs you can see `integerBreak(n) ~ e^(n/e)` is a very good approximation. \\n\\nGiven that this optimization problem is constrained to the integers, partitioning `n` with `e` is not possible. Therefore, we must optimize `x^(n/x)` with the restriction that `x` is an integer. Therefore `x` must either be `2` or `3` since we know the maximum occurs in between at `x = e` \\n\\nComputing the two possibilities:\\n\\n```\\n2^(1/2) = 1.414213562\\n3^(1/3) = 1.44224957\\n```\\n\\nWe see that `x = 3` is larger and therefore pulling out as many `3`s as possible from `n` will strike the perfect balance between the length of the sum `k` and the base of the exponent we are using to compute the maximum product for the integers which make up the partition of `n`\\n\\nTherefore in cases where `n > 4` we should always decompose `n` in the following way:\\n\\n```\\nn = 3 * q + r\\n```\\n\\nWhen `3` perfectly divides `n` or in other words: `r = 0` : `integerBreak(n) = 3 ^ (n / 3)`\\n\\nWhen `3` does not perfectly divide `n` and has a remainder of `1` or in other words: `r = 1`:\\n\\nWe do the following manipulation:\\n\\n```\\nn = 3 * q + 1\\nn = 3 * (q - 1 + 1) + 1\\nn = 3 * (q - 1) + 3 * 1 + 1\\nn = 3 * (q - 1) + 4\\n```\\n\\nTherefore, we break `n` into `(q - 1)` partitions of `3` followed by a `4` leading to: `4 * 3 ^ (n / 3 - 1)` as the answer.\\n\\nFactoring out the subtraction in the exponent we get:\\n```\\nintegerBreak(n) = (4 / 3) * 3 ^ (n / 3) \\n```\\n\\nThis is always going to be bigger than what we would have if we didn\\'t do any manipulation which have been:\\n`1 * 3 ^ (n / 3)` because `4/3 > 1`. In code, I leave the subtraction inside the exponent, so that the final multiplication is between two integers rather than two floats as integer multiplication is much faster than floating point. For the sake of proof, however, I use the expression above since it shows how the manipulation leads to a product that is `33.333%` bigger than what you would have gotten without it.\\n\\nFinally, when `3` does not perfectly divide `n` and has a remainder of `2` or in other words: `r = 2`:\\n\\nWe fit `n` to the following form.\\n```\\nn = 3 * q + 2\\n```\\n\\nIf we did the same manipulation steps as above we can end up with `n = 3*(q - 1) + 5` which would lead to an answer:\\n\\n`(5/3) * 3 ^ (n / 3)` however not doing the manipulation would give us `2 * 3 ^ (n / 3)` which is always bigger simply because `2 > 5/3`. \\n\\nTherefore in the `r = 2` case:\\n\\n```\\nintegerBreak(n) = 2 * 3 ^ (n / 3)\\n```\\n\\nAs code:\\n\\n```\\n    def integerBreak(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n == 2:\\n            return 1\\n        if n == 3:\\n            return 2\\n        if n == 4:\\n            return 4\\n        \\n        if n % 3 == 0:\\n            return int(pow(3, n // 3))\\n        if n % 3 == 1:\\n            return int(pow(3, n // 3 - 1)) * 4\\n        if n % 3 == 2:\\n            return int(pow(3, n // 3)) * 2\\n```",
                "solutionTags": [],
                "code": "```\\n17 = 2 + 2 + 2 + 2 + 2 + 2 + 2 + 2 + 1 (2 ^ 8 * 1)\\n17 = 3 + 3 + 3 + 3 + 3 + 2 (3 ^ 5 * 2)\\n17 = 4 + 4 + 4 + 4 + 1 (4 ^ 4 * 1)\\n17 = 5 + 5 + 5 + 2 (5 ^ 3 * 2)\\n...\\n```\n```\\nn   integerBreak(n)     n ~ e * ln(integerBreak(n))\\n--  ---------------     ---------------------------\\n10  36                  9.7410\\n15  243                 14.9316        \\n20  1458                19.8021\\n25  8748                24.6727\\n30  59049               29.8634\\n35  354294              34.7339\\n40  2125764             39.6044\\n45  14348907            44.7951\\n50  86093442            49.6656\\n55  516560652           54.5360\\n```\n```\\n2^(1/2) = 1.414213562\\n3^(1/3) = 1.44224957\\n```\n```\\nn = 3 * q + r\\n```\n```\\nn = 3 * q + 1\\nn = 3 * (q - 1 + 1) + 1\\nn = 3 * (q - 1) + 3 * 1 + 1\\nn = 3 * (q - 1) + 4\\n```\n```\\nintegerBreak(n) = (4 / 3) * 3 ^ (n / 3) \\n```\n```\\nn = 3 * q + 2\\n```\n```\\nintegerBreak(n) = 2 * 3 ^ (n / 3)\\n```\n```\\n    def integerBreak(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n == 2:\\n            return 1\\n        if n == 3:\\n            return 2\\n        if n == 4:\\n            return 4\\n        \\n        if n % 3 == 0:\\n            return int(pow(3, n // 3))\\n        if n % 3 == 1:\\n            return int(pow(3, n // 3 - 1)) * 4\\n        if n % 3 == 2:\\n            return int(pow(3, n // 3)) * 2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1286861,
                "title": "java-double-o-1-time-space-0ms-solution-thought-by-thought-math-ultra-understandable",
                "content": "## Thoughts Before Coding\\nOften when approached with patten based problems, I find it helpful to run through some examples. I have hand computed the answer for the first 11 numbers by hand. You do not need to do 11, but I wanted to show an abudance of numbers to spot a pattern in.\\n```\\n          n = 2 : 1*1\\n          n = 3 : 2*1\\n          n = 4 : 2*2\\n          n = 5 : 3*2\\n          n = 6 : 3*3\\n          n = 7 : 3*2*2\\n          n = 8 : 3*3*2\\n          n = 9 : 3*3*3\\n          n = 10: 3*3*2*2\\n          n = 11: 3*3*3*2\\n```\\nYou may notice something about this pattern- it is mostly 2\\'s and 3\\'s. Why is this? Another post here goes into calculus, but I think that makes it needlessly difficult. Instead approach it with the following observation:\\n***The more addeds (i.e. pieces) > 1 that the number is decomposed to, the larger the product.***\\n\\nWhy is this? It should be clear that addends of 0 or 1 are \"bad\" as multiplying by 0 turns the product to 0, and multipling any integer by 1 does not change the value of the integer. So if one were to use all 2\\'s, there is a problem: not every number can be summed with only 2\\'s. For odd numbers, adding on a remaining 1 does not change the product, but turning a two into a three and using fewer twos will change the product. \\nFor example:\\n```\\n2+2+2+1 = 7\\n2*2*2*1 = 8\\n-----\\n2+2+3 = 7\\n2*2*3 = 12\\n-----\\n12 > 7\\n```\\nThis pattern will always hold. The reasoning behind that is if you multiply by 4 instead of 3 or 2, 4 = 2\\\\*2 so there really is no difference. If you multiply by 5, you get a scale factor of 5 whereas multipling by 2\\\\*3 (because 2+3 = 5) gives a scale factor of 6. You can show that for any number, its always better to break it into the most pieces > 1. This gives the math an exponent-like effect as opposed to multiplication.\\n\\n# Turning This Into Code\\nPersonally, I have found DP to not be very intuitive for this problem. As it is not the optimal solution, I will leave that approach to other discussion posts. Instead, we can use our math observations above to create a clean, readable solution that relies on math to perform in constant time.\\n\\nFrom our math pattern, there are a few more things to notice.\\n```\\n          n = 2 : 1*1\\n          n = 3 : 2*1\\n          n = 4 : 2*2\\n          n = 5 : 3*2\\n          n = 6 : 3*3\\n          n = 7 : 3*2*2\\n          n = 8 : 3*3*2\\n          n = 9 : 3*3*3\\n          n = 10: 3*3*2*2\\n          n = 11: 3*3*3*2\\n```\\n\\nThere is no number 3 for the n = 2, n = 3 and n = 4. These are our edge cases. Otherwise, there is a clear pattern that emerges. In plain English, our algorithm would be\\n\\n* For the input number n, if only threes can be used without remainder, return the product of the amount of threes that make it up.\\n* Otherwise, if there is a remainder of 1 when subtracting threes, use one less three than you can fit, and multiply by 2 and then 2 again (because 3\\\\*1 < 2\\\\*2). Return this product.\\n*  Lastly if there is a remainder of 2 when subtracting threes, use as many threes as possible, and then finally a 2. Return this product.\\n\\nThis behavior with finding how many of a number fit, and the remainder is what characterizes the modulo operation. This brings us to...\\n## The Code\\n```\\nclass Solution {\\n    private static final int[] bases = {0,0,1,2,4};\\n    public int integerBreak(int n) {\\n        if(n <= 4)\\n          return bases[n];\\n        else\\n          switch(n%3){\\n            case 0 :\\n              return (int) Math.pow(3,n/3);\\n            case 1 :\\n              return (int) Math.pow(3,n/3 - 1)*2*2;\\n            default: // case 2\\n              return (int) Math.pow(3,n/3)*2;\\n          }\\n    }\\n}\\n```\\n## Time and Space Analysis\\nThe only additional memory used is constant, the static array for edge cases. The only time complexity hiccup is the pow function. The Math.pow function is not iterative- see [this stack overflow thread](https://stackoverflow.com/questions/32418731/java-math-powa-b-time-complexity) for implementation details on how this is.\\n\\nAs a result, the above code runs in constant time and constant space, beating 100% of Java submissions.\\n\\nIf you liked this write-up or have any questions, please leave a comment or upvote for visibility. Also checkout some of my other more detailed writeups from this account. Thank you -AC",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\n          n = 2 : 1*1\\n          n = 3 : 2*1\\n          n = 4 : 2*2\\n          n = 5 : 3*2\\n          n = 6 : 3*3\\n          n = 7 : 3*2*2\\n          n = 8 : 3*3*2\\n          n = 9 : 3*3*3\\n          n = 10: 3*3*2*2\\n          n = 11: 3*3*3*2\\n```\n```\\n2+2+2+1 = 7\\n2*2*2*1 = 8\\n-----\\n2+2+3 = 7\\n2*2*3 = 12\\n-----\\n12 > 7\\n```\n```\\n          n = 2 : 1*1\\n          n = 3 : 2*1\\n          n = 4 : 2*2\\n          n = 5 : 3*2\\n          n = 6 : 3*3\\n          n = 7 : 3*2*2\\n          n = 8 : 3*3*2\\n          n = 9 : 3*3*3\\n          n = 10: 3*3*2*2\\n          n = 11: 3*3*3*2\\n```\n```\\nclass Solution {\\n    private static final int[] bases = {0,0,1,2,4};\\n    public int integerBreak(int n) {\\n        if(n <= 4)\\n          return bases[n];\\n        else\\n          switch(n%3){\\n            case 0 :\\n              return (int) Math.pow(3,n/3);\\n            case 1 :\\n              return (int) Math.pow(3,n/3 - 1)*2*2;\\n            default: // case 2\\n              return (int) Math.pow(3,n/3)*2;\\n          }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 80693,
                "title": "java-solution-very-very-ez",
                "content": "    public class Solution {\\n        public int integerBreak(int n) {\\n            if(n == 2) return 1;\\n            if(n == 3) return 2;\\n            if(n%3 == 0) return (int) Math.pow(3,n/3); \\n            else if(n%3 == 1) return ((int)Math.pow(3,n/3))/3*4;\\n            else return ((int)Math.pow(3,n/3))*2;\\n        }\\n    }\\nnum 3 is the sum of 1,2 or 1,1,1 and both of the products is less than 3 <br>\\nnum 4 is the sum of 2,2 or 1,1,2 or \\xb7\\xb7\\xb7 and all of them is no more than 4 <br>\\nthen 5  : 2 x 3 > 5  then 6 : 3 x 3 > 6 <br>\\nthis part seems like Greedy?<br>\\n\\nso make more '3' as a break of n and here comes to the ac solution <br>\\nand it seems an O(lgN) solution?",
                "solutionTags": [],
                "code": "class Solution {\\n        public int integerBreak(int n) {\\n            if(n == 2) return 1;\\n            if(n == 3) return 2;\\n            if(n%3 == 0) return (int) Math.pow(3,n/3); \\n            else if(n%3 == 1) return ((int)Math.pow(3,n/3))/3*4;\\n            else return ((int)Math.pow(3,n/3))*2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 80874,
                "title": "dp-top-down-dp-bottom-up-magic-solution",
                "content": "All solutions are accepted.\\nWe need to ask the interview whether the result will exceed to limit of range of int32 or int64.\\nIf not, we could use multiply operator simply.\\n\\npublic class Solution {\\n    public int integerBreak(int n) {\\n        return solve_magic(n);\\n    }\\n    \\n    // accepted\\n    private int solve_topdown(int n, int[] dp) {\\n        if (n == 2) {\\n            dp[2] = 1;\\n            return dp[2];\\n        }\\n        \\n        if (dp[n] > 0) {\\n            return dp[n];\\n        }\\n        \\n        for(int i = n - 1; i >=2; i--) {\\n            // do not break\\n            dp[n] = Math.max(dp[n], i * (n - i));\\n            \\n            // do break\\n            dp[n] = Math.max(dp[n], solve_topdown(i, dp) * (n - i));\\n        }\\n        \\n        return dp[n];\\n    }\\n    \\n    // accepted\\n    private int solve_bottomup(int n) {\\n        int[] dp = new int[n + 1];\\n        dp[2] = 1;\\n        for(int i = 3; i <= n; i++) {\\n           for(int j = 2; j <= i; j++) {\\n               // do not break\\n               dp[i] = Math.max(dp[i], j * (i - j));\\n               \\n               // do break\\n               dp[i] = Math.max(dp[i], dp[j] * (i - j));\\n           }\\n        }\\n        \\n        return dp[n];\\n    }\\n\\n    // accepted\\n    private int solve_magic(int n) {\\n        switch(n) {\\n            case 2: return 1;\\n            case 3: return 2;\\n            case 4: return 4;\\n            case 5: return 6;\\n            case 6: return 9;\\n            default: return solve_magic(n - 3) * 3;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int integerBreak(int n) {\\n        return solve_magic(n);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3417502,
                "title": "time-space-complexity-o-1-math-solution-96-58-time-67-94-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply speaking it is a math problem instead of DP Problem. If the number is greater than 3, we need to break the number into summation of 2 and 3. This leads to the largest product.\\n\\nWe need as many 3 as possible because 3^2 is greater than 2^3.\\n\\nHowever, special case for 4, 2$\\\\times$2 > 3 $\\\\times$ 1.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf n = 2 we break it into 1+1 = 2\\nIf n = 3 we break it into 1+2 = 3 \\nIf n >= 4:\\n----If n%3==0: break n into 3 + 3 + 3 + ... + 3\\n----If n%3==1: break n into 3 + ... + 3 + 2 + 2: Number of 3 equals to n//3 - 1\\n----If n%3==2: break n into 3 + ... + 3 + 2: Number of 3 equals to n//3\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        if n <= 3:\\n            return n - 1\\n        elif n%3 == 0:\\n            return 3**(int(n/3))\\n        elif n%3 == 1:\\n            return 3**(int(n/3)-1)*4\\n        else:\\n            return 3**(int(n/3))*2\\n```\\n\\n# One Liner Code\\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:    \\n        return n-1 if n <= 3 else 3**(int(n/3)-1)*round(0.5*(n%3)**2 + 0.5*(n%3) + 3)\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        if n <= 3:\\n            return n - 1\\n        elif n%3 == 0:\\n            return 3**(int(n/3))\\n        elif n%3 == 1:\\n            return 3**(int(n/3)-1)*4\\n        else:\\n            return 3**(int(n/3))*2\\n```\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:    \\n        return n-1 if n <= 3 else 3**(int(n/3)-1)*round(0.5*(n%3)**2 + 0.5*(n%3) + 3)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211451,
                "title": "recursion-memoization-tabulation-c",
                "content": "*Please upvote if you liked the solution ;)*\\n\\n**RECURSION**\\n```\\nclass Solution {\\npublic:\\n    int solve(int ind,int target)\\n    {\\n        if(ind==1)\\n          return 1 ;\\n        int notPick=solve(ind-1,target);\\n        int pick=0;\\n        if(target>=ind)\\n          pick=ind*solve(ind,target-ind);\\n        \\n        return max(pick,notPick);\\n    }\\n\\tint integerBreak(int n){\\n\\t\\treturn solve(n-1,n);\\n\\t}\\n}; \\n```\\n\\n**MEMOIZATION**\\n```\\nclass Solution {\\npublic:\\n    int solve(int ind,int target,vector<vector<int>>&dp)\\n    {\\n        if(ind==1)\\n          return 1 ;\\n        if(dp[ind][target]!=-1)\\n           return dp[ind][target];\\n        int notPick=solve(ind-1,target,dp);\\n        int pick=0;\\n        if(target>=ind)\\n          pick=ind*solve(ind,target-ind,dp);\\n        \\n        return dp[ind][target]=max(pick,notPick);\\n    }\\n\\tint integerBreak(int n){\\n        vector<vector<int>>dp(n,vector<int>(n+1,-1));\\n\\t\\treturn solve(n-1,n,dp);\\n\\t}\\n}; \\n```\\n\\n**TABULATION**\\n```\\nclass Solution {\\npublic:\\n\\tint integerBreak(int n){\\n\\t\\t vector<vector<int>>dp(n,vector<int>(n+1,0));\\n         for(int i=0;i<=n;i++)\\n          dp[1][i]=1;\\n\\n         for(int ind=2;ind<n;ind++)\\n         {\\n             for(int target=0;target<=n;target++)\\n             {\\n              int notPick=dp[ind-1][target];\\n              int pick=0;\\n              if(target>=ind)\\n                  pick=ind*dp[ind][target-ind];\\n        \\n               dp[ind][target]=max(pick,notPick);\\n             }\\n         }\\n         return dp[n-1][n];\\n\\t}\\n}; \\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int ind,int target)\\n    {\\n        if(ind==1)\\n          return 1 ;\\n        int notPick=solve(ind-1,target);\\n        int pick=0;\\n        if(target>=ind)\\n          pick=ind*solve(ind,target-ind);\\n        \\n        return max(pick,notPick);\\n    }\\n\\tint integerBreak(int n){\\n\\t\\treturn solve(n-1,n);\\n\\t}\\n}; \\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int ind,int target,vector<vector<int>>&dp)\\n    {\\n        if(ind==1)\\n          return 1 ;\\n        if(dp[ind][target]!=-1)\\n           return dp[ind][target];\\n        int notPick=solve(ind-1,target,dp);\\n        int pick=0;\\n        if(target>=ind)\\n          pick=ind*solve(ind,target-ind,dp);\\n        \\n        return dp[ind][target]=max(pick,notPick);\\n    }\\n\\tint integerBreak(int n){\\n        vector<vector<int>>dp(n,vector<int>(n+1,-1));\\n\\t\\treturn solve(n-1,n,dp);\\n\\t}\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091183,
                "title": "c-o-1-time-innovative-solution",
                "content": "#### O(1) code\\n```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        if(n <= 3)\\n            return n - 1;\\n\\n        int noOf3s = n/3, noOf2s = n%3;\\n        \\n        if(noOf2s == 1) {\\n            noOf3s--;\\n            noOf2s = 2;\\n        } else if(noOf2s == 2)\\n            noOf2s = 1;\\n\\n        return pow(3, noOf3s) * pow(2, noOf2s);\\n    }\\n};\\n```\\n#### Complexity\\n- Time complexity: $$O(1)$$ without considering pow operation\\n\\n- Space complexity: $$O(1)$$\\n\\nNOTE: \\n- pow operation takes $$O(log(n))$$ time.\\n",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        if(n <= 3)\\n            return n - 1;\\n\\n        int noOf3s = n/3, noOf2s = n%3;\\n        \\n        if(noOf2s == 1) {\\n            noOf3s--;\\n            noOf2s = 2;\\n        } else if(noOf2s == 2)\\n            noOf2s = 1;\\n\\n        return pow(3, noOf3s) * pow(2, noOf2s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629818,
                "title": "o-n-dp-no-recursion-100ms",
                "content": "```\\nint integerBreak(int n) {\\n        if(n==2)\\n            return 1;\\n        int ans[n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        ans[2]=1;\\n        ans[3]=2;\\n        for(int i=4;i<=n;i++)\\n        {\\n            ans[i]=i;\\n            for(int j=1;j<i;j++)\\n            {\\n                //these two values of x and y are precalculated becase think logically if j or i-j                     \\n\\t\\t\\t\\t//being 1,2 or 3 max answer would be that number \\n                //unlike 5 6 7... where max ans are like 2*3,3*3,3*4...\\n                int x=j<=3?j:ans[j];\\n                int y=i-j<=3?i-j:ans[i-j];\\n                ans[i]=max(ans[i],x*y);\\n            }\\n        }\\n        return ans[n];\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nint integerBreak(int n) {\\n        if(n==2)\\n            return 1;\\n        int ans[n+1];\\n        ans[0]=0;\\n        ans[1]=1;\\n        ans[2]=1;\\n        ans[3]=2;\\n        for(int i=4;i<=n;i++)\\n        {\\n            ans[i]=i;\\n            for(int j=1;j<i;j++)\\n            {\\n                //these two values of x and y are precalculated becase think logically if j or i-j                     \\n\\t\\t\\t\\t//being 1,2 or 3 max answer would be that number \\n                //unlike 5 6 7... where max ans are like 2*3,3*3,3*4...\\n                int x=j<=3?j:ans[j];\\n                int y=i-j<=3?i-j:ans[i-j];\\n                ans[i]=max(ans[i],x*y);\\n            }\\n        }\\n        return ans[n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1624115,
                "title": "recursion-and-dp-java",
                "content": "1) Recursion\\nThe idea is that at every value, we can loop from 1 to n-1 for the first value (**a**). The remain value (**b**) has two options:\\n- Keep the same, which means the product will be a * b\\n- Or broken down, which means the product is: a * max(integerBreak(b))\\n\\nWe also want to cache the result using **n** as key.\\n\\n```java\\nclass Solution {\\n    Map<Integer, Integer> map = new HashMap<>();\\n    \\n    public int integerBreak(int n) {\\n        if (map.containsKey(n)) return map.get(n);\\n        \\n        int res = Integer.MIN_VALUE;\\n        if (n == 1) {\\n            return 1;\\n        } \\n        \\n        for(int i = 1; i <= n / 2; i++) {\\n            res = Math.max(res, i * Math.max(n-i, integerBreak(n-i)));\\n        }\\n        \\n        map.put(n, res);\\n        return map.get(n);\\n    }\\n}\\n```\\n\\n2) Similar to the recursion, we just use table to cache the value for dp\\n```java\\nclass Solution {\\n    public int integerBreak(int n) {\\n        if (n == 0) return 0; \\n        if (n == 1) return 1;\\n        \\n        int[] dp = new int[n+1];\\n        \\n        dp[1] = 1;\\n        \\n        for(int i = 2; i <= n; i++) {\\n            for(int j = 1; j <= i / 2; j++) {\\n                dp[i] = Math.max(dp[i], j * Math.max(i-j, dp[i-j]));\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```\\n\\nNote: for both methods, we only want to loop up to **n/2** since the values are mirrored. IE: 5 = 2 + 3 = 3 + 2",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```java\\nclass Solution {\\n    Map<Integer, Integer> map = new HashMap<>();\\n    \\n    public int integerBreak(int n) {\\n        if (map.containsKey(n)) return map.get(n);\\n        \\n        int res = Integer.MIN_VALUE;\\n        if (n == 1) {\\n            return 1;\\n        } \\n        \\n        for(int i = 1; i <= n / 2; i++) {\\n            res = Math.max(res, i * Math.max(n-i, integerBreak(n-i)));\\n        }\\n        \\n        map.put(n, res);\\n        return map.get(n);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int integerBreak(int n) {\\n        if (n == 0) return 0; \\n        if (n == 1) return 1;\\n        \\n        int[] dp = new int[n+1];\\n        \\n        dp[1] = 1;\\n        \\n        for(int i = 2; i <= n; i++) {\\n            for(int j = 1; j <= i / 2; j++) {\\n                dp[i] = Math.max(dp[i], j * Math.max(i-j, dp[i-j]));\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666448,
                "title": "o-log-n-simple-solution-using-math-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n    if(n==2||n==3) return n-1;\\n    int r=n%3;  int q=n/3; int ans=pow(3,q);   \\n    if(r==0) return ans;\\n    if(r==1) return pow(3,q-1)*4;\\n    if(r==2) return ans*2;\\n    return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n    if(n==2||n==3) return n-1;\\n    int r=n%3;  int q=n/3; int ans=pow(3,q);   \\n    if(r==0) return ans;\\n    if(r==1) return pow(3,q-1)*4;\\n    if(r==2) return ans*2;\\n    return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763195,
                "title": "easy-to-understand-recursive-memoization-faster-than-100-solutions",
                "content": "So first I have written the recursive approach of the solution. This is done by multiplying i * Math.max(n-i,solve(n-i));\\nThis means that when I\\'m subtacting 4 by 1 I\\'m getting (4-1) = 3 so now  a possible solution may be 1*(4-1 =3) = 3 or 1*(solve(3))<-- this is passd back into the recursion where 3 can be written as 1 *(3-1=2) = 3 0r 1*(solve(3-1));\\nusing this approach only I have used memoization int the second step to make it optimized \\n\\n\\n```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        return solve(n);\\n        \\n    }\\n    public static int solve(int n){\\n        if(n == 1){\\n            return 1;\\n        }\\n        int max = 0;\\n        for(int i =1 ; i<=n-1 ; i++){\\n            int num1 = i;\\n            int num2 = n-i;\\n            int x = num1 * Math.max(n-i,solve(n-i));\\n            max = Math.max(max,x);\\n            \\n        }\\n        return max;\\n    }\\n}\\n```\\nMemoised Code:\\n\\n\\n```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        int[] dp = new int[n+1];\\n        return solve(n,dp);\\n        \\n    }\\n    public static int solve(int n,int[] dp){\\n        if(n == 1){\\n            return dp[n] = 1;\\n        }\\n        if(dp[n] != 0){\\n            return dp[n];\\n        }\\n        int max = 0;\\n        for(int i =1 ; i<=n-1 ; i++){\\n            int x = i * Math.max(n-i,solve(n-i,dp));\\n            max = Math.max(max,x);\\n            \\n        }\\n        return dp[n] = max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        return solve(n);\\n        \\n    }\\n    public static int solve(int n){\\n        if(n == 1){\\n            return 1;\\n        }\\n        int max = 0;\\n        for(int i =1 ; i<=n-1 ; i++){\\n            int num1 = i;\\n            int num2 = n-i;\\n            int x = num1 * Math.max(n-i,solve(n-i));\\n            max = Math.max(max,x);\\n            \\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        int[] dp = new int[n+1];\\n        return solve(n,dp);\\n        \\n    }\\n    public static int solve(int n,int[] dp){\\n        if(n == 1){\\n            return dp[n] = 1;\\n        }\\n        if(dp[n] != 0){\\n            return dp[n];\\n        }\\n        int max = 0;\\n        for(int i =1 ; i<=n-1 ; i++){\\n            int x = i * Math.max(n-i,solve(n-i,dp));\\n            max = Math.max(max,x);\\n            \\n        }\\n        return dp[n] = max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 246283,
                "title": "easy-step-by-step-interview-thought-process-with-recursion-solution",
                "content": "lets take 10 as an example.\\nFirst thing came up to my mind was that the problem can break down as \\n```\\nint result = Math.max(2 * integerBreak(10 - 2) * i, 3 * integerBreak(10 - 3), 4 * integerBreak(10 - 4)...)\\n```\\n\\nSo we have our solution as,\\n```\\npublic int integerBreak(int n) {\\n\\tif (n <= 2) return 1;//base case\\n\\tint solution = 0;\\n\\tfor(int i = 2; i<n; i++) {\\n\\t\\tsolution = Math.max(solution, i * integerBreak(n-i));\\n\\t}\\n\\treturn solution;\\n}\\n```\\n\\nHowever, after plug a couple number in, we will soon find out that our answer is wrong.\\nFor example, plug in 4 would yield `2 * integerBreak(4-2)` which leads to `2 * 1 = 3`, because our base case is `if (n <= 2) return 1;` which is correct if the input is 2, but not if it is greater than 2. \\n\\nSo, we have a corner case to take care.\\n\\nAfter some experiment, it\\'s not hard to see that when n <=4, n always bigger than break down product. Hence, our algorithm could be improved as follow.\\n```\\npublic int integerBreak(int n) {\\n\\tif (n <= 2) return 1;//base case\\n\\tint solution = 0;\\n\\tfor(int i = 2; i<n; i++) {\\n\\t\\tif(n-i <= 4) solution = Math.max(solution, i * (n-i));//the corner discussed above\\n\\t\\telse solution = Math.max(solution, i * integerBreak(n-i));\\n\\t}\\n\\treturn solution;\\n}\\n```\\n\\nLast step, it is not hard to see that we have repeated calculation that could be cached.\\n```\\npublic int integerBreak(int n) {\\n\\treturn integerBreak(n, new int[n+1]);\\n}\\n\\npublic int integerBreak(int n, int[] cache) {\\n\\tif (n == 2) return 1;\\n\\tif(cache[n] > 0) return cache[n];//we have calculated the result before, so return it\\n\\tint solution = 0;\\n\\tfor(int i = 2; i<n; i++) {\\n\\t\\tif(n-i<=4) {\\n\\t\\t\\tsolution = Math.max(solution, i * (n-i));\\n\\t\\t}else {\\n\\t\\t\\tsolution = Math.max(solution, i * integerBreak(n - i, cache));\\n\\t\\t}\\n\\t}\\n\\tcache[n] = solution;//cache the result\\n\\treturn solution;\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nint result = Math.max(2 * integerBreak(10 - 2) * i, 3 * integerBreak(10 - 3), 4 * integerBreak(10 - 4)...)\\n```\n```\\npublic int integerBreak(int n) {\\n\\tif (n <= 2) return 1;//base case\\n\\tint solution = 0;\\n\\tfor(int i = 2; i<n; i++) {\\n\\t\\tsolution = Math.max(solution, i * integerBreak(n-i));\\n\\t}\\n\\treturn solution;\\n}\\n```\n```\\npublic int integerBreak(int n) {\\n\\tif (n <= 2) return 1;//base case\\n\\tint solution = 0;\\n\\tfor(int i = 2; i<n; i++) {\\n\\t\\tif(n-i <= 4) solution = Math.max(solution, i * (n-i));//the corner discussed above\\n\\t\\telse solution = Math.max(solution, i * integerBreak(n-i));\\n\\t}\\n\\treturn solution;\\n}\\n```\n```\\npublic int integerBreak(int n) {\\n\\treturn integerBreak(n, new int[n+1]);\\n}\\n\\npublic int integerBreak(int n, int[] cache) {\\n\\tif (n == 2) return 1;\\n\\tif(cache[n] > 0) return cache[n];//we have calculated the result before, so return it\\n\\tint solution = 0;\\n\\tfor(int i = 2; i<n; i++) {\\n\\t\\tif(n-i<=4) {\\n\\t\\t\\tsolution = Math.max(solution, i * (n-i));\\n\\t\\t}else {\\n\\t\\t\\tsolution = Math.max(solution, i * integerBreak(n - i, cache));\\n\\t\\t}\\n\\t}\\n\\tcache[n] = solution;//cache the result\\n\\treturn solution;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 80815,
                "title": "a-line-python-solution",
                "content": "        def integerBreak(self, n):\\n            return ((n % 3 + 3 + (n%3 == 2))*3**(n/3-1)) if (n>3) else (n-1)",
                "solutionTags": [],
                "code": "        def integerBreak(self, n):\\n            return ((n % 3 + 3 + (n%3 == 2))*3**(n/3-1)) if (n>3) else (n-1)",
                "codeTag": "Python3"
            },
            {
                "id": 80714,
                "title": "hint-for-the-pattern",
                "content": "As we can see the pattern is, for n>=4:\\n\\n    4=2+2;\\n    5=2+3;\\n    6=3+3;\\n    7=2+2+3;\\n    8=2+3+3;\\n    9=3+3+3;\\n    10=2+2+3+3;\\n    11=2+3+3+3;\\n    12=3+3+3+3;\\n    13=2+2+3+3+3;\\n    14=2+3+3+3+3;\\n    15=3+3+3+3+3;\\n\\nand so on.\\n\\nIf `n == 3 * k` then the answer is `3 ^ k`; \\n\\nIf `3*(k-1) < n <= 3*k`, replace some `3` with `2`'s.",
                "solutionTags": [],
                "code": "As we can see the pattern is, for n>=4:\\n\\n    4=2+2;\\n    5=2+3;\\n    6=3+3;\\n    7=2+2+3;\\n    8=2+3+3;\\n    9=3+3+3;\\n    10=2+2+3+3;\\n    11=2+3+3+3;\\n    12=3+3+3+3;\\n    13=2+2+3+3+3;\\n    14=2+3+3+3+3;\\n    15=3+3+3+3+3;\\n\\nand so on.\\n\\nIf `n == 3 * k` then the answer is `3 ^ k`; \\n\\nIf `3*(k-1) < n <= 3*k`, replace some `3` with `2`'s.",
                "codeTag": "Unknown"
            },
            {
                "id": 3475818,
                "title": "java-solution-for-integer-break-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is to break a given integer n into the sum of at least two positive integers and maximize the product of those integers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used here is dynamic programming. The idea is to maintain an array dp where dp[i] represents the maximum product that can be obtained by breaking the number i into at least two positive integers.\\n\\nTo compute dp[i], we iterate over all possible ways of breaking i into two positive integers j and i-j, and calculate the product of dp[j] and dp[i-j]. We take the maximum of this product and dp[i] to update dp[i].\\n\\nThe final answer is dp[n].\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe outer loop iterates n-1 times, and the inner loop iterates i times for each iteration of the outer loop. Therefore, the time complexity is O(n^2).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe use an array dp of size n+1. Therefore, the space complexity is O(n).\\n\\n# Code\\n```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        int[] dp = new int[n+1];\\n        for(int i=1; i<n; i++)\\n        {\\n            for(int j=1; j<i+1; j++)\\n            {\\n                if(i+j<=n)\\n                {\\n                    dp[i+j]=Math.max(Math.max(dp[i],i)*Math.max(dp[j],j), dp[i+j]);\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        int[] dp = new int[n+1];\\n        for(int i=1; i<n; i++)\\n        {\\n            for(int j=1; j<i+1; j++)\\n            {\\n                if(i+j<=n)\\n                {\\n                    dp[i+j]=Math.max(Math.max(dp[i],i)*Math.max(dp[j],j), dp[i+j]);\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046555,
                "title": "c-easy-memoization-tabulation-faster-than-100",
                "content": "![image](https://assets.leetcode.com/users/images/49cb28e0-a3da-4dc0-97f1-7c35784fef15_1673631328.4229546.png)\\n\\n**Memoization**\\n\\n```\\nclass Solution {\\nprivate:\\n    int solve(int n,vector<int>& dp){\\n        if(n==0 || n==1) return 1;\\n        \\n        if(dp[n]!=-1) return dp[n];\\n        \\n        int maxi=0;\\n        \\n        for(int ind=1;ind<n;ind++){\\n            int temp=max(ind*(n-ind), ind * solve(n-ind,dp));\\n            maxi=max(maxi,temp);\\n        }\\n        return dp[n]=maxi;\\n    }\\npublic:\\n    int integerBreak(int n) {\\n        vector<int> dp(n+1,-1);\\n        return solve(n,dp);\\n    }\\n};\\n```\\n\\n**Tabulation**\\n\\n```\\nclass Solution {\\nprivate:\\n    int solveTab(int n){\\n        vector<int> dp(n+1,0);\\n        \\n        dp[0]=1;\\n        dp[1]=1;\\n     \\n        for(int i=2;i<=n;i++){\\n            int maxi=1;\\n            for(int ind=1;ind<i;ind++){\\n            int temp=max(ind*(i-ind), ind * dp[i-ind]);\\n            maxi=max(maxi,temp);\\n            }\\n            dp[i]=maxi;\\n        }\\n        \\n        return dp[n];\\n    }\\npublic:\\n    int integerBreak(int n) {\\n        return solveTab(n);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int n,vector<int>& dp){\\n        if(n==0 || n==1) return 1;\\n        \\n        if(dp[n]!=-1) return dp[n];\\n        \\n        int maxi=0;\\n        \\n        for(int ind=1;ind<n;ind++){\\n            int temp=max(ind*(n-ind), ind * solve(n-ind,dp));\\n            maxi=max(maxi,temp);\\n        }\\n        return dp[n]=maxi;\\n    }\\npublic:\\n    int integerBreak(int n) {\\n        vector<int> dp(n+1,-1);\\n        return solve(n,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solveTab(int n){\\n        vector<int> dp(n+1,0);\\n        \\n        dp[0]=1;\\n        dp[1]=1;\\n     \\n        for(int i=2;i<=n;i++){\\n            int maxi=1;\\n            for(int ind=1;ind<i;ind++){\\n            int temp=max(ind*(i-ind), ind * dp[i-ind]);\\n            maxi=max(maxi,temp);\\n            }\\n            dp[i]=maxi;\\n        }\\n        \\n        return dp[n];\\n    }\\npublic:\\n    int integerBreak(int n) {\\n        return solveTab(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567222,
                "title": "java-dp-no-maths",
                "content": "```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        int[] dp = new int[n+1];\\n        Arrays.fill(dp,-1);\\n        return helper(n,n,dp);\\n    }\\n    \\n    private int helper(int n,int q,int[] dp){\\n        if(n == 1)return 1;\\n        if(dp[n] != -1)return dp[n];\\n        \\n        int ans = (n == q)? 0 : n;\\n        for(int i = 1; i < n; i++){\\n            \\n            int c = helper(i,n,dp) * helper(n-i,n,dp);\\n            ans = Math.max(c,ans);\\n        }\\n        dp[n] = ans;\\n        return ans;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        int[] dp = new int[n+1];\\n        Arrays.fill(dp,-1);\\n        return helper(n,n,dp);\\n    }\\n    \\n    private int helper(int n,int q,int[] dp){\\n        if(n == 1)return 1;\\n        if(dp[n] != -1)return dp[n];\\n        \\n        int ans = (n == q)? 0 : n;\\n        for(int i = 1; i < n; i++){\\n            \\n            int c = helper(i,n,dp) * helper(n-i,n,dp);\\n            ans = Math.max(c,ans);\\n        }\\n        dp[n] = ans;\\n        return ans;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2372697,
                "title": "c-simple-math-0ms-solution-with-explanation",
                "content": "**Approach:**\\n\\n* If the product contains a factor f >= 4, then we can always replace it with factors 2 and f-2 without losing optimality\\n\\t* as ```2*(f-2) = 2f-4 >= f```\\n* So you never need a factor greater than or equal to 4, meaning you only need factors 1, 2 and 3\\n\\t* and 1 is of course wasteful and you\\'d only use it for n=2 and n=3, where it\\'s needed\\n* we will prefer 3 for n>4\\n\\t* why?\\n\\t\\t* for n = 6\\n\\t\\t* ```6 = 2 + 2 + 2 = 3 + 3. But 2 * 2 * 2 < 3 * 3```\\n\\t\\t* Therefore, if there are three 2\\'s in the decomposition, we can replace them by two 3\\'s to gain a larger product.\\n\\t\\t* similarly, if we have two 2\\'s and one 1 then we can replace them by one 2 and one 3 as in the case of 5\\n\\t\\t* ``` 5 = 2+2+1=2+3 but 2*2*1<2*3```\\n* so just calculate the n%3 =m\\n\\t* if m==0\\n\\t\\t* we can have all factors as 3\\n\\t* if m==1\\n\\t\\t* we will take (k-1) 3\\'s and one 4\\n\\t* if m==2\\n\\t\\t* we will take k 3\\'s and one 2\\n\\n**Code:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int integerBreak(int n)\\n    {\\n        if (n == 2)\\n            return 1;\\n        if (n == 3)\\n            return 2;\\n        if (n == 4)\\n            return 4;\\n        int k = n / 3;\\n        int m = n % 3;\\n        int ans;\\n        if (m == 0)\\n            ans = pow(3, k);\\n        else if (m == 1)\\n            ans = pow(3, k - 1) * 4;\\n        else if (m == 2)\\n            ans = pow(3, k) * m;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```2*(f-2) = 2f-4 >= f```\n```6 = 2 + 2 + 2 = 3 + 3. But 2 * 2 * 2 < 3 * 3```\n``` 5 = 2+2+1=2+3 but 2*2*1<2*3```\n```\\nclass Solution\\n{\\npublic:\\n    int integerBreak(int n)\\n    {\\n        if (n == 2)\\n            return 1;\\n        if (n == 3)\\n            return 2;\\n        if (n == 4)\\n            return 4;\\n        int k = n / 3;\\n        int m = n % 3;\\n        int ans;\\n        if (m == 0)\\n            ans = pow(3, k);\\n        else if (m == 1)\\n            ans = pow(3, k - 1) * 4;\\n        else if (m == 2)\\n            ans = pow(3, k) * m;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219501,
                "title": "easy-to-approach-understand-c-both-recursion-method-as-well-as-top-down-dp-solution",
                "content": "Approach 1(Recursion): \\n```\\nclass Solution {\\npublic:\\n    //Recursion Approach - May be TLE, just written to get the top-down approach\\n    //Recursion is easy to understand - once skip a number and once take it and multiply it\\n    //Can be approached similar to coin change problem\\n    int solve(int n, int i){\\n        if(n == 0) return 1;\\n        if(n < 0 || i <= 0) return 0;\\n        int res = solve(n, i-1);               //once skip the number\\n        res = max(res, i*solve(n-i, i));   //consider it and multiply\\n        return res;\\n    }\\n    int integerBreak(int n) {\\n       return solve(n, n-1);\\n    }\\n};\\n```\\n\\nApproch 2( Top down dp):\\n```\\nclass Solution {\\npublic:\\n    //top-down approach\\n    int integerBreak(int n) {\\n        vector<vector<int>> dp(n+1, vector<int> (n+1, 1 ));\\n        for(int i = 2; i <= n; ++i){\\n            for(int j = 2; j <= n; ++j){\\n                dp[i][j] = dp[i-1][j];\\n                if(i-1 <= j){\\n                    dp[i][j] = max(dp[i][j], (i-1)*dp[i][j -(i-1)]);\\n                }\\n            }\\n        }\\n        return dp[n][n];\\n    }\\n};\\n```\\nNote: Further this can be optimized to O(N) Space Complexity.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Recursion Approach - May be TLE, just written to get the top-down approach\\n    //Recursion is easy to understand - once skip a number and once take it and multiply it\\n    //Can be approached similar to coin change problem\\n    int solve(int n, int i){\\n        if(n == 0) return 1;\\n        if(n < 0 || i <= 0) return 0;\\n        int res = solve(n, i-1);               //once skip the number\\n        res = max(res, i*solve(n-i, i));   //consider it and multiply\\n        return res;\\n    }\\n    int integerBreak(int n) {\\n       return solve(n, n-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //top-down approach\\n    int integerBreak(int n) {\\n        vector<vector<int>> dp(n+1, vector<int> (n+1, 1 ));\\n        for(int i = 2; i <= n; ++i){\\n            for(int j = 2; j <= n; ++j){\\n                dp[i][j] = dp[i-1][j];\\n                if(i-1 <= j){\\n                    dp[i][j] = max(dp[i][j], (i-1)*dp[i][j -(i-1)]);\\n                }\\n            }\\n        }\\n        return dp[n][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2184043,
                "title": "math-c-100-faster",
                "content": "class Solution {\\npublic:\\n    \\n    // it is always optimal to split the number in form 2x+3y  if n>5\\n    // example - 8 as 3+3+2, 10 as 3+3+2+2\\n    // Proof intuition\\n    // Say number is of form 6+x, now product is 6*x but if we make it as 3+3+x its product is 9*x\\n    // also its better to split it into more threes than two as 3*(x-3) >= 2*(x-2) for x>=5\\n    // now we are left if three cases :\\n    // n%3 == 0 split it as n/3 3\\'s\\n    // n%3 == 1 split it as (n/3 -1) 3\\'s and two 2\\'s\\n    // n%3 == 2 split it as n/3  3\\'s and one two\\n    // can be done in O(logn) with binary exponentiation\\n    \\n    int binexp(int a,int b){\\n        if(b == 0) return 1;\\n        int res = binexp(a,b/2);\\n        if(b%2 == 0) return (res*res);\\n        return (a*res*res);\\n    }\\n    \\n    \\n    int integerBreak(int n) {\\n        // handle 2 to 5 separately\\n        if(n == 2) return 1;\\n        if(n == 3) return 2;\\n        if(n == 4) return 4;\\n        if(n == 5) return 6;\\n        \\n        if(n%3 == 0){\\n            return binexp(3,n/3);\\n        }\\n        if(n%3 == 1){\\n            return binexp(3,n/3 -1)*4;\\n        }\\n        if(n%3 == 2){\\n            return binexp(3,n/3)*2;\\n        }\\n        return 1;\\n    }\\n};``",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    // it is always optimal to split the number in form 2x+3y  if n>5\\n    // example - 8 as 3+3+2, 10 as 3+3+2+2\\n    // Proof intuition\\n    // Say number is of form 6+x, now product is 6*x but if we make it as 3+3+x its product is 9*x\\n    // also its better to split it into more threes than two as 3*(x-3) >= 2*(x-2) for x>=5\\n    // now we are left if three cases :\\n    // n%3 == 0 split it as n/3 3\\'s\\n    // n%3 == 1 split it as (n/3 -1) 3\\'s and two 2\\'s\\n    // n%3 == 2 split it as n/3  3\\'s and one two\\n    // can be done in O(logn) with binary exponentiation\\n    \\n    int binexp(int a,int b){\\n        if(b == 0) return 1;\\n        int res = binexp(a,b/2);\\n        if(b%2 == 0) return (res*res);\\n        return (a*res*res);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2180665,
                "title": "python3-dp-top-down-approach-faster-than-96",
                "content": "```\\nclass Solution:\\n    result = {1:1,2:1,3:2,4:4,5:6,6:9,7:12,8:18,9:27,10:36}\\n    def integerBreak(self, n: int) -> int:\\n        try:\\n            return self.result[n]\\n        except:\\n            x = float(\"-inf\")\\n            for i in range(1,n):\\n                j = n-1\\n                while j>0:\\n                    if i+j==n:\\n                        k = self.integerBreak(i)*self.integerBreak(j)\\n                        x = max(x,k)\\n                    j-=1\\n            self.result[n] = x\\n            return self.result[n]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    result = {1:1,2:1,3:2,4:4,5:6,6:9,7:12,8:18,9:27,10:36}\\n    def integerBreak(self, n: int) -> int:\\n        try:\\n            return self.result[n]\\n        except:\\n            x = float(\"-inf\")\\n            for i in range(1,n):\\n                j = n-1\\n                while j>0:\\n                    if i+j==n:\\n                        k = self.integerBreak(i)*self.integerBreak(j)\\n                        x = max(x,k)\\n                    j-=1\\n            self.result[n] = x\\n            return self.result[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1837121,
                "title": "c-top-down-dp-easy-to-understand",
                "content": "**Approach:-**\\n\\nIn dp helper function i have taken three arguments n, dp array and m\\nIn each recursive call we will try with the product of all possible number from 1 to n and check at which case we get maximum answer.\\nAfter that if n!=m (m is the original number itself) then n itself may be the possible maximum product, so we have checked the max(ans,n) only when n is not equal to the original input number. \\nKindly have a look into the code below for better understanding\\n\\n**Complexity:-**\\n**Time :-** O(n^2)\\n**Space :-** O(n)\\n\\n**Code:-**\\n```\\nclass Solution {\\n    int helper(int n,vector<int> &dp,int m){\\n        if(n==1){\\n            return dp[n] = 1;\\n        }\\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        int ans = 1;\\n        for(int i=1;i<=n;i++){\\n            if(n-i>0){\\n                ans = max(ans,(i*helper(n-i,dp,m)));\\n            }\\n        }\\n        if(n!=m){\\n            ans = max(ans,n);\\n        }\\n        return dp[n]=ans;\\n    }\\npublic:\\n    int integerBreak(int n) {\\n        vector<int> dp(n+1,-1);\\n        return helper(n,dp,n);\\n    }\\n};\\n```\\n\\nHope you liked it, thanks :)",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int helper(int n,vector<int> &dp,int m){\\n        if(n==1){\\n            return dp[n] = 1;\\n        }\\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        int ans = 1;\\n        for(int i=1;i<=n;i++){\\n            if(n-i>0){\\n                ans = max(ans,(i*helper(n-i,dp,m)));\\n            }\\n        }\\n        if(n!=m){\\n            ans = max(ans,n);\\n        }\\n        return dp[n]=ans;\\n    }\\npublic:\\n    int integerBreak(int n) {\\n        vector<int> dp(n+1,-1);\\n        return helper(n,dp,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836015,
                "title": "c-0ms-faster-than-100-recursion-memoization",
                "content": "The idea is to first think of a Recursive Approach and then memoize it\\n\\n### Recurisive Approach \\n```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        if(n<0)\\n            return 0;\\n        if(n==0)\\n           return 1;\\n        if(n==1)\\n            return 1;\\n        if(n==2)\\n            return 1;\\n        if(n==3)\\n            return 2;\\n        if(n==4)\\n            return 4;\\n        if(n==5)\\n            return 6;\\n        if(n==6)\\n            return 9;\\n   \\n        int ans=INT_MIN;\\n        for(int i=1;i<=n;i++)\\n        {\\n            ans=max(ans,i*integerBreak(n-i));\\n        }\\n        return ans==INT_MIN?-1:ans;\\n    }\\n};\\n```\\n\\n### Recurisive + Memoization \\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(int n,vector<int> &t)\\n    {\\n        if(n<0)\\n            return 0;\\n        if(t[n]!=-1)\\n            return t[n];\\n        int ans=INT_MIN;\\n        for(int i=1;i<=n;i++)\\n        {\\n            ans=max(ans,i*solve(n-i,t));\\n        }\\n        \\n        return t[n]= ans==INT_MIN?-1:ans;\\n        \\n        \\n    }\\n    \\n    int integerBreak(int n) {\\n        vector<int> t(60,-1);\\n\\t\\tt[0]=0\\n\\t\\tt[1]=1;\\n        t[2]=1;\\n        t[3]=2;\\n        t[4]=4;\\n        t[5]=6;\\n        t[6]=9;\\n        return solve(n,t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        if(n<0)\\n            return 0;\\n        if(n==0)\\n           return 1;\\n        if(n==1)\\n            return 1;\\n        if(n==2)\\n            return 1;\\n        if(n==3)\\n            return 2;\\n        if(n==4)\\n            return 4;\\n        if(n==5)\\n            return 6;\\n        if(n==6)\\n            return 9;\\n   \\n        int ans=INT_MIN;\\n        for(int i=1;i<=n;i++)\\n        {\\n            ans=max(ans,i*integerBreak(n-i));\\n        }\\n        return ans==INT_MIN?-1:ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(int n,vector<int> &t)\\n    {\\n        if(n<0)\\n            return 0;\\n        if(t[n]!=-1)\\n            return t[n];\\n        int ans=INT_MIN;\\n        for(int i=1;i<=n;i++)\\n        {\\n            ans=max(ans,i*solve(n-i,t));\\n        }\\n        \\n        return t[n]= ans==INT_MIN?-1:ans;\\n        \\n        \\n    }\\n    \\n    int integerBreak(int n) {\\n        vector<int> t(60,-1);\\n\\t\\tt[0]=0\\n\\t\\tt[1]=1;\\n        t[2]=1;\\n        t[3]=2;\\n        t[4]=4;\\n        t[5]=6;\\n        t[6]=9;\\n        return solve(n,t);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1699371,
                "title": "python-solution-o-1-method-easy-to-understand-with-explanation",
                "content": "The main idea is --  **break it into 3 as many as possible**.\\nif  4 --> 2 x 2. (They are the same no matter u break it or not)\\nif  5 --> 2 x 3\\nif 6  --> 3 x 3 \\nif 7 --> 3 x 4   (because 3 * 3 * 1 is useless, just take 3 * 4)\\nif 8 --> 3 x 3 x 2\\n\\nSo numbers greater than 3 should be breakdown\\n\\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        if n == 2 or n == 3:\\n            return n - 1                # must break into 1 & (n-1)\\n        \\n        num_3 = n // 3                  # break the number into (3+3+3+...) + remainder\\n        \\n        if n%3 == 0:                    \\n            return 3**num_3             # (3+3+3+...)\\n        if n%3 == 2:\\n            return (3**num_3) * 2       # (3+3+3+...) + 2     \\n        if n%3 == 1:\\n            return 3**(num_3-1) * 4     # (3+3+3+...) + 1 --> (3+3+...) + 3 + 1 -- > (3+3+...) + 4",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "The main idea is --  **break it into 3 as many as possible**.\\nif  4 --> 2 x 2. (They are the same no matter u break it or not)\\nif  5 --> 2 x 3\\nif 6  --> 3 x 3 \\nif 7 --> 3 x 4   (because 3 * 3 * 1 is useless, just take 3 * 4)\\nif 8 --> 3 x 3 x 2\\n\\nSo numbers greater than 3 should be breakdown\\n\\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        if n == 2 or n == 3:\\n            return n - 1                # must break into 1 & (n-1)\\n        \\n        num_3 = n // 3                  # break the number into (3+3+3+...) + remainder\\n        \\n        if n%3 == 0:                    \\n            return 3**num_3             # (3+3+3+...)\\n        if n%3 == 2:\\n            return (3**num_3) * 2       # (3+3+3+...) + 2     \\n        if n%3 == 1:\\n            return 3**(num_3-1) * 4     # (3+3+3+...) + 1 --> (3+3+...) + 3 + 1 -- > (3+3+...) + 4",
                "codeTag": "Java"
            },
            {
                "id": 1434209,
                "title": "c-javascript-0ms-recursive-memoization-dp-2d-approach",
                "content": "**Approach** : This question is direct implementation of rod cutting problem which is a very common problem which is itself a direct implementation of unbounded 0-1 knapsack.\\n\\n### CPP Recursive Approach 72 ms\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(int n, int idx ) {\\n        \\n        if(n == 0 || idx == 0) return 1 ;\\n        \\n        if(idx > n) return solve(n,idx-1);\\n        \\n        return max((idx * solve(n-idx,idx)),solve(n,idx-1));\\n        \\n    }\\n    \\n    int integerBreak(int n) {\\n        return solve(n,n-1);\\n    }\\n};\\n\\n```\\n\\n### Cpp Memoization Approach 0ms\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[59][58];\\n    \\n    int solve(int n, int idx ) {\\n        \\n        if(n == 0 || idx == 0) return 1 ;\\n        \\n        if(dp[n][idx] != -1) return dp[n][idx];\\n        \\n        if(idx > n) return dp[n][idx] = solve(n,idx-1);\\n        \\n        return dp[n][idx] = max((idx * solve(n-idx,idx)),solve(n,idx-1));\\n        \\n    }\\n    \\n    int integerBreak(int n) {\\n        \\n        for(int rctr = 0 ; rctr <= 58 ; rctr++)\\n            for(int cctr = 0 ; cctr <= 57 ; cctr++)\\n                dp[rctr][cctr] = -1 ;\\n        \\n        return solve(n,n-1);\\n    }\\n};\\n```\\n\\n### Cpp Dynamic Programming - Bottom Up Approach \\n\\n```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        \\n        int dp[n+1][n];\\n        \\n        for(int ctr = 0 ; ctr < n+1 ; ctr++)\\n            dp[ctr][0] = 1 ;\\n        \\n        for(int ctr = 0 ; ctr < n ; ctr ++)\\n            dp[0][ctr] = 1 ;\\n        \\n        for(int row = 1 ; row < n+1 ; row ++)\\n            for(int col = 1 ; col < n ; col ++)\\n            {\\n                \\n                if(row>=col)\\n                    dp[row][col] = max((col*dp[row-col][col]),dp[row][col-1]);\\n                else\\n                    dp[row][col] = dp[row][col-1];\\n                    \\n            }\\n        \\n        \\n        return dp[n][n-1];\\n        \\n    }\\n};\\n```\\n\\n### Javascript - Dynamic Programming - Bottom Up Approach\\n\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar integerBreak = function(n) {\\n        let dp=[];\\n    \\n        for(let row = 0 ; row < n+1 ; row ++)\\n        {\\n            let array = [];\\n            for(let col = 0 ; col < n ; col ++)\\n                array.push(1);\\n            dp.push(array);\\n        }\\n        \\n        for(let row = 1 ; row < n+1 ; row ++)\\n            for(let col = 1 ; col < n ; col ++)\\n            {\\n                \\n                if(row>=col)\\n                    dp[row][col] = Math.max((col*dp[row-col][col]),dp[row][col-1]);\\n                else\\n                    dp[row][col] = dp[row][col-1];\\n                    \\n            }\\n        \\n        \\n        return dp[n][n-1];\\n};\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "JavaScript",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(int n, int idx ) {\\n        \\n        if(n == 0 || idx == 0) return 1 ;\\n        \\n        if(idx > n) return solve(n,idx-1);\\n        \\n        return max((idx * solve(n-idx,idx)),solve(n,idx-1));\\n        \\n    }\\n    \\n    int integerBreak(int n) {\\n        return solve(n,n-1);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[59][58];\\n    \\n    int solve(int n, int idx ) {\\n        \\n        if(n == 0 || idx == 0) return 1 ;\\n        \\n        if(dp[n][idx] != -1) return dp[n][idx];\\n        \\n        if(idx > n) return dp[n][idx] = solve(n,idx-1);\\n        \\n        return dp[n][idx] = max((idx * solve(n-idx,idx)),solve(n,idx-1));\\n        \\n    }\\n    \\n    int integerBreak(int n) {\\n        \\n        for(int rctr = 0 ; rctr <= 58 ; rctr++)\\n            for(int cctr = 0 ; cctr <= 57 ; cctr++)\\n                dp[rctr][cctr] = -1 ;\\n        \\n        return solve(n,n-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        \\n        int dp[n+1][n];\\n        \\n        for(int ctr = 0 ; ctr < n+1 ; ctr++)\\n            dp[ctr][0] = 1 ;\\n        \\n        for(int ctr = 0 ; ctr < n ; ctr ++)\\n            dp[0][ctr] = 1 ;\\n        \\n        for(int row = 1 ; row < n+1 ; row ++)\\n            for(int col = 1 ; col < n ; col ++)\\n            {\\n                \\n                if(row>=col)\\n                    dp[row][col] = max((col*dp[row-col][col]),dp[row][col-1]);\\n                else\\n                    dp[row][col] = dp[row][col-1];\\n                    \\n            }\\n        \\n        \\n        return dp[n][n-1];\\n        \\n    }\\n};\\n```\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar integerBreak = function(n) {\\n        let dp=[];\\n    \\n        for(let row = 0 ; row < n+1 ; row ++)\\n        {\\n            let array = [];\\n            for(let col = 0 ; col < n ; col ++)\\n                array.push(1);\\n            dp.push(array);\\n        }\\n        \\n        for(let row = 1 ; row < n+1 ; row ++)\\n            for(let col = 1 ; col < n ; col ++)\\n            {\\n                \\n                if(row>=col)\\n                    dp[row][col] = Math.max((col*dp[row-col][col]),dp[row][col-1]);\\n                else\\n                    dp[row][col] = dp[row][col-1];\\n                    \\n            }\\n        \\n        \\n        return dp[n][n-1];\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1251064,
                "title": "java-tabulation-solution-with-detailed-explanation",
                "content": "Consider an array where each index i contains the maximum product the number i can be broken into.\\n\\n- index 0 and 1 must be 0 as they cannot be broken down further.\\n- index 2 contains 1 as 1 + 1 = 2 and the product is 1 * 1 = 1.\\n\\nTaking the example where n = 4:\\n\\nThis is the initial state\\n\\n**0  1  2  3  4**  \\n\\n0  0  1  0  0 \\n\\nWhen filling in the 3rd index we consider the possible combos that can make 3.\\n\\n2 + 1 = 3\\n\\n1 + 2 = 3\\n\\n(Due to symmetry we only need to check half of the pairs that sum to n)\\n\\nFor the numbers 1 and 2, we can either use the numbers itself to form the product or the integer break given by these numbers (dp[1] or dp[2]). In this case using the numbers itself yields the larger product (as 1 > dp[1] and 2 > dp[2]). So we can now fill dp[3] with 1*2.\\n\\n**0  1  2  3  4**  \\n\\n0  0  1  2  0  \\n\\nSimilar logic can be applied for index 4.\\n\\n1+3 and 2+2 sum to 4. 1 is greater than the integer break of 1 (which is dp[1] = 0), and 3 is greater than the integer break of 3 (which is dp[3] = 2). So, dp[4] = 1*3 = 3. \\n\\nRepeating for 2+2, the number 2 is greater than the integer break of 2 (which is dp[1] = 1) so max product is 2*2=4, this is greater than dp[4] currently (which is 3), so set dp[4] = 4.,\\n\\nThis recurrence can be applied to fill the array. \\n\\n1. For an index n in the array.\\n2. Check all the pairs of numbers that sum to n.\\n3. Consider the pair a and b that sum to n, then **dp[n] is the maximum of the current value stored in it, or the product of  max(a and dp[a]) * max(b and dp[b])** (as we can either use the index of a/b or the integer break of a/b).\\n4. Once we fill all indices we can return dp[n].\\n```\\npublic int integerBreak(int n) {\\n       int[] dp = new int[n + 1];\\n       dp[1] = 1;\\n       dp[2] = 1;\\n\\t   // i moves across the dp array and j generates the pairs a and b that sum to n.\\n       for (int i = 3; i <= n; i++) {\\n           for (int j = 1; j <= i/2; j++) {\\n               int a = j;\\n               int b = i - j;\\n\\t\\t\\t   // dp[i] is the maximum of what is already in it or the maximum product\\n\\t\\t\\t   // that can be generated by multiplying max(a, a\\'s word break) and max(b, b\\'s word break).\\n               dp[i] = Math.max(dp[i], Math.max(dp[a], a) * Math.max(dp[b], b));\\n           }\\n       } \\n       return dp[n];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\npublic int integerBreak(int n) {\\n       int[] dp = new int[n + 1];\\n       dp[1] = 1;\\n       dp[2] = 1;\\n\\t   // i moves across the dp array and j generates the pairs a and b that sum to n.\\n       for (int i = 3; i <= n; i++) {\\n           for (int j = 1; j <= i/2; j++) {\\n               int a = j;\\n               int b = i - j;\\n\\t\\t\\t   // dp[i] is the maximum of what is already in it or the maximum product\\n\\t\\t\\t   // that can be generated by multiplying max(a, a\\'s word break) and max(b, b\\'s word break).\\n               dp[i] = Math.max(dp[i], Math.max(dp[a], a) * Math.max(dp[b], b));\\n           }\\n       } \\n       return dp[n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 699250,
                "title": "python-very-simple-dp-solution-o-n",
                "content": "```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        ## RC ##\\n        ## APPROACH : DP ##\\n        ## LOGIC : ANY NUMBER MORE THAN 3, will have maximum product when all its factors are 2,3\\n        ## EX : 4 => 2*2 , 7 => 3*2*2, 9 => 3*3*3\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        if(n <= 2): return 1\\n        dp = [0,0,1,2]                          # base cases for 2,3\\n        for i in range(4, n + 1):\\n            dp.append(max( max(3 * dp[i - 3], 3 * (i - 3)), max(2 * dp[i - 2], 2 * (i - 2)) ))         # appending to dp list\\n        return dp[n]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        ## RC ##\\n        ## APPROACH : DP ##\\n        ## LOGIC : ANY NUMBER MORE THAN 3, will have maximum product when all its factors are 2,3\\n        ## EX : 4 => 2*2 , 7 => 3*2*2, 9 => 3*3*3\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        if(n <= 2): return 1\\n        dp = [0,0,1,2]                          # base cases for 2,3\\n        for i in range(4, n + 1):\\n            dp.append(max( max(3 * dp[i - 3], 3 * (i - 3)), max(2 * dp[i - 2], 2 * (i - 2)) ))         # appending to dp list\\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632342,
                "title": "easy-c-solution-dp-memoization-100-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int help(int n,vector<int> &dp){\\n        if(n==0) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        int ans=n;\\n        for(int i=1;i<=n;i++){\\n            ans=max(ans,i*help(n-i,dp));\\n        }\\n        return dp[n]=ans;\\n    }\\n    int integerBreak(int n) {\\n        if(n<4) return n-1;\\n        vector<int> dp(n+1,-1);\\n        return help(n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int help(int n,vector<int> &dp){\\n        if(n==0) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        int ans=n;\\n        for(int i=1;i<=n;i++){\\n            ans=max(ans,i*help(n-i,dp));\\n        }\\n        return dp[n]=ans;\\n    }\\n    int integerBreak(int n) {\\n        if(n<4) return n-1;\\n        vector<int> dp(n+1,-1);\\n        return help(n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431540,
                "title": "java-recursion-memoization-dp-linear-solution-optimized-solution",
                "content": "\\n\\n# Recursion code\\n```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        return helper(n-1, n);\\n        \\n    }\\n    int helper(int n, int total)\\n    {\\n        if(n <= 1)\\n        return 1;\\n        int notpick = helper(n-1, total);\\n        int pick = 0;\\n        if(total >= n)\\n        pick = n * helper(n, total - n);\\n\\n        return Math.max(pick, notpick);\\n    }\\n}\\n```\\n\\n# Rcursion + Memoization\\n\\n```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        int dp[] = new int[n+1];\\n        dp[0] = 0;\\n        dp[1] = 0;\\n        dp[2] = 1;\\n        return helper(n-1, n, dp);\\n    }\\n    int helper(int n, int total, int dp[])\\n    {\\n        if(n <= 1)\\n        return 1;\\n        int notpick = helper(n-1, total, dp);\\n        int pick = 0;\\n        if(total >= n)\\n        pick = n * helper(n, total - n, dp);\\n        \\n        return dp[n] = Math.max(pick, notpick);\\n    }\\n}\\n```\\n\\n# Dp code\\n```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        int dp[] = new int[n+1];\\n        dp[0] = 0;\\n        dp[1] = 0;\\n        dp[2] = 1;\\n        \\n        for(int i=3;i<=n;i++)\\n            for(int j=1;j<=i;j++)\\n                dp[i] = Math.max(dp[i], j*Math.max(dp[i-j], i-j));\\n\\n        return dp[n];\\n    }\\n}\\n```\\n\\n# Linear Solution\\n```\\nclass Solution {\\n    public int integerBreak(int n)\\n    {\\n        if (n == 2 || n == 3) return n-1;\\n        int res = 1;\\n        while (n>4){\\n            n -= 3;\\n            res *= 3;\\n        }\\n        return (n*res);\\n    }\\n}\\n```\\n\\n# Optimized Solution\\n```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        if(n<=3)\\n            return n-1;\\n        else if(n%3==1)\\n            return (int)(Math.pow(3,n/3 - 1))*4;\\n        else if(n%3==2)\\n            return 2*((int)Math.pow(3,n/3));\\n        else\\n            return (int)Math.pow(3, n/3);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        return helper(n-1, n);\\n        \\n    }\\n    int helper(int n, int total)\\n    {\\n        if(n <= 1)\\n        return 1;\\n        int notpick = helper(n-1, total);\\n        int pick = 0;\\n        if(total >= n)\\n        pick = n * helper(n, total - n);\\n\\n        return Math.max(pick, notpick);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        int dp[] = new int[n+1];\\n        dp[0] = 0;\\n        dp[1] = 0;\\n        dp[2] = 1;\\n        return helper(n-1, n, dp);\\n    }\\n    int helper(int n, int total, int dp[])\\n    {\\n        if(n <= 1)\\n        return 1;\\n        int notpick = helper(n-1, total, dp);\\n        int pick = 0;\\n        if(total >= n)\\n        pick = n * helper(n, total - n, dp);\\n        \\n        return dp[n] = Math.max(pick, notpick);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        int dp[] = new int[n+1];\\n        dp[0] = 0;\\n        dp[1] = 0;\\n        dp[2] = 1;\\n        \\n        for(int i=3;i<=n;i++)\\n            for(int j=1;j<=i;j++)\\n                dp[i] = Math.max(dp[i], j*Math.max(dp[i-j], i-j));\\n\\n        return dp[n];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int integerBreak(int n)\\n    {\\n        if (n == 2 || n == 3) return n-1;\\n        int res = 1;\\n        while (n>4){\\n            n -= 3;\\n            res *= 3;\\n        }\\n        return (n*res);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        if(n<=3)\\n            return n-1;\\n        else if(n%3==1)\\n            return (int)(Math.pow(3,n/3 - 1))*4;\\n        else if(n%3==2)\\n            return 2*((int)Math.pow(3,n/3));\\n        else\\n            return (int)Math.pow(3, n/3);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186293,
                "title": "one-of-those-easy-dps",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[59][3];\\n    int find(int n,int c)\\n    {\\n        if(n==0) return 1;\\n        if(dp[n][c]!=-1) return dp[n][c];\\n        int a=0;\\n        for(int i=1;i<=n;++i)\\n        {\\n            if(c>1 && n-i>0)\\n            a=max(a,find(n-i,c-1)*i);\\n            else if(c==1 && n-i>=0)\\n            a=max(a,find(n-i,c)*i);\\n        }\\n        return dp[n][c]=a;\\n    }\\n    int integerBreak(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return find(n,2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[59][3];\\n    int find(int n,int c)\\n    {\\n        if(n==0) return 1;\\n        if(dp[n][c]!=-1) return dp[n][c];\\n        int a=0;\\n        for(int i=1;i<=n;++i)\\n        {\\n            if(c>1 && n-i>0)\\n            a=max(a,find(n-i,c-1)*i);\\n            else if(c==1 && n-i>=0)\\n            a=max(a,find(n-i,c)*i);\\n        }\\n        return dp[n][c]=a;\\n    }\\n    int integerBreak(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return find(n,2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045032,
                "title": "0-ms-4-lines-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        \\n        if(n <= 3) return n-1;\\n        else if(n % 3 == 0) return pow(3, n/3);\\n        else if(n % 3 == 1) return 4 * pow(3, (n-4)/3);\\n        else return 2*pow(3, n/3);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        \\n        if(n <= 3) return n-1;\\n        else if(n % 3 == 0) return pow(3, n/3);\\n        else if(n % 3 == 1) return 4 * pow(3, (n-4)/3);\\n        else return 2*pow(3, n/3);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2520834,
                "title": "java-top-down-dp-intution-solution",
                "content": "**Basic Intution** : maximum product  can be achieved in two cases \\n\\t\\t\\t\\t\\t\\t\\t\\t1) for each i till n we calculate i *(n-i) and take max of it\\n\\t\\t\\t\\t\\t\\t\\t\\t2)  for each i till n we calculate i* recursion of (n-i)  and take max of it. \\nWe use dp to store repetitive subproblems\\n\\tdp[i] represents max product we can achieve breaking the sum i\\n\\tNote: it necessarily doesn\\'t need to i*subproblem(n-i) for ans to be max the answer can be maximum in cases where i*(n-1)\\n\\tEg: 5\\n\\t\\tCase1: n=5 i=2\\n\\t\\t\\t3+2=5 \\n\\t\\t\\t3x2=6\\n\\t\\tCase 2: n=5 i=2\\n\\t\\t\\t2*memo(3,dp)=2*2=4;\\n\\t\\tans=max(case1,case2);\\n```\\nclass Solution {\\n    public int memo(int n,int[] dp){\\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        int max=0;\\n        for(int i=1;i<n;i++){\\n            max=Math.max(max,Math.max(i*(n-i),i*memo(n-i,dp)));\\n        }\\n        return dp[n]=max;\\n    }\\n    public int integerBreak(int n) {\\n        int dp[]=new int[n+1];\\n        Arrays.fill(dp,-1);\\n        dp[0]=0;\\n        dp[1]=1;\\n        memo(n,dp);\\n            // System.out.print(dp[i]+\" \");\\n        return dp[n];\\n    }\\n}\\n```\\nI hope the intution makes it clear .\\nPlease upvote if it helps :)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int memo(int n,int[] dp){\\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        int max=0;\\n        for(int i=1;i<n;i++){\\n            max=Math.max(max,Math.max(i*(n-i),i*memo(n-i,dp)));\\n        }\\n        return dp[n]=max;\\n    }\\n    public int integerBreak(int n) {\\n        int dp[]=new int[n+1];\\n        Arrays.fill(dp,-1);\\n        dp[0]=0;\\n        dp[1]=1;\\n        memo(n,dp);\\n            // System.out.print(dp[i]+\" \");\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424004,
                "title": "c-memoization-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int>mp;\\n    int integerBreak(int n) \\n    {\\n         if(n==1)\\n         {\\n             return 1;\\n         }\\n        \\n         int ans=INT_MIN;\\n         if(mp.find(n)!=mp.end())\\n         {\\n             return mp[n];\\n         }\\n         for(int i=1;i<n;i++)\\n         {\\n            int choise1=integerBreak(i)*integerBreak(n-i);\\n            int choise2=integerBreak(i)*(n-i);\\n            int choise3=(i)*integerBreak(n-i);\\n            int choise4=(i)*(n-i);\\n             \\n            int temp1=max(choise1,choise2);\\n            int temp2=max(choise3,choise4);\\n             \\n            ans=max(ans,max(temp1,temp2));\\n         }\\n         return mp[n] =ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int>mp;\\n    int integerBreak(int n) \\n    {\\n         if(n==1)\\n         {\\n             return 1;\\n         }\\n        \\n         int ans=INT_MIN;\\n         if(mp.find(n)!=mp.end())\\n         {\\n             return mp[n];\\n         }\\n         for(int i=1;i<n;i++)\\n         {\\n            int choise1=integerBreak(i)*integerBreak(n-i);\\n            int choise2=integerBreak(i)*(n-i);\\n            int choise3=(i)*integerBreak(n-i);\\n            int choise4=(i)*(n-i);\\n             \\n            int temp1=max(choise1,choise2);\\n            int temp2=max(choise3,choise4);\\n             \\n            ans=max(ans,max(temp1,temp2));\\n         }\\n         return mp[n] =ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2407006,
                "title": "python3-solved-using-bottom-up-dp-tabulation",
                "content": "```\\nclass Solution:\\n    #Time-Complexity: O(n^2)\\n    #Space-Complexity: O(n)\\n    def integerBreak(self, n: int) -> int:\\n        #we know we can reduce n as \\n        # n\\n    #   /  \\\\\\n    #  1   n-1\\n    #     /  \\\\\\n    #    1   n-2\\n    #     ...\\n    \\n        #Basically, we can keep reducing n like this in this tree structure above!\\n        #This is the pattern I recognized! I recognized for given n, there are \\n        #potential sums of (1, n-1), (2, n-2), (3, n-3), ..., (n//2, n//2)!\\n        #For each pair, I can compare the direct number with the max product decomposition\\n        #and take the max of two!\\n        \\n        \\n        #Reason for comparison: for each of the sum factor of given n, either leave it\\n        #undecomposed or decompose it into further sum factors if the product of sum\\n        #factors produce ultimately a number that exceeds the orignal sum factor! This way\\n        #I am maximing product contribution for each and every sum factor!\\n        \\n        #For example, for 5, we decompose it into 2 and 3, since 2*3 > 5, so it will\\n        #maximize our product further!\\n        \\n        #However, for 3, we don\\'t decompose since we can maximally decompose to\\n        #1 and 2 but 1*2 < 3!\\n        \\n        #Do that for both numbers of each pair and take the product!\\n        #Whatever is largest across the pairs will be answer for given input n!\\n    \\n        dp = [-1] * (n+1)\\n        #add dp-base!\\n        dp[1] = 1\\n    \\n        #this problem has only one state parameter: the given number to start decomposing           #from!\\n        #iterate through each subproblem or state!\\n        #Bottom-Up\\n        for i in range(2, n+1, 1):\\n            upper_bound = (i // 2) + 1\\n            #iterate through all possible pairs!\\n            for j in range(1, upper_bound, 1):\\n                #current pair (j, i-j), which we probably already solved its subproblems!\\n                first = max(j, dp[j])\\n                second = max(i-j, dp[i-j])\\n                #get product for current pair!\\n                sub_ans = first * second\\n                #compare current pair\\'s product against built up answer maximum!\\n                dp[i] = max(dp[i], sub_ans)\\n    \\n        #then, once we are done, we can return dp[n]!\\n        return dp[n]",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    #Time-Complexity: O(n^2)\\n    #Space-Complexity: O(n)\\n    def integerBreak(self, n: int) -> int:\\n        #we know we can reduce n as \\n        # n\\n    #   /  \\\\\\n    #  1   n-1\\n    #     /  \\\\\\n    #    1   n-2\\n    #     ...\\n    \\n        #Basically, we can keep reducing n like this in this tree structure above!\\n        #This is the pattern I recognized! I recognized for given n, there are \\n        #potential sums of (1, n-1), (2, n-2), (3, n-3), ..., (n//2, n//2)!\\n        #For each pair, I can compare the direct number with the max product decomposition\\n        #and take the max of two!\\n        \\n        \\n        #Reason for comparison: for each of the sum factor of given n, either leave it\\n        #undecomposed or decompose it into further sum factors if the product of sum\\n        #factors produce ultimately a number that exceeds the orignal sum factor! This way\\n        #I am maximing product contribution for each and every sum factor!\\n        \\n        #For example, for 5, we decompose it into 2 and 3, since 2*3 > 5, so it will\\n        #maximize our product further!\\n        \\n        #However, for 3, we don\\'t decompose since we can maximally decompose to\\n        #1 and 2 but 1*2 < 3!\\n        \\n        #Do that for both numbers of each pair and take the product!\\n        #Whatever is largest across the pairs will be answer for given input n!\\n    \\n        dp = [-1] * (n+1)\\n        #add dp-base!\\n        dp[1] = 1\\n    \\n        #this problem has only one state parameter: the given number to start decomposing           #from!\\n        #iterate through each subproblem or state!\\n        #Bottom-Up\\n        for i in range(2, n+1, 1):\\n            upper_bound = (i // 2) + 1\\n            #iterate through all possible pairs!\\n            for j in range(1, upper_bound, 1):\\n                #current pair (j, i-j), which we probably already solved its subproblems!\\n                first = max(j, dp[j])\\n                second = max(i-j, dp[i-j])\\n                #get product for current pair!\\n                sub_ans = first * second\\n                #compare current pair\\'s product against built up answer maximum!\\n                dp[i] = max(dp[i], sub_ans)\\n    \\n        #then, once we are done, we can return dp[n]!\\n        return dp[n]",
                "codeTag": "Java"
            },
            {
                "id": 2334645,
                "title": "very-easy-c-solution-in-o-log-n-3",
                "content": "For solution explanation please call +91 8529463177 (indian number) \\n```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        if(n<=3) return n-1;\\n        if(n%3==0){\\n            return pow(3,n/3);\\n        }\\n        else if(n%3==1){\\n            return pow(3,n/3-1)*4;\\n        }\\n        else{\\n            return pow(3,n/3)*2;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        if(n<=3) return n-1;\\n        if(n%3==0){\\n            return pow(3,n/3);\\n        }\\n        else if(n%3==1){\\n            return pow(3,n/3-1)*4;\\n        }\\n        else{\\n            return pow(3,n/3)*2;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2224747,
                "title": "c-java-python-super-easy-maths-o-n-3-time-and-o-1-space",
                "content": "You just need to check: `n % 3`.      The idea is to utilize as many 3\\'s as possible.\\n-  if n % 3 == 0, ans = 3 ^ (n / 3)                             \\n-  if n % 3 == 1, ans = 4 * (3 ^ (n / 3 - 1))                            \\n- else ans = 2 * (3 ^ (n / 3))   \\n\\nC++ implementation:\\n\\n```\\nclass Solution {\\npublic:\\n    ///////////////////////////////////////////////////////////////////////\\n    //  Just observe these test cases -                                 ///\\n    //    n       broken into       product         answer              ///\\n    //    7       3 + 4             3 * 4            12                 ///\\n    //    8       3 + 3 + 2         3 * 3 * 2        18                 ///\\n    //    9       3 + 3 + 3         3 * 3 * 3        27                 ///\\n    //    10      3 + 3 + 4         3 * 3 * 4        36                 ///\\n    //    11      3 + 3 + 3 + 2     3 * 3 * 3 * 2    54                 ///\\n    ///////////////////////////////////////////////////////////////////////\\n    //  The idea is to utilize as many 3\\'s as possible (~ n / 3)        ///\\n    //  if n % 3 == 0, ans = 3 ^ (n / 3)                                ///\\n    //  if n % 3 == 1, ans = 4 * (3 ^ (n / 3 - 1))                      ///\\n    //  else ans = 2 * (3 ^ (n / 3))                                    ///\\n    ///////////////////////////////////////////////////////////////////////\\n    // Time: O(n / 3), Space: O(1)                                      ///\\n    ///////////////////////////////////////////////////////////////////////\\n    int integerBreak(int n) {\\n        // edge cases\\n        if(n == 2 | n == 3) return n - 1;\\n        int ans = 1;\\n        if(n % 3 == 0) {\\n            for(int i = 0; i < n / 3; ++i)\\n                ans *= 3;\\n        } else if(n % 3 == 1) {\\n            for(int i = 0; i < n / 3 - 1; ++i)\\n                ans *= 3;\\n            ans *= 4;\\n        } else {\\n             for(int i = 0; i < n / 3; ++i)\\n                ans *= 3;\\n            ans *= 2;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nJava implementation:\\n```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        // edge cases\\n        if(n == 2 | n == 3) return n - 1;\\n        int ans = 1;\\n        if(n % 3 == 0) {\\n            for(int i = 0; i < n / 3; ++i)\\n                ans *= 3;\\n        } else if(n % 3 == 1) {\\n            for(int i = 0; i < n / 3 - 1; ++i)\\n                ans *= 3;\\n            ans *= 4;\\n        } else {\\n             for(int i = 0; i < n / 3; ++i)\\n                ans *= 3;\\n            ans *= 2;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nPython implementation:\\n```\\nclass Solution(object):\\n    def integerBreak(self, n):\\n        if n == 2 or n == 3:\\n            return n - 1\\n        ans = 1\\n        if n % 3 == 0:\\n            for i in range(n / 3):\\n                ans *= 3\\n        elif n % 3 == 1:\\n            for i in range(n / 3 - 1):\\n                ans *= 3;\\n            ans *= 4\\n        else:\\n            for i in range(n / 3):\\n                ans *= 3;\\n            ans *= 2\\n        return ans\\n        \\n```\\n\\nTime complexity: O (n / 3)\\nSpace complexity: O(1)\\n\\nThe time complexity can be brought down further by using a power function.\\n\\n\\u23E9 Thanks for reading. An upvote would be appreciated.   ^_^",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ///////////////////////////////////////////////////////////////////////\\n    //  Just observe these test cases -                                 ///\\n    //    n       broken into       product         answer              ///\\n    //    7       3 + 4             3 * 4            12                 ///\\n    //    8       3 + 3 + 2         3 * 3 * 2        18                 ///\\n    //    9       3 + 3 + 3         3 * 3 * 3        27                 ///\\n    //    10      3 + 3 + 4         3 * 3 * 4        36                 ///\\n    //    11      3 + 3 + 3 + 2     3 * 3 * 3 * 2    54                 ///\\n    ///////////////////////////////////////////////////////////////////////\\n    //  The idea is to utilize as many 3\\'s as possible (~ n / 3)        ///\\n    //  if n % 3 == 0, ans = 3 ^ (n / 3)                                ///\\n    //  if n % 3 == 1, ans = 4 * (3 ^ (n / 3 - 1))                      ///\\n    //  else ans = 2 * (3 ^ (n / 3))                                    ///\\n    ///////////////////////////////////////////////////////////////////////\\n    // Time: O(n / 3), Space: O(1)                                      ///\\n    ///////////////////////////////////////////////////////////////////////\\n    int integerBreak(int n) {\\n        // edge cases\\n        if(n == 2 | n == 3) return n - 1;\\n        int ans = 1;\\n        if(n % 3 == 0) {\\n            for(int i = 0; i < n / 3; ++i)\\n                ans *= 3;\\n        } else if(n % 3 == 1) {\\n            for(int i = 0; i < n / 3 - 1; ++i)\\n                ans *= 3;\\n            ans *= 4;\\n        } else {\\n             for(int i = 0; i < n / 3; ++i)\\n                ans *= 3;\\n            ans *= 2;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        // edge cases\\n        if(n == 2 | n == 3) return n - 1;\\n        int ans = 1;\\n        if(n % 3 == 0) {\\n            for(int i = 0; i < n / 3; ++i)\\n                ans *= 3;\\n        } else if(n % 3 == 1) {\\n            for(int i = 0; i < n / 3 - 1; ++i)\\n                ans *= 3;\\n            ans *= 4;\\n        } else {\\n             for(int i = 0; i < n / 3; ++i)\\n                ans *= 3;\\n            ans *= 2;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def integerBreak(self, n):\\n        if n == 2 or n == 3:\\n            return n - 1\\n        ans = 1\\n        if n % 3 == 0:\\n            for i in range(n / 3):\\n                ans *= 3\\n        elif n % 3 == 1:\\n            for i in range(n / 3 - 1):\\n                ans *= 3;\\n            ans *= 4\\n        else:\\n            for i in range(n / 3):\\n                ans *= 3;\\n            ans *= 2\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194081,
                "title": "easy-recursion-with-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[70];\\n    int f(int n){\\n        if(n<1)return 0;\\n        if(n==1 or n==2)return 1;\\n        if(dp[n]!=-1)return dp[n];\\n        int ans = 0;\\n        for(int k=1;k<n;k++)ans = max({ans,k*f(n-k),k*(n-k)});\\n        return dp[n] = ans;\\n    }\\n    int integerBreak(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return f(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[70];\\n    int f(int n){\\n        if(n<1)return 0;\\n        if(n==1 or n==2)return 1;\\n        if(dp[n]!=-1)return dp[n];\\n        int ans = 0;\\n        for(int k=1;k<n;k++)ans = max({ans,k*f(n-k),k*(n-k)});\\n        return dp[n] = ans;\\n    }\\n    int integerBreak(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return f(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113429,
                "title": "simple-unbounded-knapsack-variation",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[59][59];\\n    int answer(int n, int i){\\n        if(n<0||i==0){\\n            return 0;\\n        }\\n        if(n==0)\\n           return 1;\\n        if(dp[n][i]!=-1)\\n            return dp[n][i];\\n        if(i<=n){\\n            return dp[n][i]=max(i*answer(n-i,i-1),max(answer(n,i-1),i*answer(n-i,i)));\\n        }\\n        else{\\n            return dp[n][i]=answer(n,i-1);\\n        }\\n        \\n    }\\n    int integerBreak(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return answer(n,n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[59][59];\\n    int answer(int n, int i){\\n        if(n<0||i==0){\\n            return 0;\\n        }\\n        if(n==0)\\n           return 1;\\n        if(dp[n][i]!=-1)\\n            return dp[n][i];\\n        if(i<=n){\\n            return dp[n][i]=max(i*answer(n-i,i-1),max(answer(n,i-1),i*answer(n-i,i)));\\n        }\\n        else{\\n            return dp[n][i]=answer(n,i-1);\\n        }\\n        \\n    }\\n    int integerBreak(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return answer(n,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997682,
                "title": "javascript-dp-dfs-recursive-memoization-easy-and-fast",
                "content": "```\\n// Recursive Approach: TLE\\nvar integerBreak = function (n) {\\n    let res = 1;\\n\\n    function dfs(num) {\\n        if (num === 1) return 1;\\n\\n        let res = num;\\n        for (let i = 1; i <= num; i++) {\\n            const tmpRes = i * dfs(num - i);\\n            res = Math.max(tmpRes, res);\\n        }\\n\\n        return res;\\n    }\\n    for (let i = 1; i < n; i++) {\\n        const tmpRes = i * dfs(n - i);\\n        res = Math.max(tmpRes, res);\\n    }\\n    return res;\\n};\\n\\n// console.log(integerBreak(10));\\n// console.log(integerBreak(2));\\n\\n\\n// Memoized recursion\\nvar integerBreak = function (n) {\\n    let res = 1;\\n    let dp = new Array(n + 1).fill(-1);\\n    function dfs(num) {\\n        if (num === 1) return 1;\\n\\n        if (dp[num] !== -1) return dp[num];\\n        let res = num;\\n        for (let i = 1; i <= num; i++) {\\n            const tmpRes = i * dfs(num - i);\\n            res = Math.max(tmpRes, res);\\n        }\\n\\n        return dp[num] = res;\\n    }\\n    for (let i = 1; i < n; i++) {\\n        const tmpRes = i * dfs(n - i);\\n        res = Math.max(tmpRes, res);\\n    }\\n    return res;\\n};\\n\\nconsole.log(integerBreak(10));\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n// Recursive Approach: TLE\\nvar integerBreak = function (n) {\\n    let res = 1;\\n\\n    function dfs(num) {\\n        if (num === 1) return 1;\\n\\n        let res = num;\\n        for (let i = 1; i <= num; i++) {\\n            const tmpRes = i * dfs(num - i);\\n            res = Math.max(tmpRes, res);\\n        }\\n\\n        return res;\\n    }\\n    for (let i = 1; i < n; i++) {\\n        const tmpRes = i * dfs(n - i);\\n        res = Math.max(tmpRes, res);\\n    }\\n    return res;\\n};\\n\\n// console.log(integerBreak(10));\\n// console.log(integerBreak(2));\\n\\n\\n// Memoized recursion\\nvar integerBreak = function (n) {\\n    let res = 1;\\n    let dp = new Array(n + 1).fill(-1);\\n    function dfs(num) {\\n        if (num === 1) return 1;\\n\\n        if (dp[num] !== -1) return dp[num];\\n        let res = num;\\n        for (let i = 1; i <= num; i++) {\\n            const tmpRes = i * dfs(num - i);\\n            res = Math.max(tmpRes, res);\\n        }\\n\\n        return dp[num] = res;\\n    }\\n    for (let i = 1; i < n; i++) {\\n        const tmpRes = i * dfs(n - i);\\n        res = Math.max(tmpRes, res);\\n    }\\n    return res;\\n};\\n\\nconsole.log(integerBreak(10));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1894515,
                "title": "c-dp-memoisation-easy-understanding",
                "content": "May be base cases are blocker for solution so check them first \\n```\\n```\\n```\\nclass Solution {\\nprivate:\\n\\tint solve(int n, vector<int>&dp)\\n\\t{\\tif (n == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tif (n == 2)\\n\\t\\t\\treturn 1;\\n\\t\\tif (n == 3)\\n\\t\\t\\treturn 2;\\n\\t\\tif (n == 4)\\n\\t\\t\\treturn 4;\\n\\t\\tif (n == 5)\\n\\t\\t\\treturn 6;\\n\\t\\tif (n == 6)\\n\\t\\t\\treturn 9;\\n\\t\\tif (n == 7)\\n\\t\\t\\treturn 12;\\n\\t\\tif (n == 8)\\n\\t\\t\\treturn 18;\\n\\t\\tif (n == 9)\\n\\t\\t\\treturn 27;\\n\\t\\tif (dp[n] != -1)\\n\\t\\t\\treturn dp[n];\\n\\t\\tint maxAns = 1;\\n\\n\\t\\tfor (int i = 1; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tmaxAns = max(maxAns, (i) * solve(n - i, dp));\\n\\t\\t}\\n\\t\\treturn dp[n] = maxAns;\\n\\t}\\npublic:\\n\\tint integerBreak(int n) {\\n\\t\\tvector<int>dp(n + 1, -1);\\n\\t\\tint ans = solve(n, dp);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\n```\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Math",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n```\n```\\nclass Solution {\\nprivate:\\n\\tint solve(int n, vector<int>&dp)\\n\\t{\\tif (n == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tif (n == 2)\\n\\t\\t\\treturn 1;\\n\\t\\tif (n == 3)\\n\\t\\t\\treturn 2;\\n\\t\\tif (n == 4)\\n\\t\\t\\treturn 4;\\n\\t\\tif (n == 5)\\n\\t\\t\\treturn 6;\\n\\t\\tif (n == 6)\\n\\t\\t\\treturn 9;\\n\\t\\tif (n == 7)\\n\\t\\t\\treturn 12;\\n\\t\\tif (n == 8)\\n\\t\\t\\treturn 18;\\n\\t\\tif (n == 9)\\n\\t\\t\\treturn 27;\\n\\t\\tif (dp[n] != -1)\\n\\t\\t\\treturn dp[n];\\n\\t\\tint maxAns = 1;\\n\\n\\t\\tfor (int i = 1; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tmaxAns = max(maxAns, (i) * solve(n - i, dp));\\n\\t\\t}\\n\\t\\treturn dp[n] = maxAns;\\n\\t}\\npublic:\\n\\tint integerBreak(int n) {\\n\\t\\tvector<int>dp(n + 1, -1);\\n\\t\\tint ans = solve(n, dp);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1815024,
                "title": "simple-approach-easy-to-understand-tc-o-n-space-o-1-0-ms-100-faster",
                "content": "Given question is based on a pattern after certain input:\\n2 - 1,1\\n3 - 2,1\\n4 - 2,2\\n5 - 3,2\\n6 - 3,3\\n7 - 3,4\\n8 - 3,3,2\\n9 - 3,3,3\\n10 - 3,3,4\\nand so on......\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        if(n==2)return 1;\\n        else if(n==3)return 2;\\n        else if(n==4)return 4;\\n        else{\\n            int prod=1;\\n            int p = (n-2)/3;\\n            prod = pow(3,p)*(n-(3*p));\\n            return prod;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int integerBreak(int n) {\\n        if(n==2)return 1;\\n        else if(n==3)return 2;\\n        else if(n==4)return 4;\\n        else{\\n            int prod=1;\\n            int p = (n-2)/3;\\n            prod = pow(3,p)*(n-(3*p));\\n            return prod;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1806255,
                "title": "c-mathematical-solution-with-explanation-100-fast",
                "content": "Consider for Example 2 : (n = 10)\\n\\nIt is said that k>=2\\n\\nk is the number of integers involve, and it is said that minimum no. of intergers involved must be 2, it can also be proved by taking the least value of n which is 2, no the integers involve will be 2, 1+1 = 2, so this proves that the minimum integers involve will be 2.  \\n\\nNow what about the maximum integers that can be involved ?\\nIt would be n, if n is 10, then the minium value that you can involve is 1, if we sum 1 ten times, it will give the value 10.\\n\\nNow, we can deduce that  2<=k<=n\\n\\nLet me show all the pairs of values for n=10 : \\n\\nIf k=2,  5+5 = 10,  ans = 5*5 = 25\\nIf k=3,  4+3+3 = 10,  ans = 4*3*3 = 36\\nIf k=4,  3+3+2+2 = 10,  ans = 3*3*2*2 = 36\\nIf k=5,  2+2+2+2+2 = 10,  ans = 2*2*2*2*2 = 32\\nIf k=6,  2+2+2+2+1+1 = 10,  ans = 2*2*2*2*1*1 = 16\\nIf k=7,  2+2+2+1+1+1+1 = 10,  ans = 2*2*2*1*1*1*1 = 8\\nIf k=8,  2(2 times) + 1(6 times) = 10,  ans = 4\\nIf k=9, 2(1 time) + 1(8 times) = 10, ans = 2\\nIf k=10, 1(10 times) = 10, ans = 1\\n\\nThe final result will be the maximum of all the answers found for different values of k.\\n\\nWe see the maximum difference between any values for a given k does not exceed 1.\\n\\nIf we have to find the maximum product then we always keep the difference in the values to be minimum, that\\'s a unsaid rule in maths, so that\\'s what we do, we try to evenly divide the values(like for k=2, 5), and if the value cannnot be evenly spreaded then we increase every value by 1 until we get the sufficient sum.\\n\\nNow let\\'s make a simple mathematical equation\\nn = (x+1)*y  +  x*(k-y)  \\nwhere,\\nk = no. values invloved\\nx = n/k\\ny = n-(x*k)\\n\\nIt you still have confusion of how did I get to this equation then I would suggest you dry run some more sample test cases and try yourself.\\n```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        int ans = INT_MIN;\\n        \\n        for(int k=2 ; k<=n ; k++){\\n            int x = n/k;\\n            int y = n - (x * k);\\n            \\n            int val = 1;\\n            \\n            for(int i=1 ; i<=y ; i++)\\n                val = val*(x+1);\\n            \\n            for(int i=1 ; i<=(k-y) ; i++)\\n                val = val*x;\\n            \\n            ans = max(ans, val);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        int ans = INT_MIN;\\n        \\n        for(int k=2 ; k<=n ; k++){\\n            int x = n/k;\\n            int y = n - (x * k);\\n            \\n            int val = 1;\\n            \\n            for(int i=1 ; i<=y ; i++)\\n                val = val*(x+1);\\n            \\n            for(int i=1 ; i<=(k-y) ; i++)\\n                val = val*x;\\n            \\n            ans = max(ans, val);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745330,
                "title": "java-easy-and-clean-code-with-comments",
                "content": "Runtime: 1 ms, faster than 61.13% of Java online submissions for Integer Break.\\n\\n```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        //dp[i] will store the maximum product we can get for i.\\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        \\n        //Outer loop will run from 2 till our n.\\n        for (int i = 2; i <= n; i++) {\\n            //Inner loop will break i and give the max product. We are using (j <= i / 2) instead of (j < i) as it \\n\\t\\t\\t//removes duplicate checks and increases efficiency.\\n            //Example : For i = 4, 1)If we use (j < i), then the checks will be (1,3), (2,2) and (3,1). If we have \\n\\t\\t\\t//calculated for (1,3), we don\\'t need (3,1) check. 2)If we use (j <= i / 2), then checks will be \\n\\t\\t\\t//(1,3) and (2,2).\\n            for (int j = 1; j <= i / 2; j++) {\\n                dp[i] = Math.max(dp[i], (Math.max(j, dp[j]) * Math.max(i - j, dp[i - j])));\\n            }\\n        }\\n        \\n        //dp[n] stores the maximum product we can get for n.\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        //dp[i] will store the maximum product we can get for i.\\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        \\n        //Outer loop will run from 2 till our n.\\n        for (int i = 2; i <= n; i++) {\\n            //Inner loop will break i and give the max product. We are using (j <= i / 2) instead of (j < i) as it \\n\\t\\t\\t//removes duplicate checks and increases efficiency.\\n            //Example : For i = 4, 1)If we use (j < i), then the checks will be (1,3), (2,2) and (3,1). If we have \\n\\t\\t\\t//calculated for (1,3), we don\\'t need (3,1) check. 2)If we use (j <= i / 2), then checks will be \\n\\t\\t\\t//(1,3) and (2,2).\\n            for (int j = 1; j <= i / 2; j++) {\\n                dp[i] = Math.max(dp[i], (Math.max(j, dp[j]) * Math.max(i - j, dp[i - j])));\\n            }\\n        }\\n        \\n        //dp[n] stores the maximum product we can get for n.\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1595182,
                "title": "simple-java-solution-using-dp",
                "content": "Basic idea: n must be breaked into 2 or more positive integers. No matter how many positve integers produce the max product, we can always group them into two groups `n = (a + b + c) + (d + e)`,  so let\\'s assume `n = i + j`. For `i`, it can be further breaked into 2, 3 or more positive integers **OR** just not be breaked at all, though we are not sure which combination has the maximum product. Same for `j`.\\n\\n```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        for (int i = 2; i < n + 1; i++) {\\n            for (int j = 1; j <= i / 2; j++) {\\n                int maxProduct = Math.max(j, dp[j]) * Math.max(i - j, dp[i - j]);\\n                dp[i] = Math.max(dp[i], maxProduct);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```\\n\\nIn the implementation above, dp array keeps records of max product of 2 or more positve integers whose sum equals to the index. We need to compare the j and dp[j] because the we are not sure which one is larger. For example, 3 = 1 + 2 and 3 > 1 * 2, whereas 5 = 2 + 3 and 5 < 2 * 3.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        for (int i = 2; i < n + 1; i++) {\\n            for (int j = 1; j <= i / 2; j++) {\\n                int maxProduct = Math.max(j, dp[j]) * Math.max(i - j, dp[i - j]);\\n                dp[i] = Math.max(dp[i], maxProduct);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1561942,
                "title": "simple-and-easy-solution-100-time-and-100-space-with-no-dp",
                "content": "We\\'ve discovered that the largest products will be of 3\\'s.\\nEg: 6 => 3 x 3 > 2 x 2 x 2\\n      7 => 3 x 4 > 2 x 5\\n\\t  8 => 3 x 3 x 2 > 3 x 5\\n```\\nint integerBreak(int n){\\n    if(n == 2) return 1;\\n    if(n == 3) return 2;\\n    int max = 1;\\n    while(n > 4)\\n    {\\n        max *= 3;\\n        n -= 3;\\n    }\\n    max *= n;\\n    return max;    \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint integerBreak(int n){\\n    if(n == 2) return 1;\\n    if(n == 3) return 2;\\n    int max = 1;\\n    while(n > 4)\\n    {\\n        max *= 3;\\n        n -= 3;\\n    }\\n    max *= n;\\n    return max;    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1557878,
                "title": "typescript-constant-time-o-1",
                "content": "Based on [observations by leetcode user kevin_gunner](https://leetcode.com/problems/integer-break/discuss/80923/O(n)-time-complexity-O(1)-space-Java-solution), the largest product will be obtained by dividing the number into as many threes as possible, combined with either a 4 or a 2.\\n\\ne.g. 10 = 3 * 3 * 4 = 36\\ne.g. 14 = 3 * 3 * 3 * 3 * 2 = 162\\ne.g. 15 = 3 * 3 * 3 * 3 * 3 = 243\\n\\nYou must take care to deal with the base cases of 2 and 3, which cannot follow this rule since they can\\'t be split into 3s with either a 2 or 4 remainder.\\n\\n```\\nfunction integerBreak(n: number): number {\\n    // 2 and 3 can\\'t be split into 3s, so handle them separately.\\n    if(n === 2) return 1;\\n    if(n === 3) return 2;\\n    switch(n % 3) {\\n        // Split this number into one less than as many 3s as possible and one 4.\\n        case 1: return 4 * Math.pow(3, Math.floor(n/3)-1);\\n        // Split this number into as many 3s as possible and one 2\\n        case 2: return 2 * Math.pow(3, Math.floor(n/3));\\n\\t\\t// Split this number into entirely threes.\\n        case 0: return Math.pow(3, n/3);\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction integerBreak(n: number): number {\\n    // 2 and 3 can\\'t be split into 3s, so handle them separately.\\n    if(n === 2) return 1;\\n    if(n === 3) return 2;\\n    switch(n % 3) {\\n        // Split this number into one less than as many 3s as possible and one 4.\\n        case 1: return 4 * Math.pow(3, Math.floor(n/3)-1);\\n        // Split this number into as many 3s as possible and one 2\\n        case 2: return 2 * Math.pow(3, Math.floor(n/3));\\n\\t\\t// Split this number into entirely threes.\\n        case 0: return Math.pow(3, n/3);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1550473,
                "title": "simple-c-solution-time-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        if (n <= 3) return n-1;\\n        int num_3 = n / 3, remainder = n % 3;\\n        if (remainder == 1) {\\n            remainder = 4;\\n            --num_3;\\n        } \\n        else if (remainder == 0) remainder = 1;\\n        \\n        return pow(3, num_3) * remainder;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        if (n <= 3) return n-1;\\n        int num_3 = n / 3, remainder = n % 3;\\n        if (remainder == 1) {\\n            remainder = 4;\\n            --num_3;\\n        } \\n        else if (remainder == 0) remainder = 1;\\n        \\n        return pow(3, num_3) * remainder;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507451,
                "title": "solution-for-general-problem-with-real-numbers",
                "content": "This post deals with solving the problem for getting the maximal product but with real numbers (includes non-integers). It falls outside of the question but is quite nice mathematically so I thought I\\'d share with all you guys. \\n\\nWe want to find maximal a(1) * a(2) * a(3) * ... * a(k) where a(1) + a(2) + ... + a(k) = n. We can use Arithmetic Mean - Geometric Mean (AM-GM) inequality to help us solve, which goes like this:\\n\\n(a(1) + a(2) + ... + a(k))/k >= a(1) * a(2) * a(3) * ... * a(k) to the kth root \\n(sorry don\\'t know how to write this up in this format)\\n\\nReducing to:\\n\\n(n/k)^k >= a(1) * a(2) * a(3) * ... * a(k)\\n\\nNow the right hand side is what we wish to maximise so we can find the maximum left-hand side(LHS) and then bound.\\n\\nd/dx ((n/k)^k) turns out to be very nice:\\n= (n/k)^k * (ln(n/k) - 1)\\n\\nLHS is maximal when derivative = 0. \\n0 = ln(n/k) - 1\\n1 = ln(n/k)\\nn/k = e\\nk = n/e\\n\\nAM-GM also also has a very nice property that sides are equal(and product is maximised) when a(1) = a(2) = ... = a(k) = n/k. So this tells us that our product is upper-bounded when either k = ceiling(n/e) or k = floor(n/e), since k is an integer. So we can write up our solution like this:\\n\\n```\\ndef integerBreak(self, n: int) -> int:\\n        x = n//math.e\\n        y = n//math.e + 1\\n        ans1 = (n/x)**x\\n        ans2 = (n/y)**y\\n        return max(ans1,ans2)\\n\\n```\\n\\nP.S. This also gives us another reason why there are so many 2\\'s and 3\\'s in the solutions to the original. Since product is maximised when k = n/e and all terms are equal --> a(i) = n/k = e ~ 2.718, product is maximised when all the terms are around e.\\n\\nP.P.S. I haven\\'t included some fairly important math steps, like proving that the turning point was a maximum, or that it only had one t.p. So any posts on that I think would help and be very much appreciated!\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\ndef integerBreak(self, n: int) -> int:\\n        x = n//math.e\\n        y = n//math.e + 1\\n        ans1 = (n/x)**x\\n        ans2 = (n/y)**y\\n        return max(ans1,ans2)\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1435306,
                "title": "c-dp-math-runtime-0-ms-faster-than-100-00-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n//     //dp\\n//     //the STE:\\n//     //dp[i] = max(dp[i], max(j*(i-j), dp[j] * (i-j)));\\n//     int integerBreak(int n) {\\n//         vector<int> dp (n+1, 1);\\n        \\n//         for(int i = 1; i <= n; ++i){\\n//             for(int j = 1; j < i; ++j){\\n//                 dp[i] = max(dp[i], max(j*(i-j), dp[j] * (i-j)));\\n//             }            \\n//         }\\n        \\n//         return dp[n];\\n//     }\\n    \\n    //math\\n    int integerBreak(int n){\\n        int result = 1;\\n        if( n <= 3) return n-1;\\n        \\n        while(n > 4){\\n            result *= 3;\\n            n -= 3;\\n        }\\n        \\n        return result*n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//     //dp\\n//     //the STE:\\n//     //dp[i] = max(dp[i], max(j*(i-j), dp[j] * (i-j)));\\n//     int integerBreak(int n) {\\n//         vector<int> dp (n+1, 1);\\n        \\n//         for(int i = 1; i <= n; ++i){\\n//             for(int j = 1; j < i; ++j){\\n//                 dp[i] = max(dp[i], max(j*(i-j), dp[j] * (i-j)));\\n//             }            \\n//         }\\n        \\n//         return dp[n];\\n//     }\\n    \\n    //math\\n    int integerBreak(int n){\\n        int result = 1;\\n        if( n <= 3) return n-1;\\n        \\n        while(n > 4){\\n            result *= 3;\\n            n -= 3;\\n        }\\n        \\n        return result*n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1415808,
                "title": "c-o-log-n-solution",
                "content": "```class Solution {\\npublic:\\n    int integerBreak(int n) {\\n        if(n <= 3)return n-1;\\n        \\n        int x = n % 3;\\n        if(x == 0)\\n            return pow(3,n/3);\\n        if(x == 1)\\n            return pow(3,n/3-1)*4;\\n        else\\n            return pow(3,n/3-1)*6;\\n    \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int integerBreak(int n) {\\n        if(n <= 3)return n-1;\\n        \\n        int x = n % 3;\\n        if(x == 0)\\n            return pow(3,n/3);\\n        if(x == 1)\\n            return pow(3,n/3-1)*4;\\n        else\\n            return pow(3,n/3-1)*6;\\n    \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1289552,
                "title": "dp-0-ms-beats-100-c",
                "content": "```\\nclass Solution {\\npublic:\\n    #define lli long long int\\n    lli dp[60];\\n    lli solve(lli n){\\n        if(n<0) return 0;\\n        if(n==0) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        lli ans=INT_MIN;\\n        for(lli i=1;i<=n;i++){\\n            ans=max(ans,i*solve(n-i));\\n        }\\n        return dp[n]=ans;\\n        \\n    }\\n    int integerBreak(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        if(n==2) return 1;\\n        if(n==3) return 2;\\n        return solve(n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define lli long long int\\n    lli dp[60];\\n    lli solve(lli n){\\n        if(n<0) return 0;\\n        if(n==0) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        lli ans=INT_MIN;\\n        for(lli i=1;i<=n;i++){\\n            ans=max(ans,i*solve(n-i));\\n        }\\n        return dp[n]=ans;\\n        \\n    }\\n    int integerBreak(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        if(n==2) return 1;\\n        if(n==3) return 2;\\n        return solve(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1265117,
                "title": "time-complexity-o-1-easy-with-comments",
                "content": "For those who are unable to understand the idea behind this i am pasting the explanation written by @StefanPochmann in a comment  on [this](https://leetcode.com/problems/integer-break/discuss/80721/Why-factor-2-or-3-The-math-behind-this-problem.) post.\\n```\\nIf an optimal product contains a factor f >= 4,\\nthen you can replace it with factors 2 and f-2 without \\nlosing optimality, as 2*(f-2) = 2f-4 >= f.\\nSo you never need a factor greater than or equal to 4,\\nmeaning you only need factors 1, 2 and 3\\n(and 1 is of course wasteful and you\\'d only use it for n=2 and n=3, where it\\'s needed).\\n\\nFor the rest I agree, 3*3 is simply better than 2*2*2, so you\\'d never use 2 more than twice.\\n```\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        if(n==2)\\n            return 1;\\n        else if(n==3)\\n            return 2;\\n       else if(n%3==0)\\n            return (pow(3,n/3));\\n        else if(n%3==1)\\n            return (pow(3,n/3 -1)*4); /* if 1 is remainder then the situation is like this\\n           :- 3+3+3...+(3+1) so for getting more product value we can write (3+1) to(2+2)  */\\n        else \\n          return (pow(3,n/3 )*2);   \\n    }\\n};\\n```\\nDo UPVOTE if it helps :)\\nIf you have any doubt then ask in comment section :)",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nIf an optimal product contains a factor f >= 4,\\nthen you can replace it with factors 2 and f-2 without \\nlosing optimality, as 2*(f-2) = 2f-4 >= f.\\nSo you never need a factor greater than or equal to 4,\\nmeaning you only need factors 1, 2 and 3\\n(and 1 is of course wasteful and you\\'d only use it for n=2 and n=3, where it\\'s needed).\\n\\nFor the rest I agree, 3*3 is simply better than 2*2*2, so you\\'d never use 2 more than twice.\\n```\n```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        if(n==2)\\n            return 1;\\n        else if(n==3)\\n            return 2;\\n       else if(n%3==0)\\n            return (pow(3,n/3));\\n        else if(n%3==1)\\n            return (pow(3,n/3 -1)*4); /* if 1 is remainder then the situation is like this\\n           :- 3+3+3...+(3+1) so for getting more product value we can write (3+1) to(2+2)  */\\n        else \\n          return (pow(3,n/3 )*2);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156340,
                "title": "python-detailed-explanation-with-o-log-n-time",
                "content": "The main intuition to this solution is understanding that any positive integer greater than 3 can be divided into sums of 3 and 2.\\n\\nwe can use this idea to solve this problem very elegantly.\\n\\nFirstly we should try to maximize the number of threes as that would push our product bigger.\\n\\nWe can use two variables, \\n \\ncount_three = number of 3s the number can comprise of\\ncount_two = number of 2s the number can comprise of\\n\\nNOTE : 2 * count_two + 3 * count_three = number\\n\\nSo we get the maximum numbers of threes that the number can hold, and we will have three cases \\n\\n\\ncase 1: If the number is completely divisible by 3 \\n\\t\\tthen just return 3 to the power of (n // 3)\\n\\n\\t\\teg: 15 => 3 ** (15//3) => 3 * 3 * 3 * 3 * 3\\n\\ncase 2: If dividing the number with three has a remainder of 2\\n\\t\\tthen multiply a 2 to (n//3), that would make the result.\\n\\n\\t\\teg:  17 => 17 % 3 == 2\\n\\n\\t\\t\\t    => ( 3 ** (17//3))  * 2\\n\\n\\t\\t\\t    => 3 * 3 * 3 * 3 * 3 * 2\\n\\nTricky case\\n\\ncase 3: If dividing the number with three has a remainder of 1,\\n\\t\\tThat means adding a single 2 cannot make up the result as there will be an extra 1, so we remove a three and then add two 2s. And we take the product of those.\\n\\n\\t  eg:    n = 10 \\n\\t\\t\\t  => 10 % 3 == 1\\n\\t\\t\\t  => count_three = (n//3) = 3\\n\\t\\t  \\t     count_two = 0\\n\\t\\t  \\t     product = 3 * 3 * 3\\n\\t\\t  \\t     sum = 3 + 3 + 3 != 10\\n\\n\\t\\t       => subtract 1 from count_three and add 2 to count_two \\n\\t\\t     \\n\\t\\t         count_three = 2\\n\\t\\t         count_two = 2\\n\\t\\t         product = 3 * 3 * 2 * 2 => 36\\n\\t\\t         sum = 3 + 3 + 2 + 2 == 10\\t\\n\\nPython 3 Code\\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        # base Checks\\n        if n == 2:\\n            return 1\\n        if n == 3:\\n            return 2\\n            \\n        count_two = 0\\n        count_three = n // 3\\n        \\n        if n % 3 == 1:\\n            count_three -= 1\\n            count_two += 2\\n        elif n % 3 == 2:\\n            count_two += 1\\n            \\n        product = 3 ** count_three \\n        \\n        if count_two:\\n            product *= 2 ** count_two\\n        return product\\n```\\n\\nTime Complexity: O(log n) [for calculating exponents]\\nSpace Complexity: O(1)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        # base Checks\\n        if n == 2:\\n            return 1\\n        if n == 3:\\n            return 2\\n            \\n        count_two = 0\\n        count_three = n // 3\\n        \\n        if n % 3 == 1:\\n            count_three -= 1\\n            count_two += 2\\n        elif n % 3 == 2:\\n            count_two += 1\\n            \\n        product = 3 ** count_three \\n        \\n        if count_two:\\n            product *= 2 ** count_two\\n        return product\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1086176,
                "title": "java-0ms-easy-to-understand-pattern-study",
                "content": "for every number greater than 3 ,the maximum product is combination is 2 and 3 \\nso to reduce TC we will check only for combinatons of 2 and 3 and it will give our result\\n```\\nclass Solution {\\n    \\n    public int integerBreak(int n) {\\n        if(n<=3)\\n            return n-1;\\n        int [] arr=new int[n+1];\\n        return solve(n,arr);\\n    }\\n    public int solve(int tv,int [] arr){\\n        if(tv<=3){\\n            return tv;\\n        }\\n        if(arr[tv]!=0)\\n            return arr[tv];\\n        int a=2*solve(tv-2,arr);\\n        int b=3*solve(tv-3,arr);\\n        arr[tv]=Math.max(a,b);\\n        return Math.max(a,b);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int integerBreak(int n) {\\n        if(n<=3)\\n            return n-1;\\n        int [] arr=new int[n+1];\\n        return solve(n,arr);\\n    }\\n    public int solve(int tv,int [] arr){\\n        if(tv<=3){\\n            return tv;\\n        }\\n        if(arr[tv]!=0)\\n            return arr[tv];\\n        int a=2*solve(tv-2,arr);\\n        int b=3*solve(tv-3,arr);\\n        arr[tv]=Math.max(a,b);\\n        return Math.max(a,b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1066997,
                "title": "c-0ms-solution-o-n-repeating-pattern-with-explanation",
                "content": "In this problem, let consider some test case\\n\\t**Input->Output\\n\\t\\t\\t2->1\\n\\t\\t\\t3->2\\n\\t\\t\\t4->4\\n\\t\\t\\t5->6\\n\\t\\t\\t6->9\\n\\t\\t\\t7->12\\n\\t\\t\\t8->18\\n\\t\\t\\t9->27\\n\\t\\t\\t10->36\\n\\t\\t\\t11->54\\n\\t\\t\\t12->81**\\nand so on.....but if you see the output carefully after input **4**, we can see there is a hidden of multiples of 3 on every **i+3** input like.....\\n\\te.g    input 4 = 4 \\n\\t\\t\\tinput 7 = (input 4)*3 = 12\\n\\te.g    input 6 = 9 \\n\\t\\t\\tinput 9 = (input 6)*3 = 27\\nHere we got the hidden pattern now next part is to implent in code :\\n\\n```\\nint integerBreak(int n) {\\n        vector<int>a(58);\\n        a[0]=1;\\n        a[1]=1;\\n        a[2]=1;\\n        a[3]=2;\\n        a[4]=4;\\n        a[5]=6;\\n        a[6]=9;        \\n        for(int i=7;i<=n;++i)\\n            a[i]=a[i-3]*3;       \\n        \\n        return a[n];\\n    }\\n```\\nHappy Coding\\n\\t\\t\\t\\n\\n",
                "solutionTags": [],
                "code": "```\\nint integerBreak(int n) {\\n        vector<int>a(58);\\n        a[0]=1;\\n        a[1]=1;\\n        a[2]=1;\\n        a[3]=2;\\n        a[4]=4;\\n        a[5]=6;\\n        a[6]=9;        \\n        for(int i=7;i<=n;++i)\\n            a[i]=a[i-3]*3;       \\n        \\n        return a[n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 941785,
                "title": "recursion-memoization-c-100-faster-than-other-c-submissions",
                "content": "first let us think of Hypothesis.\\ntake 10 as n;\\nwe need to break 10 from 1 to 9 and find out max product.\\nso for  k=1 to k=9\\ntemp=k*Solve(n-k)\\nans=max(temp,ans)\\n......\\nThink a bit hard.\\nU will find that we need to check for temp1=k*(n-k) case too....\\n.........\\nans=max(temp,temp1)\\n........\\nNow, Base Case : Think of smallest Valid input :)\\nif(n==1 || n==2)\\n{\\nreturn 1;\\n}\\nRest u can easily understand from code below\\n\\nOne thing.. think why we need Memoization....\\nonly n is changing , so 1-D array dp would be sufficent.....\\n\\n```\\nclass Solution {\\npublic:\\n    int t[60];\\n    int Solve(int n)\\n    {\\n        if(n==1 || n==2)\\n        {\\n            return 1;\\n        }\\n        if(n<1)\\n        {\\n            return 0;\\n        }\\n        if(t[n]!=-1)\\n        {\\n            return t[n];\\n        }\\n        int temp,ans=INT_MIN;\\n        int temp2;\\n        for(int k=1;k<n;k++)\\n        {\\n            temp=k*Solve(n-k);\\n            temp2=k*(n-k);\\n            temp=max(temp,temp2);\\n            \\n            ans=max(temp,ans);\\n        }\\n        t[n]=ans;\\n       // cout<<\"n =\"<<n<<\" \"<<ans<<endl;\\n        return ans;\\n    }\\n    int integerBreak(int n) {\\n        memset(t,-1,sizeof(t));\\n        return Solve(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int t[60];\\n    int Solve(int n)\\n    {\\n        if(n==1 || n==2)\\n        {\\n            return 1;\\n        }\\n        if(n<1)\\n        {\\n            return 0;\\n        }\\n        if(t[n]!=-1)\\n        {\\n            return t[n];\\n        }\\n        int temp,ans=INT_MIN;\\n        int temp2;\\n        for(int k=1;k<n;k++)\\n        {\\n            temp=k*Solve(n-k);\\n            temp2=k*(n-k);\\n            temp=max(temp,temp2);\\n            \\n            ans=max(temp,ans);\\n        }\\n        t[n]=ans;\\n       // cout<<\"n =\"<<n<<\" \"<<ans<<endl;\\n        return ans;\\n    }\\n    int integerBreak(int n) {\\n        memset(t,-1,sizeof(t));\\n        return Solve(n);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 916205,
                "title": "simple-java-solution-without-dp-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        if (n <= 2) return 1;\\n        if (n == 3) return 2;\\n        int product = 1;\\n        while (n > 1) {\\n            if (n % 3 == 0) {\\n                product *= 3;\\n                n -= 3;\\n            } else {\\n                product *= 2;\\n                n -= 2;\\n            }\\n        }\\n        return product;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        if (n <= 2) return 1;\\n        if (n == 3) return 2;\\n        int product = 1;\\n        while (n > 1) {\\n            if (n % 3 == 0) {\\n                product *= 3;\\n                n -= 3;\\n            } else {\\n                product *= 2;\\n                n -= 2;\\n            }\\n        }\\n        return product;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 898637,
                "title": "python-o-logn-faster-than-99-9-less-memory-than-100",
                "content": "```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        if n<3: return 1\\n        if n==3: return 2\\n        if n%3==0: return pow(3, (n//3))\\n        if n%3==1: return pow(3, ((n//3)-1))*4\\n        if n%3==2: return pow(3,(n//3))*2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        if n<3: return 1\\n        if n==3: return 2\\n        if n%3==0: return pow(3, (n//3))\\n        if n%3==1: return pow(3, ((n//3)-1))*4\\n        if n%3==2: return pow(3,(n//3))*2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794482,
                "title": "unbounded-knapsack-variation-java-dp",
                "content": "```\\n public int integerBreak(int n) {\\n        \\n        if(n <= 2) return 1;\\n        if(n == 3) return 2;\\n        \\n        int[] dp = new int[n+1];\\n        dp[0] = 1;\\n        \\n        for(int i = 1; i <= n; i++){            // Cost of breaking integer into parts\\n            for(int j = i; j <= n; j++){        // breaking integer, starts from 1 to n\\n                dp[j] = Math.max(dp[j], i * dp[j-i]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n public int integerBreak(int n) {\\n        \\n        if(n <= 2) return 1;\\n        if(n == 3) return 2;\\n        \\n        int[] dp = new int[n+1];\\n        dp[0] = 1;\\n        \\n        for(int i = 1; i <= n; i++){            // Cost of breaking integer into parts\\n            for(int j = i; j <= n; j++){        // breaking integer, starts from 1 to n\\n                dp[j] = Math.max(dp[j], i * dp[j-i]);\\n            }\\n        }\\n        return dp[n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 776044,
                "title": "o-1-time-and-space-c-with-explanation",
                "content": "Product is maximized when the number is broken into products of 3. The idea is to split the number in such a way that all the splitted numbers are as much close to each other as possible and also, the product should be maximized. Refer to : https://leetcode.com/problems/integer-break/discuss/80721/Why-factor-2-or-3-The-math-behind-this-problem. for the explanation of why we break it into product of 3 only.\\n```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        if(n==2) return 1;\\n        if(n==3) return 2;\\n        if(n%3==0) return pow(3,n/3);\\n        if(n%3==1) return pow(3,(n/3-1))*4;\\n        else return pow(3,(n/3))*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        if(n==2) return 1;\\n        if(n==3) return 2;\\n        if(n%3==0) return pow(3,n/3);\\n        if(n%3==1) return pow(3,(n/3-1))*4;\\n        else return pow(3,(n/3))*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772191,
                "title": "top-down-java",
                "content": "Try every possible way to divide. Make sure maintainsing the max and dp entry to not recompute. \\n```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        if(n<2) {\\n            return 1;\\n        }\\n        int[] dp = new int[n+1];\\n        Arrays.fill(dp,-1);\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        return helper(n, dp);\\n    }\\n    \\n    //TOP DOWN HELPER\\n    public int helper(int n, int[] dp) {\\n        \\n        if (dp[n] != -1) {\\n            return dp[n];\\n        }\\n        \\n        \\n        int max = 0;\\n        //TRY EVERY POSSIBLE WAY TO DEVIDE THE NUMBERS \\n        for (int i=1;i<=n/2;i++) {\\n            max = Math.max((n-i)*i,max);\\n            max = Math.max((helper(n-i,dp) * i),max);\\n        }\\n       \\n        dp[n] = max;\\n        return max;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int integerBreak(int n) {\\n        if(n<2) {\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 760794,
                "title": "c-without-dp-100-runtime-75-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n    if(n==2 || n==3){\\n        return n-1;\\n    }    \\n    if(n%3==0){\\n        return pow(3,n/3);\\n    }\\n    if(n%3==1){\\n        return 4*pow(3,(n/3)-1);\\n    }\\n        return 2* pow(3,n/3);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n    if(n==2 || n==3){\\n        return n-1;\\n    }    \\n    if(n%3==0){\\n        return pow(3,n/3);\\n    }\\n    if(n%3==1){\\n        return 4*pow(3,(n/3)-1);\\n    }\\n        return 2* pow(3,n/3);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722488,
                "title": "python-3-simple-dp-solution-with-explanation",
                "content": "Initialize dp array with n - 1 ( n-1  * 1 as base answer)\\nFor each i <= n, do\\n\\t1. \\t Divide i into sum of two numbers, j and i - j, i.e., (1, i-1) (2, i-2), ... (i/2, i-i/2)\\n\\t2. \\t Use dp array to find optimal division of j and n-j\\n\\t3. \\t Update dp[i] to max of dp[i] and max(j,dp[j])*max((i - j),dp[i-j])\\n\\t4. \\t Return dp[n]\\n\\nExplanation of max(j,dp[j])*max((i - j),dp[i-j]):\\n* \\t*Ex.* i(=n) = 10, j = 3, i.e., 10 = 3 + 7\\n* You could directly either multiply j and n-j or further divide j and n-j into sum of integers and use whichever is larger.\\n*  Here dp is used to store result of smaller numbers: (3 or dp[3]( = 2) ) *  (7 or dp[7]=12)\\nComplexity:\\n* O(n^2) Time \\n* O(n) space\\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        dp = [i-1 for i in range(n+1)]\\n        for i in range(3, n + 1):\\n            for j in range(2, i//2 + 1):\\n                dp[i] = max(dp[i], max(j,dp[j])*max((i - j),dp[i-j]))\\n        return dp[n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        dp = [i-1 for i in range(n+1)]\\n        for i in range(3, n + 1):\\n            for j in range(2, i//2 + 1):\\n                dp[i] = max(dp[i], max(j,dp[j])*max((i - j),dp[i-j]))\\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691317,
                "title": "python-dp-with-explanation-and-some-thought-process-for-beginners",
                "content": "##### Thought process for beginners: first write some 10 examples in a rough book or white board and see the pattern it follows,we can easily find the pattern between them.\\nLets do a example for 6:\\n6=1 + 5 [1xdp[5] or 1x5] will find the max between them so it is 1xdp[5] =6\\n6=2+4[2xdp[4] or 2x4] max is 8\\n6=3+3[3xdp[3] or 3x3] max(6,9) it is 9\\n6=4+2.........\\nNow max of all the above numbers so it is 9\\nso,\\ndp[i]=max(dp[i], j x (i-j), j x dp[i-j])\\n               j runs from 1,i/2\\nafter the half of the number it will be less because dp of the number will be low so lets take only half of the numbers\\n\\n```\\nclass Solution(object):\\n    def integerBreak(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        dp=[0]*(n+1)\\n        dp[2]=1\\n        for i in range(3,n+1):\\n            for j in range(1,(i+1)/2+1):\\n                dp[i]=max(dp[i],j*(i-j),j*dp[i-j])\\n        return dp[-1]\\n                \\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def integerBreak(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        dp=[0]*(n+1)\\n        dp[2]=1\\n        for i in range(3,n+1):\\n            for j in range(1,(i+1)/2+1):\\n                dp[i]=max(dp[i],j*(i-j),j*dp[i-j])\\n        return dp[-1]\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 522060,
                "title": "use-3-to-maximize",
                "content": "```\\npublic int integerBreak(int n) {\\n        int res = 1;\\n        if (n == 2) return 1;\\n        if (n == 3) return 2;\\n        while(n > 4) {\\n            res *= 3;\\n            n -= 3;\\n        }\\n        res *= n;\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int integerBreak(int n) {\\n        int res = 1;\\n        if (n == 2) return 1;\\n        if (n == 3) return 2;\\n        while(n > 4) {\\n            res *= 3;\\n            n -= 3;\\n        }\\n        res *= n;\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 520042,
                "title": "python-o-n-greedy-dp-with-hint-75",
                "content": "Python O(n) sol by greedy of picking threes.\\n\\n---\\n\\n**Hint** & **Observation**:\\n\\n#1. Base case:\\n2 = 1 + 1, product = 1 * 1 = 1\\n3 = 2 + 1, product = 2 * 1 = 2\\n\\n4 = 2 + 2, product = 2 * 2 = 4\\n\\n#2. General case:\\nKeep decompose by **3** if *remain* > 4\\n\\nFocus on the **pattern of optimal decomposition**\\n\\n5 = **3** + *2*, product = 3 x *2* = 6\\n6 = **3** + *3*, product = 3 x *3* = 9\\n7 = **3** + *4*, product = 3 x *4* = 12\\n8 = **3** + **3** + *2*, product = 3 x 3 x *2* = 18\\n9 = **3** + **3** + *3*, product = 3 x 3 x *3* = 27\\n10 = **3** + **3** + *4*, product = 3 x 3 x *4*= 36\\n11 = **3** + **3** + **3** + *2*, product = 3 x 3 x 3 x *2* = 54\\n\\n... and so on\\n\\n\\n\\n---\\n**Implementation** by greedy of picking threes:\\n\\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        \\n        if n <= 3:\\n            # n = 2 = 1 + 1, product = 1\\n            # n = 3 = 2 + 1, product = 2\\n            return n-1\\n        \\n        remain, product = n, 1\\n        \\n        while remain > 4:\\n            # Keep decompose with 3\\n            product *= 3\\n            remain -=3\\n            \\n        return product * remain\\n```\\n\\n---\\n\\nShare another implementaion by Top-down DP\\n\\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        \\n        ## Quick response on boundary cases\\n        if n == 2:\\n            # 2 = 1 + 1, product = 1\\n            return 1\\n\\n        elif n == 3:\\n            # 3 = 1 + 2, product = 2\\n            return 2\\n        \\n        \\n        # use python\\'s built-in cache as memoization\\n        @cache\\n        def dp(k):\\n            \\n            ## Base case: dont decompose if k <= 3\\n            if k <= 3:\\n                return k\\n            \\n            ## General case:\\n            \\n            # rewrite k = x + (k-x)\\n            # compute the max product by updating with dp(x) * dp( k-x )\\n            \\n            # due to symmetric, x + (k-x) is the same as (k-x) + x\\n            # so x is up to k // 2 + 1\\n            \\n            return max( [ dp(x) * dp(k-x) for x in range(2, k//2+1) ] )\\n                \\n        # -----------------------------------------------------\\n\\n        return dp(n)\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        \\n        if n <= 3:\\n            # n = 2 = 1 + 1, product = 1\\n            # n = 3 = 2 + 1, product = 2\\n            return n-1\\n        \\n        remain, product = n, 1\\n        \\n        while remain > 4:\\n            # Keep decompose with 3\\n            product *= 3\\n            remain -=3\\n            \\n        return product * remain\\n```\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        \\n        ## Quick response on boundary cases\\n        if n == 2:\\n            # 2 = 1 + 1, product = 1\\n            return 1\\n\\n        elif n == 3:\\n            # 3 = 1 + 2, product = 2\\n            return 2\\n        \\n        \\n        # use python\\'s built-in cache as memoization\\n        @cache\\n        def dp(k):\\n            \\n            ## Base case: dont decompose if k <= 3\\n            if k <= 3:\\n                return k\\n            \\n            ## General case:\\n            \\n            # rewrite k = x + (k-x)\\n            # compute the max product by updating with dp(x) * dp( k-x )\\n            \\n            # due to symmetric, x + (k-x) is the same as (k-x) + x\\n            # so x is up to k // 2 + 1\\n            \\n            return max( [ dp(x) * dp(k-x) for x in range(2, k//2+1) ] )\\n                \\n        # -----------------------------------------------------\\n\\n        return dp(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479923,
                "title": "python-o-n-dynamic-programming-with-memoization",
                "content": "```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        memo = {}\\n        def intBreak(n):\\n            if n in memo:\\n                return memo[n]\\n            if n<2:\\n                memo[n] = 0\\n                return 0\\n            if n==2:\\n                memo[2] = 2\\n                return 1\\n            maxval = 0\\n            for i in range(1,n//2+1):\\n                maxval = max(maxval,i*intBreak(n-i),i*(n-i))\\n            memo[n] = maxval\\n            return maxval\\n        ans = intBreak(n)\\n        return ans\\n        \\n```\\nTime: O(n)\\nspace: O(n)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        memo = {}\\n        def intBreak(n):\\n            if n in memo:\\n                return memo[n]\\n            if n<2:\\n                memo[n] = 0\\n                return 0\\n            if n==2:\\n                memo[2] = 2\\n                return 1\\n            maxval = 0\\n            for i in range(1,n//2+1):\\n                maxval = max(maxval,i*intBreak(n-i),i*(n-i))\\n            memo[n] = maxval\\n            return maxval\\n        ans = intBreak(n)\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 161563,
                "title": "tail-recurssion-python",
                "content": "maximum product partion of `n` has subproblme of maximum product partion of `n - i`.\\nif we cut the number starting from `i`:\\n```\\nMPP(n) = max(i * (n - i), i * MPP(n - i))\\n```\\nRepeat the process for `i` from `1` to `n - 1`.\\n\\n\\n```\\nclass Solution(object):\\n\\n    def integerBreak(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        memo = [-1] * (n + 1)\\n        return self.helper(n, memo)\\n\\n    def helper(self, n, memo):\\n        if n == 1 :\\n            return 1\\n        \\n        if memo[n] != -1:\\n            return memo[n]\\n        \\n        res = -1\\n        for i in range(1, n):\\n            res = max(res, i * (n - i), i * self.helper(n - i, memo))\\n        memo[n] = res\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nMPP(n) = max(i * (n - i), i * MPP(n - i))\\n```\n```\\nclass Solution(object):\\n\\n    def integerBreak(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        memo = [-1] * (n + 1)\\n        return self.helper(n, memo)\\n\\n    def helper(self, n, memo):\\n        if n == 1 :\\n            return 1\\n        \\n        if memo[n] != -1:\\n            return memo[n]\\n        \\n        res = -1\\n        for i in range(1, n):\\n            res = max(res, i * (n - i), i * self.helper(n - i, memo))\\n        memo[n] = res\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 140971,
                "title": "mathematical-solution-with-proof-of-correctness-o-log-n",
                "content": "    def integerBreakFast(self, n):\\n\\n        if n == 2: return 1\\n        if n == 3: return 2\\n\\n        # n >= 4\\n        # Consider n = a1 + a2 + ... + ak\\n        # product = a1 * a2 * ... * ak\\n        # The task at hand is to maximize product, notice that the there might\\n        # be multiple ways to break \\'n\\' to obtain this maximize product.\\n\\n        # We will show that:\\n        # 1. there must be an optimal solution of the form n = 3*a + 2*b, \\n        #   (that is, each ai \\'break\\' of n is either 2 or 3)\\n        # 2. given n = 3*a + 2*b, a, b > 0, product = 3^a * 2^b is maximized when b = 0, 1, or 2\\n        #   that is, given the form n = 3*a + 2*b, product is maximized when b = 0, 1, or 2\\n\\n        # A). Number 1 essentially proves that: there are many ways to write \\'n\\' as sum of \\n        # 2\\'s and 3\\'s (denote as S), but ONE OF THEM must have THE maximize product among all\\n        # combinations (ways to break n).\\n        # B). Number 2 proves that within S, the combination that yields the maximum product\\n        # WITHIN S, is when we break \\'n\\' into 3 as much as possible, then add some \\'2\\'s if necessary\\n\\n        # Apparently, the break that yields the global maximum product described in A) must be\\n        # the one decribed in B) as well, otherwise it\\'s a contracdiction, because a local maximum\\n        # within S will be greater than the global maximum of all possible ways to break \\'n\\'.\\n\\n\\n        # 1).\\n        # let P be AN optimal product and a1 .. ak be the \\'breaks\\'\\n        # apparently none of \\'a\\' can be 1, else\\n        # we can just merge it with another \\'a\\' and increase product\\n\\n        # Also notice every n >= 4 can be written as n = 3*a + 2*b\\n        # Just take modulo 5, and deal with each residue case. Easy proof.\\n\\n        # We will show that given any optimal break, we can keep converting any number \\n        # greater than 4 into sum of 2s and 3s, AND the product yielded will be NO WORSE than\\n        # what the optimal solution gave.\\n\\n        # Assume aj >= 4, for some j \\u2208 [1, k]\\n        # if we break a 2 from it, in product we get\\n        # K = 2 * (aj - 2)\\n        # By manipulating the inequality aj >= 4 we have:\\n        # aj >= 4 \\n        # - 2*aj >= aj + 4\\n        # - 2*(aj - 2) >= aj\\n        # - K >= aj.\\n        # This shows that it is safe to modify the optimal breaks by taking 2\\'s\\n        # from any number greater than 4. As the resulting product is NO WORSE\\n        # than the original product P.\\n\\n        # thus, for any aj >= 4, we convert it\\n        # into aj\\' + 2, where aj\\' is either 2, 3, or else we keep converting it\\n        # in the end we get, n = 3 + 3 + ... + 3 + 2 + 2 + ... + 2 = 3*a + 2*b, \\n        # and the final product = 3^a + 2^b. By what we showed above, this product is no worse than the\\n        # original optimal product.\\n        # Thus, there must be an optimal solution of the form n = 3*a + 2*b\\n\\n        # 2).\\n        # The next task is to select (a, b) to find THE optimal solution of this form \\n        # We can convert every three 2s into two 3s, and the product goes from\\n        # 2 * 2 * 2 = 8 to 3 * 3 = 9. Which is better\\n                            \\n        # After recursively applying this conversion, we end up with\\n        # n = 3*a + 2*b, where b = 0, 1, or 2, and we can calculate the product accordingly \\n        # We showed that this pair (a, b) will be better than any other pair, since we can reduce other pairs\\n        # into this pair, and obtain higher product.\\n                            \\n\\n        residue = n % 3\\n\\n        if residue == 0:\\n            return 3 ** (n // 3)\\n        \\n        elif residue == 1:\\n            # n = 3*a + 2*2 = 3*a + 2 + 2\\n            a = (n - 4) // 3\\n            return 3 ** a * 4\\n\\n        else:\\n            # n = 3*a + 2\\n            a = (n - 2) // 3\\n            return 3 ** a * 2\\n\\n",
                "solutionTags": [],
                "code": "    def integerBreakFast(self, n):\\n\\n        if n == 2: return 1\\n        if n == 3: return 2\\n\\n        # n >= 4\\n        # Consider n = a1 + a2 + ... + ak\\n        # product = a1 * a2 * ... * ak\\n        # The task at hand is to maximize product, notice that the there might\\n        # be multiple ways to break \\'n\\' to obtain this maximize product.\\n\\n        # We will show that:\\n        # 1. there must be an optimal solution of the form n = 3*a + 2*b, \\n        #   (that is, each ai \\'break\\' of n is either 2 or 3)\\n        # 2. given n = 3*a + 2*b, a, b > 0, product = 3^a * 2^b is maximized when b = 0, 1, or 2\\n        #   that is, given the form n = 3*a + 2*b, product is maximized when b = 0, 1, or 2\\n\\n        # A). Number 1 essentially proves that: there are many ways to write \\'n\\' as sum of \\n        # 2\\'s and 3\\'s (denote as S), but ONE OF THEM must have THE maximize product among all\\n        # combinations (ways to break n).\\n        # B). Number 2 proves that within S, the combination that yields the maximum product\\n        # WITHIN S, is when we break \\'n\\' into 3 as much as possible, then add some \\'2\\'s if necessary\\n\\n        # Apparently, the break that yields the global maximum product described in A) must be\\n        # the one decribed in B) as well, otherwise it\\'s a contracdiction, because a local maximum\\n        # within S will be greater than the global maximum of all possible ways to break \\'n\\'.\\n\\n\\n        # 1).\\n        # let P be AN optimal product and a1 .. ak be the \\'breaks\\'\\n        # apparently none of \\'a\\' can be 1, else\\n        # we can just merge it with another \\'a\\' and increase product\\n\\n        # Also notice every n >= 4 can be written as n = 3*a + 2*b\\n        # Just take modulo 5, and deal with each residue case. Easy proof.\\n\\n        # We will show that given any optimal break, we can keep converting any number \\n        # greater than 4 into sum of 2s and 3s, AND the product yielded will be NO WORSE than\\n        # what the optimal solution gave.\\n\\n        # Assume aj >= 4, for some j \\u2208 [1, k]\\n        # if we break a 2 from it, in product we get\\n        # K = 2 * (aj - 2)\\n        # By manipulating the inequality aj >= 4 we have:\\n        # aj >= 4 \\n        # - 2*aj >= aj + 4\\n        # - 2*(aj - 2) >= aj\\n        # - K >= aj.\\n        # This shows that it is safe to modify the optimal breaks by taking 2\\'s\\n        # from any number greater than 4. As the resulting product is NO WORSE\\n        # than the original product P.\\n\\n        # thus, for any aj >= 4, we convert it\\n        # into aj\\' + 2, where aj\\' is either 2, 3, or else we keep converting it\\n        # in the end we get, n = 3 + 3 + ... + 3 + 2 + 2 + ... + 2 = 3*a + 2*b, \\n        # and the final product = 3^a + 2^b. By what we showed above, this product is no worse than the\\n        # original optimal product.\\n        # Thus, there must be an optimal solution of the form n = 3*a + 2*b\\n\\n        # 2).\\n        # The next task is to select (a, b) to find THE optimal solution of this form \\n        # We can convert every three 2s into two 3s, and the product goes from\\n        # 2 * 2 * 2 = 8 to 3 * 3 = 9. Which is better\\n                            \\n        # After recursively applying this conversion, we end up with\\n        # n = 3*a + 2*b, where b = 0, 1, or 2, and we can calculate the product accordingly \\n        # We showed that this pair (a, b) will be better than any other pair, since we can reduce other pairs\\n        # into this pair, and obtain higher product.\\n                            \\n\\n        residue = n % 3\\n\\n        if residue == 0:\\n            return 3 ** (n // 3)\\n        \\n        elif residue == 1:\\n            # n = 3*a + 2*2 = 3*a + 2 + 2\\n            a = (n - 4) // 3\\n            return 3 ** a * 4\\n\\n        else:\\n            # n = 3*a + 2\\n            a = (n - 2) // 3\\n            return 3 ** a * 2\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 80743,
                "title": "c-0ms-o-1-solution-with-explanation",
                "content": "Let me illustrate the regularity\\nn=1:  return 1\\nn=2:  return 1 (1+1)\\nn=3:  return 2 (1+2)\\nn=4:  return  4 (2+2)\\nn=5:  return 5 (2+3)\\n\\nActually when n is bigger than 5, there is a regularity\\n                                                    \\nn=6:  return 9 (3+3) \\nn=7:  return 12 (3+2+2)\\nn=8:  return  18  (3+3+2)\\nn=9:  return   27 (3+3+3)\\nn=10: return   36    (3+3+2+2) \\nn=11: return    54    (3+3+3+2)\\nn=12: return    81   (3+3+3+3)\\n\\nwe can see that if the remainder when n is divided by 3 is 0, the maximum product is consists of no two and all three; if the remainder is 1, the maximum product is consists of 2 two and the others are three; if the remainder  is 2, the maximum product is consists of 1 two and the others are three.\\n```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        if(n==1) return 1;\\n        if(n<=3) return n-1;\\n        if(n==4) return 4;\\n        if(n==5) return 6;\\n        int n_2 = n%3;\\n        if(n_2==0) return pow(3,n/3);\\n        if(n_2==1) return pow(3,(n-4)/3)*4;\\n        else return pow(3,(n-2)/3)*2;\\n    }\\n};\\n\\xb7\\xb7\\xb7",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int integerBreak(int n) {\\n        if(n==1) return 1;\\n        if(n<=3) return n-1;\\n        if(n==4) return 4;\\n        if(n==5) return 6;\\n        int n_2 = n%3;\\n        if(n_2==0) return pow(3,n/3);\\n        if(n_2==1) return pow(3,(n-4)/3)*4;\\n        else return pow(3,(n-2)/3)*2;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 80841,
                "title": "java-simple-0ms-solution",
                "content": "    public int integerBreak(int n) {\\n        if(n==2)return 1;\\n    \\tif(n==3)return 2;\\n    \\tint m = n/3;\\n    \\tint ret = (int)Math.pow(3, m-1);\\n    \\tswitch(n%3){\\n    \\t\\tcase 0: ret *= 3; break;\\n    \\t\\tcase 1: ret *= 4; break;\\n    \\t\\tcase 2: ret *= 6; break;\\n    \\t}\\n    \\treturn ret;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int integerBreak(int n) {\\n        if(n==2)return 1;\\n    \\tif(n==3)return 2;\\n    \\tint m = n/3;\\n    \\tint ret = (int)Math.pow(3, m-1);\\n    \\tswitch(n%3){\\n    \\t\\tcase 0: ret *= 3; break;\\n    \\t\\tcase 1: ret *= 4; break;\\n    \\t\\tcase 2: ret *= 6; break;\\n    \\t}\\n    \\treturn ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 80806,
                "title": "simple-java-dp-solution-with-comments",
                "content": "    public class Solution {\\n    public int integerBreak(int n) {\\n    \\t// dp[i] denotes the maximum product breaking i, then we have state equation:\\n    \\t// dp[i] = max (dp[i], max(i-j, dp[i-j]) * max(j, dp[j])) for 1 <= j < i,\\n        // that is, the max of all possible ways of breaking i into (i-1, 1), (i-2, 2)... (1, i -1).\\n\\n        int[] dp = new int[n + 1];\\n        dp[1] = 0;\\n        dp[2] = 1;\\n        for (int i = 3; i < n + 1; i++) {\\n        \\tfor (int j = 1; j < i; j++) {\\n        \\t\\tdp[i] = Math.max(dp[i],  Math.max(i - j, dp[i-j]) * Math.max(j, dp[j]));\\n        \\t}\\n        }\\n        return dp[n];\\n    } }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int integerBreak(int n) {\\n    \\t// dp[i] denotes the maximum product breaking i, then we have state equation:\\n    \\t// dp[i] = max (dp[i], max(i-j, dp[i-j]) * max(j, dp[j])) for 1 <= j < i,\\n        // that is, the max of all possible ways of breaking i into (i-1, 1), (i-2, 2)... (1, i -1).\\n\\n        int[] dp = new int[n + 1];\\n        dp[1] = 0;\\n        dp[2] = 1;\\n        for (int i = 3; i < n + 1; i++) {\\n        \\tfor (int j = 1; j < i; j++) {\\n        \\t\\tdp[i] = Math.max(dp[i],  Math.max(i - j, dp[i-j]) * Math.max(j, dp[j]));\\n        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 80863,
                "title": "c-18-line-o-log-n-solution",
                "content": "pow can be implemented to do the power in O(log(n))time.\\n\\nThis is using the math back ground that 2 & 3 (actually I think is e which is not an integer) is the most \\nefficient way of breaking sums\\n\\nclass Solution {\\n\\npublic:\\n    int integerBreak(int n) {\\n\\n\\n        if(n==2)return 1;\\n\\n        if(n==3)return 2;\\n\\n        if(n%3==1){\\n\\n            int k=(n-4)/3;\\n\\n            return 4*pow(3,k);\\n\\n        }\\n\\n        else if(n%3==2){\\n\\n            int k=(n-2)/3;\\n\\n            return 2*pow(3,k);\\n\\n        }\\n\\n        else{\\n\\n            return pow(3,n/3);\\n\\n        }\\n\\n    }\\n\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\npublic:\\n    int integerBreak(int n) {\\n\\n\\n        if(n==2)return 1;\\n\\n        if(n==3)return 2;\\n\\n        if(n%3==1){\\n\\n            int k=(n-4)/3;\\n\\n            return 4*pow(3,k);\\n\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 80898,
                "title": "python-dp-solution-with-explanation",
                "content": "dp[i]: the maximum product for integer i\\n\\nFor integer n, n = 1 \\\\+ (n-1) = 2 \\\\+ (n-2) = ... = j \\\\+ (n-j) = ... = n-2 \\\\+ (2)\\n\\nSo dp[n] = 1 \\\\* dp[n-1] or 2 \\\\* dp[n-2] or ... or j \\\\* dp[n-j] or (n-2) \\\\* dp[2], and we just need to get the maximum product among all the possibilities. \\n\\nWait, dp[i] means there will be a break for integer i, and it is also possible there is no break for i. After considering this, we correct the state function as follows.\\n\\ndp[n] = 1 \\\\* max(dp[n-1], n-1) or 2 \\\\* max(dp[n-2], n-2) or ... or j \\\\* max(dp[n-j], n-j) or (n-2) \\\\* max(dp[2], 2) \\n\\nFinally we get the state dp[n] = max(j * max(dp[n-j], n-j)), j = 1,2, ... , n-2.\\n\\n    dp = [0]*(n+1)\\n    dp[2] = 1\\n    for i in range(3, n+1):\\n        for j in range(1, i-1):\\n            dp[i] = max(dp[i], j*max(i-j, dp[i-j]))\\n    return dp[-1]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "dp[i]: the maximum product for integer i\\n\\nFor integer n, n = 1 \\\\+ (n-1) = 2 \\\\+ (n-2) = ... = j \\\\+ (n-j) = ... = n-2 \\\\+ (2)\\n\\nSo dp[n] = 1 \\\\* dp[n-1] or 2 \\\\* dp[n-2] or ... or j \\\\* dp[n-j] or (n-2) \\\\* dp[2], and we just need to get the maximum product among all the possibilities. \\n\\nWait, dp[i] means there will be a break for integer i, and it is also possible there is no break for i. After considering this, we correct the state function as follows.\\n\\ndp[n] = 1 \\\\* max(dp[n-1], n-1) or 2 \\\\* max(dp[n-2], n-2) or ... or j \\\\* max(dp[n-j], n-j) or (n-2) \\\\* max(dp[2], 2) \\n\\nFinally we get the state dp[n] = max(j * max(dp[n-j], n-j)), j = 1,2, ... , n-2.\\n\\n    dp = [0]*(n+1)\\n    dp[2] = 1\\n    for i in range(3, n+1):\\n        for j in range(1, i-1):\\n            dp[i] = max(dp[i], j*max(i-j, dp[i-j]))\\n    return dp[-1]",
                "codeTag": "Unknown"
            },
            {
                "id": 80918,
                "title": "0ms-c-o-n-math-and-dp-solutions-and-47ms-python-solution",
                "content": "When n is larger than 2, we need use as many factor 3 as possible to make the product larger. \\nBut we don't allow number 1 exists in factors. \\n\\nc++ Math: Time Complexity : O( n ); Space Complexity : O(1)\\n\\n    class Solution {\\n    public:\\n        int integerBreak(int n) {\\n            if(n == 2) return 1;\\n            if(n == 3) return 2;\\n            \\n            int res = 1;\\n            while(n > 2){\\n                res *= 3;\\n                n -= 3;\\n            }\\n            if(n == 0) return res;\\n            if(n == 1) return (res / 3 ) * 4;\\n            if(n == 2) return res * 2;\\n        }\\n    };\\n\\nc++ DP: Time Complexity : O( n ); Space Complexity : O(n)\\n\\n    class Solution {\\n    public:\\n        //dp[i] means max result we can get when n = i;\\n        int integerBreak(int n) {\\n            if(n == 2) return 1;\\n            if(n == 3) return 2;\\n            vector<int> dp(n+1, 0);\\n            dp[2] = 2;\\n            dp[3] = 3;\\n            for(int i = 4; i <= n; i++){\\n                dp[i] = max(dp[i-2] * 2, dp[i-3] * 3);\\n            }\\n            return dp[n];\\n        }\\n    };\\n\\n\\npython:\\n\\n    class Solution(object):\\n        def integerBreak(self, n):\\n            \"\"\"\\n            :type n: int\\n            :rtype: int\\n            \"\"\"\\n            if n == 2:\\n                return 1\\n            if n == 3:\\n                return 2\\n            t = n % 3\\n            if t == 0:\\n                return int(math.pow(3,n/3))\\n            if t == 1:\\n                return int(math.pow(3,(n-4)/3) * 4)\\n            if t == 2:\\n                return int(math.pow(3,(n-2)/3) * 2)",
                "solutionTags": [
                    "C++",
                    "Python"
                ],
                "code": "class Solution {\\n    public:\\n        int integerBreak(int n) {\\n            if(n == 2) return 1;\\n            if(n == 3) return 2;\\n            \\n            int res = 1;\\n            while(n > 2){\\n                res *= 3;\\n                n -= 3;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 80921,
                "title": "0ms-5-line-math-solution",
                "content": "    class Solution {\\n    public:\\n        int integerBreak(int n) {\\n            const vector<int> ref{1,1,1,2,4};\\n            if(n<=4) return ref[n];\\n            if(n%3==0) return pow(3, n/3);\\n            if(n%3==1) return 4*pow(3, n/3-1);\\n            if(n%3==2) return 2*pow(3, n/3);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int integerBreak(int n) {\\n            const vector<int> ref{1,1,1,2,4}",
                "codeTag": "Java"
            },
            {
                "id": 3434590,
                "title": "beats-100-solutions-c-space-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ntaking the cases for 3 consecutive numbers we get the intution\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ngeneral approach\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        \\n        if(n==2)    return 1;\\n        if(n==3)    return 2;\\n        int z=n%3;\\n        if(z==0)    return pow(3,n/3);\\n        else if(z==1)   return pow(3,n/3-1)*4;\\n        else if(z==2)   return pow(3,n/3)*2;\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        \\n        if(n==2)    return 1;\\n        if(n==3)    return 2;\\n        int z=n%3;\\n        if(z==0)    return pow(3,n/3);\\n        else if(z==1)   return pow(3,n/3-1)*4;\\n        else if(z==2)   return pow(3,n/3)*2;\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424452,
                "title": "100-beat-very-easy-to-understand-c",
                "content": "It\\'s all about thinking of 3\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int integerBreak(int n)\\n    {\\n        if (n == 2 || n == 3)\\n            return (n - 1);\\n\\n        int result = 1;\\n        while (n > 4)\\n        {\\n            n -= 3;\\n            result *= 3;\\n        }\\n        return (n * result);\\n    }\\n};\\n```\\nPlease \\uD83D\\uDC46 vote, if it\\'s helpful to you.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int integerBreak(int n)\\n    {\\n        if (n == 2 || n == 3)\\n            return (n - 1);\\n\\n        int result = 1;\\n        while (n > 4)\\n        {\\n            n -= 3;\\n            result *= 3;\\n        }\\n        return (n * result);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302680,
                "title": "sort-and-easy-c-soltuon-simple-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[60];\\n    int f(int n)\\n    {\\n        if(n==1)return 1;\\n        if(n==2)return 1;\\n        if(n==3)return 2;\\n        if(dp[n]!=-1)return dp[n];\\n        int take=0, ans=-1;\\n        for(int i=1;i<=n/2;i++)\\n        {\\n            take =  max({(n-i)*i,f(n-i)*i,f(i)*(n-i)});\\n            ans = max(ans,take);\\n        }\\n        return dp[n] =  ans;\\n    }\\n    int integerBreak(int n) {\\n        memset(dp,-1,sizeof(dp));\\n    return f(n);  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[60];\\n    int f(int n)\\n    {\\n        if(n==1)return 1;\\n        if(n==2)return 1;\\n        if(n==3)return 2;\\n        if(dp[n]!=-1)return dp[n];\\n        int take=0, ans=-1;\\n        for(int i=1;i<=n/2;i++)\\n        {\\n            take =  max({(n-i)*i,f(n-i)*i,f(i)*(n-i)});\\n            ans = max(ans,take);\\n        }\\n        return dp[n] =  ans;\\n    }\\n    int integerBreak(int n) {\\n        memset(dp,-1,sizeof(dp));\\n    return f(n);  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286818,
                "title": "6-lines-of-code-beats-100-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThinks of a pattern for elements having remainder as 1,or other than 1.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n       int x=n/3;\\n       int r=n%3;\\n       if(n==2||n==3) return n-1;\\n       if(r==1)return pow(3,x-1)*4;\\n       if(r>1)return pow(3,x)*r;\\n       return pow(3,x);\\n    \\n    }\\n};\\n \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n       int x=n/3;\\n       int r=n%3;\\n       if(n==2||n==3) return n-1;\\n       if(r==1)return pow(3,x-1)*4;\\n       if(r>1)return pow(3,x)*r;\\n       return pow(3,x);\\n    \\n    }\\n};\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3226508,
                "title": "c-beats-100-simple-maths-super-easy-approach",
                "content": "# Intuition\\nthe number is broken into maximum number of 3\\'s\\nwhen n is divided by 3, there will be 3 remainders: 0, 1 and 2\\n\\n# Approach\\n1. Remainder is 2: maximum number of 3\\'s are subtracted from n and the remaining number is 2 which is also multiplied. Exmaple: 14 would be broken as {3,3,3,3,2} `if(n%3==2){return pow(3,n/3)*2;}`\\n2. Remainder is 1: here if we try to get maximum number of 3\\'s will be left with a 1, which would be wasted as any number multiplied by 1 remains same. So what we do is, let a 3 remain in the n, so now we would be left with a 4, which is better then 3. Example: 16 = {3,3,3,3,4} `else if(n%3){return pow(3,n/3 -1)*pow(2,n%3 +1);}`\\n3. Remainder is 0: in this case also number is divided into maximum number of 3\\'s `return pow(3,n/3);`\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        if(n==2 || n==3) return n-1;\\n        if(n%3==2){\\n            return pow(3,n/3)*2;\\n        }\\n        else if(n%3){\\n            return pow(3,n/3 -1)*pow(2,n%3 +1);\\n        }\\n        return pow(3,n/3);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        if(n==2 || n==3) return n-1;\\n        if(n%3==2){\\n            return pow(3,n/3)*2;\\n        }\\n        else if(n%3){\\n            return pow(3,n/3 -1)*pow(2,n%3 +1);\\n        }\\n        return pow(3,n/3);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146388,
                "title": "java-easy-solution-with-2-approaches",
                "content": "\\n# Code\\n### Approach - 1\\n```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        for(int i = 2; i <= n; i++){\\n            int max = 0;\\n            for(int j = 1; j <= i / 2; j++){\\n                max = Math.max(max, Math.max(j * (i - j), dp[j] * dp[i - j]));\\n                max = Math.max(max, Math.max(j * dp[i - j], dp[j] * (i - j)));\\n            }\\n            dp[i] = max;\\n        }\\n        return dp[n];\\n    }\\n}\\n```\\n### Approach - 2\\n```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        if (n < 4) {\\n            return n - 1;\\n        }\\n        if (n % 3 == 0) {\\n            return (int) Math.pow(3, n / 3);\\n        }\\n        if (n % 3 == 1) {\\n            return (int) Math.pow(3, n / 3 - 1) * 4;\\n        }\\n        return (int) Math.pow(3, n / 3) * 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        int[] dp = new int[n + 1];\\n        dp[0] = 1;\\n        dp[1] = 1;\\n        for(int i = 2; i <= n; i++){\\n            int max = 0;\\n            for(int j = 1; j <= i / 2; j++){\\n                max = Math.max(max, Math.max(j * (i - j), dp[j] * dp[i - j]));\\n                max = Math.max(max, Math.max(j * dp[i - j], dp[j] * (i - j)));\\n            }\\n            dp[i] = max;\\n        }\\n        return dp[n];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        if (n < 4) {\\n            return n - 1;\\n        }\\n        if (n % 3 == 0) {\\n            return (int) Math.pow(3, n / 3);\\n        }\\n        if (n % 3 == 1) {\\n            return (int) Math.pow(3, n / 3 - 1) * 4;\\n        }\\n        return (int) Math.pow(3, n / 3) * 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030095,
                "title": "simple-java-solution-from-brute-force-to-bottom-up-dp-rod-cutting",
                "content": "It is similar to rod cutting problem or we can say unbounded knapsack problem subset.\\n\\nin rod cutting problem we have price array which we want to maximize.\\nlength n which is the total capacity.\\nand cutting can be done from 1 to n\\n\\nHere two variables a and i can be used which will be initially set to n. where \\'i\\' will serve as index and \\'a\\' will serve as value which needed to be break.\\n\\ninstead of sum of prices which we want to maximize in rod cutting. here we want product of number to be maximum. hence we multiply it by i.\\n\\nand on reaching range i.e. 0. instead of returning 0 we will return 1.(bcz multiplication by 0 make everything 0)\\n\\nrod cutting example can be referenced on gfg site.\\n\\nNote-> since in question it is mentioned that k>=2. we need to handle special check where n==3 or n==2 in such case answer will be 2 and 1. as if we did not apply this check. then by classic rod problem output of n=3 will be 3.\\n\\n# Brute Force\\n```\\npublic int integerBreak(int n) {\\n    return n<4?n-1:helper(n,n);\\n}\\nprivate int helper(int a,int i) {\\n    if(i==0 || a==0) {\\n        return 1;\\n    }\\n    if(a<i) {\\n        return helper(a,i-1);\\n    }\\n    return Math.max(helper(a,i-1),helper(a-i,i)*(i));\\n}\\n```\\n\\n# Top Down DP\\n```\\npublic int integerBreak(int n) {\\n    return n<=3?n-1:helper(n,n,new Integer[n+1][n+1]);\\n}\\nprivate int helper(int a,int i,Integer[][] memo) {\\n    if(i==0 || a==0) {\\n        return 1;\\n    }\\n    if(memo[a][i]!=null) {\\n        return memo[a][i];\\n    }\\n    if(a<i) {\\n        return memo[a][i]=helper(a,i-1,memo);\\n    }\\n    return memo[a][i]=Math.max(helper(a,i-1,memo),helper(a-i,i,memo)*(i));\\n}\\n```\\n# Bottom Up DP\\n```\\npublic int integerBreak(int n) {\\n    if(n<4) {\\n        return n-1;\\n    }\\n    int[][] memo=new int[n+1][n+1];\\n    for(int i=0;i<=n;i++) {\\n        for(int a=0;a<=n;a++) {\\n            if(i==0||a==0) {\\n                memo[a][i]=1;\\n            }\\n            else if(a<i) {\\n                memo[a][i]=memo[a][i-1];\\n            } else {\\n                memo[a][i]=Math.max(memo[a][i-1],memo[a-i][i]*i);\\n            }\\n        }\\n    }\\n    return memo[n][n];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int integerBreak(int n) {\\n    return n<4?n-1:helper(n,n);\\n}\\nprivate int helper(int a,int i) {\\n    if(i==0 || a==0) {\\n        return 1;\\n    }\\n    if(a<i) {\\n        return helper(a,i-1);\\n    }\\n    return Math.max(helper(a,i-1),helper(a-i,i)*(i));\\n}\\n```\n```\\npublic int integerBreak(int n) {\\n    return n<=3?n-1:helper(n,n,new Integer[n+1][n+1]);\\n}\\nprivate int helper(int a,int i,Integer[][] memo) {\\n    if(i==0 || a==0) {\\n        return 1;\\n    }\\n    if(memo[a][i]!=null) {\\n        return memo[a][i];\\n    }\\n    if(a<i) {\\n        return memo[a][i]=helper(a,i-1,memo);\\n    }\\n    return memo[a][i]=Math.max(helper(a,i-1,memo),helper(a-i,i,memo)*(i));\\n}\\n```\n```\\npublic int integerBreak(int n) {\\n    if(n<4) {\\n        return n-1;\\n    }\\n    int[][] memo=new int[n+1][n+1];\\n    for(int i=0;i<=n;i++) {\\n        for(int a=0;a<=n;a++) {\\n            if(i==0||a==0) {\\n                memo[a][i]=1;\\n            }\\n            else if(a<i) {\\n                memo[a][i]=memo[a][i-1];\\n            } else {\\n                memo[a][i]=Math.max(memo[a][i-1],memo[a-i][i]*i);\\n            }\\n        }\\n    }\\n    return memo[n][n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2883204,
                "title": "beats-96-submissions-proof-attached-fastest-and-easiest-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![Screenshot 2022-12-06 150721.png](https://assets.leetcode.com/users/images/a1ef258b-632a-417e-aa87-e79f6752b85a_1670319460.7449555.png)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSIMPLE DP SOLUTION WHERE WE CALCULATE THE MAX PRODUCT FOR EACH SUBPROBLEM AND THEN STORE THEM IN DP ARRAY.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        dp={1:1}\\n        for num in range(2,n+1):\\n            dp[num]=0 if num==n else num\\n            for i in range(1,num):\\n                val=dp[i]*dp[num-i]\\n                dp[num]=max(dp[num],val)\\n        return dp[n]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        dp={1:1}\\n        for num in range(2,n+1):\\n            dp[num]=0 if num==n else num\\n            for i in range(1,num):\\n                val=dp[i]*dp[num-i]\\n                dp[num]=max(dp[num],val)\\n        return dp[n]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696497,
                "title": "python3-simplest-answer-possible-with-explanation",
                "content": "```python\\ndef integerBreak(self, n: int) -> int:\\n        # 1 = 1*1 and 2 = 2*1\\n        if n == 2 or n == 3:\\n            return n-1\\n        \\n        # greedily use all 3s \\n        # EXCEPT when there is a remainder of 1\\n        # because we can \"steal\" a 3 to split into two 2s\\n        num_of_threes = (n//3 - (n%3 == 1))\\n        \\n        # If there is a remainder of 2, mulitply by 2 (because 2 > 1*1)\\n        # If there is a remainder of 1, multiply by 4 (because 2*2 > 3*1)\\n        # If there is a remainder of 0, we cannot make any 2s\\n\\t\\t# you can also write this as (n%3 == 1)+(n%3 != 0)\\n        num_of_twos = 0 if not n%3 else (2 if n%3 == 1 else 1)\\n        \\n        return 3**num_of_threes * 2**num_of_twos\\n```\\n\\nand a one liner to show off because why not\\n\\n```python\\ndef integerBreak(self, n: int) -> int:\\n        return 3**(n//3-(n%3 == 1))*2**((n%3 == 1)+(n%3 != 0)) if (n != 2 and n != 3) else n-1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef integerBreak(self, n: int) -> int:\\n        # 1 = 1*1 and 2 = 2*1\\n        if n == 2 or n == 3:\\n            return n-1\\n        \\n        # greedily use all 3s \\n        # EXCEPT when there is a remainder of 1\\n        # because we can \"steal\" a 3 to split into two 2s\\n        num_of_threes = (n//3 - (n%3 == 1))\\n        \\n        # If there is a remainder of 2, mulitply by 2 (because 2 > 1*1)\\n        # If there is a remainder of 1, multiply by 4 (because 2*2 > 3*1)\\n        # If there is a remainder of 0, we cannot make any 2s\\n\\t\\t# you can also write this as (n%3 == 1)+(n%3 != 0)\\n        num_of_twos = 0 if not n%3 else (2 if n%3 == 1 else 1)\\n        \\n        return 3**num_of_threes * 2**num_of_twos\\n```\n```python\\ndef integerBreak(self, n: int) -> int:\\n        return 3**(n//3-(n%3 == 1))*2**((n%3 == 1)+(n%3 != 0)) if (n != 2 and n != 3) else n-1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2519921,
                "title": "java-easy-solution-100-faster-only-if-else",
                "content": "```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        \\n        int x = (int) Math.pow(3,n/3);\\n        int y =(int) Math.pow(3,n/3-1);\\n       \\n        if(n<=5){\\n            if(n==2) return 1;\\n            if(n==3) return 2;\\n            if(n%2==0) return n/2*n/2;\\n            else return 6; \\n        }\\n        if(n>5){\\n          if(n%3==0){\\n              return x;\\n          } \\n          if(n%3==1){\\n              return y*4;\\n          }\\n          if(n%3==2){\\n              return x*2;\\n          }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        \\n        int x = (int) Math.pow(3,n/3);\\n        int y =(int) Math.pow(3,n/3-1);\\n       \\n        if(n<=5){\\n            if(n==2) return 1;\\n            if(n==3) return 2;\\n            if(n%2==0) return n/2*n/2;\\n            else return 6; \\n        }\\n        if(n>5){\\n          if(n%3==0){\\n              return x;\\n          } \\n          if(n%3==1){\\n              return y*4;\\n          }\\n          if(n%3==2){\\n              return x*2;\\n          }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500326,
                "title": "c-fast-soln-100-0ms-soluition-with-little-explanation",
                "content": "```\\nclass Solution {\\n    int getMax(int n, vector<int> &dp){\\n        if(n <= 1) return 1;  //  base case \\n        \\n        //  if the max mult exists for n return it..\\n        if(dp[n] != -1) \\n            return dp[n];\\n        \\n        int ans = 1;\\n        //  now divide n from (1, n-1) to (n, 0) and recur \\n        \\n        for(int i = 1; i <= n; i++){\\n            // mult is i*(next mult) \\n            ans = max(ans, i*getMax(n-i, dp));\\n        }\\n        \\n        return dp[n] = ans;  // store the ans for n and return\\n        \\n    }\\npublic:\\n    int integerBreak(int n) {\\n        if(n <= 3) return n-1; // as an edge case 3 = 2+1, 2 = 1+1\\n        \\n        //  The dp vector to store the max multiplication of numbers which sum upto i\\n        //  like dp[10] = 36 => (10 = 3+3+4) and 3*3*4 = 36\\n        vector<int> dp(n+1, -1); \\n        \\n        return getMax(n, dp);  // call the function as a tabulation approach\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int getMax(int n, vector<int> &dp){\\n        if(n <= 1) return 1;  //  base case \\n        \\n        //  if the max mult exists for n return it..\\n        if(dp[n] != -1) \\n            return dp[n];\\n        \\n        int ans = 1;\\n        //  now divide n from (1, n-1) to (n, 0) and recur \\n        \\n        for(int i = 1; i <= n; i++){\\n            // mult is i*(next mult) \\n            ans = max(ans, i*getMax(n-i, dp));\\n        }\\n        \\n        return dp[n] = ans;  // store the ans for n and return\\n        \\n    }\\npublic:\\n    int integerBreak(int n) {\\n        if(n <= 3) return n-1; // as an edge case 3 = 2+1, 2 = 1+1\\n        \\n        //  The dp vector to store the max multiplication of numbers which sum upto i\\n        //  like dp[10] = 36 => (10 = 3+3+4) and 3*3*4 = 36\\n        vector<int> dp(n+1, -1); \\n        \\n        return getMax(n, dp);  // call the function as a tabulation approach\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2477777,
                "title": "c-solution-recursion-dp-best-soluton-100",
                "content": "```\\n\\nclass Solution {\\npublic:\\n//     Here are some base cases which we can think of manually!!!\\n    unordered_map<int,int> mp={\\n        {2,1},   {3,2},   {4,4},   {5,6},   {6,9},   {7,12},   {8,18},   {9,27}\\n    };\\n    \\n    int   solve(int n,vector<int> &dp)\\n    {\\n//         base case\\n        if(n<=9)\\n        {\\n            return mp[n];\\n        }\\n        \\n//         If previous call is already calculated!!!\\n        if(dp[n]!=-1)\\n            return dp[n];\\n        \\n        \\n//         If odd number then n/2 and n/2+1 call otherwise both n/2 call will be caluclated!!\\n        if(n&1)\\n        {\\n           return solve(n/2,dp)*solve(n/2+1,dp);\\n        }\\n        \\n        \\n            return solve(n/2,dp)*solve(n/2,dp);\\n        \\n        \\n    }\\n    int integerBreak(int n) {\\n//         dp initization\\n        vector<int> dp(59,-1);\\n        \\n    \\n//         premutation of all the possible numbers\\n         for(int i=2;i<=58;i++)\\n         {\\n             if(i<=9)\\n             {\\n                 \\n                 dp[i]=mp[i];\\n             }\\n             else\\n             {\\n                 int res=1;\\n                 for(int j=2;j<=i/2;j++)\\n                 {\\n                     dp[i]=max(dp[i],solve(j,dp)*solve(i-j,dp));\\n                 }\\n                \\n                 \\n             }\\n         }\\n        return dp[n];\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n//     Here are some base cases which we can think of manually!!!\\n    unordered_map<int,int> mp={\\n        {2,1},   {3,2},   {4,4},   {5,6},   {6,9},   {7,12},   {8,18},   {9,27}\\n    };\\n    \\n    int   solve(int n,vector<int> &dp)\\n    {\\n//         base case\\n        if(n<=9)\\n        {\\n            return mp[n];\\n        }\\n        \\n//         If previous call is already calculated!!!\\n        if(dp[n]!=-1)\\n            return dp[n];\\n        \\n        \\n//         If odd number then n/2 and n/2+1 call otherwise both n/2 call will be caluclated!!\\n        if(n&1)\\n        {\\n           return solve(n/2,dp)*solve(n/2+1,dp);\\n        }\\n        \\n        \\n            return solve(n/2,dp)*solve(n/2,dp);\\n        \\n        \\n    }\\n    int integerBreak(int n) {\\n//         dp initization\\n        vector<int> dp(59,-1);\\n        \\n    \\n//         premutation of all the possible numbers\\n         for(int i=2;i<=58;i++)\\n         {\\n             if(i<=9)\\n             {\\n                 \\n                 dp[i]=mp[i];\\n             }\\n             else\\n             {\\n                 int res=1;\\n                 for(int j=2;j<=i/2;j++)\\n                 {\\n                     dp[i]=max(dp[i],solve(j,dp)*solve(i-j,dp));\\n                 }\\n                \\n                 \\n             }\\n         }\\n        return dp[n];\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475334,
                "title": "c-solution-time-o-n-2-memory-o-n-dynamic-programming-iterative-and-recursive",
                "content": "The recursive solution:\\n```C#\\npublic class Solution {\\n    public int IntegerBreak(int n) {\\n        Dictionary<int, int> dp = new Dictionary<int, int>(capacity: n + 1);\\n        dp[1] = 1;\\n\\n        Solve(n);\\n        return dp[n];\\n        \\n        int Solve(int number) {\\n            if (dp.TryGetValue(number, out int memoizedResult)) return memoizedResult;\\n            \\n            int half = number / 2;\\n            int result = 0;\\n            for (int i = 1; i <= half; i++) {\\n                int a = Math.Max(i, Solve(i)), b = Math.Max(number - i, Solve(number - i));\\n                result = Math.Max(result, a * b);\\n            }\\n            \\n            dp[number] = result;\\n            return result;\\n        }\\n    }\\n}\\n```\\n\\nThe iterative solution:\\n```C#\\npublic class Solution {\\n    public int IntegerBreak(int n) {\\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        \\n        for (int i = 2; i <= n; i++) {\\n            int half = i / 2;\\n            for (int j = 1; j <= half; j++) {\\n                int a = Math.Max(j, dp[j]), b = Math.Max(i - j, dp[i - j]);\\n                dp[i] = Math.Max(dp[i], a * b);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```C#\\npublic class Solution {\\n    public int IntegerBreak(int n) {\\n        Dictionary<int, int> dp = new Dictionary<int, int>(capacity: n + 1);\\n        dp[1] = 1;\\n\\n        Solve(n);\\n        return dp[n];\\n        \\n        int Solve(int number) {\\n            if (dp.TryGetValue(number, out int memoizedResult)) return memoizedResult;\\n            \\n            int half = number / 2;\\n            int result = 0;\\n            for (int i = 1; i <= half; i++) {\\n                int a = Math.Max(i, Solve(i)), b = Math.Max(number - i, Solve(number - i));\\n                result = Math.Max(result, a * b);\\n            }\\n            \\n            dp[number] = result;\\n            return result;\\n        }\\n    }\\n}\\n```\n```C#\\npublic class Solution {\\n    public int IntegerBreak(int n) {\\n        int[] dp = new int[n + 1];\\n        dp[1] = 1;\\n        \\n        for (int i = 2; i <= n; i++) {\\n            int half = i / 2;\\n            for (int j = 1; j <= half; j++) {\\n                int a = Math.Max(j, dp[j]), b = Math.Max(i - j, dp[i - j]);\\n                dp[i] = Math.Max(dp[i], a * b);\\n            }\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2307076,
                "title": "java-easy-solution-0ms-100-fast",
                "content": "![image](https://assets.leetcode.com/users/images/d5246a2d-d6ec-4edd-8c20-fc3219fccff1_1658295708.8481832.png)\\n\\n```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        if(n == 2) {\\n            return 1;\\n        }\\n        if(n == 3) {\\n            return 2;\\n        }\\n        int answer = 1;\\n        while(n > 4) {\\n            n -= 3;\\n            answer *= 3;\\n        }\\n        return answer * n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        if(n == 2) {\\n            return 1;\\n        }\\n        if(n == 3) {\\n            return 2;\\n        }\\n        int answer = 1;\\n        while(n > 4) {\\n            n -= 3;\\n            answer *= 3;\\n        }\\n        return answer * n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278604,
                "title": "i-want-a-girl-friend-have-been-single-for-loooong-time",
                "content": "```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        if(n==2)return 1;\\n        if(n==3)return 2;\\n        int prod=1;\\n        while(n>4){\\n            prod*=3;\\n            n-=3;\\n        }\\n        return prod*n;\\n    }\\n}\\n```\\nMy future GF please comment your insta ID",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int integerBreak(int n) {\\n        if(n==2)return 1;\\n        if(n==3)return 2;\\n        int prod=1;\\n        while(n>4){\\n            prod*=3;\\n            n-=3;\\n        }\\n        return prod*n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2209574,
                "title": "cpp-easy-to-understand-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        vector<int> dp(n+1);\\n        if(n==2) return 1;\\n        if(n==3) return 2;\\n        dp[0]=1; dp[1]=1; dp[2]=2; dp[3]=3;\\n        \\n        for(int i=4;i<=n;i++){\\n            int mx=0;\\n            for(int j=1;j<=(i/2);j++){\\n                mx = max(dp[j] * dp[i-j],mx);\\n            }\\n            dp[i]=mx;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        vector<int> dp(n+1);\\n        if(n==2) return 1;\\n        if(n==3) return 2;\\n        dp[0]=1; dp[1]=1; dp[2]=2; dp[3]=3;\\n        \\n        for(int i=4;i<=n;i++){\\n            int mx=0;\\n            for(int j=1;j<=(i/2);j++){\\n                mx = max(dp[j] * dp[i-j],mx);\\n            }\\n            dp[i]=mx;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2144085,
                "title": "java-0-ms-100-faster",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int f(int num,int dp[]){\\n        if(num==1) return num;\\n        if(dp[num]!=-1) return dp[num];\\n        \\n        int max =  0;\\n        for(int i=1;i<=num;i++){\\n            int ans1 = i*f(num-i,dp);\\n            int ans2 = i*(num-i);\\n            max = Math.max(max,Math.max(ans1,ans2));\\n        }    \\n        return dp[num] = max;\\n    }\\n    \\n    public int integerBreak(int n) {\\n        if(n==1) return 0;\\n        int dp[] = new int[n+1];\\n        Arrays.fill(dp,-1);\\n        return f(n,dp);\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    public int f(int num,int dp[]){\\n        if(num==1) return num;\\n        if(dp[num]!=-1) return dp[num];\\n        \\n        int max =  0;\\n        for(int i=1;i<=num;i++){\\n            int ans1 = i*f(num-i,dp);\\n            int ans2 = i*(num-i);\\n            max = Math.max(max,Math.max(ans1,ans2));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1985670,
                "title": "python-dp-top-down-to-bottom-up-0-1-knapsack-rod-cutting-problem",
                "content": "I\\'ve seen a lot of writeup\\'s for this problem, but there weren\\'t too many descriptions on how to come up with the recurrence relationship. I recognized this as the 0/1 knapsack, but I couldn\\'t really figure out the dp function. After looking through some solutions, it looks like this is a variant of the rod cutting problem from CLRS Chapter 15.1!\\n\\n##### Function\\n* let ```dp(n)``` be a function that returns the maximum product IFF we can split n into >= 2 numbers, such that the product of the numbers is maximized\\n* we can try split ```n``` int parts if we subract some number ```i``` in ```range(1,n)```\\n*  this will give is two parts ```i``` and ```n-i```\\n\\n\\n##### Base Cases\\n* if n gets down to 1, well, we only have onre product, thats 1\\n* if n gets down to 2, this can only be split into [1,1], that has product of 1\\n\\n##### Recurrence \\n* for all splits ```i``` we can get a new maximum product ```dp(n-i)*i``` if we wish to split n at this i\\n* or we can choose not to access this previous computation, at which we are left with the another product ```(n-i)*i```\\n* we have the recurrence as ```dp(n) = max(dp(n-i),n-i)*i```\\n* keep in mind we have to MINIMIZE this for all ```i``` in ```range(1,n)```\\n\\n#### Top Down\\n```\\n        memo = {}\\n        \\n        def dp(n):\\n            if n == 1 or n == 2:\\n                return 1\\n            if n in memo:\\n                return memo[n]\\n            \\n            ans = 0\\n            for i in range(1,n):\\n                take = dp(n-i)\\n                no_take = n-i\\n                ans = max(ans,i*max(take,no_take))\\n            \\n            memo[n] = ans\\n            return ans\\n        \\n        return dp(n)\\n```\\n\\n##### Bottom Up\\n* For every recurrence relation, their is a toplogical sort (rather an order in which we MUST solve subroblems to solve the original problem)\\n* We start from the BASE CASE and work our way up to N\\n* we can store our dp answers in array (+1 becaue of zero indexing)\\n\\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        \\'\\'\\'\\n        bottom up\\n        \\'\\'\\'\\n        dp = [0]*(n+1)\\n        dp[1] = 1\\n        dp[2] = 1\\n        \\n        for num in range(3,len(dp)):\\n            ans = 0\\n            for i in range(1,num):\\n                take = dp[num-i]\\n                no_take = num-i\\n                ans = max(ans,i*max(take,no_take))\\n            \\n            dp[num] = ans\\n        \\n        return dp[-1]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```dp(n)```\n```n```\n```i```\n```range(1,n)```\n```i```\n```n-i```\n```i```\n```dp(n-i)*i```\n```(n-i)*i```\n```dp(n) = max(dp(n-i),n-i)*i```\n```i```\n```range(1,n)```\n```\\n        memo = {}\\n        \\n        def dp(n):\\n            if n == 1 or n == 2:\\n                return 1\\n            if n in memo:\\n                return memo[n]\\n            \\n            ans = 0\\n            for i in range(1,n):\\n                take = dp(n-i)\\n                no_take = n-i\\n                ans = max(ans,i*max(take,no_take))\\n            \\n            memo[n] = ans\\n            return ans\\n        \\n        return dp(n)\\n```\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        \\'\\'\\'\\n        bottom up\\n        \\'\\'\\'\\n        dp = [0]*(n+1)\\n        dp[1] = 1\\n        dp[2] = 1\\n        \\n        for num in range(3,len(dp)):\\n            ans = 0\\n            for i in range(1,num):\\n                take = dp[num-i]\\n                no_take = num-i\\n                ans = max(ans,i*max(take,no_take))\\n            \\n            dp[num] = ans\\n        \\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1968920,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Solution { \\n\\n    public int integerBreak(int n) {\\n        int res = 0;\\n        int three = n / 3;\\n        int rest = n % 3;\\n        if (n == 2) {\\n            return 1;\\n        } else if (n == 3) {\\n            return 2;\\n        } else if (rest == 0) {\\n            res = (int) Math.pow(3, three);\\n        } else if (rest == 1){\\n            res = (int) Math.pow(3, three - 1) * (rest + 3);\\n        } else if (rest == 2){\\n            res = (int) Math.pow(3, three) * (rest);\\n        }\\n        return res;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution { \\n\\n    public int integerBreak(int n) {\\n        int res = 0;\\n        int three = n / 3;\\n        int rest = n % 3;\\n        if (n == 2) {\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1910832,
                "title": "intuitive-solution-greedy-and-dp-combined",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    int dp[60];\\n    \\n    int integerBreak(int n) {\\n      \\n        if(n==2)return 1;\\n        if(n==3)return 2;\\n        if(n==4)return 4;\\n        if(n==5)return 6;\\n        if(n==6)return 9;\\n        \\n        if(dp[n]!=0)return dp[n];\\n        \\n        return dp[n]= max(integerBreak(n-3)*3 , integerBreak(n-2)*2);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   \\n    int dp[60];\\n    \\n    int integerBreak(int n) {\\n      \\n        if(n==2)return 1;\\n        if(n==3)return 2;\\n        if(n==4)return 4;\\n        if(n==5)return 6;\\n        if(n==6)return 9;\\n        \\n        if(dp[n]!=0)return dp[n];\\n        \\n        return dp[n]= max(integerBreak(n-3)*3 , integerBreak(n-2)*2);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1892340,
                "title": "c-single-loop-3-lines-code-easy-understanding-math",
                "content": "```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n\\t\\n        long value = 1;\\n        if(n == 2) return 1;\\n        if(n == 3) return 2;\\n        if(n == 4) return 4;\\n        \\n        while(n-3 >= 2){\\n            value *= 3, n -= 3;\\n        }\\n        value *= n;\\n        \\n        return value;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n\\t\\n        long value = 1;\\n        if(n == 2) return 1;\\n        if(n == 3) return 2;\\n        if(n == 4) return 4;\\n        \\n        while(n-3 >= 2){\\n            value *= 3, n -= 3;\\n        }\\n        value *= n;\\n        \\n        return value;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891837,
                "title": "java-dynamic-programming",
                "content": "\\ndp[i] means maximum product of number i ( ignore k>=2 ). So dp[2]=2 and dp[3]=3 . When the product is max, n always break into 2 and 3. So for each n>=4 , the solution is `2*dp[n-2]` or `3*dp[n-3]`\\n\\n```java\\npublic int integerBreak(int n) {\\n\\tif(n<=3) return n-1;\\n\\tint[] dp=new int[n+1];\\n\\tdp[2]=2;\\n\\tdp[3]=3;\\n\\tfor(int i=4;i<=n;++i){\\n\\t\\tint i2=2*dp[i-2];\\n\\t\\tint i3=3*dp[i-3];\\n\\t\\tdp[i]=Math.max(i2,i3);\\n\\t}\\n\\treturn dp[n];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\npublic int integerBreak(int n) {\\n\\tif(n<=3) return n-1;\\n\\tint[] dp=new int[n+1];\\n\\tdp[2]=2;\\n\\tdp[3]=3;\\n\\tfor(int i=4;i<=n;++i){\\n\\t\\tint i2=2*dp[i-2];\\n\\t\\tint i3=3*dp[i-3];\\n\\t\\tdp[i]=Math.max(i2,i3);\\n\\t}\\n\\treturn dp[n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1753444,
                "title": "unbounded-knapsack-problem-integer-break",
                "content": "**This is Typical Knapsack Problem**\\n\\n**TC : O(N^2)**\\n\\n```\\nclass Solution {\\npublic:\\n//     unbounded knapsack \\n//     recursion + memoization\\n    int dp[59][59];\\n    int solve(vector<int>&nums,int cp,int n){\\n        if(cp == 0) return 1;\\n        if(n == 0) return 0;\\n        if(dp[n][cp] != -1) return dp[n][cp];\\n        if(cp >= nums[n-1])\\n        {\\n            return  dp[n][cp] =  max(nums[n-1]*solve(nums,cp-nums[n-1],n),solve(nums,cp,n-1));\\n        }else return  dp[n][cp] = solve(nums,cp,n-1);\\n    }\\n    int integerBreak(int n) {\\n     memset(dp,-1,sizeof(dp));\\n        vector<int>nums;\\n        for(int i=1;i<=n-1;i++){\\n            nums.push_back(i);\\n        }\\n        return solve(nums,n,nums.size());\\n    }\\n};\\n```\\n\\n*If you like the solution then please UPVOTE this help to motivate me \\uD83C\\uDF88\\uD83D\\uDE01*\\n**:) Happy Coding**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//     unbounded knapsack \\n//     recursion + memoization\\n    int dp[59][59];\\n    int solve(vector<int>&nums,int cp,int n){\\n        if(cp == 0) return 1;\\n        if(n == 0) return 0;\\n        if(dp[n][cp] != -1) return dp[n][cp];\\n        if(cp >= nums[n-1])\\n        {\\n            return  dp[n][cp] =  max(nums[n-1]*solve(nums,cp-nums[n-1],n),solve(nums,cp,n-1));\\n        }else return  dp[n][cp] = solve(nums,cp,n-1);\\n    }\\n    int integerBreak(int n) {\\n     memset(dp,-1,sizeof(dp));\\n        vector<int>nums;\\n        for(int i=1;i<=n-1;i++){\\n            nums.push_back(i);\\n        }\\n        return solve(nums,n,nums.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1744914,
                "title": "python-3-4-liner-top-99",
                "content": "![image](https://assets.leetcode.com/users/images/39883059-ce49-4da5-8839-8ecbc982c562_1643994505.01198.png)\\n\\n\\n```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        \\n        if n<=3: return n-1\\n\\n        if n%3 == 0: return int(3**(n/3))\\n        elif n%3 == 1: return int(3**(n//3)/3*2*2)\\n        else: return int(3**(n//3)*2)\\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        \\n        if n<=3: return n-1\\n\\n        if n%3 == 0: return int(3**(n/3))\\n        elif n%3 == 1: return int(3**(n//3)/3*2*2)\\n        else: return int(3**(n//3)*2)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738748,
                "title": "c-beats-100-dp-bottom-up",
                "content": "```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        vector<int> dp(n+1,INT_MIN);\\n        dp[0]=0;\\n        dp[1]=1;\\n        \\n        for(int i=2;i<=n;i++){\\n            for(int j=1;j<i;j++){\\n                dp[i] = max(dp[i],j*max(dp[i-j],i-j));\\n            }   \\n        }\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        vector<int> dp(n+1,INT_MIN);\\n        dp[0]=0;\\n        dp[1]=1;\\n        \\n        for(int i=2;i<=n;i++){\\n            for(int j=1;j<i;j++){\\n                dp[i] = max(dp[i],j*max(dp[i-j],i-j));\\n            }   \\n        }\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1719868,
                "title": "modulo-3",
                "content": "```\\n\\n\\nint integerBreak(int n){\\n    if (n == 2) return 1;\\n    if (n == 3) return 2;\\n    int prod = 1; // there is no point in including a number greater than 4\\n    while (n > 4) { // 3*3 > 2*2*2 so include as many threes as possible\\n        n -= 3;\\n        prod *= 3;\\n    }\\n    return prod*n; // 4 = 2*2 so can break\\n        \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nint integerBreak(int n){\\n    if (n == 2) return 1;\\n    if (n == 3) return 2;\\n    int prod = 1; // there is no point in including a number greater than 4\\n    while (n > 4) { // 3*3 > 2*2*2 so include as many threes as possible\\n        n -= 3;\\n        prod *= 3;\\n    }\\n    return prod*n; // 4 = 2*2 so can break\\n        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1621563,
                "title": "o-1-timecomplexity-java-solution-easy-to-understand",
                "content": "Just using several manual test cases to find that for any number the product will be max when it is consisting of sum of several small numbers (majorly 3). and this will be valid for all the number greater than 5 (n >= 5)\\n\\n\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int integerBreak(int n) {\\n\\t//Taking exception cases\\n        if(n==2) return 1;\\n        if(n==3) return 2;\\n        if(n==4) return 4;\\n        int count3 = n/3;\\n        int rem = n%3;\\n\\t\\t// remainder must not be 0 or 1 as it will decrease the resulting value\\n\\t\\t// If remainder is 1 then we will be adding 1 3 from count3 \\n\\t\\t//so count3 will be reduced by 1\\n\\t\\t// and rem will increase to 4\\n\\t\\t//if rem == 0 then set it to 1\\n        rem = (rem==1)?4:(rem==0)?1:2;\\n        count3 = (rem==4)?count3-1:count3;\\n        int ans = (int)Math.pow(3, count3) * rem;\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int integerBreak(int n) {\\n\\t//Taking exception cases\\n        if(n==2) return 1;\\n        if(n==3) return 2;\\n        if(n==4) return 4;\\n        int count3 = n/3;\\n        int rem = n%3;\\n\\t\\t// remainder must not be 0 or 1 as it will decrease the resulting value\\n\\t\\t// If remainder is 1 then we will be adding 1 3 from count3 \\n\\t\\t//so count3 will be reduced by 1\\n\\t\\t// and rem will increase to 4\\n\\t\\t//if rem == 0 then set it to 1\\n        rem = (rem==1)?4:(rem==0)?1:2;\\n        count3 = (rem==4)?count3-1:count3;\\n        int ans = (int)Math.pow(3, count3) * rem;\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1533128,
                "title": "c-java-dynamic-programming-tabulation-o-n-time-o-n-space",
                "content": "### C++ Solutoin.\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int integerBreak(int n) {\\n        dp.resize(n+1, 0);\\n        return solve(n);\\n    }\\n    \\n    int solve(int n){\\n        if(n == 1) return 1;\\n        if(dp[n] != 0) return dp[n];\\n        \\n        int result = 1 * (n - 1);\\n        for(int i = 1; i < n; i++){\\n            int first = i;\\n            int second = n - i;\\n            int product = first * max(second, solve(second));\\n            result = max(result, product);\\n        }\\n        return dp[n] = result;\\n    }\\n};\\n```\\n### Java Solution.\\n```\\nclass Solution {\\n    private int[] dp;\\n    public int integerBreak(int n) {\\n        dp = new int[n+1];\\n        return solve(n);\\n    }\\n    \\n    private int solve(int n){\\n        if(n == 1) return 1;\\n        if(dp[n] != 0) return dp[n];\\n        \\n        int result = 1 * (n - 1);\\n        for(int i = 1; i < n; i++){\\n            int first = i;\\n            int second = n - i;\\n            int product = first * Math.max(second, solve(second));\\n            result = Math.max(result, product);\\n        }\\n        return dp[n] = result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int integerBreak(int n) {\\n        dp.resize(n+1, 0);\\n        return solve(n);\\n    }\\n    \\n    int solve(int n){\\n        if(n == 1) return 1;\\n        if(dp[n] != 0) return dp[n];\\n        \\n        int result = 1 * (n - 1);\\n        for(int i = 1; i < n; i++){\\n            int first = i;\\n            int second = n - i;\\n            int product = first * max(second, solve(second));\\n            result = max(result, product);\\n        }\\n        return dp[n] = result;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    private int[] dp;\\n    public int integerBreak(int n) {\\n        dp = new int[n+1];\\n        return solve(n);\\n    }\\n    \\n    private int solve(int n){\\n        if(n == 1) return 1;\\n        if(dp[n] != 0) return dp[n];\\n        \\n        int result = 1 * (n - 1);\\n        for(int i = 1; i < n; i++){\\n            int first = i;\\n            int second = n - i;\\n            int product = first * Math.max(second, solve(second));\\n            result = Math.max(result, product);\\n        }\\n        return dp[n] = result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1482433,
                "title": "c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    long long integerBreak(long long n) {\\n        if(n == 2) return 1;\\n        if(n == 3) return 2;\\n        if(n == 4) return 4;\\n        if(n == 5) return 6;\\n        if(n == 6) return 9;\\n        return 3 * integerBreak(n - 3);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long integerBreak(long long n) {\\n        if(n == 2) return 1;\\n        if(n == 3) return 2;\\n        if(n == 4) return 4;\\n        if(n == 5) return 6;\\n        if(n == 6) return 9;\\n        return 3 * integerBreak(n - 3);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450456,
                "title": "o-1-c-explanation-in-comments-easy-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        int i,j;\\n        vector<int> dp(5);  //constant space vector for those numbers which are not following the pattern (n=2 to 4)\\n        dp[2]=1;\\n        dp[3]=2;\\n        dp[4]=4;\\n        if(n<=4)\\n            return dp[n];\\n        int f=n/3;\\n        int ans=pow(3,f);\\n        if(n%3==0)  // if n is divisible by 3 we can obtain the number by adding 3 and answer by just multipying it\\n            return ans;\\n        if(n%3==1){   // if remainder is 1, ex: n=10 then answer is 3+3+4 i.e. ans=pow(3,f-1)*4\\n            ans=pow(3,f-1);  \\n            return ans*4;\\n        }\\n        ans=ans*(n%3); //basically its for n%3==2 case\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int integerBreak(int n) {\\n        int i,j;\\n        vector<int> dp(5);  //constant space vector for those numbers which are not following the pattern (n=2 to 4)\\n        dp[2]=1;\\n        dp[3]=2;\\n        dp[4]=4;\\n        if(n<=4)\\n            return dp[n];\\n        int f=n/3;\\n        int ans=pow(3,f);\\n        if(n%3==0)  // if n is divisible by 3 we can obtain the number by adding 3 and answer by just multipying it\\n            return ans;\\n        if(n%3==1){   // if remainder is 1, ex: n=10 then answer is 3+3+4 i.e. ans=pow(3,f-1)*4\\n            ans=pow(3,f-1);  \\n            return ans*4;\\n        }\\n        ans=ans*(n%3); //basically its for n%3==2 case\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365732,
                "title": "easy-c-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int n , int k , int dp[]) {\\n        if(n < 0){\\n            return 0;\\n        }\\n        if(n == 0 && k >= 2){\\n            return 1;\\n        }\\n        if(dp[n] != -1){\\n            return dp[n];\\n        }\\n        int ans = 0;\\n        for(int i = 1 ; i <= n ; i++){\\n            int tempAns = i * solve(n - i , k + 1 , dp);\\n            ans = max(ans , tempAns);\\n        }\\n        return dp[n] = ans;\\n    }\\n    int integerBreak(int n) {\\n        int dp[n + 1];\\n        memset(dp , -1 , sizeof(dp));\\n        return solve(n , 0 , dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n , int k , int dp[]) {\\n        if(n < 0){\\n            return 0;\\n        }\\n        if(n == 0 && k >= 2){\\n            return 1;\\n        }\\n        if(dp[n] != -1){\\n            return dp[n];\\n        }\\n        int ans = 0;\\n        for(int i = 1 ; i <= n ; i++){\\n            int tempAns = i * solve(n - i , k + 1 , dp);\\n            ans = max(ans , tempAns);\\n        }\\n        return dp[n] = ans;\\n    }\\n    int integerBreak(int n) {\\n        int dp[n + 1];\\n        memset(dp , -1 , sizeof(dp));\\n        return solve(n , 0 , dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564544,
                "content": [
                    {
                        "username": "lixx2100",
                        "content": "I saw many solutions were referring to factors of 2 and 3. But why these two magic numbers? Why other factors do not work?\\nLet's study the math behind it.\\n\\nFor convenience, say **n** is sufficiently large and can be broken into any smaller real positive numbers. We now try to calculate which real number generates the largest product.\\nAssume we break **n** into **(n / x)**  **x**'s, then the product will be **x<sup>n/x</sup>**, and we want to maximize it.\\n\\nTaking its derivative gives us **n * x<sup>n/x-2</sup> * (1 - ln(x))**.\\nThe derivative is positive when **0 < x < e**, and equal to **0** when **x = e**, then becomes negative when **x > e**,\\nwhich indicates that the product increases as **x** increases, then reaches its maximum when **x = e**, then starts dropping.\\n\\nThis reveals the fact that if **n** is sufficiently large and we are allowed to break **n** into real numbers,\\nthe best idea is to break it into nearly all **e**'s.\\nOn the other hand, if **n** is sufficiently large and we can only break **n** into integers, we should choose integers that are closer to **e**.\\nThe only potential candidates are **2** and **3** since **2 < e < 3**, but we will generally prefer **3** to **2**. Why?\\n\\nOf course, one can prove it based on the formula above, but there is a more natural way shown as follows.\\n\\n**6 = 2 + 2 + 2 = 3 + 3**. But **2 * 2 * 2 < 3 * 3**.\\nTherefore, if there are three **2**'s in the decomposition, we can replace them by two **3**'s to gain a larger product.\\n\\nAll the analysis above assumes **n** is significantly large. When **n** is small (say **n <= 10**), it may contain flaws.\\nFor instance, when **n = 4**, we have **2 * 2 > 3 * 1**.\\nTo fix it, we keep breaking **n** into **3**'s until **n** gets smaller than **10**, then solve the problem by brute-force."
                    },
                    {
                        "username": "adrianliu0729",
                        "content": "Who else thinks this question is the worst one ?"
                    },
                    {
                        "username": "zflair_zpz",
                        "content": "if (n == 2 || n == 3) return (n-1);\\n   \\n   // Keep removing parts of size 3 while n is greater than 4\\n   int res = 1;\\n   while (n > 4)\\n   {\\n       n -= 3;\\n       res *= 3; // Keep multiplying 3 to res\\n   }\\n   return (n * res);"
                    },
                    {
                        "username": "jason177",
                        "content": "The stand answer is actually wrong. This is misleading.\\nFor example, take 60 as input, the maximum should be 3^20 = 3486784401. The standard answer gets a much smaller value."
                    },
                    {
                        "username": "Runtime__Terror_",
                        "content": "In question we are given constraints as n<=58. I guess 60 is overflowing"
                    },
                    {
                        "username": "Yogesh_Ghatode",
                        "content": "This happened due to overflow of integer value range."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "unbounded knapsack"
                    },
                    {
                        "username": "peida2015",
                        "content": "I use ruby.  LeetCode gives an expected answer of integer_break(100) = 2124471432.  I think this is clearly wrong because an obvious alternative 10**10 = 10,000,000,000 is greater than the expected answer."
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The idea is maximizing the number of \"3\", with the number of \"2\" should not be greater than 2 when breaking the input integer."
                    },
                    {
                        "username": "mukundsh",
                        "content": "This solution is beautifully explained for any integer by Alon Amit in this Quora Post\\nhttps://www.quora.com/Math-question-You-are-allowed-to-take-as-many-positive-whole-numbers-as-you-want-that-add-up-to-20-and-then-multiply-them-together-What-is-the-biggest-possible-result-you-can-get"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint 1</span>\nFor all x, y >1, product(x,y) ≥ sum(x,y)\n\n# <span style='color:green'>Hint 2</span>\nIt follows that it always makes sense to try to split the sum into the most components > 1 possible, as product > sum\n\n# <span style='color:green'>Hint 3</span>\n2 and 3 sum up to any number ≥ 2*, so it always makes sense to break it down into 2s and 3s. The optimal answer will be comprised of only 2s and 3s\n*(you can trivially prove this because 1 and 2 sum up to every number, and 3 is 2+1)"
                    },
                    {
                        "username": "Shivam_12_shivam",
                        "content": "can anyone tell why this is wrong \\n\\n\\nclass Solution {\\npublic:\\n\\n    int solve(int n,int pro,int sum,int o,vector<vector<int> > &dp){\\n        if(sum==o){\\n            return pro;  \\n        }\\n        if(sum>o || n==0){\\n            return 0;\\n        }\\n\\n        if(dp[n][sum]!=-1){\\n            return dp[n][sum];\\n        }\\n        int a1=0;\\n        int a3=0;\\n        if(sum+n<=o){\\n            a1=solve(n,pro*n,sum+n,o,dp);\\n        }\\n        a3=solve(n-1,pro,sum,o,dp);\\n        return dp[n][sum]=max(a1,a3);\\n\\n    }\\n    int integerBreak(int n) {\\n        vector<vector<int> > dp(n+1,vector<int>(n+1,-1));\\n        return solve(n-1,1,0,n,dp);\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1566784,
                "content": [
                    {
                        "username": "lixx2100",
                        "content": "I saw many solutions were referring to factors of 2 and 3. But why these two magic numbers? Why other factors do not work?\\nLet's study the math behind it.\\n\\nFor convenience, say **n** is sufficiently large and can be broken into any smaller real positive numbers. We now try to calculate which real number generates the largest product.\\nAssume we break **n** into **(n / x)**  **x**'s, then the product will be **x<sup>n/x</sup>**, and we want to maximize it.\\n\\nTaking its derivative gives us **n * x<sup>n/x-2</sup> * (1 - ln(x))**.\\nThe derivative is positive when **0 < x < e**, and equal to **0** when **x = e**, then becomes negative when **x > e**,\\nwhich indicates that the product increases as **x** increases, then reaches its maximum when **x = e**, then starts dropping.\\n\\nThis reveals the fact that if **n** is sufficiently large and we are allowed to break **n** into real numbers,\\nthe best idea is to break it into nearly all **e**'s.\\nOn the other hand, if **n** is sufficiently large and we can only break **n** into integers, we should choose integers that are closer to **e**.\\nThe only potential candidates are **2** and **3** since **2 < e < 3**, but we will generally prefer **3** to **2**. Why?\\n\\nOf course, one can prove it based on the formula above, but there is a more natural way shown as follows.\\n\\n**6 = 2 + 2 + 2 = 3 + 3**. But **2 * 2 * 2 < 3 * 3**.\\nTherefore, if there are three **2**'s in the decomposition, we can replace them by two **3**'s to gain a larger product.\\n\\nAll the analysis above assumes **n** is significantly large. When **n** is small (say **n <= 10**), it may contain flaws.\\nFor instance, when **n = 4**, we have **2 * 2 > 3 * 1**.\\nTo fix it, we keep breaking **n** into **3**'s until **n** gets smaller than **10**, then solve the problem by brute-force."
                    },
                    {
                        "username": "adrianliu0729",
                        "content": "Who else thinks this question is the worst one ?"
                    },
                    {
                        "username": "zflair_zpz",
                        "content": "if (n == 2 || n == 3) return (n-1);\\n   \\n   // Keep removing parts of size 3 while n is greater than 4\\n   int res = 1;\\n   while (n > 4)\\n   {\\n       n -= 3;\\n       res *= 3; // Keep multiplying 3 to res\\n   }\\n   return (n * res);"
                    },
                    {
                        "username": "jason177",
                        "content": "The stand answer is actually wrong. This is misleading.\\nFor example, take 60 as input, the maximum should be 3^20 = 3486784401. The standard answer gets a much smaller value."
                    },
                    {
                        "username": "Runtime__Terror_",
                        "content": "In question we are given constraints as n<=58. I guess 60 is overflowing"
                    },
                    {
                        "username": "Yogesh_Ghatode",
                        "content": "This happened due to overflow of integer value range."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "unbounded knapsack"
                    },
                    {
                        "username": "peida2015",
                        "content": "I use ruby.  LeetCode gives an expected answer of integer_break(100) = 2124471432.  I think this is clearly wrong because an obvious alternative 10**10 = 10,000,000,000 is greater than the expected answer."
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The idea is maximizing the number of \"3\", with the number of \"2\" should not be greater than 2 when breaking the input integer."
                    },
                    {
                        "username": "mukundsh",
                        "content": "This solution is beautifully explained for any integer by Alon Amit in this Quora Post\\nhttps://www.quora.com/Math-question-You-are-allowed-to-take-as-many-positive-whole-numbers-as-you-want-that-add-up-to-20-and-then-multiply-them-together-What-is-the-biggest-possible-result-you-can-get"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint 1</span>\nFor all x, y >1, product(x,y) ≥ sum(x,y)\n\n# <span style='color:green'>Hint 2</span>\nIt follows that it always makes sense to try to split the sum into the most components > 1 possible, as product > sum\n\n# <span style='color:green'>Hint 3</span>\n2 and 3 sum up to any number ≥ 2*, so it always makes sense to break it down into 2s and 3s. The optimal answer will be comprised of only 2s and 3s\n*(you can trivially prove this because 1 and 2 sum up to every number, and 3 is 2+1)"
                    },
                    {
                        "username": "Shivam_12_shivam",
                        "content": "can anyone tell why this is wrong \\n\\n\\nclass Solution {\\npublic:\\n\\n    int solve(int n,int pro,int sum,int o,vector<vector<int> > &dp){\\n        if(sum==o){\\n            return pro;  \\n        }\\n        if(sum>o || n==0){\\n            return 0;\\n        }\\n\\n        if(dp[n][sum]!=-1){\\n            return dp[n][sum];\\n        }\\n        int a1=0;\\n        int a3=0;\\n        if(sum+n<=o){\\n            a1=solve(n,pro*n,sum+n,o,dp);\\n        }\\n        a3=solve(n-1,pro,sum,o,dp);\\n        return dp[n][sum]=max(a1,a3);\\n\\n    }\\n    int integerBreak(int n) {\\n        vector<vector<int> > dp(n+1,vector<int>(n+1,-1));\\n        return solve(n-1,1,0,n,dp);\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1576642,
                "content": [
                    {
                        "username": "lixx2100",
                        "content": "I saw many solutions were referring to factors of 2 and 3. But why these two magic numbers? Why other factors do not work?\\nLet's study the math behind it.\\n\\nFor convenience, say **n** is sufficiently large and can be broken into any smaller real positive numbers. We now try to calculate which real number generates the largest product.\\nAssume we break **n** into **(n / x)**  **x**'s, then the product will be **x<sup>n/x</sup>**, and we want to maximize it.\\n\\nTaking its derivative gives us **n * x<sup>n/x-2</sup> * (1 - ln(x))**.\\nThe derivative is positive when **0 < x < e**, and equal to **0** when **x = e**, then becomes negative when **x > e**,\\nwhich indicates that the product increases as **x** increases, then reaches its maximum when **x = e**, then starts dropping.\\n\\nThis reveals the fact that if **n** is sufficiently large and we are allowed to break **n** into real numbers,\\nthe best idea is to break it into nearly all **e**'s.\\nOn the other hand, if **n** is sufficiently large and we can only break **n** into integers, we should choose integers that are closer to **e**.\\nThe only potential candidates are **2** and **3** since **2 < e < 3**, but we will generally prefer **3** to **2**. Why?\\n\\nOf course, one can prove it based on the formula above, but there is a more natural way shown as follows.\\n\\n**6 = 2 + 2 + 2 = 3 + 3**. But **2 * 2 * 2 < 3 * 3**.\\nTherefore, if there are three **2**'s in the decomposition, we can replace them by two **3**'s to gain a larger product.\\n\\nAll the analysis above assumes **n** is significantly large. When **n** is small (say **n <= 10**), it may contain flaws.\\nFor instance, when **n = 4**, we have **2 * 2 > 3 * 1**.\\nTo fix it, we keep breaking **n** into **3**'s until **n** gets smaller than **10**, then solve the problem by brute-force."
                    },
                    {
                        "username": "adrianliu0729",
                        "content": "Who else thinks this question is the worst one ?"
                    },
                    {
                        "username": "zflair_zpz",
                        "content": "if (n == 2 || n == 3) return (n-1);\\n   \\n   // Keep removing parts of size 3 while n is greater than 4\\n   int res = 1;\\n   while (n > 4)\\n   {\\n       n -= 3;\\n       res *= 3; // Keep multiplying 3 to res\\n   }\\n   return (n * res);"
                    },
                    {
                        "username": "jason177",
                        "content": "The stand answer is actually wrong. This is misleading.\\nFor example, take 60 as input, the maximum should be 3^20 = 3486784401. The standard answer gets a much smaller value."
                    },
                    {
                        "username": "Runtime__Terror_",
                        "content": "In question we are given constraints as n<=58. I guess 60 is overflowing"
                    },
                    {
                        "username": "Yogesh_Ghatode",
                        "content": "This happened due to overflow of integer value range."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "unbounded knapsack"
                    },
                    {
                        "username": "peida2015",
                        "content": "I use ruby.  LeetCode gives an expected answer of integer_break(100) = 2124471432.  I think this is clearly wrong because an obvious alternative 10**10 = 10,000,000,000 is greater than the expected answer."
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The idea is maximizing the number of \"3\", with the number of \"2\" should not be greater than 2 when breaking the input integer."
                    },
                    {
                        "username": "mukundsh",
                        "content": "This solution is beautifully explained for any integer by Alon Amit in this Quora Post\\nhttps://www.quora.com/Math-question-You-are-allowed-to-take-as-many-positive-whole-numbers-as-you-want-that-add-up-to-20-and-then-multiply-them-together-What-is-the-biggest-possible-result-you-can-get"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint 1</span>\nFor all x, y >1, product(x,y) ≥ sum(x,y)\n\n# <span style='color:green'>Hint 2</span>\nIt follows that it always makes sense to try to split the sum into the most components > 1 possible, as product > sum\n\n# <span style='color:green'>Hint 3</span>\n2 and 3 sum up to any number ≥ 2*, so it always makes sense to break it down into 2s and 3s. The optimal answer will be comprised of only 2s and 3s\n*(you can trivially prove this because 1 and 2 sum up to every number, and 3 is 2+1)"
                    },
                    {
                        "username": "Shivam_12_shivam",
                        "content": "can anyone tell why this is wrong \\n\\n\\nclass Solution {\\npublic:\\n\\n    int solve(int n,int pro,int sum,int o,vector<vector<int> > &dp){\\n        if(sum==o){\\n            return pro;  \\n        }\\n        if(sum>o || n==0){\\n            return 0;\\n        }\\n\\n        if(dp[n][sum]!=-1){\\n            return dp[n][sum];\\n        }\\n        int a1=0;\\n        int a3=0;\\n        if(sum+n<=o){\\n            a1=solve(n,pro*n,sum+n,o,dp);\\n        }\\n        a3=solve(n-1,pro,sum,o,dp);\\n        return dp[n][sum]=max(a1,a3);\\n\\n    }\\n    int integerBreak(int n) {\\n        vector<vector<int> > dp(n+1,vector<int>(n+1,-1));\\n        return solve(n-1,1,0,n,dp);\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1566783,
                "content": [
                    {
                        "username": "lixx2100",
                        "content": "I saw many solutions were referring to factors of 2 and 3. But why these two magic numbers? Why other factors do not work?\\nLet's study the math behind it.\\n\\nFor convenience, say **n** is sufficiently large and can be broken into any smaller real positive numbers. We now try to calculate which real number generates the largest product.\\nAssume we break **n** into **(n / x)**  **x**'s, then the product will be **x<sup>n/x</sup>**, and we want to maximize it.\\n\\nTaking its derivative gives us **n * x<sup>n/x-2</sup> * (1 - ln(x))**.\\nThe derivative is positive when **0 < x < e**, and equal to **0** when **x = e**, then becomes negative when **x > e**,\\nwhich indicates that the product increases as **x** increases, then reaches its maximum when **x = e**, then starts dropping.\\n\\nThis reveals the fact that if **n** is sufficiently large and we are allowed to break **n** into real numbers,\\nthe best idea is to break it into nearly all **e**'s.\\nOn the other hand, if **n** is sufficiently large and we can only break **n** into integers, we should choose integers that are closer to **e**.\\nThe only potential candidates are **2** and **3** since **2 < e < 3**, but we will generally prefer **3** to **2**. Why?\\n\\nOf course, one can prove it based on the formula above, but there is a more natural way shown as follows.\\n\\n**6 = 2 + 2 + 2 = 3 + 3**. But **2 * 2 * 2 < 3 * 3**.\\nTherefore, if there are three **2**'s in the decomposition, we can replace them by two **3**'s to gain a larger product.\\n\\nAll the analysis above assumes **n** is significantly large. When **n** is small (say **n <= 10**), it may contain flaws.\\nFor instance, when **n = 4**, we have **2 * 2 > 3 * 1**.\\nTo fix it, we keep breaking **n** into **3**'s until **n** gets smaller than **10**, then solve the problem by brute-force."
                    },
                    {
                        "username": "adrianliu0729",
                        "content": "Who else thinks this question is the worst one ?"
                    },
                    {
                        "username": "zflair_zpz",
                        "content": "if (n == 2 || n == 3) return (n-1);\\n   \\n   // Keep removing parts of size 3 while n is greater than 4\\n   int res = 1;\\n   while (n > 4)\\n   {\\n       n -= 3;\\n       res *= 3; // Keep multiplying 3 to res\\n   }\\n   return (n * res);"
                    },
                    {
                        "username": "jason177",
                        "content": "The stand answer is actually wrong. This is misleading.\\nFor example, take 60 as input, the maximum should be 3^20 = 3486784401. The standard answer gets a much smaller value."
                    },
                    {
                        "username": "Runtime__Terror_",
                        "content": "In question we are given constraints as n<=58. I guess 60 is overflowing"
                    },
                    {
                        "username": "Yogesh_Ghatode",
                        "content": "This happened due to overflow of integer value range."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "unbounded knapsack"
                    },
                    {
                        "username": "peida2015",
                        "content": "I use ruby.  LeetCode gives an expected answer of integer_break(100) = 2124471432.  I think this is clearly wrong because an obvious alternative 10**10 = 10,000,000,000 is greater than the expected answer."
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The idea is maximizing the number of \"3\", with the number of \"2\" should not be greater than 2 when breaking the input integer."
                    },
                    {
                        "username": "mukundsh",
                        "content": "This solution is beautifully explained for any integer by Alon Amit in this Quora Post\\nhttps://www.quora.com/Math-question-You-are-allowed-to-take-as-many-positive-whole-numbers-as-you-want-that-add-up-to-20-and-then-multiply-them-together-What-is-the-biggest-possible-result-you-can-get"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint 1</span>\nFor all x, y >1, product(x,y) ≥ sum(x,y)\n\n# <span style='color:green'>Hint 2</span>\nIt follows that it always makes sense to try to split the sum into the most components > 1 possible, as product > sum\n\n# <span style='color:green'>Hint 3</span>\n2 and 3 sum up to any number ≥ 2*, so it always makes sense to break it down into 2s and 3s. The optimal answer will be comprised of only 2s and 3s\n*(you can trivially prove this because 1 and 2 sum up to every number, and 3 is 2+1)"
                    },
                    {
                        "username": "Shivam_12_shivam",
                        "content": "can anyone tell why this is wrong \\n\\n\\nclass Solution {\\npublic:\\n\\n    int solve(int n,int pro,int sum,int o,vector<vector<int> > &dp){\\n        if(sum==o){\\n            return pro;  \\n        }\\n        if(sum>o || n==0){\\n            return 0;\\n        }\\n\\n        if(dp[n][sum]!=-1){\\n            return dp[n][sum];\\n        }\\n        int a1=0;\\n        int a3=0;\\n        if(sum+n<=o){\\n            a1=solve(n,pro*n,sum+n,o,dp);\\n        }\\n        a3=solve(n-1,pro,sum,o,dp);\\n        return dp[n][sum]=max(a1,a3);\\n\\n    }\\n    int integerBreak(int n) {\\n        vector<vector<int> > dp(n+1,vector<int>(n+1,-1));\\n        return solve(n-1,1,0,n,dp);\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1917560,
                "content": [
                    {
                        "username": "lixx2100",
                        "content": "I saw many solutions were referring to factors of 2 and 3. But why these two magic numbers? Why other factors do not work?\\nLet's study the math behind it.\\n\\nFor convenience, say **n** is sufficiently large and can be broken into any smaller real positive numbers. We now try to calculate which real number generates the largest product.\\nAssume we break **n** into **(n / x)**  **x**'s, then the product will be **x<sup>n/x</sup>**, and we want to maximize it.\\n\\nTaking its derivative gives us **n * x<sup>n/x-2</sup> * (1 - ln(x))**.\\nThe derivative is positive when **0 < x < e**, and equal to **0** when **x = e**, then becomes negative when **x > e**,\\nwhich indicates that the product increases as **x** increases, then reaches its maximum when **x = e**, then starts dropping.\\n\\nThis reveals the fact that if **n** is sufficiently large and we are allowed to break **n** into real numbers,\\nthe best idea is to break it into nearly all **e**'s.\\nOn the other hand, if **n** is sufficiently large and we can only break **n** into integers, we should choose integers that are closer to **e**.\\nThe only potential candidates are **2** and **3** since **2 < e < 3**, but we will generally prefer **3** to **2**. Why?\\n\\nOf course, one can prove it based on the formula above, but there is a more natural way shown as follows.\\n\\n**6 = 2 + 2 + 2 = 3 + 3**. But **2 * 2 * 2 < 3 * 3**.\\nTherefore, if there are three **2**'s in the decomposition, we can replace them by two **3**'s to gain a larger product.\\n\\nAll the analysis above assumes **n** is significantly large. When **n** is small (say **n <= 10**), it may contain flaws.\\nFor instance, when **n = 4**, we have **2 * 2 > 3 * 1**.\\nTo fix it, we keep breaking **n** into **3**'s until **n** gets smaller than **10**, then solve the problem by brute-force."
                    },
                    {
                        "username": "adrianliu0729",
                        "content": "Who else thinks this question is the worst one ?"
                    },
                    {
                        "username": "zflair_zpz",
                        "content": "if (n == 2 || n == 3) return (n-1);\\n   \\n   // Keep removing parts of size 3 while n is greater than 4\\n   int res = 1;\\n   while (n > 4)\\n   {\\n       n -= 3;\\n       res *= 3; // Keep multiplying 3 to res\\n   }\\n   return (n * res);"
                    },
                    {
                        "username": "jason177",
                        "content": "The stand answer is actually wrong. This is misleading.\\nFor example, take 60 as input, the maximum should be 3^20 = 3486784401. The standard answer gets a much smaller value."
                    },
                    {
                        "username": "Runtime__Terror_",
                        "content": "In question we are given constraints as n<=58. I guess 60 is overflowing"
                    },
                    {
                        "username": "Yogesh_Ghatode",
                        "content": "This happened due to overflow of integer value range."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "unbounded knapsack"
                    },
                    {
                        "username": "peida2015",
                        "content": "I use ruby.  LeetCode gives an expected answer of integer_break(100) = 2124471432.  I think this is clearly wrong because an obvious alternative 10**10 = 10,000,000,000 is greater than the expected answer."
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The idea is maximizing the number of \"3\", with the number of \"2\" should not be greater than 2 when breaking the input integer."
                    },
                    {
                        "username": "mukundsh",
                        "content": "This solution is beautifully explained for any integer by Alon Amit in this Quora Post\\nhttps://www.quora.com/Math-question-You-are-allowed-to-take-as-many-positive-whole-numbers-as-you-want-that-add-up-to-20-and-then-multiply-them-together-What-is-the-biggest-possible-result-you-can-get"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint 1</span>\nFor all x, y >1, product(x,y) ≥ sum(x,y)\n\n# <span style='color:green'>Hint 2</span>\nIt follows that it always makes sense to try to split the sum into the most components > 1 possible, as product > sum\n\n# <span style='color:green'>Hint 3</span>\n2 and 3 sum up to any number ≥ 2*, so it always makes sense to break it down into 2s and 3s. The optimal answer will be comprised of only 2s and 3s\n*(you can trivially prove this because 1 and 2 sum up to every number, and 3 is 2+1)"
                    },
                    {
                        "username": "Shivam_12_shivam",
                        "content": "can anyone tell why this is wrong \\n\\n\\nclass Solution {\\npublic:\\n\\n    int solve(int n,int pro,int sum,int o,vector<vector<int> > &dp){\\n        if(sum==o){\\n            return pro;  \\n        }\\n        if(sum>o || n==0){\\n            return 0;\\n        }\\n\\n        if(dp[n][sum]!=-1){\\n            return dp[n][sum];\\n        }\\n        int a1=0;\\n        int a3=0;\\n        if(sum+n<=o){\\n            a1=solve(n,pro*n,sum+n,o,dp);\\n        }\\n        a3=solve(n-1,pro,sum,o,dp);\\n        return dp[n][sum]=max(a1,a3);\\n\\n    }\\n    int integerBreak(int n) {\\n        vector<vector<int> > dp(n+1,vector<int>(n+1,-1));\\n        return solve(n-1,1,0,n,dp);\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1567253,
                "content": [
                    {
                        "username": "lixx2100",
                        "content": "I saw many solutions were referring to factors of 2 and 3. But why these two magic numbers? Why other factors do not work?\\nLet's study the math behind it.\\n\\nFor convenience, say **n** is sufficiently large and can be broken into any smaller real positive numbers. We now try to calculate which real number generates the largest product.\\nAssume we break **n** into **(n / x)**  **x**'s, then the product will be **x<sup>n/x</sup>**, and we want to maximize it.\\n\\nTaking its derivative gives us **n * x<sup>n/x-2</sup> * (1 - ln(x))**.\\nThe derivative is positive when **0 < x < e**, and equal to **0** when **x = e**, then becomes negative when **x > e**,\\nwhich indicates that the product increases as **x** increases, then reaches its maximum when **x = e**, then starts dropping.\\n\\nThis reveals the fact that if **n** is sufficiently large and we are allowed to break **n** into real numbers,\\nthe best idea is to break it into nearly all **e**'s.\\nOn the other hand, if **n** is sufficiently large and we can only break **n** into integers, we should choose integers that are closer to **e**.\\nThe only potential candidates are **2** and **3** since **2 < e < 3**, but we will generally prefer **3** to **2**. Why?\\n\\nOf course, one can prove it based on the formula above, but there is a more natural way shown as follows.\\n\\n**6 = 2 + 2 + 2 = 3 + 3**. But **2 * 2 * 2 < 3 * 3**.\\nTherefore, if there are three **2**'s in the decomposition, we can replace them by two **3**'s to gain a larger product.\\n\\nAll the analysis above assumes **n** is significantly large. When **n** is small (say **n <= 10**), it may contain flaws.\\nFor instance, when **n = 4**, we have **2 * 2 > 3 * 1**.\\nTo fix it, we keep breaking **n** into **3**'s until **n** gets smaller than **10**, then solve the problem by brute-force."
                    },
                    {
                        "username": "adrianliu0729",
                        "content": "Who else thinks this question is the worst one ?"
                    },
                    {
                        "username": "zflair_zpz",
                        "content": "if (n == 2 || n == 3) return (n-1);\\n   \\n   // Keep removing parts of size 3 while n is greater than 4\\n   int res = 1;\\n   while (n > 4)\\n   {\\n       n -= 3;\\n       res *= 3; // Keep multiplying 3 to res\\n   }\\n   return (n * res);"
                    },
                    {
                        "username": "jason177",
                        "content": "The stand answer is actually wrong. This is misleading.\\nFor example, take 60 as input, the maximum should be 3^20 = 3486784401. The standard answer gets a much smaller value."
                    },
                    {
                        "username": "Runtime__Terror_",
                        "content": "In question we are given constraints as n<=58. I guess 60 is overflowing"
                    },
                    {
                        "username": "Yogesh_Ghatode",
                        "content": "This happened due to overflow of integer value range."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "unbounded knapsack"
                    },
                    {
                        "username": "peida2015",
                        "content": "I use ruby.  LeetCode gives an expected answer of integer_break(100) = 2124471432.  I think this is clearly wrong because an obvious alternative 10**10 = 10,000,000,000 is greater than the expected answer."
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The idea is maximizing the number of \"3\", with the number of \"2\" should not be greater than 2 when breaking the input integer."
                    },
                    {
                        "username": "mukundsh",
                        "content": "This solution is beautifully explained for any integer by Alon Amit in this Quora Post\\nhttps://www.quora.com/Math-question-You-are-allowed-to-take-as-many-positive-whole-numbers-as-you-want-that-add-up-to-20-and-then-multiply-them-together-What-is-the-biggest-possible-result-you-can-get"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint 1</span>\nFor all x, y >1, product(x,y) ≥ sum(x,y)\n\n# <span style='color:green'>Hint 2</span>\nIt follows that it always makes sense to try to split the sum into the most components > 1 possible, as product > sum\n\n# <span style='color:green'>Hint 3</span>\n2 and 3 sum up to any number ≥ 2*, so it always makes sense to break it down into 2s and 3s. The optimal answer will be comprised of only 2s and 3s\n*(you can trivially prove this because 1 and 2 sum up to every number, and 3 is 2+1)"
                    },
                    {
                        "username": "Shivam_12_shivam",
                        "content": "can anyone tell why this is wrong \\n\\n\\nclass Solution {\\npublic:\\n\\n    int solve(int n,int pro,int sum,int o,vector<vector<int> > &dp){\\n        if(sum==o){\\n            return pro;  \\n        }\\n        if(sum>o || n==0){\\n            return 0;\\n        }\\n\\n        if(dp[n][sum]!=-1){\\n            return dp[n][sum];\\n        }\\n        int a1=0;\\n        int a3=0;\\n        if(sum+n<=o){\\n            a1=solve(n,pro*n,sum+n,o,dp);\\n        }\\n        a3=solve(n-1,pro,sum,o,dp);\\n        return dp[n][sum]=max(a1,a3);\\n\\n    }\\n    int integerBreak(int n) {\\n        vector<vector<int> > dp(n+1,vector<int>(n+1,-1));\\n        return solve(n-1,1,0,n,dp);\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1742609,
                "content": [
                    {
                        "username": "lixx2100",
                        "content": "I saw many solutions were referring to factors of 2 and 3. But why these two magic numbers? Why other factors do not work?\\nLet's study the math behind it.\\n\\nFor convenience, say **n** is sufficiently large and can be broken into any smaller real positive numbers. We now try to calculate which real number generates the largest product.\\nAssume we break **n** into **(n / x)**  **x**'s, then the product will be **x<sup>n/x</sup>**, and we want to maximize it.\\n\\nTaking its derivative gives us **n * x<sup>n/x-2</sup> * (1 - ln(x))**.\\nThe derivative is positive when **0 < x < e**, and equal to **0** when **x = e**, then becomes negative when **x > e**,\\nwhich indicates that the product increases as **x** increases, then reaches its maximum when **x = e**, then starts dropping.\\n\\nThis reveals the fact that if **n** is sufficiently large and we are allowed to break **n** into real numbers,\\nthe best idea is to break it into nearly all **e**'s.\\nOn the other hand, if **n** is sufficiently large and we can only break **n** into integers, we should choose integers that are closer to **e**.\\nThe only potential candidates are **2** and **3** since **2 < e < 3**, but we will generally prefer **3** to **2**. Why?\\n\\nOf course, one can prove it based on the formula above, but there is a more natural way shown as follows.\\n\\n**6 = 2 + 2 + 2 = 3 + 3**. But **2 * 2 * 2 < 3 * 3**.\\nTherefore, if there are three **2**'s in the decomposition, we can replace them by two **3**'s to gain a larger product.\\n\\nAll the analysis above assumes **n** is significantly large. When **n** is small (say **n <= 10**), it may contain flaws.\\nFor instance, when **n = 4**, we have **2 * 2 > 3 * 1**.\\nTo fix it, we keep breaking **n** into **3**'s until **n** gets smaller than **10**, then solve the problem by brute-force."
                    },
                    {
                        "username": "adrianliu0729",
                        "content": "Who else thinks this question is the worst one ?"
                    },
                    {
                        "username": "zflair_zpz",
                        "content": "if (n == 2 || n == 3) return (n-1);\\n   \\n   // Keep removing parts of size 3 while n is greater than 4\\n   int res = 1;\\n   while (n > 4)\\n   {\\n       n -= 3;\\n       res *= 3; // Keep multiplying 3 to res\\n   }\\n   return (n * res);"
                    },
                    {
                        "username": "jason177",
                        "content": "The stand answer is actually wrong. This is misleading.\\nFor example, take 60 as input, the maximum should be 3^20 = 3486784401. The standard answer gets a much smaller value."
                    },
                    {
                        "username": "Runtime__Terror_",
                        "content": "In question we are given constraints as n<=58. I guess 60 is overflowing"
                    },
                    {
                        "username": "Yogesh_Ghatode",
                        "content": "This happened due to overflow of integer value range."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "unbounded knapsack"
                    },
                    {
                        "username": "peida2015",
                        "content": "I use ruby.  LeetCode gives an expected answer of integer_break(100) = 2124471432.  I think this is clearly wrong because an obvious alternative 10**10 = 10,000,000,000 is greater than the expected answer."
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The idea is maximizing the number of \"3\", with the number of \"2\" should not be greater than 2 when breaking the input integer."
                    },
                    {
                        "username": "mukundsh",
                        "content": "This solution is beautifully explained for any integer by Alon Amit in this Quora Post\\nhttps://www.quora.com/Math-question-You-are-allowed-to-take-as-many-positive-whole-numbers-as-you-want-that-add-up-to-20-and-then-multiply-them-together-What-is-the-biggest-possible-result-you-can-get"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint 1</span>\nFor all x, y >1, product(x,y) ≥ sum(x,y)\n\n# <span style='color:green'>Hint 2</span>\nIt follows that it always makes sense to try to split the sum into the most components > 1 possible, as product > sum\n\n# <span style='color:green'>Hint 3</span>\n2 and 3 sum up to any number ≥ 2*, so it always makes sense to break it down into 2s and 3s. The optimal answer will be comprised of only 2s and 3s\n*(you can trivially prove this because 1 and 2 sum up to every number, and 3 is 2+1)"
                    },
                    {
                        "username": "Shivam_12_shivam",
                        "content": "can anyone tell why this is wrong \\n\\n\\nclass Solution {\\npublic:\\n\\n    int solve(int n,int pro,int sum,int o,vector<vector<int> > &dp){\\n        if(sum==o){\\n            return pro;  \\n        }\\n        if(sum>o || n==0){\\n            return 0;\\n        }\\n\\n        if(dp[n][sum]!=-1){\\n            return dp[n][sum];\\n        }\\n        int a1=0;\\n        int a3=0;\\n        if(sum+n<=o){\\n            a1=solve(n,pro*n,sum+n,o,dp);\\n        }\\n        a3=solve(n-1,pro,sum,o,dp);\\n        return dp[n][sum]=max(a1,a3);\\n\\n    }\\n    int integerBreak(int n) {\\n        vector<vector<int> > dp(n+1,vector<int>(n+1,-1));\\n        return solve(n-1,1,0,n,dp);\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1572802,
                "content": [
                    {
                        "username": "lixx2100",
                        "content": "I saw many solutions were referring to factors of 2 and 3. But why these two magic numbers? Why other factors do not work?\\nLet's study the math behind it.\\n\\nFor convenience, say **n** is sufficiently large and can be broken into any smaller real positive numbers. We now try to calculate which real number generates the largest product.\\nAssume we break **n** into **(n / x)**  **x**'s, then the product will be **x<sup>n/x</sup>**, and we want to maximize it.\\n\\nTaking its derivative gives us **n * x<sup>n/x-2</sup> * (1 - ln(x))**.\\nThe derivative is positive when **0 < x < e**, and equal to **0** when **x = e**, then becomes negative when **x > e**,\\nwhich indicates that the product increases as **x** increases, then reaches its maximum when **x = e**, then starts dropping.\\n\\nThis reveals the fact that if **n** is sufficiently large and we are allowed to break **n** into real numbers,\\nthe best idea is to break it into nearly all **e**'s.\\nOn the other hand, if **n** is sufficiently large and we can only break **n** into integers, we should choose integers that are closer to **e**.\\nThe only potential candidates are **2** and **3** since **2 < e < 3**, but we will generally prefer **3** to **2**. Why?\\n\\nOf course, one can prove it based on the formula above, but there is a more natural way shown as follows.\\n\\n**6 = 2 + 2 + 2 = 3 + 3**. But **2 * 2 * 2 < 3 * 3**.\\nTherefore, if there are three **2**'s in the decomposition, we can replace them by two **3**'s to gain a larger product.\\n\\nAll the analysis above assumes **n** is significantly large. When **n** is small (say **n <= 10**), it may contain flaws.\\nFor instance, when **n = 4**, we have **2 * 2 > 3 * 1**.\\nTo fix it, we keep breaking **n** into **3**'s until **n** gets smaller than **10**, then solve the problem by brute-force."
                    },
                    {
                        "username": "adrianliu0729",
                        "content": "Who else thinks this question is the worst one ?"
                    },
                    {
                        "username": "zflair_zpz",
                        "content": "if (n == 2 || n == 3) return (n-1);\\n   \\n   // Keep removing parts of size 3 while n is greater than 4\\n   int res = 1;\\n   while (n > 4)\\n   {\\n       n -= 3;\\n       res *= 3; // Keep multiplying 3 to res\\n   }\\n   return (n * res);"
                    },
                    {
                        "username": "jason177",
                        "content": "The stand answer is actually wrong. This is misleading.\\nFor example, take 60 as input, the maximum should be 3^20 = 3486784401. The standard answer gets a much smaller value."
                    },
                    {
                        "username": "Runtime__Terror_",
                        "content": "In question we are given constraints as n<=58. I guess 60 is overflowing"
                    },
                    {
                        "username": "Yogesh_Ghatode",
                        "content": "This happened due to overflow of integer value range."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "unbounded knapsack"
                    },
                    {
                        "username": "peida2015",
                        "content": "I use ruby.  LeetCode gives an expected answer of integer_break(100) = 2124471432.  I think this is clearly wrong because an obvious alternative 10**10 = 10,000,000,000 is greater than the expected answer."
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The idea is maximizing the number of \"3\", with the number of \"2\" should not be greater than 2 when breaking the input integer."
                    },
                    {
                        "username": "mukundsh",
                        "content": "This solution is beautifully explained for any integer by Alon Amit in this Quora Post\\nhttps://www.quora.com/Math-question-You-are-allowed-to-take-as-many-positive-whole-numbers-as-you-want-that-add-up-to-20-and-then-multiply-them-together-What-is-the-biggest-possible-result-you-can-get"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint 1</span>\nFor all x, y >1, product(x,y) ≥ sum(x,y)\n\n# <span style='color:green'>Hint 2</span>\nIt follows that it always makes sense to try to split the sum into the most components > 1 possible, as product > sum\n\n# <span style='color:green'>Hint 3</span>\n2 and 3 sum up to any number ≥ 2*, so it always makes sense to break it down into 2s and 3s. The optimal answer will be comprised of only 2s and 3s\n*(you can trivially prove this because 1 and 2 sum up to every number, and 3 is 2+1)"
                    },
                    {
                        "username": "Shivam_12_shivam",
                        "content": "can anyone tell why this is wrong \\n\\n\\nclass Solution {\\npublic:\\n\\n    int solve(int n,int pro,int sum,int o,vector<vector<int> > &dp){\\n        if(sum==o){\\n            return pro;  \\n        }\\n        if(sum>o || n==0){\\n            return 0;\\n        }\\n\\n        if(dp[n][sum]!=-1){\\n            return dp[n][sum];\\n        }\\n        int a1=0;\\n        int a3=0;\\n        if(sum+n<=o){\\n            a1=solve(n,pro*n,sum+n,o,dp);\\n        }\\n        a3=solve(n-1,pro,sum,o,dp);\\n        return dp[n][sum]=max(a1,a3);\\n\\n    }\\n    int integerBreak(int n) {\\n        vector<vector<int> > dp(n+1,vector<int>(n+1,-1));\\n        return solve(n-1,1,0,n,dp);\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1803012,
                "content": [
                    {
                        "username": "lixx2100",
                        "content": "I saw many solutions were referring to factors of 2 and 3. But why these two magic numbers? Why other factors do not work?\\nLet's study the math behind it.\\n\\nFor convenience, say **n** is sufficiently large and can be broken into any smaller real positive numbers. We now try to calculate which real number generates the largest product.\\nAssume we break **n** into **(n / x)**  **x**'s, then the product will be **x<sup>n/x</sup>**, and we want to maximize it.\\n\\nTaking its derivative gives us **n * x<sup>n/x-2</sup> * (1 - ln(x))**.\\nThe derivative is positive when **0 < x < e**, and equal to **0** when **x = e**, then becomes negative when **x > e**,\\nwhich indicates that the product increases as **x** increases, then reaches its maximum when **x = e**, then starts dropping.\\n\\nThis reveals the fact that if **n** is sufficiently large and we are allowed to break **n** into real numbers,\\nthe best idea is to break it into nearly all **e**'s.\\nOn the other hand, if **n** is sufficiently large and we can only break **n** into integers, we should choose integers that are closer to **e**.\\nThe only potential candidates are **2** and **3** since **2 < e < 3**, but we will generally prefer **3** to **2**. Why?\\n\\nOf course, one can prove it based on the formula above, but there is a more natural way shown as follows.\\n\\n**6 = 2 + 2 + 2 = 3 + 3**. But **2 * 2 * 2 < 3 * 3**.\\nTherefore, if there are three **2**'s in the decomposition, we can replace them by two **3**'s to gain a larger product.\\n\\nAll the analysis above assumes **n** is significantly large. When **n** is small (say **n <= 10**), it may contain flaws.\\nFor instance, when **n = 4**, we have **2 * 2 > 3 * 1**.\\nTo fix it, we keep breaking **n** into **3**'s until **n** gets smaller than **10**, then solve the problem by brute-force."
                    },
                    {
                        "username": "adrianliu0729",
                        "content": "Who else thinks this question is the worst one ?"
                    },
                    {
                        "username": "zflair_zpz",
                        "content": "if (n == 2 || n == 3) return (n-1);\\n   \\n   // Keep removing parts of size 3 while n is greater than 4\\n   int res = 1;\\n   while (n > 4)\\n   {\\n       n -= 3;\\n       res *= 3; // Keep multiplying 3 to res\\n   }\\n   return (n * res);"
                    },
                    {
                        "username": "jason177",
                        "content": "The stand answer is actually wrong. This is misleading.\\nFor example, take 60 as input, the maximum should be 3^20 = 3486784401. The standard answer gets a much smaller value."
                    },
                    {
                        "username": "Runtime__Terror_",
                        "content": "In question we are given constraints as n<=58. I guess 60 is overflowing"
                    },
                    {
                        "username": "Yogesh_Ghatode",
                        "content": "This happened due to overflow of integer value range."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "unbounded knapsack"
                    },
                    {
                        "username": "peida2015",
                        "content": "I use ruby.  LeetCode gives an expected answer of integer_break(100) = 2124471432.  I think this is clearly wrong because an obvious alternative 10**10 = 10,000,000,000 is greater than the expected answer."
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The idea is maximizing the number of \"3\", with the number of \"2\" should not be greater than 2 when breaking the input integer."
                    },
                    {
                        "username": "mukundsh",
                        "content": "This solution is beautifully explained for any integer by Alon Amit in this Quora Post\\nhttps://www.quora.com/Math-question-You-are-allowed-to-take-as-many-positive-whole-numbers-as-you-want-that-add-up-to-20-and-then-multiply-them-together-What-is-the-biggest-possible-result-you-can-get"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint 1</span>\nFor all x, y >1, product(x,y) ≥ sum(x,y)\n\n# <span style='color:green'>Hint 2</span>\nIt follows that it always makes sense to try to split the sum into the most components > 1 possible, as product > sum\n\n# <span style='color:green'>Hint 3</span>\n2 and 3 sum up to any number ≥ 2*, so it always makes sense to break it down into 2s and 3s. The optimal answer will be comprised of only 2s and 3s\n*(you can trivially prove this because 1 and 2 sum up to every number, and 3 is 2+1)"
                    },
                    {
                        "username": "Shivam_12_shivam",
                        "content": "can anyone tell why this is wrong \\n\\n\\nclass Solution {\\npublic:\\n\\n    int solve(int n,int pro,int sum,int o,vector<vector<int> > &dp){\\n        if(sum==o){\\n            return pro;  \\n        }\\n        if(sum>o || n==0){\\n            return 0;\\n        }\\n\\n        if(dp[n][sum]!=-1){\\n            return dp[n][sum];\\n        }\\n        int a1=0;\\n        int a3=0;\\n        if(sum+n<=o){\\n            a1=solve(n,pro*n,sum+n,o,dp);\\n        }\\n        a3=solve(n-1,pro,sum,o,dp);\\n        return dp[n][sum]=max(a1,a3);\\n\\n    }\\n    int integerBreak(int n) {\\n        vector<vector<int> > dp(n+1,vector<int>(n+1,-1));\\n        return solve(n-1,1,0,n,dp);\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 2000055,
                "content": [
                    {
                        "username": "lixx2100",
                        "content": "I saw many solutions were referring to factors of 2 and 3. But why these two magic numbers? Why other factors do not work?\\nLet's study the math behind it.\\n\\nFor convenience, say **n** is sufficiently large and can be broken into any smaller real positive numbers. We now try to calculate which real number generates the largest product.\\nAssume we break **n** into **(n / x)**  **x**'s, then the product will be **x<sup>n/x</sup>**, and we want to maximize it.\\n\\nTaking its derivative gives us **n * x<sup>n/x-2</sup> * (1 - ln(x))**.\\nThe derivative is positive when **0 < x < e**, and equal to **0** when **x = e**, then becomes negative when **x > e**,\\nwhich indicates that the product increases as **x** increases, then reaches its maximum when **x = e**, then starts dropping.\\n\\nThis reveals the fact that if **n** is sufficiently large and we are allowed to break **n** into real numbers,\\nthe best idea is to break it into nearly all **e**'s.\\nOn the other hand, if **n** is sufficiently large and we can only break **n** into integers, we should choose integers that are closer to **e**.\\nThe only potential candidates are **2** and **3** since **2 < e < 3**, but we will generally prefer **3** to **2**. Why?\\n\\nOf course, one can prove it based on the formula above, but there is a more natural way shown as follows.\\n\\n**6 = 2 + 2 + 2 = 3 + 3**. But **2 * 2 * 2 < 3 * 3**.\\nTherefore, if there are three **2**'s in the decomposition, we can replace them by two **3**'s to gain a larger product.\\n\\nAll the analysis above assumes **n** is significantly large. When **n** is small (say **n <= 10**), it may contain flaws.\\nFor instance, when **n = 4**, we have **2 * 2 > 3 * 1**.\\nTo fix it, we keep breaking **n** into **3**'s until **n** gets smaller than **10**, then solve the problem by brute-force."
                    },
                    {
                        "username": "adrianliu0729",
                        "content": "Who else thinks this question is the worst one ?"
                    },
                    {
                        "username": "zflair_zpz",
                        "content": "if (n == 2 || n == 3) return (n-1);\\n   \\n   // Keep removing parts of size 3 while n is greater than 4\\n   int res = 1;\\n   while (n > 4)\\n   {\\n       n -= 3;\\n       res *= 3; // Keep multiplying 3 to res\\n   }\\n   return (n * res);"
                    },
                    {
                        "username": "jason177",
                        "content": "The stand answer is actually wrong. This is misleading.\\nFor example, take 60 as input, the maximum should be 3^20 = 3486784401. The standard answer gets a much smaller value."
                    },
                    {
                        "username": "Runtime__Terror_",
                        "content": "In question we are given constraints as n<=58. I guess 60 is overflowing"
                    },
                    {
                        "username": "Yogesh_Ghatode",
                        "content": "This happened due to overflow of integer value range."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "unbounded knapsack"
                    },
                    {
                        "username": "peida2015",
                        "content": "I use ruby.  LeetCode gives an expected answer of integer_break(100) = 2124471432.  I think this is clearly wrong because an obvious alternative 10**10 = 10,000,000,000 is greater than the expected answer."
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The idea is maximizing the number of \"3\", with the number of \"2\" should not be greater than 2 when breaking the input integer."
                    },
                    {
                        "username": "mukundsh",
                        "content": "This solution is beautifully explained for any integer by Alon Amit in this Quora Post\\nhttps://www.quora.com/Math-question-You-are-allowed-to-take-as-many-positive-whole-numbers-as-you-want-that-add-up-to-20-and-then-multiply-them-together-What-is-the-biggest-possible-result-you-can-get"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint 1</span>\nFor all x, y >1, product(x,y) ≥ sum(x,y)\n\n# <span style='color:green'>Hint 2</span>\nIt follows that it always makes sense to try to split the sum into the most components > 1 possible, as product > sum\n\n# <span style='color:green'>Hint 3</span>\n2 and 3 sum up to any number ≥ 2*, so it always makes sense to break it down into 2s and 3s. The optimal answer will be comprised of only 2s and 3s\n*(you can trivially prove this because 1 and 2 sum up to every number, and 3 is 2+1)"
                    },
                    {
                        "username": "Shivam_12_shivam",
                        "content": "can anyone tell why this is wrong \\n\\n\\nclass Solution {\\npublic:\\n\\n    int solve(int n,int pro,int sum,int o,vector<vector<int> > &dp){\\n        if(sum==o){\\n            return pro;  \\n        }\\n        if(sum>o || n==0){\\n            return 0;\\n        }\\n\\n        if(dp[n][sum]!=-1){\\n            return dp[n][sum];\\n        }\\n        int a1=0;\\n        int a3=0;\\n        if(sum+n<=o){\\n            a1=solve(n,pro*n,sum+n,o,dp);\\n        }\\n        a3=solve(n-1,pro,sum,o,dp);\\n        return dp[n][sum]=max(a1,a3);\\n\\n    }\\n    int integerBreak(int n) {\\n        vector<vector<int> > dp(n+1,vector<int>(n+1,-1));\\n        return solve(n-1,1,0,n,dp);\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1564544,
                "content": [
                    {
                        "username": "lixx2100",
                        "content": "I saw many solutions were referring to factors of 2 and 3. But why these two magic numbers? Why other factors do not work?\\nLet's study the math behind it.\\n\\nFor convenience, say **n** is sufficiently large and can be broken into any smaller real positive numbers. We now try to calculate which real number generates the largest product.\\nAssume we break **n** into **(n / x)**  **x**'s, then the product will be **x<sup>n/x</sup>**, and we want to maximize it.\\n\\nTaking its derivative gives us **n * x<sup>n/x-2</sup> * (1 - ln(x))**.\\nThe derivative is positive when **0 < x < e**, and equal to **0** when **x = e**, then becomes negative when **x > e**,\\nwhich indicates that the product increases as **x** increases, then reaches its maximum when **x = e**, then starts dropping.\\n\\nThis reveals the fact that if **n** is sufficiently large and we are allowed to break **n** into real numbers,\\nthe best idea is to break it into nearly all **e**'s.\\nOn the other hand, if **n** is sufficiently large and we can only break **n** into integers, we should choose integers that are closer to **e**.\\nThe only potential candidates are **2** and **3** since **2 < e < 3**, but we will generally prefer **3** to **2**. Why?\\n\\nOf course, one can prove it based on the formula above, but there is a more natural way shown as follows.\\n\\n**6 = 2 + 2 + 2 = 3 + 3**. But **2 * 2 * 2 < 3 * 3**.\\nTherefore, if there are three **2**'s in the decomposition, we can replace them by two **3**'s to gain a larger product.\\n\\nAll the analysis above assumes **n** is significantly large. When **n** is small (say **n <= 10**), it may contain flaws.\\nFor instance, when **n = 4**, we have **2 * 2 > 3 * 1**.\\nTo fix it, we keep breaking **n** into **3**'s until **n** gets smaller than **10**, then solve the problem by brute-force."
                    },
                    {
                        "username": "adrianliu0729",
                        "content": "Who else thinks this question is the worst one ?"
                    },
                    {
                        "username": "zflair_zpz",
                        "content": "if (n == 2 || n == 3) return (n-1);\\n   \\n   // Keep removing parts of size 3 while n is greater than 4\\n   int res = 1;\\n   while (n > 4)\\n   {\\n       n -= 3;\\n       res *= 3; // Keep multiplying 3 to res\\n   }\\n   return (n * res);"
                    },
                    {
                        "username": "jason177",
                        "content": "The stand answer is actually wrong. This is misleading.\\nFor example, take 60 as input, the maximum should be 3^20 = 3486784401. The standard answer gets a much smaller value."
                    },
                    {
                        "username": "Runtime__Terror_",
                        "content": "In question we are given constraints as n<=58. I guess 60 is overflowing"
                    },
                    {
                        "username": "Yogesh_Ghatode",
                        "content": "This happened due to overflow of integer value range."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "unbounded knapsack"
                    },
                    {
                        "username": "peida2015",
                        "content": "I use ruby.  LeetCode gives an expected answer of integer_break(100) = 2124471432.  I think this is clearly wrong because an obvious alternative 10**10 = 10,000,000,000 is greater than the expected answer."
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The idea is maximizing the number of \"3\", with the number of \"2\" should not be greater than 2 when breaking the input integer."
                    },
                    {
                        "username": "mukundsh",
                        "content": "This solution is beautifully explained for any integer by Alon Amit in this Quora Post\\nhttps://www.quora.com/Math-question-You-are-allowed-to-take-as-many-positive-whole-numbers-as-you-want-that-add-up-to-20-and-then-multiply-them-together-What-is-the-biggest-possible-result-you-can-get"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint 1</span>\nFor all x, y >1, product(x,y) ≥ sum(x,y)\n\n# <span style='color:green'>Hint 2</span>\nIt follows that it always makes sense to try to split the sum into the most components > 1 possible, as product > sum\n\n# <span style='color:green'>Hint 3</span>\n2 and 3 sum up to any number ≥ 2*, so it always makes sense to break it down into 2s and 3s. The optimal answer will be comprised of only 2s and 3s\n*(you can trivially prove this because 1 and 2 sum up to every number, and 3 is 2+1)"
                    },
                    {
                        "username": "Shivam_12_shivam",
                        "content": "can anyone tell why this is wrong \\n\\n\\nclass Solution {\\npublic:\\n\\n    int solve(int n,int pro,int sum,int o,vector<vector<int> > &dp){\\n        if(sum==o){\\n            return pro;  \\n        }\\n        if(sum>o || n==0){\\n            return 0;\\n        }\\n\\n        if(dp[n][sum]!=-1){\\n            return dp[n][sum];\\n        }\\n        int a1=0;\\n        int a3=0;\\n        if(sum+n<=o){\\n            a1=solve(n,pro*n,sum+n,o,dp);\\n        }\\n        a3=solve(n-1,pro,sum,o,dp);\\n        return dp[n][sum]=max(a1,a3);\\n\\n    }\\n    int integerBreak(int n) {\\n        vector<vector<int> > dp(n+1,vector<int>(n+1,-1));\\n        return solve(n-1,1,0,n,dp);\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1566784,
                "content": [
                    {
                        "username": "lixx2100",
                        "content": "I saw many solutions were referring to factors of 2 and 3. But why these two magic numbers? Why other factors do not work?\\nLet's study the math behind it.\\n\\nFor convenience, say **n** is sufficiently large and can be broken into any smaller real positive numbers. We now try to calculate which real number generates the largest product.\\nAssume we break **n** into **(n / x)**  **x**'s, then the product will be **x<sup>n/x</sup>**, and we want to maximize it.\\n\\nTaking its derivative gives us **n * x<sup>n/x-2</sup> * (1 - ln(x))**.\\nThe derivative is positive when **0 < x < e**, and equal to **0** when **x = e**, then becomes negative when **x > e**,\\nwhich indicates that the product increases as **x** increases, then reaches its maximum when **x = e**, then starts dropping.\\n\\nThis reveals the fact that if **n** is sufficiently large and we are allowed to break **n** into real numbers,\\nthe best idea is to break it into nearly all **e**'s.\\nOn the other hand, if **n** is sufficiently large and we can only break **n** into integers, we should choose integers that are closer to **e**.\\nThe only potential candidates are **2** and **3** since **2 < e < 3**, but we will generally prefer **3** to **2**. Why?\\n\\nOf course, one can prove it based on the formula above, but there is a more natural way shown as follows.\\n\\n**6 = 2 + 2 + 2 = 3 + 3**. But **2 * 2 * 2 < 3 * 3**.\\nTherefore, if there are three **2**'s in the decomposition, we can replace them by two **3**'s to gain a larger product.\\n\\nAll the analysis above assumes **n** is significantly large. When **n** is small (say **n <= 10**), it may contain flaws.\\nFor instance, when **n = 4**, we have **2 * 2 > 3 * 1**.\\nTo fix it, we keep breaking **n** into **3**'s until **n** gets smaller than **10**, then solve the problem by brute-force."
                    },
                    {
                        "username": "adrianliu0729",
                        "content": "Who else thinks this question is the worst one ?"
                    },
                    {
                        "username": "zflair_zpz",
                        "content": "if (n == 2 || n == 3) return (n-1);\\n   \\n   // Keep removing parts of size 3 while n is greater than 4\\n   int res = 1;\\n   while (n > 4)\\n   {\\n       n -= 3;\\n       res *= 3; // Keep multiplying 3 to res\\n   }\\n   return (n * res);"
                    },
                    {
                        "username": "jason177",
                        "content": "The stand answer is actually wrong. This is misleading.\\nFor example, take 60 as input, the maximum should be 3^20 = 3486784401. The standard answer gets a much smaller value."
                    },
                    {
                        "username": "Runtime__Terror_",
                        "content": "In question we are given constraints as n<=58. I guess 60 is overflowing"
                    },
                    {
                        "username": "Yogesh_Ghatode",
                        "content": "This happened due to overflow of integer value range."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "unbounded knapsack"
                    },
                    {
                        "username": "peida2015",
                        "content": "I use ruby.  LeetCode gives an expected answer of integer_break(100) = 2124471432.  I think this is clearly wrong because an obvious alternative 10**10 = 10,000,000,000 is greater than the expected answer."
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The idea is maximizing the number of \"3\", with the number of \"2\" should not be greater than 2 when breaking the input integer."
                    },
                    {
                        "username": "mukundsh",
                        "content": "This solution is beautifully explained for any integer by Alon Amit in this Quora Post\\nhttps://www.quora.com/Math-question-You-are-allowed-to-take-as-many-positive-whole-numbers-as-you-want-that-add-up-to-20-and-then-multiply-them-together-What-is-the-biggest-possible-result-you-can-get"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint 1</span>\nFor all x, y >1, product(x,y) ≥ sum(x,y)\n\n# <span style='color:green'>Hint 2</span>\nIt follows that it always makes sense to try to split the sum into the most components > 1 possible, as product > sum\n\n# <span style='color:green'>Hint 3</span>\n2 and 3 sum up to any number ≥ 2*, so it always makes sense to break it down into 2s and 3s. The optimal answer will be comprised of only 2s and 3s\n*(you can trivially prove this because 1 and 2 sum up to every number, and 3 is 2+1)"
                    },
                    {
                        "username": "Shivam_12_shivam",
                        "content": "can anyone tell why this is wrong \\n\\n\\nclass Solution {\\npublic:\\n\\n    int solve(int n,int pro,int sum,int o,vector<vector<int> > &dp){\\n        if(sum==o){\\n            return pro;  \\n        }\\n        if(sum>o || n==0){\\n            return 0;\\n        }\\n\\n        if(dp[n][sum]!=-1){\\n            return dp[n][sum];\\n        }\\n        int a1=0;\\n        int a3=0;\\n        if(sum+n<=o){\\n            a1=solve(n,pro*n,sum+n,o,dp);\\n        }\\n        a3=solve(n-1,pro,sum,o,dp);\\n        return dp[n][sum]=max(a1,a3);\\n\\n    }\\n    int integerBreak(int n) {\\n        vector<vector<int> > dp(n+1,vector<int>(n+1,-1));\\n        return solve(n-1,1,0,n,dp);\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1576642,
                "content": [
                    {
                        "username": "lixx2100",
                        "content": "I saw many solutions were referring to factors of 2 and 3. But why these two magic numbers? Why other factors do not work?\\nLet's study the math behind it.\\n\\nFor convenience, say **n** is sufficiently large and can be broken into any smaller real positive numbers. We now try to calculate which real number generates the largest product.\\nAssume we break **n** into **(n / x)**  **x**'s, then the product will be **x<sup>n/x</sup>**, and we want to maximize it.\\n\\nTaking its derivative gives us **n * x<sup>n/x-2</sup> * (1 - ln(x))**.\\nThe derivative is positive when **0 < x < e**, and equal to **0** when **x = e**, then becomes negative when **x > e**,\\nwhich indicates that the product increases as **x** increases, then reaches its maximum when **x = e**, then starts dropping.\\n\\nThis reveals the fact that if **n** is sufficiently large and we are allowed to break **n** into real numbers,\\nthe best idea is to break it into nearly all **e**'s.\\nOn the other hand, if **n** is sufficiently large and we can only break **n** into integers, we should choose integers that are closer to **e**.\\nThe only potential candidates are **2** and **3** since **2 < e < 3**, but we will generally prefer **3** to **2**. Why?\\n\\nOf course, one can prove it based on the formula above, but there is a more natural way shown as follows.\\n\\n**6 = 2 + 2 + 2 = 3 + 3**. But **2 * 2 * 2 < 3 * 3**.\\nTherefore, if there are three **2**'s in the decomposition, we can replace them by two **3**'s to gain a larger product.\\n\\nAll the analysis above assumes **n** is significantly large. When **n** is small (say **n <= 10**), it may contain flaws.\\nFor instance, when **n = 4**, we have **2 * 2 > 3 * 1**.\\nTo fix it, we keep breaking **n** into **3**'s until **n** gets smaller than **10**, then solve the problem by brute-force."
                    },
                    {
                        "username": "adrianliu0729",
                        "content": "Who else thinks this question is the worst one ?"
                    },
                    {
                        "username": "zflair_zpz",
                        "content": "if (n == 2 || n == 3) return (n-1);\\n   \\n   // Keep removing parts of size 3 while n is greater than 4\\n   int res = 1;\\n   while (n > 4)\\n   {\\n       n -= 3;\\n       res *= 3; // Keep multiplying 3 to res\\n   }\\n   return (n * res);"
                    },
                    {
                        "username": "jason177",
                        "content": "The stand answer is actually wrong. This is misleading.\\nFor example, take 60 as input, the maximum should be 3^20 = 3486784401. The standard answer gets a much smaller value."
                    },
                    {
                        "username": "Runtime__Terror_",
                        "content": "In question we are given constraints as n<=58. I guess 60 is overflowing"
                    },
                    {
                        "username": "Yogesh_Ghatode",
                        "content": "This happened due to overflow of integer value range."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "unbounded knapsack"
                    },
                    {
                        "username": "peida2015",
                        "content": "I use ruby.  LeetCode gives an expected answer of integer_break(100) = 2124471432.  I think this is clearly wrong because an obvious alternative 10**10 = 10,000,000,000 is greater than the expected answer."
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The idea is maximizing the number of \"3\", with the number of \"2\" should not be greater than 2 when breaking the input integer."
                    },
                    {
                        "username": "mukundsh",
                        "content": "This solution is beautifully explained for any integer by Alon Amit in this Quora Post\\nhttps://www.quora.com/Math-question-You-are-allowed-to-take-as-many-positive-whole-numbers-as-you-want-that-add-up-to-20-and-then-multiply-them-together-What-is-the-biggest-possible-result-you-can-get"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint 1</span>\nFor all x, y >1, product(x,y) ≥ sum(x,y)\n\n# <span style='color:green'>Hint 2</span>\nIt follows that it always makes sense to try to split the sum into the most components > 1 possible, as product > sum\n\n# <span style='color:green'>Hint 3</span>\n2 and 3 sum up to any number ≥ 2*, so it always makes sense to break it down into 2s and 3s. The optimal answer will be comprised of only 2s and 3s\n*(you can trivially prove this because 1 and 2 sum up to every number, and 3 is 2+1)"
                    },
                    {
                        "username": "Shivam_12_shivam",
                        "content": "can anyone tell why this is wrong \\n\\n\\nclass Solution {\\npublic:\\n\\n    int solve(int n,int pro,int sum,int o,vector<vector<int> > &dp){\\n        if(sum==o){\\n            return pro;  \\n        }\\n        if(sum>o || n==0){\\n            return 0;\\n        }\\n\\n        if(dp[n][sum]!=-1){\\n            return dp[n][sum];\\n        }\\n        int a1=0;\\n        int a3=0;\\n        if(sum+n<=o){\\n            a1=solve(n,pro*n,sum+n,o,dp);\\n        }\\n        a3=solve(n-1,pro,sum,o,dp);\\n        return dp[n][sum]=max(a1,a3);\\n\\n    }\\n    int integerBreak(int n) {\\n        vector<vector<int> > dp(n+1,vector<int>(n+1,-1));\\n        return solve(n-1,1,0,n,dp);\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1566783,
                "content": [
                    {
                        "username": "lixx2100",
                        "content": "I saw many solutions were referring to factors of 2 and 3. But why these two magic numbers? Why other factors do not work?\\nLet's study the math behind it.\\n\\nFor convenience, say **n** is sufficiently large and can be broken into any smaller real positive numbers. We now try to calculate which real number generates the largest product.\\nAssume we break **n** into **(n / x)**  **x**'s, then the product will be **x<sup>n/x</sup>**, and we want to maximize it.\\n\\nTaking its derivative gives us **n * x<sup>n/x-2</sup> * (1 - ln(x))**.\\nThe derivative is positive when **0 < x < e**, and equal to **0** when **x = e**, then becomes negative when **x > e**,\\nwhich indicates that the product increases as **x** increases, then reaches its maximum when **x = e**, then starts dropping.\\n\\nThis reveals the fact that if **n** is sufficiently large and we are allowed to break **n** into real numbers,\\nthe best idea is to break it into nearly all **e**'s.\\nOn the other hand, if **n** is sufficiently large and we can only break **n** into integers, we should choose integers that are closer to **e**.\\nThe only potential candidates are **2** and **3** since **2 < e < 3**, but we will generally prefer **3** to **2**. Why?\\n\\nOf course, one can prove it based on the formula above, but there is a more natural way shown as follows.\\n\\n**6 = 2 + 2 + 2 = 3 + 3**. But **2 * 2 * 2 < 3 * 3**.\\nTherefore, if there are three **2**'s in the decomposition, we can replace them by two **3**'s to gain a larger product.\\n\\nAll the analysis above assumes **n** is significantly large. When **n** is small (say **n <= 10**), it may contain flaws.\\nFor instance, when **n = 4**, we have **2 * 2 > 3 * 1**.\\nTo fix it, we keep breaking **n** into **3**'s until **n** gets smaller than **10**, then solve the problem by brute-force."
                    },
                    {
                        "username": "adrianliu0729",
                        "content": "Who else thinks this question is the worst one ?"
                    },
                    {
                        "username": "zflair_zpz",
                        "content": "if (n == 2 || n == 3) return (n-1);\\n   \\n   // Keep removing parts of size 3 while n is greater than 4\\n   int res = 1;\\n   while (n > 4)\\n   {\\n       n -= 3;\\n       res *= 3; // Keep multiplying 3 to res\\n   }\\n   return (n * res);"
                    },
                    {
                        "username": "jason177",
                        "content": "The stand answer is actually wrong. This is misleading.\\nFor example, take 60 as input, the maximum should be 3^20 = 3486784401. The standard answer gets a much smaller value."
                    },
                    {
                        "username": "Runtime__Terror_",
                        "content": "In question we are given constraints as n<=58. I guess 60 is overflowing"
                    },
                    {
                        "username": "Yogesh_Ghatode",
                        "content": "This happened due to overflow of integer value range."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "unbounded knapsack"
                    },
                    {
                        "username": "peida2015",
                        "content": "I use ruby.  LeetCode gives an expected answer of integer_break(100) = 2124471432.  I think this is clearly wrong because an obvious alternative 10**10 = 10,000,000,000 is greater than the expected answer."
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The idea is maximizing the number of \"3\", with the number of \"2\" should not be greater than 2 when breaking the input integer."
                    },
                    {
                        "username": "mukundsh",
                        "content": "This solution is beautifully explained for any integer by Alon Amit in this Quora Post\\nhttps://www.quora.com/Math-question-You-are-allowed-to-take-as-many-positive-whole-numbers-as-you-want-that-add-up-to-20-and-then-multiply-them-together-What-is-the-biggest-possible-result-you-can-get"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint 1</span>\nFor all x, y >1, product(x,y) ≥ sum(x,y)\n\n# <span style='color:green'>Hint 2</span>\nIt follows that it always makes sense to try to split the sum into the most components > 1 possible, as product > sum\n\n# <span style='color:green'>Hint 3</span>\n2 and 3 sum up to any number ≥ 2*, so it always makes sense to break it down into 2s and 3s. The optimal answer will be comprised of only 2s and 3s\n*(you can trivially prove this because 1 and 2 sum up to every number, and 3 is 2+1)"
                    },
                    {
                        "username": "Shivam_12_shivam",
                        "content": "can anyone tell why this is wrong \\n\\n\\nclass Solution {\\npublic:\\n\\n    int solve(int n,int pro,int sum,int o,vector<vector<int> > &dp){\\n        if(sum==o){\\n            return pro;  \\n        }\\n        if(sum>o || n==0){\\n            return 0;\\n        }\\n\\n        if(dp[n][sum]!=-1){\\n            return dp[n][sum];\\n        }\\n        int a1=0;\\n        int a3=0;\\n        if(sum+n<=o){\\n            a1=solve(n,pro*n,sum+n,o,dp);\\n        }\\n        a3=solve(n-1,pro,sum,o,dp);\\n        return dp[n][sum]=max(a1,a3);\\n\\n    }\\n    int integerBreak(int n) {\\n        vector<vector<int> > dp(n+1,vector<int>(n+1,-1));\\n        return solve(n-1,1,0,n,dp);\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1917560,
                "content": [
                    {
                        "username": "lixx2100",
                        "content": "I saw many solutions were referring to factors of 2 and 3. But why these two magic numbers? Why other factors do not work?\\nLet's study the math behind it.\\n\\nFor convenience, say **n** is sufficiently large and can be broken into any smaller real positive numbers. We now try to calculate which real number generates the largest product.\\nAssume we break **n** into **(n / x)**  **x**'s, then the product will be **x<sup>n/x</sup>**, and we want to maximize it.\\n\\nTaking its derivative gives us **n * x<sup>n/x-2</sup> * (1 - ln(x))**.\\nThe derivative is positive when **0 < x < e**, and equal to **0** when **x = e**, then becomes negative when **x > e**,\\nwhich indicates that the product increases as **x** increases, then reaches its maximum when **x = e**, then starts dropping.\\n\\nThis reveals the fact that if **n** is sufficiently large and we are allowed to break **n** into real numbers,\\nthe best idea is to break it into nearly all **e**'s.\\nOn the other hand, if **n** is sufficiently large and we can only break **n** into integers, we should choose integers that are closer to **e**.\\nThe only potential candidates are **2** and **3** since **2 < e < 3**, but we will generally prefer **3** to **2**. Why?\\n\\nOf course, one can prove it based on the formula above, but there is a more natural way shown as follows.\\n\\n**6 = 2 + 2 + 2 = 3 + 3**. But **2 * 2 * 2 < 3 * 3**.\\nTherefore, if there are three **2**'s in the decomposition, we can replace them by two **3**'s to gain a larger product.\\n\\nAll the analysis above assumes **n** is significantly large. When **n** is small (say **n <= 10**), it may contain flaws.\\nFor instance, when **n = 4**, we have **2 * 2 > 3 * 1**.\\nTo fix it, we keep breaking **n** into **3**'s until **n** gets smaller than **10**, then solve the problem by brute-force."
                    },
                    {
                        "username": "adrianliu0729",
                        "content": "Who else thinks this question is the worst one ?"
                    },
                    {
                        "username": "zflair_zpz",
                        "content": "if (n == 2 || n == 3) return (n-1);\\n   \\n   // Keep removing parts of size 3 while n is greater than 4\\n   int res = 1;\\n   while (n > 4)\\n   {\\n       n -= 3;\\n       res *= 3; // Keep multiplying 3 to res\\n   }\\n   return (n * res);"
                    },
                    {
                        "username": "jason177",
                        "content": "The stand answer is actually wrong. This is misleading.\\nFor example, take 60 as input, the maximum should be 3^20 = 3486784401. The standard answer gets a much smaller value."
                    },
                    {
                        "username": "Runtime__Terror_",
                        "content": "In question we are given constraints as n<=58. I guess 60 is overflowing"
                    },
                    {
                        "username": "Yogesh_Ghatode",
                        "content": "This happened due to overflow of integer value range."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "unbounded knapsack"
                    },
                    {
                        "username": "peida2015",
                        "content": "I use ruby.  LeetCode gives an expected answer of integer_break(100) = 2124471432.  I think this is clearly wrong because an obvious alternative 10**10 = 10,000,000,000 is greater than the expected answer."
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The idea is maximizing the number of \"3\", with the number of \"2\" should not be greater than 2 when breaking the input integer."
                    },
                    {
                        "username": "mukundsh",
                        "content": "This solution is beautifully explained for any integer by Alon Amit in this Quora Post\\nhttps://www.quora.com/Math-question-You-are-allowed-to-take-as-many-positive-whole-numbers-as-you-want-that-add-up-to-20-and-then-multiply-them-together-What-is-the-biggest-possible-result-you-can-get"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint 1</span>\nFor all x, y >1, product(x,y) ≥ sum(x,y)\n\n# <span style='color:green'>Hint 2</span>\nIt follows that it always makes sense to try to split the sum into the most components > 1 possible, as product > sum\n\n# <span style='color:green'>Hint 3</span>\n2 and 3 sum up to any number ≥ 2*, so it always makes sense to break it down into 2s and 3s. The optimal answer will be comprised of only 2s and 3s\n*(you can trivially prove this because 1 and 2 sum up to every number, and 3 is 2+1)"
                    },
                    {
                        "username": "Shivam_12_shivam",
                        "content": "can anyone tell why this is wrong \\n\\n\\nclass Solution {\\npublic:\\n\\n    int solve(int n,int pro,int sum,int o,vector<vector<int> > &dp){\\n        if(sum==o){\\n            return pro;  \\n        }\\n        if(sum>o || n==0){\\n            return 0;\\n        }\\n\\n        if(dp[n][sum]!=-1){\\n            return dp[n][sum];\\n        }\\n        int a1=0;\\n        int a3=0;\\n        if(sum+n<=o){\\n            a1=solve(n,pro*n,sum+n,o,dp);\\n        }\\n        a3=solve(n-1,pro,sum,o,dp);\\n        return dp[n][sum]=max(a1,a3);\\n\\n    }\\n    int integerBreak(int n) {\\n        vector<vector<int> > dp(n+1,vector<int>(n+1,-1));\\n        return solve(n-1,1,0,n,dp);\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1567253,
                "content": [
                    {
                        "username": "lixx2100",
                        "content": "I saw many solutions were referring to factors of 2 and 3. But why these two magic numbers? Why other factors do not work?\\nLet's study the math behind it.\\n\\nFor convenience, say **n** is sufficiently large and can be broken into any smaller real positive numbers. We now try to calculate which real number generates the largest product.\\nAssume we break **n** into **(n / x)**  **x**'s, then the product will be **x<sup>n/x</sup>**, and we want to maximize it.\\n\\nTaking its derivative gives us **n * x<sup>n/x-2</sup> * (1 - ln(x))**.\\nThe derivative is positive when **0 < x < e**, and equal to **0** when **x = e**, then becomes negative when **x > e**,\\nwhich indicates that the product increases as **x** increases, then reaches its maximum when **x = e**, then starts dropping.\\n\\nThis reveals the fact that if **n** is sufficiently large and we are allowed to break **n** into real numbers,\\nthe best idea is to break it into nearly all **e**'s.\\nOn the other hand, if **n** is sufficiently large and we can only break **n** into integers, we should choose integers that are closer to **e**.\\nThe only potential candidates are **2** and **3** since **2 < e < 3**, but we will generally prefer **3** to **2**. Why?\\n\\nOf course, one can prove it based on the formula above, but there is a more natural way shown as follows.\\n\\n**6 = 2 + 2 + 2 = 3 + 3**. But **2 * 2 * 2 < 3 * 3**.\\nTherefore, if there are three **2**'s in the decomposition, we can replace them by two **3**'s to gain a larger product.\\n\\nAll the analysis above assumes **n** is significantly large. When **n** is small (say **n <= 10**), it may contain flaws.\\nFor instance, when **n = 4**, we have **2 * 2 > 3 * 1**.\\nTo fix it, we keep breaking **n** into **3**'s until **n** gets smaller than **10**, then solve the problem by brute-force."
                    },
                    {
                        "username": "adrianliu0729",
                        "content": "Who else thinks this question is the worst one ?"
                    },
                    {
                        "username": "zflair_zpz",
                        "content": "if (n == 2 || n == 3) return (n-1);\\n   \\n   // Keep removing parts of size 3 while n is greater than 4\\n   int res = 1;\\n   while (n > 4)\\n   {\\n       n -= 3;\\n       res *= 3; // Keep multiplying 3 to res\\n   }\\n   return (n * res);"
                    },
                    {
                        "username": "jason177",
                        "content": "The stand answer is actually wrong. This is misleading.\\nFor example, take 60 as input, the maximum should be 3^20 = 3486784401. The standard answer gets a much smaller value."
                    },
                    {
                        "username": "Runtime__Terror_",
                        "content": "In question we are given constraints as n<=58. I guess 60 is overflowing"
                    },
                    {
                        "username": "Yogesh_Ghatode",
                        "content": "This happened due to overflow of integer value range."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "unbounded knapsack"
                    },
                    {
                        "username": "peida2015",
                        "content": "I use ruby.  LeetCode gives an expected answer of integer_break(100) = 2124471432.  I think this is clearly wrong because an obvious alternative 10**10 = 10,000,000,000 is greater than the expected answer."
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The idea is maximizing the number of \"3\", with the number of \"2\" should not be greater than 2 when breaking the input integer."
                    },
                    {
                        "username": "mukundsh",
                        "content": "This solution is beautifully explained for any integer by Alon Amit in this Quora Post\\nhttps://www.quora.com/Math-question-You-are-allowed-to-take-as-many-positive-whole-numbers-as-you-want-that-add-up-to-20-and-then-multiply-them-together-What-is-the-biggest-possible-result-you-can-get"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint 1</span>\nFor all x, y >1, product(x,y) ≥ sum(x,y)\n\n# <span style='color:green'>Hint 2</span>\nIt follows that it always makes sense to try to split the sum into the most components > 1 possible, as product > sum\n\n# <span style='color:green'>Hint 3</span>\n2 and 3 sum up to any number ≥ 2*, so it always makes sense to break it down into 2s and 3s. The optimal answer will be comprised of only 2s and 3s\n*(you can trivially prove this because 1 and 2 sum up to every number, and 3 is 2+1)"
                    },
                    {
                        "username": "Shivam_12_shivam",
                        "content": "can anyone tell why this is wrong \\n\\n\\nclass Solution {\\npublic:\\n\\n    int solve(int n,int pro,int sum,int o,vector<vector<int> > &dp){\\n        if(sum==o){\\n            return pro;  \\n        }\\n        if(sum>o || n==0){\\n            return 0;\\n        }\\n\\n        if(dp[n][sum]!=-1){\\n            return dp[n][sum];\\n        }\\n        int a1=0;\\n        int a3=0;\\n        if(sum+n<=o){\\n            a1=solve(n,pro*n,sum+n,o,dp);\\n        }\\n        a3=solve(n-1,pro,sum,o,dp);\\n        return dp[n][sum]=max(a1,a3);\\n\\n    }\\n    int integerBreak(int n) {\\n        vector<vector<int> > dp(n+1,vector<int>(n+1,-1));\\n        return solve(n-1,1,0,n,dp);\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1742609,
                "content": [
                    {
                        "username": "lixx2100",
                        "content": "I saw many solutions were referring to factors of 2 and 3. But why these two magic numbers? Why other factors do not work?\\nLet's study the math behind it.\\n\\nFor convenience, say **n** is sufficiently large and can be broken into any smaller real positive numbers. We now try to calculate which real number generates the largest product.\\nAssume we break **n** into **(n / x)**  **x**'s, then the product will be **x<sup>n/x</sup>**, and we want to maximize it.\\n\\nTaking its derivative gives us **n * x<sup>n/x-2</sup> * (1 - ln(x))**.\\nThe derivative is positive when **0 < x < e**, and equal to **0** when **x = e**, then becomes negative when **x > e**,\\nwhich indicates that the product increases as **x** increases, then reaches its maximum when **x = e**, then starts dropping.\\n\\nThis reveals the fact that if **n** is sufficiently large and we are allowed to break **n** into real numbers,\\nthe best idea is to break it into nearly all **e**'s.\\nOn the other hand, if **n** is sufficiently large and we can only break **n** into integers, we should choose integers that are closer to **e**.\\nThe only potential candidates are **2** and **3** since **2 < e < 3**, but we will generally prefer **3** to **2**. Why?\\n\\nOf course, one can prove it based on the formula above, but there is a more natural way shown as follows.\\n\\n**6 = 2 + 2 + 2 = 3 + 3**. But **2 * 2 * 2 < 3 * 3**.\\nTherefore, if there are three **2**'s in the decomposition, we can replace them by two **3**'s to gain a larger product.\\n\\nAll the analysis above assumes **n** is significantly large. When **n** is small (say **n <= 10**), it may contain flaws.\\nFor instance, when **n = 4**, we have **2 * 2 > 3 * 1**.\\nTo fix it, we keep breaking **n** into **3**'s until **n** gets smaller than **10**, then solve the problem by brute-force."
                    },
                    {
                        "username": "adrianliu0729",
                        "content": "Who else thinks this question is the worst one ?"
                    },
                    {
                        "username": "zflair_zpz",
                        "content": "if (n == 2 || n == 3) return (n-1);\\n   \\n   // Keep removing parts of size 3 while n is greater than 4\\n   int res = 1;\\n   while (n > 4)\\n   {\\n       n -= 3;\\n       res *= 3; // Keep multiplying 3 to res\\n   }\\n   return (n * res);"
                    },
                    {
                        "username": "jason177",
                        "content": "The stand answer is actually wrong. This is misleading.\\nFor example, take 60 as input, the maximum should be 3^20 = 3486784401. The standard answer gets a much smaller value."
                    },
                    {
                        "username": "Runtime__Terror_",
                        "content": "In question we are given constraints as n<=58. I guess 60 is overflowing"
                    },
                    {
                        "username": "Yogesh_Ghatode",
                        "content": "This happened due to overflow of integer value range."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "unbounded knapsack"
                    },
                    {
                        "username": "peida2015",
                        "content": "I use ruby.  LeetCode gives an expected answer of integer_break(100) = 2124471432.  I think this is clearly wrong because an obvious alternative 10**10 = 10,000,000,000 is greater than the expected answer."
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The idea is maximizing the number of \"3\", with the number of \"2\" should not be greater than 2 when breaking the input integer."
                    },
                    {
                        "username": "mukundsh",
                        "content": "This solution is beautifully explained for any integer by Alon Amit in this Quora Post\\nhttps://www.quora.com/Math-question-You-are-allowed-to-take-as-many-positive-whole-numbers-as-you-want-that-add-up-to-20-and-then-multiply-them-together-What-is-the-biggest-possible-result-you-can-get"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint 1</span>\nFor all x, y >1, product(x,y) ≥ sum(x,y)\n\n# <span style='color:green'>Hint 2</span>\nIt follows that it always makes sense to try to split the sum into the most components > 1 possible, as product > sum\n\n# <span style='color:green'>Hint 3</span>\n2 and 3 sum up to any number ≥ 2*, so it always makes sense to break it down into 2s and 3s. The optimal answer will be comprised of only 2s and 3s\n*(you can trivially prove this because 1 and 2 sum up to every number, and 3 is 2+1)"
                    },
                    {
                        "username": "Shivam_12_shivam",
                        "content": "can anyone tell why this is wrong \\n\\n\\nclass Solution {\\npublic:\\n\\n    int solve(int n,int pro,int sum,int o,vector<vector<int> > &dp){\\n        if(sum==o){\\n            return pro;  \\n        }\\n        if(sum>o || n==0){\\n            return 0;\\n        }\\n\\n        if(dp[n][sum]!=-1){\\n            return dp[n][sum];\\n        }\\n        int a1=0;\\n        int a3=0;\\n        if(sum+n<=o){\\n            a1=solve(n,pro*n,sum+n,o,dp);\\n        }\\n        a3=solve(n-1,pro,sum,o,dp);\\n        return dp[n][sum]=max(a1,a3);\\n\\n    }\\n    int integerBreak(int n) {\\n        vector<vector<int> > dp(n+1,vector<int>(n+1,-1));\\n        return solve(n-1,1,0,n,dp);\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1572802,
                "content": [
                    {
                        "username": "lixx2100",
                        "content": "I saw many solutions were referring to factors of 2 and 3. But why these two magic numbers? Why other factors do not work?\\nLet's study the math behind it.\\n\\nFor convenience, say **n** is sufficiently large and can be broken into any smaller real positive numbers. We now try to calculate which real number generates the largest product.\\nAssume we break **n** into **(n / x)**  **x**'s, then the product will be **x<sup>n/x</sup>**, and we want to maximize it.\\n\\nTaking its derivative gives us **n * x<sup>n/x-2</sup> * (1 - ln(x))**.\\nThe derivative is positive when **0 < x < e**, and equal to **0** when **x = e**, then becomes negative when **x > e**,\\nwhich indicates that the product increases as **x** increases, then reaches its maximum when **x = e**, then starts dropping.\\n\\nThis reveals the fact that if **n** is sufficiently large and we are allowed to break **n** into real numbers,\\nthe best idea is to break it into nearly all **e**'s.\\nOn the other hand, if **n** is sufficiently large and we can only break **n** into integers, we should choose integers that are closer to **e**.\\nThe only potential candidates are **2** and **3** since **2 < e < 3**, but we will generally prefer **3** to **2**. Why?\\n\\nOf course, one can prove it based on the formula above, but there is a more natural way shown as follows.\\n\\n**6 = 2 + 2 + 2 = 3 + 3**. But **2 * 2 * 2 < 3 * 3**.\\nTherefore, if there are three **2**'s in the decomposition, we can replace them by two **3**'s to gain a larger product.\\n\\nAll the analysis above assumes **n** is significantly large. When **n** is small (say **n <= 10**), it may contain flaws.\\nFor instance, when **n = 4**, we have **2 * 2 > 3 * 1**.\\nTo fix it, we keep breaking **n** into **3**'s until **n** gets smaller than **10**, then solve the problem by brute-force."
                    },
                    {
                        "username": "adrianliu0729",
                        "content": "Who else thinks this question is the worst one ?"
                    },
                    {
                        "username": "zflair_zpz",
                        "content": "if (n == 2 || n == 3) return (n-1);\\n   \\n   // Keep removing parts of size 3 while n is greater than 4\\n   int res = 1;\\n   while (n > 4)\\n   {\\n       n -= 3;\\n       res *= 3; // Keep multiplying 3 to res\\n   }\\n   return (n * res);"
                    },
                    {
                        "username": "jason177",
                        "content": "The stand answer is actually wrong. This is misleading.\\nFor example, take 60 as input, the maximum should be 3^20 = 3486784401. The standard answer gets a much smaller value."
                    },
                    {
                        "username": "Runtime__Terror_",
                        "content": "In question we are given constraints as n<=58. I guess 60 is overflowing"
                    },
                    {
                        "username": "Yogesh_Ghatode",
                        "content": "This happened due to overflow of integer value range."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "unbounded knapsack"
                    },
                    {
                        "username": "peida2015",
                        "content": "I use ruby.  LeetCode gives an expected answer of integer_break(100) = 2124471432.  I think this is clearly wrong because an obvious alternative 10**10 = 10,000,000,000 is greater than the expected answer."
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The idea is maximizing the number of \"3\", with the number of \"2\" should not be greater than 2 when breaking the input integer."
                    },
                    {
                        "username": "mukundsh",
                        "content": "This solution is beautifully explained for any integer by Alon Amit in this Quora Post\\nhttps://www.quora.com/Math-question-You-are-allowed-to-take-as-many-positive-whole-numbers-as-you-want-that-add-up-to-20-and-then-multiply-them-together-What-is-the-biggest-possible-result-you-can-get"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint 1</span>\nFor all x, y >1, product(x,y) ≥ sum(x,y)\n\n# <span style='color:green'>Hint 2</span>\nIt follows that it always makes sense to try to split the sum into the most components > 1 possible, as product > sum\n\n# <span style='color:green'>Hint 3</span>\n2 and 3 sum up to any number ≥ 2*, so it always makes sense to break it down into 2s and 3s. The optimal answer will be comprised of only 2s and 3s\n*(you can trivially prove this because 1 and 2 sum up to every number, and 3 is 2+1)"
                    },
                    {
                        "username": "Shivam_12_shivam",
                        "content": "can anyone tell why this is wrong \\n\\n\\nclass Solution {\\npublic:\\n\\n    int solve(int n,int pro,int sum,int o,vector<vector<int> > &dp){\\n        if(sum==o){\\n            return pro;  \\n        }\\n        if(sum>o || n==0){\\n            return 0;\\n        }\\n\\n        if(dp[n][sum]!=-1){\\n            return dp[n][sum];\\n        }\\n        int a1=0;\\n        int a3=0;\\n        if(sum+n<=o){\\n            a1=solve(n,pro*n,sum+n,o,dp);\\n        }\\n        a3=solve(n-1,pro,sum,o,dp);\\n        return dp[n][sum]=max(a1,a3);\\n\\n    }\\n    int integerBreak(int n) {\\n        vector<vector<int> > dp(n+1,vector<int>(n+1,-1));\\n        return solve(n-1,1,0,n,dp);\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1803012,
                "content": [
                    {
                        "username": "lixx2100",
                        "content": "I saw many solutions were referring to factors of 2 and 3. But why these two magic numbers? Why other factors do not work?\\nLet's study the math behind it.\\n\\nFor convenience, say **n** is sufficiently large and can be broken into any smaller real positive numbers. We now try to calculate which real number generates the largest product.\\nAssume we break **n** into **(n / x)**  **x**'s, then the product will be **x<sup>n/x</sup>**, and we want to maximize it.\\n\\nTaking its derivative gives us **n * x<sup>n/x-2</sup> * (1 - ln(x))**.\\nThe derivative is positive when **0 < x < e**, and equal to **0** when **x = e**, then becomes negative when **x > e**,\\nwhich indicates that the product increases as **x** increases, then reaches its maximum when **x = e**, then starts dropping.\\n\\nThis reveals the fact that if **n** is sufficiently large and we are allowed to break **n** into real numbers,\\nthe best idea is to break it into nearly all **e**'s.\\nOn the other hand, if **n** is sufficiently large and we can only break **n** into integers, we should choose integers that are closer to **e**.\\nThe only potential candidates are **2** and **3** since **2 < e < 3**, but we will generally prefer **3** to **2**. Why?\\n\\nOf course, one can prove it based on the formula above, but there is a more natural way shown as follows.\\n\\n**6 = 2 + 2 + 2 = 3 + 3**. But **2 * 2 * 2 < 3 * 3**.\\nTherefore, if there are three **2**'s in the decomposition, we can replace them by two **3**'s to gain a larger product.\\n\\nAll the analysis above assumes **n** is significantly large. When **n** is small (say **n <= 10**), it may contain flaws.\\nFor instance, when **n = 4**, we have **2 * 2 > 3 * 1**.\\nTo fix it, we keep breaking **n** into **3**'s until **n** gets smaller than **10**, then solve the problem by brute-force."
                    },
                    {
                        "username": "adrianliu0729",
                        "content": "Who else thinks this question is the worst one ?"
                    },
                    {
                        "username": "zflair_zpz",
                        "content": "if (n == 2 || n == 3) return (n-1);\\n   \\n   // Keep removing parts of size 3 while n is greater than 4\\n   int res = 1;\\n   while (n > 4)\\n   {\\n       n -= 3;\\n       res *= 3; // Keep multiplying 3 to res\\n   }\\n   return (n * res);"
                    },
                    {
                        "username": "jason177",
                        "content": "The stand answer is actually wrong. This is misleading.\\nFor example, take 60 as input, the maximum should be 3^20 = 3486784401. The standard answer gets a much smaller value."
                    },
                    {
                        "username": "Runtime__Terror_",
                        "content": "In question we are given constraints as n<=58. I guess 60 is overflowing"
                    },
                    {
                        "username": "Yogesh_Ghatode",
                        "content": "This happened due to overflow of integer value range."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "unbounded knapsack"
                    },
                    {
                        "username": "peida2015",
                        "content": "I use ruby.  LeetCode gives an expected answer of integer_break(100) = 2124471432.  I think this is clearly wrong because an obvious alternative 10**10 = 10,000,000,000 is greater than the expected answer."
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The idea is maximizing the number of \"3\", with the number of \"2\" should not be greater than 2 when breaking the input integer."
                    },
                    {
                        "username": "mukundsh",
                        "content": "This solution is beautifully explained for any integer by Alon Amit in this Quora Post\\nhttps://www.quora.com/Math-question-You-are-allowed-to-take-as-many-positive-whole-numbers-as-you-want-that-add-up-to-20-and-then-multiply-them-together-What-is-the-biggest-possible-result-you-can-get"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint 1</span>\nFor all x, y >1, product(x,y) ≥ sum(x,y)\n\n# <span style='color:green'>Hint 2</span>\nIt follows that it always makes sense to try to split the sum into the most components > 1 possible, as product > sum\n\n# <span style='color:green'>Hint 3</span>\n2 and 3 sum up to any number ≥ 2*, so it always makes sense to break it down into 2s and 3s. The optimal answer will be comprised of only 2s and 3s\n*(you can trivially prove this because 1 and 2 sum up to every number, and 3 is 2+1)"
                    },
                    {
                        "username": "Shivam_12_shivam",
                        "content": "can anyone tell why this is wrong \\n\\n\\nclass Solution {\\npublic:\\n\\n    int solve(int n,int pro,int sum,int o,vector<vector<int> > &dp){\\n        if(sum==o){\\n            return pro;  \\n        }\\n        if(sum>o || n==0){\\n            return 0;\\n        }\\n\\n        if(dp[n][sum]!=-1){\\n            return dp[n][sum];\\n        }\\n        int a1=0;\\n        int a3=0;\\n        if(sum+n<=o){\\n            a1=solve(n,pro*n,sum+n,o,dp);\\n        }\\n        a3=solve(n-1,pro,sum,o,dp);\\n        return dp[n][sum]=max(a1,a3);\\n\\n    }\\n    int integerBreak(int n) {\\n        vector<vector<int> > dp(n+1,vector<int>(n+1,-1));\\n        return solve(n-1,1,0,n,dp);\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 2000055,
                "content": [
                    {
                        "username": "lixx2100",
                        "content": "I saw many solutions were referring to factors of 2 and 3. But why these two magic numbers? Why other factors do not work?\\nLet's study the math behind it.\\n\\nFor convenience, say **n** is sufficiently large and can be broken into any smaller real positive numbers. We now try to calculate which real number generates the largest product.\\nAssume we break **n** into **(n / x)**  **x**'s, then the product will be **x<sup>n/x</sup>**, and we want to maximize it.\\n\\nTaking its derivative gives us **n * x<sup>n/x-2</sup> * (1 - ln(x))**.\\nThe derivative is positive when **0 < x < e**, and equal to **0** when **x = e**, then becomes negative when **x > e**,\\nwhich indicates that the product increases as **x** increases, then reaches its maximum when **x = e**, then starts dropping.\\n\\nThis reveals the fact that if **n** is sufficiently large and we are allowed to break **n** into real numbers,\\nthe best idea is to break it into nearly all **e**'s.\\nOn the other hand, if **n** is sufficiently large and we can only break **n** into integers, we should choose integers that are closer to **e**.\\nThe only potential candidates are **2** and **3** since **2 < e < 3**, but we will generally prefer **3** to **2**. Why?\\n\\nOf course, one can prove it based on the formula above, but there is a more natural way shown as follows.\\n\\n**6 = 2 + 2 + 2 = 3 + 3**. But **2 * 2 * 2 < 3 * 3**.\\nTherefore, if there are three **2**'s in the decomposition, we can replace them by two **3**'s to gain a larger product.\\n\\nAll the analysis above assumes **n** is significantly large. When **n** is small (say **n <= 10**), it may contain flaws.\\nFor instance, when **n = 4**, we have **2 * 2 > 3 * 1**.\\nTo fix it, we keep breaking **n** into **3**'s until **n** gets smaller than **10**, then solve the problem by brute-force."
                    },
                    {
                        "username": "adrianliu0729",
                        "content": "Who else thinks this question is the worst one ?"
                    },
                    {
                        "username": "zflair_zpz",
                        "content": "if (n == 2 || n == 3) return (n-1);\\n   \\n   // Keep removing parts of size 3 while n is greater than 4\\n   int res = 1;\\n   while (n > 4)\\n   {\\n       n -= 3;\\n       res *= 3; // Keep multiplying 3 to res\\n   }\\n   return (n * res);"
                    },
                    {
                        "username": "jason177",
                        "content": "The stand answer is actually wrong. This is misleading.\\nFor example, take 60 as input, the maximum should be 3^20 = 3486784401. The standard answer gets a much smaller value."
                    },
                    {
                        "username": "Runtime__Terror_",
                        "content": "In question we are given constraints as n<=58. I guess 60 is overflowing"
                    },
                    {
                        "username": "Yogesh_Ghatode",
                        "content": "This happened due to overflow of integer value range."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "unbounded knapsack"
                    },
                    {
                        "username": "peida2015",
                        "content": "I use ruby.  LeetCode gives an expected answer of integer_break(100) = 2124471432.  I think this is clearly wrong because an obvious alternative 10**10 = 10,000,000,000 is greater than the expected answer."
                    },
                    {
                        "username": "MichaelTan53",
                        "content": "The idea is maximizing the number of \"3\", with the number of \"2\" should not be greater than 2 when breaking the input integer."
                    },
                    {
                        "username": "mukundsh",
                        "content": "This solution is beautifully explained for any integer by Alon Amit in this Quora Post\\nhttps://www.quora.com/Math-question-You-are-allowed-to-take-as-many-positive-whole-numbers-as-you-want-that-add-up-to-20-and-then-multiply-them-together-What-is-the-biggest-possible-result-you-can-get"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint 1</span>\nFor all x, y >1, product(x,y) ≥ sum(x,y)\n\n# <span style='color:green'>Hint 2</span>\nIt follows that it always makes sense to try to split the sum into the most components > 1 possible, as product > sum\n\n# <span style='color:green'>Hint 3</span>\n2 and 3 sum up to any number ≥ 2*, so it always makes sense to break it down into 2s and 3s. The optimal answer will be comprised of only 2s and 3s\n*(you can trivially prove this because 1 and 2 sum up to every number, and 3 is 2+1)"
                    },
                    {
                        "username": "Shivam_12_shivam",
                        "content": "can anyone tell why this is wrong \\n\\n\\nclass Solution {\\npublic:\\n\\n    int solve(int n,int pro,int sum,int o,vector<vector<int> > &dp){\\n        if(sum==o){\\n            return pro;  \\n        }\\n        if(sum>o || n==0){\\n            return 0;\\n        }\\n\\n        if(dp[n][sum]!=-1){\\n            return dp[n][sum];\\n        }\\n        int a1=0;\\n        int a3=0;\\n        if(sum+n<=o){\\n            a1=solve(n,pro*n,sum+n,o,dp);\\n        }\\n        a3=solve(n-1,pro,sum,o,dp);\\n        return dp[n][sum]=max(a1,a3);\\n\\n    }\\n    int integerBreak(int n) {\\n        vector<vector<int> > dp(n+1,vector<int>(n+1,-1));\\n        return solve(n-1,1,0,n,dp);\\n    }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1999080,
                "content": [
                    {
                        "username": "Plasticc",
                        "content": "Given a value n, if a + b = n, with 1 <= a, b < n, the maximum product they can have is n^2 / 4 for a = b = n / 2.\\n\\nProof:\\nWLOG assume a > b and a != b. Let d = (a - b) / 2.\\nConsider the square of their mean: (a - d) * (b + d) = ab - db + ad - d^2.\\nObserve that b = a - 2d, then:\\n(a - d) * (b + d) = a(a - 2d) - d(a - 2d) + ad - d^2\\n= a^2 - 2ad - ad + 2d^2 + ad - d^2\\n= a^2 - 2ad + d^2\\n= a(a - 2d) + d^2\\n= ab + d^2\\nSince d > 0, this is strictly greater than ab. Q\\n\\nThis generalizes for sums involving more than 2 factors, the proof is left up to you, but what this means is that the largest product for any given k is always achieved by sums of numbers as close to each other as possible."
                    },
                    {
                        "username": "kk-hard-coding",
                        "content": "in dynamic programming, i dont understand why we ust compare dp[i], j*(i-j), dp[j]*dp[i-j].why we not consider dp[i]*dp[i-j]"
                    },
                    {
                        "username": "Jstark6",
                        "content": "The hints are misleading. The optimal DP solution is O(n^2). If you are here practicing algorithm question and not math, just aim for the DP solution. "
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "can anyone explain the hint given  "
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple dp pattern solution\\nhttps://leetcode.com/problems/integer-break/solutions/3573714/simple-and-best-solution-you-will-find-just-a-simple-pattern-come-out-dp-c/"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just amazing solution\\n"
                    },
                    {
                        "username": "yonggari0821",
                        "content": "Why max value made by two of num 1 is 1? Isn\\'t it 2?"
                    },
                    {
                        "username": "yonggari0821",
                        "content": "Plus, maximizing can be only operated by multiplying in this problem? Then it should be mentioned."
                    },
                    {
                        "username": "Apoorv_cha",
                        "content": "Is There any problem equivalent to classical 0/1 knapsack problem\\n"
                    },
                    {
                        "username": "BruceYG",
                        "content": "Why two factors of 2 and 3 are better? This solution is explained for this with AM\\u2013GM inequality.\\n[https://leetcode.com/problems/integer-break/solutions/3185189/c-math-solution-with-explanation-am-gm-inequality/](https://leetcode.com/problems/integer-break/solutions/3185189/c-math-solution-with-explanation-am-gm-inequality/)\\n."
                    },
                    {
                        "username": "aryan_rajjput",
                        "content": "My simple and easy Logic using giving codition ....\\nJava Easy solution.....\\n\\n\\n\\nclass Solution {\\n    public int integerBreak(int n) {\\n        if(n == 2){\\n            return 1;\\n        }\\n        if(n == 3){\\n            return 2;\\n        }\\n        int ans = 1;\\n        while(n>4){\\n            n = n-3;\\n            ans = ans*3;\\n        }\\n        return ans*n;\\n    }\\n}"
                    },
                    {
                        "username": "ryabkin",
                        "content": "Why its even marked as Dynamic Programming topic??"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "[@surYeah](/surYeah) Yeah and the solution is pretty simple. Store the max product of a number and use that, or the number itself, whichever is bigger.\n\nExample: 10 becomes 6 and 4. Get the max product of those and multiply. The max product of 6 is 9 (3x3), and 4 is 4. 9 x 4 = 36.\n\nBy luck of math you never have to delve into the issue of having three or more items to multiply. Recursing into 3x3x4 is not necessary. Makes the problem trivial.\n\nThe only trick is sometimes the product is smaller than the value. 3 for example is 2+1 and 2*1 = 2. But when doing 6 you need 3 * 3, not 2 * 2. So you need this:\nMath.Max(j, dp[j])"
                    },
                    {
                        "username": "surYeah",
                        "content": "it can be solved using DP"
                    }
                ]
            },
            {
                "id": 1995138,
                "content": [
                    {
                        "username": "Plasticc",
                        "content": "Given a value n, if a + b = n, with 1 <= a, b < n, the maximum product they can have is n^2 / 4 for a = b = n / 2.\\n\\nProof:\\nWLOG assume a > b and a != b. Let d = (a - b) / 2.\\nConsider the square of their mean: (a - d) * (b + d) = ab - db + ad - d^2.\\nObserve that b = a - 2d, then:\\n(a - d) * (b + d) = a(a - 2d) - d(a - 2d) + ad - d^2\\n= a^2 - 2ad - ad + 2d^2 + ad - d^2\\n= a^2 - 2ad + d^2\\n= a(a - 2d) + d^2\\n= ab + d^2\\nSince d > 0, this is strictly greater than ab. Q\\n\\nThis generalizes for sums involving more than 2 factors, the proof is left up to you, but what this means is that the largest product for any given k is always achieved by sums of numbers as close to each other as possible."
                    },
                    {
                        "username": "kk-hard-coding",
                        "content": "in dynamic programming, i dont understand why we ust compare dp[i], j*(i-j), dp[j]*dp[i-j].why we not consider dp[i]*dp[i-j]"
                    },
                    {
                        "username": "Jstark6",
                        "content": "The hints are misleading. The optimal DP solution is O(n^2). If you are here practicing algorithm question and not math, just aim for the DP solution. "
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "can anyone explain the hint given  "
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple dp pattern solution\\nhttps://leetcode.com/problems/integer-break/solutions/3573714/simple-and-best-solution-you-will-find-just-a-simple-pattern-come-out-dp-c/"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just amazing solution\\n"
                    },
                    {
                        "username": "yonggari0821",
                        "content": "Why max value made by two of num 1 is 1? Isn\\'t it 2?"
                    },
                    {
                        "username": "yonggari0821",
                        "content": "Plus, maximizing can be only operated by multiplying in this problem? Then it should be mentioned."
                    },
                    {
                        "username": "Apoorv_cha",
                        "content": "Is There any problem equivalent to classical 0/1 knapsack problem\\n"
                    },
                    {
                        "username": "BruceYG",
                        "content": "Why two factors of 2 and 3 are better? This solution is explained for this with AM\\u2013GM inequality.\\n[https://leetcode.com/problems/integer-break/solutions/3185189/c-math-solution-with-explanation-am-gm-inequality/](https://leetcode.com/problems/integer-break/solutions/3185189/c-math-solution-with-explanation-am-gm-inequality/)\\n."
                    },
                    {
                        "username": "aryan_rajjput",
                        "content": "My simple and easy Logic using giving codition ....\\nJava Easy solution.....\\n\\n\\n\\nclass Solution {\\n    public int integerBreak(int n) {\\n        if(n == 2){\\n            return 1;\\n        }\\n        if(n == 3){\\n            return 2;\\n        }\\n        int ans = 1;\\n        while(n>4){\\n            n = n-3;\\n            ans = ans*3;\\n        }\\n        return ans*n;\\n    }\\n}"
                    },
                    {
                        "username": "ryabkin",
                        "content": "Why its even marked as Dynamic Programming topic??"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "[@surYeah](/surYeah) Yeah and the solution is pretty simple. Store the max product of a number and use that, or the number itself, whichever is bigger.\n\nExample: 10 becomes 6 and 4. Get the max product of those and multiply. The max product of 6 is 9 (3x3), and 4 is 4. 9 x 4 = 36.\n\nBy luck of math you never have to delve into the issue of having three or more items to multiply. Recursing into 3x3x4 is not necessary. Makes the problem trivial.\n\nThe only trick is sometimes the product is smaller than the value. 3 for example is 2+1 and 2*1 = 2. But when doing 6 you need 3 * 3, not 2 * 2. So you need this:\nMath.Max(j, dp[j])"
                    },
                    {
                        "username": "surYeah",
                        "content": "it can be solved using DP"
                    }
                ]
            },
            {
                "id": 1979684,
                "content": [
                    {
                        "username": "Plasticc",
                        "content": "Given a value n, if a + b = n, with 1 <= a, b < n, the maximum product they can have is n^2 / 4 for a = b = n / 2.\\n\\nProof:\\nWLOG assume a > b and a != b. Let d = (a - b) / 2.\\nConsider the square of their mean: (a - d) * (b + d) = ab - db + ad - d^2.\\nObserve that b = a - 2d, then:\\n(a - d) * (b + d) = a(a - 2d) - d(a - 2d) + ad - d^2\\n= a^2 - 2ad - ad + 2d^2 + ad - d^2\\n= a^2 - 2ad + d^2\\n= a(a - 2d) + d^2\\n= ab + d^2\\nSince d > 0, this is strictly greater than ab. Q\\n\\nThis generalizes for sums involving more than 2 factors, the proof is left up to you, but what this means is that the largest product for any given k is always achieved by sums of numbers as close to each other as possible."
                    },
                    {
                        "username": "kk-hard-coding",
                        "content": "in dynamic programming, i dont understand why we ust compare dp[i], j*(i-j), dp[j]*dp[i-j].why we not consider dp[i]*dp[i-j]"
                    },
                    {
                        "username": "Jstark6",
                        "content": "The hints are misleading. The optimal DP solution is O(n^2). If you are here practicing algorithm question and not math, just aim for the DP solution. "
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "can anyone explain the hint given  "
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple dp pattern solution\\nhttps://leetcode.com/problems/integer-break/solutions/3573714/simple-and-best-solution-you-will-find-just-a-simple-pattern-come-out-dp-c/"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just amazing solution\\n"
                    },
                    {
                        "username": "yonggari0821",
                        "content": "Why max value made by two of num 1 is 1? Isn\\'t it 2?"
                    },
                    {
                        "username": "yonggari0821",
                        "content": "Plus, maximizing can be only operated by multiplying in this problem? Then it should be mentioned."
                    },
                    {
                        "username": "Apoorv_cha",
                        "content": "Is There any problem equivalent to classical 0/1 knapsack problem\\n"
                    },
                    {
                        "username": "BruceYG",
                        "content": "Why two factors of 2 and 3 are better? This solution is explained for this with AM\\u2013GM inequality.\\n[https://leetcode.com/problems/integer-break/solutions/3185189/c-math-solution-with-explanation-am-gm-inequality/](https://leetcode.com/problems/integer-break/solutions/3185189/c-math-solution-with-explanation-am-gm-inequality/)\\n."
                    },
                    {
                        "username": "aryan_rajjput",
                        "content": "My simple and easy Logic using giving codition ....\\nJava Easy solution.....\\n\\n\\n\\nclass Solution {\\n    public int integerBreak(int n) {\\n        if(n == 2){\\n            return 1;\\n        }\\n        if(n == 3){\\n            return 2;\\n        }\\n        int ans = 1;\\n        while(n>4){\\n            n = n-3;\\n            ans = ans*3;\\n        }\\n        return ans*n;\\n    }\\n}"
                    },
                    {
                        "username": "ryabkin",
                        "content": "Why its even marked as Dynamic Programming topic??"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "[@surYeah](/surYeah) Yeah and the solution is pretty simple. Store the max product of a number and use that, or the number itself, whichever is bigger.\n\nExample: 10 becomes 6 and 4. Get the max product of those and multiply. The max product of 6 is 9 (3x3), and 4 is 4. 9 x 4 = 36.\n\nBy luck of math you never have to delve into the issue of having three or more items to multiply. Recursing into 3x3x4 is not necessary. Makes the problem trivial.\n\nThe only trick is sometimes the product is smaller than the value. 3 for example is 2+1 and 2*1 = 2. But when doing 6 you need 3 * 3, not 2 * 2. So you need this:\nMath.Max(j, dp[j])"
                    },
                    {
                        "username": "surYeah",
                        "content": "it can be solved using DP"
                    }
                ]
            },
            {
                "id": 1934599,
                "content": [
                    {
                        "username": "Plasticc",
                        "content": "Given a value n, if a + b = n, with 1 <= a, b < n, the maximum product they can have is n^2 / 4 for a = b = n / 2.\\n\\nProof:\\nWLOG assume a > b and a != b. Let d = (a - b) / 2.\\nConsider the square of their mean: (a - d) * (b + d) = ab - db + ad - d^2.\\nObserve that b = a - 2d, then:\\n(a - d) * (b + d) = a(a - 2d) - d(a - 2d) + ad - d^2\\n= a^2 - 2ad - ad + 2d^2 + ad - d^2\\n= a^2 - 2ad + d^2\\n= a(a - 2d) + d^2\\n= ab + d^2\\nSince d > 0, this is strictly greater than ab. Q\\n\\nThis generalizes for sums involving more than 2 factors, the proof is left up to you, but what this means is that the largest product for any given k is always achieved by sums of numbers as close to each other as possible."
                    },
                    {
                        "username": "kk-hard-coding",
                        "content": "in dynamic programming, i dont understand why we ust compare dp[i], j*(i-j), dp[j]*dp[i-j].why we not consider dp[i]*dp[i-j]"
                    },
                    {
                        "username": "Jstark6",
                        "content": "The hints are misleading. The optimal DP solution is O(n^2). If you are here practicing algorithm question and not math, just aim for the DP solution. "
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "can anyone explain the hint given  "
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple dp pattern solution\\nhttps://leetcode.com/problems/integer-break/solutions/3573714/simple-and-best-solution-you-will-find-just-a-simple-pattern-come-out-dp-c/"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just amazing solution\\n"
                    },
                    {
                        "username": "yonggari0821",
                        "content": "Why max value made by two of num 1 is 1? Isn\\'t it 2?"
                    },
                    {
                        "username": "yonggari0821",
                        "content": "Plus, maximizing can be only operated by multiplying in this problem? Then it should be mentioned."
                    },
                    {
                        "username": "Apoorv_cha",
                        "content": "Is There any problem equivalent to classical 0/1 knapsack problem\\n"
                    },
                    {
                        "username": "BruceYG",
                        "content": "Why two factors of 2 and 3 are better? This solution is explained for this with AM\\u2013GM inequality.\\n[https://leetcode.com/problems/integer-break/solutions/3185189/c-math-solution-with-explanation-am-gm-inequality/](https://leetcode.com/problems/integer-break/solutions/3185189/c-math-solution-with-explanation-am-gm-inequality/)\\n."
                    },
                    {
                        "username": "aryan_rajjput",
                        "content": "My simple and easy Logic using giving codition ....\\nJava Easy solution.....\\n\\n\\n\\nclass Solution {\\n    public int integerBreak(int n) {\\n        if(n == 2){\\n            return 1;\\n        }\\n        if(n == 3){\\n            return 2;\\n        }\\n        int ans = 1;\\n        while(n>4){\\n            n = n-3;\\n            ans = ans*3;\\n        }\\n        return ans*n;\\n    }\\n}"
                    },
                    {
                        "username": "ryabkin",
                        "content": "Why its even marked as Dynamic Programming topic??"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "[@surYeah](/surYeah) Yeah and the solution is pretty simple. Store the max product of a number and use that, or the number itself, whichever is bigger.\n\nExample: 10 becomes 6 and 4. Get the max product of those and multiply. The max product of 6 is 9 (3x3), and 4 is 4. 9 x 4 = 36.\n\nBy luck of math you never have to delve into the issue of having three or more items to multiply. Recursing into 3x3x4 is not necessary. Makes the problem trivial.\n\nThe only trick is sometimes the product is smaller than the value. 3 for example is 2+1 and 2*1 = 2. But when doing 6 you need 3 * 3, not 2 * 2. So you need this:\nMath.Max(j, dp[j])"
                    },
                    {
                        "username": "surYeah",
                        "content": "it can be solved using DP"
                    }
                ]
            },
            {
                "id": 1909508,
                "content": [
                    {
                        "username": "Plasticc",
                        "content": "Given a value n, if a + b = n, with 1 <= a, b < n, the maximum product they can have is n^2 / 4 for a = b = n / 2.\\n\\nProof:\\nWLOG assume a > b and a != b. Let d = (a - b) / 2.\\nConsider the square of their mean: (a - d) * (b + d) = ab - db + ad - d^2.\\nObserve that b = a - 2d, then:\\n(a - d) * (b + d) = a(a - 2d) - d(a - 2d) + ad - d^2\\n= a^2 - 2ad - ad + 2d^2 + ad - d^2\\n= a^2 - 2ad + d^2\\n= a(a - 2d) + d^2\\n= ab + d^2\\nSince d > 0, this is strictly greater than ab. Q\\n\\nThis generalizes for sums involving more than 2 factors, the proof is left up to you, but what this means is that the largest product for any given k is always achieved by sums of numbers as close to each other as possible."
                    },
                    {
                        "username": "kk-hard-coding",
                        "content": "in dynamic programming, i dont understand why we ust compare dp[i], j*(i-j), dp[j]*dp[i-j].why we not consider dp[i]*dp[i-j]"
                    },
                    {
                        "username": "Jstark6",
                        "content": "The hints are misleading. The optimal DP solution is O(n^2). If you are here practicing algorithm question and not math, just aim for the DP solution. "
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "can anyone explain the hint given  "
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple dp pattern solution\\nhttps://leetcode.com/problems/integer-break/solutions/3573714/simple-and-best-solution-you-will-find-just-a-simple-pattern-come-out-dp-c/"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just amazing solution\\n"
                    },
                    {
                        "username": "yonggari0821",
                        "content": "Why max value made by two of num 1 is 1? Isn\\'t it 2?"
                    },
                    {
                        "username": "yonggari0821",
                        "content": "Plus, maximizing can be only operated by multiplying in this problem? Then it should be mentioned."
                    },
                    {
                        "username": "Apoorv_cha",
                        "content": "Is There any problem equivalent to classical 0/1 knapsack problem\\n"
                    },
                    {
                        "username": "BruceYG",
                        "content": "Why two factors of 2 and 3 are better? This solution is explained for this with AM\\u2013GM inequality.\\n[https://leetcode.com/problems/integer-break/solutions/3185189/c-math-solution-with-explanation-am-gm-inequality/](https://leetcode.com/problems/integer-break/solutions/3185189/c-math-solution-with-explanation-am-gm-inequality/)\\n."
                    },
                    {
                        "username": "aryan_rajjput",
                        "content": "My simple and easy Logic using giving codition ....\\nJava Easy solution.....\\n\\n\\n\\nclass Solution {\\n    public int integerBreak(int n) {\\n        if(n == 2){\\n            return 1;\\n        }\\n        if(n == 3){\\n            return 2;\\n        }\\n        int ans = 1;\\n        while(n>4){\\n            n = n-3;\\n            ans = ans*3;\\n        }\\n        return ans*n;\\n    }\\n}"
                    },
                    {
                        "username": "ryabkin",
                        "content": "Why its even marked as Dynamic Programming topic??"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "[@surYeah](/surYeah) Yeah and the solution is pretty simple. Store the max product of a number and use that, or the number itself, whichever is bigger.\n\nExample: 10 becomes 6 and 4. Get the max product of those and multiply. The max product of 6 is 9 (3x3), and 4 is 4. 9 x 4 = 36.\n\nBy luck of math you never have to delve into the issue of having three or more items to multiply. Recursing into 3x3x4 is not necessary. Makes the problem trivial.\n\nThe only trick is sometimes the product is smaller than the value. 3 for example is 2+1 and 2*1 = 2. But when doing 6 you need 3 * 3, not 2 * 2. So you need this:\nMath.Max(j, dp[j])"
                    },
                    {
                        "username": "surYeah",
                        "content": "it can be solved using DP"
                    }
                ]
            },
            {
                "id": 1898082,
                "content": [
                    {
                        "username": "Plasticc",
                        "content": "Given a value n, if a + b = n, with 1 <= a, b < n, the maximum product they can have is n^2 / 4 for a = b = n / 2.\\n\\nProof:\\nWLOG assume a > b and a != b. Let d = (a - b) / 2.\\nConsider the square of their mean: (a - d) * (b + d) = ab - db + ad - d^2.\\nObserve that b = a - 2d, then:\\n(a - d) * (b + d) = a(a - 2d) - d(a - 2d) + ad - d^2\\n= a^2 - 2ad - ad + 2d^2 + ad - d^2\\n= a^2 - 2ad + d^2\\n= a(a - 2d) + d^2\\n= ab + d^2\\nSince d > 0, this is strictly greater than ab. Q\\n\\nThis generalizes for sums involving more than 2 factors, the proof is left up to you, but what this means is that the largest product for any given k is always achieved by sums of numbers as close to each other as possible."
                    },
                    {
                        "username": "kk-hard-coding",
                        "content": "in dynamic programming, i dont understand why we ust compare dp[i], j*(i-j), dp[j]*dp[i-j].why we not consider dp[i]*dp[i-j]"
                    },
                    {
                        "username": "Jstark6",
                        "content": "The hints are misleading. The optimal DP solution is O(n^2). If you are here practicing algorithm question and not math, just aim for the DP solution. "
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "can anyone explain the hint given  "
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple dp pattern solution\\nhttps://leetcode.com/problems/integer-break/solutions/3573714/simple-and-best-solution-you-will-find-just-a-simple-pattern-come-out-dp-c/"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just amazing solution\\n"
                    },
                    {
                        "username": "yonggari0821",
                        "content": "Why max value made by two of num 1 is 1? Isn\\'t it 2?"
                    },
                    {
                        "username": "yonggari0821",
                        "content": "Plus, maximizing can be only operated by multiplying in this problem? Then it should be mentioned."
                    },
                    {
                        "username": "Apoorv_cha",
                        "content": "Is There any problem equivalent to classical 0/1 knapsack problem\\n"
                    },
                    {
                        "username": "BruceYG",
                        "content": "Why two factors of 2 and 3 are better? This solution is explained for this with AM\\u2013GM inequality.\\n[https://leetcode.com/problems/integer-break/solutions/3185189/c-math-solution-with-explanation-am-gm-inequality/](https://leetcode.com/problems/integer-break/solutions/3185189/c-math-solution-with-explanation-am-gm-inequality/)\\n."
                    },
                    {
                        "username": "aryan_rajjput",
                        "content": "My simple and easy Logic using giving codition ....\\nJava Easy solution.....\\n\\n\\n\\nclass Solution {\\n    public int integerBreak(int n) {\\n        if(n == 2){\\n            return 1;\\n        }\\n        if(n == 3){\\n            return 2;\\n        }\\n        int ans = 1;\\n        while(n>4){\\n            n = n-3;\\n            ans = ans*3;\\n        }\\n        return ans*n;\\n    }\\n}"
                    },
                    {
                        "username": "ryabkin",
                        "content": "Why its even marked as Dynamic Programming topic??"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "[@surYeah](/surYeah) Yeah and the solution is pretty simple. Store the max product of a number and use that, or the number itself, whichever is bigger.\n\nExample: 10 becomes 6 and 4. Get the max product of those and multiply. The max product of 6 is 9 (3x3), and 4 is 4. 9 x 4 = 36.\n\nBy luck of math you never have to delve into the issue of having three or more items to multiply. Recursing into 3x3x4 is not necessary. Makes the problem trivial.\n\nThe only trick is sometimes the product is smaller than the value. 3 for example is 2+1 and 2*1 = 2. But when doing 6 you need 3 * 3, not 2 * 2. So you need this:\nMath.Max(j, dp[j])"
                    },
                    {
                        "username": "surYeah",
                        "content": "it can be solved using DP"
                    }
                ]
            },
            {
                "id": 1835864,
                "content": [
                    {
                        "username": "Plasticc",
                        "content": "Given a value n, if a + b = n, with 1 <= a, b < n, the maximum product they can have is n^2 / 4 for a = b = n / 2.\\n\\nProof:\\nWLOG assume a > b and a != b. Let d = (a - b) / 2.\\nConsider the square of their mean: (a - d) * (b + d) = ab - db + ad - d^2.\\nObserve that b = a - 2d, then:\\n(a - d) * (b + d) = a(a - 2d) - d(a - 2d) + ad - d^2\\n= a^2 - 2ad - ad + 2d^2 + ad - d^2\\n= a^2 - 2ad + d^2\\n= a(a - 2d) + d^2\\n= ab + d^2\\nSince d > 0, this is strictly greater than ab. Q\\n\\nThis generalizes for sums involving more than 2 factors, the proof is left up to you, but what this means is that the largest product for any given k is always achieved by sums of numbers as close to each other as possible."
                    },
                    {
                        "username": "kk-hard-coding",
                        "content": "in dynamic programming, i dont understand why we ust compare dp[i], j*(i-j), dp[j]*dp[i-j].why we not consider dp[i]*dp[i-j]"
                    },
                    {
                        "username": "Jstark6",
                        "content": "The hints are misleading. The optimal DP solution is O(n^2). If you are here practicing algorithm question and not math, just aim for the DP solution. "
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "can anyone explain the hint given  "
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple dp pattern solution\\nhttps://leetcode.com/problems/integer-break/solutions/3573714/simple-and-best-solution-you-will-find-just-a-simple-pattern-come-out-dp-c/"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just amazing solution\\n"
                    },
                    {
                        "username": "yonggari0821",
                        "content": "Why max value made by two of num 1 is 1? Isn\\'t it 2?"
                    },
                    {
                        "username": "yonggari0821",
                        "content": "Plus, maximizing can be only operated by multiplying in this problem? Then it should be mentioned."
                    },
                    {
                        "username": "Apoorv_cha",
                        "content": "Is There any problem equivalent to classical 0/1 knapsack problem\\n"
                    },
                    {
                        "username": "BruceYG",
                        "content": "Why two factors of 2 and 3 are better? This solution is explained for this with AM\\u2013GM inequality.\\n[https://leetcode.com/problems/integer-break/solutions/3185189/c-math-solution-with-explanation-am-gm-inequality/](https://leetcode.com/problems/integer-break/solutions/3185189/c-math-solution-with-explanation-am-gm-inequality/)\\n."
                    },
                    {
                        "username": "aryan_rajjput",
                        "content": "My simple and easy Logic using giving codition ....\\nJava Easy solution.....\\n\\n\\n\\nclass Solution {\\n    public int integerBreak(int n) {\\n        if(n == 2){\\n            return 1;\\n        }\\n        if(n == 3){\\n            return 2;\\n        }\\n        int ans = 1;\\n        while(n>4){\\n            n = n-3;\\n            ans = ans*3;\\n        }\\n        return ans*n;\\n    }\\n}"
                    },
                    {
                        "username": "ryabkin",
                        "content": "Why its even marked as Dynamic Programming topic??"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "[@surYeah](/surYeah) Yeah and the solution is pretty simple. Store the max product of a number and use that, or the number itself, whichever is bigger.\n\nExample: 10 becomes 6 and 4. Get the max product of those and multiply. The max product of 6 is 9 (3x3), and 4 is 4. 9 x 4 = 36.\n\nBy luck of math you never have to delve into the issue of having three or more items to multiply. Recursing into 3x3x4 is not necessary. Makes the problem trivial.\n\nThe only trick is sometimes the product is smaller than the value. 3 for example is 2+1 and 2*1 = 2. But when doing 6 you need 3 * 3, not 2 * 2. So you need this:\nMath.Max(j, dp[j])"
                    },
                    {
                        "username": "surYeah",
                        "content": "it can be solved using DP"
                    }
                ]
            },
            {
                "id": 1801635,
                "content": [
                    {
                        "username": "Plasticc",
                        "content": "Given a value n, if a + b = n, with 1 <= a, b < n, the maximum product they can have is n^2 / 4 for a = b = n / 2.\\n\\nProof:\\nWLOG assume a > b and a != b. Let d = (a - b) / 2.\\nConsider the square of their mean: (a - d) * (b + d) = ab - db + ad - d^2.\\nObserve that b = a - 2d, then:\\n(a - d) * (b + d) = a(a - 2d) - d(a - 2d) + ad - d^2\\n= a^2 - 2ad - ad + 2d^2 + ad - d^2\\n= a^2 - 2ad + d^2\\n= a(a - 2d) + d^2\\n= ab + d^2\\nSince d > 0, this is strictly greater than ab. Q\\n\\nThis generalizes for sums involving more than 2 factors, the proof is left up to you, but what this means is that the largest product for any given k is always achieved by sums of numbers as close to each other as possible."
                    },
                    {
                        "username": "kk-hard-coding",
                        "content": "in dynamic programming, i dont understand why we ust compare dp[i], j*(i-j), dp[j]*dp[i-j].why we not consider dp[i]*dp[i-j]"
                    },
                    {
                        "username": "Jstark6",
                        "content": "The hints are misleading. The optimal DP solution is O(n^2). If you are here practicing algorithm question and not math, just aim for the DP solution. "
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "can anyone explain the hint given  "
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple dp pattern solution\\nhttps://leetcode.com/problems/integer-break/solutions/3573714/simple-and-best-solution-you-will-find-just-a-simple-pattern-come-out-dp-c/"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just amazing solution\\n"
                    },
                    {
                        "username": "yonggari0821",
                        "content": "Why max value made by two of num 1 is 1? Isn\\'t it 2?"
                    },
                    {
                        "username": "yonggari0821",
                        "content": "Plus, maximizing can be only operated by multiplying in this problem? Then it should be mentioned."
                    },
                    {
                        "username": "Apoorv_cha",
                        "content": "Is There any problem equivalent to classical 0/1 knapsack problem\\n"
                    },
                    {
                        "username": "BruceYG",
                        "content": "Why two factors of 2 and 3 are better? This solution is explained for this with AM\\u2013GM inequality.\\n[https://leetcode.com/problems/integer-break/solutions/3185189/c-math-solution-with-explanation-am-gm-inequality/](https://leetcode.com/problems/integer-break/solutions/3185189/c-math-solution-with-explanation-am-gm-inequality/)\\n."
                    },
                    {
                        "username": "aryan_rajjput",
                        "content": "My simple and easy Logic using giving codition ....\\nJava Easy solution.....\\n\\n\\n\\nclass Solution {\\n    public int integerBreak(int n) {\\n        if(n == 2){\\n            return 1;\\n        }\\n        if(n == 3){\\n            return 2;\\n        }\\n        int ans = 1;\\n        while(n>4){\\n            n = n-3;\\n            ans = ans*3;\\n        }\\n        return ans*n;\\n    }\\n}"
                    },
                    {
                        "username": "ryabkin",
                        "content": "Why its even marked as Dynamic Programming topic??"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "[@surYeah](/surYeah) Yeah and the solution is pretty simple. Store the max product of a number and use that, or the number itself, whichever is bigger.\n\nExample: 10 becomes 6 and 4. Get the max product of those and multiply. The max product of 6 is 9 (3x3), and 4 is 4. 9 x 4 = 36.\n\nBy luck of math you never have to delve into the issue of having three or more items to multiply. Recursing into 3x3x4 is not necessary. Makes the problem trivial.\n\nThe only trick is sometimes the product is smaller than the value. 3 for example is 2+1 and 2*1 = 2. But when doing 6 you need 3 * 3, not 2 * 2. So you need this:\nMath.Max(j, dp[j])"
                    },
                    {
                        "username": "surYeah",
                        "content": "it can be solved using DP"
                    }
                ]
            },
            {
                "id": 1793494,
                "content": [
                    {
                        "username": "Plasticc",
                        "content": "Given a value n, if a + b = n, with 1 <= a, b < n, the maximum product they can have is n^2 / 4 for a = b = n / 2.\\n\\nProof:\\nWLOG assume a > b and a != b. Let d = (a - b) / 2.\\nConsider the square of their mean: (a - d) * (b + d) = ab - db + ad - d^2.\\nObserve that b = a - 2d, then:\\n(a - d) * (b + d) = a(a - 2d) - d(a - 2d) + ad - d^2\\n= a^2 - 2ad - ad + 2d^2 + ad - d^2\\n= a^2 - 2ad + d^2\\n= a(a - 2d) + d^2\\n= ab + d^2\\nSince d > 0, this is strictly greater than ab. Q\\n\\nThis generalizes for sums involving more than 2 factors, the proof is left up to you, but what this means is that the largest product for any given k is always achieved by sums of numbers as close to each other as possible."
                    },
                    {
                        "username": "kk-hard-coding",
                        "content": "in dynamic programming, i dont understand why we ust compare dp[i], j*(i-j), dp[j]*dp[i-j].why we not consider dp[i]*dp[i-j]"
                    },
                    {
                        "username": "Jstark6",
                        "content": "The hints are misleading. The optimal DP solution is O(n^2). If you are here practicing algorithm question and not math, just aim for the DP solution. "
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "can anyone explain the hint given  "
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple dp pattern solution\\nhttps://leetcode.com/problems/integer-break/solutions/3573714/simple-and-best-solution-you-will-find-just-a-simple-pattern-come-out-dp-c/"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just amazing solution\\n"
                    },
                    {
                        "username": "yonggari0821",
                        "content": "Why max value made by two of num 1 is 1? Isn\\'t it 2?"
                    },
                    {
                        "username": "yonggari0821",
                        "content": "Plus, maximizing can be only operated by multiplying in this problem? Then it should be mentioned."
                    },
                    {
                        "username": "Apoorv_cha",
                        "content": "Is There any problem equivalent to classical 0/1 knapsack problem\\n"
                    },
                    {
                        "username": "BruceYG",
                        "content": "Why two factors of 2 and 3 are better? This solution is explained for this with AM\\u2013GM inequality.\\n[https://leetcode.com/problems/integer-break/solutions/3185189/c-math-solution-with-explanation-am-gm-inequality/](https://leetcode.com/problems/integer-break/solutions/3185189/c-math-solution-with-explanation-am-gm-inequality/)\\n."
                    },
                    {
                        "username": "aryan_rajjput",
                        "content": "My simple and easy Logic using giving codition ....\\nJava Easy solution.....\\n\\n\\n\\nclass Solution {\\n    public int integerBreak(int n) {\\n        if(n == 2){\\n            return 1;\\n        }\\n        if(n == 3){\\n            return 2;\\n        }\\n        int ans = 1;\\n        while(n>4){\\n            n = n-3;\\n            ans = ans*3;\\n        }\\n        return ans*n;\\n    }\\n}"
                    },
                    {
                        "username": "ryabkin",
                        "content": "Why its even marked as Dynamic Programming topic??"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "[@surYeah](/surYeah) Yeah and the solution is pretty simple. Store the max product of a number and use that, or the number itself, whichever is bigger.\n\nExample: 10 becomes 6 and 4. Get the max product of those and multiply. The max product of 6 is 9 (3x3), and 4 is 4. 9 x 4 = 36.\n\nBy luck of math you never have to delve into the issue of having three or more items to multiply. Recursing into 3x3x4 is not necessary. Makes the problem trivial.\n\nThe only trick is sometimes the product is smaller than the value. 3 for example is 2+1 and 2*1 = 2. But when doing 6 you need 3 * 3, not 2 * 2. So you need this:\nMath.Max(j, dp[j])"
                    },
                    {
                        "username": "surYeah",
                        "content": "it can be solved using DP"
                    }
                ]
            },
            {
                "id": 1700341,
                "content": [
                    {
                        "username": "Plasticc",
                        "content": "Given a value n, if a + b = n, with 1 <= a, b < n, the maximum product they can have is n^2 / 4 for a = b = n / 2.\\n\\nProof:\\nWLOG assume a > b and a != b. Let d = (a - b) / 2.\\nConsider the square of their mean: (a - d) * (b + d) = ab - db + ad - d^2.\\nObserve that b = a - 2d, then:\\n(a - d) * (b + d) = a(a - 2d) - d(a - 2d) + ad - d^2\\n= a^2 - 2ad - ad + 2d^2 + ad - d^2\\n= a^2 - 2ad + d^2\\n= a(a - 2d) + d^2\\n= ab + d^2\\nSince d > 0, this is strictly greater than ab. Q\\n\\nThis generalizes for sums involving more than 2 factors, the proof is left up to you, but what this means is that the largest product for any given k is always achieved by sums of numbers as close to each other as possible."
                    },
                    {
                        "username": "kk-hard-coding",
                        "content": "in dynamic programming, i dont understand why we ust compare dp[i], j*(i-j), dp[j]*dp[i-j].why we not consider dp[i]*dp[i-j]"
                    },
                    {
                        "username": "Jstark6",
                        "content": "The hints are misleading. The optimal DP solution is O(n^2). If you are here practicing algorithm question and not math, just aim for the DP solution. "
                    },
                    {
                        "username": "senco01ded001ag1",
                        "content": "can anyone explain the hint given  "
                    },
                    {
                        "username": "Meher6124",
                        "content": "just a simple dp pattern solution\\nhttps://leetcode.com/problems/integer-break/solutions/3573714/simple-and-best-solution-you-will-find-just-a-simple-pattern-come-out-dp-c/"
                    },
                    {
                        "username": "Meher6124",
                        "content": "just amazing solution\\n"
                    },
                    {
                        "username": "yonggari0821",
                        "content": "Why max value made by two of num 1 is 1? Isn\\'t it 2?"
                    },
                    {
                        "username": "yonggari0821",
                        "content": "Plus, maximizing can be only operated by multiplying in this problem? Then it should be mentioned."
                    },
                    {
                        "username": "Apoorv_cha",
                        "content": "Is There any problem equivalent to classical 0/1 knapsack problem\\n"
                    },
                    {
                        "username": "BruceYG",
                        "content": "Why two factors of 2 and 3 are better? This solution is explained for this with AM\\u2013GM inequality.\\n[https://leetcode.com/problems/integer-break/solutions/3185189/c-math-solution-with-explanation-am-gm-inequality/](https://leetcode.com/problems/integer-break/solutions/3185189/c-math-solution-with-explanation-am-gm-inequality/)\\n."
                    },
                    {
                        "username": "aryan_rajjput",
                        "content": "My simple and easy Logic using giving codition ....\\nJava Easy solution.....\\n\\n\\n\\nclass Solution {\\n    public int integerBreak(int n) {\\n        if(n == 2){\\n            return 1;\\n        }\\n        if(n == 3){\\n            return 2;\\n        }\\n        int ans = 1;\\n        while(n>4){\\n            n = n-3;\\n            ans = ans*3;\\n        }\\n        return ans*n;\\n    }\\n}"
                    },
                    {
                        "username": "ryabkin",
                        "content": "Why its even marked as Dynamic Programming topic??"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "[@surYeah](/surYeah) Yeah and the solution is pretty simple. Store the max product of a number and use that, or the number itself, whichever is bigger.\n\nExample: 10 becomes 6 and 4. Get the max product of those and multiply. The max product of 6 is 9 (3x3), and 4 is 4. 9 x 4 = 36.\n\nBy luck of math you never have to delve into the issue of having three or more items to multiply. Recursing into 3x3x4 is not necessary. Makes the problem trivial.\n\nThe only trick is sometimes the product is smaller than the value. 3 for example is 2+1 and 2*1 = 2. But when doing 6 you need 3 * 3, not 2 * 2. So you need this:\nMath.Max(j, dp[j])"
                    },
                    {
                        "username": "surYeah",
                        "content": "it can be solved using DP"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimize Max Distance to Gas Station",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565154,
                "content": [
                    {
                        "username": "jiazheng",
                        "content": "This is literally another reskin of the problem 410 split the largest array, just like 1231\\t\\nDivide Chocolate,1011\\tCapacity To Ship Packages Within D Days,"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\ni don\\'t think Alex Wice was born in a English native speaker country. i always have trouble of understanding his questions."
                    },
                    {
                        "username": "unordered_set",
                        "content": "[@Howard](/huowa222)How do you get to know the name of the question creator?? For me it is not visible anywhere on the screen"
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "This problem is very unclear."
                    },
                    {
                        "username": "parameterNextNaive",
                        "content": "Upvote if you found a priority queue (max heap) solution and got TLE."
                    },
                    {
                        "username": "srishti7",
                        "content": "The question does not clearly mention that it can be anywhere on the X-axis but within the bounds of the first and last stations."
                    },
                    {
                        "username": "leetcode__id",
                        "content": "But it doesn\\'t make sense to place a new gas station outside the bounds to minimize the final answer. You have to place between 2 gas stations to minimize the distance "
                    }
                ]
            },
            {
                "id": 1573601,
                "content": [
                    {
                        "username": "jiazheng",
                        "content": "This is literally another reskin of the problem 410 split the largest array, just like 1231\\t\\nDivide Chocolate,1011\\tCapacity To Ship Packages Within D Days,"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\ni don\\'t think Alex Wice was born in a English native speaker country. i always have trouble of understanding his questions."
                    },
                    {
                        "username": "unordered_set",
                        "content": "[@Howard](/huowa222)How do you get to know the name of the question creator?? For me it is not visible anywhere on the screen"
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "This problem is very unclear."
                    },
                    {
                        "username": "parameterNextNaive",
                        "content": "Upvote if you found a priority queue (max heap) solution and got TLE."
                    },
                    {
                        "username": "srishti7",
                        "content": "The question does not clearly mention that it can be anywhere on the X-axis but within the bounds of the first and last stations."
                    },
                    {
                        "username": "leetcode__id",
                        "content": "But it doesn\\'t make sense to place a new gas station outside the bounds to minimize the final answer. You have to place between 2 gas stations to minimize the distance "
                    }
                ]
            },
            {
                "id": 1825777,
                "content": [
                    {
                        "username": "jiazheng",
                        "content": "This is literally another reskin of the problem 410 split the largest array, just like 1231\\t\\nDivide Chocolate,1011\\tCapacity To Ship Packages Within D Days,"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\ni don\\'t think Alex Wice was born in a English native speaker country. i always have trouble of understanding his questions."
                    },
                    {
                        "username": "unordered_set",
                        "content": "[@Howard](/huowa222)How do you get to know the name of the question creator?? For me it is not visible anywhere on the screen"
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "This problem is very unclear."
                    },
                    {
                        "username": "parameterNextNaive",
                        "content": "Upvote if you found a priority queue (max heap) solution and got TLE."
                    },
                    {
                        "username": "srishti7",
                        "content": "The question does not clearly mention that it can be anywhere on the X-axis but within the bounds of the first and last stations."
                    },
                    {
                        "username": "leetcode__id",
                        "content": "But it doesn\\'t make sense to place a new gas station outside the bounds to minimize the final answer. You have to place between 2 gas stations to minimize the distance "
                    }
                ]
            },
            {
                "id": 1990661,
                "content": [
                    {
                        "username": "jiazheng",
                        "content": "This is literally another reskin of the problem 410 split the largest array, just like 1231\\t\\nDivide Chocolate,1011\\tCapacity To Ship Packages Within D Days,"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\ni don\\'t think Alex Wice was born in a English native speaker country. i always have trouble of understanding his questions."
                    },
                    {
                        "username": "unordered_set",
                        "content": "[@Howard](/huowa222)How do you get to know the name of the question creator?? For me it is not visible anywhere on the screen"
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "This problem is very unclear."
                    },
                    {
                        "username": "parameterNextNaive",
                        "content": "Upvote if you found a priority queue (max heap) solution and got TLE."
                    },
                    {
                        "username": "srishti7",
                        "content": "The question does not clearly mention that it can be anywhere on the X-axis but within the bounds of the first and last stations."
                    },
                    {
                        "username": "leetcode__id",
                        "content": "But it doesn\\'t make sense to place a new gas station outside the bounds to minimize the final answer. You have to place between 2 gas stations to minimize the distance "
                    }
                ]
            },
            {
                "id": 1814547,
                "content": [
                    {
                        "username": "jiazheng",
                        "content": "This is literally another reskin of the problem 410 split the largest array, just like 1231\\t\\nDivide Chocolate,1011\\tCapacity To Ship Packages Within D Days,"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\ni don\\'t think Alex Wice was born in a English native speaker country. i always have trouble of understanding his questions."
                    },
                    {
                        "username": "unordered_set",
                        "content": "[@Howard](/huowa222)How do you get to know the name of the question creator?? For me it is not visible anywhere on the screen"
                    },
                    {
                        "username": "TobiasKaufmann",
                        "content": "This problem is very unclear."
                    },
                    {
                        "username": "parameterNextNaive",
                        "content": "Upvote if you found a priority queue (max heap) solution and got TLE."
                    },
                    {
                        "username": "srishti7",
                        "content": "The question does not clearly mention that it can be anywhere on the X-axis but within the bounds of the first and last stations."
                    },
                    {
                        "username": "leetcode__id",
                        "content": "But it doesn\\'t make sense to place a new gas station outside the bounds to minimize the final answer. You have to place between 2 gas stations to minimize the distance "
                    }
                ]
            }
        ]
    }
]